<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: kdapi.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>kdapi.c</h1><a href="../../d8/d3/kdapi_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1990  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    kdapi.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    Implementation of Kernel Debugger portable remote APIs.</span>
00012 <span class="comment"></span>
00013 <span class="comment">Author:</span>
00014 <span class="comment"></span>
00015 <span class="comment">    Mark Lucovsky (markl) 31-Aug-1990</span>
00016 <span class="comment"></span>
00017 <span class="comment">Revision History:</span>
00018 <span class="comment"></span>
00019 <span class="comment">    John Vert (jvert) 28-May-1991</span>
00020 <span class="comment"></span>
00021 <span class="comment">        Added APIs for reading and writing physical memory</span>
00022 <span class="comment">        (KdpReadPhysicalMemory and KdpWritePhysicalMemory)</span>
00023 <span class="comment"></span>
00024 <span class="comment">    Wesley Witt (wesw) 18-Aug-1993</span>
00025 <span class="comment"></span>
00026 <span class="comment">        Added KdpGetVersion, KdpWriteBreakPointEx, &amp; KdpRestoreBreakPointEx</span>
00027 <span class="comment"></span>
00028 <span class="comment"></span>
00029 <span class="comment">--*/</span>
00030 
00031 <span class="preprocessor">#include "<a class="code" href="../../d0/d7/kdp_8h.html">kdp.h</a>"</span>
00032 
00033 <span class="preprocessor">#ifdef _GAMBIT_</span>
00034 <span class="preprocessor"></span><span class="preprocessor">#include "Ssc.h"</span>
00035 <span class="preprocessor">#endif // _GAMBIT_</span>
00036 <span class="preprocessor"></span>
00037 <span class="preprocessor">#if ACCASM &amp;&amp; !defined(_MSC_VER)</span>
00038 <span class="preprocessor"></span><span class="keywordtype">long</span> <span class="keyword">asm</span>(<span class="keyword">const</span> <span class="keywordtype">char</span> *,...);
00039 <span class="preprocessor">#pragma intrinsic(asm)</span>
00040 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00041 <span class="preprocessor"></span>
00042 LARGE_INTEGER <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a5">KdpQueryPerformanceCounter</a> (
00043     IN PKTRAP_FRAME TrapFrame
00044     );
00045 
<a name="l00046"></a><a class="code" href="../../d8/d3/kdapi_8c.html#a2">00046</a> <span class="keyword">extern</span> LARGE_INTEGER <a class="code" href="../../d8/d3/kdapi_8c.html#a2">Magic10000</a>;
<a name="l00047"></a><a class="code" href="../../d8/d3/kdapi_8c.html#a0">00047</a> <span class="preprocessor">#define SHIFT10000   13</span>
<a name="l00048"></a><a class="code" href="../../d8/d3/kdapi_8c.html#a1">00048</a> <span class="preprocessor"></span><span class="preprocessor">#define Convert100nsToMilliseconds(LARGE_INTEGER) (                         \</span>
00049 <span class="preprocessor">    RtlExtendedMagicDivide( (LARGE_INTEGER), Magic10000, SHIFT10000 )       \</span>
00050 <span class="preprocessor">    )</span>
00051 <span class="preprocessor"></span>
00052 <span class="comment">//</span>
00053 <span class="comment">// Define forward referenced function prototypes.</span>
00054 <span class="comment">//</span>
00055 
00056 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00057 <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a6">KdpProcessInternalBreakpoint</a> (
00058     ULONG BreakpointNumber
00059     );
00060 
00061 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00062 <a class="code" href="../../d1/d7/4_2kdp_8h.html#a107">KdQuerySpecialCalls</a> (
00063     PDBGKD_MANIPULATE_STATE m,
00064     ULONG Length,
00065     PULONG RequiredLength
00066     );
00067 
00068 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00069 <a class="code" href="../../d1/d7/4_2kdp_8h.html#a108">KdSetSpecialCall</a> (
00070     PDBGKD_MANIPULATE_STATE m,
00071     PCONTEXT ContextRecord
00072     );
00073 
00074 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00075 <a class="code" href="../../d1/d7/4_2kdp_8h.html#a109">KdClearSpecialCalls</a> (
00076     VOID
00077     );
00078 
00079 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00080 <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a7">KdpGetVersion</a>(
00081     IN PDBGKD_MANIPULATE_STATE m
00082     );
00083 
00084 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00085 <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a8">KdpNotSupported</a>(
00086     IN PDBGKD_MANIPULATE_STATE m
00087     );
00088 
00089 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00090 <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a9">KdpCauseBugCheck</a>(
00091     IN PDBGKD_MANIPULATE_STATE m
00092     );
00093 
00094 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00095 <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a10">KdpWriteBreakPointEx</a>(
00096     IN PDBGKD_MANIPULATE_STATE m,
00097     IN PSTRING AdditionalData,
00098     IN PCONTEXT Context
00099     );
00100 
00101 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00102 <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a11">KdpRestoreBreakPointEx</a>(
00103     IN PDBGKD_MANIPULATE_STATE m,
00104     IN PSTRING AdditionalData,
00105     IN PCONTEXT Context
00106     );
00107 
00108 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00109 <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a12">KdpSearchMemory</a>(
00110     IN PDBGKD_MANIPULATE_STATE m,
00111     IN PSTRING AdditionalData,
00112     IN PCONTEXT Context
00113     );
00114 
00115 <span class="preprocessor">#if i386</span>
00116 <span class="preprocessor"></span><a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00117 InternalBreakpointCheck (
00118     <a class="code" href="../../d1/d6/struct__KDPC.html">PKDPC</a> Dpc,
00119     PVOID DeferredContext,
00120     PVOID SystemArgument1,
00121     PVOID SystemArgument2
00122     );
00123 
00124 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00125 KdSetInternalBreakpoint (
00126     IN PDBGKD_MANIPULATE_STATE m
00127     );
00128 
00129 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00130 KdGetTraceInformation(
00131     PVOID SystemInformation,
00132     ULONG SystemInformationLength,
00133     PULONG ReturnLength
00134     );
00135 
00136 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00137 KdGetInternalBreakpoint(
00138     IN PDBGKD_MANIPULATE_STATE m
00139     );
00140 
00141 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00142 KdGetInternalBreakpoint(
00143     IN PDBGKD_MANIPULATE_STATE m
00144     );
00145 
00146 <span class="keywordtype">long</span>
00147 SymNumFor(
00148     ULONG_PTR pc
00149     );
00150 
00151 <span class="keywordtype">void</span> PotentialNewSymbol (ULONG_PTR pc);
00152 
00153 <span class="keywordtype">void</span> DumpTraceData(PSTRING MessageData);
00154 
00155 BOOLEAN
00156 TraceDataRecordCallInfo(
00157     ULONG InstructionsTraced,
00158     LONG CallLevelChange,
00159     ULONG_PTR pc
00160     );
00161 
00162 BOOLEAN
00163 SkippingWhichBP (
00164     PVOID thread,
00165     PULONG BPNum
00166     );
00167 
00168 BOOLEAN
00169 <a class="code" href="../../d2/d9/4_2i386_2kdtrap_8c.html#a3">KdpCheckTracePoint</a>(
00170     IN PEXCEPTION_RECORD ExceptionRecord,
00171     IN OUT PCONTEXT ContextRecord
00172     );
00173 
00174 ULONG_PTR
00175 <a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a8">KdpGetReturnAddress</a>(
00176     IN PCONTEXT ContextRecord
00177     );
00178 
00179 ULONG_PTR
00180 <a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a9">KdpGetCallNextOffset</a> (
00181     ULONG_PTR Pc,
00182     IN PCONTEXT ContextRecord
00183     );
00184 
00185 LONG
00186 <a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a5">KdpLevelChange</a> (
00187     ULONG_PTR Pc,
00188     PCONTEXT ContextRecord,
00189     IN OUT PBOOLEAN SpecialCall
00190     );
00191 
00192 <span class="preprocessor">#endif // i386</span>
00193 <span class="preprocessor"></span>
00194 <span class="preprocessor">#ifdef ALLOC_PRAGMA</span>
00195 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdEnterDebugger)</span>
00196 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdExitDebugger)</span>
00197 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpTimeSlipDpcRoutine)</span>
00198 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpTimeSlipWork)</span>
00199 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpSendWaitContinue)</span>
00200 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpReadVirtualMemory)</span>
00201 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpReadVirtualMemory64)</span>
00202 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpWriteVirtualMemory)</span>
00203 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpWriteVirtualMemory64)</span>
00204 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpGetContext)</span>
00205 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpSetContext)</span>
00206 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpWriteBreakpoint)</span>
00207 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpRestoreBreakpoint)</span>
00208 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpReportExceptionStateChange)</span>
00209 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpReportLoadSymbolsStateChange)</span>
00210 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpReadPhysicalMemory)</span>
00211 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpWritePhysicalMemory)</span>
00212 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpGetVersion)</span>
00213 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpNotSupported)</span>
00214 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpCauseBugCheck)</span>
00215 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpWriteBreakPointEx)</span>
00216 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpRestoreBreakPointEx)</span>
00217 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpSearchMemory)</span>
00218 <span class="preprocessor"></span><span class="preprocessor">#if DBG</span>
00219 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpDprintf)</span>
00220 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00221 <span class="preprocessor"></span><span class="preprocessor">#if i386</span>
00222 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, InternalBreakpointCheck)</span>
00223 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdSetInternalBreakpoint)</span>
00224 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdGetTraceInformation)</span>
00225 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdGetInternalBreakpoint)</span>
00226 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, SymNumFor)</span>
00227 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, PotentialNewSymbol)</span>
00228 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, DumpTraceData)</span>
00229 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, TraceDataRecordCallInfo)</span>
00230 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, SkippingWhichBP)</span>
00231 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdQuerySpecialCalls)</span>
00232 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdSetSpecialCall)</span>
00233 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdClearSpecialCalls)</span>
00234 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpCheckTracePoint)</span>
00235 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpProcessInternalBreakpoint)</span>
00236 <span class="preprocessor"></span><span class="preprocessor">#endif // i386</span>
00237 <span class="preprocessor"></span><span class="preprocessor">#endif // ALLOC_PRAGMA</span>
00238 <span class="preprocessor"></span>
00239 
00240 <span class="comment">//</span>
00241 <span class="comment">// This variable has a count for each time KdDisableDebugger has been called.</span>
00242 <span class="comment">//</span>
<a name="l00243"></a><a class="code" href="../../d8/d3/kdapi_8c.html#a3">00243</a> LONG <a class="code" href="../../d8/d3/kdapi_8c.html#a3">KdDisableCount</a> = 0 ;
<a name="l00244"></a><a class="code" href="../../d8/d3/kdapi_8c.html#a4">00244</a> BOOLEAN <a class="code" href="../../d8/d3/kdapi_8c.html#a4">KdPreviouslyEnabled</a> ;
00245 
00246 
00247 <span class="preprocessor">#if DBG</span>
00248 <span class="preprocessor"></span><a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00249 KdpDprintf(
00250     IN PCHAR f,
00251     ...
00252     )
00253 <span class="comment">/*++</span>
00254 <span class="comment"></span>
00255 <span class="comment">Routine Description:</span>
00256 <span class="comment"></span>
00257 <span class="comment">    Printf routine for the debugger that is safer than DbgPrint.  Calls</span>
00258 <span class="comment">    the packet driver instead of reentering the debugger.</span>
00259 <span class="comment"></span>
00260 <span class="comment">Arguments:</span>
00261 <span class="comment"></span>
00262 <span class="comment">    f - Supplies printf format</span>
00263 <span class="comment"></span>
00264 <span class="comment">Return Value:</span>
00265 <span class="comment"></span>
00266 <span class="comment">    None</span>
00267 <span class="comment"></span>
00268 <span class="comment">--*/</span>
00269 {
00270     <span class="keywordtype">char</span>    buf[100];
00271     STRING  Output;
00272     va_list mark;
00273 
00274     va_start(mark, f);
00275     _vsnprintf(buf, 100, f, mark);
00276     va_end(mark);
00277 
00278 <span class="preprocessor">#ifdef _GAMBIT_</span>
00279 <span class="preprocessor"></span><span class="comment">/*  Uncomment out to display DPRINT() output to GAMBIT console</span>
00280 <span class="comment">    if (f) {</span>
00281 <span class="comment"></span>
00282 <span class="comment">        PHYSICAL_ADDRESS pStringBuffer;</span>
00283 <span class="comment"></span>
00284 <span class="comment">        // KdpDprintf() is unsafe to use while other KD command is in progress.</span>
00285 <span class="comment">        // Send all DPRINT() output to Gambit console instead.</span>
00286 <span class="comment"></span>
00287 <span class="comment">       pStringBuffer = MmGetPhysicalAddress (&amp;buf);</span>
00288 <span class="comment">       if (pStringBuffer.QuadPart != 0ULL) {</span>
00289 <span class="comment">           SscDisplayString(pStringBuffer);</span>
00290 <span class="comment">       }</span>
00291 <span class="comment">    }</span>
00292 <span class="comment">*/</span>
00293 <span class="preprocessor">#else</span>
00294 <span class="preprocessor"></span>    Output.Buffer = buf;
00295     Output.Length = <a class="code" href="../../d2/d7/regtest_8c.html#a2">strlen</a>(Output.Buffer);
00296     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a102">KdpPrintString</a>(&amp;Output);
00297 <span class="preprocessor">#endif // _GAMBIT_</span>
00298 <span class="preprocessor"></span>}
00299 <span class="preprocessor">#endif // DBG</span>
00300 <span class="preprocessor"></span>
00301 
00302 BOOLEAN
<a name="l00303"></a><a class="code" href="../../d8/d3/kdapi_8c.html#a16">00303</a> <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a17">KdEnterDebugger</a>(
00304     IN PKTRAP_FRAME TrapFrame,
00305     IN PKEXCEPTION_FRAME ExceptionFrame
00306     )
00307 
00308 <span class="comment">/*++</span>
00309 <span class="comment"></span>
00310 <span class="comment">Routine Description:</span>
00311 <span class="comment"></span>
00312 <span class="comment">    This function is used to enter the kernel debugger. Its purpose</span>
00313 <span class="comment">    is to freeze all other processors and aqcuire the kernel debugger</span>
00314 <span class="comment">    comm port.</span>
00315 <span class="comment"></span>
00316 <span class="comment">Arguments:</span>
00317 <span class="comment"></span>
00318 <span class="comment">    TrapFrame - Supplies a pointer to a trap frame that describes the</span>
00319 <span class="comment">        trap.</span>
00320 <span class="comment"></span>
00321 <span class="comment">    ExceptionFrame - Supplies a pointer to an exception frame that</span>
00322 <span class="comment">        describes the trap.</span>
00323 <span class="comment"></span>
00324 <span class="comment">Return Value:</span>
00325 <span class="comment"></span>
00326 <span class="comment">    Returns the previous interrupt enable.</span>
00327 <span class="comment"></span>
00328 <span class="comment">--*/</span>
00329 
00330 {
00331 
00332     BOOLEAN Enable;
00333     TIME_FIELDS <a class="code" href="../../d6/d6/ttime_8c.html#a13">TimeFields</a>;
00334 <span class="preprocessor">#if DBG</span>
00335 <span class="preprocessor"></span>    <span class="keyword">extern</span> ULONG <a class="code" href="../../d5/d9/kernldat_8c.html#a43">KiFreezeFlag</a>;
00336 <span class="preprocessor">#endif</span>
00337 <span class="preprocessor"></span>
00338     <span class="comment">//</span>
00339     <span class="comment">// HACKHACK - do some crude timer support</span>
00340     <span class="comment">//            but not if called from KdSetOwedBreakpoints()</span>
00341     <span class="comment">//</span>
00342 
00343     <span class="keywordflow">if</span> (TrapFrame) {
00344         <a class="code" href="../../d8/d5/kddata_8c.html#a57">KdTimerStop</a> = <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a5">KdpQueryPerformanceCounter</a> (TrapFrame);
00345         <a class="code" href="../../d8/d5/kddata_8c.html#a58">KdTimerDifference</a>.QuadPart = <a class="code" href="../../d8/d5/kddata_8c.html#a57">KdTimerStop</a>.QuadPart - <a class="code" href="../../d8/d5/kddata_8c.html#a56">KdTimerStart</a>.QuadPart;
00346     } <span class="keywordflow">else</span> {
00347         <a class="code" href="../../d8/d5/kddata_8c.html#a57">KdTimerStop</a>.QuadPart = 0;
00348     }
00349 
00350     <span class="comment">//</span>
00351     <span class="comment">// Freeze all other processors, raise IRQL to HIGH_LEVEL, and save debug</span>
00352     <span class="comment">// port state.  We lock the port so that KdPollBreakin and a debugger</span>
00353     <span class="comment">// operation don't interfere with each other.</span>
00354     <span class="comment">//</span>
00355 
00356     Enable = <a class="code" href="../../d9/d4/ke_2debug_8c.html#a9">KeFreezeExecution</a>(TrapFrame, ExceptionFrame);
00357     <a class="code" href="../../d8/d5/kddata_8c.html#a68">KdpPortLocked</a> = <a class="code" href="../../d0/d0/ki_8h.html#a155">KiTryToAcquireSpinLock</a>(&amp;<a class="code" href="../../d4/d4/alpha_2splocks_8c.html#a9">KdpDebuggerLock</a>);
00358     <a class="code" href="../../d2/d7/hal_8h.html#a204">KdPortSave</a>();
00359     <a class="code" href="../../d8/d5/kddata_8c.html#a109">KdEnteredDebugger</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00360 
00361 <span class="preprocessor">#if DBG</span>
00362 <span class="preprocessor"></span>
00363     <span class="keywordflow">if</span> ((<a class="code" href="../../d5/d9/kernldat_8c.html#a43">KiFreezeFlag</a> &amp; <a class="code" href="../../d7/d3/kd_8h.html#a3">FREEZE_BACKUP</a>) != 0) {
00364         <a class="code" href="../../d0/d7/kdp_8h.html#a16">DPRINT</a>((<span class="stringliteral">"FreezeLock was jammed!  Backup SpinLock was used!\n"</span>));
00365     }
00366 
00367     <span class="keywordflow">if</span> ((<a class="code" href="../../d5/d9/kernldat_8c.html#a43">KiFreezeFlag</a> &amp; <a class="code" href="../../d7/d3/kd_8h.html#a4">FREEZE_SKIPPED_PROCESSOR</a>) != 0) {
00368         <a class="code" href="../../d0/d7/kdp_8h.html#a16">DPRINT</a>((<span class="stringliteral">"Some processors not frozen in debugger!\n"</span>));
00369     }
00370 
00371     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d5/kddata_8c.html#a68">KdpPortLocked</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
00372         <a class="code" href="../../d0/d7/kdp_8h.html#a16">DPRINT</a>((<span class="stringliteral">"Port lock was not acquired!\n"</span>));
00373     }
00374 
00375 <span class="preprocessor">#endif</span>
00376 <span class="preprocessor"></span>
00377     <span class="keywordflow">return</span> Enable;
00378 }
00379 
00380 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00381"></a><a class="code" href="../../d8/d3/kdapi_8c.html#a17">00381</a> <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a18">KdExitDebugger</a>(
00382     IN BOOLEAN Enable
00383     )
00384 
00385 <span class="comment">/*++</span>
00386 <span class="comment"></span>
00387 <span class="comment">Routine Description:</span>
00388 <span class="comment"></span>
00389 <span class="comment">    This function is used to exit the kernel debugger. It is the reverse</span>
00390 <span class="comment">    of KdEnterDebugger.</span>
00391 <span class="comment"></span>
00392 <span class="comment">Arguments:</span>
00393 <span class="comment"></span>
00394 <span class="comment">    Enable - Supplies the previous interrupt enable which is to be restored.</span>
00395 <span class="comment"></span>
00396 <span class="comment">Return Value:</span>
00397 <span class="comment"></span>
00398 <span class="comment">    None.</span>
00399 <span class="comment"></span>
00400 <span class="comment">--*/</span>
00401 
00402 {
00403     ULONG ElapsedTime;
00404     ULARGE_INTEGER TimeDifference;
00405     TIME_FIELDS <a class="code" href="../../d6/d6/ttime_8c.html#a13">TimeFields</a>;
00406     ULONG Pending;
00407 
00408     <span class="comment">//</span>
00409     <span class="comment">// restore stuff and exit</span>
00410     <span class="comment">//</span>
00411 
00412     <a class="code" href="../../d2/d7/hal_8h.html#a203">KdPortRestore</a>();
00413     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d5/kddata_8c.html#a68">KdpPortLocked</a>) {
00414         <a class="code" href="../../d1/d7/4_2kdp_8h.html#a146">KdpPortUnlock</a>();
00415     }
00416 
00417     <a class="code" href="../../d9/d4/ke_2debug_8c.html#a12">KeThawExecution</a>(Enable);
00418 
00419     <span class="comment">//</span>
00420     <span class="comment">// Do some crude timer support.  If KdEnterDebugger didn't</span>
00421     <span class="comment">// Query the performance counter, then don't do it here either.</span>
00422     <span class="comment">//</span>
00423 
00424     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d5/kddata_8c.html#a57">KdTimerStop</a>.QuadPart == 0) {
00425         <a class="code" href="../../d8/d5/kddata_8c.html#a56">KdTimerStart</a> = <a class="code" href="../../d8/d5/kddata_8c.html#a57">KdTimerStop</a>;
00426     } <span class="keywordflow">else</span> {
00427         <a class="code" href="../../d8/d5/kddata_8c.html#a56">KdTimerStart</a> = <a class="code" href="../../d2/d7/hal_8h.html#a205">KeQueryPerformanceCounter</a>(<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00428     }
00429 
00430     <span class="comment">//</span>
00431     <span class="comment">// Process a time slip</span>
00432     <span class="comment">//</span>
00433 
00434     <span class="keywordflow">if</span> (!<a class="code" href="../../d1/d2/po_8h.html#a55">PoHiberInProgress</a>) {
00435 
00436         Pending = InterlockedIncrement(&amp;<a class="code" href="../../d8/d5/kddata_8c.html#a103">KdpTimeSlipPending</a>);
00437 
00438         <span class="comment">//</span>
00439         <span class="comment">// If there's wasn't a time slip pending, queue the DPC to handle it</span>
00440         <span class="comment">//</span>
00441 
00442         <span class="keywordflow">if</span> (Pending == 1) {
00443             InterlockedIncrement(&amp;<a class="code" href="../../d8/d5/kddata_8c.html#a103">KdpTimeSlipPending</a>);
00444             <a class="code" href="../../d4/d1/dpcobj_8c.html#a2">KeInsertQueueDpc</a>(&amp;<a class="code" href="../../d8/d5/kddata_8c.html#a100">KdpTimeSlipDpc</a>, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00445         }
00446     }
00447 
00448     <span class="keywordflow">return</span>;
00449 }
00450 
00451 
00452 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00453"></a><a class="code" href="../../d8/d3/kdapi_8c.html#a18">00453</a> <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a19">KdUpdateTimeSlipEvent</a>(
00454     PVOID Event
00455     )
00456 
00457 <span class="comment">/*++</span>
00458 <span class="comment"></span>
00459 <span class="comment">Routine Description:</span>
00460 <span class="comment"></span>
00461 <span class="comment">    Update the reference to an event object which will be signalled when</span>
00462 <span class="comment">    the debugger has caused the system clock to skew.</span>
00463 <span class="comment"></span>
00464 <span class="comment">Arguments:</span>
00465 <span class="comment"></span>
00466 <span class="comment">    Event - Supplies a pointer to an event object</span>
00467 <span class="comment"></span>
00468 <span class="comment">Return Value:</span>
00469 <span class="comment"></span>
00470 <span class="comment">    None</span>
00471 <span class="comment"></span>
00472 <span class="comment">--*/</span>
00473 
00474 {
00475     KIRQL OldIrql;
00476 
00477     <a class="code" href="../../d4/d9/ke_8h.html#a37">KeAcquireSpinLock</a>(&amp;<a class="code" href="../../d8/d5/kddata_8c.html#a98">KdpTimeSlipEventLock</a>, &amp;OldIrql);
00478 
00479     <span class="comment">//</span>
00480     <span class="comment">// Dereference the old event and forget about it.</span>
00481     <span class="comment">// Remember the new event if there is one.</span>
00482     <span class="comment">//</span>
00483 
00484     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d5/kddata_8c.html#a99">KdpTimeSlipEvent</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00485         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>(<a class="code" href="../../d8/d5/kddata_8c.html#a99">KdpTimeSlipEvent</a>);
00486     }
00487 
00488     <a class="code" href="../../d8/d5/kddata_8c.html#a99">KdpTimeSlipEvent</a> = <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>;
00489 
00490     <a class="code" href="../../d9/d5/verifier_8c.html#a119">KeReleaseSpinLock</a>(&amp;<a class="code" href="../../d8/d5/kddata_8c.html#a98">KdpTimeSlipEventLock</a>, OldIrql);
00491 }
00492 
00493 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00494"></a><a class="code" href="../../d1/d7/4_2kdp_8h.html#a141">00494</a> <a class="code" href="../../d1/d7/4_2kdp_8h.html#a141">KdpTimeSlipDpcRoutine</a> (
00495     <a class="code" href="../../d1/d6/struct__KDPC.html">PKDPC</a> Dpc,
00496     PVOID DeferredContext,
00497     PVOID SystemArgument1,
00498     PVOID SystemArgument2
00499     )
00500 {
00501     LONG OldCount, NewCount, j;
00502 
00503     <span class="comment">//</span>
00504     <span class="comment">// Reset pending count.  If the current count is 1, then clear</span>
00505     <span class="comment">// the pending count.  if the current count is greater then 1,</span>
00506     <span class="comment">// then set to one and update the time now.</span>
00507     <span class="comment">//</span>
00508 
00509     j = <a class="code" href="../../d8/d5/kddata_8c.html#a103">KdpTimeSlipPending</a>;
00510     <span class="keywordflow">do</span> {
00511         OldCount = j;
00512         NewCount = OldCount &gt; 1 ? 1 : 0;
00513 
00514         j = InterlockedCompareExchange(&amp;<a class="code" href="../../d8/d5/kddata_8c.html#a103">KdpTimeSlipPending</a>, NewCount, OldCount);
00515 
00516     } <span class="keywordflow">while</span> (j != OldCount);
00517 
00518     <span class="comment">//</span>
00519     <span class="comment">// If new count is non-zero, then process a time slip now</span>
00520     <span class="comment">//</span>
00521 
00522     <span class="keywordflow">if</span> (NewCount) {
00523         <a class="code" href="../../d5/d8/ex_8h.html#a261">ExQueueWorkItem</a>(&amp;<a class="code" href="../../d8/d5/kddata_8c.html#a101">KdpTimeSlipWorkItem</a>, <a class="code" href="../../d5/d8/ex_8h.html#a332a206">DelayedWorkQueue</a>);
00524     }
00525 }
00526 
00527 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00528"></a><a class="code" href="../../d1/d7/4_2kdp_8h.html#a142">00528</a> <a class="code" href="../../d1/d7/4_2kdp_8h.html#a142">KdpTimeSlipWork</a> (
00529     IN PVOID Context
00530     )
00531 {
00532     KIRQL               OldIrql;
00533     LARGE_INTEGER       DueTime;
00534 
00535     <span class="comment">//</span>
00536     <span class="comment">// Update time from the real time clock</span>
00537     <span class="comment">//</span>
00538 
00539     <a class="code" href="../../d5/d8/ex_8h.html#a312">ExAcquireTimeRefreshLock</a>();
00540     <a class="code" href="../../d5/d8/ex_8h.html#a314">ExUpdateSystemTimeFromCmos</a> (<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, 0);
00541     <a class="code" href="../../d5/d8/ex_8h.html#a313">ExReleaseTimeRefreshLock</a>();
00542 
00543     <span class="comment">//</span>
00544     <span class="comment">// If there's a time service installed, signal it's time slip event</span>
00545     <span class="comment">//</span>
00546 
00547     <a class="code" href="../../d4/d9/ke_8h.html#a37">KeAcquireSpinLock</a>(&amp;<a class="code" href="../../d8/d5/kddata_8c.html#a98">KdpTimeSlipEventLock</a>, &amp;OldIrql);
00548     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d5/kddata_8c.html#a99">KdpTimeSlipEvent</a>) {
00549         <a class="code" href="../../d2/d8/eventobj_8c.html#a8">KeSetEvent</a> (<a class="code" href="../../d8/d5/kddata_8c.html#a99">KdpTimeSlipEvent</a>, 0, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
00550     }
00551     <a class="code" href="../../d9/d5/verifier_8c.html#a119">KeReleaseSpinLock</a>(&amp;<a class="code" href="../../d8/d5/kddata_8c.html#a98">KdpTimeSlipEventLock</a>, OldIrql);
00552 
00553     <span class="comment">//</span>
00554     <span class="comment">// Insert a forced delay between time slip operations</span>
00555     <span class="comment">//</span>
00556 
00557     DueTime.QuadPart = -1800000000;
00558     <a class="code" href="../../d3/d2/timerobj_8c.html#a6">KeSetTimer</a> (&amp;<a class="code" href="../../d8/d5/kddata_8c.html#a102">KdpTimeSlipTimer</a>, DueTime, &amp;<a class="code" href="../../d8/d5/kddata_8c.html#a100">KdpTimeSlipDpc</a>);
00559 }
00560 
00561 <span class="preprocessor">#if i386</span>
00562 <span class="preprocessor"></span><a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00563 InternalBreakpointCheck (
00564     <a class="code" href="../../d1/d6/struct__KDPC.html">PKDPC</a> Dpc,
00565     PVOID DeferredContext,
00566     PVOID SystemArgument1,
00567     PVOID SystemArgument2
00568     )
00569 {
00570     LARGE_INTEGER dueTime;
00571     ULONG i;
00572 
00573     UNREFERENCED_PARAMETER(Dpc);
00574     UNREFERENCED_PARAMETER(DeferredContext);
00575     UNREFERENCED_PARAMETER(SystemArgument1);
00576     UNREFERENCED_PARAMETER(SystemArgument2);
00577 
00578     dueTime.LowPart = (ULONG)(-1 * 10 * 1000 * 1000);
00579     dueTime.HighPart = -1;
00580 
00581     <a class="code" href="../../d3/d2/timerobj_8c.html#a6">KeSetTimer</a>(
00582         &amp;InternalBreakpointTimer,
00583         dueTime,
00584         &amp;InternalBreakpointCheckDpc
00585         );
00586 
00587     <span class="keywordflow">for</span> ( i = 0 ; i &lt; <a class="code" href="../../d8/d5/kddata_8c.html#a65">KdpNumInternalBreakpoints</a>; i++ ) {
00588         <span class="keywordflow">if</span> ( !(<a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[i].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o1">Flags</a> &amp; DBGKD_INTERNAL_BP_FLAG_INVALID) &amp;&amp;
00589              (<a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[i].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o1">Flags</a> &amp; DBGKD_INTERNAL_BP_FLAG_COUNTONLY) ) {
00590 
00591             <a class="code" href="../../d0/d7/kdp_8h.html#a39">PDBGKD_INTERNAL_BREAKPOINT</a> b = <a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a> + i;
00592             ULONG callsThisPeriod;
00593 
00594             callsThisPeriod = b-&gt;<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o2">Calls</a> - b-&gt;CallsLastCheck;
00595             <span class="keywordflow">if</span> ( callsThisPeriod &gt; b-&gt;MaxCallsPerPeriod ) {
00596                 b-&gt;MaxCallsPerPeriod = callsThisPeriod;
00597             }
00598             b-&gt;CallsLastCheck = b-&gt;Calls;
00599         }
00600     }
00601 
00602     <span class="keywordflow">return</span>;
00603 
00604 } <span class="comment">// InternalBreakpointCheck</span>
00605 
00606 
00607 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00608 KdSetInternalBreakpoint (
00609     IN PDBGKD_MANIPULATE_STATE m
00610     )
00611 
00612 <span class="comment">/*++</span>
00613 <span class="comment"></span>
00614 <span class="comment">Routine Description:</span>
00615 <span class="comment"></span>
00616 <span class="comment">    This function sets an internal breakpoint.  "Internal breakpoint"</span>
00617 <span class="comment">    means one in which control is not returned to the kernel debugger at</span>
00618 <span class="comment">    all, but rather just update internal counting routines and resume.</span>
00619 <span class="comment"></span>
00620 <span class="comment">Arguments:</span>
00621 <span class="comment"></span>
00622 <span class="comment">    m - Supplies the state manipulation message.</span>
00623 <span class="comment"></span>
00624 <span class="comment">Return Value:</span>
00625 <span class="comment"></span>
00626 <span class="comment">    None.</span>
00627 <span class="comment">--*/</span>
00628 
00629 {
00630     ULONG i;
00631     <a class="code" href="../../d0/d7/kdp_8h.html#a39">PDBGKD_INTERNAL_BREAKPOINT</a> bp = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00632     ULONG savedFlags;
00633 
00634     <span class="keywordflow">for</span> ( i = 0 ; i &lt; <a class="code" href="../../d8/d5/kddata_8c.html#a65">KdpNumInternalBreakpoints</a>; i++ ) {
00635         <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[i].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o0">Addr</a> ==
00636                             m-&gt;u.SetInternalBreakpoint.BreakpointAddress ) {
00637             bp = &amp;<a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[i];
00638             <span class="keywordflow">break</span>;
00639         }
00640     }
00641 
00642     <span class="keywordflow">if</span> ( !bp ) {
00643         <span class="keywordflow">for</span> ( i = 0; i &lt; <a class="code" href="../../d8/d5/kddata_8c.html#a65">KdpNumInternalBreakpoints</a>; i++ ) {
00644             <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[i].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o1">Flags</a> &amp; DBGKD_INTERNAL_BP_FLAG_INVALID ) {
00645                 bp = &amp;<a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[i];
00646                 <span class="keywordflow">break</span>;
00647             }
00648         }
00649     }
00650 
00651     <span class="keywordflow">if</span> ( !bp ) {
00652         <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d5/kddata_8c.html#a65">KdpNumInternalBreakpoints</a> &gt;= <a class="code" href="../../d0/d7/kdp_8h.html#a15">DBGKD_MAX_INTERNAL_BREAKPOINTS</a> ) {
00653             <span class="keywordflow">return</span>; <span class="comment">// no space.  Probably should report error.</span>
00654         }
00655         bp = &amp;<a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[<a class="code" href="../../d8/d5/kddata_8c.html#a65">KdpNumInternalBreakpoints</a>++];
00656         bp-&gt;<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o1">Flags</a> |= DBGKD_INTERNAL_BP_FLAG_INVALID; <span class="comment">// force initialization</span>
00657     }
00658 
00659     <span class="keywordflow">if</span> ( bp-&gt;Flags &amp; DBGKD_INTERNAL_BP_FLAG_INVALID ) {
00660         <span class="keywordflow">if</span> ( m-&gt;u.SetInternalBreakpoint.Flags &amp;
00661                                         DBGKD_INTERNAL_BP_FLAG_INVALID ) {
00662             <span class="keywordflow">return</span>; <span class="comment">// tried clearing a non-existant BP.  Ignore the request</span>
00663         }
00664         bp-&gt;Calls = bp-&gt;MaxInstructions = bp-&gt;TotalInstructions = 0;
00665         bp-&gt;CallsLastCheck = bp-&gt;MaxCallsPerPeriod = 0;
00666         bp-&gt;MinInstructions = 0xffffffff;
00667         bp-&gt;Handle = 0;
00668         bp-&gt;Thread = 0;
00669     }
00670 
00671     savedFlags = bp-&gt;Flags;
00672     bp-&gt;Flags = m-&gt;u.SetInternalBreakpoint.Flags; <span class="comment">// this could possibly invalidate the BP</span>
00673     bp-&gt;Addr = m-&gt;u.SetInternalBreakpoint.BreakpointAddress;
00674 
00675     <span class="keywordflow">if</span> ( bp-&gt;Flags &amp; (DBGKD_INTERNAL_BP_FLAG_INVALID |
00676                       DBGKD_INTERNAL_BP_FLAG_SUSPENDED) ) {
00677 
00678         <span class="keywordflow">if</span> ( (bp-&gt;Flags &amp; DBGKD_INTERNAL_BP_FLAG_INVALID) &amp;&amp;
00679              (bp-&gt;Thread != 0) ) {
00680             <span class="comment">// The breakpoint is active; defer its deletion</span>
00681             bp-&gt;Flags &amp;= ~DBGKD_INTERNAL_BP_FLAG_INVALID;
00682             bp-&gt;Flags |= DBGKD_INTERNAL_BP_FLAG_DYING;
00683         }
00684 
00685         <span class="comment">// This is really a CLEAR bp request.</span>
00686 
00687         <span class="keywordflow">if</span> ( bp-&gt;Handle != 0 ) {
00688             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a105">KdpDeleteBreakpoint</a>( bp-&gt;Handle );
00689         }
00690         bp-&gt;Handle = 0;
00691 
00692         <span class="keywordflow">return</span>;
00693     }
00694 
00695     <span class="comment">// now set the real breakpoint and remember its handle.</span>
00696 
00697     <span class="keywordflow">if</span> ( savedFlags &amp; (DBGKD_INTERNAL_BP_FLAG_INVALID |
00698                        DBGKD_INTERNAL_BP_FLAG_SUSPENDED) ) {
00699         <span class="comment">// breakpoint was invalid; activate it now</span>
00700         bp-&gt;Handle = <a class="code" href="../../d1/d7/4_2kdp_8h.html#a104">KdpAddBreakpoint</a>( (PVOID)bp-&gt;Addr );
00701     }
00702 
00703     <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d5/kddata_8c.html#a86">BreakpointsSuspended</a> ) {
00704         <a class="code" href="../../d1/d7/4_2kdp_8h.html#a138">KdpSuspendBreakpoint</a>( bp-&gt;Handle );
00705     }
00706 
00707 } <span class="comment">// KdSetInternalBreakpoint</span>
00708 
00709 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00710 KdGetTraceInformation(
00711     PVOID SystemInformation,
00712     ULONG SystemInformationLength,
00713     PULONG ReturnLength
00714     )
00715 
00716 <span class="comment">/*++</span>
00717 <span class="comment"></span>
00718 <span class="comment">Routine Description:</span>
00719 <span class="comment"></span>
00720 <span class="comment">    This function gets data about an internal breakpoint and returns it</span>
00721 <span class="comment">    in a buffer provided for it.  It is designed to be called from</span>
00722 <span class="comment">    NTQuerySystemInformation.  It is morally equivalent to GetInternalBP</span>
00723 <span class="comment">    except that it communicates locally, and returns all the breakpoints</span>
00724 <span class="comment">    at once.</span>
00725 <span class="comment"></span>
00726 <span class="comment">Arguments:</span>
00727 <span class="comment"></span>
00728 <span class="comment">    SystemInforamtion - the buffer into which to write the result.</span>
00729 <span class="comment">    SystemInformationLength - the maximum length to write</span>
00730 <span class="comment">    RetrunLength - How much data was really written</span>
00731 <span class="comment"></span>
00732 <span class="comment">Return Value:</span>
00733 <span class="comment"></span>
00734 <span class="comment">    None.</span>
00735 <span class="comment"></span>
00736 <span class="comment">--*/</span>
00737 
00738 {
00739     ULONG numEntries = 0;
00740     ULONG i = 0;
00741     PDBGKD_GET_INTERNAL_BREAKPOINT outPtr;
00742 
00743     <span class="keywordflow">for</span> ( i = 0; i &lt; <a class="code" href="../../d8/d5/kddata_8c.html#a65">KdpNumInternalBreakpoints</a>; i++ ) {
00744         <span class="keywordflow">if</span> ( !(<a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[i].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o1">Flags</a> &amp; DBGKD_INTERNAL_BP_FLAG_INVALID) ) {
00745             numEntries++;
00746         }
00747     }
00748 
00749     *ReturnLength = numEntries * <span class="keyword">sizeof</span>(DBGKD_GET_INTERNAL_BREAKPOINT);
00750     <span class="keywordflow">if</span> ( *ReturnLength &gt; SystemInformationLength ) {
00751         <span class="keywordflow">return</span> STATUS_INFO_LENGTH_MISMATCH;
00752     }
00753 
00754     <span class="comment">//</span>
00755     <span class="comment">// We've got enough space.  Copy it in.</span>
00756     <span class="comment">//</span>
00757 
00758     outPtr = (PDBGKD_GET_INTERNAL_BREAKPOINT)SystemInformation;
00759     <span class="keywordflow">for</span> ( i = 0; i &lt; <a class="code" href="../../d8/d5/kddata_8c.html#a65">KdpNumInternalBreakpoints</a>; i++ ) {
00760         <span class="keywordflow">if</span> ( !(<a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[i].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o1">Flags</a> &amp; DBGKD_INTERNAL_BP_FLAG_INVALID) ) {
00761             outPtr-&gt;BreakpointAddress = <a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[i].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o0">Addr</a>;
00762             outPtr-&gt;Flags = <a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[i].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o1">Flags</a>;
00763             outPtr-&gt;Calls = <a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[i].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o2">Calls</a>;
00764             outPtr-&gt;MaxCallsPerPeriod = <a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[i].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o4">MaxCallsPerPeriod</a>;
00765             outPtr-&gt;MinInstructions = <a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[i].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o5">MinInstructions</a>;
00766             outPtr-&gt;MaxInstructions = <a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[i].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o6">MaxInstructions</a>;
00767             outPtr-&gt;TotalInstructions = <a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[i].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o7">TotalInstructions</a>;
00768             outPtr++;
00769         }
00770     }
00771 
00772     <span class="keywordflow">return</span> STATUS_SUCCESS;
00773 
00774 } <span class="comment">// KdGetTraceInformation</span>
00775 
00776 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00777 KdGetInternalBreakpoint(
00778     IN PDBGKD_MANIPULATE_STATE m
00779     )
00780 
00781 <span class="comment">/*++</span>
00782 <span class="comment"></span>
00783 <span class="comment">Routine Description:</span>
00784 <span class="comment"></span>
00785 <span class="comment">    This function gets data about an internal breakpoint and returns it</span>
00786 <span class="comment">    to the calling debugger.</span>
00787 <span class="comment"></span>
00788 <span class="comment">Arguments:</span>
00789 <span class="comment"></span>
00790 <span class="comment">    m - Supplies the state manipulation message.</span>
00791 <span class="comment"></span>
00792 <span class="comment">Return Value:</span>
00793 <span class="comment"></span>
00794 <span class="comment">    None.</span>
00795 <span class="comment"></span>
00796 <span class="comment">--*/</span>
00797 
00798 {
00799     ULONG i;
00800     <a class="code" href="../../d0/d7/kdp_8h.html#a39">PDBGKD_INTERNAL_BREAKPOINT</a> bp = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00801     STRING messageHeader;
00802 
00803     messageHeader.Length = <span class="keyword">sizeof</span>(*m);
00804     messageHeader.Buffer = (PCHAR)m;
00805 
00806     <span class="keywordflow">for</span> ( i = 0; i &lt; <a class="code" href="../../d8/d5/kddata_8c.html#a65">KdpNumInternalBreakpoints</a>; i++ ) {
00807         <span class="keywordflow">if</span> ( !(<a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[i].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o1">Flags</a> &amp; (DBGKD_INTERNAL_BP_FLAG_INVALID |
00808                                           DBGKD_INTERNAL_BP_FLAG_SUSPENDED)) &amp;&amp;
00809              (<a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[i].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o0">Addr</a> ==
00810                         m-&gt;u.GetInternalBreakpoint.BreakpointAddress) ) {
00811             bp = &amp;<a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[i];
00812             <span class="keywordflow">break</span>;
00813         }
00814     }
00815 
00816     <span class="keywordflow">if</span> ( !bp ) {
00817         m-&gt;u.GetInternalBreakpoint.<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o1">Flags</a> = DBGKD_INTERNAL_BP_FLAG_INVALID;
00818         m-&gt;u.GetInternalBreakpoint.Calls = 0;
00819         m-&gt;u.GetInternalBreakpoint.MaxCallsPerPeriod = 0;
00820         m-&gt;u.GetInternalBreakpoint.MinInstructions = 0;
00821         m-&gt;u.GetInternalBreakpoint.MaxInstructions = 0;
00822         m-&gt;u.GetInternalBreakpoint.TotalInstructions = 0;
00823         m-&gt;ReturnStatus = STATUS_UNSUCCESSFUL;
00824     } <span class="keywordflow">else</span> {
00825         m-&gt;u.GetInternalBreakpoint.Flags = bp-&gt;Flags;
00826         m-&gt;u.GetInternalBreakpoint.Calls = bp-&gt;Calls;
00827         m-&gt;u.GetInternalBreakpoint.MaxCallsPerPeriod = bp-&gt;MaxCallsPerPeriod;
00828         m-&gt;u.GetInternalBreakpoint.MinInstructions = bp-&gt;MinInstructions;
00829         m-&gt;u.GetInternalBreakpoint.MaxInstructions = bp-&gt;MaxInstructions;
00830         m-&gt;u.GetInternalBreakpoint.TotalInstructions = bp-&gt;TotalInstructions;
00831         m-&gt;ReturnStatus = STATUS_SUCCESS;
00832     }
00833 
00834     m-&gt;ApiNumber = DbgKdGetInternalBreakPointApi;
00835 
00836     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a116">KdpSendPacket</a>(PACKET_TYPE_KD_STATE_MANIPULATE,
00837                     &amp;messageHeader,
00838                     NULL
00839                     );
00840 
00841     <span class="keywordflow">return</span>;
00842 
00843 } <span class="comment">// KdGetInternalBreakpoint</span>
00844 <span class="preprocessor">#endif // i386</span>
00845 <span class="preprocessor"></span>
00846 <a class="code" href="../../d4/d9/ke_8h.html#a408">KCONTINUE_STATUS</a>
<a name="l00847"></a><a class="code" href="../../d8/d3/kdapi_8c.html#a21">00847</a> <a class="code" href="../../d1/d7/4_2kdp_8h.html#a122">KdpSendWaitContinue</a> (
00848     IN ULONG OutPacketType,
00849     IN PSTRING OutMessageHeader,
00850     IN PSTRING OutMessageData OPTIONAL,
00851     IN OUT PCONTEXT ContextRecord
00852     )
00853 
00854 <span class="comment">/*++</span>
00855 <span class="comment"></span>
00856 <span class="comment">Routine Description:</span>
00857 <span class="comment"></span>
00858 <span class="comment">    This function sends a packet, and then waits for a continue message.</span>
00859 <span class="comment">    BreakIns received while waiting will always cause a resend of the</span>
00860 <span class="comment">    packet originally sent out.  While waiting, manipulate messages</span>
00861 <span class="comment">    will be serviced.</span>
00862 <span class="comment"></span>
00863 <span class="comment">    A resend always resends the original event sent to the debugger,</span>
00864 <span class="comment">    not the last response to some debugger command.</span>
00865 <span class="comment"></span>
00866 <span class="comment">Arguments:</span>
00867 <span class="comment"></span>
00868 <span class="comment">    OutPacketType - Supplies the type of packet to send.</span>
00869 <span class="comment"></span>
00870 <span class="comment">    OutMessageHeader - Supplies a pointer to a string descriptor that describes</span>
00871 <span class="comment">        the message information.</span>
00872 <span class="comment"></span>
00873 <span class="comment">    OutMessageData - Supplies a pointer to a string descriptor that describes</span>
00874 <span class="comment">        the optional message data.</span>
00875 <span class="comment"></span>
00876 <span class="comment">    ContextRecord - Exception context</span>
00877 <span class="comment"></span>
00878 <span class="comment">Return Value:</span>
00879 <span class="comment"></span>
00880 <span class="comment">    A value of TRUE is returned if the continue message indicates</span>
00881 <span class="comment">    success, Otherwise, a value of FALSE is returned.</span>
00882 <span class="comment"></span>
00883 <span class="comment">--*/</span>
00884 
00885 {
00886 
00887     ULONG Length;
00888     STRING MessageData;
00889     STRING MessageHeader;
00890     DBGKD_MANIPULATE_STATE ManipulateState;
00891     ULONG ReturnCode;
00892     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00893     <a class="code" href="../../d4/d9/ke_8h.html#a408">KCONTINUE_STATUS</a> ContinueStatus;
00894 
00895     <span class="comment">//</span>
00896     <span class="comment">// Loop servicing state manipulation message until a continue message</span>
00897     <span class="comment">// is received.</span>
00898     <span class="comment">//</span>
00899 
00900     MessageHeader.MaximumLength = <span class="keyword">sizeof</span>(DBGKD_MANIPULATE_STATE);
00901     MessageHeader.Buffer = (PCHAR)&amp;ManipulateState;
00902     MessageData.MaximumLength = <a class="code" href="../../d0/d7/kdp_8h.html#a14">KDP_MESSAGE_BUFFER_SIZE</a>;
00903     MessageData.Buffer = (PCHAR)<a class="code" href="../../d8/d5/kddata_8c.html#a52">KdpMessageBuffer</a>;
00904 
00905 ResendPacket:
00906 
00907     <span class="comment">//</span>
00908     <span class="comment">// Send event notification packet to debugger on host.  Come back</span>
00909     <span class="comment">// here any time we see a breakin sequence.</span>
00910     <span class="comment">//</span>
00911 
00912     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a116">KdpSendPacket</a>(
00913                   OutPacketType,
00914                   OutMessageHeader,
00915                   OutMessageData
00916                   );
00917 
00918     <span class="comment">//</span>
00919     <span class="comment">// After sending packet, if there is no response from debugger</span>
00920     <span class="comment">// AND the packet is for reporting symbol (un)load, the debugger</span>
00921     <span class="comment">// will be declared to be not present.  Note If the packet is for</span>
00922     <span class="comment">// reporting exception, the KdpSendPacket will never stop.</span>
00923     <span class="comment">//</span>
00924 
00925     <span class="keywordflow">if</span> (<a class="code" href="../../d7/d3/kd_8h.html#a12">KdDebuggerNotPresent</a>) {
00926         <span class="keywordflow">return</span> <a class="code" href="../../d4/d9/ke_8h.html#a408a227">ContinueSuccess</a>;
00927     }
00928 
00929     <span class="keywordflow">while</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
00930 
00931         <span class="comment">//</span>
00932         <span class="comment">// Wait for State Manipulate Packet without timeout.</span>
00933         <span class="comment">//</span>
00934 
00935         <span class="keywordflow">do</span> {
00936 
00937             ReturnCode = <a class="code" href="../../d1/d7/4_2kdp_8h.html#a112">KdpReceivePacket</a>(
00938                             PACKET_TYPE_KD_STATE_MANIPULATE,
00939                             &amp;MessageHeader,
00940                             &amp;MessageData,
00941                             &amp;Length
00942                             );
00943             <span class="keywordflow">if</span> (ReturnCode == (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)<a class="code" href="../../d0/d7/kdp_8h.html#a11">KDP_PACKET_RESEND</a>) {
00944                 <span class="keywordflow">goto</span> ResendPacket;
00945             }
00946         } <span class="keywordflow">while</span> (ReturnCode == <a class="code" href="../../d0/d7/kdp_8h.html#a10">KDP_PACKET_TIMEOUT</a>);
00947 
00948         <span class="comment">//</span>
00949         <span class="comment">// Switch on the return message API number.</span>
00950         <span class="comment">//</span>
00951 
00952         <span class="keywordflow">switch</span> (ManipulateState.ApiNumber) {
00953 
00954         <span class="keywordflow">case</span> DbgKdReadVirtualMemoryApi:
00955             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a123">KdpReadVirtualMemory</a>(&amp;ManipulateState,&amp;MessageData,ContextRecord);
00956             <span class="keywordflow">break</span>;
00957 
00958         <span class="keywordflow">case</span> DbgKdReadVirtualMemory64Api:
00959             <a class="code" href="../../d0/d7/kdp_8h.html#a110">KdpReadVirtualMemory64</a>(&amp;ManipulateState,&amp;MessageData,ContextRecord);
00960             <span class="keywordflow">break</span>;
00961 
00962         <span class="keywordflow">case</span> DbgKdWriteVirtualMemoryApi:
00963             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a124">KdpWriteVirtualMemory</a>(&amp;ManipulateState,&amp;MessageData,ContextRecord);
00964             <span class="keywordflow">break</span>;
00965 
00966         <span class="keywordflow">case</span> DbgKdWriteVirtualMemory64Api:
00967             <a class="code" href="../../d0/d7/kdp_8h.html#a112">KdpWriteVirtualMemory64</a>(&amp;ManipulateState,&amp;MessageData,ContextRecord);
00968             <span class="keywordflow">break</span>;
00969 
00970         <span class="keywordflow">case</span> DbgKdReadPhysicalMemoryApi:
00971             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a125">KdpReadPhysicalMemory</a>(&amp;ManipulateState,&amp;MessageData,ContextRecord);
00972             <span class="keywordflow">break</span>;
00973 
00974         <span class="keywordflow">case</span> DbgKdWritePhysicalMemoryApi:
00975             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a126">KdpWritePhysicalMemory</a>(&amp;ManipulateState,&amp;MessageData,ContextRecord);
00976             <span class="keywordflow">break</span>;
00977 
00978         <span class="keywordflow">case</span> DbgKdGetContextApi:
00979             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a128">KdpGetContext</a>(&amp;ManipulateState,&amp;MessageData,ContextRecord);
00980             <span class="keywordflow">break</span>;
00981 
00982         <span class="keywordflow">case</span> DbgKdSetContextApi:
00983             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a129">KdpSetContext</a>(&amp;ManipulateState,&amp;MessageData,ContextRecord);
00984             <span class="keywordflow">break</span>;
00985 
00986         <span class="keywordflow">case</span> DbgKdWriteBreakPointApi:
00987             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a130">KdpWriteBreakpoint</a>(&amp;ManipulateState,&amp;MessageData,ContextRecord);
00988             <span class="keywordflow">break</span>;
00989 
00990         <span class="keywordflow">case</span> DbgKdRestoreBreakPointApi:
00991             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a131">KdpRestoreBreakpoint</a>(&amp;ManipulateState,&amp;MessageData,ContextRecord);
00992             <span class="keywordflow">break</span>;
00993 
00994         <span class="keywordflow">case</span> DbgKdReadControlSpaceApi:
00995             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a132">KdpReadControlSpace</a>(&amp;ManipulateState,&amp;MessageData,ContextRecord);
00996             <span class="keywordflow">break</span>;
00997 
00998         <span class="keywordflow">case</span> DbgKdWriteControlSpaceApi:
00999             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a133">KdpWriteControlSpace</a>(&amp;ManipulateState,&amp;MessageData,ContextRecord);
01000             <span class="keywordflow">break</span>;
01001 
01002         <span class="keywordflow">case</span> DbgKdReadIoSpaceApi:
01003             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a134">KdpReadIoSpace</a>(&amp;ManipulateState,&amp;MessageData,ContextRecord);
01004             <span class="keywordflow">break</span>;
01005 
01006         <span class="keywordflow">case</span> DbgKdWriteIoSpaceApi:
01007             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a136">KdpWriteIoSpace</a>(&amp;ManipulateState,&amp;MessageData,ContextRecord);
01008             <span class="keywordflow">break</span>;
01009 
01010 <span class="preprocessor">#ifdef _ALPHA_</span>
01011 <span class="preprocessor"></span>
01012         <span class="keywordflow">case</span> DbgKdReadIoSpaceExtendedApi:
01013             <a class="code" href="../../d7/d7/4_2axp64_2kdpcpu_8h.html#a10">KdpReadIoSpaceExtended</a>(&amp;ManipulateState,&amp;MessageData,ContextRecord);
01014             <span class="keywordflow">break</span>;
01015 
01016         <span class="keywordflow">case</span> DbgKdWriteIoSpaceExtendedApi:
01017             <a class="code" href="../../d7/d7/4_2axp64_2kdpcpu_8h.html#a11">KdpWriteIoSpaceExtended</a>(&amp;ManipulateState,&amp;MessageData,ContextRecord);
01018             <span class="keywordflow">break</span>;
01019 
01020 <span class="preprocessor">#endif // _ALPHA_</span>
01021 <span class="preprocessor"></span>
01022         <span class="keywordflow">case</span> DbgKdContinueApi:
01023             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(ManipulateState.u.Continue.ContinueStatus) != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01024                 <span class="keywordflow">return</span> <a class="code" href="../../d4/d9/ke_8h.html#a408a227">ContinueSuccess</a>;
01025             } <span class="keywordflow">else</span> {
01026                 <span class="keywordflow">return</span> <a class="code" href="../../d4/d9/ke_8h.html#a408a226">ContinueError</a>;
01027             }
01028             <span class="keywordflow">break</span>;
01029 
01030         <span class="keywordflow">case</span> DbgKdContinueApi2:
01031             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(ManipulateState.u.Continue2.ContinueStatus) != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01032                 <a class="code" href="../../d1/d7/4_2kdp_8h.html#a115">KdpGetStateChange</a>(&amp;ManipulateState,ContextRecord);
01033                 <span class="keywordflow">return</span> <a class="code" href="../../d4/d9/ke_8h.html#a408a227">ContinueSuccess</a>;
01034             } <span class="keywordflow">else</span> {
01035                 <span class="keywordflow">return</span> <a class="code" href="../../d4/d9/ke_8h.html#a408a226">ContinueError</a>;
01036             }
01037             <span class="keywordflow">break</span>;
01038 
01039         <span class="keywordflow">case</span> DbgKdRebootApi:
01040             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a101">KdpReboot</a>();
01041             <span class="keywordflow">break</span>;
01042 
01043 <span class="preprocessor">#if i386</span>
01044 <span class="preprocessor"></span>        <span class="keywordflow">case</span> DbgKdReadMachineSpecificRegister:
01045             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a135">KdpReadMachineSpecificRegister</a>(&amp;ManipulateState,&amp;MessageData,ContextRecord);
01046             <span class="keywordflow">break</span>;
01047 
01048         <span class="keywordflow">case</span> DbgKdWriteMachineSpecificRegister:
01049             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a137">KdpWriteMachineSpecificRegister</a>(&amp;ManipulateState,&amp;MessageData,ContextRecord);
01050             <span class="keywordflow">break</span>;
01051 
01052         <span class="keywordflow">case</span> DbgKdSetSpecialCallApi:
01053             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a108">KdSetSpecialCall</a>(&amp;ManipulateState,ContextRecord);
01054             <span class="keywordflow">break</span>;
01055 
01056         <span class="keywordflow">case</span> DbgKdClearSpecialCallsApi:
01057             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a109">KdClearSpecialCalls</a>();
01058             <span class="keywordflow">break</span>;
01059 
01060         <span class="keywordflow">case</span> DbgKdSetInternalBreakPointApi:
01061             KdSetInternalBreakpoint(&amp;ManipulateState);
01062             <span class="keywordflow">break</span>;
01063 
01064         <span class="keywordflow">case</span> DbgKdGetInternalBreakPointApi:
01065             KdGetInternalBreakpoint(&amp;ManipulateState);
01066             <span class="keywordflow">break</span>;
01067 <span class="preprocessor">#endif</span>
01068 <span class="preprocessor"></span>
01069         <span class="keywordflow">case</span> DbgKdGetVersionApi:
01070             <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a7">KdpGetVersion</a>(&amp;ManipulateState);
01071             <span class="keywordflow">break</span>;
01072 
01073         <span class="keywordflow">case</span> DbgKdCauseBugCheckApi:
01074             <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a9">KdpCauseBugCheck</a>(&amp;ManipulateState);
01075             <span class="keywordflow">break</span>;
01076 
01077         <span class="keywordflow">case</span> DbgKdPageInApi:
01078             <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a8">KdpNotSupported</a>(&amp;ManipulateState);
01079             <span class="keywordflow">break</span>;
01080 
01081         <span class="keywordflow">case</span> DbgKdWriteBreakPointExApi:
01082             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a10">KdpWriteBreakPointEx</a>(&amp;ManipulateState,
01083                                           &amp;MessageData,
01084                                           ContextRecord);
01085             <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>) {
01086                 ManipulateState.ApiNumber = DbgKdContinueApi;
01087                 ManipulateState.u.Continue.ContinueStatus = <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01088                 <span class="keywordflow">return</span> <a class="code" href="../../d4/d9/ke_8h.html#a408a226">ContinueError</a>;
01089             }
01090             <span class="keywordflow">break</span>;
01091 
01092         <span class="keywordflow">case</span> DbgKdRestoreBreakPointExApi:
01093             <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a11">KdpRestoreBreakPointEx</a>(&amp;ManipulateState,&amp;MessageData,ContextRecord);
01094             <span class="keywordflow">break</span>;
01095 
01096         <span class="keywordflow">case</span> DbgKdSwitchProcessor:
01097             <a class="code" href="../../d2/d7/hal_8h.html#a203">KdPortRestore</a> ();
01098             ContinueStatus = <a class="code" href="../../d9/d4/ke_2debug_8c.html#a11">KeSwitchFrozenProcessor</a>(ManipulateState.Processor);
01099             <a class="code" href="../../d2/d7/hal_8h.html#a204">KdPortSave</a> ();
01100             <span class="keywordflow">return</span> ContinueStatus;
01101 
01102         <span class="keywordflow">case</span> DbgKdSearchMemoryApi:
01103             <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a12">KdpSearchMemory</a>(&amp;ManipulateState, &amp;MessageData, ContextRecord);
01104             <span class="keywordflow">break</span>;
01105 
01106             <span class="comment">//</span>
01107             <span class="comment">// Invalid message.</span>
01108             <span class="comment">//</span>
01109 
01110         <span class="keywordflow">default</span>:
01111             MessageData.Length = 0;
01112             ManipulateState.ReturnStatus = STATUS_UNSUCCESSFUL;
01113             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a116">KdpSendPacket</a>(PACKET_TYPE_KD_STATE_MANIPULATE, &amp;MessageHeader, &amp;MessageData);
01114             <span class="keywordflow">break</span>;
01115         }
01116 
01117 <span class="preprocessor">#ifdef _ALPHA_</span>
01118 <span class="preprocessor"></span>
01119         <span class="comment">//</span>
01120         <span class="comment">//jnfix</span>
01121         <span class="comment">// this is embarrasing, we have an icache coherency problem that</span>
01122         <span class="comment">// the following imb fixes, later we must track this down to the</span>
01123         <span class="comment">// exact offending API but for now this statement allows the stub</span>
01124         <span class="comment">// work to appropriately for Alpha.</span>
01125         <span class="comment">//</span>
01126 
01127 <span class="preprocessor">#if defined(_MSC_VER)</span>
01128 <span class="preprocessor"></span>        __PAL_IMB();
01129 <span class="preprocessor">#else</span>
01130 <span class="preprocessor"></span>        <span class="keyword">asm</span>( <span class="stringliteral">"call_pal 0x86"</span> );   <span class="comment">// x86 = imb</span>
01131 <span class="preprocessor">#endif</span>
01132 <span class="preprocessor"></span>
01133 <span class="preprocessor">#endif</span>
01134 <span class="preprocessor"></span>
01135     }
01136 }
01137 
01138 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01139"></a><a class="code" href="../../d0/d7/kdp_8h.html#a109">01139</a> <a class="code" href="../../d1/d7/4_2kdp_8h.html#a123">KdpReadVirtualMemory</a>(
01140     IN PDBGKD_MANIPULATE_STATE m,
01141     IN PSTRING AdditionalData,
01142     IN PCONTEXT Context
01143     )
01144 
01145 <span class="comment">/*++</span>
01146 <span class="comment"></span>
01147 <span class="comment">Routine Description:</span>
01148 <span class="comment"></span>
01149 <span class="comment">    This function is called in response to a read virtual memory 32-bit</span>
01150 <span class="comment">    state manipulation message. Its function is to read virtual memory</span>
01151 <span class="comment">    and return.</span>
01152 <span class="comment"></span>
01153 <span class="comment">Arguments:</span>
01154 <span class="comment"></span>
01155 <span class="comment">    m - Supplies a pointer to the state manipulation message.</span>
01156 <span class="comment"></span>
01157 <span class="comment">    AdditionalData - Supplies a pointer to a descriptor for the data to read.</span>
01158 <span class="comment"></span>
01159 <span class="comment">    Context - Supplies a pointer to the current context.</span>
01160 <span class="comment"></span>
01161 <span class="comment">Return Value:</span>
01162 <span class="comment"></span>
01163 <span class="comment">    None.</span>
01164 <span class="comment"></span>
01165 <span class="comment">--*/</span>
01166 
01167 {
01168 
01169     ULONG Length;
01170     STRING MessageHeader;
01171 
01172     <span class="comment">//</span>
01173     <span class="comment">// Trim the transfer count to fit in a single message.</span>
01174     <span class="comment">//</span>
01175 
01176     Length = m-&gt;u.ReadMemory.TransferCount;
01177     <span class="keywordflow">if</span> (Length &gt; (PACKET_MAX_SIZE - <span class="keyword">sizeof</span>(DBGKD_MANIPULATE_STATE))) {
01178         Length = PACKET_MAX_SIZE - <span class="keyword">sizeof</span>(DBGKD_MANIPULATE_STATE);
01179     }
01180 
01181     <span class="comment">//</span>
01182     <span class="comment">// Move the data to the destination buffer.</span>
01183     <span class="comment">//</span>
01184 
01185     AdditionalData-&gt;Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)<a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>(AdditionalData-&gt;Buffer,
01186                                                    m-&gt;u.ReadMemory.TargetBaseAddress,
01187                                                    Length);
01188 
01189     <span class="comment">//</span>
01190     <span class="comment">// If all the data is read, then return a success status. Otherwise,</span>
01191     <span class="comment">// return unsuccessful.</span>
01192     <span class="comment">//</span>
01193 
01194     m-&gt;ReturnStatus = STATUS_SUCCESS;
01195     <span class="keywordflow">if</span> (Length != AdditionalData-&gt;Length) {
01196         m-&gt;ReturnStatus = STATUS_UNSUCCESSFUL;
01197     }
01198 
01199     <span class="comment">//</span>
01200     <span class="comment">// Set the actual number of bytes read, initialize the message header,</span>
01201     <span class="comment">// and send the reply packet to the host debugger.</span>
01202     <span class="comment">//</span>
01203 
01204     m-&gt;u.ReadMemory.ActualBytesRead = AdditionalData-&gt;Length;
01205     MessageHeader.Length = <span class="keyword">sizeof</span>(DBGKD_MANIPULATE_STATE);
01206     MessageHeader.Buffer = (PCHAR)m;
01207     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a116">KdpSendPacket</a>(PACKET_TYPE_KD_STATE_MANIPULATE,
01208                   &amp;MessageHeader,
01209                   AdditionalData);
01210 
01211     <span class="keywordflow">return</span>;
01212 }
01213 
01214 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01215"></a><a class="code" href="../../d0/d7/kdp_8h.html#a110">01215</a> <a class="code" href="../../d0/d7/kdp_8h.html#a110">KdpReadVirtualMemory64</a>(
01216     IN PDBGKD_MANIPULATE_STATE m,
01217     IN PSTRING AdditionalData,
01218     IN PCONTEXT Context
01219     )
01220 
01221 <span class="comment">/*++</span>
01222 <span class="comment"></span>
01223 <span class="comment">Routine Description:</span>
01224 <span class="comment"></span>
01225 <span class="comment">    This function is called in response of a read virtual memory 64-bit</span>
01226 <span class="comment">    state manipulation message. Its function is to read virtual memory</span>
01227 <span class="comment">    and return.</span>
01228 <span class="comment"></span>
01229 <span class="comment">Arguments:</span>
01230 <span class="comment"></span>
01231 <span class="comment">    m - Supplies a pointer to a state manipulation message.</span>
01232 <span class="comment"></span>
01233 <span class="comment">    AdditionalData - Supplies a pointer to descriptor for the data to read.</span>
01234 <span class="comment"></span>
01235 <span class="comment">    Context - Supplies a pointer to the current context.</span>
01236 <span class="comment"></span>
01237 <span class="comment">Return Value:</span>
01238 <span class="comment"></span>
01239 <span class="comment">    None.</span>
01240 <span class="comment"></span>
01241 <span class="comment">--*/</span>
01242 
01243 {
01244 
01245     UCHAR * POINTER_64 Address;
01246     PUCHAR Destination;
01247     ULONG Length;
01248     STRING MessageHeader;
01249     UCHAR * POINTER_64 Source;
01250 
01251     <span class="comment">//</span>
01252     <span class="comment">// Trim the transfer count to fit in a single message.</span>
01253     <span class="comment">//</span>
01254 
01255     Length = m-&gt;u.ReadMemory64.TransferCount;
01256     <span class="keywordflow">if</span> (Length &gt; (PACKET_MAX_SIZE - <span class="keyword">sizeof</span>(DBGKD_MANIPULATE_STATE))) {
01257         Length = PACKET_MAX_SIZE - <span class="keyword">sizeof</span>(DBGKD_MANIPULATE_STATE);
01258     }
01259 
01260     <span class="comment">//</span>
01261     <span class="comment">// Move the data to the destination buffer.</span>
01262     <span class="comment">//</span>
01263 
01264     AdditionalData-&gt;Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)Length;
01265 
01266 <span class="preprocessor">#if defined(_MIPS_) || defined(_ALPHA_)</span>
01267 <span class="preprocessor"></span>
01268     Destination = AdditionalData-&gt;Buffer;
01269     Source = (UCHAR * POINTER_64)m-&gt;u.ReadMemory64.TargetBaseAddress;
01270     <span class="keywordflow">while</span> (Length &gt; 0) {
01271         <span class="keywordflow">if</span> ((Address = <a class="code" href="../../d4/d6/ppc_2debugsup_8c.html#a2">MmDbgReadCheck64</a>(Source)) == NULL64) {
01272             <span class="keywordflow">break</span>;
01273         }
01274 
01275         *Destination++ = *Address;
01276         Source += 1;
01277         Length -= 1;
01278     }
01279 
01280 <span class="preprocessor">#endif</span>
01281 <span class="preprocessor"></span>
01282     <span class="comment">//</span>
01283     <span class="comment">// If all the data is read, then return a success status. Otherwise,</span>
01284     <span class="comment">// return an unsuccessful status.</span>
01285     <span class="comment">//</span>
01286 
01287     m-&gt;ReturnStatus = STATUS_SUCCESS;
01288     <span class="keywordflow">if</span> (Length != 0) {
01289         m-&gt;ReturnStatus = STATUS_UNSUCCESSFUL;
01290     }
01291 
01292     <span class="comment">//</span>
01293     <span class="comment">// Set the actual number of bytes read, initialize the message header,</span>
01294     <span class="comment">// and send the reply packet to the host debugger.</span>
01295     <span class="comment">//</span>
01296 
01297     m-&gt;u.ReadMemory64.ActualBytesRead = AdditionalData-&gt;Length - Length;
01298     MessageHeader.Length = <span class="keyword">sizeof</span>(DBGKD_MANIPULATE_STATE);
01299     MessageHeader.Buffer = (PCHAR)m;
01300     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a116">KdpSendPacket</a>(PACKET_TYPE_KD_STATE_MANIPULATE,
01301                   &amp;MessageHeader,
01302                   AdditionalData);
01303 
01304     <span class="keywordflow">return</span>;
01305 }
01306 
01307 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01308"></a><a class="code" href="../../d0/d7/kdp_8h.html#a111">01308</a> <a class="code" href="../../d1/d7/4_2kdp_8h.html#a124">KdpWriteVirtualMemory</a>(
01309     IN PDBGKD_MANIPULATE_STATE m,
01310     IN PSTRING AdditionalData,
01311     IN PCONTEXT Context
01312     )
01313 
01314 <span class="comment">/*++</span>
01315 <span class="comment"></span>
01316 <span class="comment">Routine Description:</span>
01317 <span class="comment"></span>
01318 <span class="comment">    This function is called in response of a write virtual memory 32-bit</span>
01319 <span class="comment">    state manipulation message. Its function is to write virtual memory</span>
01320 <span class="comment">    and return.</span>
01321 <span class="comment"></span>
01322 <span class="comment">Arguments:</span>
01323 <span class="comment"></span>
01324 <span class="comment">    m - Supplies a pointer to the state manipulation message.</span>
01325 <span class="comment"></span>
01326 <span class="comment">    AdditionalData - Supplies a pointer to a descriptor for the data to write.</span>
01327 <span class="comment"></span>
01328 <span class="comment">    Context - Supplies a pointer to the current context.</span>
01329 <span class="comment"></span>
01330 <span class="comment">Return Value:</span>
01331 <span class="comment"></span>
01332 <span class="comment">    None.</span>
01333 <span class="comment"></span>
01334 <span class="comment">--*/</span>
01335 
01336 {
01337 
01338     ULONG Length;
01339     STRING MessageHeader;
01340 
01341     <span class="comment">//</span>
01342     <span class="comment">// Move the data to the destination buffer.</span>
01343     <span class="comment">//</span>
01344 
01345     Length = <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>(m-&gt;u.WriteMemory.TargetBaseAddress,
01346                            AdditionalData-&gt;Buffer,
01347                            AdditionalData-&gt;Length);
01348 
01349     <span class="comment">//</span>
01350     <span class="comment">// If all the data is written, then return a success status. Otherwise,</span>
01351     <span class="comment">// return an unsuccessful status.</span>
01352     <span class="comment">//</span>
01353 
01354     m-&gt;ReturnStatus = STATUS_SUCCESS;
01355     <span class="keywordflow">if</span> (Length != AdditionalData-&gt;Length) {
01356         m-&gt;ReturnStatus = STATUS_UNSUCCESSFUL;
01357     }
01358 
01359     <span class="comment">//</span>
01360     <span class="comment">// Set the actual number of bytes written, initialize the message header,</span>
01361     <span class="comment">// and send the reply packet to the host debugger.</span>
01362     <span class="comment">//</span>
01363 
01364     m-&gt;u.WriteMemory.ActualBytesWritten = Length;
01365     MessageHeader.Length = <span class="keyword">sizeof</span>(DBGKD_MANIPULATE_STATE);
01366     MessageHeader.Buffer = (PCHAR)m;
01367     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a116">KdpSendPacket</a>(PACKET_TYPE_KD_STATE_MANIPULATE,
01368                   &amp;MessageHeader,
01369                   <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
01370 
01371     <span class="keywordflow">return</span>;
01372 }
01373 
01374 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01375"></a><a class="code" href="../../d0/d7/kdp_8h.html#a112">01375</a> <a class="code" href="../../d0/d7/kdp_8h.html#a112">KdpWriteVirtualMemory64</a>(
01376     IN PDBGKD_MANIPULATE_STATE m,
01377     IN PSTRING AdditionalData,
01378     IN PCONTEXT Context
01379     )
01380 
01381 <span class="comment">/*++</span>
01382 <span class="comment"></span>
01383 <span class="comment">Routine Description:</span>
01384 <span class="comment"></span>
01385 <span class="comment">    This function is called in response of a write virtual memory 64-bit</span>
01386 <span class="comment">    state manipulation message. Its function is to write virtual memory</span>
01387 <span class="comment">    and return.</span>
01388 <span class="comment"></span>
01389 <span class="comment">Arguments:</span>
01390 <span class="comment"></span>
01391 <span class="comment">    m - Supplies a pointer to the state manipulation message.</span>
01392 <span class="comment"></span>
01393 <span class="comment">    AdditionalData - Supplies a pointer to a descriptor for the data to write.</span>
01394 <span class="comment"></span>
01395 <span class="comment">    Context - Supplies a pointer to the current context.</span>
01396 <span class="comment"></span>
01397 <span class="comment">Return Value:</span>
01398 <span class="comment"></span>
01399 <span class="comment">    None.</span>
01400 <span class="comment"></span>
01401 <span class="comment">--*/</span>
01402 
01403 {
01404 
01405     UCHAR * POINTER_64 Address;
01406     UCHAR * POINTER_64 Destination;
01407     ULONG Length;
01408     STRING MessageHeader;
01409     PUCHAR Source;
01410     ULONG_PTR Opaque;
01411 
01412     <span class="comment">//</span>
01413     <span class="comment">// Move the data to the destination buffer.</span>
01414     <span class="comment">//</span>
01415 
01416     Length = AdditionalData-&gt;Length;
01417 
01418 <span class="preprocessor">#if defined(_MIPS_) || defined(_ALPHA_)</span>
01419 <span class="preprocessor"></span>
01420     Destination = (UCHAR * POINTER_64)m-&gt;u.WriteMemory64.TargetBaseAddress;
01421     Source = AdditionalData-&gt;Buffer;
01422     <span class="keywordflow">while</span> (Length &gt; 0) {
01423         <span class="keywordflow">if</span> ((Address = <a class="code" href="../../d4/d6/ppc_2debugsup_8c.html#a3">MmDbgWriteCheck64</a>(Destination)) == NULL64) {
01424             <span class="keywordflow">break</span>;
01425         }
01426 
01427         *Address = *Source++;
01428         Destination += 1;
01429         Length -= 1;
01430     }
01431 
01432 <span class="preprocessor">#endif</span>
01433 <span class="preprocessor"></span>
01434     <span class="comment">//</span>
01435     <span class="comment">// If all the data is written, then return a success status. Otherwise,</span>
01436     <span class="comment">// return an unsuccessful status.</span>
01437     <span class="comment">//</span>
01438 
01439     m-&gt;ReturnStatus = STATUS_SUCCESS;
01440     <span class="keywordflow">if</span> (Length != 0) {
01441         m-&gt;ReturnStatus = STATUS_UNSUCCESSFUL;
01442     }
01443 
01444     <span class="comment">//</span>
01445     <span class="comment">// Set the actual number of bytes written, initialize the message header,</span>
01446     <span class="comment">// and send the reply packet to the host debugger.</span>
01447     <span class="comment">//</span>
01448 
01449     m-&gt;u.WriteMemory64.ActualBytesWritten = AdditionalData-&gt;Length - Length;
01450     MessageHeader.Length = <span class="keyword">sizeof</span>(DBGKD_MANIPULATE_STATE);
01451     MessageHeader.Buffer = (PCHAR)m;
01452     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a116">KdpSendPacket</a>(PACKET_TYPE_KD_STATE_MANIPULATE,
01453                   &amp;MessageHeader,
01454                   <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
01455 
01456     <span class="keywordflow">return</span>;
01457 }
01458 
01459 
01460 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01461"></a><a class="code" href="../../d0/d7/kdp_8h.html#a115">01461</a> <a class="code" href="../../d1/d7/4_2kdp_8h.html#a128">KdpGetContext</a>(
01462     IN PDBGKD_MANIPULATE_STATE m,
01463     IN PSTRING AdditionalData,
01464     IN PCONTEXT Context
01465     )
01466 
01467 <span class="comment">/*++</span>
01468 <span class="comment"></span>
01469 <span class="comment">Routine Description:</span>
01470 <span class="comment"></span>
01471 <span class="comment">    This function is called in response of a get context state</span>
01472 <span class="comment">    manipulation message.  Its function is to return the current</span>
01473 <span class="comment">    context.</span>
01474 <span class="comment"></span>
01475 <span class="comment">Arguments:</span>
01476 <span class="comment"></span>
01477 <span class="comment">    m - Supplies the state manipulation message.</span>
01478 <span class="comment"></span>
01479 <span class="comment">    AdditionalData - Supplies any additional data for the message.</span>
01480 <span class="comment"></span>
01481 <span class="comment">    Context - Supplies the current context.</span>
01482 <span class="comment"></span>
01483 <span class="comment">Return Value:</span>
01484 <span class="comment"></span>
01485 <span class="comment">    None.</span>
01486 <span class="comment"></span>
01487 <span class="comment">--*/</span>
01488 
01489 {
01490     PDBGKD_GET_CONTEXT a = &amp;m-&gt;u.GetContext;
01491     STRING MessageHeader;
01492 
01493     MessageHeader.Length = <span class="keyword">sizeof</span>(*m);
01494     MessageHeader.Buffer = (PCHAR)m;
01495 
01496     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(AdditionalData-&gt;Length == 0);
01497 
01498     <span class="keywordflow">if</span> (m-&gt;Processor &gt;= (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)<a class="code" href="../../d4/d9/ke_8h.html#a133">KeNumberProcessors</a>) {
01499         m-&gt;ReturnStatus = STATUS_UNSUCCESSFUL;
01500     } <span class="keywordflow">else</span> {
01501         m-&gt;ReturnStatus = STATUS_SUCCESS;
01502         AdditionalData-&gt;Length = <span class="keyword">sizeof</span>(CONTEXT);
01503         <span class="keywordflow">if</span> (m-&gt;Processor == (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)<a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a2">KeGetCurrentPrcb</a>()-&gt;Number) {
01504             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a111">KdpQuickMoveMemory</a>(AdditionalData-&gt;Buffer, (PCHAR)Context, <span class="keyword">sizeof</span>(CONTEXT));
01505         } <span class="keywordflow">else</span> {
01506             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a111">KdpQuickMoveMemory</a>(AdditionalData-&gt;Buffer,
01507                           (PCHAR)&amp;<a class="code" href="../../d4/d9/ke_8h.html#a139">KiProcessorBlock</a>[m-&gt;Processor]-&gt;ProcessorState.ContextFrame,
01508                           <span class="keyword">sizeof</span>(CONTEXT)
01509                          );
01510         }
01511     }
01512 
01513     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a116">KdpSendPacket</a>(
01514                   PACKET_TYPE_KD_STATE_MANIPULATE,
01515                   &amp;MessageHeader,
01516                   AdditionalData
01517                   );
01518 }
01519 
01520 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01521"></a><a class="code" href="../../d0/d7/kdp_8h.html#a116">01521</a> <a class="code" href="../../d1/d7/4_2kdp_8h.html#a129">KdpSetContext</a>(
01522     IN PDBGKD_MANIPULATE_STATE m,
01523     IN PSTRING AdditionalData,
01524     IN PCONTEXT Context
01525     )
01526 
01527 <span class="comment">/*++</span>
01528 <span class="comment"></span>
01529 <span class="comment">Routine Description:</span>
01530 <span class="comment"></span>
01531 <span class="comment">    This function is called in response of a set context state</span>
01532 <span class="comment">    manipulation message.  Its function is set the current</span>
01533 <span class="comment">    context.</span>
01534 <span class="comment"></span>
01535 <span class="comment">Arguments:</span>
01536 <span class="comment"></span>
01537 <span class="comment">    m - Supplies the state manipulation message.</span>
01538 <span class="comment"></span>
01539 <span class="comment">    AdditionalData - Supplies any additional data for the message.</span>
01540 <span class="comment"></span>
01541 <span class="comment">    Context - Supplies the current context.</span>
01542 <span class="comment"></span>
01543 <span class="comment">Return Value:</span>
01544 <span class="comment"></span>
01545 <span class="comment">    None.</span>
01546 <span class="comment"></span>
01547 <span class="comment">--*/</span>
01548 
01549 {
01550     PDBGKD_SET_CONTEXT a = &amp;m-&gt;u.SetContext;
01551     STRING MessageHeader;
01552 
01553     MessageHeader.Length = <span class="keyword">sizeof</span>(*m);
01554     MessageHeader.Buffer = (PCHAR)m;
01555 
01556     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(AdditionalData-&gt;Length == <span class="keyword">sizeof</span>(CONTEXT));
01557 
01558     <span class="keywordflow">if</span> (m-&gt;Processor &gt;= (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)<a class="code" href="../../d4/d9/ke_8h.html#a133">KeNumberProcessors</a>) {
01559         m-&gt;ReturnStatus = STATUS_UNSUCCESSFUL;
01560     } <span class="keywordflow">else</span> {
01561         m-&gt;ReturnStatus = STATUS_SUCCESS;
01562         <span class="keywordflow">if</span> (m-&gt;Processor == (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)<a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a2">KeGetCurrentPrcb</a>()-&gt;Number) {
01563             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a111">KdpQuickMoveMemory</a>((PCHAR)Context, AdditionalData-&gt;Buffer, <span class="keyword">sizeof</span>(CONTEXT));
01564         } <span class="keywordflow">else</span> {
01565             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a111">KdpQuickMoveMemory</a>((PCHAR)&amp;<a class="code" href="../../d4/d9/ke_8h.html#a139">KiProcessorBlock</a>[m-&gt;Processor]-&gt;ProcessorState.ContextFrame,
01566                           AdditionalData-&gt;Buffer,
01567                           <span class="keyword">sizeof</span>(CONTEXT)
01568                          );
01569         }
01570     }
01571 
01572     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a116">KdpSendPacket</a>(
01573                   PACKET_TYPE_KD_STATE_MANIPULATE,
01574                   &amp;MessageHeader,
01575                   <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>
01576                   );
01577 }
01578 
01579 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01580"></a><a class="code" href="../../d0/d7/kdp_8h.html#a117">01580</a> <a class="code" href="../../d1/d7/4_2kdp_8h.html#a130">KdpWriteBreakpoint</a>(
01581     IN PDBGKD_MANIPULATE_STATE m,
01582     IN PSTRING AdditionalData,
01583     IN PCONTEXT Context
01584     )
01585 
01586 <span class="comment">/*++</span>
01587 <span class="comment"></span>
01588 <span class="comment">Routine Description:</span>
01589 <span class="comment"></span>
01590 <span class="comment">    This function is called in response of a write breakpoint state</span>
01591 <span class="comment">    manipulation message.  Its function is to write a breakpoint</span>
01592 <span class="comment">    and return a handle to the breakpoint.</span>
01593 <span class="comment"></span>
01594 <span class="comment">Arguments:</span>
01595 <span class="comment"></span>
01596 <span class="comment">    m - Supplies the state manipulation message.</span>
01597 <span class="comment"></span>
01598 <span class="comment">    AdditionalData - Supplies any additional data for the message.</span>
01599 <span class="comment"></span>
01600 <span class="comment">    Context - Supplies the current context.</span>
01601 <span class="comment"></span>
01602 <span class="comment">Return Value:</span>
01603 <span class="comment"></span>
01604 <span class="comment">    None.</span>
01605 <span class="comment"></span>
01606 <span class="comment">--*/</span>
01607 
01608 {
01609     PDBGKD_WRITE_BREAKPOINT a = &amp;m-&gt;u.WriteBreakPoint;
01610     STRING MessageHeader;
01611 
01612     MessageHeader.Length = <span class="keyword">sizeof</span>(*m);
01613     MessageHeader.Buffer = (PCHAR)m;
01614 
01615     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(AdditionalData-&gt;Length == 0);
01616 
01617     a-&gt;BreakPointHandle = <a class="code" href="../../d1/d7/4_2kdp_8h.html#a104">KdpAddBreakpoint</a>(a-&gt;BreakPointAddress);
01618     <span class="keywordflow">if</span> (a-&gt;BreakPointHandle != 0) {
01619         m-&gt;ReturnStatus = STATUS_SUCCESS;
01620     } <span class="keywordflow">else</span> {
01621         m-&gt;ReturnStatus = STATUS_UNSUCCESSFUL;
01622     }
01623     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a116">KdpSendPacket</a>(
01624                   PACKET_TYPE_KD_STATE_MANIPULATE,
01625                   &amp;MessageHeader,
01626                   <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>
01627                   );
01628     UNREFERENCED_PARAMETER(Context);
01629 }
01630 
01631 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01632"></a><a class="code" href="../../d0/d7/kdp_8h.html#a118">01632</a> <a class="code" href="../../d1/d7/4_2kdp_8h.html#a131">KdpRestoreBreakpoint</a>(
01633     IN PDBGKD_MANIPULATE_STATE m,
01634     IN PSTRING AdditionalData,
01635     IN PCONTEXT Context
01636     )
01637 
01638 <span class="comment">/*++</span>
01639 <span class="comment"></span>
01640 <span class="comment">Routine Description:</span>
01641 <span class="comment"></span>
01642 <span class="comment">    This function is called in response of a restore breakpoint state</span>
01643 <span class="comment">    manipulation message.  Its function is to restore a breakpoint</span>
01644 <span class="comment">    using the specified handle.</span>
01645 <span class="comment"></span>
01646 <span class="comment">Arguments:</span>
01647 <span class="comment"></span>
01648 <span class="comment">    m - Supplies the state manipulation message.</span>
01649 <span class="comment"></span>
01650 <span class="comment">    AdditionalData - Supplies any additional data for the message.</span>
01651 <span class="comment"></span>
01652 <span class="comment">    Context - Supplies the current context.</span>
01653 <span class="comment"></span>
01654 <span class="comment">Return Value:</span>
01655 <span class="comment"></span>
01656 <span class="comment">    None.</span>
01657 <span class="comment"></span>
01658 <span class="comment">--*/</span>
01659 
01660 {
01661     PDBGKD_RESTORE_BREAKPOINT a = &amp;m-&gt;u.RestoreBreakPoint;
01662     STRING MessageHeader;
01663 
01664     MessageHeader.Length = <span class="keyword">sizeof</span>(*m);
01665     MessageHeader.Buffer = (PCHAR)m;
01666 
01667     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(AdditionalData-&gt;Length == 0);
01668     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d7/4_2kdp_8h.html#a105">KdpDeleteBreakpoint</a>(a-&gt;BreakPointHandle)) {
01669         m-&gt;ReturnStatus = STATUS_SUCCESS;
01670     } <span class="keywordflow">else</span> {
01671         m-&gt;ReturnStatus = STATUS_UNSUCCESSFUL;
01672     }
01673     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a116">KdpSendPacket</a>(
01674                   PACKET_TYPE_KD_STATE_MANIPULATE,
01675                   &amp;MessageHeader,
01676                   <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>
01677                   );
01678     UNREFERENCED_PARAMETER(Context);
01679 }
01680 
01681 <span class="preprocessor">#if i386</span>
01682 <span class="preprocessor"></span><span class="keywordtype">long</span>
01683 SymNumFor(
01684     ULONG pc
01685     )
01686 {
01687     ULONG index;
01688 
01689     <span class="keywordflow">for</span> (index = 0; index &lt; <a class="code" href="../../d8/d5/kddata_8c.html#a73">NumTraceDataSyms</a>; index++) {
01690         <span class="keywordflow">if</span> ((<a class="code" href="../../d8/d5/kddata_8c.html#a71">TraceDataSyms</a>[index].<a class="code" href="../../d9/d1/struct__TRACE__DATA__SYM.html#o0">SymMin</a> &lt;= pc) &amp;&amp;
01691             (<a class="code" href="../../d8/d5/kddata_8c.html#a71">TraceDataSyms</a>[index].<a class="code" href="../../d9/d1/struct__TRACE__DATA__SYM.html#o1">SymMax</a> &gt; pc)) <span class="keywordflow">return</span>(index);
01692     }
01693     <span class="keywordflow">return</span>(-1);
01694 }
01695 
01696 BOOLEAN TraceDataBufferFilled = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01697 
01698 <span class="keywordtype">void</span> PotentialNewSymbol (ULONG pc)
01699 {
01700     <span class="keywordflow">if</span> (!TraceDataBufferFilled &amp;&amp;
01701         -1 != SymNumFor(pc)) {     <span class="comment">// we've already seen this one</span>
01702         <span class="keywordflow">return</span>;
01703     }
01704 
01705     TraceDataBufferFilled = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01706 
01707     <span class="comment">// OK, we've got to start up a TraceDataRecord</span>
01708     <a class="code" href="../../d8/d5/kddata_8c.html#a69">TraceDataBuffer</a>[<a class="code" href="../../d8/d5/kddata_8c.html#a70">TraceDataBufferPosition</a>].s.LevelChange = 0;
01709 
01710     <span class="keywordflow">if</span> (-1 != SymNumFor(pc)) {
01711         <span class="keywordtype">int</span> sym = SymNumFor(pc);
01712         <a class="code" href="../../d8/d5/kddata_8c.html#a69">TraceDataBuffer</a>[<a class="code" href="../../d8/d5/kddata_8c.html#a70">TraceDataBufferPosition</a>].s.SymbolNumber = (UCHAR) sym;
01713         <a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a1">KdpCurrentSymbolStart</a> = <a class="code" href="../../d8/d5/kddata_8c.html#a71">TraceDataSyms</a>[sym].<a class="code" href="../../d9/d1/struct__TRACE__DATA__SYM.html#o0">SymMin</a>;
01714         <a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a2">KdpCurrentSymbolEnd</a> = <a class="code" href="../../d8/d5/kddata_8c.html#a71">TraceDataSyms</a>[sym].<a class="code" href="../../d9/d1/struct__TRACE__DATA__SYM.html#o1">SymMax</a>;
01715 
01716         <span class="keywordflow">return</span>;  <span class="comment">// we've already seen this one</span>
01717     }
01718 
01719     <a class="code" href="../../d8/d5/kddata_8c.html#a71">TraceDataSyms</a>[<a class="code" href="../../d8/d5/kddata_8c.html#a72">NextTraceDataSym</a>].<a class="code" href="../../d9/d1/struct__TRACE__DATA__SYM.html#o0">SymMin</a> = <a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a1">KdpCurrentSymbolStart</a>;
01720     <a class="code" href="../../d8/d5/kddata_8c.html#a71">TraceDataSyms</a>[<a class="code" href="../../d8/d5/kddata_8c.html#a72">NextTraceDataSym</a>].<a class="code" href="../../d9/d1/struct__TRACE__DATA__SYM.html#o1">SymMax</a> = <a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a2">KdpCurrentSymbolEnd</a>;
01721 
01722     <a class="code" href="../../d8/d5/kddata_8c.html#a69">TraceDataBuffer</a>[<a class="code" href="../../d8/d5/kddata_8c.html#a70">TraceDataBufferPosition</a>].s.SymbolNumber = <a class="code" href="../../d8/d5/kddata_8c.html#a72">NextTraceDataSym</a>;
01723 
01724     <span class="comment">// Bump the "next" pointer, wrapping if necessary.  Also bump the</span>
01725     <span class="comment">// "valid" pointer if we need to.</span>
01726     <a class="code" href="../../d8/d5/kddata_8c.html#a72">NextTraceDataSym</a> = (<a class="code" href="../../d8/d5/kddata_8c.html#a72">NextTraceDataSym</a> + 1) % 256;
01727     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d5/kddata_8c.html#a73">NumTraceDataSyms</a> &lt; <a class="code" href="../../d8/d5/kddata_8c.html#a72">NextTraceDataSym</a>) {
01728         <a class="code" href="../../d8/d5/kddata_8c.html#a73">NumTraceDataSyms</a> = <a class="code" href="../../d8/d5/kddata_8c.html#a72">NextTraceDataSym</a>;
01729     }
01730 
01731 }
01732 
01733 <span class="keywordtype">void</span> DumpTraceData(PSTRING MessageData)
01734 {
01735 
01736  <a class="code" href="../../d8/d5/kddata_8c.html#a69">TraceDataBuffer</a>[0].LongNumber = <a class="code" href="../../d8/d5/kddata_8c.html#a70">TraceDataBufferPosition</a>;
01737  MessageData-&gt;Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(<span class="keyword">sizeof</span>(<a class="code" href="../../d8/d5/kddata_8c.html#a69">TraceDataBuffer</a>[0]) * <a class="code" href="../../d8/d5/kddata_8c.html#a70">TraceDataBufferPosition</a>);
01738  MessageData-&gt;Buffer = (PVOID)<a class="code" href="../../d8/d5/kddata_8c.html#a69">TraceDataBuffer</a>;
01739  <a class="code" href="../../d8/d5/kddata_8c.html#a70">TraceDataBufferPosition</a> = 1;
01740 }
01741 
01742 BOOLEAN
01743 TraceDataRecordCallInfo(
01744     ULONG InstructionsTraced,
01745     LONG CallLevelChange,
01746     ULONG pc
01747     )
01748 {
01749     <span class="comment">// We've just exited a symbol scope.  The InstructionsTraced number goes</span>
01750     <span class="comment">// with the old scope, the CallLevelChange goes with the new, and the</span>
01751     <span class="comment">// pc fills in the symbol for the new TraceData record.</span>
01752 
01753     <span class="keywordtype">long</span> SymNum = SymNumFor(pc);
01754 
01755     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d5/kddata_8c.html#a61">KdpNextCallLevelChange</a> != 0) {
01756         <a class="code" href="../../d8/d5/kddata_8c.html#a69">TraceDataBuffer</a>[<a class="code" href="../../d8/d5/kddata_8c.html#a70">TraceDataBufferPosition</a>].s.LevelChange =
01757                                                 (<span class="keywordtype">char</span>) <a class="code" href="../../d8/d5/kddata_8c.html#a61">KdpNextCallLevelChange</a>;
01758         <a class="code" href="../../d8/d5/kddata_8c.html#a61">KdpNextCallLevelChange</a> = 0;
01759     }
01760 
01761 
01762     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d5/kddata_8c.html#a81">InstructionsTraced</a> &gt;= TRACE_DATA_INSTRUCTIONS_BIG) {
01763        <a class="code" href="../../d8/d5/kddata_8c.html#a69">TraceDataBuffer</a>[<a class="code" href="../../d8/d5/kddata_8c.html#a70">TraceDataBufferPosition</a>].s.Instructions =
01764            TRACE_DATA_INSTRUCTIONS_BIG;
01765        <a class="code" href="../../d8/d5/kddata_8c.html#a69">TraceDataBuffer</a>[<a class="code" href="../../d8/d5/kddata_8c.html#a70">TraceDataBufferPosition</a>+1].LongNumber =
01766            <a class="code" href="../../d8/d5/kddata_8c.html#a81">InstructionsTraced</a>;
01767        <a class="code" href="../../d8/d5/kddata_8c.html#a70">TraceDataBufferPosition</a> += 2;
01768     } <span class="keywordflow">else</span> {
01769        <a class="code" href="../../d8/d5/kddata_8c.html#a69">TraceDataBuffer</a>[<a class="code" href="../../d8/d5/kddata_8c.html#a70">TraceDataBufferPosition</a>].s.Instructions =
01770            (<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>)<a class="code" href="../../d8/d5/kddata_8c.html#a81">InstructionsTraced</a>;
01771        <a class="code" href="../../d8/d5/kddata_8c.html#a70">TraceDataBufferPosition</a>++;
01772     }
01773 
01774     <span class="keywordflow">if</span> ((<a class="code" href="../../d8/d5/kddata_8c.html#a70">TraceDataBufferPosition</a> + 2 &gt;= TRACE_DATA_BUFFER_MAX_SIZE) ||
01775         (-1 == SymNum)) {
01776         <span class="keywordflow">if</span> (<a class="code" href="../../d8/d5/kddata_8c.html#a70">TraceDataBufferPosition</a> +2 &gt;= TRACE_DATA_BUFFER_MAX_SIZE) {
01777             TraceDataBufferFilled = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01778         }
01779        <a class="code" href="../../d8/d5/kddata_8c.html#a61">KdpNextCallLevelChange</a> = <a class="code" href="../../d8/d5/kddata_8c.html#a83">CallLevelChange</a>;
01780        <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01781     }
01782 
01783     <a class="code" href="../../d8/d5/kddata_8c.html#a69">TraceDataBuffer</a>[<a class="code" href="../../d8/d5/kddata_8c.html#a70">TraceDataBufferPosition</a>].s.LevelChange =(<span class="keywordtype">char</span>)<a class="code" href="../../d8/d5/kddata_8c.html#a83">CallLevelChange</a>;
01784     <a class="code" href="../../d8/d5/kddata_8c.html#a69">TraceDataBuffer</a>[<a class="code" href="../../d8/d5/kddata_8c.html#a70">TraceDataBufferPosition</a>].s.SymbolNumber = (UCHAR) SymNum;
01785     <a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a1">KdpCurrentSymbolStart</a> = <a class="code" href="../../d8/d5/kddata_8c.html#a71">TraceDataSyms</a>[SymNum].<a class="code" href="../../d9/d1/struct__TRACE__DATA__SYM.html#o0">SymMin</a>;
01786     <a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a2">KdpCurrentSymbolEnd</a> = <a class="code" href="../../d8/d5/kddata_8c.html#a71">TraceDataSyms</a>[SymNum].<a class="code" href="../../d9/d1/struct__TRACE__DATA__SYM.html#o1">SymMax</a>;
01787 
01788     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01789 }
01790 
01791 BOOLEAN
01792 SkippingWhichBP (
01793     PVOID thread,
01794     PULONG BPNum
01795     )
01796 
01797 <span class="comment">/*</span>
01798 <span class="comment"> * Return TRUE iff the pc corresponds to an internal breakpoint</span>
01799 <span class="comment"> * that has just been replaced for execution.  If TRUE, then return</span>
01800 <span class="comment"> * the breakpoint number in BPNum.</span>
01801 <span class="comment"> */</span>
01802 
01803 {
01804     ULONG index;
01805 
01806     <span class="keywordflow">if</span> (!<a class="code" href="../../d8/d5/kddata_8c.html#a74">IntBPsSkipping</a>) <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01807 
01808     <span class="keywordflow">for</span> (index = 0; index &lt; <a class="code" href="../../d8/d5/kddata_8c.html#a65">KdpNumInternalBreakpoints</a>; index++) {
01809         <span class="keywordflow">if</span> (!(<a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[index].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o1">Flags</a> &amp; DBGKD_INTERNAL_BP_FLAG_INVALID) &amp;&amp;
01810             (<a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[index].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o9">Thread</a> == thread)) {
01811             *BPNum = index;
01812             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01813         }
01814     }
01815     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>; <span class="comment">// didn't match any</span>
01816 }
01817 
01818 
01819 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01820 <a class="code" href="../../d1/d7/4_2kdp_8h.html#a107">KdQuerySpecialCalls</a> (
01821     IN PDBGKD_MANIPULATE_STATE m,
01822     ULONG Length,
01823     PULONG RequiredLength
01824     )
01825 {
01826     *RequiredLength = <span class="keyword">sizeof</span>(DBGKD_MANIPULATE_STATE) +
01827                         (<span class="keyword">sizeof</span>(ULONG) * <a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a4">KdNumberOfSpecialCalls</a>);
01828 
01829     <span class="keywordflow">if</span> ( Length &lt; *RequiredLength ) {
01830         <span class="keywordflow">return</span> STATUS_INFO_LENGTH_MISMATCH;
01831     }
01832 
01833     m-&gt;u.QuerySpecialCalls.NumberOfSpecialCalls = <a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a4">KdNumberOfSpecialCalls</a>;
01834         RtlCopyMemory(
01835         m + 1,
01836         KdSpecialCalls,
01837         <span class="keyword">sizeof</span>(ULONG) * KdNumberOfSpecialCalls
01838         );
01839 
01840     <span class="keywordflow">return</span> STATUS_SUCCESS;
01841 
01842 } <span class="comment">// KdQuerySpecialCalls</span>
01843 
01844 
01845 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01846 <a class="code" href="../../d1/d7/4_2kdp_8h.html#a108">KdSetSpecialCall</a> (
01847     IN PDBGKD_MANIPULATE_STATE m,
01848     IN PCONTEXT ContextRecord
01849     )
01850 
01851 <span class="comment">/*++</span>
01852 <span class="comment"></span>
01853 <span class="comment">Routine Description:</span>
01854 <span class="comment"></span>
01855 <span class="comment">    This function sets the addresses of the "special" call addresses</span>
01856 <span class="comment">    that the watchtrace facility pushes back to the kernel debugger</span>
01857 <span class="comment">    rather than stepping through.</span>
01858 <span class="comment"></span>
01859 <span class="comment">Arguments:</span>
01860 <span class="comment"></span>
01861 <span class="comment">    m - Supplies the state manipulation message.</span>
01862 <span class="comment"></span>
01863 <span class="comment">Return Value:</span>
01864 <span class="comment"></span>
01865 <span class="comment">    None.</span>
01866 <span class="comment">--*/</span>
01867 
01868 {
01869     <span class="keywordflow">if</span> ( <a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a4">KdNumberOfSpecialCalls</a> &gt;= <a class="code" href="../../d0/d7/kdp_8h.html#a13">DBGKD_MAX_SPECIAL_CALLS</a> ) {
01870         <span class="keywordflow">return</span>; <span class="comment">// too bad</span>
01871     }
01872 
01873     <a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a3">KdSpecialCalls</a>[<a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a4">KdNumberOfSpecialCalls</a>++] = m-&gt;u.SetSpecialCall.SpecialCall;
01874 
01875     <a class="code" href="../../d8/d5/kddata_8c.html#a72">NextTraceDataSym</a> = 0;
01876     <a class="code" href="../../d8/d5/kddata_8c.html#a73">NumTraceDataSyms</a> = 0;
01877     <a class="code" href="../../d8/d5/kddata_8c.html#a61">KdpNextCallLevelChange</a> = 0;
01878     <span class="keywordflow">if</span> (ContextRecord &amp;&amp; !<a class="code" href="../../d8/d5/kddata_8c.html#a85">InstrCountInternal</a>) {
01879         <a class="code" href="../../d8/d5/kddata_8c.html#a64">InitialSP</a> = ContextRecord-&gt;Esp;
01880     }
01881 
01882 } <span class="comment">// KdSetSpecialCall</span>
01883 
01884 
01885 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01886 <a class="code" href="../../d1/d7/4_2kdp_8h.html#a109">KdClearSpecialCalls</a> (
01887     VOID
01888     )
01889 
01890 <span class="comment">/*++</span>
01891 <span class="comment"></span>
01892 <span class="comment">Routine Description:</span>
01893 <span class="comment"></span>
01894 <span class="comment">    This function clears the addresses of the "special" call addresses</span>
01895 <span class="comment">    that the watchtrace facility pushes back to the kernel debugger</span>
01896 <span class="comment">    rather than stepping through.</span>
01897 <span class="comment"></span>
01898 <span class="comment">Arguments:</span>
01899 <span class="comment"></span>
01900 <span class="comment">    None.</span>
01901 <span class="comment"></span>
01902 <span class="comment">Return Value:</span>
01903 <span class="comment"></span>
01904 <span class="comment">    None.</span>
01905 <span class="comment"></span>
01906 <span class="comment">--*/</span>
01907 
01908 {
01909     <a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a4">KdNumberOfSpecialCalls</a> = 0;
01910     <span class="keywordflow">return</span>;
01911 
01912 } <span class="comment">// KdClearSpecialCalls</span>
01913 
01914 
01915 BOOLEAN
01916 <a class="code" href="../../d2/d9/4_2i386_2kdtrap_8c.html#a3">KdpCheckTracePoint</a>(
01917     IN PEXCEPTION_RECORD ExceptionRecord,
01918     IN OUT PCONTEXT ContextRecord
01919     )
01920 {
01921     ULONG pc = (ULONG)CONTEXT_TO_PROGRAM_COUNTER(ContextRecord);
01922     LONG BpNum;
01923     ULONG SkippedBPNum;
01924     BOOLEAN AfterSC = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01925 
01926     <span class="keywordflow">if</span> (ExceptionRecord-&gt;ExceptionCode == STATUS_SINGLE_STEP) {
01927         <span class="keywordflow">if</span> (<a class="code" href="../../d8/d5/kddata_8c.html#a80">WatchStepOverSuspended</a>) {
01928             <span class="comment">//</span>
01929             <span class="comment">//  For background, see the comment below where WSOThread is</span>
01930             <span class="comment">//  wrong.  We've now stepped over the breakpoint in the non-traced</span>
01931             <span class="comment">//  thread, and need to replace it and restart the non-traced</span>
01932             <span class="comment">//  thread at full speed.</span>
01933             <span class="comment">//</span>
01934 
01935             <a class="code" href="../../d8/d5/kddata_8c.html#a78">WatchStepOverHandle</a> = <a class="code" href="../../d1/d7/4_2kdp_8h.html#a104">KdpAddBreakpoint</a>((PVOID)WatchStepOverBreakAddr);
01936             <a class="code" href="../../d8/d5/kddata_8c.html#a80">WatchStepOverSuspended</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01937             ContextRecord-&gt;EFlags &amp;= ~0x100<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>; <span class="comment">/* clear trace flag */</span>
01938             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>; <span class="comment">// resume non-traced thread at full speed</span>
01939         }
01940 
01941         <span class="keywordflow">if</span> ((!<a class="code" href="../../d8/d5/kddata_8c.html#a82">SymbolRecorded</a>) &amp;&amp; (<a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a1">KdpCurrentSymbolStart</a> != 0) &amp;&amp; (<a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a2">KdpCurrentSymbolEnd</a> != 0)) {
01942             <span class="comment">//</span>
01943             <span class="comment">//  We need to use oldpc here, because this may have been</span>
01944             <span class="comment">//  a 1 instruction call.  We've ALREADY executed the instruction</span>
01945             <span class="comment">//  that the new symbol is for, and if the pc has moved out of</span>
01946             <span class="comment">//  range, we might screw up.  Hence, use the pc from when</span>
01947             <span class="comment">//  SymbolRecorded was set.  Yuck.</span>
01948             <span class="comment">//</span>
01949 
01950             PotentialNewSymbol(oldpc);
01951             <a class="code" href="../../d8/d5/kddata_8c.html#a82">SymbolRecorded</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01952         }
01953 
01954         <span class="keywordflow">if</span> (!<a class="code" href="../../d8/d5/kddata_8c.html#a85">InstrCountInternal</a> &amp;&amp;
01955             SkippingWhichBP((PVOID)<a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a3">KeGetCurrentThread</a>(),&amp;SkippedBPNum)) {
01956 
01957             <span class="comment">//</span>
01958             <span class="comment">//  We just single-stepped over a temporarily removed internal</span>
01959             <span class="comment">//  breakpoint.</span>
01960             <span class="comment">//  If it's a COUNTONLY breakpoint:</span>
01961             <span class="comment">//      Put the breakpoint instruction back and resume</span>
01962             <span class="comment">//      regular execution.</span>
01963             <span class="comment">//</span>
01964 
01965             <span class="keywordflow">if</span> (<a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[SkippedBPNum].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o1">Flags</a> &amp;
01966                 DBGKD_INTERNAL_BP_FLAG_COUNTONLY) {
01967 
01968                 <a class="code" href="../../d8/d5/kddata_8c.html#a74">IntBPsSkipping</a> --;
01969 
01970                 <a class="code" href="../../d1/d7/4_2kdp_8h.html#a140">KdpRestoreAllBreakpoints</a>();
01971 
01972                 ContextRecord-&gt;EFlags &amp;= ~0x100<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>;  <span class="comment">// Clear trace flag</span>
01973                 <a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[SkippedBPNum].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o9">Thread</a> = 0;
01974 
01975                 <span class="keywordflow">if</span> (<a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[SkippedBPNum].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o1">Flags</a> &amp;
01976                         DBGKD_INTERNAL_BP_FLAG_DYING) {
01977                     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a105">KdpDeleteBreakpoint</a>(KdpInternalBPs[SkippedBPNum].Handle);
01978                     <a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[SkippedBPNum].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o1">Flags</a> |=
01979                             DBGKD_INTERNAL_BP_FLAG_INVALID; <span class="comment">// bye, bye</span>
01980                 }
01981 
01982                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01983             }
01984 
01985             <span class="comment">//</span>
01986             <span class="comment">//  If it's not:</span>
01987             <span class="comment">//      set up like it's a ww, by setting Begin and KdpCurrentSymbolEnd</span>
01988             <span class="comment">//      and bop off into single step land.  We probably ought to</span>
01989             <span class="comment">//      disable all breakpoints here, too, so that we don't do</span>
01990             <span class="comment">//      anything foul like trying two non-COUNTONLY's at the</span>
01991             <span class="comment">//      same time or something...</span>
01992             <span class="comment">//</span>
01993 
01994             <a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a2">KdpCurrentSymbolEnd</a> = 0;
01995             <a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a1">KdpCurrentSymbolStart</a> = <a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[SkippedBPNum].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o10">ReturnAddress</a>;
01996 
01997             ContextRecord-&gt;EFlags |= 0x100<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>; <span class="comment">/* Trace on. */</span>
01998             <a class="code" href="../../d8/d5/kddata_8c.html#a64">InitialSP</a> = ContextRecord-&gt;Esp;
01999 
02000             <a class="code" href="../../d8/d5/kddata_8c.html#a81">InstructionsTraced</a> = 1;  <span class="comment">/* Count the initial call instruction. */</span>
02001             <a class="code" href="../../d8/d5/kddata_8c.html#a85">InstrCountInternal</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02002         }
02003 
02004     } <span class="comment">/* if single step */</span>
02005     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ExceptionRecord-&gt;ExceptionCode == STATUS_BREAKPOINT) {
02006         <span class="keywordflow">if</span> (<a class="code" href="../../d8/d5/kddata_8c.html#a75">WatchStepOver</a> &amp;&amp; pc == <a class="code" href="../../d8/d5/kddata_8c.html#a79">WatchStepOverBreakAddr</a>) {
02007             <span class="comment">//</span>
02008             <span class="comment">//  This is a breakpoint after completion of a "special call"</span>
02009             <span class="comment">//</span>
02010 
02011             <span class="keywordflow">if</span> ((<a class="code" href="../../d8/d5/kddata_8c.html#a76">WSOThread</a> != (PVOID)<a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a3">KeGetCurrentThread</a>()) ||
02012                 (<a class="code" href="../../d8/d5/kddata_8c.html#a77">WSOEsp</a> + 0x20 &lt; ContextRecord-&gt;Esp) ||
02013                 (ContextRecord-&gt;Esp + 0x20 &lt; <a class="code" href="../../d8/d5/kddata_8c.html#a77">WSOEsp</a>)) {
02014                 <span class="comment">//</span>
02015                 <span class="comment">//  Here's the story up to this point: the traced thread</span>
02016                 <span class="comment">//  cruised along until it it a special call.  The tracer</span>
02017                 <span class="comment">//  placed a breakpoint on the instruction immediately after</span>
02018                 <span class="comment">//  the special call returns and restarted the traced thread</span>
02019                 <span class="comment">//  at full speed.  Then, some *other* thread hit the</span>
02020                 <span class="comment">//  breakpoint.  So, to correct for this, we're going to</span>
02021                 <span class="comment">//  remove the breakpoint, single step the non-traced</span>
02022                 <span class="comment">//  thread one instruction, replace the breakpoint,</span>
02023                 <span class="comment">//  restart the non-traced thread at full speed, and wait</span>
02024                 <span class="comment">//  for the traced thread to get to this breakpoint, just</span>
02025                 <span class="comment">//  like we were when this happened.  The assumption</span>
02026                 <span class="comment">//  here is that the traced thread won't hit the breakpoint</span>
02027                 <span class="comment">//  while it's removed, which I believe to be true, because</span>
02028                 <span class="comment">//  I don't think a context switch can occur during a single</span>
02029                 <span class="comment">//  step operation.</span>
02030                 <span class="comment">//</span>
02031                 <span class="comment">//  For extra added fun, it's possible to execute interrupt</span>
02032                 <span class="comment">//  routines IN THE SAME THREAD!!!  That's why we need to keep</span>
02033                 <span class="comment">//  the stack pointer as well as the thread address: the APC</span>
02034                 <span class="comment">//  code can result in pushing on the stack and doing a call</span>
02035                 <span class="comment">//  that's really part on an interrupt service routine in the</span>
02036                 <span class="comment">//  context of the current thread.  Lovely, isn't it?</span>
02037                 <span class="comment">//</span>
02038 
02039                 <a class="code" href="../../d8/d5/kddata_8c.html#a80">WatchStepOverSuspended</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02040                 <a class="code" href="../../d1/d7/4_2kdp_8h.html#a105">KdpDeleteBreakpoint</a>(WatchStepOverHandle);
02041                 ContextRecord-&gt;EFlags |= 0x100<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>; <span class="comment">// Set trace flag</span>
02042                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>; <span class="comment">// single step "non-traced" thread</span>
02043             }
02044 
02045             <span class="comment">//</span>
02046             <span class="comment">//  we're in the thread we started in; resume in single-step mode</span>
02047             <span class="comment">//  to continue the trace.</span>
02048             <span class="comment">//</span>
02049 
02050             <a class="code" href="../../d8/d5/kddata_8c.html#a75">WatchStepOver</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02051             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a105">KdpDeleteBreakpoint</a>(WatchStepOverHandle);
02052             ContextRecord-&gt;EFlags |= 0x100<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>; <span class="comment">// back to single step mode</span>
02053             AfterSC = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>; <span class="comment">// put us into the regular watchStep code</span>
02054 
02055         } <span class="keywordflow">else</span> {
02056 
02057             <span class="keywordflow">for</span> ( BpNum = 0; BpNum &lt; (LONG) <a class="code" href="../../d8/d5/kddata_8c.html#a65">KdpNumInternalBreakpoints</a>; BpNum++ ) {
02058                 <span class="keywordflow">if</span> ( !(<a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[BpNum].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o1">Flags</a> &amp;
02059                        (DBGKD_INTERNAL_BP_FLAG_INVALID |
02060                         DBGKD_INTERNAL_BP_FLAG_SUSPENDED) ) &amp;&amp;
02061                      (<a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[BpNum].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o0">Addr</a> == pc) ) {
02062                     <span class="keywordflow">break</span>;
02063                 }
02064             }
02065 
02066             <span class="keywordflow">if</span> ( BpNum &lt; (LONG) <a class="code" href="../../d8/d5/kddata_8c.html#a65">KdpNumInternalBreakpoints</a> ) {
02067 
02068                 <span class="comment">//</span>
02069                 <span class="comment">//  This is an internal monitoring breakpoint.</span>
02070                 <span class="comment">//  Restore the instruction and start in single-step</span>
02071                 <span class="comment">//  mode so that we can retore the breakpoint once the</span>
02072                 <span class="comment">//  instruction executes, or continue stepping if this isn't</span>
02073                 <span class="comment">//  a COUNTONLY breakpoint.</span>
02074                 <span class="comment">//</span>
02075 
02076                 <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a6">KdpProcessInternalBreakpoint</a>( BpNum );
02077                 <a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[BpNum].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o9">Thread</a> = (PVOID)<a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a3">KeGetCurrentThread</a>();
02078                 <a class="code" href="../../d8/d5/kddata_8c.html#a74">IntBPsSkipping</a> ++;
02079 
02080                 <a class="code" href="../../d1/d7/4_2kdp_8h.html#a139">KdpSuspendAllBreakpoints</a>();
02081 
02082                 ContextRecord-&gt;EFlags |= 0x100<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>;  <span class="comment">// Set trace flag</span>
02083                 <span class="keywordflow">if</span> (!(<a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[BpNum].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o1">Flags</a> &amp;
02084                         DBGKD_INTERNAL_BP_FLAG_COUNTONLY)) {
02085                     <a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[BpNum].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o10">ReturnAddress</a> =
02086                                     <a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a8">KdpGetReturnAddress</a>( ContextRecord );
02087                 }
02088                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02089             }
02090         }
02091     } <span class="comment">/* if breakpoint */</span>
02092 
02093 <span class="comment">//  if (AfterSC) {</span>
02094 <span class="comment">//      DPRINT(( "1: KdpCurrentSymbolStart %x  KdpCurrentSymbolEnd %x\n", KdpCurrentSymbolStart, KdpCurrentSymbolEnd ));</span>
02095 <span class="comment">//  }</span>
02096 
02097     <span class="keywordflow">if</span> ((AfterSC || ExceptionRecord-&gt;ExceptionCode == STATUS_SINGLE_STEP) &amp;&amp;
02098         <a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a1">KdpCurrentSymbolStart</a> != 0 &amp;&amp;
02099         ((<a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a2">KdpCurrentSymbolEnd</a> == 0 &amp;&amp; ContextRecord-&gt;Esp &lt;= <a class="code" href="../../d8/d5/kddata_8c.html#a64">InitialSP</a>) ||
02100          (<a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a1">KdpCurrentSymbolStart</a> &lt;= pc &amp;&amp; pc &lt; <a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a2">KdpCurrentSymbolEnd</a>))) {
02101         ULONG lc;
02102         BOOLEAN IsSpecialCall;
02103 
02104         <span class="comment">//</span>
02105         <span class="comment">//  We've taken a step trace, but are still executing in the current</span>
02106         <span class="comment">//  function.  Remember that we executed an instruction and see if the</span>
02107         <span class="comment">//  instruction changes the call level.</span>
02108         <span class="comment">//</span>
02109 
02110         lc = <a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a5">KdpLevelChange</a>( pc, ContextRecord, &amp;IsSpecialCall );
02111         <a class="code" href="../../d8/d5/kddata_8c.html#a81">InstructionsTraced</a>++;
02112         <a class="code" href="../../d8/d5/kddata_8c.html#a83">CallLevelChange</a> += lc;
02113 
02114         <span class="comment">//</span>
02115         <span class="comment">//  See if instruction is a transfer to a special routine, one that we</span>
02116         <span class="comment">//  cannot trace through since it may swap contexts</span>
02117         <span class="comment">//</span>
02118 
02119         <span class="keywordflow">if</span> (IsSpecialCall) {
02120 
02121 <span class="comment">//  DPRINT( ("2: pc=%x, level change %d\n", pc, lc) );</span>
02122 
02123             <span class="comment">//</span>
02124             <span class="comment">//  We are about to transfer to a special call routine.  Since we</span>
02125             <span class="comment">//  cannot trace through this routine, we execute it atomically by</span>
02126             <span class="comment">//  setting a breakpoint at the next logical offset.</span>
02127             <span class="comment">//</span>
02128             <span class="comment">//  Note in the case of an indirect jump to a special call routine, the</span>
02129             <span class="comment">//  level change will be -1 and the next offset will be the ULONG that's</span>
02130             <span class="comment">//  on the top of the stack.</span>
02131             <span class="comment">//</span>
02132             <span class="comment">//  However, we've already adjusted the level based on this</span>
02133             <span class="comment">//  instruction.  We need to undo this except for the magic -1 call.</span>
02134             <span class="comment">//</span>
02135 
02136             <span class="keywordflow">if</span> (lc != -1) {
02137                 <a class="code" href="../../d8/d5/kddata_8c.html#a83">CallLevelChange</a> -= lc;
02138             }
02139 
02140             <span class="comment">//</span>
02141             <span class="comment">//  Set up for stepping over a procedure</span>
02142             <span class="comment">//</span>
02143 
02144             <a class="code" href="../../d8/d5/kddata_8c.html#a75">WatchStepOver</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02145             <a class="code" href="../../d8/d5/kddata_8c.html#a79">WatchStepOverBreakAddr</a> = <a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a9">KdpGetCallNextOffset</a>( pc, ContextRecord );
02146             <a class="code" href="../../d8/d5/kddata_8c.html#a76">WSOThread</a> = (PVOID)<a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a3">KeGetCurrentThread</a>( );
02147             <a class="code" href="../../d8/d5/kddata_8c.html#a77">WSOEsp</a> = ContextRecord-&gt;Esp;
02148 
02149             <span class="comment">//</span>
02150             <span class="comment">//  Establish the breakpoint</span>
02151             <span class="comment">//</span>
02152 
02153             <a class="code" href="../../d8/d5/kddata_8c.html#a78">WatchStepOverHandle</a> = <a class="code" href="../../d1/d7/4_2kdp_8h.html#a104">KdpAddBreakpoint</a>( (PVOID)WatchStepOverBreakAddr );
02154 
02155 
02156             <span class="comment">//</span>
02157             <span class="comment">//  Note that we are continuing rather than tracing and rely on hitting</span>
02158             <span class="comment">//  the breakpoint in the current thread context to resume the watch</span>
02159             <span class="comment">//  action.</span>
02160             <span class="comment">//</span>
02161 
02162             ContextRecord-&gt;EFlags &amp;= ~0x100<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>;
02163             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02164         }
02165 
02166         <span class="comment">//</span>
02167         <span class="comment">//  Resume execution with the trace flag set.  Avoid going over the wire to</span>
02168         <span class="comment">//  the remote debugger.</span>
02169         <span class="comment">//</span>
02170 
02171         ContextRecord-&gt;EFlags |= 0x100<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>;  <span class="comment">// Set trace flag</span>
02172 
02173         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02174     }
02175 
02176     <span class="keywordflow">if</span> ((AfterSC || (ExceptionRecord-&gt;ExceptionCode == STATUS_SINGLE_STEP)) &amp;&amp;
02177         (<a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a1">KdpCurrentSymbolStart</a> != 0)) {
02178         <span class="comment">//</span>
02179         <span class="comment">// We're WatchTracing, but have just changed symbol range.</span>
02180         <span class="comment">// Fill in the call record and return to the debugger if</span>
02181         <span class="comment">// either we're full or the pc is outside of the known</span>
02182         <span class="comment">// symbol scopes.  Otherwise, resume stepping.</span>
02183         <span class="comment">//</span>
02184         <span class="keywordtype">int</span> lc;
02185         BOOLEAN IsSpecialCall;
02186 
02187         <a class="code" href="../../d8/d5/kddata_8c.html#a81">InstructionsTraced</a>++; <span class="comment">// don't forget to count the call/ret instruction.</span>
02188 
02189 <span class="comment">//  if (AfterSC) {</span>
02190 <span class="comment">//      DPRINT(( "3: InstrCountInternal: %x\n", InstrCountInternal ));</span>
02191 <span class="comment">//  }</span>
02192 
02193         <span class="keywordflow">if</span> (<a class="code" href="../../d8/d5/kddata_8c.html#a85">InstrCountInternal</a>) {
02194 
02195             <span class="comment">// We've just finished processing a non-COUNTONLY breakpoint.</span>
02196             <span class="comment">// Record the appropriate data and resume full speed execution.</span>
02197 
02198             SkippingWhichBP((PVOID)<a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a3">KeGetCurrentThread</a>(),&amp;SkippedBPNum);
02199 
02200             <a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[SkippedBPNum].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o2">Calls</a>++;
02201 
02202 
02203             <span class="keywordflow">if</span> (<a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[SkippedBPNum].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o5">MinInstructions</a> &gt; <a class="code" href="../../d8/d5/kddata_8c.html#a81">InstructionsTraced</a>) {
02204                 <a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[SkippedBPNum].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o5">MinInstructions</a> = <a class="code" href="../../d8/d5/kddata_8c.html#a81">InstructionsTraced</a>;
02205             }
02206             <span class="keywordflow">if</span> (<a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[SkippedBPNum].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o6">MaxInstructions</a> &lt; <a class="code" href="../../d8/d5/kddata_8c.html#a81">InstructionsTraced</a>) {
02207                 <a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[SkippedBPNum].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o6">MaxInstructions</a> = <a class="code" href="../../d8/d5/kddata_8c.html#a81">InstructionsTraced</a>;
02208             }
02209             <a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[SkippedBPNum].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o7">TotalInstructions</a> += <a class="code" href="../../d8/d5/kddata_8c.html#a81">InstructionsTraced</a>;
02210 
02211             <a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[SkippedBPNum].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o9">Thread</a> = 0;
02212 
02213             <a class="code" href="../../d8/d5/kddata_8c.html#a74">IntBPsSkipping</a>--;
02214             <a class="code" href="../../d8/d5/kddata_8c.html#a85">InstrCountInternal</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02215             <a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a1">KdpCurrentSymbolStart</a> = 0;
02216             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a140">KdpRestoreAllBreakpoints</a>();
02217 
02218             <span class="keywordflow">if</span> (<a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[SkippedBPNum].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o1">Flags</a> &amp;
02219                     DBGKD_INTERNAL_BP_FLAG_DYING) {
02220                 <a class="code" href="../../d1/d7/4_2kdp_8h.html#a105">KdpDeleteBreakpoint</a>(KdpInternalBPs[SkippedBPNum].Handle);
02221                 <a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[SkippedBPNum].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o1">Flags</a> |=
02222                         DBGKD_INTERNAL_BP_FLAG_INVALID; <span class="comment">// bye, bye</span>
02223             }
02224 
02225             ContextRecord-&gt;EFlags &amp;= ~0x100<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>; <span class="comment">// clear trace flag</span>
02226             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>; <span class="comment">// Back to normal execution.</span>
02227         }
02228 
02229         <span class="keywordflow">if</span> (TraceDataRecordCallInfo( InstructionsTraced, CallLevelChange, pc)) {
02230 
02231             <span class="comment">//</span>
02232             <span class="comment">//  Everything was cool internally.  We can keep executing without</span>
02233             <span class="comment">//  going back to the remote debugger.</span>
02234             <span class="comment">//</span>
02235             <span class="comment">//  We have to compute lc after calling</span>
02236             <span class="comment">//  TraceDataRecordCallInfo, because LevelChange relies on</span>
02237             <span class="comment">//  KdpCurrentSymbolStart and KdpCurrentSymbolEnd corresponding to</span>
02238             <span class="comment">//  the pc.</span>
02239             <span class="comment">//</span>
02240 
02241             lc = <a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a5">KdpLevelChange</a>( pc, ContextRecord, &amp;IsSpecialCall );
02242             <a class="code" href="../../d8/d5/kddata_8c.html#a81">InstructionsTraced</a> = 0;
02243             <a class="code" href="../../d8/d5/kddata_8c.html#a83">CallLevelChange</a> = lc;
02244 
02245             <span class="comment">//</span>
02246             <span class="comment">//  See if instruction is a transfer to a special routine, one that we</span>
02247             <span class="comment">//  cannot trace through since it may swap contexts</span>
02248             <span class="comment">//</span>
02249 
02250             <span class="keywordflow">if</span> (IsSpecialCall) {
02251 
02252 <span class="comment">//  DPRINT(( "4: pc=%x, level change %d\n", pc, lc));</span>
02253 
02254                 <span class="comment">//</span>
02255                 <span class="comment">//  We are about to transfer to a special call routine.  Since we</span>
02256                 <span class="comment">//  cannot trace through this routine, we execute it atomically by</span>
02257                 <span class="comment">//  setting a breakpoint at the next logical offset.</span>
02258                 <span class="comment">//</span>
02259                 <span class="comment">//  Note in the case of an indirect jump to a special call routine, the</span>
02260                 <span class="comment">//  level change will be -1 and the next offset will be the ULONG that's</span>
02261                 <span class="comment">//  on the top of the stack.</span>
02262                 <span class="comment">//</span>
02263                 <span class="comment">//  However, we've already adjusted the level based on this</span>
02264                 <span class="comment">//  instruction.  We need to undo this except for the magic -1 call.</span>
02265                 <span class="comment">//</span>
02266 
02267                 <span class="keywordflow">if</span> (lc != -1) {
02268                     <a class="code" href="../../d8/d5/kddata_8c.html#a83">CallLevelChange</a> -= lc;
02269                 }
02270 
02271                 <span class="comment">//</span>
02272                 <span class="comment">//  Set up for stepping over a procedure</span>
02273                 <span class="comment">//</span>
02274 
02275                 <a class="code" href="../../d8/d5/kddata_8c.html#a75">WatchStepOver</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02276                 <a class="code" href="../../d8/d5/kddata_8c.html#a76">WSOThread</a> = (PVOID)<a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a3">KeGetCurrentThread</a>();
02277 
02278                 <span class="comment">//</span>
02279                 <span class="comment">//  Establish the breakpoint</span>
02280                 <span class="comment">//</span>
02281 
02282                 <a class="code" href="../../d8/d5/kddata_8c.html#a78">WatchStepOverHandle</a> =
02283                     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a104">KdpAddBreakpoint</a>( (PVOID)<a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a9">KdpGetCallNextOffset</a>( pc, ContextRecord ));
02284 
02285                 <span class="comment">//</span>
02286                 <span class="comment">//  Resume execution with the trace flag set.  Avoid going over the wire to</span>
02287                 <span class="comment">//  the remote debugger.</span>
02288                 <span class="comment">//</span>
02289 
02290                 ContextRecord-&gt;EFlags &amp;= ~0x100<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>;
02291                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02292             }
02293 
02294             ContextRecord-&gt;EFlags |= 0x100<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>; <span class="comment">// Set trace flag</span>
02295             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>; <span class="comment">// Off we go</span>
02296         }
02297 
02298         lc = <a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a5">KdpLevelChange</a>( pc, ContextRecord, &amp;IsSpecialCall );
02299         <a class="code" href="../../d8/d5/kddata_8c.html#a81">InstructionsTraced</a> = 0;
02300         <a class="code" href="../../d8/d5/kddata_8c.html#a83">CallLevelChange</a> = lc;
02301 
02302         <span class="comment">// We need to go back to the remote debugger.  Just fall through.</span>
02303 
02304         <span class="keywordflow">if</span> ((lc != 0) &amp;&amp; IsSpecialCall) {
02305             <span class="comment">// We're hosed</span>
02306             <a class="code" href="../../d0/d7/kdp_8h.html#a16">DPRINT</a>(( <span class="stringliteral">"Special call on first entry to symbol scope @ %x\n"</span>, pc ));
02307         }
02308     }
02309 
02310     <a class="code" href="../../d8/d5/kddata_8c.html#a82">SymbolRecorded</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02311     <a class="code" href="../../d8/d5/kddata_8c.html#a84">oldpc</a> = pc;
02312 
02313     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02314 }
02315 <span class="preprocessor">#endif // i386</span>
02316 <span class="preprocessor"></span>
02317 BOOLEAN
<a name="l02318"></a><a class="code" href="../../d1/d7/4_2kdp_8h.html#a119">02318</a> <a class="code" href="../../d1/d7/4_2kdp_8h.html#a119">KdpSwitchProcessor</a> (
02319     IN PEXCEPTION_RECORD ExceptionRecord,
02320     IN OUT PCONTEXT ContextRecord,
02321     IN BOOLEAN SecondChance
02322     )
02323 {
02324     BOOLEAN <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
02325 
02326     <span class="comment">//</span>
02327     <span class="comment">// Save port state</span>
02328     <span class="comment">//</span>
02329 
02330     <a class="code" href="../../d2/d7/hal_8h.html#a204">KdPortSave</a> ();
02331 
02332     <span class="comment">//</span>
02333     <span class="comment">// Process state change for this processor</span>
02334     <span class="comment">//</span>
02335 
02336     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d1/d7/4_2kdp_8h.html#a120">KdpReportExceptionStateChange</a> (
02337                 ExceptionRecord,
02338                 ContextRecord,
02339                 SecondChance
02340                 );
02341 
02342     <span class="comment">//</span>
02343     <span class="comment">// Restore port state and return status</span>
02344     <span class="comment">//</span>
02345 
02346     <a class="code" href="../../d2/d7/hal_8h.html#a203">KdPortRestore</a> ();
02347     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
02348 }
02349 
02350 BOOLEAN
<a name="l02351"></a><a class="code" href="../../d1/d7/4_2kdp_8h.html#a120">02351</a> <a class="code" href="../../d1/d7/4_2kdp_8h.html#a120">KdpReportExceptionStateChange</a> (
02352     IN PEXCEPTION_RECORD ExceptionRecord,
02353     IN OUT PCONTEXT ContextRecord,
02354     IN BOOLEAN SecondChance
02355     )
02356 
02357 <span class="comment">/*++</span>
02358 <span class="comment"></span>
02359 <span class="comment">Routine Description:</span>
02360 <span class="comment"></span>
02361 <span class="comment">    This routine sends an exception state change packet to the kernel</span>
02362 <span class="comment">    debugger and waits for a manipulate state message.</span>
02363 <span class="comment"></span>
02364 <span class="comment">Arguments:</span>
02365 <span class="comment"></span>
02366 <span class="comment">    ExceptionRecord - Supplies a pointer to an exception record.</span>
02367 <span class="comment"></span>
02368 <span class="comment">    ContextRecord - Supplies a pointer to a context record.</span>
02369 <span class="comment"></span>
02370 <span class="comment">    SecondChance - Supplies a boolean value that determines whether this is</span>
02371 <span class="comment">        the first or second chance for the exception.</span>
02372 <span class="comment"></span>
02373 <span class="comment">Return Value:</span>
02374 <span class="comment"></span>
02375 <span class="comment">    A value of TRUE is returned if the exception is handled. Otherwise, a</span>
02376 <span class="comment">    value of FALSE is returned.</span>
02377 <span class="comment"></span>
02378 <span class="comment">--*/</span>
02379 
02380 {
02381     STRING MessageData;
02382     STRING MessageHeader;
02383     DBGKD_WAIT_STATE_CHANGE WaitStateChange;
02384     <a class="code" href="../../d4/d9/ke_8h.html#a408">KCONTINUE_STATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
02385 
02386 <span class="preprocessor">#if i386</span>
02387 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (<a class="code" href="../../d2/d9/4_2i386_2kdtrap_8c.html#a3">KdpCheckTracePoint</a>(ExceptionRecord,ContextRecord)) <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02388 <span class="preprocessor">#endif</span>
02389 <span class="preprocessor"></span>
02390     <span class="keywordflow">do</span> {
02391 
02392         <span class="comment">//</span>
02393         <span class="comment">// Construct the wait state change message and message descriptor.</span>
02394         <span class="comment">//</span>
02395 
02396         <a class="code" href="../../d1/d7/4_2kdp_8h.html#a114">KdpSetStateChange</a>(&amp;WaitStateChange,
02397                             ExceptionRecord,
02398                             ContextRecord,
02399                             SecondChance
02400                             );
02401 
02402         MessageHeader.Length = <span class="keyword">sizeof</span>(DBGKD_WAIT_STATE_CHANGE);
02403         MessageHeader.Buffer = (PCHAR)&amp;WaitStateChange;
02404 
02405 <span class="preprocessor">#if i386</span>
02406 <span class="preprocessor"></span>        <span class="comment">//</span>
02407         <span class="comment">// Construct the wait state change data and data descriptor.</span>
02408         <span class="comment">//</span>
02409 
02410         DumpTraceData(&amp;MessageData);
02411 <span class="preprocessor">#else</span>
02412 <span class="preprocessor"></span>        MessageData.Length = 0;
02413 <span class="preprocessor">#endif</span>
02414 <span class="preprocessor"></span>
02415         <span class="comment">//</span>
02416         <span class="comment">// Send packet to the kernel debugger on the host machine,</span>
02417         <span class="comment">// wait for answer.</span>
02418         <span class="comment">//</span>
02419 
02420         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d1/d7/4_2kdp_8h.html#a122">KdpSendWaitContinue</a>(
02421                     PACKET_TYPE_KD_STATE_CHANGE,
02422                     &amp;MessageHeader,
02423                     &amp;MessageData,
02424                     ContextRecord
02425                     );
02426 
02427     } <span class="keywordflow">while</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == <a class="code" href="../../d4/d9/ke_8h.html#a408a228">ContinueProcessorReselected</a>) ;
02428 
02429     <span class="keywordflow">return</span> (BOOLEAN) <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
02430 }
02431 
02432 
02433 BOOLEAN
<a name="l02434"></a><a class="code" href="../../d1/d7/4_2kdp_8h.html#a121">02434</a> <a class="code" href="../../d1/d7/4_2kdp_8h.html#a121">KdpReportLoadSymbolsStateChange</a> (
02435     IN PSTRING PathName,
02436     IN <a class="code" href="../../d6/d5/struct__KD__SYMBOLS__INFO.html">PKD_SYMBOLS_INFO</a> SymbolInfo,
02437     IN BOOLEAN UnloadSymbols,
02438     IN OUT PCONTEXT ContextRecord
02439     )
02440 
02441 <span class="comment">/*++</span>
02442 <span class="comment"></span>
02443 <span class="comment">Routine Description:</span>
02444 <span class="comment"></span>
02445 <span class="comment">    This routine sends a load symbols state change packet to the kernel</span>
02446 <span class="comment">    debugger and waits for a manipulate state message.</span>
02447 <span class="comment"></span>
02448 <span class="comment">Arguments:</span>
02449 <span class="comment"></span>
02450 <span class="comment">    PathName - Supplies a pointer to the pathname of the image whose</span>
02451 <span class="comment">        symbols are to be loaded.</span>
02452 <span class="comment"></span>
02453 <span class="comment">    BaseOfDll - Supplies the base address where the image was loaded.</span>
02454 <span class="comment"></span>
02455 <span class="comment">    ProcessId - Unique 32-bit identifier for process that is using</span>
02456 <span class="comment">        the symbols.  -1 for system process.</span>
02457 <span class="comment"></span>
02458 <span class="comment">    CheckSum - Unique 32-bit identifier from image header.</span>
02459 <span class="comment"></span>
02460 <span class="comment">    UnloadSymbol - TRUE if the symbols that were previously loaded for</span>
02461 <span class="comment">        the named image are to be unloaded from the debugger.</span>
02462 <span class="comment"></span>
02463 <span class="comment">Return Value:</span>
02464 <span class="comment"></span>
02465 <span class="comment">    A value of TRUE is returned if the exception is handled. Otherwise, a</span>
02466 <span class="comment">    value of FALSE is returned.</span>
02467 <span class="comment"></span>
02468 <span class="comment">--*/</span>
02469 
02470 {
02471 
02472     PSTRING AdditionalData;
02473     STRING MessageData;
02474     STRING MessageHeader;
02475     DBGKD_WAIT_STATE_CHANGE WaitStateChange;
02476     <a class="code" href="../../d4/d9/ke_8h.html#a408">KCONTINUE_STATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
02477 
02478     <span class="keywordflow">do</span> {
02479         <span class="comment">//</span>
02480         <span class="comment">// Construct the wait state change message and message descriptor.</span>
02481         <span class="comment">//</span>
02482 
02483         WaitStateChange.NewState = DbgKdLoadSymbolsStateChange;
02484         WaitStateChange.ProcessorLevel = <a class="code" href="../../d4/d9/ke_8h.html#a135">KeProcessorLevel</a>;
02485         WaitStateChange.Processor = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)<a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a2">KeGetCurrentPrcb</a>()-&gt;Number;
02486         WaitStateChange.NumberProcessors = (ULONG)<a class="code" href="../../d4/d9/ke_8h.html#a133">KeNumberProcessors</a>;
02487         WaitStateChange.Thread = (PVOID)<a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a3">KeGetCurrentThread</a>();
02488         WaitStateChange.ProgramCounter = (PVOID)CONTEXT_TO_PROGRAM_COUNTER(ContextRecord);
02489         <a class="code" href="../../d1/d7/4_2kdp_8h.html#a113">KdpSetLoadState</a>(&amp;WaitStateChange, ContextRecord);
02490         WaitStateChange.u.LoadSymbols.UnloadSymbols = UnloadSymbols;
02491         WaitStateChange.u.LoadSymbols.BaseOfDll = SymbolInfo-&gt;BaseOfDll;
02492         WaitStateChange.u.LoadSymbols.ProcessId = (ULONG)SymbolInfo-&gt;ProcessId;
02493         WaitStateChange.u.LoadSymbols.CheckSum = SymbolInfo-&gt;CheckSum;
02494         WaitStateChange.u.LoadSymbols.SizeOfImage = SymbolInfo-&gt;SizeOfImage;
02495         <span class="keywordflow">if</span> (ARGUMENT_PRESENT( PathName )) {
02496             WaitStateChange.u.LoadSymbols.PathNameLength =
02497                 <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>(
02498                     (PCHAR)<a class="code" href="../../d8/d5/kddata_8c.html#a53">KdpPathBuffer</a>,
02499                     (PCHAR)PathName-&gt;Buffer,
02500                     PathName-&gt;Length
02501                     ) + 1;
02502 
02503             MessageData.Buffer = <a class="code" href="../../d8/d5/kddata_8c.html#a53">KdpPathBuffer</a>;
02504             MessageData.Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)WaitStateChange.u.LoadSymbols.PathNameLength;
02505             MessageData.Buffer[MessageData.Length-1] = <span class="charliteral">'\0'</span>;
02506             AdditionalData = &amp;MessageData;
02507         } <span class="keywordflow">else</span> {
02508             WaitStateChange.u.LoadSymbols.PathNameLength = 0;
02509             AdditionalData = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02510         }
02511 
02512         MessageHeader.Length = <span class="keyword">sizeof</span>(DBGKD_WAIT_STATE_CHANGE);
02513         MessageHeader.Buffer = (PCHAR)&amp;WaitStateChange;
02514 
02515         <span class="comment">//</span>
02516         <span class="comment">// Send packet to the kernel debugger on the host machine, wait</span>
02517         <span class="comment">// for the reply.</span>
02518         <span class="comment">//</span>
02519 
02520         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d1/d7/4_2kdp_8h.html#a122">KdpSendWaitContinue</a>(
02521                     PACKET_TYPE_KD_STATE_CHANGE,
02522                     &amp;MessageHeader,
02523                     AdditionalData,
02524                     ContextRecord
02525                     );
02526 
02527     } <span class="keywordflow">while</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == <a class="code" href="../../d4/d9/ke_8h.html#a408a228">ContinueProcessorReselected</a>);
02528 
02529     <span class="keywordflow">return</span> (BOOLEAN) <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
02530 }
02531 
02532 
02533 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l02534"></a><a class="code" href="../../d0/d7/kdp_8h.html#a113">02534</a> <a class="code" href="../../d1/d7/4_2kdp_8h.html#a125">KdpReadPhysicalMemory</a>(
02535     IN PDBGKD_MANIPULATE_STATE m,
02536     IN PSTRING AdditionalData,
02537     IN PCONTEXT Context
02538     )
02539 
02540 <span class="comment">/*++</span>
02541 <span class="comment"></span>
02542 <span class="comment">Routine Description:</span>
02543 <span class="comment"></span>
02544 <span class="comment">    This function is called in response to a read physical memory</span>
02545 <span class="comment">    state manipulation message. Its function is to read physical memory</span>
02546 <span class="comment">    and return.</span>
02547 <span class="comment"></span>
02548 <span class="comment">    N.B. This is now more dangerous than ever:  if the modified physical</span>
02549 <span class="comment">    memory is mapped to a virtual page which is protected as readonly text,</span>
02550 <span class="comment">    the memory manager will eventually bugcheck when it discovers that</span>
02551 <span class="comment">    the page has been modified.</span>
02552 <span class="comment"></span>
02553 <span class="comment">Arguments:</span>
02554 <span class="comment"></span>
02555 <span class="comment">    m - Supplies the state manipulation message.</span>
02556 <span class="comment"></span>
02557 <span class="comment">    AdditionalData - Supplies any additional data for the message.</span>
02558 <span class="comment"></span>
02559 <span class="comment">    Context - Supplies the current context.</span>
02560 <span class="comment"></span>
02561 <span class="comment">Return Value:</span>
02562 <span class="comment"></span>
02563 <span class="comment">    None.</span>
02564 <span class="comment"></span>
02565 <span class="comment">--*/</span>
02566 
02567 {
02568     PDBGKD_READ_MEMORY a = &amp;m-&gt;u.ReadMemory;
02569     ULONG Length;
02570     STRING MessageHeader;
02571     PVOID VirtualAddress;
02572     PHYSICAL_ADDRESS Source;
02573     PUCHAR Destination;
02574     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> NumberBytes;
02575     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> BytesLeft;
02576 
02577     MessageHeader.Length = <span class="keyword">sizeof</span>(*m);
02578     MessageHeader.Buffer = (PCHAR)m;
02579 
02580     <span class="comment">//</span>
02581     <span class="comment">// make sure that nothing but a read memory message was transmitted</span>
02582     <span class="comment">//</span>
02583 
02584     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(AdditionalData-&gt;Length == 0);
02585 
02586     <span class="comment">//</span>
02587     <span class="comment">// Trim transfer count to fit in a single message</span>
02588     <span class="comment">//</span>
02589 
02590     <span class="keywordflow">if</span> (a-&gt;TransferCount &gt; (PACKET_MAX_SIZE - <span class="keyword">sizeof</span>(DBGKD_MANIPULATE_STATE))) {
02591         Length = PACKET_MAX_SIZE - <span class="keyword">sizeof</span>(DBGKD_MANIPULATE_STATE);
02592     } <span class="keywordflow">else</span> {
02593         Length = a-&gt;TransferCount;
02594     }
02595 
02596     <span class="comment">//</span>
02597     <span class="comment">// Since the MmDbgTranslatePhysicalAddress only maps in one physical</span>
02598     <span class="comment">// page at a time, we need to break the memory move up into smaller</span>
02599     <span class="comment">// moves which don't cross page boundaries.  There are two cases we</span>
02600     <span class="comment">// need to deal with.  The area to be moved may start and end on the</span>
02601     <span class="comment">// same page, or it may start and end on different pages (with an</span>
02602     <span class="comment">// arbitrary number of pages in between)</span>
02603     <span class="comment">//</span>
02604     Source.QuadPart = (ULONG_PTR)a-&gt;TargetBaseAddress;
02605     Destination = AdditionalData-&gt;Buffer;
02606     BytesLeft = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)Length;
02607     <span class="keywordflow">if</span>(<a class="code" href="../../d2/d1/mm_8h.html#a7">PAGE_ALIGN</a>((PUCHAR)a-&gt;TargetBaseAddress) ==
02608        <a class="code" href="../../d2/d1/mm_8h.html#a7">PAGE_ALIGN</a>((PUCHAR)(a-&gt;TargetBaseAddress)+Length)) {
02609         <span class="comment">//</span>
02610         <span class="comment">// Memory move starts and ends on the same page.</span>
02611         <span class="comment">//</span>
02612         VirtualAddress=<a class="code" href="../../d4/d6/ppc_2debugsup_8c.html#a4">MmDbgTranslatePhysicalAddress</a>(Source);
02613         <span class="keywordflow">if</span> (VirtualAddress == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02614             AdditionalData-&gt;Length = 0;
02615         } <span class="keywordflow">else</span> {
02616             AdditionalData-&gt;Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)<a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>(
02617                                                 Destination,
02618                                                 VirtualAddress,
02619                                                 BytesLeft
02620                                                 );
02621             BytesLeft -= AdditionalData-&gt;Length;
02622         }
02623     } <span class="keywordflow">else</span> {
02624         <span class="comment">//</span>
02625         <span class="comment">// Memory move spans page boundaries</span>
02626         <span class="comment">//</span>
02627         VirtualAddress=<a class="code" href="../../d4/d6/ppc_2debugsup_8c.html#a4">MmDbgTranslatePhysicalAddress</a>(Source);
02628         <span class="keywordflow">if</span> (VirtualAddress == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02629             AdditionalData-&gt;Length = 0;
02630         } <span class="keywordflow">else</span> {
02631             NumberBytes = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - <a class="code" href="../../d2/d1/mm_8h.html#a6">BYTE_OFFSET</a>(VirtualAddress));
02632             AdditionalData-&gt;Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)<a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>(
02633                                             Destination,
02634                                             VirtualAddress,
02635                                             NumberBytes
02636                                             );
02637             Source.LowPart += NumberBytes;
02638             Destination += NumberBytes;
02639             BytesLeft -= NumberBytes;
02640             <span class="keywordflow">while</span>(BytesLeft &gt; 0) {
02641                 <span class="comment">//</span>
02642                 <span class="comment">// Transfer a full page or the last bit,</span>
02643                 <span class="comment">// whichever is smaller.</span>
02644                 <span class="comment">//</span>
02645                 VirtualAddress = <a class="code" href="../../d4/d6/ppc_2debugsup_8c.html#a4">MmDbgTranslatePhysicalAddress</a>(Source);
02646                 <span class="keywordflow">if</span> (VirtualAddress == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02647                     <span class="keywordflow">break</span>;
02648                 } <span class="keywordflow">else</span> {
02649                     NumberBytes = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>) ((<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> &lt; BytesLeft) ? <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> : BytesLeft);
02650                     AdditionalData-&gt;Length += (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)<a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>(
02651                                                     Destination,
02652                                                     VirtualAddress,
02653                                                     NumberBytes
02654                                                     );
02655                     Source.LowPart += NumberBytes;
02656                     Destination += NumberBytes;
02657                     BytesLeft -= NumberBytes;
02658                 }
02659             }
02660         }
02661     }
02662 
02663     <span class="keywordflow">if</span> (Length == AdditionalData-&gt;Length) {
02664         m-&gt;ReturnStatus = STATUS_SUCCESS;
02665     } <span class="keywordflow">else</span> {
02666         m-&gt;ReturnStatus = STATUS_UNSUCCESSFUL;
02667     }
02668     a-&gt;ActualBytesRead = AdditionalData-&gt;Length;
02669 
02670     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a116">KdpSendPacket</a>(
02671                   PACKET_TYPE_KD_STATE_MANIPULATE,
02672                   &amp;MessageHeader,
02673                   AdditionalData
02674                   );
02675     UNREFERENCED_PARAMETER(Context);
02676 }
02677 
02678 
02679 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l02680"></a><a class="code" href="../../d0/d7/kdp_8h.html#a114">02680</a> <a class="code" href="../../d1/d7/4_2kdp_8h.html#a126">KdpWritePhysicalMemory</a>(
02681     IN PDBGKD_MANIPULATE_STATE m,
02682     IN PSTRING AdditionalData,
02683     IN PCONTEXT Context
02684     )
02685 
02686 <span class="comment">/*++</span>
02687 <span class="comment"></span>
02688 <span class="comment">Routine Description:</span>
02689 <span class="comment"></span>
02690 <span class="comment">    This function is called in response to a write physical memory</span>
02691 <span class="comment">    state manipulation message. Its function is to write physical memory</span>
02692 <span class="comment">    and return.</span>
02693 <span class="comment"></span>
02694 <span class="comment">Arguments:</span>
02695 <span class="comment"></span>
02696 <span class="comment">    m - Supplies the state manipulation message.</span>
02697 <span class="comment"></span>
02698 <span class="comment">    AdditionalData - Supplies any additional data for the message.</span>
02699 <span class="comment"></span>
02700 <span class="comment">    Context - Supplies the current context.</span>
02701 <span class="comment"></span>
02702 <span class="comment">Return Value:</span>
02703 <span class="comment"></span>
02704 <span class="comment">    None.</span>
02705 <span class="comment"></span>
02706 <span class="comment">--*/</span>
02707 
02708 {
02709     PDBGKD_WRITE_MEMORY a = &amp;m-&gt;u.WriteMemory;
02710     ULONG Length;
02711     STRING MessageHeader;
02712     PVOID VirtualAddress;
02713     PHYSICAL_ADDRESS Destination;
02714     PUCHAR Source;
02715     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> NumberBytes;
02716     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> BytesLeft;
02717 
02718     MessageHeader.Length = <span class="keyword">sizeof</span>(*m);
02719     MessageHeader.Buffer = (PCHAR)m;
02720 
02721 
02722     <span class="comment">//</span>
02723     <span class="comment">// Since the MmDbgTranslatePhysicalAddress only maps in one physical</span>
02724     <span class="comment">// page at a time, we need to break the memory move up into smaller</span>
02725     <span class="comment">// moves which don't cross page boundaries.  There are two cases we</span>
02726     <span class="comment">// need to deal with.  The area to be moved may start and end on the</span>
02727     <span class="comment">// same page, or it may start and end on different pages (with an</span>
02728     <span class="comment">// arbitrary number of pages in between)</span>
02729     <span class="comment">//</span>
02730     Destination.QuadPart = (ULONG_PTR)a-&gt;TargetBaseAddress;
02731     Source = AdditionalData-&gt;Buffer;
02732     BytesLeft = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>) a-&gt;TransferCount;
02733     <span class="keywordflow">if</span>(<a class="code" href="../../d2/d1/mm_8h.html#a7">PAGE_ALIGN</a>((PUCHAR)Destination.LowPart) ==
02734        <a class="code" href="../../d2/d1/mm_8h.html#a7">PAGE_ALIGN</a>((PUCHAR)(Destination.LowPart)+BytesLeft)) {
02735         <span class="comment">//</span>
02736         <span class="comment">// Memory move starts and ends on the same page.</span>
02737         <span class="comment">//</span>
02738         VirtualAddress=<a class="code" href="../../d4/d6/ppc_2debugsup_8c.html#a4">MmDbgTranslatePhysicalAddress</a>(Destination);
02739         Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)<a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>(
02740                                        VirtualAddress,
02741                                        Source,
02742                                        BytesLeft
02743                                       );
02744         BytesLeft -= (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>) Length;
02745     } <span class="keywordflow">else</span> {
02746         <span class="comment">//</span>
02747         <span class="comment">// Memory move spans page boundaries</span>
02748         <span class="comment">//</span>
02749         VirtualAddress=<a class="code" href="../../d4/d6/ppc_2debugsup_8c.html#a4">MmDbgTranslatePhysicalAddress</a>(Destination);
02750         NumberBytes = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>) (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - <a class="code" href="../../d2/d1/mm_8h.html#a6">BYTE_OFFSET</a>(VirtualAddress));
02751         Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)<a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>(
02752                                        VirtualAddress,
02753                                        Source,
02754                                        NumberBytes
02755                                       );
02756         Source += NumberBytes;
02757         Destination.LowPart += NumberBytes;
02758         BytesLeft -= NumberBytes;
02759         <span class="keywordflow">while</span>(BytesLeft &gt; 0) {
02760             <span class="comment">//</span>
02761             <span class="comment">// Transfer a full page or the last bit,</span>
02762             <span class="comment">// whichever is smaller.</span>
02763             <span class="comment">//</span>
02764             VirtualAddress = <a class="code" href="../../d4/d6/ppc_2debugsup_8c.html#a4">MmDbgTranslatePhysicalAddress</a>(Destination);
02765             NumberBytes = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>) ((<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> &lt; BytesLeft) ? <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> : BytesLeft);
02766             Length += (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)<a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>(
02767                                             VirtualAddress,
02768                                             Source,
02769                                             NumberBytes
02770                                            );
02771             Source += NumberBytes;
02772             Destination.LowPart += NumberBytes;
02773             BytesLeft -= NumberBytes;
02774         }
02775     }
02776 
02777 
02778     <span class="keywordflow">if</span> (Length == AdditionalData-&gt;Length) {
02779         m-&gt;ReturnStatus = STATUS_SUCCESS;
02780     } <span class="keywordflow">else</span> {
02781         m-&gt;ReturnStatus = STATUS_UNSUCCESSFUL;
02782     }
02783 
02784     a-&gt;ActualBytesWritten = Length;
02785 
02786     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a116">KdpSendPacket</a>(
02787                   PACKET_TYPE_KD_STATE_MANIPULATE,
02788                   &amp;MessageHeader,
02789                   <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>
02790                   );
02791     UNREFERENCED_PARAMETER(Context);
02792 }
02793 
02794 
02795 <span class="preprocessor">#if i386</span>
02796 <span class="preprocessor"></span><a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
02797 <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a6">KdpProcessInternalBreakpoint</a> (
02798     ULONG BreakpointNumber
02799     )
02800 {
02801     <span class="keyword">static</span> BOOLEAN timerStarted = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02802     LARGE_INTEGER dueTime;
02803 
02804     <span class="keywordflow">if</span> ( !<a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[BreakpointNumber].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o1">Flags</a> &amp;
02805           DBGKD_INTERNAL_BP_FLAG_COUNTONLY ) {
02806         <span class="keywordflow">return</span>;     <span class="comment">// We only deal with COUNTONLY breakpoints</span>
02807     }
02808 
02809     <span class="comment">//</span>
02810     <span class="comment">// We've hit a real internal breakpoint; make sure the timeout is</span>
02811     <span class="comment">// kicked off.</span>
02812     <span class="comment">//</span>
02813 
02814     <span class="keywordflow">if</span> ( !timerStarted ) { <span class="comment">// ok, maybe there's a prettier way to do this.</span>
02815         dueTime.LowPart = (ULONG)(-1 * 10 * 1000 * 1000);
02816         dueTime.HighPart = -1;
02817         <a class="code" href="../../d4/d1/dpcobj_8c.html#a1">KeInitializeDpc</a>(
02818             &amp;InternalBreakpointCheckDpc,
02819             &amp;InternalBreakpointCheck,
02820             NULL
02821             );
02822         <a class="code" href="../../d3/d2/timerobj_8c.html#a1">KeInitializeTimer</a>( &amp;InternalBreakpointTimer );
02823         <a class="code" href="../../d3/d2/timerobj_8c.html#a6">KeSetTimer</a>(
02824             &amp;InternalBreakpointTimer,
02825             dueTime,
02826             &amp;InternalBreakpointCheckDpc
02827             );
02828         timerStarted = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02829     }
02830 
02831     <a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[BreakpointNumber].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o2">Calls</a>++;
02832 
02833 } <span class="comment">// KdpProcessInternalBreakpoint</span>
02834 <span class="preprocessor">#endif</span>
02835 <span class="preprocessor"></span>
02836 
02837 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l02838"></a><a class="code" href="../../d8/d3/kdapi_8c.html#a10">02838</a> <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a7">KdpGetVersion</a>(
02839     IN PDBGKD_MANIPULATE_STATE m
02840     )
02841 
02842 <span class="comment">/*++</span>
02843 <span class="comment"></span>
02844 <span class="comment">Routine Description:</span>
02845 <span class="comment"></span>
02846 <span class="comment">    This function returns to the caller a general information packet</span>
02847 <span class="comment">    that contains useful information to a debugger.  This packet is also</span>
02848 <span class="comment">    used for a debugger to determine if the writebreakpointex and</span>
02849 <span class="comment">    readbreakpointex apis are available.</span>
02850 <span class="comment"></span>
02851 <span class="comment">Arguments:</span>
02852 <span class="comment"></span>
02853 <span class="comment">    m - Supplies the state manipulation message.</span>
02854 <span class="comment"></span>
02855 <span class="comment">Return Value:</span>
02856 <span class="comment"></span>
02857 <span class="comment">    None.</span>
02858 <span class="comment"></span>
02859 <span class="comment">--*/</span>
02860 
02861 {
02862     STRING                   messageHeader;
02863 
02864 
02865     messageHeader.Length = <span class="keyword">sizeof</span>(*m);
02866     messageHeader.Buffer = (PCHAR)m;
02867 
02868     RtlZeroMemory(&amp;m-&gt;u.GetVersion, <span class="keyword">sizeof</span>(m-&gt;u.GetVersion));
02869     <span class="comment">//</span>
02870     <span class="comment">// the current build number</span>
02871     <span class="comment">//</span>
02872     m-&gt;u.GetVersion.MinorVersion = (<span class="keywordtype">short</span>)<a class="code" href="../../d5/d5/triage_8c.html#a0">NtBuildNumber</a>;
02873     m-&gt;u.GetVersion.MajorVersion = (<span class="keywordtype">short</span>)((<a class="code" href="../../d5/d5/triage_8c.html#a0">NtBuildNumber</a> &gt;&gt; 28) &amp; 0xFFFFFFF);
02874 
02875     <span class="comment">//</span>
02876     <span class="comment">// kd protocol version number.  this should be incremented if the</span>
02877     <span class="comment">// protocol changes.</span>
02878     <span class="comment">//</span>
02879     m-&gt;u.GetVersion.ProtocolVersion = 4;
02880     m-&gt;u.GetVersion.Flags = DBGKD_VERS_FLAG_DATA;
02881 
02882 <span class="preprocessor">#if !defined(NT_UP)</span>
02883 <span class="preprocessor"></span>    m-&gt;u.GetVersion.Flags |= DBGKD_VERS_FLAG_MP;
02884 <span class="preprocessor">#endif</span>
02885 <span class="preprocessor"></span>
02886 <span class="preprocessor">#if defined(_M_IX86)</span>
02887 <span class="preprocessor"></span>    m-&gt;u.GetVersion.MachineType = IMAGE_FILE_MACHINE_I386;
02888 <span class="preprocessor">#elif defined(_M_MRX000)</span>
02889 <span class="preprocessor"></span>    m-&gt;u.GetVersion.MachineType = IMAGE_FILE_MACHINE_R4000;
02890 <span class="preprocessor">#elif defined(_M_ALPHA)</span>
02891 <span class="preprocessor"></span>    m-&gt;u.GetVersion.MachineType = IMAGE_FILE_MACHINE_ALPHA;
02892 <span class="preprocessor">#if defined (_AXP64_)</span>
02893 <span class="preprocessor"></span>    m-&gt;u.GetVersion.Flags |= DBGKD_VERS_FLAG_PTR64;
02894 <span class="preprocessor">#endif</span>
02895 <span class="preprocessor"></span><span class="preprocessor">#elif defined(_M_PPC)</span>
02896 <span class="preprocessor"></span>    m-&gt;u.GetVersion.MachineType = IMAGE_FILE_MACHINE_POWERPC;
02897 <span class="preprocessor">#elif defined(_M_IA64)</span>
02898 <span class="preprocessor"></span>    m-&gt;u.GetVersion.MachineType = IMAGE_FILE_MACHINE_IA64;
02899     m-&gt;u.GetVersion.Flags |= DBGKD_VERS_FLAG_PTR64;
02900 <span class="preprocessor">#else</span>
02901 <span class="preprocessor"></span><span class="preprocessor">#error( "unknown target machine" );</span>
02902 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
02903 <span class="preprocessor"></span>
02904     <span class="comment">//</span>
02905     <span class="comment">// address of the loader table</span>
02906     <span class="comment">//</span>
02907     m-&gt;u.GetVersion.PsLoadedModuleList = (ULONG_PTR)&amp;<a class="code" href="../../d1/d9/ps_8h.html#a56">PsLoadedModuleList</a>;
02908 
02909     <span class="comment">//</span>
02910     <span class="comment">// If the debugger is being initialized during boot, PsNtosImageBase</span>
02911     <span class="comment">// and PsLoadedModuleList are not yet valid.  KdInitSystem got</span>
02912     <span class="comment">// the image base from the loader block.</span>
02913     <span class="comment">// On the other hand, if the debugger was initialized by a bugcheck,</span>
02914     <span class="comment">// it didn't get a loader block to look at, but the system was</span>
02915     <span class="comment">// running so the other variables are valid.</span>
02916     <span class="comment">//</span>
02917     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d5/kddata_8c.html#a94">KdpNtosImageBase</a>) {
02918         m-&gt;u.GetVersion.KernBase = (ULONG_PTR)<a class="code" href="../../d8/d5/kddata_8c.html#a94">KdpNtosImageBase</a>;
02919     } <span class="keywordflow">else</span> {
02920         m-&gt;u.GetVersion.KernBase = (ULONG_PTR)<a class="code" href="../../d1/d9/ps_8h.html#a54">PsNtosImageBase</a>;
02921     }
02922 
02923     <span class="comment">//</span>
02924     <span class="comment">// These fields are obsolete with the introduction of</span>
02925     <span class="comment">// KdDebuggerDataBlock.  They are being kept for a while</span>
02926     <span class="comment">// so people can still use their 4.0 debuggers.</span>
02927     <span class="comment">//</span>
02928     m-&gt;u.GetVersion.ThCallbackStack = FIELD_OFFSET(<a class="code" href="../../d1/d8/struct__KTHREAD.html">KTHREAD</a>, CallbackStack);
02929     m-&gt;u.GetVersion.KiCallUserMode = (ULONG_PTR)<a class="code" href="../../d0/d0/ki_8h.html#a98">KiCallUserMode</a>;
02930     m-&gt;u.GetVersion.KeUserCallbackDispatcher = (ULONG_PTR) <a class="code" href="../../d4/d9/ke_8h.html#a149">KeUserCallbackDispatcher</a>;
02931     m-&gt;u.GetVersion.NextCallback = FIELD_OFFSET(KCALLOUT_FRAME, CbStk);
02932 <span class="preprocessor">#if defined(_X86_)</span>
02933 <span class="preprocessor"></span>    m-&gt;u.GetVersion.FramePointer = FIELD_OFFSET(KCALLOUT_FRAME, Ebp);
02934 <span class="preprocessor">#endif</span>
02935 <span class="preprocessor"></span>    m-&gt;u.GetVersion.BreakpointWithStatus = (ULONG_PTR)<a class="code" href="../../d0/d7/kdp_8h.html#a130">RtlpBreakWithStatusInstruction</a>;
02936 
02937 
02938 
02939 
02940 
02941     m-&gt;u.GetVersion.DebuggerDataList = (ULONG_PTR)&amp;<a class="code" href="../../d8/d5/kddata_8c.html#a97">KdpDebuggerDataListHead</a>;
02942 
02943     <span class="comment">//</span>
02944     <span class="comment">// the usual stuff</span>
02945     <span class="comment">//</span>
02946     m-&gt;ReturnStatus = STATUS_SUCCESS;
02947     m-&gt;ApiNumber = DbgKdGetVersionApi;
02948 
02949     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a116">KdpSendPacket</a>(PACKET_TYPE_KD_STATE_MANIPULATE,
02950                   &amp;messageHeader,
02951                   <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>
02952                  );
02953 
02954     <span class="keywordflow">return</span>;
02955 } <span class="comment">// KdGetVersion</span>
02956 
02957 
02958 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l02959"></a><a class="code" href="../../d8/d3/kdapi_8c.html#a11">02959</a> <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a8">KdpNotSupported</a>(
02960     IN PDBGKD_MANIPULATE_STATE m
02961     )
02962 <span class="comment">/*++</span>
02963 <span class="comment"></span>
02964 <span class="comment">Routine Description:</span>
02965 <span class="comment"></span>
02966 <span class="comment">    This routine returns STATUS_UNSUCCESSFUL to the debugger</span>
02967 <span class="comment"></span>
02968 <span class="comment">Arguments:</span>
02969 <span class="comment"></span>
02970 <span class="comment">    m - Supplies a DBGKD_MANIPULATE_STATE struct to answer with</span>
02971 <span class="comment"></span>
02972 <span class="comment">Return Value:</span>
02973 <span class="comment"></span>
02974 <span class="comment">    0, to indicate that the system should not continue</span>
02975 <span class="comment"></span>
02976 <span class="comment">--*/</span>
02977 {
02978 
02979     STRING          MessageHeader;
02980     <span class="comment">//</span>
02981     <span class="comment">// setup packet</span>
02982     <span class="comment">//</span>
02983     MessageHeader.Length = <span class="keyword">sizeof</span>(*m);
02984     MessageHeader.Buffer = (PCHAR)m;
02985     m-&gt;ReturnStatus = STATUS_UNSUCCESSFUL;
02986 
02987     <span class="comment">//</span>
02988     <span class="comment">// send back our response</span>
02989     <span class="comment">//</span>
02990     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a116">KdpSendPacket</a>(
02991         PACKET_TYPE_KD_STATE_MANIPULATE,
02992         &amp;MessageHeader,
02993         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>
02994         );
02995 
02996     <span class="comment">//</span>
02997     <span class="comment">// return the caller's continue status value.  if this is a non-zero</span>
02998     <span class="comment">// value the system is continued using this value as the continuestatus.</span>
02999     <span class="comment">//</span>
03000 
03001     <span class="keywordflow">return</span> 0;
03002 
03003 } <span class="comment">// KdpNotSupported</span>
03004 
03005 
03006 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l03007"></a><a class="code" href="../../d8/d3/kdapi_8c.html#a12">03007</a> <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a9">KdpCauseBugCheck</a>(
03008     IN PDBGKD_MANIPULATE_STATE m
03009     )
03010 
03011 <span class="comment">/*++</span>
03012 <span class="comment"></span>
03013 <span class="comment">Routine Description:</span>
03014 <span class="comment"></span>
03015 <span class="comment">    This routine causes a bugcheck.  It is used for testing the debugger.</span>
03016 <span class="comment"></span>
03017 <span class="comment">Arguments:</span>
03018 <span class="comment"></span>
03019 <span class="comment">    m - Supplies the state manipulation message.</span>
03020 <span class="comment"></span>
03021 <span class="comment">Return Value:</span>
03022 <span class="comment"></span>
03023 <span class="comment">    None.</span>
03024 <span class="comment"></span>
03025 <span class="comment">--*/</span>
03026 
03027 {
03028 
03029     <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a>( *(PULONG)&amp;m-&gt;u, 0, 0, 0, 0 );
03030 
03031 } <span class="comment">// KdCauseBugCheck</span>
03032 
03033 
03034 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l03035"></a><a class="code" href="../../d8/d3/kdapi_8c.html#a13">03035</a> <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a10">KdpWriteBreakPointEx</a>(
03036     IN PDBGKD_MANIPULATE_STATE m,
03037     IN PSTRING AdditionalData,
03038     IN PCONTEXT Context
03039     )
03040 
03041 <span class="comment">/*++</span>
03042 <span class="comment"></span>
03043 <span class="comment">Routine Description:</span>
03044 <span class="comment"></span>
03045 <span class="comment">    This function is called in response of a write breakpoint state 'ex'</span>
03046 <span class="comment">    manipulation message.  Its function is to clear breakpoints, write</span>
03047 <span class="comment">    new breakpoints, and continue the target system.  The clearing of</span>
03048 <span class="comment">    breakpoints is conditional based on the presence of breakpoint handles.</span>
03049 <span class="comment">    The setting of breakpoints is conditional based on the presence of</span>
03050 <span class="comment">    valid, non-zero, addresses.  The continueing of the target system</span>
03051 <span class="comment">    is conditional based on a non-zero continuestatus.</span>
03052 <span class="comment"></span>
03053 <span class="comment">    This api allows a debugger to clear breakpoints, add new breakpoint,</span>
03054 <span class="comment">    and continue the target system all in one api packet.  This reduces the</span>
03055 <span class="comment">    amount of traffic across the wire and greatly improves source stepping.</span>
03056 <span class="comment"></span>
03057 <span class="comment"></span>
03058 <span class="comment">Arguments:</span>
03059 <span class="comment"></span>
03060 <span class="comment">    m - Supplies the state manipulation message.</span>
03061 <span class="comment"></span>
03062 <span class="comment">    AdditionalData - Supplies any additional data for the message.</span>
03063 <span class="comment"></span>
03064 <span class="comment">    Context - Supplies the current context.</span>
03065 <span class="comment"></span>
03066 <span class="comment">Return Value:</span>
03067 <span class="comment"></span>
03068 <span class="comment">    None.</span>
03069 <span class="comment"></span>
03070 <span class="comment">--*/</span>
03071 
03072 {
03073     PDBGKD_BREAKPOINTEX       a = &amp;m-&gt;u.BreakPointEx;
03074     PDBGKD_WRITE_BREAKPOINT   b;
03075     STRING                    MessageHeader;
03076     ULONG                     i;
03077     DBGKD_WRITE_BREAKPOINT    BpBuf[BREAKPOINT_TABLE_SIZE];
03078 
03079 
03080     MessageHeader.Length = <span class="keyword">sizeof</span>(*m);
03081     MessageHeader.Buffer = (PCHAR)m;
03082 
03083     <span class="comment">//</span>
03084     <span class="comment">// verify that the packet size is correct</span>
03085     <span class="comment">//</span>
03086     <span class="keywordflow">if</span> (AdditionalData-&gt;Length !=
03087                          a-&gt;BreakPointCount*<span class="keyword">sizeof</span>(DBGKD_WRITE_BREAKPOINT)) {
03088         m-&gt;ReturnStatus = STATUS_UNSUCCESSFUL;
03089         <a class="code" href="../../d1/d7/4_2kdp_8h.html#a116">KdpSendPacket</a>(
03090                       PACKET_TYPE_KD_STATE_MANIPULATE,
03091                       &amp;MessageHeader,
03092                       AdditionalData
03093                       );
03094         <span class="keywordflow">return</span> m-&gt;ReturnStatus;
03095     }
03096 
03097     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>((PUCHAR)BpBuf,
03098                   AdditionalData-&gt;Buffer,
03099                   a-&gt;BreakPointCount*<span class="keyword">sizeof</span>(DBGKD_WRITE_BREAKPOINT));
03100 
03101     <span class="comment">//</span>
03102     <span class="comment">// assume success</span>
03103     <span class="comment">//</span>
03104     m-&gt;ReturnStatus = STATUS_SUCCESS;
03105 
03106     <span class="comment">//</span>
03107     <span class="comment">// loop thru the breakpoint handles passed in from the debugger and</span>
03108     <span class="comment">// clear any breakpoint that has a non-zero handle</span>
03109     <span class="comment">//</span>
03110     b = BpBuf;
03111     <span class="keywordflow">for</span> (i=0; i&lt;a-&gt;BreakPointCount; i++,b++) {
03112         <span class="keywordflow">if</span> (b-&gt;BreakPointHandle) {
03113             <span class="keywordflow">if</span> (!<a class="code" href="../../d1/d7/4_2kdp_8h.html#a105">KdpDeleteBreakpoint</a>(b-&gt;BreakPointHandle)) {
03114                 m-&gt;ReturnStatus = STATUS_UNSUCCESSFUL;
03115             }
03116             b-&gt;BreakPointHandle = 0;
03117         }
03118     }
03119 
03120     <span class="comment">//</span>
03121     <span class="comment">// loop thru the breakpoint addesses passed in from the debugger and</span>
03122     <span class="comment">// add any new breakpoints that have a non-zero address</span>
03123     <span class="comment">//</span>
03124     b = BpBuf;
03125     <span class="keywordflow">for</span> (i=0; i&lt;a-&gt;BreakPointCount; i++,b++) {
03126         <span class="keywordflow">if</span> (b-&gt;BreakPointAddress) {
03127             b-&gt;BreakPointHandle = <a class="code" href="../../d1/d7/4_2kdp_8h.html#a104">KdpAddBreakpoint</a>( b-&gt;BreakPointAddress );
03128             <span class="keywordflow">if</span> (!b-&gt;BreakPointHandle) {
03129                 m-&gt;ReturnStatus = STATUS_UNSUCCESSFUL;
03130             }
03131         }
03132     }
03133 
03134     <span class="comment">//</span>
03135     <span class="comment">// send back our response</span>
03136     <span class="comment">//</span>
03137 
03138     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>(AdditionalData-&gt;Buffer,
03139                   (PUCHAR)BpBuf,
03140                   a-&gt;BreakPointCount*<span class="keyword">sizeof</span>(DBGKD_WRITE_BREAKPOINT));
03141 
03142     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a116">KdpSendPacket</a>(
03143                   PACKET_TYPE_KD_STATE_MANIPULATE,
03144                   &amp;MessageHeader,
03145                   AdditionalData
03146                   );
03147 
03148     <span class="comment">//</span>
03149     <span class="comment">// return the caller's continue status value.  if this is a non-zero</span>
03150     <span class="comment">// value the system is continued using this value as the continuestatus.</span>
03151     <span class="comment">//</span>
03152     <span class="keywordflow">return</span> a-&gt;ContinueStatus;
03153 }
03154 
03155 
03156 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l03157"></a><a class="code" href="../../d8/d3/kdapi_8c.html#a14">03157</a> <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a11">KdpRestoreBreakPointEx</a>(
03158     IN PDBGKD_MANIPULATE_STATE m,
03159     IN PSTRING AdditionalData,
03160     IN PCONTEXT Context
03161     )
03162 
03163 <span class="comment">/*++</span>
03164 <span class="comment"></span>
03165 <span class="comment">Routine Description:</span>
03166 <span class="comment"></span>
03167 <span class="comment">    This function is called in response of a restore breakpoint state 'ex'</span>
03168 <span class="comment">    manipulation message.  Its function is to clear a list of breakpoints.</span>
03169 <span class="comment"></span>
03170 <span class="comment">Arguments:</span>
03171 <span class="comment"></span>
03172 <span class="comment">    m - Supplies the state manipulation message.</span>
03173 <span class="comment"></span>
03174 <span class="comment">    AdditionalData - Supplies any additional data for the message.</span>
03175 <span class="comment"></span>
03176 <span class="comment">    Context - Supplies the current context.</span>
03177 <span class="comment"></span>
03178 <span class="comment">Return Value:</span>
03179 <span class="comment"></span>
03180 <span class="comment">    None.</span>
03181 <span class="comment"></span>
03182 <span class="comment">--*/</span>
03183 
03184 {
03185     PDBGKD_BREAKPOINTEX         a = &amp;m-&gt;u.BreakPointEx;
03186     PDBGKD_RESTORE_BREAKPOINT   b;
03187     STRING                      MessageHeader;
03188     ULONG                       i;
03189     DBGKD_RESTORE_BREAKPOINT    BpBuf[BREAKPOINT_TABLE_SIZE];
03190 
03191 
03192     MessageHeader.Length = <span class="keyword">sizeof</span>(*m);
03193     MessageHeader.Buffer = (PCHAR)m;
03194 
03195     <span class="comment">//</span>
03196     <span class="comment">// verify that the packet size is correct</span>
03197     <span class="comment">//</span>
03198     <span class="keywordflow">if</span> (AdditionalData-&gt;Length !=
03199                        a-&gt;BreakPointCount*<span class="keyword">sizeof</span>(DBGKD_RESTORE_BREAKPOINT)) {
03200         m-&gt;ReturnStatus = STATUS_UNSUCCESSFUL;
03201         <a class="code" href="../../d1/d7/4_2kdp_8h.html#a116">KdpSendPacket</a>(
03202                       PACKET_TYPE_KD_STATE_MANIPULATE,
03203                       &amp;MessageHeader,
03204                       AdditionalData
03205                       );
03206         <span class="keywordflow">return</span>;
03207     }
03208 
03209     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>((PUCHAR)BpBuf,
03210                   AdditionalData-&gt;Buffer,
03211                   a-&gt;BreakPointCount*<span class="keyword">sizeof</span>(DBGKD_RESTORE_BREAKPOINT));
03212 
03213     <span class="comment">//</span>
03214     <span class="comment">// assume success</span>
03215     <span class="comment">//</span>
03216     m-&gt;ReturnStatus = STATUS_SUCCESS;
03217 
03218     <span class="comment">//</span>
03219     <span class="comment">// loop thru the breakpoint handles passed in from the debugger and</span>
03220     <span class="comment">// clear any breakpoint that has a non-zero handle</span>
03221     <span class="comment">//</span>
03222     b = BpBuf;
03223     <span class="keywordflow">for</span> (i=0; i&lt;a-&gt;BreakPointCount; i++,b++) {
03224         <span class="keywordflow">if</span> (!<a class="code" href="../../d1/d7/4_2kdp_8h.html#a105">KdpDeleteBreakpoint</a>(b-&gt;BreakPointHandle)) {
03225             m-&gt;ReturnStatus = STATUS_UNSUCCESSFUL;
03226         }
03227     }
03228 
03229     <span class="comment">//</span>
03230     <span class="comment">// send back our response</span>
03231     <span class="comment">//</span>
03232     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a116">KdpSendPacket</a>(
03233                   PACKET_TYPE_KD_STATE_MANIPULATE,
03234                   &amp;MessageHeader,
03235                   AdditionalData
03236                   );
03237 }
03238 
03239 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l03240"></a><a class="code" href="../../d8/d3/kdapi_8c.html#a35">03240</a> <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a34">KdDisableDebugger</a>(
03241     VOID
03242     )
03243 
03244 <span class="comment">/*++</span>
03245 <span class="comment"></span>
03246 <span class="comment">Routine Description:</span>
03247 <span class="comment"></span>
03248 <span class="comment">    This function is called to disable the debugger.</span>
03249 <span class="comment"></span>
03250 <span class="comment">Arguments:</span>
03251 <span class="comment"></span>
03252 <span class="comment">    None.</span>
03253 <span class="comment"></span>
03254 <span class="comment">Return Value:</span>
03255 <span class="comment"></span>
03256 <span class="comment">    None.</span>
03257 <span class="comment"></span>
03258 <span class="comment">--*/</span>
03259 
03260 {
03261     KIRQL oldIrql ;
03262 
03263     <a class="code" href="../../d9/d5/verifier_8c.html#a116">KeRaiseIrql</a>(<a class="code" href="../../d6/d7/halmips_8h.html#a53">DISPATCH_LEVEL</a>, &amp;oldIrql) ;
03264     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a145">KdpPortLock</a>();
03265 
03266     <span class="keywordflow">if</span> (!<a class="code" href="../../d8/d3/kdapi_8c.html#a3">KdDisableCount</a>) {
03267 
03268         <a class="code" href="../../d8/d3/kdapi_8c.html#a4">KdPreviouslyEnabled</a> = <a class="code" href="../../d7/d3/kd_8h.html#a13">KdDebuggerEnabled</a> &amp;&amp; (!<a class="code" href="../../d7/d3/kd_8h.html#a7">KdPitchDebugger</a>) ;
03269         <span class="keywordflow">if</span> (<a class="code" href="../../d7/d3/kd_8h.html#a13">KdDebuggerEnabled</a>) {
03270 
03271             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a139">KdpSuspendAllBreakpoints</a>() ;
03272             <a class="code" href="../../d0/d7/kdp_8h.html#a24">KiDebugRoutine</a> = <a class="code" href="../../d7/d8/alpha_2kdtrap_8c.html#a2">KdpStub</a>;
03273             <a class="code" href="../../d7/d3/kd_8h.html#a13">KdDebuggerEnabled</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> ;
03274         }
03275     }
03276     <a class="code" href="../../d8/d3/kdapi_8c.html#a3">KdDisableCount</a>++ ;
03277     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a146">KdpPortUnlock</a>();
03278     <a class="code" href="../../d9/d5/verifier_8c.html#a117">KeLowerIrql</a>(oldIrql);
03279 }
03280 
03281 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l03282"></a><a class="code" href="../../d8/d3/kdapi_8c.html#a36">03282</a> <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a35">KdEnableDebugger</a>(
03283    VOID
03284    )
03285 <span class="comment">/*++</span>
03286 <span class="comment"></span>
03287 <span class="comment">Routine Description:</span>
03288 <span class="comment"></span>
03289 <span class="comment">    This function is called to reenable the debugger after a call to</span>
03290 <span class="comment">    KdDisableDebugger.</span>
03291 <span class="comment"></span>
03292 <span class="comment">Arguments:</span>
03293 <span class="comment"></span>
03294 <span class="comment">    None.</span>
03295 <span class="comment"></span>
03296 <span class="comment">Return Value:</span>
03297 <span class="comment"></span>
03298 <span class="comment">    None.</span>
03299 <span class="comment"></span>
03300 <span class="comment">--*/</span>
03301 {
03302     KIRQL oldIrql ;
03303 
03304     <a class="code" href="../../d9/d5/verifier_8c.html#a116">KeRaiseIrql</a>(<a class="code" href="../../d6/d7/halmips_8h.html#a53">DISPATCH_LEVEL</a>, &amp;oldIrql) ;
03305     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a145">KdpPortLock</a>();
03306 
03307     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(<a class="code" href="../../d8/d3/kdapi_8c.html#a3">KdDisableCount</a> &gt; 0) ;
03308     <a class="code" href="../../d8/d3/kdapi_8c.html#a3">KdDisableCount</a>-- ;
03309 
03310     <span class="keywordflow">if</span> (!<a class="code" href="../../d8/d3/kdapi_8c.html#a3">KdDisableCount</a>) {
03311         <span class="keywordflow">if</span> (<a class="code" href="../../d8/d3/kdapi_8c.html#a4">KdPreviouslyEnabled</a>) {
03312 
03313             <span class="comment">//</span>
03314             <span class="comment">// Ugly HACKHACK - Make sure the timers aren't reset.</span>
03315             <span class="comment">//</span>
03316             <a class="code" href="../../d1/d2/po_8h.html#a55">PoHiberInProgress</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> ;
03317             <a class="code" href="../../d5/d6/4_2kdinit_8c.html#a4">KdInitSystem</a>(<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) ;
03318             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a140">KdpRestoreAllBreakpoints</a>();
03319             <a class="code" href="../../d1/d2/po_8h.html#a55">PoHiberInProgress</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> ;
03320         }
03321     }
03322     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a146">KdpPortUnlock</a>();
03323     <a class="code" href="../../d9/d5/verifier_8c.html#a117">KeLowerIrql</a>(oldIrql);
03324 }
03325 
03326 
03327 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l03328"></a><a class="code" href="../../d8/d3/kdapi_8c.html#a15">03328</a> <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a12">KdpSearchMemory</a>(
03329     IN PDBGKD_MANIPULATE_STATE m,
03330     IN PSTRING AdditionalData,
03331     IN PCONTEXT Context
03332     )
03333 
03334 <span class="comment">/*++</span>
03335 <span class="comment"></span>
03336 <span class="comment">Routine Description:</span>
03337 <span class="comment"></span>
03338 <span class="comment">    This function implements a memory pattern searcher.  This will</span>
03339 <span class="comment">    find an instance of a pattern that begins in the range</span>
03340 <span class="comment">    SearchAddress..SearchAddress+SearchLength.  The pattern may</span>
03341 <span class="comment">    end outside of the range.</span>
03342 <span class="comment"></span>
03343 <span class="comment">Arguments:</span>
03344 <span class="comment"></span>
03345 <span class="comment">    m - Supplies the state manipulation message.</span>
03346 <span class="comment"></span>
03347 <span class="comment">    AdditionalData - Supplies the pattern to search for</span>
03348 <span class="comment"></span>
03349 <span class="comment">    Context - Supplies the current context.</span>
03350 <span class="comment"></span>
03351 <span class="comment">Return Value:</span>
03352 <span class="comment"></span>
03353 <span class="comment">    None.</span>
03354 <span class="comment"></span>
03355 <span class="comment">--*/</span>
03356 
03357 {
03358     PUCHAR <a class="code" href="../../d9/d4/localrtl_8c.html#a2">Pattern</a> = AdditionalData-&gt;Buffer;
03359     ULONG_PTR StartAddress = (ULONG_PTR)m-&gt;u.SearchMemory.SearchAddress;
03360     ULONG_PTR EndAddress = (ULONG_PTR)(StartAddress + m-&gt;u.SearchMemory.SearchLength);
03361     ULONG PatternLength = m-&gt;u.SearchMemory.PatternLength;
03362 
03363     STRING MessageHeader;
03364     ULONG MaskIndex;
03365     PUCHAR PatternTail;
03366     PUCHAR DataTail;
03367     ULONG TailLength;
03368     ULONG Data;
03369     ULONG FirstWordPattern[4];
03370     ULONG FirstWordMask[4];
03371 
03372 
03373     <span class="comment">//</span>
03374     <span class="comment">// On failure, return STATUS_NO_MORE_ENTRIES.  DON'T RETURN</span>
03375     <span class="comment">// STATUS_UNSUCCESSFUL!  That return status indicates that the</span>
03376     <span class="comment">// operation is not supported, and the debugger will fall back</span>
03377     <span class="comment">// to a debugger-side search.</span>
03378     <span class="comment">//</span>
03379 
03380     m-&gt;ReturnStatus = STATUS_NO_MORE_ENTRIES;
03381 
03382     <span class="comment">//</span>
03383     <span class="comment">// Do a fast search for the beginning of the pattern</span>
03384     <span class="comment">//</span>
03385 
03386     <span class="keywordflow">if</span> (PatternLength &gt; 3) {
03387         FirstWordMask[0] = 0xffffffff;
03388     } <span class="keywordflow">else</span> {
03389         FirstWordMask[0] = 0xffffffff &gt;&gt; (8*(4-PatternLength));
03390     }
03391 
03392     FirstWordMask[1] = FirstWordMask[0] &lt;&lt; 8;
03393     FirstWordMask[2] = FirstWordMask[1] &lt;&lt; 8;
03394     FirstWordMask[3] = FirstWordMask[2] &lt;&lt; 8;
03395 
03396     FirstWordPattern[0] = 0;
03397     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a111">KdpQuickMoveMemory</a>((PVOID)FirstWordPattern,
03398                        <a class="code" href="../../d9/d4/localrtl_8c.html#a2">Pattern</a>,
03399                        PatternLength &lt; 5 ? PatternLength : 4);
03400 
03401     FirstWordPattern[1] = FirstWordPattern[0] &lt;&lt; 8;
03402     FirstWordPattern[2] = FirstWordPattern[1] &lt;&lt; 8;
03403     FirstWordPattern[3] = FirstWordPattern[2] &lt;&lt; 8;
03404 
03405 
03406 <span class="comment">/*</span>
03407 <span class="comment">{</span>
03408 <span class="comment">    int i;</span>
03409 <span class="comment">    for (i = 0; i &lt; (int)PatternLength; i++) {</span>
03410 <span class="comment">        KdpDprintf("%08x: %02x\n", &amp;Pattern[i], Pattern[i]);</span>
03411 <span class="comment">    }</span>
03412 <span class="comment">    for (i = 0; i &lt; 4; i++) {</span>
03413 <span class="comment">        KdpDprintf("%d: %08x %08x\n", i, FirstWordPattern[i], FirstWordMask[i]);</span>
03414 <span class="comment">    }</span>
03415 <span class="comment">}</span>
03416 <span class="comment">*/</span>
03417 
03418 
03419 
03420     <span class="comment">//</span>
03421     <span class="comment">// Get starting mask</span>
03422     <span class="comment">//</span>
03423 
03424     MaskIndex = StartAddress &amp; 3;
03425     StartAddress = StartAddress &amp; ~3;
03426 
03427     <span class="comment">//</span>
03428     <span class="comment">// check that the starting page is available</span>
03429     <span class="comment">//</span>
03430 
03431     <span class="keywordflow">if</span> (<a class="code" href="../../d4/d6/ppc_2debugsup_8c.html#a0">MmDbgReadCheck</a>((PVOID)StartAddress) == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03432         StartAddress = (StartAddress + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>) &amp; ~(<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>-1);
03433         MaskIndex = 0;
03434     }
03435 
03436     <span class="keywordflow">while</span> (StartAddress &lt; EndAddress) {
03437 
03438         <span class="comment">//</span>
03439         <span class="comment">// check when starting a new page</span>
03440         <span class="comment">//</span>
03441         <span class="keywordflow">if</span> ((StartAddress &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>-1)) == 0) {
03442             <span class="keywordflow">if</span> (<a class="code" href="../../d4/d6/ppc_2debugsup_8c.html#a0">MmDbgReadCheck</a>((PVOID)StartAddress) == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03443                 StartAddress = StartAddress + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
03444                 <span class="keywordflow">continue</span>;
03445             }
03446         }
03447 
03448         <span class="comment">//</span>
03449         <span class="comment">// search for a match in each of the 4 starting positions</span>
03450         <span class="comment">//</span>
03451 
03452         Data = *(ULONG*)StartAddress;
03453 <span class="comment">//KdpDprintf("\n%08x: %08x ", StartAddress, Data);</span>
03454 
03455         <span class="keywordflow">for</span> ( ; MaskIndex &lt; 4; MaskIndex++) {
03456 <span class="comment">//KdpDprintf(" %d", MaskIndex);</span>
03457 
03458             <span class="keywordflow">if</span> ( (Data &amp; FirstWordMask[MaskIndex]) == FirstWordPattern[MaskIndex]) {
03459 
03460                 <span class="comment">//</span>
03461                 <span class="comment">// first word matched</span>
03462                 <span class="comment">//</span>
03463 
03464                 <span class="keywordflow">if</span> ( (4-MaskIndex) &gt;= PatternLength ) {
03465 
03466                     <span class="comment">//</span>
03467                     <span class="comment">// string is all in this word; good match</span>
03468                     <span class="comment">//</span>
03469 <span class="comment">//KdpDprintf(" %d hit, complete\n", MaskIndex);</span>
03470 
03471                     m-&gt;u.SearchMemory.FoundAddress = StartAddress + MaskIndex;
03472                     m-&gt;ReturnStatus = STATUS_SUCCESS;
03473                     <span class="keywordflow">goto</span> done;
03474 
03475                 } <span class="keywordflow">else</span> {
03476 
03477                     <span class="comment">//</span>
03478                     <span class="comment">// string is longer; see if tail matches</span>
03479                     <span class="comment">//</span>
03480 <span class="comment">//KdpDprintf(" %d hit, check tail\n", MaskIndex);</span>
03481 
03482                     PatternTail = <a class="code" href="../../d9/d4/localrtl_8c.html#a2">Pattern</a> + 4 - MaskIndex;
03483                     DataTail = (PUCHAR)StartAddress + 4;
03484                     TailLength = PatternLength - 4 + MaskIndex;
03485 
03486 <span class="comment">//KdpDprintf("Pattern == %08x\n", Pattern);</span>
03487 <span class="comment">//KdpDprintf("PatternTail == %08x\n", PatternTail);</span>
03488 <span class="comment">//KdpDprintf("DataTail == %08x\n", DataTail);</span>
03489 
03490                     <span class="keywordflow">while</span> (TailLength) {
03491                         <span class="keywordflow">if</span> ( ((ULONG_PTR)DataTail &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>-1)) == 0 &amp;&amp;
03492                              <a class="code" href="../../d4/d6/ppc_2debugsup_8c.html#a0">MmDbgReadCheck</a>(DataTail) == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
03493 <span class="comment">//KdpDprintf("Tail failed: page not present at %08x\n", DataTail);</span>
03494                             <span class="keywordflow">break</span>;
03495                         } <span class="keywordflow">else</span>
03496 {
03497 <span class="comment">//KdpDprintf("D: %02x  P: %02x\n", *DataTail, *PatternTail);</span>
03498 
03499                         <span class="keywordflow">if</span> (*DataTail != *PatternTail) {
03500 <span class="comment">//KdpDprintf("Tail failed at %08x\n", DataTail);</span>
03501                             <span class="keywordflow">break</span>;
03502                         } <span class="keywordflow">else</span> {
03503                             DataTail++;
03504                             PatternTail++;
03505                             TailLength--;
03506                         }
03507 }
03508                     }
03509 
03510                     <span class="keywordflow">if</span> (TailLength == 0) {
03511 
03512                         <span class="comment">//</span>
03513                         <span class="comment">// A winner</span>
03514                         <span class="comment">//</span>
03515 
03516                         m-&gt;u.SearchMemory.FoundAddress = StartAddress + MaskIndex;
03517                         m-&gt;ReturnStatus = STATUS_SUCCESS;
03518                         <span class="keywordflow">goto</span> done;
03519 
03520                     }
03521                 }
03522             }
03523         }
03524 
03525         StartAddress += 4;
03526         MaskIndex = 0;
03527     }
03528 
03529 done:
03530 <span class="comment">//KdpDprintf("\n");</span>
03531     MessageHeader.Length = <span class="keyword">sizeof</span>(*m);
03532     MessageHeader.Buffer = (PCHAR)m;
03533 
03534     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a116">KdpSendPacket</a>(
03535         PACKET_TYPE_KD_STATE_MANIPULATE,
03536         &amp;MessageHeader,
03537         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>
03538         );
03539 
03540 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:40:33 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
