<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: logsup.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>logsup.c</h1><a href="../../d8/d5/logsup_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1990  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    logsup.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module implements the special cache manager support for logging</span>
00012 <span class="comment">    file systems.</span>
00013 <span class="comment"></span>
00014 <span class="comment">Author:</span>
00015 <span class="comment"></span>
00016 <span class="comment">    Tom Miller      [TomM]      30-Jul-1991</span>
00017 <span class="comment"></span>
00018 <span class="comment">Revision History:</span>
00019 <span class="comment"></span>
00020 <span class="comment">--*/</span>
00021 
00022 <span class="preprocessor">#include "<a class="code" href="../../d5/d5/cc_8h.html">cc.h</a>"</span>
00023 
00024 <span class="comment">//</span>
00025 <span class="comment">//  Define our debug constant</span>
00026 <span class="comment">//</span>
00027 
<a name="l00028"></a><a class="code" href="../../d8/d5/logsup_8c.html#a0">00028</a> <span class="preprocessor">#define me 0x0000040</span>
00029 <span class="preprocessor"></span>
00030 
00031 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00032"></a><a class="code" href="../../d4/d2/cache_8h.html#a95">00032</a> <a class="code" href="../../d4/d2/cache_8h.html#a95">CcSetAdditionalCacheAttributes</a> (
00033     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
00034     IN BOOLEAN DisableReadAhead,
00035     IN BOOLEAN DisableWriteBehind
00036     )
00037 
00038 <span class="comment">/*++</span>
00039 <span class="comment"></span>
00040 <span class="comment">Routine Description:</span>
00041 <span class="comment"></span>
00042 <span class="comment">    This routine supports the setting of disable read ahead or disable write</span>
00043 <span class="comment">    behind flags to control Cache Manager operation.  This routine may be</span>
00044 <span class="comment">    called any time after calling CcInitializeCacheMap.  Initially both</span>
00045 <span class="comment">    read ahead and write behind are enabled.  Note that the state of both</span>
00046 <span class="comment">    of these flags must be specified on each call to this routine.</span>
00047 <span class="comment"></span>
00048 <span class="comment">Arguments:</span>
00049 <span class="comment"></span>
00050 <span class="comment">    FileObject - File object for which the respective flags are to be set.</span>
00051 <span class="comment"></span>
00052 <span class="comment">    DisableReadAhead - FALSE to enable read ahead, TRUE to disable it.</span>
00053 <span class="comment"></span>
00054 <span class="comment">    DisableWriteBehind - FALSE to enable write behind, TRUE to disable it.</span>
00055 <span class="comment"></span>
00056 <span class="comment">Return Value:</span>
00057 <span class="comment"></span>
00058 <span class="comment">    None.</span>
00059 <span class="comment"></span>
00060 <span class="comment">--*/</span>
00061 
00062 {
00063     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap;
00064     KIRQL OldIrql;
00065 
00066     <span class="comment">//</span>
00067     <span class="comment">//  Get pointer to SharedCacheMap.</span>
00068     <span class="comment">//</span>
00069 
00070     SharedCacheMap = FileObject-&gt;SectionObjectPointer-&gt;SharedCacheMap;
00071 
00072     <span class="comment">//</span>
00073     <span class="comment">//  Now set the flags and return.</span>
00074     <span class="comment">//</span>
00075 
00076     <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
00077     <span class="keywordflow">if</span> (DisableReadAhead) {
00078         <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, <a class="code" href="../../d5/d5/cc_8h.html#a70">DISABLE_READ_AHEAD</a>);
00079     } <span class="keywordflow">else</span> {
00080         <a class="code" href="../../d5/d5/cc_8h.html#a61">ClearFlag</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, <a class="code" href="../../d5/d5/cc_8h.html#a70">DISABLE_READ_AHEAD</a>);
00081     }
00082     <span class="keywordflow">if</span> (DisableWriteBehind) {
00083         <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, <a class="code" href="../../d5/d5/cc_8h.html#a71">DISABLE_WRITE_BEHIND</a> | <a class="code" href="../../d5/d5/cc_8h.html#a78">MODIFIED_WRITE_DISABLED</a>);
00084     } <span class="keywordflow">else</span> {
00085         <a class="code" href="../../d5/d5/cc_8h.html#a61">ClearFlag</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, <a class="code" href="../../d5/d5/cc_8h.html#a71">DISABLE_WRITE_BEHIND</a>);
00086     }
00087     <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
00088 }
00089 
00090 
00091 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00092"></a><a class="code" href="../../d4/d2/cache_8h.html#a96">00092</a> <a class="code" href="../../d4/d2/cache_8h.html#a96">CcSetLogHandleForFile</a> (
00093     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
00094     IN PVOID LogHandle,
00095     IN PFLUSH_TO_LSN FlushToLsnRoutine
00096     )
00097 
00098 <span class="comment">/*++</span>
00099 <span class="comment"></span>
00100 <span class="comment">Routine Description:</span>
00101 <span class="comment"></span>
00102 <span class="comment">    This routine may be called to instruct the Cache Manager to store the</span>
00103 <span class="comment">    specified log handle with the shared cache map for a file, to support</span>
00104 <span class="comment">    subsequent calls to the other routines in this module which effectively</span>
00105 <span class="comment">    perform an associative search for files by log handle.</span>
00106 <span class="comment"></span>
00107 <span class="comment">Arguments:</span>
00108 <span class="comment"></span>
00109 <span class="comment">    FileObject - File for which the log handle should be stored.</span>
00110 <span class="comment"></span>
00111 <span class="comment">    LogHandle - Log Handle to store.</span>
00112 <span class="comment"></span>
00113 <span class="comment">    FlushToLsnRoutine - A routine to call before flushing buffers for this</span>
00114 <span class="comment">                        file, to insure a log file is flushed to the most</span>
00115 <span class="comment">                        recent Lsn for any Bcb being flushed.</span>
00116 <span class="comment"></span>
00117 <span class="comment">Return Value:</span>
00118 <span class="comment"></span>
00119 <span class="comment">    None.</span>
00120 <span class="comment"></span>
00121 <span class="comment">--*/</span>
00122 
00123 {
00124     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap;
00125 
00126     <span class="comment">//</span>
00127     <span class="comment">//  Get pointer to SharedCacheMap.</span>
00128     <span class="comment">//</span>
00129 
00130     SharedCacheMap = FileObject-&gt;SectionObjectPointer-&gt;SharedCacheMap;
00131 
00132     <span class="comment">//</span>
00133     <span class="comment">//  Now set the log file handle and flush routine</span>
00134     <span class="comment">//</span>
00135 
00136     SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o30">LogHandle</a> = LogHandle;
00137     SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o31">FlushToLsnRoutine</a> = FlushToLsnRoutine;
00138 }
00139 
00140 
00141 LARGE_INTEGER
<a name="l00142"></a><a class="code" href="../../d4/d2/cache_8h.html#a97">00142</a> <a class="code" href="../../d4/d2/cache_8h.html#a97">CcGetDirtyPages</a> (
00143     IN PVOID LogHandle,
00144     IN PDIRTY_PAGE_ROUTINE DirtyPageRoutine,
00145     IN PVOID Context1,
00146     IN PVOID Context2
00147     )
00148 
00149 <span class="comment">/*++</span>
00150 <span class="comment"></span>
00151 <span class="comment">Routine Description:</span>
00152 <span class="comment"></span>
00153 <span class="comment">    This routine may be called to return all of the dirty pages in all files</span>
00154 <span class="comment">    for a given log handle.  Each page is returned by an individual call to</span>
00155 <span class="comment">    the Dirty Page Routine.  The Dirty Page Routine is defined by a prototype</span>
00156 <span class="comment">    in ntos\inc\cache.h.</span>
00157 <span class="comment"></span>
00158 <span class="comment">Arguments:</span>
00159 <span class="comment"></span>
00160 <span class="comment">    LogHandle - Log Handle which must match the log handle previously stored</span>
00161 <span class="comment">                for all files which are to be returned.</span>
00162 <span class="comment"></span>
00163 <span class="comment">    DirtyPageRoutine -- The routine to call as each dirty page for this log</span>
00164 <span class="comment">                        handle is found.</span>
00165 <span class="comment"></span>
00166 <span class="comment">    Context1 - First context parameter to be passed to the Dirty Page Routine.</span>
00167 <span class="comment"></span>
00168 <span class="comment">    Context2 - First context parameter to be passed to the Dirty Page Routine.</span>
00169 <span class="comment"></span>
00170 <span class="comment">Return Value:</span>
00171 <span class="comment"></span>
00172 <span class="comment">    LARGE_INTEGER - Oldest Lsn found of all the dirty pages, or 0 if no dirty pages</span>
00173 <span class="comment"></span>
00174 <span class="comment">--*/</span>
00175 
00176 {
00177     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap;
00178     <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> Bcb, BcbToUnpin = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00179     KIRQL OldIrql;
00180     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> ExceptionStatus;
00181     LARGE_INTEGER SavedFileOffset, SavedOldestLsn, SavedNewestLsn;
00182     ULONG SavedByteLength;
00183     LARGE_INTEGER OldestLsn = {0,0};
00184 
00185     <span class="comment">//</span>
00186     <span class="comment">//  Synchronize with changes to the SharedCacheMap list.</span>
00187     <span class="comment">//</span>
00188 
00189     <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
00190 
00191     SharedCacheMap = CONTAINING_RECORD( <a class="code" href="../../d5/d2/cachedat_8c.html#a2">CcDirtySharedCacheMapList</a>.<a class="code" href="../../d1/d3/struct__SHARED__CACHE__MAP__LIST__CURSOR.html#o0">SharedCacheMapLinks</a>.Flink,
00192                                         <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">SHARED_CACHE_MAP</a>,
00193                                         SharedCacheMapLinks );
00194 
00195     <span class="comment">//</span>
00196     <span class="comment">//  Use try/finally for cleanup.  The only spot where we can raise is out of the</span>
00197     <span class="comment">//  filesystem callback, but we have the exception handler out here so we aren't</span>
00198     <span class="comment">//  constantly setting/unsetting it.</span>
00199     <span class="comment">//</span>
00200 
00201     <span class="keywordflow">try</span> {
00202 
00203         <span class="keywordflow">while</span> (&amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a> != &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a2">CcDirtySharedCacheMapList</a>.<a class="code" href="../../d1/d3/struct__SHARED__CACHE__MAP__LIST__CURSOR.html#o0">SharedCacheMapLinks</a>) {
00204 
00205             <span class="comment">//</span>
00206             <span class="comment">//  Skip over cursors, SharedCacheMaps for other LogHandles, and ones with</span>
00207             <span class="comment">//  no dirty pages</span>
00208             <span class="comment">//</span>
00209 
00210             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, <a class="code" href="../../d5/d5/cc_8h.html#a80">IS_CURSOR</a>) &amp;&amp; (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o30">LogHandle</a> == LogHandle) &amp;&amp;
00211                 (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o20">DirtyPages</a> != 0)) {
00212 
00213                 <span class="comment">//</span>
00214                 <span class="comment">//  This SharedCacheMap should stick around for a while in the dirty list.</span>
00215                 <span class="comment">//</span>
00216 
00217                 <a class="code" href="../../d5/d5/cc_8h.html#a68">CcIncrementOpenCount</a>( SharedCacheMap, 'pdGS' );
00218                 SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o20">DirtyPages</a> += 1;
00219                 <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
00220 
00221                 <span class="comment">//</span>
00222                 <span class="comment">//  Set our initial resume point and point to first Bcb in List.</span>
00223                 <span class="comment">//</span>
00224 
00225                 ExAcquireFastLock( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o36">BcbSpinLock</a>, &amp;OldIrql );
00226                 Bcb = CONTAINING_RECORD( SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o4">BcbList</a>.Flink, <a class="code" href="../../d4/d3/struct__BCB.html">BCB</a>, BcbLinks );
00227 
00228                 <span class="comment">//</span>
00229                 <span class="comment">//  Scan to the end of the Bcb list.</span>
00230                 <span class="comment">//</span>
00231 
00232                 <span class="keywordflow">while</span> (&amp;Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o4">BcbLinks</a> != &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o4">BcbList</a>) {
00233 
00234                     <span class="comment">//</span>
00235                     <span class="comment">//  If the Bcb is dirty, then capture the inputs for the</span>
00236                     <span class="comment">//  callback routine so we can call without holding a spinlock.</span>
00237                     <span class="comment">//</span>
00238 
00239                     <span class="keywordflow">if</span> ((Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o0">NodeTypeCode</a> == <a class="code" href="../../d5/d5/cc_8h.html#a14">CACHE_NTC_BCB</a>) &amp;&amp; Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o13">Dirty</a>) {
00240 
00241                         SavedFileOffset = Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o3">FileOffset</a>;
00242                         SavedByteLength = Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o2">ByteLength</a>;
00243                         SavedOldestLsn = Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o6">OldestLsn</a>;
00244                         SavedNewestLsn = Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o7">NewestLsn</a>;
00245 
00246                         <span class="comment">//</span>
00247                         <span class="comment">//  Increment PinCount so the Bcb sticks around</span>
00248                         <span class="comment">//</span>
00249 
00250                         Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o9">PinCount</a> += 1;
00251 
00252                         ExReleaseFastLock( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o36">BcbSpinLock</a>, OldIrql );
00253 
00254                         <span class="comment">//</span>
00255                         <span class="comment">//  Any Bcb to unpin from a previous loop?</span>
00256                         <span class="comment">//</span>
00257 
00258                         <span class="keywordflow">if</span> (BcbToUnpin != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00259                             <a class="code" href="../../d5/d5/cc_8h.html#a176">CcUnpinFileData</a>( BcbToUnpin, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, <a class="code" href="../../d5/d5/cc_8h.html#a211a172">UNREF</a> );
00260                             BcbToUnpin = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00261                         }
00262 
00263                         <span class="comment">//</span>
00264                         <span class="comment">//  Call the file system.  This callback may raise status.</span>
00265                         <span class="comment">//</span>
00266 
00267                         (*DirtyPageRoutine)( SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o10">FileObject</a>,
00268                                              &amp;SavedFileOffset,
00269                                              SavedByteLength,
00270                                              &amp;SavedOldestLsn,
00271                                              &amp;SavedNewestLsn,
00272                                              <a class="code" href="../../d3/d1/threads_8h.html#a107">Context1</a>,
00273                                              <a class="code" href="../../d3/d1/threads_8h.html#a108">Context2</a> );
00274 
00275                         <span class="comment">//</span>
00276                         <span class="comment">//  Possibly update OldestLsn</span>
00277                         <span class="comment">//</span>
00278 
00279                         <span class="keywordflow">if</span> ((SavedOldestLsn.QuadPart != 0) &amp;&amp;
00280                             ((OldestLsn.QuadPart == 0) || (SavedOldestLsn.QuadPart &lt; OldestLsn.QuadPart ))) {
00281                             OldestLsn = SavedOldestLsn;
00282                         }
00283 
00284                         <span class="comment">//</span>
00285                         <span class="comment">//  Now reacquire the spinlock and scan from the resume point</span>
00286                         <span class="comment">//  point to the next Bcb to return in the descending list.</span>
00287                         <span class="comment">//</span>
00288 
00289                         ExAcquireFastLock( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o36">BcbSpinLock</a>, &amp;OldIrql );
00290 
00291                         <span class="comment">//</span>
00292                         <span class="comment">//  Normally the Bcb can stay around a while, but if not,</span>
00293                         <span class="comment">//  we will just remember it for the next time we do not</span>
00294                         <span class="comment">//  have the spin lock.  We cannot unpin it now, because</span>
00295                         <span class="comment">//  we would lose our place in the list.</span>
00296                         <span class="comment">//</span>
00297 
00298                         <span class="keywordflow">if</span> (Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o9">PinCount</a> &gt; 1) {
00299                             Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o9">PinCount</a> -= 1;
00300                         } <span class="keywordflow">else</span> {
00301                             BcbToUnpin = Bcb;
00302                         }
00303                     }
00304 
00305                     Bcb = CONTAINING_RECORD( Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o4">BcbLinks</a>.Flink, <a class="code" href="../../d4/d3/struct__BCB.html">BCB</a>, BcbLinks );
00306                 }
00307                 ExReleaseFastLock( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o36">BcbSpinLock</a>, OldIrql );
00308 
00309                 <span class="comment">//</span>
00310                 <span class="comment">//  We need to unpin any Bcb we are holding before moving on to</span>
00311                 <span class="comment">//  the next SharedCacheMap, or else CcDeleteSharedCacheMap will</span>
00312                 <span class="comment">//  also delete this Bcb.</span>
00313                 <span class="comment">//</span>
00314 
00315                 <span class="keywordflow">if</span> (BcbToUnpin != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00316 
00317                     <a class="code" href="../../d5/d5/cc_8h.html#a176">CcUnpinFileData</a>( BcbToUnpin, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, <a class="code" href="../../d5/d5/cc_8h.html#a211a172">UNREF</a> );
00318                     BcbToUnpin = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00319                 }
00320 
00321                 <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
00322 
00323                 <span class="comment">//</span>
00324                 <span class="comment">//  Now release the SharedCacheMap, leaving it in the dirty list.</span>
00325                 <span class="comment">//</span>
00326 
00327                 <a class="code" href="../../d5/d5/cc_8h.html#a69">CcDecrementOpenCount</a>( SharedCacheMap, 'pdGF' );
00328                 SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o20">DirtyPages</a> -= 1;
00329             }
00330 
00331             <span class="comment">//</span>
00332             <span class="comment">//  Now loop back for the next cache map.</span>
00333             <span class="comment">//</span>
00334 
00335             SharedCacheMap =
00336                 CONTAINING_RECORD( SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a>.Flink,
00337                                    <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">SHARED_CACHE_MAP</a>,
00338                                    SharedCacheMapLinks );
00339         }
00340 
00341         <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
00342 
00343     } finally {
00344 
00345         <span class="comment">//</span>
00346         <span class="comment">//  Drop the Bcb if we are being ejected.  We are guaranteed that the</span>
00347         <span class="comment">//  only raise is from the callback, at which point we have an incremented</span>
00348         <span class="comment">//  pincount.</span>
00349         <span class="comment">//</span>
00350 
00351         <span class="keywordflow">if</span> (AbnormalTermination()) {
00352 
00353             <a class="code" href="../../d5/d5/cc_8h.html#a176">CcUnpinFileData</a>( Bcb, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, <a class="code" href="../../d5/d5/cc_8h.html#a211a171">UNPIN</a> );
00354         }
00355     }
00356 
00357     <span class="keywordflow">return</span> OldestLsn;
00358 }
00359 
00360 
00361 BOOLEAN
<a name="l00362"></a><a class="code" href="../../d4/d2/cache_8h.html#a98">00362</a> <a class="code" href="../../d4/d2/cache_8h.html#a98">CcIsThereDirtyData</a> (
00363     IN <a class="code" href="../../d7/d7/struct__VPB.html">PVPB</a> Vpb
00364     )
00365 
00366 <span class="comment">/*++</span>
00367 <span class="comment"></span>
00368 <span class="comment">Routine Description:</span>
00369 <span class="comment"></span>
00370 <span class="comment">    This routine returns TRUE if the specified Vcb has any unwritten dirty</span>
00371 <span class="comment">    data in the cache.</span>
00372 <span class="comment"></span>
00373 <span class="comment">Arguments:</span>
00374 <span class="comment"></span>
00375 <span class="comment">    Vpb - specifies Vpb to check for</span>
00376 <span class="comment"></span>
00377 <span class="comment">Return Value:</span>
00378 <span class="comment"></span>
00379 <span class="comment">    FALSE - if the Vpb has no dirty data</span>
00380 <span class="comment">    TRUE - if the Vpb has dirty data</span>
00381 <span class="comment"></span>
00382 <span class="comment">--*/</span>
00383 
00384 {
00385     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap;
00386     KIRQL OldIrql;
00387     ULONG LoopsWithLockHeld = 0;
00388 
00389     <span class="comment">//</span>
00390     <span class="comment">//  Synchronize with changes to the SharedCacheMap list.</span>
00391     <span class="comment">//</span>
00392 
00393     <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
00394 
00395     SharedCacheMap = CONTAINING_RECORD( <a class="code" href="../../d5/d2/cachedat_8c.html#a2">CcDirtySharedCacheMapList</a>.<a class="code" href="../../d1/d3/struct__SHARED__CACHE__MAP__LIST__CURSOR.html#o0">SharedCacheMapLinks</a>.Flink,
00396                                         <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">SHARED_CACHE_MAP</a>,
00397                                         SharedCacheMapLinks );
00398 
00399     <span class="keywordflow">while</span> (&amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a> != &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a2">CcDirtySharedCacheMapList</a>.<a class="code" href="../../d1/d3/struct__SHARED__CACHE__MAP__LIST__CURSOR.html#o0">SharedCacheMapLinks</a>) {
00400 
00401         <span class="comment">//</span>
00402         <span class="comment">//  Look at this one if the Vpb matches and if there is dirty data.</span>
00403         <span class="comment">//  For what it's worth, don't worry about dirty data in temporary files,</span>
00404         <span class="comment">//  as that should not concern the caller if it wants to dismount.</span>
00405         <span class="comment">//</span>
00406 
00407         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, <a class="code" href="../../d5/d5/cc_8h.html#a80">IS_CURSOR</a>) &amp;&amp;
00408             (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o10">FileObject</a>-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o3">Vpb</a> == Vpb) &amp;&amp;
00409             (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o20">DirtyPages</a> != 0) &amp;&amp;
00410             !<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o10">FileObject</a>-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a>, <a class="code" href="../../d0/d5/io_8h.html#a165">FO_TEMPORARY_FILE</a>)) {
00411 
00412             <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
00413             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00414         }
00415 
00416         <span class="comment">//</span>
00417         <span class="comment">//  Make sure we occassionally drop the lock.  Set WRITE_QUEUED</span>
00418         <span class="comment">//  to keep the guy from going away, and increment DirtyPages to</span>
00419         <span class="comment">//  keep in in this list.</span>
00420         <span class="comment">//</span>
00421 
00422         <span class="keywordflow">if</span> ((++LoopsWithLockHeld &gt;= 20) &amp;&amp;
00423             !<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, <a class="code" href="../../d5/d5/cc_8h.html#a74">WRITE_QUEUED</a> | <a class="code" href="../../d5/d5/cc_8h.html#a80">IS_CURSOR</a>)) {
00424 
00425             <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>( (<span class="keyword">volatile</span> ULONG) SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, <a class="code" href="../../d5/d5/cc_8h.html#a74">WRITE_QUEUED</a>);
00426             (<span class="keyword">volatile</span> ULONG) SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o20">DirtyPages</a> += 1;
00427             <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
00428             LoopsWithLockHeld = 0;
00429             <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
00430             <a class="code" href="../../d5/d5/cc_8h.html#a61">ClearFlag</a>( (<span class="keyword">volatile</span> ULONG) SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, <a class="code" href="../../d5/d5/cc_8h.html#a74">WRITE_QUEUED</a>);
00431             (<span class="keyword">volatile</span> ULONG) SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o20">DirtyPages</a> -= 1;
00432         }
00433 
00434         <span class="comment">//</span>
00435         <span class="comment">//  Now loop back for the next cache map.</span>
00436         <span class="comment">//</span>
00437 
00438         SharedCacheMap =
00439             CONTAINING_RECORD( SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a>.Flink,
00440                                <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">SHARED_CACHE_MAP</a>,
00441                                SharedCacheMapLinks );
00442     }
00443 
00444     <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
00445 
00446     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00447 }
00448 
00449 LARGE_INTEGER
<a name="l00450"></a><a class="code" href="../../d4/d2/cache_8h.html#a99">00450</a> <a class="code" href="../../d4/d2/cache_8h.html#a99">CcGetLsnForFileObject</a>(
00451     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
00452     OUT PLARGE_INTEGER OldestLsn OPTIONAL
00453     )
00454 
00455 <span class="comment">/*++</span>
00456 <span class="comment"></span>
00457 <span class="comment">Routine Description:</span>
00458 <span class="comment"></span>
00459 <span class="comment">    This routine returns the  oldest and newest LSNs for a file object.</span>
00460 <span class="comment"></span>
00461 <span class="comment">Arguments:</span>
00462 <span class="comment"></span>
00463 <span class="comment">    FileObject - File for which the log handle should be stored.</span>
00464 <span class="comment"></span>
00465 <span class="comment">    OldestLsn - pointer to location to store oldest LSN for file object.</span>
00466 <span class="comment"></span>
00467 <span class="comment">Return Value:</span>
00468 <span class="comment"></span>
00469 <span class="comment">    The newest LSN for the file object.</span>
00470 <span class="comment"></span>
00471 <span class="comment">--*/</span>
00472 
00473 {
00474     <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> Bcb;
00475     KIRQL OldIrql;
00476     LARGE_INTEGER Oldest, Newest;
00477     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap = FileObject-&gt;SectionObjectPointer-&gt;SharedCacheMap;
00478 
00479     <span class="comment">//</span>
00480     <span class="comment">// initialize lsn variables</span>
00481     <span class="comment">//</span>
00482 
00483     Oldest.LowPart = 0;
00484     Oldest.HighPart = 0;
00485     Newest.LowPart = 0;
00486     Newest.HighPart = 0;
00487 
00488     <span class="keywordflow">if</span>(SharedCacheMap == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00489         <span class="keywordflow">return</span> Oldest;
00490     }
00491 
00492     ExAcquireFastLock(&amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o36">BcbSpinLock</a>, &amp;OldIrql);
00493 
00494     <span class="comment">//</span>
00495     <span class="comment">//  Now point to first Bcb in List, and loop through it.</span>
00496     <span class="comment">//</span>
00497 
00498     Bcb = CONTAINING_RECORD( SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o4">BcbList</a>.Flink, <a class="code" href="../../d4/d3/struct__BCB.html">BCB</a>, BcbLinks );
00499 
00500     <span class="keywordflow">while</span> (&amp;Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o4">BcbLinks</a> != &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o4">BcbList</a>) {
00501 
00502         <span class="comment">//</span>
00503         <span class="comment">//  If the Bcb is dirty then capture the oldest and newest lsn</span>
00504         <span class="comment">//</span>
00505 
00506 
00507         <span class="keywordflow">if</span> ((Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o0">NodeTypeCode</a> == <a class="code" href="../../d5/d5/cc_8h.html#a14">CACHE_NTC_BCB</a>) &amp;&amp; Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o13">Dirty</a>) {
00508 
00509             LARGE_INTEGER BcbLsn, BcbNewest;
00510 
00511             BcbLsn = Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o6">OldestLsn</a>;
00512             BcbNewest = Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o7">NewestLsn</a>;
00513 
00514             <span class="keywordflow">if</span> ((BcbLsn.QuadPart != 0) &amp;&amp;
00515                 ((Oldest.QuadPart == 0) ||
00516                  (BcbLsn.QuadPart &lt; Oldest.QuadPart))) {
00517 
00518                  Oldest = BcbLsn;
00519             }
00520 
00521             <span class="keywordflow">if</span> ((BcbLsn.QuadPart != 0) &amp;&amp; (BcbNewest.QuadPart &gt; Newest.QuadPart)) {
00522 
00523                 Newest = BcbNewest;
00524             }
00525         }
00526 
00527 
00528         Bcb = CONTAINING_RECORD( Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o4">BcbLinks</a>.Flink, <a class="code" href="../../d4/d3/struct__BCB.html">BCB</a>, BcbLinks );
00529     }
00530 
00531     <span class="comment">//</span>
00532     <span class="comment">//  Now release the spin lock for this Bcb list and generate a callback</span>
00533     <span class="comment">//  if we got something.</span>
00534     <span class="comment">//</span>
00535 
00536     ExReleaseFastLock( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o36">BcbSpinLock</a>, OldIrql );
00537 
00538     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(OldestLsn)) {
00539 
00540         *OldestLsn = Oldest;
00541     }
00542 
00543     <span class="keywordflow">return</span> Newest;
00544 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:40:39 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
