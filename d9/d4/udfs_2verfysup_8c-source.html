<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: verfysup.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>verfysup.c</h1><a href="../../d8/d5/udfs_2verfysup_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1989  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    VerfySup.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module implements the Udfs Verification routines.</span>
00012 <span class="comment"></span>
00013 <span class="comment">Author:</span>
00014 <span class="comment"></span>
00015 <span class="comment">    Dan Lovinger    [DanLo]     18-July-1996</span>
00016 <span class="comment"></span>
00017 <span class="comment">Revision History:</span>
00018 <span class="comment"></span>
00019 <span class="comment">--*/</span>
00020 
00021 <span class="preprocessor">#include "UdfProcs.h"</span>
00022 
00023 <span class="comment">//</span>
00024 <span class="comment">//  The Bug check file id for this module</span>
00025 <span class="comment">//</span>
00026 
<a name="l00027"></a><a class="code" href="../../d8/d5/udfs_2verfysup_8c.html#a0">00027</a> <span class="preprocessor">#define BugCheckFileId                   (UDFS_BUG_CHECK_VERFYSUP)</span>
00028 <span class="preprocessor"></span>
00029 <span class="comment">//</span>
00030 <span class="comment">//  The local debug trace level</span>
00031 <span class="comment">//</span>
00032 
<a name="l00033"></a><a class="code" href="../../d8/d5/udfs_2verfysup_8c.html#a1">00033</a> <span class="preprocessor">#define Dbg                              (UDFS_DEBUG_LEVEL_VERFYSUP)</span>
00034 <span class="preprocessor"></span>
00035 <span class="preprocessor">#ifdef ALLOC_PRAGMA</span>
00036 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfVerifyFcbOperation)</span>
00037 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfVerifyVcb)</span>
00038 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00039 <span class="preprocessor"></span>
00040 
00041 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00042"></a><a class="code" href="../../d8/d5/udfs_2verfysup_8c.html#a2">00042</a> <a class="code" href="../../d8/d5/udfs_2verfysup_8c.html#a2">UdfPerformVerify</a> (
00043     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00044     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp,
00045     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceToVerify
00046     )
00047 
00048 <span class="comment">/*++</span>
00049 <span class="comment"></span>
00050 <span class="comment">Routine Description:</span>
00051 <span class="comment"></span>
00052 <span class="comment">    This routines performs an IoVerifyVolume operation and takes the</span>
00053 <span class="comment">    appropriate action.  If the verify is successful then we send the originating</span>
00054 <span class="comment">    Irp off to an Ex Worker Thread.  This routine is called from the exception handler.</span>
00055 <span class="comment"></span>
00056 <span class="comment">    No file system resources are held when this routine is called.</span>
00057 <span class="comment"></span>
00058 <span class="comment">Arguments:</span>
00059 <span class="comment"></span>
00060 <span class="comment">    Irp - The irp to send off after all is well and done.</span>
00061 <span class="comment"></span>
00062 <span class="comment">    Device - The real device needing verification.</span>
00063 <span class="comment"></span>
00064 <span class="comment">Return Value:</span>
00065 <span class="comment"></span>
00066 <span class="comment">    None.</span>
00067 <span class="comment"></span>
00068 <span class="comment">--*/</span>
00069 
00070 {
00071     <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb;
00072     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
00073     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> IrpSp;
00074 
00075     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
00076     <a class="code" href="../../d1/d8/udfdata_8h.html#a32">ASSERT_IRP</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
00077 
00078     <span class="comment">//</span>
00079     <span class="comment">//  Check if this Irp has a status of Verify required and if it does</span>
00080     <span class="comment">//  then call the I/O system to do a verify.</span>
00081     <span class="comment">//</span>
00082     <span class="comment">//  Skip the IoVerifyVolume if this is a mount or verify request</span>
00083     <span class="comment">//  itself.  Trying a recursive mount will cause a deadlock with</span>
00084     <span class="comment">//  the DeviceObject-&gt;DeviceLock.</span>
00085     <span class="comment">//</span>
00086 
00087     <span class="keywordflow">if</span> ((IrpContext-&gt;MajorFunction == <a class="code" href="../../d0/d5/io_8h.html#a26">IRP_MJ_FILE_SYSTEM_CONTROL</a>) &amp;&amp;
00088         ((IrpContext-&gt;MinorFunction == <a class="code" href="../../d0/d5/io_8h.html#a47">IRP_MN_MOUNT_VOLUME</a>) ||
00089          (IrpContext-&gt;MinorFunction == <a class="code" href="../../d0/d5/io_8h.html#a48">IRP_MN_VERIFY_VOLUME</a>))) {
00090 
00091         <span class="keywordflow">return</span> <a class="code" href="../../d2/d9/workque_8c.html#a4">UdfFsdPostRequest</a>( IrpContext, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
00092     }
00093 
00094     <span class="comment">//</span>
00095     <span class="comment">//  Extract a pointer to the Vcb from the VolumeDeviceObject.</span>
00096     <span class="comment">//  Note that since we have specifically excluded mount,</span>
00097     <span class="comment">//  requests, we know that IrpSp-&gt;DeviceObject is indeed a</span>
00098     <span class="comment">//  volume device object.</span>
00099     <span class="comment">//</span>
00100 
00101     IrpSp = <a class="code" href="../../d0/d5/io_8h.html#a228">IoGetCurrentIrpStackLocation</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
00102 
00103     Vcb = &amp;CONTAINING_RECORD( IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o57">DeviceObject</a>,
00104                               <a class="code" href="../../d6/d7/struct__VOLUME__DEVICE__OBJECT.html">VOLUME_DEVICE_OBJECT</a>,
00105                               DeviceObject )-&gt;Vcb;
00106 
00107     <span class="comment">//</span>
00108     <span class="comment">//  Check if the volume still thinks it needs to be verified,</span>
00109     <span class="comment">//  if it doesn't then we can skip doing a verify because someone</span>
00110     <span class="comment">//  else beat us to it.</span>
00111     <span class="comment">//</span>
00112 
00113     <span class="keywordflow">try</span> {
00114 
00115         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( DeviceToVerify-&gt;Flags, <a class="code" href="../../d0/d5/io_8h.html#a122">DO_VERIFY_VOLUME</a> )) {
00116 
00117             BOOLEAN AllowRawMount = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00118 
00119             <span class="comment">//</span>
00120             <span class="comment">//  We will allow Raw to mount this volume if we were doing a</span>
00121             <span class="comment">//  an absolute DASD open.</span>
00122             <span class="comment">//</span>
00123 
00124             <span class="keywordflow">if</span> ((IrpContext-&gt;MajorFunction == <a class="code" href="../../d0/d5/io_8h.html#a13">IRP_MJ_CREATE</a>) &amp;&amp;
00125                 (IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a>-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o19">FileName</a>.Length == 0) &amp;&amp;
00126                 (IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a>-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o9">RelatedFileObject</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
00127 
00128                 AllowRawMount = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00129             }
00130 
00131             <span class="comment">//</span>
00132             <span class="comment">//  If the IopMount in IoVerifyVolume did something, and</span>
00133             <span class="comment">//  this is an absolute open, force a reparse.</span>
00134             <span class="comment">//</span>
00135 
00136             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d4/d6/iosubs_8c.html#a122">IoVerifyVolume</a>( DeviceToVerify, AllowRawMount );
00137 
00138             <span class="comment">//</span>
00139             <span class="comment">//  If the verify operation completed it will return</span>
00140             <span class="comment">//  either STATUS_SUCCESS or STATUS_WRONG_VOLUME, exactly.</span>
00141             <span class="comment">//</span>
00142             <span class="comment">//  If UdfVerifyVolume encountered an error during</span>
00143             <span class="comment">//  processing, it will return that error.  If we got</span>
00144             <span class="comment">//  STATUS_WRONG_VOLUME from the verify, and our volume</span>
00145             <span class="comment">//  is now mounted, commute the status to STATUS_SUCCESS.</span>
00146             <span class="comment">//</span>
00147 
00148             <span class="keywordflow">if</span> ((<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_WRONG_VOLUME) &amp;&amp;
00149                 (Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o8">VcbCondition</a> == <a class="code" href="../../d6/d8/udfstruc_8h.html#a130a119">VcbMounted</a>)) {
00150 
00151                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
00152             }
00153 
00154             <span class="comment">//</span>
00155             <span class="comment">//  Do a quick unprotected check here.  The routine will do</span>
00156             <span class="comment">//  a safe check.  After here we can release the resource.</span>
00157             <span class="comment">//  Note that if the volume really went away, we will be taking</span>
00158             <span class="comment">//  the Reparse path.</span>
00159             <span class="comment">//</span>
00160 
00161             <span class="comment">//</span>
00162             <span class="comment">//  If the device might need to go away then call our dismount routine.</span>
00163             <span class="comment">//</span>
00164 
00165             <span class="keywordflow">if</span> (((Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o8">VcbCondition</a> == <a class="code" href="../../d6/d8/udfstruc_8h.html#a130a117">VcbNotMounted</a>) ||
00166                  (Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o8">VcbCondition</a> == <a class="code" href="../../d6/d8/udfstruc_8h.html#a130a120">VcbInvalid</a>) ||
00167                  (Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o8">VcbCondition</a> == <a class="code" href="../../d6/d8/udfstruc_8h.html#a130a121">VcbDismountInProgress</a>)) &amp;&amp;
00168                 (Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o16">VcbReference</a> &lt;= Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o18">VcbResidualReference</a>)) {
00169 
00170                 <a class="code" href="../../d3/d8/udfprocs_8h.html#a72">UdfAcquireUdfData</a>( IrpContext );
00171                 <a class="code" href="../../d8/d5/udfs_2verfysup_8c.html#a3">UdfCheckForDismount</a>( IrpContext, Vcb, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00172                 <a class="code" href="../../d3/d8/udfprocs_8h.html#a73">UdfReleaseUdfData</a>( IrpContext );
00173             }
00174 
00175             <span class="comment">//</span>
00176             <span class="comment">//  If this is a create and the verify succeeded then complete the</span>
00177             <span class="comment">//  request with a REPARSE status.</span>
00178             <span class="comment">//</span>
00179 
00180             <span class="keywordflow">if</span> ((IrpContext-&gt;MajorFunction == <a class="code" href="../../d0/d5/io_8h.html#a13">IRP_MJ_CREATE</a>) &amp;&amp;
00181                 (IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a>-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o9">RelatedFileObject</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
00182                 ((<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_SUCCESS) || (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_WRONG_VOLUME))) {
00183 
00184                 <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Information = <a class="code" href="../../d0/d5/io_8h.html#a109">IO_REMOUNT</a>;
00185 
00186                 <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, STATUS_REPARSE );
00187                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_REPARSE;
00188                 <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00189                 IrpContext = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00190 
00191             <span class="comment">//</span>
00192             <span class="comment">//  If there is still an error to process then call the Io system</span>
00193             <span class="comment">//  for a popup.</span>
00194             <span class="comment">//</span>
00195 
00196             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp; !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
00197 
00198                 <span class="comment">//</span>
00199                 <span class="comment">//  Fill in the device object if required.</span>
00200                 <span class="comment">//</span>
00201 
00202                 <span class="keywordflow">if</span> (<a class="code" href="../../d0/d5/io_8h.html#a232">IoIsErrorUserInduced</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> ) ) {
00203 
00204                     <a class="code" href="../../d4/d6/iosubs_8c.html#a105">IoSetHardErrorOrVerifyDevice</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, DeviceToVerify );
00205                 }
00206 
00207                 <a class="code" href="../../d3/d8/udfprocs_8h.html#a123">UdfNormalizeAndRaiseStatus</a>( IrpContext, <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> );
00208             }
00209         }
00210 
00211         <span class="comment">//</span>
00212         <span class="comment">//  If there is still an Irp, send it off to an Ex Worker thread.</span>
00213         <span class="comment">//</span>
00214 
00215         <span class="keywordflow">if</span> (IrpContext != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00216 
00217             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d2/d9/workque_8c.html#a4">UdfFsdPostRequest</a>( IrpContext, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
00218         }
00219 
00220     } except(<a class="code" href="../../d3/d8/udfprocs_8h.html#a127">UdfExceptionFilter</a>( IrpContext, GetExceptionInformation() )) {
00221 
00222         <span class="comment">//</span>
00223         <span class="comment">//  We had some trouble trying to perform the verify or raised</span>
00224         <span class="comment">//  an error ourselves.  So we'll abort the I/O request with</span>
00225         <span class="comment">//  the error status that we get back from the execption code.</span>
00226         <span class="comment">//</span>
00227 
00228         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d3/d8/udfprocs_8h.html#a128">UdfProcessException</a>( IrpContext, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, GetExceptionCode() );
00229     }
00230 
00231     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00232 }
00233 
00234 
00235 BOOLEAN
<a name="l00236"></a><a class="code" href="../../d8/d5/udfs_2verfysup_8c.html#a3">00236</a> <a class="code" href="../../d8/d5/udfs_2verfysup_8c.html#a3">UdfCheckForDismount</a> (
00237     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00238     IN <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb,
00239     IN BOOLEAN Force
00240     )
00241 
00242 <span class="comment">/*++</span>
00243 <span class="comment"></span>
00244 <span class="comment">Routine Description:</span>
00245 <span class="comment"></span>
00246 <span class="comment">    This routine is called to check if a volume is ready for dismount.  This</span>
00247 <span class="comment">    occurs when only file system references are left on the volume.</span>
00248 <span class="comment"></span>
00249 <span class="comment">    If the dismount is not currently underway and the user reference count</span>
00250 <span class="comment">    has gone to zero then we can begin the dismount.</span>
00251 <span class="comment"></span>
00252 <span class="comment">    If the dismount is in progress and there are no references left on the</span>
00253 <span class="comment">    volume (we check the Vpb for outstanding references as well to catch</span>
00254 <span class="comment">    any create calls dispatched to the file system) then we can delete</span>
00255 <span class="comment">    the Vcb.</span>
00256 <span class="comment"></span>
00257 <span class="comment">Arguments:</span>
00258 <span class="comment"></span>
00259 <span class="comment">    Vcb - Vcb for the volume to try to dismount.</span>
00260 <span class="comment">    </span>
00261 <span class="comment">    Force - Whether we will force this volume to be dismounted.</span>
00262 <span class="comment"></span>
00263 <span class="comment">Return Value:</span>
00264 <span class="comment"></span>
00265 <span class="comment">    BOOLEAN - True if the Vcb was not gone by the time this function finished,</span>
00266 <span class="comment">        False if it was deleted.</span>
00267 <span class="comment">        </span>
00268 <span class="comment">    This is only a trustworthy indication to the caller if it had the vcb</span>
00269 <span class="comment">    exclusive itself.</span>
00270 <span class="comment"></span>
00271 <span class="comment">--*/</span>
00272 
00273 {
00274     BOOLEAN UnlockVcb = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00275     BOOLEAN VcbPresent = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00276     KIRQL SavedIrql;
00277 
00278     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
00279     <a class="code" href="../../d1/d8/udfdata_8h.html#a12">ASSERT_VCB</a>( Vcb );
00280 
00281     <a class="code" href="../../d1/d8/udfdata_8h.html#a39">ASSERT_EXCLUSIVE_UDFDATA</a>;
00282 
00283     <span class="comment">//</span>
00284     <span class="comment">//  Acquire and lock this Vcb to check the dismount state.</span>
00285     <span class="comment">//</span>
00286 
00287     <a class="code" href="../../d3/d8/udfprocs_8h.html#a74">UdfAcquireVcbExclusive</a>( IrpContext, Vcb, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00288 
00289     <span class="comment">//</span>
00290     <span class="comment">//  Lets get rid of any pending closes for this volume.</span>
00291     <span class="comment">//</span>
00292 
00293     <a class="code" href="../../d3/d8/udfprocs_8h.html#a250">UdfFspClose</a>( Vcb );
00294 
00295     <a class="code" href="../../d3/d8/udfprocs_8h.html#a88">UdfLockVcb</a>( IrpContext, Vcb );
00296 
00297     <span class="comment">//</span>
00298     <span class="comment">//  If the dismount is not already underway then check if the</span>
00299     <span class="comment">//  user reference count has gone to zero or we are being forced</span>
00300     <span class="comment">//  to disconnect.  If so start the teardown on the Vcb.</span>
00301     <span class="comment">//</span>
00302 
00303     <span class="keywordflow">if</span> (Vcb-&gt;VcbCondition != <a class="code" href="../../d6/d8/udfstruc_8h.html#a130a121">VcbDismountInProgress</a>) {
00304 
00305         <span class="keywordflow">if</span> (Vcb-&gt;VcbUserReference &lt;= Vcb-&gt;VcbResidualUserReference || Force) {
00306 
00307             <a class="code" href="../../d3/d8/udfprocs_8h.html#a89">UdfUnlockVcb</a>( IrpContext, Vcb );
00308             UnlockVcb = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00309             VcbPresent = <a class="code" href="../../d8/d5/udfs_2verfysup_8c.html#a4">UdfDismountVcb</a>( IrpContext, Vcb );
00310         }
00311 
00312     <span class="comment">//</span>
00313     <span class="comment">//  If the teardown is underway and there are absolutely no references</span>
00314     <span class="comment">//  remaining then delete the Vcb.  References here include the</span>
00315     <span class="comment">//  references in the Vcb and Vpb.</span>
00316     <span class="comment">//</span>
00317 
00318     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Vcb-&gt;VcbReference == 0) {
00319 
00320         <a class="code" href="../../d4/d6/iosubs_8c.html#a10">IoAcquireVpbSpinLock</a>( &amp;SavedIrql );
00321 
00322         <span class="comment">//</span>
00323         <span class="comment">//  If there are no file objects and no reference counts in the</span>
00324         <span class="comment">//  Vpb we can delete the Vcb.  Don't forget that we have the</span>
00325         <span class="comment">//  last reference in the Vpb.</span>
00326         <span class="comment">//</span>
00327 
00328         <span class="keywordflow">if</span> (Vcb-&gt;Vpb-&gt;ReferenceCount == 1) {
00329 
00330             <a class="code" href="../../d4/d6/iosubs_8c.html#a102">IoReleaseVpbSpinLock</a>( SavedIrql );
00331             <a class="code" href="../../d3/d8/udfprocs_8h.html#a89">UdfUnlockVcb</a>( IrpContext, Vcb );
00332             UnlockVcb = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00333             <a class="code" href="../../d3/d8/udfprocs_8h.html#a206">UdfDeleteVcb</a>( IrpContext, Vcb );
00334             VcbPresent = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00335 
00336         } <span class="keywordflow">else</span> {
00337 
00338             <a class="code" href="../../d4/d6/iosubs_8c.html#a102">IoReleaseVpbSpinLock</a>( SavedIrql );
00339         }
00340     }
00341 
00342     <span class="comment">//</span>
00343     <span class="comment">//  Unlock the Vcb if still held.</span>
00344     <span class="comment">//</span>
00345 
00346     <span class="keywordflow">if</span> (UnlockVcb) {
00347 
00348         <a class="code" href="../../d3/d8/udfprocs_8h.html#a89">UdfUnlockVcb</a>( IrpContext, Vcb );
00349     }
00350 
00351     <span class="comment">//</span>
00352     <span class="comment">//  Release any resources still acquired.</span>
00353     <span class="comment">//</span>
00354 
00355     <span class="keywordflow">if</span> (VcbPresent) {
00356 
00357         <a class="code" href="../../d3/d8/udfprocs_8h.html#a76">UdfReleaseVcb</a>( IrpContext, Vcb );
00358     }
00359 
00360     <span class="keywordflow">return</span> VcbPresent;
00361 }
00362 
00363 
00364 BOOLEAN
<a name="l00365"></a><a class="code" href="../../d8/d5/udfs_2verfysup_8c.html#a4">00365</a> <a class="code" href="../../d8/d5/udfs_2verfysup_8c.html#a4">UdfDismountVcb</a> (
00366     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00367     IN <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb
00368     )
00369 
00370 <span class="comment">/*++</span>
00371 <span class="comment"></span>
00372 <span class="comment">Routine Description:</span>
00373 <span class="comment"></span>
00374 <span class="comment">    This routine is called when all of the user references to a volume are</span>
00375 <span class="comment">    gone.  We will initiate all of the teardown any system resources.</span>
00376 <span class="comment"></span>
00377 <span class="comment">    If all of the references to this volume are gone at the end of this routine</span>
00378 <span class="comment">    then we will complete the teardown of this Vcb and mark the current Vpb</span>
00379 <span class="comment">    as not mounted.  Otherwise we will allocated a new Vpb for this device</span>
00380 <span class="comment">    and keep the current Vpb attached to the Vcb.</span>
00381 <span class="comment"></span>
00382 <span class="comment">Arguments:</span>
00383 <span class="comment"></span>
00384 <span class="comment">    Vcb - Vcb for the volume to dismount.</span>
00385 <span class="comment"></span>
00386 <span class="comment">Return Value:</span>
00387 <span class="comment"></span>
00388 <span class="comment">    BOOLEAN - TRUE if we didn't delete the Vcb, FALSE otherwise.</span>
00389 <span class="comment"></span>
00390 <span class="comment">--*/</span>
00391 
00392 {
00393     <a class="code" href="../../d7/d7/struct__VPB.html">PVPB</a> OldVpb;
00394     <a class="code" href="../../d7/d7/struct__VPB.html">PVPB</a> NewVpb;
00395     BOOLEAN VcbPresent = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00396     KIRQL SavedIrql;
00397 
00398     BOOLEAN FinalReference;
00399 
00400     <a class="code" href="../../d1/d8/udfdata_8h.html#a39">ASSERT_EXCLUSIVE_UDFDATA</a>;
00401     <a class="code" href="../../d1/d8/udfdata_8h.html#a40">ASSERT_EXCLUSIVE_VCB</a>( Vcb );
00402 
00403     <a class="code" href="../../d3/d8/udfprocs_8h.html#a88">UdfLockVcb</a>( IrpContext, Vcb );
00404 
00405     <span class="comment">//</span>
00406     <span class="comment">//  We should only take this path once.</span>
00407     <span class="comment">//</span>
00408 
00409     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( Vcb-&gt;VcbCondition != <a class="code" href="../../d6/d8/udfstruc_8h.html#a130a121">VcbDismountInProgress</a> );
00410 
00411     <span class="comment">//</span>
00412     <span class="comment">//  Mark the Vcb as DismountInProgress.</span>
00413     <span class="comment">//</span>
00414 
00415     Vcb-&gt;VcbCondition = <a class="code" href="../../d6/d8/udfstruc_8h.html#a130a121">VcbDismountInProgress</a>;
00416 
00417     <span class="comment">//</span>
00418     <span class="comment">//  Remove our reference to the internal Fcb's.  The Fcb's will then</span>
00419     <span class="comment">//  be removed in the purge path below.</span>
00420     <span class="comment">//</span>
00421 
00422     <span class="keywordflow">if</span> (Vcb-&gt;RootIndexFcb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00423 
00424         Vcb-&gt;RootIndexFcb-&gt;FcbReference -= 1;
00425         Vcb-&gt;RootIndexFcb-&gt;FcbUserReference -= 1;
00426     }
00427 
00428     <span class="keywordflow">if</span> (Vcb-&gt;MetadataFcb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00429 
00430         Vcb-&gt;MetadataFcb-&gt;FcbReference -= 1;
00431         Vcb-&gt;MetadataFcb-&gt;FcbUserReference -= 1;
00432     }
00433 
00434     <span class="keywordflow">if</span> (Vcb-&gt;VatFcb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00435 
00436         Vcb-&gt;VatFcb-&gt;FcbReference -= 1;
00437         Vcb-&gt;VatFcb-&gt;FcbUserReference -= 1;
00438     }
00439 
00440     <span class="keywordflow">if</span> (Vcb-&gt;VolumeDasdFcb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00441 
00442         Vcb-&gt;VolumeDasdFcb-&gt;FcbReference -= 1;
00443         Vcb-&gt;VolumeDasdFcb-&gt;FcbUserReference -= 1;
00444     }
00445 
00446     <a class="code" href="../../d3/d8/udfprocs_8h.html#a89">UdfUnlockVcb</a>( IrpContext, Vcb );
00447 
00448     <span class="comment">//</span>
00449     <span class="comment">//  Purge the volume.</span>
00450     <span class="comment">//</span>
00451 
00452     <a class="code" href="../../d3/d8/udfprocs_8h.html#a158">UdfPurgeVolume</a>( IrpContext, Vcb, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
00453 
00454     <span class="comment">//</span>
00455     <span class="comment">//  Empty the delayed and async close queues.</span>
00456     <span class="comment">//</span>
00457 
00458     <a class="code" href="../../d3/d8/udfprocs_8h.html#a250">UdfFspClose</a>( Vcb );
00459 
00460     <span class="comment">//</span>
00461     <span class="comment">//  Allocate a new Vpb in case we will need it.</span>
00462     <span class="comment">//</span>
00463 
00464     NewVpb = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a175">NonPagedPoolMustSucceed</a>, <span class="keyword">sizeof</span>( <a class="code" href="../../d7/d7/struct__VPB.html">VPB</a> ), <a class="code" href="../../d1/d7/udfs_2nodetype_8h.html#a84">TAG_VPB</a> );
00465     RtlZeroMemory( NewVpb, <span class="keyword">sizeof</span>( <a class="code" href="../../d0/d5/io_8h.html#a332">VPB</a> ) );
00466 
00467     OldVpb = Vcb-&gt;Vpb;
00468 
00469     <span class="comment">//</span>
00470     <span class="comment">//  Remove the mount volume reference.</span>
00471     <span class="comment">//</span>
00472 
00473     <a class="code" href="../../d3/d8/udfprocs_8h.html#a88">UdfLockVcb</a>( IrpContext, Vcb );
00474     Vcb-&gt;VcbReference -= 1;
00475 
00476     <span class="comment">//</span>
00477     <span class="comment">//  Acquire the Vpb spinlock to check for Vpb references.</span>
00478     <span class="comment">//</span>
00479 
00480     <a class="code" href="../../d4/d6/iosubs_8c.html#a10">IoAcquireVpbSpinLock</a>( &amp;SavedIrql );
00481 
00482     <span class="comment">//</span>
00483     <span class="comment">//  Remember if this is the last reference on this Vcb.  We incremented</span>
00484     <span class="comment">//  the count on the Vpb earlier so we get one last crack it.  If our</span>
00485     <span class="comment">//  reference has gone to zero but the vpb reference count is greater</span>
00486     <span class="comment">//  than zero then the Io system will be responsible for deleting the</span>
00487     <span class="comment">//  Vpb.</span>
00488     <span class="comment">//</span>
00489 
00490     FinalReference = (BOOLEAN) ((Vcb-&gt;VcbReference == 0) &amp;&amp;
00491                                 (OldVpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o7">ReferenceCount</a> == 1));
00492 
00493     <span class="comment">//</span>
00494     <span class="comment">//  There is a reference count in the Vpb and in the Vcb.  We have</span>
00495     <span class="comment">//  incremented the reference count in the Vpb to make sure that</span>
00496     <span class="comment">//  we have last crack at it.  If this is a failed mount then we</span>
00497     <span class="comment">//  want to return the Vpb to the IO system to use for the next</span>
00498     <span class="comment">//  mount request.</span>
00499     <span class="comment">//</span>
00500 
00501     <span class="keywordflow">if</span> (OldVpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o5">RealDevice</a>-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o10">Vpb</a> == OldVpb) {
00502 
00503         <span class="comment">//</span>
00504         <span class="comment">//  If not the final reference then swap out the Vpb.  We must</span>
00505         <span class="comment">//  preserve the REMOVE_PENDING flag so that the device is</span>
00506         <span class="comment">//  not remounted in the middle of a PnP remove operation.</span>
00507         <span class="comment">//</span>
00508 
00509         <span class="keywordflow">if</span> (!FinalReference) {
00510 
00511             NewVpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o0">Type</a> = <a class="code" href="../../d0/d5/io_8h.html#a9">IO_TYPE_VPB</a>;
00512             NewVpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o1">Size</a> = <span class="keyword">sizeof</span>( <a class="code" href="../../d0/d5/io_8h.html#a332">VPB</a> );
00513             NewVpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o5">RealDevice</a> = OldVpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o5">RealDevice</a>;
00514 
00515             NewVpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o5">RealDevice</a>-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o10">Vpb</a> = NewVpb;
00516 
00517             NewVpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o2">Flags</a> = <a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( OldVpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o2">Flags</a>, <a class="code" href="../../d0/d5/io_8h.html#a119">VPB_REMOVE_PENDING</a> );
00518             
00519             NewVpb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00520             <a class="code" href="../../d4/d6/iosubs_8c.html#a102">IoReleaseVpbSpinLock</a>( SavedIrql );
00521             <a class="code" href="../../d3/d8/udfprocs_8h.html#a89">UdfUnlockVcb</a>( IrpContext, Vcb );
00522 
00523         <span class="comment">//</span>
00524         <span class="comment">//  We want to leave the Vpb for the IO system.  Mark it</span>
00525         <span class="comment">//  as being not mounted.  Go ahead and delete the Vcb as</span>
00526         <span class="comment">//  well.</span>
00527         <span class="comment">//</span>
00528 
00529         } <span class="keywordflow">else</span> {
00530 
00531             <span class="comment">//</span>
00532             <span class="comment">//  Make sure to remove the last reference on the Vpb.</span>
00533             <span class="comment">//</span>
00534 
00535             OldVpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o7">ReferenceCount</a> -= 1;
00536 
00537             OldVpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o4">DeviceObject</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00538             <a class="code" href="../../d5/d5/cc_8h.html#a61">ClearFlag</a>( Vcb-&gt;Vpb-&gt;Flags, <a class="code" href="../../d0/d5/io_8h.html#a116">VPB_MOUNTED</a> );
00539 
00540             <span class="comment">//</span>
00541             <span class="comment">//  Clear the Vpb flag so we know not to delete it.</span>
00542             <span class="comment">//</span>
00543 
00544             Vcb-&gt;Vpb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00545 
00546             <a class="code" href="../../d4/d6/iosubs_8c.html#a102">IoReleaseVpbSpinLock</a>( SavedIrql );
00547             <a class="code" href="../../d3/d8/udfprocs_8h.html#a89">UdfUnlockVcb</a>( IrpContext, Vcb );
00548             <a class="code" href="../../d3/d8/udfprocs_8h.html#a206">UdfDeleteVcb</a>( IrpContext, Vcb );
00549             VcbPresent = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00550         }
00551 
00552     <span class="comment">//</span>
00553     <span class="comment">//  Someone has already swapped in a new Vpb.  If this is the final reference</span>
00554     <span class="comment">//  then the file system is responsible for deleting the Vpb.</span>
00555     <span class="comment">//</span>
00556 
00557     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (FinalReference) {
00558 
00559         <span class="comment">//</span>
00560         <span class="comment">//  Make sure to remove the last reference on the Vpb.</span>
00561         <span class="comment">//</span>
00562 
00563         OldVpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o7">ReferenceCount</a> -= 1;
00564 
00565         <a class="code" href="../../d4/d6/iosubs_8c.html#a102">IoReleaseVpbSpinLock</a>( SavedIrql );
00566         <a class="code" href="../../d3/d8/udfprocs_8h.html#a89">UdfUnlockVcb</a>( IrpContext, Vcb );
00567         <a class="code" href="../../d3/d8/udfprocs_8h.html#a206">UdfDeleteVcb</a>( IrpContext, Vcb );
00568         VcbPresent = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00569 
00570     <span class="comment">//</span>
00571     <span class="comment">//  The current Vpb is no longer the Vpb for the device (the IO system</span>
00572     <span class="comment">//  has already allocated a new one).  We leave our reference in the</span>
00573     <span class="comment">//  Vpb and will be responsible for deleting it at a later time.</span>
00574     <span class="comment">//</span>
00575 
00576     } <span class="keywordflow">else</span> {
00577 
00578         OldVpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o4">DeviceObject</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00579         <a class="code" href="../../d5/d5/cc_8h.html#a61">ClearFlag</a>( Vcb-&gt;Vpb-&gt;Flags, <a class="code" href="../../d0/d5/io_8h.html#a116">VPB_MOUNTED</a> );
00580 
00581         <a class="code" href="../../d4/d6/iosubs_8c.html#a102">IoReleaseVpbSpinLock</a>( SavedIrql );
00582         <a class="code" href="../../d3/d8/udfprocs_8h.html#a89">UdfUnlockVcb</a>( IrpContext, Vcb );
00583     }
00584 
00585     <span class="comment">//</span>
00586     <span class="comment">//  Deallocate the new Vpb if we don't need it.</span>
00587     <span class="comment">//</span>
00588 
00589     <span class="keywordflow">if</span> (NewVpb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00590 
00591         <a class="code" href="../../d3/d8/udfprocs_8h.html#a124">UdfFreePool</a>( &amp;NewVpb );
00592     }
00593 
00594     <span class="comment">//</span>
00595     <span class="comment">//  Let our caller know whether the Vcb is still present.</span>
00596     <span class="comment">//</span>
00597 
00598     <span class="keywordflow">return</span> VcbPresent;
00599 }
00600 
00601 
00602 
<a name="l00603"></a><a class="code" href="../../d8/d5/udfs_2verfysup_8c.html#a5">00603</a> <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00604 <a class="code" href="../../d8/d5/udfs_2verfysup_8c.html#a5">UdfVerifyVcb</a> (
00605     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00606     IN <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb
00607     )
00608 
00609 <span class="comment">/*++</span>
00610 <span class="comment"></span>
00611 <span class="comment">Routine Description:</span>
00612 <span class="comment"></span>
00613 <span class="comment">    This routine checks that the current Vcb is valid and currently mounted</span>
00614 <span class="comment">    on the device.  It will raise on an error condition.</span>
00615 <span class="comment"></span>
00616 <span class="comment">    We check whether the volume needs verification and the current state</span>
00617 <span class="comment">    of the Vcb.</span>
00618 <span class="comment"></span>
00619 <span class="comment">Arguments:</span>
00620 <span class="comment"></span>
00621 <span class="comment">    Vcb - This is the volume to verify.</span>
00622 <span class="comment"></span>
00623 <span class="comment">Return Value:</span>
00624 <span class="comment"></span>
00625 <span class="comment">    None</span>
00626 <span class="comment"></span>
00627 <span class="comment">--*/</span>
00628 
00629 {
00630     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00631     IO_STATUS_BLOCK Iosb;
00632     ULONG MediaChangeCount = 0;
00633 
00634     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00635 
00636     <span class="comment">//</span>
00637     <span class="comment">//  Fail immediately if the volume is in the progress of being dismounted</span>
00638     <span class="comment">//  or has been marked invalid.</span>
00639     <span class="comment">//</span>
00640 
00641     <span class="keywordflow">if</span> ((Vcb-&gt;VcbCondition == <a class="code" href="../../d6/d8/udfstruc_8h.html#a130a120">VcbInvalid</a>) ||
00642         (Vcb-&gt;VcbCondition == <a class="code" href="../../d6/d8/udfstruc_8h.html#a130a121">VcbDismountInProgress</a>)) {
00643 
00644         <a class="code" href="../../d3/d8/udfprocs_8h.html#a122">UdfRaiseStatus</a>( IrpContext, STATUS_FILE_INVALID );
00645     }
00646 
00647     <span class="comment">//</span>
00648     <span class="comment">//  If the media is removable and the verify volume flag in the</span>
00649     <span class="comment">//  device object is not set then we want to ping the device</span>
00650     <span class="comment">//  to see if it needs to be verified</span>
00651     <span class="comment">//</span>
00652 
00653     <span class="keywordflow">if</span> ((Vcb-&gt;VcbCondition != <a class="code" href="../../d6/d8/udfstruc_8h.html#a130a118">VcbMountInProgress</a>) &amp;&amp;
00654         <a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( Vcb-&gt;VcbState, <a class="code" href="../../d6/d8/udfstruc_8h.html#a6">VCB_STATE_REMOVABLE_MEDIA</a> ) &amp;&amp;
00655         !<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( Vcb-&gt;Vpb-&gt;RealDevice-&gt;Flags, <a class="code" href="../../d0/d5/io_8h.html#a122">DO_VERIFY_VOLUME</a> )) {
00656 
00657         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d3/d8/udfprocs_8h.html#a159">UdfPerformDevIoCtrl</a>( IrpContext,
00658                                       ( Vcb-&gt;Vpb-&gt;RealDevice-&gt;DeviceType == FILE_DEVICE_CD_ROM ?
00659                                         IOCTL_CDROM_CHECK_VERIFY :
00660                                         IOCTL_DISK_CHECK_VERIFY ),
00661                                       Vcb-&gt;TargetDeviceObject,
00662                                       &amp;MediaChangeCount,
00663                                       <span class="keyword">sizeof</span>(ULONG),
00664                                       <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00665                                       <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00666                                       &amp;Iosb );
00667 
00668         <span class="keywordflow">if</span> (Iosb.Information != <span class="keyword">sizeof</span>(ULONG)) {
00669     
00670             <span class="comment">//</span>
00671             <span class="comment">//  Be safe about the count in case the driver didn't fill it in</span>
00672             <span class="comment">//</span>
00673     
00674             MediaChangeCount = 0;
00675         }
00676 
00677         <span class="comment">//</span>
00678         <span class="comment">//  If the volume is now an empty device, or we have receieved a</span>
00679         <span class="comment">//  bare STATUS_VERIFY_REQUIRED (various hardware conditions such</span>
00680         <span class="comment">//  as bus resets, etc., will trigger this in the drivers), or the</span>
00681         <span class="comment">//  media change count has moved since we last inspected the device,</span>
00682         <span class="comment">//  then mark the volume to be verified.</span>
00683         <span class="comment">//      </span>
00684 
00685         <span class="keywordflow">if</span> ((Vcb-&gt;VcbCondition == <a class="code" href="../../d6/d8/udfstruc_8h.html#a130a119">VcbMounted</a> &amp;&amp;
00686              <a class="code" href="../../d3/d8/udfprocs_8h.html#a100">UdfIsRawDevice</a>( IrpContext, <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) ||
00687             (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_VERIFY_REQUIRED) ||
00688             (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>) &amp;&amp;
00689              (Vcb-&gt;MediaChangeCount != MediaChangeCount))) {
00690 
00691             <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>( Vcb-&gt;Vpb-&gt;RealDevice-&gt;Flags, <a class="code" href="../../d0/d5/io_8h.html#a122">DO_VERIFY_VOLUME</a> );
00692 
00693             <span class="comment">//</span>
00694             <span class="comment">//  If the volume is not mounted and we got a media change count,</span>
00695             <span class="comment">//  update the Vcb so we do not trigger a verify again at this</span>
00696             <span class="comment">//  count value.  If the verify-&gt;mount path detects that the media</span>
00697             <span class="comment">//  has actually changed and this Vcb is valid again, this will have</span>
00698             <span class="comment">//  done nothing.  We are already synchronized since the caller has</span>
00699             <span class="comment">//  the Vcb.</span>
00700             <span class="comment">//</span>
00701 
00702             <span class="keywordflow">if</span> ((Vcb-&gt;VcbCondition == <a class="code" href="../../d6/d8/udfstruc_8h.html#a130a117">VcbNotMounted</a>) &amp;&amp;
00703                 <a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
00704 
00705                 Vcb-&gt;MediaChangeCount = MediaChangeCount;
00706             }
00707 
00708         <span class="comment">//</span>
00709         <span class="comment">//  Raise the error condition otherwise.</span>
00710         <span class="comment">//</span>
00711 
00712         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
00713 
00714             <a class="code" href="../../d3/d8/udfprocs_8h.html#a123">UdfNormalizeAndRaiseStatus</a>( IrpContext, <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> );
00715         }
00716 
00717     }
00718 
00719     <span class="comment">//</span>
00720     <span class="comment">//  The Vcb may be mounted but the underlying real device may need to be verified.</span>
00721     <span class="comment">//  If it does then we'll set the Iosb in the irp to be our real device</span>
00722     <span class="comment">//  and raise Verify required</span>
00723     <span class="comment">//</span>
00724 
00725     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( Vcb-&gt;Vpb-&gt;RealDevice-&gt;Flags, <a class="code" href="../../d0/d5/io_8h.html#a122">DO_VERIFY_VOLUME</a> )) {
00726 
00727         <a class="code" href="../../d4/d6/iosubs_8c.html#a105">IoSetHardErrorOrVerifyDevice</a>( IrpContext-&gt;Irp,
00728                                       Vcb-&gt;Vpb-&gt;RealDevice );
00729 
00730         <a class="code" href="../../d3/d8/udfprocs_8h.html#a122">UdfRaiseStatus</a>( IrpContext, STATUS_VERIFY_REQUIRED );
00731     }
00732 
00733     <span class="comment">//</span>
00734     <span class="comment">//  Based on the condition of the Vcb we'll either return to our</span>
00735     <span class="comment">//  caller or raise an error condition</span>
00736     <span class="comment">//</span>
00737 
00738     <span class="keywordflow">switch</span> (Vcb-&gt;VcbCondition) {
00739 
00740     <span class="keywordflow">case</span> <a class="code" href="../../d6/d8/udfstruc_8h.html#a130a117">VcbNotMounted</a>:
00741 
00742         <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>( Vcb-&gt;Vpb-&gt;RealDevice-&gt;Flags, <a class="code" href="../../d0/d5/io_8h.html#a122">DO_VERIFY_VOLUME</a> );
00743 
00744         <a class="code" href="../../d4/d6/iosubs_8c.html#a105">IoSetHardErrorOrVerifyDevice</a>( IrpContext-&gt;Irp, Vcb-&gt;Vpb-&gt;RealDevice );
00745 
00746         <a class="code" href="../../d3/d8/udfprocs_8h.html#a122">UdfRaiseStatus</a>( IrpContext, STATUS_WRONG_VOLUME );
00747         <span class="keywordflow">break</span>;
00748 
00749     <span class="keywordflow">case</span> <a class="code" href="../../d6/d8/udfstruc_8h.html#a130a120">VcbInvalid</a>:
00750     <span class="keywordflow">case</span> <a class="code" href="../../d6/d8/udfstruc_8h.html#a130a121">VcbDismountInProgress</a> :
00751 
00752         <a class="code" href="../../d3/d8/udfprocs_8h.html#a122">UdfRaiseStatus</a>( IrpContext, STATUS_FILE_INVALID );
00753         <span class="keywordflow">break</span>;
00754     }
00755 
00756     <span class="keywordflow">return</span>;
00757 }
00758 
00759 
<a name="l00760"></a><a class="code" href="../../d8/d5/udfs_2verfysup_8c.html#a6">00760</a> 
00761 BOOLEAN
00762 <a class="code" href="../../d8/d5/udfs_2verfysup_8c.html#a6">UdfVerifyFcbOperation</a> (
00763     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext OPTIONAL,
00764     IN <a class="code" href="../../d7/d9/struct__FCB.html">PFCB</a> Fcb
00765     )
00766 
00767 <span class="comment">/*++</span>
00768 <span class="comment"></span>
00769 <span class="comment">Routine Description:</span>
00770 <span class="comment"></span>
00771 <span class="comment">    This routine is called to verify that the state of the Fcb is valid</span>
00772 <span class="comment">    to allow the current operation to continue.  We use the state of the</span>
00773 <span class="comment">    Vcb, target device and type of operation to determine this.</span>
00774 <span class="comment"></span>
00775 <span class="comment">Arguments:</span>
00776 <span class="comment"></span>
00777 <span class="comment">    IrpContext - IrpContext for the request.  If not present then we</span>
00778 <span class="comment">        were called from the fast IO path.</span>
00779 <span class="comment"></span>
00780 <span class="comment">    Fcb - Fcb to perform the request on.</span>
00781 <span class="comment"></span>
00782 <span class="comment">Return Value:</span>
00783 <span class="comment"></span>
00784 <span class="comment">    BOOLEAN - TRUE if the request can continue, FALSE otherwise.</span>
00785 <span class="comment"></span>
00786 <span class="comment">--*/</span>
00787 
00788 {
00789     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
00790     <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb = Fcb-&gt;Vcb;
00791     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> RealDevice = Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o2">Vpb</a>-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o5">RealDevice</a>;
00792 
00793     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00794 
00795     <span class="comment">//</span>
00796     <span class="comment">//  Fail immediately if the volume is in the progress of being dismounted</span>
00797     <span class="comment">//  or has been marked invalid.</span>
00798     <span class="comment">//</span>
00799 
00800     <span class="keywordflow">if</span> ((Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o8">VcbCondition</a> == <a class="code" href="../../d6/d8/udfstruc_8h.html#a130a120">VcbInvalid</a>) ||
00801         (Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o8">VcbCondition</a> == <a class="code" href="../../d6/d8/udfstruc_8h.html#a130a121">VcbDismountInProgress</a>)) {
00802 
00803         <span class="keywordflow">if</span> (ARGUMENT_PRESENT( IrpContext )) {
00804 
00805             <a class="code" href="../../d3/d8/udfprocs_8h.html#a122">UdfRaiseStatus</a>( IrpContext, STATUS_FILE_INVALID );
00806         }
00807 
00808         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00809     }
00810 
00811     <span class="comment">//</span>
00812     <span class="comment">//  Always fail if the volume needs to be verified.</span>
00813     <span class="comment">//</span>
00814 
00815     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( RealDevice-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o8">Flags</a>, <a class="code" href="../../d0/d5/io_8h.html#a122">DO_VERIFY_VOLUME</a> )) {
00816 
00817         <span class="keywordflow">if</span> (ARGUMENT_PRESENT( IrpContext )) {
00818 
00819             <a class="code" href="../../d4/d6/iosubs_8c.html#a105">IoSetHardErrorOrVerifyDevice</a>( IrpContext-&gt;Irp,
00820                                           RealDevice );
00821 
00822             <a class="code" href="../../d3/d8/udfprocs_8h.html#a122">UdfRaiseStatus</a>( IrpContext, STATUS_VERIFY_REQUIRED );
00823         }
00824 
00825         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00826 
00827     <span class="comment">//</span>
00828     <span class="comment">//  All operations are allowed on mounted volumes.</span>
00829     <span class="comment">//</span>
00830 
00831     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o8">VcbCondition</a> == <a class="code" href="../../d6/d8/udfstruc_8h.html#a130a119">VcbMounted</a>) ||
00832                (Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o8">VcbCondition</a> == <a class="code" href="../../d6/d8/udfstruc_8h.html#a130a118">VcbMountInProgress</a>)) {
00833 
00834         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00835 
00836     <span class="comment">//</span>
00837     <span class="comment">//  Fail all requests for fast Io on other Vcb conditions.</span>
00838     <span class="comment">//</span>
00839 
00840     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!ARGUMENT_PRESENT( IrpContext )) {
00841 
00842         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00843 
00844     <span class="comment">//</span>
00845     <span class="comment">//  The remaining case is VcbNotMounted.</span>
00846     <span class="comment">//  Mark the device to be verified and raise WRONG_VOLUME.</span>
00847     <span class="comment">//</span>
00848 
00849     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o8">VcbCondition</a> == <a class="code" href="../../d6/d8/udfstruc_8h.html#a130a117">VcbNotMounted</a>) {
00850 
00851         <span class="keywordflow">if</span> (ARGUMENT_PRESENT( IrpContext )) {
00852 
00853             <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>(RealDevice-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o8">Flags</a>, <a class="code" href="../../d0/d5/io_8h.html#a122">DO_VERIFY_VOLUME</a>);
00854 
00855             <a class="code" href="../../d4/d6/iosubs_8c.html#a105">IoSetHardErrorOrVerifyDevice</a>( IrpContext-&gt;Irp, RealDevice );
00856             <a class="code" href="../../d3/d8/udfprocs_8h.html#a122">UdfRaiseStatus</a>( IrpContext, STATUS_WRONG_VOLUME );
00857         }
00858 
00859         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00860     }
00861 
00862     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00863 }
00864 
00865 
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:42:22 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
