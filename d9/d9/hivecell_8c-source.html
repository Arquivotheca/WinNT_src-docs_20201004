<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: hivecell.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>hivecell.c</h1><a href="../../d8/d0/hivecell_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1991  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    hivecell.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module implements hive cell procedures.</span>
00012 <span class="comment"></span>
00013 <span class="comment">Author:</span>
00014 <span class="comment"></span>
00015 <span class="comment">    Bryan M. Willman (bryanwi) 27-Mar-92</span>
00016 <span class="comment"></span>
00017 <span class="comment">Environment:</span>
00018 <span class="comment"></span>
00019 <span class="comment"></span>
00020 <span class="comment">Revision History:</span>
00021 <span class="comment">    Dragos C. Sambotin (dragoss) 22-Dec-98</span>
00022 <span class="comment">        Requests for cells bigger than 1K are doubled. This way </span>
00023 <span class="comment">        we avoid fragmentation and we make the value-growing </span>
00024 <span class="comment">        process more flexible.</span>
00025 <span class="comment">    Dragos C. Sambotin (dragoss) 13-Jan-99</span>
00026 <span class="comment">        At boot time, order the free cells list ascending.</span>
00027 <span class="comment"></span>
00028 <span class="comment">--*/</span>
00029 
00030 <span class="preprocessor">#include    "<a class="code" href="../../d1/d2/cmp_8h.html">cmp.h</a>"</span>
00031 
00032 <span class="comment">//</span>
00033 <span class="comment">// Private procedures</span>
00034 <span class="comment">//</span>
00035 <a class="code" href="../../d0/d1/hivedata_8h.html#a49">HCELL_INDEX</a>
00036 <a class="code" href="../../d8/d0/hivecell_8c.html#a7">HvpDoAllocateCell</a>(
00037     <a class="code" href="../../d7/d7/struct__HHIVE.html">PHHIVE</a>          Hive,
00038     ULONG           NewSize,
00039     HSTORAGE_TYPE   Type
00040     );
00041 
00042 ULONG
00043 <a class="code" href="../../d8/d0/hivecell_8c.html#a8">HvpAllocateInBin</a>(
00044     <a class="code" href="../../d7/d7/struct__HHIVE.html">PHHIVE</a>  Hive,
00045     <a class="code" href="../../d7/d4/struct__HBIN.html">PHBIN</a>   Bin,
00046     ULONG   Size,
00047     ULONG   Type
00048     );
00049 
00050 BOOLEAN
00051 <a class="code" href="../../d8/d0/hivecell_8c.html#a9">HvpMakeBinPresent</a>(
00052     IN <a class="code" href="../../d7/d7/struct__HHIVE.html">PHHIVE</a> Hive,
00053     IN HCELL_INDEX Cell,
00054     IN <a class="code" href="../../d2/d8/struct__HMAP__ENTRY.html">PHMAP_ENTRY</a> Map
00055     );
00056 
00057 BOOLEAN
00058 <a class="code" href="../../d8/d0/hivecell_8c.html#a10">HvpIsFreeNeighbor</a>(
00059     <a class="code" href="../../d7/d7/struct__HHIVE.html">PHHIVE</a>  Hive,
00060     <a class="code" href="../../d7/d4/struct__HBIN.html">PHBIN</a>   Bin,
00061     <a class="code" href="../../d8/d4/struct__HCELL.html">PHCELL</a>  FreeCell,
00062     <a class="code" href="../../d8/d4/struct__HCELL.html">PHCELL</a>  *FreeNeighbor,
00063     HSTORAGE_TYPE Type
00064     );
00065 
00066 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00067 <a class="code" href="../../d6/d1/hiveload_8c.html#a18">HvpDelistBinFreeCells</a>(
00068     <a class="code" href="../../d7/d7/struct__HHIVE.html">PHHIVE</a>  Hive,
00069     <a class="code" href="../../d7/d4/struct__HBIN.html">PHBIN</a>   Bin,
00070     HSTORAGE_TYPE Type,
00071     PHCELL_INDEX TailDisplay OPTIONAL
00072     );
00073 
<a name="l00074"></a><a class="code" href="../../d8/d0/hivecell_8c.html#a0">00074</a> <span class="preprocessor">#define CmpFindFirstSetRight KiFindFirstSetRight</span>
<a name="l00075"></a><a class="code" href="../../d8/d0/hivecell_8c.html#a5">00075</a> <span class="preprocessor"></span><span class="keyword">extern</span> CCHAR <a class="code" href="../../d8/d0/hivecell_8c.html#a5">KiFindFirstSetRight</a>[256];
<a name="l00076"></a><a class="code" href="../../d8/d0/hivecell_8c.html#a1">00076</a> <span class="preprocessor">#define CmpFindFirstSetLeft KiFindFirstSetLeft</span>
<a name="l00077"></a><a class="code" href="../../d8/d0/hivecell_8c.html#a6">00077</a> <span class="preprocessor"></span><span class="keyword">extern</span> CCHAR <a class="code" href="../../d8/d0/hivecell_8c.html#a6">KiFindFirstSetLeft</a>[256];
00078 
<a name="l00079"></a><a class="code" href="../../d8/d0/hivecell_8c.html#a2">00079</a> <span class="preprocessor">#define HvpComputeIndex(Index, Size)                                    \</span>
00080 <span class="preprocessor">    {                                                                   \</span>
00081 <span class="preprocessor">        Index = (Size &gt;&gt; HHIVE_FREE_DISPLAY_SHIFT) - 1;                 \</span>
00082 <span class="preprocessor">        if (Index &gt;= HHIVE_LINEAR_INDEX ) {                             \</span>
00083 <span class="preprocessor">                                                                        \</span>
00084 <span class="preprocessor">            </span><span class="comment">/*                                                          \</span>
00085 <span class="comment">            ** Too big for the linear lists, compute the exponential    \</span>
00086 <span class="comment">            ** list.                                                    \</span>
00087 <span class="comment">            */</span>                                                          \
00088                                                                         \
00089             if (Index &gt; 255) {                                          \
00090                 <span class="comment">/*                                                      \</span>
00091 <span class="comment">                ** Too big for all the lists, use the last index.       \</span>
00092 <span class="comment">                */</span>                                                      \
00093                 Index = HHIVE_FREE_DISPLAY_SIZE-1;                      \
00094             } else {                                                    \
00095                 Index = CmpFindFirstSetLeft[Index] +                    \
<a name="l00096"></a><a class="code" href="../../d8/d0/hivecell_8c.html#a3">00096</a>                         HHIVE_FREE_DISPLAY_BIAS;                        \
00097             }                                                           \
00098         }                                                               \
00099     }
00100 
00101 <span class="preprocessor">#define ONE_K   1024</span>
00102 <span class="preprocessor"></span>
00103 <span class="comment">//  Double requests bigger  than 1KB                       </span>
00104 <span class="comment">//  CmpSetValueKeyExisting  always allocates a bigger data </span>
00105 <span class="comment">//  value cell  exactly the required size. This creates    </span>
00106 <span class="comment">//  problems when somebody  slowly grows a value one DWORD </span>
00107 <span class="comment">//  at a time to  some enormous size. An easy fix for this </span>
00108 <span class="comment">//  would be to set a  certain threshold (like 1K). Once a </span>
<a name="l00109"></a><a class="code" href="../../d8/d0/hivecell_8c.html#a4">00109</a> <span class="comment">//  value size  crosses that threshold, allocate a new cell</span>
00110 <span class="comment">//  that is twice  the old size. So the actual allocated   </span>
00111 <span class="comment">//  size  would grow to 1k, then 2k, 4k, 8k, 16k, 32k,etc. </span>
00112 <span class="comment">//  This will reduce the fragmentation.                    </span>
00113 
00114 <span class="preprocessor">#define HvpAdjustCellSize(Size)                                         \</span>
00115 <span class="preprocessor">    {                                                                   \</span>
00116 <span class="preprocessor">        ULONG   onek = ONE_K;                                           \</span>
00117 <span class="preprocessor">        ULONG   Limit = 0;                                              \</span>
00118 <span class="preprocessor">                                                                        \</span>
00119 <span class="preprocessor">        while( Size &gt; onek ) {                                          \</span>
00120 <span class="preprocessor">            onek&lt;&lt;=1;                                                   \</span>
00121 <span class="preprocessor">            Limit++;                                                    \</span>
00122 <span class="preprocessor">        }                                                               \</span>
00123 <span class="preprocessor">                                                                        \</span>
00124 <span class="preprocessor">        Size = Limit?onek:Size;                                         \</span>
00125 <span class="preprocessor">    }   </span>
00126 <span class="preprocessor"></span>
00127 
00128 <span class="preprocessor">#ifdef ALLOC_PRAGMA</span>
00129 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,HvpGetCellPaged)</span>
00130 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,HvpGetCellFlat)</span>
00131 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,HvpGetCellMap)</span>
00132 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,HvGetCellSize)</span>
00133 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,HvAllocateCell)</span>
00134 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,HvpDoAllocateCell)</span>
00135 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,HvFreeCell)</span>
00136 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,HvpIsFreeNeighbor)</span>
00137 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,HvpEnlistFreeCell)</span>
00138 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,HvpDelistFreeCell)</span>
00139 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,HvReallocateCell)</span>
00140 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,HvIsCellAllocated)</span>
00141 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,HvpAllocateInBin)</span>
00142 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,HvpMakeBinPresent)</span>
00143 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,HvpDelistBinFreeCells)</span>
00144 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00145 <span class="preprocessor"></span>
<a name="l00146"></a><a class="code" href="../../d8/d0/hivecell_8c.html#a12">00146</a> 
00147 <span class="comment">//</span>
00148 <span class="comment">//  Cell Procedures</span>
00149 <span class="comment">//</span>
00150 <span class="keyword">struct </span><a class="code" href="../../d4/d9/struct__CELL__DATA.html">_CELL_DATA</a> *
00151 <a class="code" href="../../d8/d0/hivecell_8c.html#a12">HvpGetCellPaged</a>(
00152     <a class="code" href="../../d7/d7/struct__HHIVE.html">PHHIVE</a>      Hive,
00153     HCELL_INDEX Cell
00154     )
00155 <span class="comment">/*++</span>
00156 <span class="comment"></span>
00157 <span class="comment">Routine Description:</span>
00158 <span class="comment"></span>
00159 <span class="comment">    Returns the memory address for the specified Cell.  Will never</span>
00160 <span class="comment">    return failure, but may assert.  Use HvIsCellAllocated to check</span>
00161 <span class="comment">    validity of Cell.</span>
00162 <span class="comment"></span>
00163 <span class="comment">    This routine should never be called directly, always call it</span>
00164 <span class="comment">    via the HvGetCell() macro.</span>
00165 <span class="comment"></span>
00166 <span class="comment">    This routine provides GetCell support for hives with full maps.</span>
00167 <span class="comment">    It is the normal version of the routine.</span>
00168 <span class="comment"></span>
00169 <span class="comment">Arguments:</span>
00170 <span class="comment"></span>
00171 <span class="comment">    Hive - supplies a pointer to the hive control structure for the</span>
00172 <span class="comment">            hive of interest</span>
00173 <span class="comment"></span>
00174 <span class="comment">    Cell - supplies HCELL_INDEX of cell to return address for</span>
00175 <span class="comment"></span>
00176 <span class="comment">Return Value:</span>
00177 <span class="comment"></span>
00178 <span class="comment">    Address of Cell in memory.  Assert or BugCheck if error.</span>
00179 <span class="comment"></span>
00180 <span class="comment">--*/</span>
00181 {
00182     ULONG           Type;
00183     ULONG           Table;
00184     ULONG           Block;
00185     ULONG           <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>;
00186     <a class="code" href="../../d8/d4/struct__HCELL.html">PHCELL</a>          pcell;
00187     <a class="code" href="../../d2/d8/struct__HMAP__ENTRY.html">PHMAP_ENTRY</a>     Map;
00188 
00189     <a class="code" href="../../d1/d2/cmp_8h.html#a55">CMLOG</a>(<a class="code" href="../../d1/d2/cmp_8h.html#a24">CML_FLOW</a>, <a class="code" href="../../d1/d2/cmp_8h.html#a26">CMS_MAP</a>) {
00190         KdPrint((<span class="stringliteral">"HvGetCellPaged:\n"</span>));
00191         KdPrint((<span class="stringliteral">"\tHive=%08lx Cell=%08lx\n"</span>,<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>,<a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a>));
00192     }
00193     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>-&gt;<a class="code" href="../../d7/d7/struct__HHIVE.html#o0">Signature</a> == <a class="code" href="../../d0/d1/hivedata_8h.html#a37">HHIVE_SIGNATURE</a>);
00194     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a> != <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>);
00195     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>-&gt;<a class="code" href="../../d7/d7/struct__HHIVE.html#o13">Flat</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
00196     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>((<a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a> &amp; (<a class="code" href="../../d0/d1/hivedata_8h.html#a20">HCELL_PAD</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>)-1))==0);
00197     <a class="code" href="../../d1/d2/cmp_8h.html#a61">ASSERT_CM_LOCK_OWNED</a>();
00198 <span class="preprocessor">    #if DBG</span>
00199 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (<a class="code" href="../../d0/d1/hivedata_8h.html#a19">HvGetCellType</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a>) == <a class="code" href="../../d0/d1/hivedata_8h.html#a77a75">Stable</a>) {
00200             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a> &gt;= <span class="keyword">sizeof</span>(<a class="code" href="../../d7/d4/struct__HBIN.html">HBIN</a>));
00201         } <span class="keywordflow">else</span> {
00202             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a> &gt;= (<a class="code" href="../../d0/d1/hivedata_8h.html#a7">HCELL_TYPE_MASK</a> + <span class="keyword">sizeof</span>(<a class="code" href="../../d7/d4/struct__HBIN.html">HBIN</a>)));
00203         }
00204 <span class="preprocessor">    #endif</span>
00205 <span class="preprocessor"></span>
00206     Type = <a class="code" href="../../d0/d1/hivedata_8h.html#a19">HvGetCellType</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a>);
00207     Table = (<a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a> &amp; <a class="code" href="../../d0/d1/hivedata_8h.html#a9">HCELL_TABLE_MASK</a>) &gt;&gt; <a class="code" href="../../d0/d1/hivedata_8h.html#a10">HCELL_TABLE_SHIFT</a>;
00208     Block = (<a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a> &amp; <a class="code" href="../../d0/d1/hivedata_8h.html#a11">HCELL_BLOCK_MASK</a>) &gt;&gt; <a class="code" href="../../d0/d1/hivedata_8h.html#a12">HCELL_BLOCK_SHIFT</a>;
00209     <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> = (<a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a> &amp; <a class="code" href="../../d0/d1/hivedata_8h.html#a13">HCELL_OFFSET_MASK</a>);
00210 
00211     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>((<a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a> - (Type * <a class="code" href="../../d0/d1/hivedata_8h.html#a7">HCELL_TYPE_MASK</a>)) &lt; <a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>-&gt;Storage[Type].Length);
00212 
00213     Map = &amp;((<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>-&gt;Storage[Type].Map)-&gt;Directory[Table]-&gt;Table[Block]);
00214     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>((Map-&gt;<a class="code" href="../../d2/d8/struct__HMAP__ENTRY.html#o1">BinAddress</a> &amp; <a class="code" href="../../d0/d1/hivedata_8h.html#a34">HMAP_BASE</a>) != 0);
00215     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>((Map-&gt;<a class="code" href="../../d2/d8/struct__HMAP__ENTRY.html#o1">BinAddress</a> &amp; <a class="code" href="../../d0/d1/hivedata_8h.html#a36">HMAP_DISCARDABLE</a>) == 0);
00216     pcell = (<a class="code" href="../../d8/d4/struct__HCELL.html">PHCELL</a>)((ULONG_PTR)(Map-&gt;<a class="code" href="../../d2/d8/struct__HMAP__ENTRY.html#o0">BlockAddress</a>) + <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>);
00217     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d1/hivedata_8h.html#a23">USE_OLD_CELL</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>)) {
00218         <span class="keywordflow">return</span> (<span class="keyword">struct </span><a class="code" href="../../d4/d9/struct__CELL__DATA.html">_CELL_DATA</a> *)&amp;(pcell-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o4">u</a>.OldCell.u.UserData);
00219     } <span class="keywordflow">else</span> {
00220         <span class="keywordflow">return</span> (<span class="keyword">struct </span><a class="code" href="../../d4/d9/struct__CELL__DATA.html">_CELL_DATA</a> *)&amp;(pcell-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o4">u</a>.NewCell.u.UserData);
<a name="l00221"></a><a class="code" href="../../d8/d0/hivecell_8c.html#a13">00221</a>     }
00222 }
00223 
00224 
00225 <span class="keyword">struct </span><a class="code" href="../../d4/d9/struct__CELL__DATA.html">_CELL_DATA</a> *
00226 <a class="code" href="../../d8/d0/hivecell_8c.html#a13">HvpGetCellFlat</a>(
00227     <a class="code" href="../../d7/d7/struct__HHIVE.html">PHHIVE</a>      Hive,
00228     HCELL_INDEX Cell
00229     )
00230 <span class="comment">/*++</span>
00231 <span class="comment"></span>
00232 <span class="comment">Routine Description:</span>
00233 <span class="comment"></span>
00234 <span class="comment">    Returns the memory address for the specified Cell.  Will never</span>
00235 <span class="comment">    return failure, but may assert.  Use HvIsCellAllocated to check</span>
00236 <span class="comment">    validity of Cell.</span>
00237 <span class="comment"></span>
00238 <span class="comment">    This routine should never be called directly, always call it</span>
00239 <span class="comment">    via the HvGetCell() macro.</span>
00240 <span class="comment"></span>
00241 <span class="comment">    This routine provides GetCell support for read only hives with</span>
00242 <span class="comment">    single allocation flat images.  Such hives do not have cell</span>
00243 <span class="comment">    maps ("page tables"), instead, we compute addresses by</span>
00244 <span class="comment">    arithmetic against the base image address.</span>
00245 <span class="comment"></span>
00246 <span class="comment">    Such hives cannot have volatile cells.</span>
00247 <span class="comment"></span>
00248 <span class="comment">Arguments:</span>
00249 <span class="comment"></span>
00250 <span class="comment">    Hive - supplies a pointer to the hive control structure for the</span>
00251 <span class="comment">            hive of interest</span>
00252 <span class="comment"></span>
00253 <span class="comment">    Cell - supplies HCELL_INDEX of cell to return address for</span>
00254 <span class="comment"></span>
00255 <span class="comment">Return Value:</span>
00256 <span class="comment"></span>
00257 <span class="comment">    Address of Cell in memory.  Assert or BugCheck if error.</span>
00258 <span class="comment"></span>
00259 <span class="comment">--*/</span>
00260 {
00261     PUCHAR          base;
00262     <a class="code" href="../../d8/d4/struct__HCELL.html">PHCELL</a>          pcell;
00263 
00264     <a class="code" href="../../d1/d2/cmp_8h.html#a55">CMLOG</a>(<a class="code" href="../../d1/d2/cmp_8h.html#a24">CML_FLOW</a>, <a class="code" href="../../d1/d2/cmp_8h.html#a26">CMS_MAP</a>) {
00265         KdPrint((<span class="stringliteral">"HvGetCellFlat:\n"</span>));
00266         KdPrint((<span class="stringliteral">"\tHive=%08lx Cell=%08lx\n"</span>,<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>,<a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a>));
00267     }
00268     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>-&gt;<a class="code" href="../../d7/d7/struct__HHIVE.html#o0">Signature</a> == HHIVE_SIGNATURE);
00269     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(Cell != HCELL_NIL);
00270     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>-&gt;<a class="code" href="../../d7/d7/struct__HHIVE.html#o13">Flat</a> == TRUE);
00271     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(<a class="code" href="../../d0/d1/hivedata_8h.html#a19">HvGetCellType</a>(Cell) == Stable);
00272     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(Cell &gt;= <span class="keyword">sizeof</span>(<a class="code" href="../../d7/d4/struct__HBIN.html">HBIN</a>));
00273     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(Cell &lt; Hive-&gt;BaseBlock-&gt;Length);
00274     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>((Cell &amp; 0x7)==0);
00275 
00276     <span class="comment">//</span>
00277     <span class="comment">// Address is base of Hive image + Cell</span>
00278     <span class="comment">//</span>
00279     base = (PUCHAR)(<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>-&gt;<a class="code" href="../../d7/d7/struct__HHIVE.html#o8">BaseBlock</a>) + <a class="code" href="../../d0/d1/hivedata_8h.html#a14">HBLOCK_SIZE</a>;
00280     pcell = (<a class="code" href="../../d8/d4/struct__HCELL.html">PHCELL</a>)(base + <a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a>);
00281     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d1/hivedata_8h.html#a23">USE_OLD_CELL</a>(Hive)) {
00282         <span class="keywordflow">return</span> (<span class="keyword">struct </span><a class="code" href="../../d4/d9/struct__CELL__DATA.html">_CELL_DATA</a> *)&amp;(pcell-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o4">u</a>.OldCell.u.UserData);
00283     } <span class="keywordflow">else</span> {
00284         <span class="keywordflow">return</span> (<span class="keyword">struct </span><a class="code" href="../../d4/d9/struct__CELL__DATA.html">_CELL_DATA</a> *)&amp;(pcell-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o4">u</a>.NewCell.u.UserData);
<a name="l00285"></a><a class="code" href="../../d8/d0/hivecell_8c.html#a14">00285</a>     }
00286 }
00287 
00288 
00289 <a class="code" href="../../d2/d8/struct__HMAP__ENTRY.html">PHMAP_ENTRY</a>
00290 <a class="code" href="../../d8/d0/hivecell_8c.html#a14">HvpGetCellMap</a>(
00291     <a class="code" href="../../d7/d7/struct__HHIVE.html">PHHIVE</a>      Hive,
00292     HCELL_INDEX Cell
00293     )
00294 <span class="comment">/*++</span>
00295 <span class="comment"></span>
00296 <span class="comment">Routine Description:</span>
00297 <span class="comment"></span>
00298 <span class="comment">    Returns the address of the HMAP_ENTRY for the cell.</span>
00299 <span class="comment"></span>
00300 <span class="comment">Arguments:</span>
00301 <span class="comment"></span>
00302 <span class="comment">    Hive - supplies a pointer to the hive control structure for the</span>
00303 <span class="comment">            hive of interest</span>
00304 <span class="comment"></span>
00305 <span class="comment">    Cell - supplies HCELL_INDEX of cell to return map entry address for</span>
00306 <span class="comment"></span>
00307 <span class="comment">Return Value:</span>
00308 <span class="comment"></span>
00309 <span class="comment">    Address of MAP_ENTRY in memory.  NULL if no such cell or other error.</span>
00310 <span class="comment"></span>
00311 <span class="comment">--*/</span>
00312 {
00313     ULONG           Type;
00314     ULONG           Table;
00315     ULONG           Block;
00316     <a class="code" href="../../d3/d8/struct__HMAP__TABLE.html">PHMAP_TABLE</a>     ptab;
00317 
00318     <a class="code" href="../../d1/d2/cmp_8h.html#a55">CMLOG</a>(<a class="code" href="../../d1/d2/cmp_8h.html#a24">CML_FLOW</a>, <a class="code" href="../../d1/d2/cmp_8h.html#a26">CMS_MAP</a>) {
00319         KdPrint((<span class="stringliteral">"HvpGetCellMapPaged:\n"</span>));
00320         KdPrint((<span class="stringliteral">"\tHive=%08lx Cell=%08lx\n"</span>,<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>,<a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a>));
00321     }
00322     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>-&gt;<a class="code" href="../../d7/d7/struct__HHIVE.html#o0">Signature</a> == HHIVE_SIGNATURE);
00323     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>-&gt;<a class="code" href="../../d7/d7/struct__HHIVE.html#o13">Flat</a> == FALSE);
00324     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>((Cell &amp; (<a class="code" href="../../d0/d1/hivedata_8h.html#a20">HCELL_PAD</a>(Hive)-1))==0);
00325 
00326     Type = <a class="code" href="../../d0/d1/hivedata_8h.html#a19">HvGetCellType</a>(Cell);
00327     Table = (<a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a> &amp; <a class="code" href="../../d0/d1/hivedata_8h.html#a9">HCELL_TABLE_MASK</a>) &gt;&gt; <a class="code" href="../../d0/d1/hivedata_8h.html#a10">HCELL_TABLE_SHIFT</a>;
00328     Block = (<a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a> &amp; <a class="code" href="../../d0/d1/hivedata_8h.html#a11">HCELL_BLOCK_MASK</a>) &gt;&gt; <a class="code" href="../../d0/d1/hivedata_8h.html#a12">HCELL_BLOCK_SHIFT</a>;
00329 
00330     <span class="keywordflow">if</span> ((<a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a> - (Type * <a class="code" href="../../d0/d1/hivedata_8h.html#a7">HCELL_TYPE_MASK</a>)) &gt;= <a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>-&gt;Storage[Type].Length) {
00331         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00332     }
00333 
00334     ptab = (<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>-&gt;Storage[Type].Map)-&gt;Directory[Table];
<a name="l00335"></a><a class="code" href="../../d8/d0/hivecell_8c.html#a15">00335</a>     <span class="keywordflow">return</span> &amp;(ptab-&gt;<a class="code" href="../../d3/d8/struct__HMAP__TABLE.html#o0">Table</a>[Block]);
00336 }
00337 
00338 
00339 LONG
00340 <a class="code" href="../../d8/d0/hivecell_8c.html#a15">HvGetCellSize</a>(
00341     IN <a class="code" href="../../d7/d7/struct__HHIVE.html">PHHIVE</a>   Hive,
00342     IN PVOID    Address
00343     )
00344 <span class="comment">/*++</span>
00345 <span class="comment"></span>
00346 <span class="comment">Routine Description:</span>
00347 <span class="comment"></span>
00348 <span class="comment">    Returns the size of the specified Cell, based on its MEMORY</span>
00349 <span class="comment">    ADDRESS.  Must always call HvGetCell first to get that</span>
00350 <span class="comment">    address.</span>
00351 <span class="comment"></span>
00352 <span class="comment">    NOTE:   This should be a macro if speed is issue.</span>
00353 <span class="comment"></span>
00354 <span class="comment">    NOTE:   If you pass in some random pointer, you will get some</span>
00355 <span class="comment">            random answer.  Only pass in valid Cell addresses.</span>
00356 <span class="comment"></span>
00357 <span class="comment">Arguments:</span>
00358 <span class="comment"></span>
00359 <span class="comment">    Hive - supplies hive control structure for the given cell</span>
00360 <span class="comment"></span>
00361 <span class="comment">    Address - address in memory of the cell, returned by HvGetCell()</span>
00362 <span class="comment"></span>
00363 <span class="comment">Return Value:</span>
00364 <span class="comment"></span>
00365 <span class="comment">    Allocated size in bytes of the cell.</span>
00366 <span class="comment"></span>
00367 <span class="comment">    If Negative, Cell is free, or Address is bogus.</span>
00368 <span class="comment"></span>
00369 <span class="comment">--*/</span>
00370 {
00371     LONG    size;
00372 
00373     <a class="code" href="../../d1/d2/cmp_8h.html#a55">CMLOG</a>(<a class="code" href="../../d1/d2/cmp_8h.html#a24">CML_FLOW</a>, <a class="code" href="../../d1/d2/cmp_8h.html#a26">CMS_MAP</a>) {
00374         KdPrint((<span class="stringliteral">"HvGetCellSize:\n"</span>));
00375         KdPrint((<span class="stringliteral">"\tAddress=%08lx\n"</span>, Address));
00376     }
00377 
00378     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d1/hivedata_8h.html#a23">USE_OLD_CELL</a>(Hive)) {
00379         size = ( (CONTAINING_RECORD(Address, <a class="code" href="../../d8/d4/struct__HCELL.html">HCELL</a>, u.OldCell.u.UserData))-&gt;Size ) * -1;
00380         size -= FIELD_OFFSET(<a class="code" href="../../d8/d4/struct__HCELL.html">HCELL</a>, u.OldCell.u.UserData);
00381     } <span class="keywordflow">else</span> {
00382         size = ( (CONTAINING_RECORD(Address, <a class="code" href="../../d8/d4/struct__HCELL.html">HCELL</a>, u.NewCell.u.UserData))-&gt;Size ) * -1;
00383         size -= FIELD_OFFSET(<a class="code" href="../../d8/d4/struct__HCELL.html">HCELL</a>, u.NewCell.u.UserData);
00384     }
00385     <span class="keywordflow">return</span> size;
<a name="l00386"></a><a class="code" href="../../d8/d0/hivecell_8c.html#a16">00386</a> }
00387 
00388 
00389 
00390 <a class="code" href="../../d0/d1/hivedata_8h.html#a49">HCELL_INDEX</a>
00391 <a class="code" href="../../d8/d0/hivecell_8c.html#a16">HvAllocateCell</a>(
00392     <a class="code" href="../../d7/d7/struct__HHIVE.html">PHHIVE</a>          Hive,
00393     ULONG           NewSize,
00394     HSTORAGE_TYPE   Type
00395     )
00396 <span class="comment">/*++</span>
00397 <span class="comment"></span>
00398 <span class="comment">Routine Description:</span>
00399 <span class="comment"></span>
00400 <span class="comment">    Allocates the space and the cell index for a new cell.</span>
00401 <span class="comment"></span>
00402 <span class="comment">Arguments:</span>
00403 <span class="comment"></span>
00404 <span class="comment">    Hive - supplies a pointer to the hive control structure for the</span>
00405 <span class="comment">            hive of interest</span>
00406 <span class="comment"></span>
00407 <span class="comment">    NewSize - size in bytes of the cell to allocate</span>
00408 <span class="comment"></span>
00409 <span class="comment">    Type - indicates whether Stable or Volatile storage is desired.</span>
00410 <span class="comment"></span>
00411 <span class="comment">Return Value:</span>
00412 <span class="comment"></span>
00413 <span class="comment">    New HCELL_INDEX if success, HCELL_NIL if failure.</span>
00414 <span class="comment"></span>
00415 <span class="comment">--*/</span>
00416 {
00417     <a class="code" href="../../d0/d1/hivedata_8h.html#a49">HCELL_INDEX</a> NewCell;
00418 
00419     <a class="code" href="../../d1/d2/cmp_8h.html#a55">CMLOG</a>(<a class="code" href="../../d1/d2/cmp_8h.html#a22">CML_MAJOR</a>, <a class="code" href="../../d1/d2/cmp_8h.html#a29">CMS_HIVE</a>) {
00420         KdPrint((<span class="stringliteral">"HvAllocateCell:\n"</span>));
00421         KdPrint((<span class="stringliteral">"\tHive=%08lx NewSize=%08lx\n"</span>,<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>,NewSize));
00422     }
00423     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>-&gt;<a class="code" href="../../d7/d7/struct__HHIVE.html#o0">Signature</a> == HHIVE_SIGNATURE);
00424     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>-&gt;<a class="code" href="../../d7/d7/struct__HHIVE.html#o14">ReadOnly</a> == FALSE);
00425     <a class="code" href="../../d1/d2/cmp_8h.html#a62">ASSERT_CM_LOCK_OWNED_EXCLUSIVE</a>();
00426 
00427     <span class="comment">//</span>
00428     <span class="comment">// Make room for overhead fields and round up to HCELL_PAD boundary</span>
00429     <span class="comment">//</span>
00430     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d1/hivedata_8h.html#a23">USE_OLD_CELL</a>(Hive)) {
00431         NewSize += FIELD_OFFSET(<a class="code" href="../../d8/d4/struct__HCELL.html">HCELL</a>, u.OldCell.u.UserData);
00432     } <span class="keywordflow">else</span> {
00433         NewSize += FIELD_OFFSET(<a class="code" href="../../d8/d4/struct__HCELL.html">HCELL</a>, u.NewCell.u.UserData);
00434     }
00435     NewSize = <a class="code" href="../../d6/d0/hive_8h.html#a2">ROUND_UP</a>(NewSize, <a class="code" href="../../d0/d1/hivedata_8h.html#a20">HCELL_PAD</a>(Hive));
00436 
00437     <span class="comment">// </span>
00438     <span class="comment">// Adjust the size (an easy fix for granularity)</span>
00439     <span class="comment">//</span>
00440     <a class="code" href="../../d8/d0/hivecell_8c.html#a4">HvpAdjustCellSize</a>(NewSize);
00441     <span class="comment">//</span>
00442     <span class="comment">// reject impossible/unreasonable values</span>
00443     <span class="comment">//</span>
00444     <span class="keywordflow">if</span> (NewSize &gt; <a class="code" href="../../d0/d1/hivedata_8h.html#a0">HSANE_CELL_MAX</a>) {
00445         <span class="keywordflow">return</span> <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>;
00446     }
00447 
00448     <span class="comment">//</span>
00449     <span class="comment">// Do the actual storage allocation</span>
00450     <span class="comment">//</span>
00451     NewCell = <a class="code" href="../../d8/d0/hivecell_8c.html#a7">HvpDoAllocateCell</a>(Hive, NewSize, Type);
00452 
00453 <span class="preprocessor">#if DBG</span>
00454 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (NewCell != <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>) {
00455         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(<a class="code" href="../../d8/d0/hivecell_8c.html#a21">HvIsCellAllocated</a>(Hive, NewCell));
00456     }
00457 <span class="preprocessor">#endif</span>
00458 <span class="preprocessor"></span>
00459 
00460     <a class="code" href="../../d1/d2/cmp_8h.html#a55">CMLOG</a>(CML_FLOW, CMS_HIVE) {
00461         KdPrint((<span class="stringliteral">"\tNewCell=%08lx\n"</span>, NewCell));
00462     }
<a name="l00463"></a><a class="code" href="../../d8/d0/hivecell_8c.html#a7">00463</a>     <span class="keywordflow">return</span> NewCell;
00464 }
00465 
00466 
00467 <a class="code" href="../../d0/d1/hivedata_8h.html#a49">HCELL_INDEX</a>
00468 <a class="code" href="../../d8/d0/hivecell_8c.html#a7">HvpDoAllocateCell</a>(
00469     <a class="code" href="../../d7/d7/struct__HHIVE.html">PHHIVE</a>          Hive,
00470     ULONG           NewSize,
00471     HSTORAGE_TYPE   Type
00472     )
00473 <span class="comment">/*++</span>
00474 <span class="comment"></span>
00475 <span class="comment">Routine Description:</span>
00476 <span class="comment"></span>
00477 <span class="comment">    Allocates space in the hive.  Does not affect cell map in any way.</span>
00478 <span class="comment"></span>
00479 <span class="comment">Arguments:</span>
00480 <span class="comment"></span>
00481 <span class="comment">    Hive - supplies a pointer to the hive control structure for the</span>
00482 <span class="comment">            hive of interest</span>
00483 <span class="comment"></span>
00484 <span class="comment">    NewSize - size in bytes of the cell to allocate</span>
00485 <span class="comment"></span>
00486 <span class="comment">    Type - indicates whether Stable or Volatile storage is desired.</span>
00487 <span class="comment"></span>
00488 <span class="comment">Return Value:</span>
00489 <span class="comment"></span>
00490 <span class="comment">    HCELL_INDEX of new cell, HCELL_NIL if failure</span>
00491 <span class="comment"></span>
00492 <span class="comment">--*/</span>
00493 {
00494     ULONG       <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
00495     ULONG       Summary;
00496     <a class="code" href="../../d0/d1/hivedata_8h.html#a49">HCELL_INDEX</a> cell;
00497     <a class="code" href="../../d8/d4/struct__HCELL.html">PHCELL</a>      pcell;
00498     <a class="code" href="../../d0/d1/hivedata_8h.html#a49">HCELL_INDEX</a> tcell;
00499     <a class="code" href="../../d8/d4/struct__HCELL.html">PHCELL</a>      ptcell;
00500     <a class="code" href="../../d7/d4/struct__HBIN.html">PHBIN</a>       <a class="code" href="../../d7/d0/cmdat2_8c.html#a36">Bin</a>;
00501     <a class="code" href="../../d2/d8/struct__HMAP__ENTRY.html">PHMAP_ENTRY</a> Me;
00502     ULONG       offset;
00503     <a class="code" href="../../d8/d4/struct__HCELL.html">PHCELL</a>      next;
00504     ULONG       MinFreeSize;
00505 
00506 
00507     <a class="code" href="../../d1/d2/cmp_8h.html#a55">CMLOG</a>(<a class="code" href="../../d1/d2/cmp_8h.html#a23">CML_MINOR</a>, <a class="code" href="../../d1/d2/cmp_8h.html#a29">CMS_HIVE</a>) {
00508         KdPrint((<span class="stringliteral">"HvDoAllocateCell:\n"</span>));
00509         KdPrint((<span class="stringliteral">"\tHive=%08lx NewSize=%08lx Type=%08lx\n"</span>,<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>,NewSize,Type));
00510     }
00511     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>-&gt;<a class="code" href="../../d7/d7/struct__HHIVE.html#o14">ReadOnly</a> == FALSE);
00512 
00513 
00514     <span class="comment">//</span>
00515     <span class="comment">// Compute Index into Display</span>
00516     <span class="comment">//</span>
00517     <a class="code" href="../../d8/d0/hivecell_8c.html#a2">HvpComputeIndex</a>(Index, NewSize);
00518 
00519     <span class="comment">//</span>
00520     <span class="comment">// Compute Summary vector of Display entries that are non null</span>
00521     <span class="comment">//</span>
00522     Summary = <a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>-&gt;Storage[Type].FreeSummary;
00523     Summary = Summary &amp; ~((1 &lt;&lt; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>) - 1);
00524 
00525     <span class="comment">//</span>
00526     <span class="comment">// We now have a summary of lists that are non-null and may</span>
00527     <span class="comment">// contain entries large enough to satisfy the request.</span>
00528     <span class="comment">// Iterate through the list and pull the first cell that is</span>
00529     <span class="comment">// big enough.  If no cells are big enough, advance to the</span>
00530     <span class="comment">// next non-null list.</span>
00531     <span class="comment">//</span>
00532 
00533     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(HHIVE_FREE_DISPLAY_SIZE == 24);
00534     <span class="keywordflow">while</span> (Summary != 0) {
00535         <span class="keywordflow">if</span> (Summary &amp; 0xff) {
00536             <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = <a class="code" href="../../d8/d0/hivecell_8c.html#a0">CmpFindFirstSetRight</a>[Summary &amp; 0xff];
00537         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Summary &amp; 0xff00) {
00538             <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = <a class="code" href="../../d8/d0/hivecell_8c.html#a0">CmpFindFirstSetRight</a>[(Summary &amp; 0xff00) &gt;&gt; 8] + 8;
00539         } <span class="keywordflow">else</span>  {
00540             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(Summary &amp; 0xff0000);
00541             <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = <a class="code" href="../../d8/d0/hivecell_8c.html#a0">CmpFindFirstSetRight</a>[(Summary &amp; 0xff0000) &gt;&gt; 16] + 16;
00542         }
00543 
00544         <span class="comment">//</span>
00545         <span class="comment">// Walk through the list until we find a cell large enough</span>
00546         <span class="comment">// to satisfy the allocation.  If we find one, pull it from</span>
00547         <span class="comment">// the list and use it.  If we don't find one, clear this</span>
00548         <span class="comment">// list's bit in the Summary and try the next larger list.</span>
00549         <span class="comment">//</span>
00550 
00551         <span class="comment">//</span>
00552         <span class="comment">// look for a large enough cell in the list</span>
00553         <span class="comment">//</span>
00554         cell = <a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>-&gt;Storage[Type].FreeDisplay[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>];
00555         <span class="keywordflow">while</span> (cell != <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>) {
00556 
00557             pcell = <a class="code" href="../../d6/d0/hive_8h.html#a13">HvpGetHCell</a>(Hive, cell);
00558 
00559             <span class="keywordflow">if</span> (NewSize &lt;= (ULONG)pcell-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o0">Size</a>) {
00560 
00561                 <span class="comment">//</span>
00562                 <span class="comment">// Found a big enough cell.</span>
00563                 <span class="comment">//</span>
00564                 <span class="keywordflow">if</span> (! <a class="code" href="../../d0/d2/hivesync_8c.html#a7">HvMarkCellDirty</a>(Hive, cell)) {
00565                     <span class="keywordflow">return</span> <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>;
00566                 }
00567 
00568                 <a class="code" href="../../d8/d0/hivecell_8c.html#a19">HvpDelistFreeCell</a>(Hive, pcell, Type, NULL);
00569 
00570                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(pcell-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o0">Size</a> &gt; 0);
00571                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(NewSize &lt;= (ULONG)pcell-&gt;Size);
00572                 <span class="keywordflow">goto</span> UseIt;
00573             }
00574 <span class="comment">//            DbgPrint("cell %08lx (%lx) too small (%d &lt; %d), trying next at",cell,pcell,pcell-&gt;Size,NewSize);</span>
00575             <span class="keywordflow">if</span> (<a class="code" href="../../d0/d1/hivedata_8h.html#a23">USE_OLD_CELL</a>(Hive)) {
00576                 cell = pcell-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o4">u</a>.OldCell.u.Next;
00577             } <span class="keywordflow">else</span> {
00578                 cell = pcell-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o4">u</a>.NewCell.u.Next;
00579             }
00580 <span class="comment">//          DbgPrint(" %08lx\n",cell);</span>
00581         }
00582 
00583         <span class="comment">//</span>
00584         <span class="comment">// No suitable cell was found on that list.</span>
00585         <span class="comment">// Clear the bit in the summary and try the</span>
00586         <span class="comment">// next biggest list.</span>
00587         <span class="comment">//</span>
00588 <span class="comment">//        DbgPrint("No suitable cell, Index %d, Summary %08lx -&gt; ",Index, Summary);</span>
00589         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(Summary &amp; (1 &lt;&lt; Index));
00590         Summary = Summary &amp; ~(1 &lt;&lt; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>);
00591 <span class="comment">//        DbgPrint("%08lx\n",Summary);</span>
00592     }
00593 
00594     <span class="keywordflow">if</span> (Summary == 0) {
00595         <span class="comment">//</span>
00596         <span class="comment">// No suitable cells were found on any free list.</span>
00597         <span class="comment">//</span>
00598         <span class="comment">// Either there is no large enough cell, or we</span>
00599         <span class="comment">// have no free cells left at all.  In either case, allocate a</span>
00600         <span class="comment">// new bin, with a new free cell certain to be large enough in</span>
00601         <span class="comment">// it, and use that cell.</span>
00602         <span class="comment">//</span>
00603 
00604         <span class="comment">//</span>
00605         <span class="comment">// Attempt to create a new bin</span>
00606         <span class="comment">//</span>
00607         <span class="keywordflow">if</span> ((<a class="code" href="../../d7/d0/cmdat2_8c.html#a36">Bin</a> = <a class="code" href="../../d7/d0/hivebin_8c.html#a1">HvpAddBin</a>(Hive, NewSize, Type)) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00608 
00609             <span class="comment">//</span>
00610             <span class="comment">// It worked.  Use single large cell in Bin.</span>
00611             <span class="comment">//</span>
00612             <a class="code" href="../../d6/d0/hive_8h.html#a1">DHvCheckBin</a>(Hive,Bin);
00613             cell = (<a class="code" href="../../d7/d0/cmdat2_8c.html#a36">Bin</a>-&gt;<a class="code" href="../../d7/d4/struct__HBIN.html#o1">FileOffset</a>) + <span class="keyword">sizeof</span>(<a class="code" href="../../d7/d4/struct__HBIN.html">HBIN</a>) + (Type*<a class="code" href="../../d0/d1/hivedata_8h.html#a7">HCELL_TYPE_MASK</a>);
00614             pcell = <a class="code" href="../../d6/d0/hive_8h.html#a13">HvpGetHCell</a>(Hive, cell);
00615         } <span class="keywordflow">else</span> {
00616             <span class="keywordflow">return</span> <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>;
00617         }
00618     }
00619 
00620 UseIt:
00621 
00622     <span class="comment">//</span>
00623     <span class="comment">// cell refers to a free cell we have pulled from its list</span>
00624     <span class="comment">// if it is too big, give the residue back</span>
00625     <span class="comment">// ("too big" means there is at least one HCELL of extra space)</span>
00626     <span class="comment">// always mark it allocated</span>
00627     <span class="comment">// return it as our function value</span>
00628     <span class="comment">//</span>
00629 
00630     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(pcell-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o0">Size</a> &gt; 0);
00631     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d1/hivedata_8h.html#a23">USE_OLD_CELL</a>(Hive)) {
00632         MinFreeSize = FIELD_OFFSET(<a class="code" href="../../d8/d4/struct__HCELL.html">HCELL</a>, u.OldCell.u.Next) + <span class="keyword">sizeof</span>(<a class="code" href="../../d0/d1/hivedata_8h.html#a49">HCELL_INDEX</a>);
00633     } <span class="keywordflow">else</span> {
00634         MinFreeSize = FIELD_OFFSET(<a class="code" href="../../d8/d4/struct__HCELL.html">HCELL</a>, u.NewCell.u.Next) + <span class="keyword">sizeof</span>(<a class="code" href="../../d0/d1/hivedata_8h.html#a49">HCELL_INDEX</a>);
00635     }
00636     <span class="keywordflow">if</span> ((NewSize + MinFreeSize) &lt; (ULONG)pcell-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o0">Size</a>) {
00637 
00638         <span class="comment">//</span>
00639         <span class="comment">// Crack the cell, use part we need, put rest on</span>
00640         <span class="comment">// free list.</span>
00641         <span class="comment">//</span>
00642         Me = <a class="code" href="../../d8/d0/hivecell_8c.html#a14">HvpGetCellMap</a>(Hive, cell);
00643         <a class="code" href="../../d1/d2/cmp_8h.html#a65">VALIDATE_CELL_MAP</a>(__LINE__,Me,Hive,cell);
00644         <a class="code" href="../../d7/d0/cmdat2_8c.html#a36">Bin</a> = (<a class="code" href="../../d7/d4/struct__HBIN.html">PHBIN</a>)((Me-&gt;<a class="code" href="../../d2/d8/struct__HMAP__ENTRY.html#o1">BinAddress</a>) &amp; <a class="code" href="../../d0/d1/hivedata_8h.html#a34">HMAP_BASE</a>);
00645         offset = (ULONG)((ULONG_PTR)pcell - (ULONG_PTR)<a class="code" href="../../d7/d0/cmdat2_8c.html#a36">Bin</a>);
00646 
00647         ptcell = (<a class="code" href="../../d8/d4/struct__HCELL.html">PHCELL</a>)((PUCHAR)pcell + NewSize);
00648         <span class="keywordflow">if</span> (<a class="code" href="../../d0/d1/hivedata_8h.html#a23">USE_OLD_CELL</a>(Hive)) {
00649             ptcell-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o4">u</a>.OldCell.Last = offset;
00650         }
00651         ptcell-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o0">Size</a> = pcell-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o0">Size</a> - NewSize;
00652 
00653         <span class="keywordflow">if</span> ((offset + pcell-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o0">Size</a>) &lt; <a class="code" href="../../d7/d0/cmdat2_8c.html#a36">Bin</a>-&gt;<a class="code" href="../../d7/d4/struct__HBIN.html#o2">Size</a>) {
00654             next = (<a class="code" href="../../d8/d4/struct__HCELL.html">PHCELL</a>)((PUCHAR)pcell + pcell-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o0">Size</a>);
00655             <span class="keywordflow">if</span> (<a class="code" href="../../d0/d1/hivedata_8h.html#a23">USE_OLD_CELL</a>(Hive)) {
00656                 next-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o4">u</a>.OldCell.Last = offset + NewSize;
00657             }
00658         }
00659 
00660         pcell-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o0">Size</a> = NewSize;
00661         tcell = (<a class="code" href="../../d0/d1/hivedata_8h.html#a49">HCELL_INDEX</a>)((ULONG)cell + NewSize);
00662 
00663         <a class="code" href="../../d8/d0/hivecell_8c.html#a18">HvpEnlistFreeCell</a>(Hive, tcell, ptcell-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o0">Size</a>, Type, TRUE,NULL);
00664     }
00665 
00666     <span class="comment">//</span>
00667     <span class="comment">// return the cell we found.</span>
00668     <span class="comment">//</span>
00669 <span class="preprocessor">#if DBG</span>
00670 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (<a class="code" href="../../d0/d1/hivedata_8h.html#a23">USE_OLD_CELL</a>(Hive)) {
00671         RtlFillMemory(
00672             &amp;(pcell-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o4">u</a>.OldCell.u.UserData),
00673             (pcell-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o0">Size</a> - FIELD_OFFSET(<a class="code" href="../../d8/d4/struct__HCELL.html">HCELL</a>, u.OldCell.u.UserData)),
00674             HCELL_ALLOCATE_FILL
00675             );
00676     } <span class="keywordflow">else</span> {
00677         RtlFillMemory(
00678             &amp;(pcell-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o4">u</a>.NewCell.u.UserData),
00679             (pcell-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o0">Size</a> - FIELD_OFFSET(<a class="code" href="../../d8/d4/struct__HCELL.html">HCELL</a>, u.NewCell.u.UserData)),
00680             HCELL_ALLOCATE_FILL
00681             );
00682     }
00683 <span class="preprocessor">#endif</span>
00684 <span class="preprocessor"></span>    pcell-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o0">Size</a> *= -1;
00685 
00686     <span class="keywordflow">return</span> cell;
00687 }
<a name="l00688"></a><a class="code" href="../../d8/d0/hivecell_8c.html#a17">00688</a> 
00689 
00690 
00691 
00692 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00693 <a class="code" href="../../d8/d0/hivecell_8c.html#a17">HvFreeCell</a>(
00694     <a class="code" href="../../d7/d7/struct__HHIVE.html">PHHIVE</a>      Hive,
00695     HCELL_INDEX Cell
00696     )
00697 <span class="comment">/*++</span>
00698 <span class="comment"></span>
00699 <span class="comment">Routine Description:</span>
00700 <span class="comment"></span>
00701 <span class="comment"></span>
00702 <span class="comment">    Frees the storage for a cell.</span>
00703 <span class="comment"></span>
00704 <span class="comment">    NOTE:   CALLER is expected to mark relevent data dirty, so as to</span>
00705 <span class="comment">            allow this call to always succeed.</span>
00706 <span class="comment"></span>
00707 <span class="comment">Arguments:</span>
00708 <span class="comment"></span>
00709 <span class="comment">    Hive - supplies a pointer to the hive control structure for the</span>
00710 <span class="comment">            hive of interest</span>
00711 <span class="comment"></span>
00712 <span class="comment">    Cell - HCELL_INDEX of Cell to free.</span>
00713 <span class="comment"></span>
00714 <span class="comment">Return Value:</span>
00715 <span class="comment"></span>
00716 <span class="comment">    FALSE - failed, presumably for want of log space.</span>
00717 <span class="comment"></span>
00718 <span class="comment">    TRUE - it worked</span>
00719 <span class="comment"></span>
00720 <span class="comment">--*/</span>
00721 {
00722     <a class="code" href="../../d7/d4/struct__HBIN.html">PHBIN</a>           <a class="code" href="../../d7/d0/cmdat2_8c.html#a36">Bin</a>;
00723     <a class="code" href="../../d8/d4/struct__HCELL.html">PHCELL</a>          tmp;
00724     <a class="code" href="../../d0/d1/hivedata_8h.html#a49">HCELL_INDEX</a>     newfreecell;
00725     <a class="code" href="../../d8/d4/struct__HCELL.html">PHCELL</a>          freebase;
00726     ULONG           savesize;
00727     <a class="code" href="../../d8/d4/struct__HCELL.html">PHCELL</a>          neighbor;
00728     ULONG           Type;
00729     <a class="code" href="../../d2/d8/struct__HMAP__ENTRY.html">PHMAP_ENTRY</a>     Me;
00730 
00731 
00732     <a class="code" href="../../d1/d2/cmp_8h.html#a55">CMLOG</a>(<a class="code" href="../../d1/d2/cmp_8h.html#a23">CML_MINOR</a>, <a class="code" href="../../d1/d2/cmp_8h.html#a29">CMS_HIVE</a>) {
00733         KdPrint((<span class="stringliteral">"HvFreeCell:\n"</span>));
00734         KdPrint((<span class="stringliteral">"\tHive=%08lx Cell=%08lx\n"</span>,<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>,<a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a>));
00735     }
00736     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>-&gt;<a class="code" href="../../d7/d7/struct__HHIVE.html#o14">ReadOnly</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
00737     <a class="code" href="../../d1/d2/cmp_8h.html#a62">ASSERT_CM_LOCK_OWNED_EXCLUSIVE</a>();
00738 
00739     <span class="comment">//</span>
00740     <span class="comment">// Get sizes and addresses</span>
00741     <span class="comment">//</span>
00742     Me = <a class="code" href="../../d8/d0/hivecell_8c.html#a14">HvpGetCellMap</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>, <a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a>);
00743     <a class="code" href="../../d1/d2/cmp_8h.html#a65">VALIDATE_CELL_MAP</a>(__LINE__,Me,<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>,<a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a>);
00744     Type = <a class="code" href="../../d0/d1/hivedata_8h.html#a19">HvGetCellType</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a>);
00745 
00746     <a class="code" href="../../d7/d0/cmdat2_8c.html#a36">Bin</a> = (<a class="code" href="../../d7/d4/struct__HBIN.html">PHBIN</a>)((Me-&gt;<a class="code" href="../../d2/d8/struct__HMAP__ENTRY.html#o1">BinAddress</a>) &amp; <a class="code" href="../../d0/d1/hivedata_8h.html#a34">HMAP_BASE</a>);
00747     <a class="code" href="../../d6/d0/hive_8h.html#a1">DHvCheckBin</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>,<a class="code" href="../../d7/d0/cmdat2_8c.html#a36">Bin</a>);
00748 
00749     freebase = <a class="code" href="../../d6/d0/hive_8h.html#a13">HvpGetHCell</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>, <a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a>);
00750 
00751     <span class="comment">//</span>
00752     <span class="comment">// go do actual frees, cannot fail from this point on</span>
00753     <span class="comment">//</span>
00754     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(freebase-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o0">Size</a> &lt; 0);
00755     freebase-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o0">Size</a> *= -1;
00756 
00757     savesize = freebase-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o0">Size</a>;
00758 
00759     <span class="comment">//</span>
00760     <span class="comment">// Look for free neighbors and coalesce them.  We will never travel</span>
00761     <span class="comment">// around this loop more than twice.</span>
00762     <span class="comment">//</span>
00763     <span class="keywordflow">while</span> (
00764         <a class="code" href="../../d8/d0/hivecell_8c.html#a10">HvpIsFreeNeighbor</a>(
00765             <a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>,
00766             <a class="code" href="../../d7/d0/cmdat2_8c.html#a36">Bin</a>,
00767             freebase,
00768             &amp;neighbor,
00769             Type
00770             ) == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>
00771         )
00772     {
00773 
00774         <span class="keywordflow">if</span> (neighbor &gt; freebase) {
00775 
00776             <span class="comment">//</span>
00777             <span class="comment">// Neighboring free cell is immediately above us in memory.</span>
00778             <span class="comment">//</span>
00779             <span class="keywordflow">if</span> (<a class="code" href="../../d0/d1/hivedata_8h.html#a23">USE_OLD_CELL</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>)) {
00780                 tmp = (<a class="code" href="../../d8/d4/struct__HCELL.html">PHCELL</a>)((PUCHAR)neighbor + neighbor-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o0">Size</a>);
00781                 <span class="keywordflow">if</span> ( ((ULONG)((ULONG_PTR)tmp - (ULONG_PTR)<a class="code" href="../../d7/d0/cmdat2_8c.html#a36">Bin</a>)) &lt; <a class="code" href="../../d7/d0/cmdat2_8c.html#a36">Bin</a>-&gt;<a class="code" href="../../d7/d4/struct__HBIN.html#o2">Size</a>) {
00782                         tmp-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o4">u</a>.OldCell.Last = (ULONG)((ULONG_PTR)freebase - (ULONG_PTR)<a class="code" href="../../d7/d0/cmdat2_8c.html#a36">Bin</a>);
00783                 }
00784             }
00785             freebase-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o0">Size</a> += neighbor-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o0">Size</a>;
00786 
00787         } <span class="keywordflow">else</span> {
00788 
00789             <span class="comment">//</span>
00790             <span class="comment">// Neighboring free cell is immediately below us in memory.</span>
00791             <span class="comment">//</span>
00792 
00793             <span class="keywordflow">if</span> (<a class="code" href="../../d0/d1/hivedata_8h.html#a23">USE_OLD_CELL</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>)) {
00794                 tmp = (<a class="code" href="../../d8/d4/struct__HCELL.html">PHCELL</a>)((PUCHAR)freebase + freebase-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o0">Size</a>);
00795                 <span class="keywordflow">if</span> ( ((ULONG)((ULONG_PTR)tmp - (ULONG_PTR)<a class="code" href="../../d7/d0/cmdat2_8c.html#a36">Bin</a>)) &lt; <a class="code" href="../../d7/d0/cmdat2_8c.html#a36">Bin</a>-&gt;<a class="code" href="../../d7/d4/struct__HBIN.html#o2">Size</a> ) {
00796                     tmp-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o4">u</a>.OldCell.Last = (ULONG)((ULONG_PTR)neighbor - (ULONG_PTR)<a class="code" href="../../d7/d0/cmdat2_8c.html#a36">Bin</a>);
00797                 }
00798             }
00799             neighbor-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o0">Size</a> += freebase-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o0">Size</a>;
00800             freebase = neighbor;
00801         }
00802     }
00803 
00804     <span class="comment">//</span>
00805     <span class="comment">// freebase now points to the biggest free cell we could make, none</span>
00806     <span class="comment">// of which is on the free list.  So put it on the list.</span>
00807     <span class="comment">//</span>
00808     newfreecell = (<a class="code" href="../../d7/d0/cmdat2_8c.html#a36">Bin</a>-&gt;<a class="code" href="../../d7/d4/struct__HBIN.html#o1">FileOffset</a>) +
00809                ((ULONG)((ULONG_PTR)freebase - (ULONG_PTR)<a class="code" href="../../d7/d0/cmdat2_8c.html#a36">Bin</a>)) +
00810                (Type*<a class="code" href="../../d0/d1/hivedata_8h.html#a7">HCELL_TYPE_MASK</a>);
00811 
00812     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(<a class="code" href="../../d6/d0/hive_8h.html#a13">HvpGetHCell</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>, newfreecell) == freebase);
00813 
00814 <span class="preprocessor">#if DBG</span>
00815 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (<a class="code" href="../../d0/d1/hivedata_8h.html#a23">USE_OLD_CELL</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>)) {
00816         RtlFillMemory(
00817             &amp;(freebase-&gt;u.OldCell.u.UserData),
00818             (freebase-&gt;Size - FIELD_OFFSET(<a class="code" href="../../d8/d4/struct__HCELL.html">HCELL</a>, u.OldCell.u.UserData)),
00819             <a class="code" href="../../d0/d1/hivedata_8h.html#a22">HCELL_FREE_FILL</a>
00820             );
00821     } <span class="keywordflow">else</span> {
00822         RtlFillMemory(
00823             &amp;(freebase-&gt;u.NewCell.u.UserData),
00824             (freebase-&gt;Size - FIELD_OFFSET(<a class="code" href="../../d8/d4/struct__HCELL.html">HCELL</a>, u.NewCell.u.UserData)),
00825             <a class="code" href="../../d0/d1/hivedata_8h.html#a22">HCELL_FREE_FILL</a>
00826             );
00827     }
00828 <span class="preprocessor">#endif</span>
00829 <span class="preprocessor"></span>
00830     <a class="code" href="../../d8/d0/hivecell_8c.html#a18">HvpEnlistFreeCell</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>, newfreecell, freebase-&gt;Size, Type, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00831 
<a name="l00832"></a><a class="code" href="../../d8/d0/hivecell_8c.html#a10">00832</a>     <span class="keywordflow">return</span>;
00833 }
00834 
00835 
00836 BOOLEAN
00837 <a class="code" href="../../d8/d0/hivecell_8c.html#a10">HvpIsFreeNeighbor</a>(
00838     <a class="code" href="../../d7/d7/struct__HHIVE.html">PHHIVE</a>  Hive,
00839     <a class="code" href="../../d7/d4/struct__HBIN.html">PHBIN</a>   Bin,
00840     <a class="code" href="../../d8/d4/struct__HCELL.html">PHCELL</a>  FreeCell,
00841     <a class="code" href="../../d8/d4/struct__HCELL.html">PHCELL</a>  *FreeNeighbor,
00842     HSTORAGE_TYPE   Type
00843     )
00844 <span class="comment">/*++</span>
00845 <span class="comment"></span>
00846 <span class="comment">Routine Description:</span>
00847 <span class="comment"></span>
00848 <span class="comment">    Reports on whether FreeCell has at least one free neighbor and</span>
00849 <span class="comment">    if so where.  Free neighbor will be cut out of the free list.</span>
00850 <span class="comment"></span>
00851 <span class="comment">Arguments:</span>
00852 <span class="comment"></span>
00853 <span class="comment">    Hive - hive we're working on</span>
00854 <span class="comment"></span>
00855 <span class="comment">    Bin - pointer to the storage bin</span>
00856 <span class="comment"></span>
00857 <span class="comment">    FreeCell - supplies a pointer to a cell that has been freed, or</span>
00858 <span class="comment">                the result of a coalesce.</span>
00859 <span class="comment"></span>
00860 <span class="comment">    FreeNeighbor - supplies a pointer to a variable to receive the address</span>
00861 <span class="comment">                    of a free neigbhor of FreeCell, if such exists</span>
00862 <span class="comment"></span>
00863 <span class="comment">    Type - storage type of the cell</span>
00864 <span class="comment"></span>
00865 <span class="comment">Return Value:</span>
00866 <span class="comment"></span>
00867 <span class="comment">    TRUE if a free neighbor was found, else false.</span>
00868 <span class="comment"></span>
00869 <span class="comment"></span>
00870 <span class="comment">--*/</span>
00871 {
00872     <a class="code" href="../../d8/d4/struct__HCELL.html">PHCELL</a>  ptcell;
00873 
00874     <a class="code" href="../../d1/d2/cmp_8h.html#a55">CMLOG</a>(<a class="code" href="../../d1/d2/cmp_8h.html#a23">CML_MINOR</a>, <a class="code" href="../../d1/d2/cmp_8h.html#a29">CMS_HIVE</a>) {
00875         KdPrint((<span class="stringliteral">"HvpIsFreeNeighbor:\n\tBin=%08lx"</span>,<a class="code" href="../../d7/d0/cmdat2_8c.html#a36">Bin</a>));
00876         KdPrint((<span class="stringliteral">"FreeCell=%08lx\n"</span>, FreeCell));
00877     }
00878     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>-&gt;<a class="code" href="../../d7/d7/struct__HHIVE.html#o14">ReadOnly</a> == FALSE);
00879 
00880     <span class="comment">//</span>
00881     <span class="comment">// Neighbor above us?</span>
00882     <span class="comment">//</span>
00883     *FreeNeighbor = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00884     ptcell = (<a class="code" href="../../d8/d4/struct__HCELL.html">PHCELL</a>)((PUCHAR)FreeCell + FreeCell-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o0">Size</a>);
00885     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( ((ULONG)((ULONG_PTR)ptcell - (ULONG_PTR)Bin)) &lt;= <a class="code" href="../../d7/d0/cmdat2_8c.html#a36">Bin</a>-&gt;<a class="code" href="../../d7/d4/struct__HBIN.html#o2">Size</a>);
00886     <span class="keywordflow">if</span> (((ULONG)((ULONG_PTR)ptcell - (ULONG_PTR)<a class="code" href="../../d7/d0/cmdat2_8c.html#a36">Bin</a>)) &lt; <a class="code" href="../../d7/d0/cmdat2_8c.html#a36">Bin</a>-&gt;<a class="code" href="../../d7/d4/struct__HBIN.html#o2">Size</a>) {
00887         <span class="keywordflow">if</span> (ptcell-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o0">Size</a> &gt; 0) {
00888             *FreeNeighbor = ptcell;
00889             <span class="keywordflow">goto</span> FoundNeighbor;
00890         }
00891     }
00892 
00893     <span class="comment">//</span>
00894     <span class="comment">// Neighbor below us?</span>
00895     <span class="comment">//</span>
00896     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d1/hivedata_8h.html#a23">USE_OLD_CELL</a>(Hive)) {
00897         <span class="keywordflow">if</span> (FreeCell-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o4">u</a>.OldCell.Last != <a class="code" href="../../d0/d1/hivedata_8h.html#a25">HBIN_NIL</a>) {
00898             ptcell = (<a class="code" href="../../d8/d4/struct__HCELL.html">PHCELL</a>)((PUCHAR)<a class="code" href="../../d7/d0/cmdat2_8c.html#a36">Bin</a> + FreeCell-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o4">u</a>.OldCell.Last);
00899             <span class="keywordflow">if</span> (ptcell-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o0">Size</a> &gt; 0) {
00900                 *FreeNeighbor = ptcell;
00901                 <span class="keywordflow">goto</span> FoundNeighbor;
00902             }
00903         }
00904     } <span class="keywordflow">else</span> {
00905         ptcell = (<a class="code" href="../../d8/d4/struct__HCELL.html">PHCELL</a>)(<a class="code" href="../../d7/d0/cmdat2_8c.html#a36">Bin</a>+1);
00906         <span class="keywordflow">while</span> (ptcell &lt; FreeCell) {
00907 
00908             <span class="comment">//</span>
00909             <span class="comment">// scan through the cells from the start of the bin looking for neighbor.</span>
00910             <span class="comment">//</span>
00911             <span class="keywordflow">if</span> (ptcell-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o0">Size</a> &gt; 0) {
00912 
00913                 <span class="keywordflow">if</span> ((<a class="code" href="../../d8/d4/struct__HCELL.html">PHCELL</a>)((PUCHAR)ptcell + ptcell-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o0">Size</a>) == FreeCell) {
00914                     *FreeNeighbor = ptcell;
00915                     <span class="comment">//</span>
00916                     <span class="comment">// Try and mark it dirty, since we will be changing</span>
00917                     <span class="comment">// the size field.  If this fails, ignore</span>
00918                     <span class="comment">// the free neighbor, we will not fail the free</span>
00919                     <span class="comment">// just because we couldn't mark the cell dirty</span>
00920                     <span class="comment">// so it could be coalesced.</span>
00921                     <span class="comment">//</span>
00922                     <span class="comment">// Note we only bother doing this for new hives,</span>
00923                     <span class="comment">// for old format hives we always mark the whole</span>
00924                     <span class="comment">// bin dirty.</span>
00925                     <span class="comment">//</span>
00926                     <span class="keywordflow">if</span> ((Type == <a class="code" href="../../d0/d1/hivedata_8h.html#a77a76">Volatile</a>) ||
00927                         (<a class="code" href="../../d0/d2/hivesync_8c.html#a7">HvMarkCellDirty</a>(Hive, (ULONG)((ULONG_PTR)ptcell-(ULONG_PTR)Bin) + <a class="code" href="../../d7/d0/cmdat2_8c.html#a36">Bin</a>-&gt;<a class="code" href="../../d7/d4/struct__HBIN.html#o1">FileOffset</a>))) {
00928                         <span class="keywordflow">goto</span> FoundNeighbor;
00929                     } <span class="keywordflow">else</span> {
00930                         <span class="keywordflow">return</span>(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
00931                     }
00932 
00933                 } <span class="keywordflow">else</span> {
00934                     ptcell = (<a class="code" href="../../d8/d4/struct__HCELL.html">PHCELL</a>)((PUCHAR)ptcell + ptcell-&gt;Size);
00935                 }
00936             } <span class="keywordflow">else</span> {
00937                 ptcell = (<a class="code" href="../../d8/d4/struct__HCELL.html">PHCELL</a>)((PUCHAR)ptcell - ptcell-&gt;Size);
00938             }
00939         }
00940     }
00941 
00942     <span class="keywordflow">return</span>(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
00943 
00944 FoundNeighbor:
00945 
00946     <a class="code" href="../../d8/d0/hivecell_8c.html#a19">HvpDelistFreeCell</a>(Hive, *FreeNeighbor, Type, NULL);
<a name="l00947"></a><a class="code" href="../../d8/d0/hivecell_8c.html#a18">00947</a>     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00948 }
00949 
00950 
00951 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00952 <a class="code" href="../../d8/d0/hivecell_8c.html#a18">HvpEnlistFreeCell</a>(
00953     <a class="code" href="../../d7/d7/struct__HHIVE.html">PHHIVE</a>  Hive,
00954     HCELL_INDEX Cell,
00955     ULONG      Size,
00956     HSTORAGE_TYPE   Type,
00957     BOOLEAN CoalesceForward,
00958     PHCELL_INDEX TailDisplay OPTIONAL
00959     )
00960 <span class="comment">/*++</span>
00961 <span class="comment"></span>
00962 <span class="comment">Routine Description:</span>
00963 <span class="comment"></span>
00964 <span class="comment">    Puts the newly freed cell on the appropriate list.</span>
00965 <span class="comment"></span>
00966 <span class="comment">Arguments:</span>
00967 <span class="comment"></span>
00968 <span class="comment">    Hive - supplies a pointer to the hive control structure for the</span>
00969 <span class="comment">            hive of interest</span>
00970 <span class="comment"></span>
00971 <span class="comment">    Cell - supplies index of cell to enlist</span>
00972 <span class="comment"></span>
00973 <span class="comment">    Size - size of cell</span>
00974 <span class="comment"></span>
00975 <span class="comment">    Type - indicates whether Stable or Volatile storage is desired.</span>
00976 <span class="comment"></span>
00977 <span class="comment">    CoalesceForward - indicates whether we can coalesce forward or not.</span>
00978 <span class="comment">        For the case where we have not finished scanning the hive and</span>
00979 <span class="comment">        enlisting free cells, we do not want to coalesce forward.</span>
00980 <span class="comment"></span>
00981 <span class="comment">Return Value:</span>
00982 <span class="comment"></span>
00983 <span class="comment">    NONE.</span>
00984 <span class="comment"></span>
00985 <span class="comment">--*/</span>
00986 {
00987     <a class="code" href="../../d0/d1/hivedata_8h.html#a50">PHCELL_INDEX</a> Last;
00988     <a class="code" href="../../d0/d1/hivedata_8h.html#a50">PHCELL_INDEX</a> First;
00989     <a class="code" href="../../d2/d8/struct__HMAP__ENTRY.html">PHMAP_ENTRY</a> Map;
00990     <a class="code" href="../../d8/d4/struct__HCELL.html">PHCELL</a> pcell;
00991     <a class="code" href="../../d8/d4/struct__HCELL.html">PHCELL</a> pcellLast;
00992     <a class="code" href="../../d8/d4/struct__HCELL.html">PHCELL</a> FirstCell;
00993     ULONG   <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
00994     <a class="code" href="../../d7/d4/struct__HBIN.html">PHBIN</a>   <a class="code" href="../../d7/d0/cmdat2_8c.html#a36">Bin</a>;
00995     <a class="code" href="../../d0/d1/hivedata_8h.html#a49">HCELL_INDEX</a> FreeCell;
00996     <a class="code" href="../../d6/d0/struct__FREE__HBIN.html">PFREE_HBIN</a> FreeBin;
00997     <a class="code" href="../../d7/d4/struct__HBIN.html">PHBIN</a>   FirstBin;
00998     <a class="code" href="../../d7/d4/struct__HBIN.html">PHBIN</a>   LastBin;
00999 
01000     <a class="code" href="../../d8/d0/hivecell_8c.html#a2">HvpComputeIndex</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>, <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>);
01001 
01002     
01003     First = &amp;(<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>-&gt;Storage[Type].FreeDisplay[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>]);
01004     pcell = <a class="code" href="../../d6/d0/hive_8h.html#a13">HvpGetHCell</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>, <a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a>);
01005     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(pcell-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o0">Size</a> &gt; 0);
01006     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> == (ULONG)pcell-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o0">Size</a>);
01007 
01008     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(TailDisplay)) {
01009         <span class="comment">//</span>
01010         <span class="comment">// This should only happen once, at boot time; Then, we want to sort the list ascedending</span>
01011         <span class="comment">//</span>
01012         Last = &amp;TailDisplay[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>];
01013         <span class="keywordflow">if</span>( *Last != <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a> ) {
01014         <span class="comment">//</span>
01015         <span class="comment">// there is a last cell; insert current cell right after it.</span>
01016         <span class="comment">// and set the next cell pointer for the current cell to NIL</span>
01017         <span class="comment">//</span>
01018             pcellLast = <a class="code" href="../../d6/d0/hive_8h.html#a13">HvpGetHCell</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>,*Last);
01019             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(pcellLast-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o0">Size</a> &gt; 0);
01020 
01021             <span class="keywordflow">if</span> (<a class="code" href="../../d0/d1/hivedata_8h.html#a23">USE_OLD_CELL</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>)) {
01022                 pcellLast-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o4">u</a>.OldCell.u.Next = <a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a>;
01023                 pcell-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o4">u</a>.OldCell.u.Next = <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>;
01024             } <span class="keywordflow">else</span> {
01025                 pcellLast-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o4">u</a>.NewCell.u.Next = <a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a>;
01026                 pcell-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o4">u</a>.NewCell.u.Next = <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>;
01027             }
01028         } <span class="keywordflow">else</span> {
01029         <span class="comment">//</span>
01030         <span class="comment">// No Last cell; Insert it at the begining and set the last cell pointing to it as well</span>
01031         <span class="comment">// Sanity check: First cell should be also NIL</span>
01032         <span class="comment">//</span>
01033             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( *First == <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a> );
01034 
01035             <span class="keywordflow">if</span> (<a class="code" href="../../d0/d1/hivedata_8h.html#a23">USE_OLD_CELL</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>)) {
01036                 pcell-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o4">u</a>.OldCell.u.Next = *First;
01037             } <span class="keywordflow">else</span> {
01038                 pcell-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o4">u</a>.NewCell.u.Next = *First;
01039             }
01040             *First = <a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a>;
01041         }
01042         <span class="comment">//</span>
01043         <span class="comment">// The current cell becomes the last cell</span>
01044         <span class="comment">//</span>
01045         *Last = <a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a>;
01046     } <span class="keywordflow">else</span> {
01047     <span class="comment">//</span>
01048     <span class="comment">// Normal case, insert the cell at the begining of the list (speed reasons).</span>
01049     <span class="comment">//</span>
01050         <span class="keywordflow">if</span> (<a class="code" href="../../d0/d1/hivedata_8h.html#a23">USE_OLD_CELL</a>(Hive)) {
01051             pcell-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o4">u</a>.OldCell.u.Next = *First;
01052         } <span class="keywordflow">else</span> {
01053             pcell-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o4">u</a>.NewCell.u.Next = *First;
01054         }
01055         *First = <a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a>;
01056     }
01057 
01058 
01059     <span class="comment">//</span>
01060     <span class="comment">// Check to see if this is the first cell in the bin and if the entire</span>
01061     <span class="comment">// bin consists just of this cell.</span>
01062     <span class="comment">//</span>
01063     Map = <a class="code" href="../../d8/d0/hivecell_8c.html#a14">HvpGetCellMap</a>(Hive, Cell);
01064     <a class="code" href="../../d1/d2/cmp_8h.html#a65">VALIDATE_CELL_MAP</a>(__LINE__,Map,Hive,Cell);
01065     <a class="code" href="../../d7/d0/cmdat2_8c.html#a36">Bin</a> = (<a class="code" href="../../d7/d4/struct__HBIN.html">PHBIN</a>)(Map-&gt;<a class="code" href="../../d2/d8/struct__HMAP__ENTRY.html#o1">BinAddress</a> &amp; ~<a class="code" href="../../d0/d1/hivedata_8h.html#a35">HMAP_NEWALLOC</a>);
01066     <span class="keywordflow">if</span> ((pcell == (<a class="code" href="../../d8/d4/struct__HCELL.html">PHCELL</a>)(<a class="code" href="../../d7/d0/cmdat2_8c.html#a36">Bin</a> + 1)) &amp;&amp;
01067         (<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> == <a class="code" href="../../d7/d0/cmdat2_8c.html#a36">Bin</a>-&gt;<a class="code" href="../../d7/d4/struct__HBIN.html#o2">Size</a>-<span class="keyword">sizeof</span>(<a class="code" href="../../d7/d4/struct__HBIN.html">HBIN</a>))) {
01068 
01069         <span class="comment">//</span>
01070         <span class="comment">// We have a bin that is entirely free.  But we cannot do anything with it</span>
01071         <span class="comment">// unless the memalloc that contains the bin is entirely free.  Walk the</span>
01072         <span class="comment">// bins backwards until we find the first one in the alloc, then walk forwards</span>
01073         <span class="comment">// until we find the last one.  If any of the other bins in the memalloc</span>
01074         <span class="comment">// are not free, bail out.</span>
01075         <span class="comment">//</span>
01076         FirstBin = <a class="code" href="../../d7/d0/cmdat2_8c.html#a36">Bin</a>;
01077         <span class="keywordflow">while</span> (FirstBin-&gt;<a class="code" href="../../d7/d4/struct__HBIN.html#o5">MemAlloc</a> == 0) {
01078             Map=<a class="code" href="../../d8/d0/hivecell_8c.html#a14">HvpGetCellMap</a>(Hive,(FirstBin-&gt;<a class="code" href="../../d7/d4/struct__HBIN.html#o1">FileOffset</a> - HBLOCK_SIZE) +
01079                                    (Type * HCELL_TYPE_MASK));
01080             <a class="code" href="../../d1/d2/cmp_8h.html#a65">VALIDATE_CELL_MAP</a>(__LINE__,Map,Hive,(FirstBin-&gt;<a class="code" href="../../d7/d4/struct__HBIN.html#o1">FileOffset</a> - HBLOCK_SIZE) +(Type * HCELL_TYPE_MASK));
01081             FirstBin = (<a class="code" href="../../d7/d4/struct__HBIN.html">PHBIN</a>)(Map-&gt;<a class="code" href="../../d2/d8/struct__HMAP__ENTRY.html#o1">BinAddress</a> &amp; <a class="code" href="../../d0/d1/hivedata_8h.html#a34">HMAP_BASE</a>);
01082             FirstCell = (<a class="code" href="../../d8/d4/struct__HCELL.html">PHCELL</a>)(FirstBin+1);
01083             <span class="keywordflow">if</span> ((ULONG)(FirstCell-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o0">Size</a>) != FirstBin-&gt;<a class="code" href="../../d7/d4/struct__HBIN.html#o2">Size</a>-<span class="keyword">sizeof</span>(<a class="code" href="../../d7/d4/struct__HBIN.html">HBIN</a>)) {
01084                 <span class="comment">//</span>
01085                 <span class="comment">// The first cell in the bin is either allocated, or not the only</span>
01086                 <span class="comment">// cell in the HBIN.  We cannot free any HBINs.</span>
01087                 <span class="comment">//</span>
01088                 <span class="keywordflow">goto</span> Done;
01089             }
01090         }
01091 
01092         <span class="comment">//</span>
01093         <span class="comment">// We can never discard the first bin of a hive as that always gets marked dirty</span>
01094         <span class="comment">// and written out.</span>
01095         <span class="comment">//</span>
01096         <span class="keywordflow">if</span> (FirstBin-&gt;<a class="code" href="../../d7/d4/struct__HBIN.html#o1">FileOffset</a> == 0) {
01097             <span class="keywordflow">goto</span> Done;
01098         }
01099 
01100         LastBin = <a class="code" href="../../d7/d0/cmdat2_8c.html#a36">Bin</a>;
01101         <span class="keywordflow">while</span> (LastBin-&gt;<a class="code" href="../../d7/d4/struct__HBIN.html#o1">FileOffset</a>+LastBin-&gt;<a class="code" href="../../d7/d4/struct__HBIN.html#o2">Size</a> &lt; FirstBin-&gt;<a class="code" href="../../d7/d4/struct__HBIN.html#o1">FileOffset</a>+FirstBin-&gt;<a class="code" href="../../d7/d4/struct__HBIN.html#o5">MemAlloc</a>) {
01102             <span class="keywordflow">if</span> (!CoalesceForward) {
01103                 <span class="comment">//</span>
01104                 <span class="comment">// We are at the end of what's been built up. Just return and this</span>
01105                 <span class="comment">// will get freed up when the next HBIN is added.</span>
01106                 <span class="comment">//</span>
01107                 <span class="keywordflow">goto</span> Done;
01108             }
01109             Map = <a class="code" href="../../d8/d0/hivecell_8c.html#a14">HvpGetCellMap</a>(Hive, (LastBin-&gt;<a class="code" href="../../d7/d4/struct__HBIN.html#o1">FileOffset</a>+LastBin-&gt;<a class="code" href="../../d7/d4/struct__HBIN.html#o2">Size</a>) +
01110                                       (Type * HCELL_TYPE_MASK));
01111             <a class="code" href="../../d1/d2/cmp_8h.html#a65">VALIDATE_CELL_MAP</a>(__LINE__,Map,Hive,(LastBin-&gt;<a class="code" href="../../d7/d4/struct__HBIN.html#o1">FileOffset</a>+LastBin-&gt;<a class="code" href="../../d7/d4/struct__HBIN.html#o2">Size</a>) + (Type * HCELL_TYPE_MASK));
01112 
01113             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(Map-&gt;<a class="code" href="../../d2/d8/struct__HMAP__ENTRY.html#o1">BinAddress</a> != 0);
01114 
01115             LastBin = (<a class="code" href="../../d7/d4/struct__HBIN.html">PHBIN</a>)(Map-&gt;<a class="code" href="../../d2/d8/struct__HMAP__ENTRY.html#o1">BinAddress</a> &amp; <a class="code" href="../../d0/d1/hivedata_8h.html#a34">HMAP_BASE</a>);
01116             FirstCell = (<a class="code" href="../../d8/d4/struct__HCELL.html">PHCELL</a>)(LastBin + 1);
01117             <span class="keywordflow">if</span> ((ULONG)(FirstCell-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o0">Size</a>) != LastBin-&gt;<a class="code" href="../../d7/d4/struct__HBIN.html#o2">Size</a>-<span class="keyword">sizeof</span>(<a class="code" href="../../d7/d4/struct__HBIN.html">HBIN</a>)) {
01118                 <span class="comment">//</span>
01119                 <span class="comment">// The first cell in the bin is either allocated, or not the only</span>
01120                 <span class="comment">// cell in the HBIN.  We cannot free any HBINs.</span>
01121                 <span class="comment">//</span>
01122                 <span class="keywordflow">goto</span> Done;
01123             }
01124         }
01125 
01126         <span class="comment">//</span>
01127         <span class="comment">// All the bins in this alloc are freed.  Coalesce all the bins into</span>
01128         <span class="comment">// one alloc-sized bin, then either discard the bin or mark it as</span>
01129         <span class="comment">// discardable.</span>
01130         <span class="comment">//</span>
01131         <span class="keywordflow">if</span> (FirstBin-&gt;<a class="code" href="../../d7/d4/struct__HBIN.html#o2">Size</a> != FirstBin-&gt;<a class="code" href="../../d7/d4/struct__HBIN.html#o5">MemAlloc</a>) {
01132             <span class="comment">//</span>
01133             <span class="comment">// Mark the first HBLOCK of the first HBIN dirty, since</span>
01134             <span class="comment">// we will need to update the on disk field for the bin size</span>
01135             <span class="comment">//</span>
01136             <span class="keywordflow">if</span> (!<a class="code" href="../../d0/d2/hivesync_8c.html#a9">HvMarkDirty</a>(Hive,
01137                              FirstBin-&gt;<a class="code" href="../../d7/d4/struct__HBIN.html#o1">FileOffset</a> + (Type * HCELL_TYPE_MASK),
01138                              <span class="keyword">sizeof</span>(<a class="code" href="../../d7/d4/struct__HBIN.html">HBIN</a>) + <span class="keyword">sizeof</span>(<a class="code" href="../../d8/d4/struct__HCELL.html">HCELL</a>))) {
01139                 <span class="keywordflow">goto</span> Done;
01140             }
01141 
01142         }
01143 
01144 
01145         FreeBin = (<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>-&gt;<a class="code" href="../../d7/d7/struct__HHIVE.html#o2">Allocate</a>)(<span class="keyword">sizeof</span>(<a class="code" href="../../d6/d0/struct__FREE__HBIN.html">FREE_HBIN</a>), <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
01146         <span class="keywordflow">if</span> (FreeBin == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01147             <span class="keywordflow">goto</span> Done;
01148         }
01149 
01150         <span class="comment">//</span>
01151         <span class="comment">// Walk through the bins and delist each free cell</span>
01152         <span class="comment">//</span>
01153         <a class="code" href="../../d7/d0/cmdat2_8c.html#a36">Bin</a> = FirstBin;
01154         <span class="keywordflow">do</span> {
01155             FirstCell = (<a class="code" href="../../d8/d4/struct__HCELL.html">PHCELL</a>)(<a class="code" href="../../d7/d0/cmdat2_8c.html#a36">Bin</a>+1);
01156             <a class="code" href="../../d8/d0/hivecell_8c.html#a19">HvpDelistFreeCell</a>(Hive, FirstCell, Type, TailDisplay);
01157             <span class="keywordflow">if</span> (<a class="code" href="../../d7/d0/cmdat2_8c.html#a36">Bin</a>==LastBin) {
01158                 <span class="keywordflow">break</span>;
01159             }
01160             Map = <a class="code" href="../../d8/d0/hivecell_8c.html#a14">HvpGetCellMap</a>(Hive, (<a class="code" href="../../d7/d0/cmdat2_8c.html#a36">Bin</a>-&gt;<a class="code" href="../../d7/d4/struct__HBIN.html#o1">FileOffset</a>+<a class="code" href="../../d7/d0/cmdat2_8c.html#a36">Bin</a>-&gt;<a class="code" href="../../d7/d4/struct__HBIN.html#o2">Size</a>)+
01161                                       (Type * HCELL_TYPE_MASK));
01162             <a class="code" href="../../d1/d2/cmp_8h.html#a65">VALIDATE_CELL_MAP</a>(__LINE__,Map,Hive,(<a class="code" href="../../d7/d0/cmdat2_8c.html#a36">Bin</a>-&gt;<a class="code" href="../../d7/d4/struct__HBIN.html#o1">FileOffset</a>+<a class="code" href="../../d7/d0/cmdat2_8c.html#a36">Bin</a>-&gt;<a class="code" href="../../d7/d4/struct__HBIN.html#o2">Size</a>)+(Type * HCELL_TYPE_MASK));
01163             <a class="code" href="../../d7/d0/cmdat2_8c.html#a36">Bin</a> = (<a class="code" href="../../d7/d4/struct__HBIN.html">PHBIN</a>)(Map-&gt;<a class="code" href="../../d2/d8/struct__HMAP__ENTRY.html#o1">BinAddress</a> &amp; <a class="code" href="../../d0/d1/hivedata_8h.html#a34">HMAP_BASE</a>);
01164 
01165         } <span class="keywordflow">while</span> ( <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
01166 
01167         <span class="comment">//</span>
01168         <span class="comment">// Coalesce them all into one bin.</span>
01169         <span class="comment">//</span>
01170         FirstBin-&gt;<a class="code" href="../../d7/d4/struct__HBIN.html#o2">Size</a> = FirstBin-&gt;MemAlloc;
01171 
01172         FreeBin-&gt;<a class="code" href="../../d6/d0/struct__FREE__HBIN.html#o1">Size</a> = FirstBin-&gt;Size;
01173         FreeBin-&gt;<a class="code" href="../../d6/d0/struct__FREE__HBIN.html#o2">FileOffset</a> = FirstBin-&gt;FileOffset;
01174         FirstCell = (<a class="code" href="../../d8/d4/struct__HCELL.html">PHCELL</a>)(FirstBin+1);
01175         FirstCell-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o0">Size</a> = FirstBin-&gt;Size - <span class="keyword">sizeof</span>(<a class="code" href="../../d7/d4/struct__HBIN.html">HBIN</a>);
01176         <span class="keywordflow">if</span> (<a class="code" href="../../d0/d1/hivedata_8h.html#a23">USE_OLD_CELL</a>(Hive)) {
01177             FirstCell-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o4">u</a>.OldCell.Last = (ULONG)<a class="code" href="../../d0/d1/hivedata_8h.html#a25">HBIN_NIL</a>;
01178         }
01179 
01180         InsertHeadList(&amp;<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>-&gt;Storage[Type].FreeBins, &amp;FreeBin-&gt;<a class="code" href="../../d6/d0/struct__FREE__HBIN.html#o0">ListEntry</a>);
01181         <a class="code" href="../../d6/d0/hive_8h.html#a3">ASSERT_LISTENTRY</a>(&amp;FreeBin-&gt;<a class="code" href="../../d6/d0/struct__FREE__HBIN.html#o0">ListEntry</a>);
01182         <a class="code" href="../../d6/d0/hive_8h.html#a3">ASSERT_LISTENTRY</a>(FreeBin-&gt;<a class="code" href="../../d6/d0/struct__FREE__HBIN.html#o0">ListEntry</a>.Flink);
01183 
01184         FreeCell = FirstBin-&gt;FileOffset+(Type*<a class="code" href="../../d0/d1/hivedata_8h.html#a7">HCELL_TYPE_MASK</a>);
01185         FreeBin-&gt;<a class="code" href="../../d6/d0/struct__FREE__HBIN.html#o3">Flags</a> = <a class="code" href="../../d0/d1/hivedata_8h.html#a48">FREE_HBIN_DISCARDABLE</a>;
01186         <span class="keywordflow">while</span> (FreeCell-FirstBin-&gt;FileOffset &lt; FirstBin-&gt;Size) {
01187             Map = <a class="code" href="../../d8/d0/hivecell_8c.html#a14">HvpGetCellMap</a>(Hive, FreeCell);
01188             <a class="code" href="../../d1/d2/cmp_8h.html#a65">VALIDATE_CELL_MAP</a>(__LINE__,Map,Hive,FreeCell);
01189             <span class="keywordflow">if</span> (Map-&gt;<a class="code" href="../../d2/d8/struct__HMAP__ENTRY.html#o1">BinAddress</a> &amp; <a class="code" href="../../d0/d1/hivedata_8h.html#a35">HMAP_NEWALLOC</a>) {
01190                 Map-&gt;<a class="code" href="../../d2/d8/struct__HMAP__ENTRY.html#o1">BinAddress</a> = (ULONG_PTR)FirstBin | <a class="code" href="../../d0/d1/hivedata_8h.html#a36">HMAP_DISCARDABLE</a> | <a class="code" href="../../d0/d1/hivedata_8h.html#a35">HMAP_NEWALLOC</a>;
01191             } <span class="keywordflow">else</span> {
01192                 Map-&gt;<a class="code" href="../../d2/d8/struct__HMAP__ENTRY.html#o1">BinAddress</a> = (ULONG_PTR)FirstBin | <a class="code" href="../../d0/d1/hivedata_8h.html#a36">HMAP_DISCARDABLE</a>;
01193             }
01194             Map-&gt;<a class="code" href="../../d2/d8/struct__HMAP__ENTRY.html#o0">BlockAddress</a> = (ULONG_PTR)FreeBin;
01195             FreeCell += <a class="code" href="../../d0/d1/hivedata_8h.html#a14">HBLOCK_SIZE</a>;
01196         }
01197     }
01198 
01199 
01200 Done:
01201     <a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>-&gt;Storage[Type].FreeSummary |= (1 &lt;&lt; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>);
01202     <span class="keywordflow">return</span>;
<a name="l01203"></a><a class="code" href="../../d8/d0/hivecell_8c.html#a19">01203</a> }
01204 
01205 
01206 
01207 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01208 <a class="code" href="../../d8/d0/hivecell_8c.html#a19">HvpDelistFreeCell</a>(
01209     <a class="code" href="../../d7/d7/struct__HHIVE.html">PHHIVE</a>  Hive,
01210     <a class="code" href="../../d8/d4/struct__HCELL.html">PHCELL</a>  Pcell,
01211     HSTORAGE_TYPE Type,
01212     PHCELL_INDEX TailDisplay OPTIONAL
01213     )
01214 <span class="comment">/*++</span>
01215 <span class="comment"></span>
01216 <span class="comment">Routine Description:</span>
01217 <span class="comment"></span>
01218 <span class="comment">    Removes a free cell from its list, and clears the Summary</span>
01219 <span class="comment">    bit for it if need be.</span>
01220 <span class="comment"></span>
01221 <span class="comment">Arguments:</span>
01222 <span class="comment"></span>
01223 <span class="comment">    Hive - supplies a pointer to the hive control structure for the</span>
01224 <span class="comment">            hive of interest</span>
01225 <span class="comment"></span>
01226 <span class="comment">    Pcell - supplies a pointer to the HCELL structure of interest</span>
01227 <span class="comment"></span>
01228 <span class="comment">    Type - Stable vs. Volatile</span>
01229 <span class="comment"></span>
01230 <span class="comment">Return Value:</span>
01231 <span class="comment"></span>
01232 <span class="comment">    NONE.</span>
01233 <span class="comment"></span>
01234 <span class="comment">--*/</span>
01235 {
01236     <a class="code" href="../../d0/d1/hivedata_8h.html#a50">PHCELL_INDEX</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a12">List</a>;
01237     <a class="code" href="../../d0/d1/hivedata_8h.html#a49">HCELL_INDEX</a> Prev = <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>;
01238     ULONG       <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
01239 
01240     <a class="code" href="../../d8/d0/hivecell_8c.html#a2">HvpComputeIndex</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>, Pcell-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o0">Size</a>);
01241     <a class="code" href="../../d1/d0/cmchek_8c.html#a12">List</a> = &amp;(<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>-&gt;Storage[Type].FreeDisplay[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>]);
01242 
01243     <span class="comment">//</span>
01244     <span class="comment">// Find previous cell on list</span>
01245     <span class="comment">//</span>
01246     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(*<a class="code" href="../../d1/d0/cmchek_8c.html#a12">List</a> != <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>);
01247     <span class="keywordflow">while</span> (<a class="code" href="../../d6/d0/hive_8h.html#a13">HvpGetHCell</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>,*<a class="code" href="../../d1/d0/cmchek_8c.html#a12">List</a>) != Pcell) {
01248         Prev = *<a class="code" href="../../d1/d0/cmchek_8c.html#a12">List</a>;
01249         <a class="code" href="../../d1/d0/cmchek_8c.html#a12">List</a> = (<a class="code" href="../../d0/d1/hivedata_8h.html#a50">PHCELL_INDEX</a>)<a class="code" href="../../d6/d0/hive_8h.html#a12">HvGetCell</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>,*<a class="code" href="../../d1/d0/cmchek_8c.html#a12">List</a>);
01250         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(*<a class="code" href="../../d1/d0/cmchek_8c.html#a12">List</a> != <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>);
01251     }
01252 
01253     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(TailDisplay)) {
01254         <span class="comment">//</span>
01255         <span class="comment">// This should only happen once, at boot time; Then, we want to sort the list ascedending</span>
01256         <span class="comment">//</span>
01257         <span class="keywordflow">if</span>( *<a class="code" href="../../d1/d0/cmchek_8c.html#a12">List</a> == TailDisplay[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>] ) {
01258             <span class="comment">//</span>
01259             <span class="comment">// this cell is also the last cell on list; so it should be reset</span>
01260             <span class="comment">//</span>
01261 
01262 <span class="preprocessor">#if DBG</span>
01263 <span class="preprocessor"></span>            <span class="comment">//</span>
01264             <span class="comment">// consistency checks</span>
01265             <span class="comment">//</span>
01266             <span class="keywordflow">if</span> (<a class="code" href="../../d0/d1/hivedata_8h.html#a23">USE_OLD_CELL</a>(Hive)) {
01267                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(Pcell-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o4">u</a>.OldCell.u.Next == HCELL_NIL);
01268             } <span class="keywordflow">else</span> {
01269                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(Pcell-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o4">u</a>.NewCell.u.Next == HCELL_NIL);
01270             }
01271 <span class="preprocessor">#endif</span>
01272 <span class="preprocessor"></span>
01273             TailDisplay[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>] = Prev;
01274         }
01275     }
01276 
01277     <span class="comment">//</span>
01278     <span class="comment">// Remove Pcell from list.</span>
01279     <span class="comment">//</span>
01280     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d1/hivedata_8h.html#a23">USE_OLD_CELL</a>(Hive)) {
01281         *<a class="code" href="../../d1/d0/cmchek_8c.html#a12">List</a> = Pcell-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o4">u</a>.OldCell.u.Next;
01282     } <span class="keywordflow">else</span> {
01283         *<a class="code" href="../../d1/d0/cmchek_8c.html#a12">List</a> = Pcell-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o4">u</a>.NewCell.u.Next;
01284     }
01285 
01286     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>-&gt;Storage[Type].FreeDisplay[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>] == <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>) {
01287         <span class="comment">//</span>
01288         <span class="comment">// consistency check</span>
01289         <span class="comment">//</span>
01290         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(Prev == HCELL_NIL);
01291 
01292         <a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>-&gt;Storage[Type].FreeSummary &amp;= ~(1 &lt;&lt; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>);
01293     }
01294 
<a name="l01295"></a><a class="code" href="../../d8/d0/hivecell_8c.html#a20">01295</a>     <span class="keywordflow">return</span>;
01296 }
01297 
01298 
01299 <a class="code" href="../../d0/d1/hivedata_8h.html#a49">HCELL_INDEX</a>
01300 <a class="code" href="../../d8/d0/hivecell_8c.html#a20">HvReallocateCell</a>(
01301     <a class="code" href="../../d7/d7/struct__HHIVE.html">PHHIVE</a>  Hive,
01302     HCELL_INDEX Cell,
01303     ULONG    NewSize
01304     )
01305 <span class="comment">/*++</span>
01306 <span class="comment"></span>
01307 <span class="comment">Routine Description:</span>
01308 <span class="comment"></span>
01309 <span class="comment">    Grows or shrinks a cell.</span>
01310 <span class="comment"></span>
01311 <span class="comment">    NOTE:</span>
01312 <span class="comment"></span>
01313 <span class="comment">        MUST NOT FAIL if the cell is being made smaller.  Can be</span>
01314 <span class="comment">        a noop, but must work.</span>
01315 <span class="comment"></span>
01316 <span class="comment">    WARNING:</span>
01317 <span class="comment"></span>
01318 <span class="comment">        If the cell is grown, it will get a NEW and DIFFERENT HCELL_INDEX!!!</span>
01319 <span class="comment"></span>
01320 <span class="comment">Arguments:</span>
01321 <span class="comment"></span>
01322 <span class="comment">    Hive - supplies a pointer to the hive control structure for the</span>
01323 <span class="comment">            hive of interest</span>
01324 <span class="comment"></span>
01325 <span class="comment">    Cell - supplies index of cell to grow or shrink</span>
01326 <span class="comment"></span>
01327 <span class="comment">    NewSize - desired size of cell  (this is an absolute size, not an</span>
01328 <span class="comment">            increment or decrement.)</span>
01329 <span class="comment"></span>
01330 <span class="comment">Return Value:</span>
01331 <span class="comment"></span>
01332 <span class="comment">    New HCELL_INDEX for cell, or HCELL_NIL if failure.</span>
01333 <span class="comment"></span>
01334 <span class="comment">    If return is HCELL_NIL, either old cell did not exist, or it did exist</span>
01335 <span class="comment">    and we could not make a new one.  In either case, nothing has changed.</span>
01336 <span class="comment"></span>
01337 <span class="comment">    If return is NOT HCELL_NIL, then it is the HCELL_INDEX for the Cell,</span>
01338 <span class="comment">    which very probably moved.</span>
01339 <span class="comment"></span>
01340 <span class="comment">--*/</span>
01341 {
01342     PUCHAR      oldaddress;
01343     LONG        oldsize;
01344     ULONG       oldalloc;
01345     <a class="code" href="../../d0/d1/hivedata_8h.html#a49">HCELL_INDEX</a> NewCell;            <span class="comment">// return value</span>
01346     PUCHAR      newaddress;
01347     ULONG       Type;
01348 
01349     <a class="code" href="../../d1/d2/cmp_8h.html#a55">CMLOG</a>(<a class="code" href="../../d1/d2/cmp_8h.html#a22">CML_MAJOR</a>, <a class="code" href="../../d1/d2/cmp_8h.html#a29">CMS_HIVE</a>) {
01350         KdPrint((<span class="stringliteral">"HvReallocateCell:\n"</span>));
01351         KdPrint((<span class="stringliteral">"\tHive=%08lx  Cell=%08lx  NewSize=%08lx\n"</span>,<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>,<a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a>,NewSize));
01352     }
01353     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>-&gt;<a class="code" href="../../d7/d7/struct__HHIVE.html#o0">Signature</a> == HHIVE_SIGNATURE);
01354     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>-&gt;<a class="code" href="../../d7/d7/struct__HHIVE.html#o14">ReadOnly</a> == FALSE);
01355     <a class="code" href="../../d1/d2/cmp_8h.html#a62">ASSERT_CM_LOCK_OWNED_EXCLUSIVE</a>();
01356 
01357     <span class="comment">//</span>
01358     <span class="comment">// Make room for overhead fields and round up to HCELL_PAD boundary</span>
01359     <span class="comment">//</span>
01360     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d1/hivedata_8h.html#a23">USE_OLD_CELL</a>(Hive)) {
01361         NewSize += FIELD_OFFSET(<a class="code" href="../../d8/d4/struct__HCELL.html">HCELL</a>, u.OldCell.u.UserData);
01362     } <span class="keywordflow">else</span> {
01363         NewSize += FIELD_OFFSET(<a class="code" href="../../d8/d4/struct__HCELL.html">HCELL</a>, u.NewCell.u.UserData);
01364     }
01365     NewSize = <a class="code" href="../../d6/d0/hive_8h.html#a2">ROUND_UP</a>(NewSize, <a class="code" href="../../d0/d1/hivedata_8h.html#a20">HCELL_PAD</a>(Hive));
01366 
01367     <span class="comment">// </span>
01368     <span class="comment">// Adjust the size (an easy fix for granularity)</span>
01369     <span class="comment">//</span>
01370     <a class="code" href="../../d8/d0/hivecell_8c.html#a4">HvpAdjustCellSize</a>(NewSize);
01371 
01372     <span class="comment">//</span>
01373     <span class="comment">// reject impossible/unreasonable values</span>
01374     <span class="comment">//</span>
01375     <span class="keywordflow">if</span> (NewSize &gt; <a class="code" href="../../d0/d1/hivedata_8h.html#a0">HSANE_CELL_MAX</a>) {
01376         <a class="code" href="../../d1/d2/cmp_8h.html#a55">CMLOG</a>(CML_FLOW, CMS_HIVE) {
01377             KdPrint((<span class="stringliteral">"\tNewSize=%08lx\n"</span>, NewSize));
01378         }
01379         <span class="keywordflow">return</span> <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>;
01380     }
01381 
01382     <span class="comment">//</span>
01383     <span class="comment">// Get sizes and addresses</span>
01384     <span class="comment">//</span>
01385     oldaddress = (PUCHAR)<a class="code" href="../../d6/d0/hive_8h.html#a12">HvGetCell</a>(Hive, Cell);
01386     oldsize = <a class="code" href="../../d8/d0/hivecell_8c.html#a15">HvGetCellSize</a>(Hive, oldaddress);
01387     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(oldsize &gt; 0);
01388     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d1/hivedata_8h.html#a23">USE_OLD_CELL</a>(Hive)) {
01389         oldalloc = (ULONG)(oldsize + FIELD_OFFSET(<a class="code" href="../../d8/d4/struct__HCELL.html">HCELL</a>, u.OldCell.u.UserData));
01390     } <span class="keywordflow">else</span> {
01391         oldalloc = (ULONG)(oldsize + FIELD_OFFSET(<a class="code" href="../../d8/d4/struct__HCELL.html">HCELL</a>, u.NewCell.u.UserData));
01392     }
01393     Type = <a class="code" href="../../d0/d1/hivedata_8h.html#a19">HvGetCellType</a>(Cell);
01394 
01395     <a class="code" href="../../d6/d0/hive_8h.html#a0">DHvCheckHive</a>(Hive);
01396 
01397     <span class="keywordflow">if</span> (NewSize == oldalloc) {
01398 
01399         <span class="comment">//</span>
01400         <span class="comment">// This is a noop, return the same cell</span>
01401         <span class="comment">//</span>
01402         NewCell = <a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a>;
01403 
01404     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (NewSize &lt; oldalloc) {
01405 
01406         <span class="comment">//</span>
01407         <span class="comment">// This is a shrink.</span>
01408         <span class="comment">//</span>
01409         <span class="comment">// PERFNOTE - IMPLEMENT THIS.  Do nothing for now.</span>
01410         <span class="comment">//</span>
01411         NewCell = <a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a>;
01412 
01413     } <span class="keywordflow">else</span> {
01414 
01415         <span class="comment">//</span>
01416         <span class="comment">// This is a grow.</span>
01417         <span class="comment">//</span>
01418 
01419         <span class="comment">//</span>
01420         <span class="comment">// PERFNOTE - Someday we want to detect that there is a free neighbor</span>
01421         <span class="comment">//          above us and grow into that neighbor if possible.</span>
01422         <span class="comment">//          For now, always do the allocate, copy, free gig.</span>
01423         <span class="comment">//</span>
01424 
01425         <span class="comment">//</span>
01426         <span class="comment">// Allocate a new block of memory to hold the cell</span>
01427         <span class="comment">//</span>
01428 
01429         <span class="keywordflow">if</span> ((NewCell = <a class="code" href="../../d8/d0/hivecell_8c.html#a7">HvpDoAllocateCell</a>(Hive, NewSize, Type)) == <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>) {
01430             <span class="keywordflow">return</span> <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>;
01431         }
01432         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(<a class="code" href="../../d8/d0/hivecell_8c.html#a21">HvIsCellAllocated</a>(Hive, NewCell));
01433         newaddress = (PUCHAR)<a class="code" href="../../d6/d0/hive_8h.html#a12">HvGetCell</a>(Hive, NewCell);
01434 
01435         <span class="comment">//</span>
01436         <span class="comment">// oldaddress points to the old data block for the cell,</span>
01437         <span class="comment">// newaddress points to the new data block, copy the data</span>
01438         <span class="comment">//</span>
01439         RtlMoveMemory(newaddress, oldaddress, oldsize);
01440 
01441         <span class="comment">//</span>
01442         <span class="comment">// Free the old block of memory</span>
01443         <span class="comment">//</span>
01444         <a class="code" href="../../d8/d0/hivecell_8c.html#a17">HvFreeCell</a>(Hive, Cell);
01445     }
01446 
01447     <a class="code" href="../../d6/d0/hive_8h.html#a0">DHvCheckHive</a>(Hive);
01448     <span class="keywordflow">return</span> NewCell;
01449 }
01450 
01451 
01452 
<a name="l01453"></a><a class="code" href="../../d8/d0/hivecell_8c.html#a21">01453</a> <span class="comment">//</span>
01454 <span class="comment">// Procedure used for checking only  (used in production systems, so</span>
01455 <span class="comment">//  must always be here.)</span>
01456 <span class="comment">//</span>
01457 BOOLEAN
01458 <a class="code" href="../../d8/d0/hivecell_8c.html#a21">HvIsCellAllocated</a>(
01459     <a class="code" href="../../d7/d7/struct__HHIVE.html">PHHIVE</a> Hive,
01460     HCELL_INDEX Cell
01461     )
01462 <span class="comment">/*++</span>
01463 <span class="comment"></span>
01464 <span class="comment">Routine Description:</span>
01465 <span class="comment"></span>
01466 <span class="comment">    Report whether the requested cell is allocated or not.</span>
01467 <span class="comment"></span>
01468 <span class="comment">Arguments:</span>
01469 <span class="comment"></span>
01470 <span class="comment">    Hive - containing Hive.</span>
01471 <span class="comment"></span>
01472 <span class="comment">    Cell - cel of interest</span>
01473 <span class="comment"></span>
01474 <span class="comment">Return Value:</span>
01475 <span class="comment"></span>
01476 <span class="comment">    TRUE if allocated, FALSE if not.</span>
01477 <span class="comment"></span>
01478 <span class="comment">--*/</span>
01479 {
01480     ULONG   Type;
01481     <a class="code" href="../../d8/d4/struct__HCELL.html">PHCELL</a>  Address;
01482     <a class="code" href="../../d8/d4/struct__HCELL.html">PHCELL</a>  Below;
01483     <a class="code" href="../../d2/d8/struct__HMAP__ENTRY.html">PHMAP_ENTRY</a> Me;
01484     <a class="code" href="../../d7/d4/struct__HBIN.html">PHBIN</a>   <a class="code" href="../../d7/d0/cmdat2_8c.html#a36">Bin</a>;
01485     ULONG   <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>;
01486     LONG    <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
01487 
01488 
01489     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>-&gt;<a class="code" href="../../d7/d7/struct__HHIVE.html#o0">Signature</a> == <a class="code" href="../../d0/d1/hivedata_8h.html#a37">HHIVE_SIGNATURE</a>);
01490 
01491     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>-&gt;<a class="code" href="../../d7/d7/struct__HHIVE.html#o13">Flat</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
01492         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01493     }
01494 
01495     Type = <a class="code" href="../../d0/d1/hivedata_8h.html#a19">HvGetCellType</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a>);
01496 
01497     <span class="keywordflow">if</span> ( ((<a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a> &amp; ~<a class="code" href="../../d0/d1/hivedata_8h.html#a7">HCELL_TYPE_MASK</a>) &gt; <a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>-&gt;Storage[Type].Length) || <span class="comment">// off end</span>
01498          (<a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a> % <a class="code" href="../../d0/d1/hivedata_8h.html#a20">HCELL_PAD</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>) != 0)                    <span class="comment">// wrong alignment</span>
01499        )
01500     {
01501         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01502     }
01503 
01504     Address = <a class="code" href="../../d6/d0/hive_8h.html#a13">HvpGetHCell</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>, <a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a>);
01505     Me = <a class="code" href="../../d8/d0/hivecell_8c.html#a14">HvpGetCellMap</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>, <a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a>);
01506     <span class="keywordflow">if</span> (Me == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01507         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01508     }
01509     <a class="code" href="../../d7/d0/cmdat2_8c.html#a36">Bin</a> = (<a class="code" href="../../d7/d4/struct__HBIN.html">PHBIN</a>)((ULONG_PTR)(Me-&gt;<a class="code" href="../../d2/d8/struct__HMAP__ENTRY.html#o1">BinAddress</a>) &amp; <a class="code" href="../../d0/d1/hivedata_8h.html#a34">HMAP_BASE</a>);
01510     <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> = (ULONG)((ULONG_PTR)Address - (ULONG_PTR)<a class="code" href="../../d7/d0/cmdat2_8c.html#a36">Bin</a>);
01511     <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> = Address-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o0">Size</a> * -1;
01512 
01513     <span class="keywordflow">if</span> ( (Address-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o0">Size</a> &gt; 0) ||                     <span class="comment">// not allocated</span>
01514          ((<a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> + (ULONG)<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>) &gt; <a class="code" href="../../d7/d0/cmdat2_8c.html#a36">Bin</a>-&gt;<a class="code" href="../../d7/d4/struct__HBIN.html#o2">Size</a>) ||    <span class="comment">// runs off bin, or too big</span>
01515          (<a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> &lt; <span class="keyword">sizeof</span>(<a class="code" href="../../d7/d4/struct__HBIN.html">HBIN</a>))                    <span class="comment">// pts into bin header</span>
01516        )
01517     {
01518         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01519     }
01520 
01521     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d1/hivedata_8h.html#a23">USE_OLD_CELL</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>)) {
01522         <span class="keywordflow">if</span> (Address-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o4">u</a>.OldCell.Last != <a class="code" href="../../d0/d1/hivedata_8h.html#a25">HBIN_NIL</a>) {
01523 
01524             <span class="keywordflow">if</span> (Address-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o4">u</a>.OldCell.Last &gt; <a class="code" href="../../d7/d0/cmdat2_8c.html#a36">Bin</a>-&gt;<a class="code" href="../../d7/d4/struct__HBIN.html#o2">Size</a>) {            <span class="comment">// bogus back pointer</span>
01525                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01526             }
01527 
01528             Below = (<a class="code" href="../../d8/d4/struct__HCELL.html">PHCELL</a>)((PUCHAR)<a class="code" href="../../d7/d0/cmdat2_8c.html#a36">Bin</a> + Address-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o4">u</a>.OldCell.Last);
01529             <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> = (Below-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o0">Size</a> &lt; 0) ?
01530                         Below-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o0">Size</a> * -1 :
01531                         Below-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o0">Size</a>;
01532 
01533             <span class="keywordflow">if</span> ( ((ULONG_PTR)Below + <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>) != (ULONG_PTR)Address ) {    <span class="comment">// no pt back</span>
01534                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01535             }
01536         }
01537     }
01538 
<a name="l01539"></a><a class="code" href="../../d8/d0/hivecell_8c.html#a11">01539</a> 
01540     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01541 }
01542 
01543 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01544 <a class="code" href="../../d6/d1/hiveload_8c.html#a18">HvpDelistBinFreeCells</a>(
01545     <a class="code" href="../../d7/d7/struct__HHIVE.html">PHHIVE</a>  Hive,
01546     <a class="code" href="../../d7/d4/struct__HBIN.html">PHBIN</a>   Bin,
01547     HSTORAGE_TYPE Type,
01548     PHCELL_INDEX TailDisplay OPTIONAL
01549     )
01550 <span class="comment">/*++</span>
01551 <span class="comment"></span>
01552 <span class="comment">Routine Description:</span>
01553 <span class="comment"></span>
01554 <span class="comment">    If we are here, the hive needs recovery.</span>
01555 <span class="comment"></span>
01556 <span class="comment">    Walks through the entire bin and removes its free cells from the list.</span>
01557 <span class="comment">    If the bin is marked as free, it just delist it from the freebins list.</span>
01558 <span class="comment"></span>
01559 <span class="comment">Arguments:</span>
01560 <span class="comment"></span>
01561 <span class="comment">    Hive - supplies a pointer to the hive control structure for the</span>
01562 <span class="comment">            hive of interest</span>
01563 <span class="comment"></span>
01564 <span class="comment">    Bin - supplies a pointer to the HBIN of interest</span>
01565 <span class="comment"></span>
01566 <span class="comment">    Type - Stable vs. Volatile</span>
01567 <span class="comment"></span>
01568 <span class="comment">Return Value:</span>
01569 <span class="comment"></span>
01570 <span class="comment">    NONE.</span>
01571 <span class="comment"></span>
01572 <span class="comment">--*/</span>
01573 {
01574     <a class="code" href="../../d8/d4/struct__HCELL.html">PHCELL</a>  p;
01575     ULONG   size;
01576     <a class="code" href="../../d0/d1/hivedata_8h.html#a49">HCELL_INDEX</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a>;
01577     <a class="code" href="../../d2/d8/struct__HMAP__ENTRY.html">PHMAP_ENTRY</a> Map;
01578     <a class="code" href="../../d6/d0/struct__FREE__HBIN.html">PFREE_HBIN</a> FreeBin;
01579     PLIST_ENTRY Entry;
01580 
01581     <a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a> = <a class="code" href="../../d7/d0/cmdat2_8c.html#a36">Bin</a>-&gt;<a class="code" href="../../d7/d4/struct__HBIN.html#o1">FileOffset</a>+(Type*<a class="code" href="../../d0/d1/hivedata_8h.html#a7">HCELL_TYPE_MASK</a>);
01582     Map = <a class="code" href="../../d8/d0/hivecell_8c.html#a14">HvpGetCellMap</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>, <a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a>);
01583     <a class="code" href="../../d1/d2/cmp_8h.html#a65">VALIDATE_CELL_MAP</a>(__LINE__,Map,<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>,<a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a>);
01584 
01585     <span class="comment">//</span>
01586     <span class="comment">// When loading, bins are always in separate chunks (each bin in it's owns chunk)</span>
01587     <span class="comment">//</span>
01588     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( Map-&gt;<a class="code" href="../../d2/d8/struct__HMAP__ENTRY.html#o1">BinAddress</a> == ((ULONG_PTR)<a class="code" href="../../d7/d0/cmdat2_8c.html#a36">Bin</a> | <a class="code" href="../../d0/d1/hivedata_8h.html#a35">HMAP_NEWALLOC</a>) );
01589     
01590     <span class="keywordflow">if</span>( Map-&gt;<a class="code" href="../../d2/d8/struct__HMAP__ENTRY.html#o1">BinAddress</a> &amp; <a class="code" href="../../d0/d1/hivedata_8h.html#a36">HMAP_DISCARDABLE</a> ) {
01591         <span class="comment">//</span>
01592         <span class="comment">// The bin has been added to the freebins list</span>
01593         <span class="comment">// we have to take it out. No free cell from this bin is on the </span>
01594         <span class="comment">// freecells list, so we don't have to delist them.</span>
01595         <span class="comment">//</span>
01596 
01597         Entry = <a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>-&gt;Storage[Type].FreeBins.Flink;
01598         <span class="keywordflow">while</span> (Entry != &amp;<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>-&gt;Storage[Type].FreeBins) {
01599             FreeBin = CONTAINING_RECORD(Entry,
01600                                         <a class="code" href="../../d6/d0/struct__FREE__HBIN.html">FREE_HBIN</a>,
01601                                         ListEntry);
01602 
01603             
01604             <span class="keywordflow">if</span>( FreeBin-&gt;<a class="code" href="../../d6/d0/struct__FREE__HBIN.html#o2">FileOffset</a> == <a class="code" href="../../d7/d0/cmdat2_8c.html#a36">Bin</a>-&gt;<a class="code" href="../../d7/d4/struct__HBIN.html#o1">FileOffset</a> ){
01605                 <span class="comment">//</span>
01606                 <span class="comment">// that's the bin we're looking for</span>
01607                 <span class="comment">//</span>
01608                 
01609                 <span class="comment">// sanity checks</span>
01610                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( FreeBin-&gt;<a class="code" href="../../d6/d0/struct__FREE__HBIN.html#o1">Size</a> == <a class="code" href="../../d7/d0/cmdat2_8c.html#a36">Bin</a>-&gt;<a class="code" href="../../d7/d4/struct__HBIN.html#o2">Size</a> );
01611                 <a class="code" href="../../d6/d0/hive_8h.html#a3">ASSERT_LISTENTRY</a>(&amp;FreeBin-&gt;<a class="code" href="../../d6/d0/struct__FREE__HBIN.html#o0">ListEntry</a>);
01612                 
01613                 RemoveEntryList(&amp;FreeBin-&gt;<a class="code" href="../../d6/d0/struct__FREE__HBIN.html#o0">ListEntry</a>);
01614                 (<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>-&gt;<a class="code" href="../../d7/d7/struct__HHIVE.html#o3">Free</a>)(FreeBin, <span class="keyword">sizeof</span>(<a class="code" href="../../d6/d0/struct__FREE__HBIN.html">FREE_HBIN</a>));
01615                 <span class="keywordflow">return</span>;
01616             }
01617 
01618             <span class="comment">// advance to the new bin</span>
01619             Entry = Entry-&gt;Flink;
01620         }
01621 
01622         <span class="comment">// we shouldn't get here</span>
01623         <a class="code" href="../../d1/d2/cmp_8h.html#a64">CM_BUGCHECK</a>(REGISTRY_ERROR,14,(ULONG)<a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a>,(ULONG_PTR)Map,0);
01624         <span class="keywordflow">return</span>;
01625     }
01626 
01627     <span class="comment">//</span>
01628     <span class="comment">// Scan all the cells in the bin, total free and allocated, check</span>
01629     <span class="comment">// for impossible pointers.</span>
01630     <span class="comment">//</span>
01631     p = (<a class="code" href="../../d8/d4/struct__HCELL.html">PHCELL</a>)((PUCHAR)<a class="code" href="../../d7/d0/cmdat2_8c.html#a36">Bin</a> + <span class="keyword">sizeof</span>(<a class="code" href="../../d7/d4/struct__HBIN.html">HBIN</a>));
01632 
01633     <span class="keywordflow">while</span> (p &lt; (<a class="code" href="../../d8/d4/struct__HCELL.html">PHCELL</a>)((PUCHAR)<a class="code" href="../../d7/d0/cmdat2_8c.html#a36">Bin</a> + <a class="code" href="../../d7/d0/cmdat2_8c.html#a36">Bin</a>-&gt;<a class="code" href="../../d7/d4/struct__HBIN.html#o2">Size</a>)) {
01634 
01635         <span class="comment">//</span>
01636         <span class="comment">// if free cell, remove it from the list of the hive</span>
01637         <span class="comment">//</span>
01638         <span class="keywordflow">if</span> (p-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o0">Size</a> &gt;= 0) {
01639 
01640             size = (ULONG)p-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o0">Size</a>;
01641 
01642             <span class="comment">//</span>
01643             <span class="comment">// Enlist this free cell, but do not coalesce with the next free cell</span>
01644             <span class="comment">// as we haven't gotten that far yet.</span>
01645             <span class="comment">//</span>
01646             <a class="code" href="../../d8/d0/hivecell_8c.html#a19">HvpDelistFreeCell</a>(Hive, p, Type, TailDisplay);
01647 
01648         } <span class="keywordflow">else</span> {
01649 
01650             size = (ULONG)(p-&gt;<a class="code" href="../../d8/d4/struct__HCELL.html#o0">Size</a> * -1);
01651 
01652         }
01653 
01654         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(size &gt;= 0);
01655         p = (<a class="code" href="../../d8/d4/struct__HCELL.html">PHCELL</a>)((PUCHAR)p + size);
01656     }
01657 
01658     <span class="keywordflow">return</span>;
01659 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:40:17 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
