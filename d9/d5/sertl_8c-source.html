<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: sertl.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>sertl.c</h1><a href="../../d8/d6/sertl_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1989  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    sertl.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This Module implements many security rtl routines defined in ntseapi.h</span>
00012 <span class="comment"></span>
00013 <span class="comment">Author:</span>
00014 <span class="comment"></span>
00015 <span class="comment">    Jim Kelly       (JimK)     23-Mar-1990</span>
00016 <span class="comment">    Robert Reichel  (RobertRe)  1-Mar-1991</span>
00017 <span class="comment"></span>
00018 <span class="comment">Environment:</span>
00019 <span class="comment"></span>
00020 <span class="comment">    Pure Runtime Library Routine</span>
00021 <span class="comment"></span>
00022 <span class="comment">Revision History:</span>
00023 <span class="comment"></span>
00024 <span class="comment"></span>
00025 <span class="comment">--*/</span>
00026 
00027 
00028 <span class="preprocessor">#include "<a class="code" href="../../d5/d9/ntrtlp_8h.html">ntrtlp.h</a>"</span>
00029 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00030 <span class="preprocessor">#include "seopaque.h"</span>
00031 <span class="preprocessor">#include "sertlp.h"</span>
00032 <span class="preprocessor">#ifdef NTOS_KERNEL_RUNTIME</span>
00033 <span class="preprocessor"></span><span class="preprocessor">#include &lt;..\se\sep.h&gt;</span>
00034 <span class="preprocessor">#else // NTOS_KERNEL_RUNTIME</span>
00035 <span class="preprocessor"></span><span class="preprocessor">#include &lt;..\dll\ldrp.h&gt;</span>
00036 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
00037 <span class="preprocessor"></span>
00038 <span class="comment">//</span>
00039 <span class="comment">// BUG, BUG does anybody use this routine - no prototype in ntrtl.h</span>
00040 <span class="comment">//</span>
00041 
00042 ULONG
00043 <a class="code" href="../../d8/d6/sertl_8c.html#a13">RtlLengthUsedSecurityDescriptor</a> (
00044     IN PSECURITY_DESCRIPTOR SecurityDescriptor
00045     );
00046 
00047 <span class="preprocessor">#undef RtlEqualLuid</span>
00048 <span class="preprocessor"></span>
00049 NTSYSAPI
00050 BOOLEAN
00051 NTAPI
00052 <a class="code" href="../../d8/d6/sertl_8c.html#a50">RtlEqualLuid</a> (
00053     PLUID Luid1,
00054     PLUID Luid2
00055     );
00056 
00057 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00058 <a class="code" href="../../d8/d6/sertl_8c.html#a15">RtlpConvertAclToAutoInherit</a> (
00059     IN PACL ParentAcl OPTIONAL,
00060     IN PACL ChildAcl,
00061     IN GUID *ObjectType OPTIONAL,
00062     IN BOOLEAN IsDirectoryObject,
00063     IN PSID OwnerSid,
00064     IN PSID GroupSid,
00065     IN PGENERIC_MAPPING GenericMapping,
00066     OUT PACL *NewAcl,
00067     OUT PULONG NewGenericControl
00068     );
00069 
00070 BOOLEAN
00071 <a class="code" href="../../d8/d6/sertl_8c.html#a16">RtlpCopyEffectiveAce</a> (
00072     IN PACE_HEADER OldAce,
00073     IN BOOLEAN AutoInherit,
00074     IN BOOLEAN WillGenerateInheritAce,
00075     IN PSID ClientOwnerSid,
00076     IN PSID ClientGroupSid,
00077     IN PSID ServerOwnerSid OPTIONAL,
00078     IN PSID ServerGroupSid OPTIONAL,
00079     IN PGENERIC_MAPPING GenericMapping,
00080     IN GUID *NewObjectType OPTIONAL,
00081     IN OUT PVOID *AcePosition,
00082     OUT PULONG NewAceLength,
00083     OUT PACL NewAcl,
00084     OUT PBOOLEAN ObjectAceInherited OPTIONAL,
00085     OUT PBOOLEAN EffectiveAceMapped,
00086     OUT PBOOLEAN AclOverflowed
00087     );
00088 
<a name="l00089"></a><a class="code" href="../../d8/d6/sertl_8c.html#a80">00089</a> <span class="keyword">typedef</span> <span class="keyword">enum</span> {
00090      <a class="code" href="../../d8/d6/sertl_8c.html#a80a10">CopyInheritedAces</a>,
00091      <a class="code" href="../../d8/d6/sertl_8c.html#a80a11">CopyNonInheritedAces</a>,
00092      <a class="code" href="../../d8/d6/sertl_8c.html#a80a12">CopyAllAces</a> } <a class="code" href="../../d8/d6/sertl_8c.html#a80">ACE_TYPE_TO_COPY</a>;
00093 
00094 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00095 <a class="code" href="../../d8/d6/sertl_8c.html#a17">RtlpCopyAces</a>(
00096     IN PACL Acl,
00097     IN PGENERIC_MAPPING GenericMapping,
00098     IN ACE_TYPE_TO_COPY AceTypeToCopy,
00099     IN UCHAR AceFlagsToReset,
00100     IN BOOLEAN MapSids,
00101     IN PSID ClientOwnerSid,
00102     IN PSID ClientGroupSid,
00103     IN PSID ServerOwnerSid OPTIONAL,
00104     IN PSID ServerGroupSid OPTIONAL,
00105     OUT PULONG NewAclSizeParam,
00106     OUT PACL NewAcl
00107     );
00108 
00109 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00110 <a class="code" href="../../d8/d6/sertl_8c.html#a18">RtlpGenerateInheritedAce</a> (
00111     IN PACE_HEADER OldAce,
00112     IN BOOLEAN IsDirectoryObject,
00113     IN BOOLEAN AutoInherit,
00114     IN PSID ClientOwnerSid,
00115     IN PSID ClientGroupSid,
00116     IN PSID ServerOwnerSid OPTIONAL,
00117     IN PSID ServerGroupSid OPTIONAL,
00118     IN PGENERIC_MAPPING GenericMapping,
00119     IN GUID *NewObjectType OPTIONAL,
00120     OUT PULONG NewAceLength,
00121     OUT PACL NewAcl,
00122     OUT PULONG NewAceExtraLength,
00123     OUT PBOOLEAN ObjectAceInherited
00124     );
00125 
00126 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00127 <a class="code" href="../../d8/d6/sertl_8c.html#a19">RtlpGenerateInheritAcl</a>(
00128     IN PACL Acl,
00129     IN BOOLEAN IsDirectoryObject,
00130     IN BOOLEAN AutoInherit,
00131     IN PSID ClientOwnerSid,
00132     IN PSID ClientGroupSid,
00133     IN PSID ServerOwnerSid OPTIONAL,
00134     IN PSID ServerGroupSid OPTIONAL,
00135     IN PGENERIC_MAPPING GenericMapping,
00136     IN GUID *NewObjectType OPTIONAL,
00137     OUT PULONG NewAclSizeParam,
00138     OUT PACL NewAcl,
00139     OUT PBOOLEAN ObjectAceInherited
00140     );
00141 
00142 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00143 <a class="code" href="../../d8/d6/sertl_8c.html#a20">RtlpInheritAcl2</a> (
00144     IN PACL DirectoryAcl,
00145     IN PACL ChildAcl,
00146     IN ULONG ChildGenericControl,
00147     IN BOOLEAN IsDirectoryObject,
00148     IN BOOLEAN AutoInherit,
00149     IN BOOLEAN DefaultDescriptorForObject,
00150     IN PSID OwnerSid,
00151     IN PSID GroupSid,
00152     IN PSID ServerOwnerSid OPTIONAL,
00153     IN PSID ServerGroupSid OPTIONAL,
00154     IN PGENERIC_MAPPING GenericMapping,
00155     IN BOOLEAN IsSacl,
00156     IN GUID *NewObjectType OPTIONAL,
00157     IN PULONG AclBufferSize,
00158     IN OUT PUCHAR AclBuffer,
00159     OUT PBOOLEAN NewAclExplicitlyAssigned,
00160     OUT PULONG NewGenericControl
00161     );
00162 
00163 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00164 <a class="code" href="../../d8/d6/sertl_8c.html#a21">RtlpComputeMergedAcl</a> (
00165     IN PACL CurrentAcl,
00166     IN ULONG CurrentGenericControl,
00167     IN PACL ModificationAcl,
00168     IN ULONG ModificationGenericControl,
00169     IN PSID ClientOwnerSid,
00170     IN PSID ClientGroupSid,
00171     IN PGENERIC_MAPPING GenericMapping,
00172     IN BOOLEAN IsSacl,
00173     OUT PACL *NewAcl,
00174     OUT PULONG NewGenericControl
00175     );
00176 
00177 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00178 <a class="code" href="../../d8/d6/sertl_8c.html#a22">RtlpComputeMergedAcl2</a> (
00179     IN PACL CurrentAcl,
00180     IN ULONG CurrentGenericControl,
00181     IN PACL ModificationAcl,
00182     IN ULONG ModificationGenericControl,
00183     IN PSID ClientOwnerSid,
00184     IN PSID ClientGroupSid,
00185     IN PGENERIC_MAPPING GenericMapping,
00186     IN BOOLEAN IsSacl,
00187     IN PULONG AclBufferSize,
00188     IN OUT PUCHAR AclBuffer,
00189     OUT PULONG NewGenericControl
00190     );
00191 
00192 BOOLEAN
00193 <a class="code" href="../../d8/d6/sertl_8c.html#a23">RtlpCompareAces</a>(
00194     IN <a class="code" href="../../d4/d7/struct__KNOWN__ACE.html">PKNOWN_ACE</a> InheritedAce,
00195     IN <a class="code" href="../../d4/d7/struct__KNOWN__ACE.html">PKNOWN_ACE</a> ChildAce,
00196     IN PSID OwnerSid,
00197     IN PSID GroupSid
00198     );
00199 
00200 BOOLEAN
00201 <a class="code" href="../../d8/d6/sertl_8c.html#a24">RtlpCompareKnownObjectAces</a>(
00202     IN PKNOWN_OBJECT_ACE InheritedAce,
00203     IN PKNOWN_OBJECT_ACE ChildAce,
00204     IN PSID OwnerSid OPTIONAL,
00205     IN PSID GroupSid OPTIONAL
00206     );
00207 
00208 BOOLEAN
00209 <a class="code" href="../../d8/d6/sertl_8c.html#a25">RtlpCompareKnownAces</a>(
00210     IN <a class="code" href="../../d4/d7/struct__KNOWN__ACE.html">PKNOWN_ACE</a> InheritedAce,
00211     IN <a class="code" href="../../d4/d7/struct__KNOWN__ACE.html">PKNOWN_ACE</a> ChildAce,
00212     IN PSID OwnerSid OPTIONAL,
00213     IN PSID GroupSid OPTIONAL
00214     );
00215 
00216 BOOLEAN
00217 <a class="code" href="../../d8/d6/sertl_8c.html#a26">RtlpIsDuplicateAce</a>(
00218     IN PACL Acl,
00219     IN <a class="code" href="../../d4/d7/struct__KNOWN__ACE.html">PKNOWN_ACE</a> NewAce,
00220     IN GUID *ObjectType OPTIONAL
00221     );
00222 
00223 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00224 <a class="code" href="../../d8/d6/sertl_8c.html#a27">RtlpCreateServerAcl</a>(
00225     IN PACL Acl,
00226     IN BOOLEAN AclUntrusted,
00227     IN PSID ServerSid,
00228     OUT PACL *ServerAcl,
00229     OUT BOOLEAN *ServerAclAllocated
00230     );
00231 
00232 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00233 <a class="code" href="../../d8/d6/sertl_8c.html#a28">RtlpGetDefaultsSubjectContext</a>(
00234     HANDLE ClientToken,
00235     OUT PTOKEN_OWNER *OwnerInfo,
00236     OUT PTOKEN_PRIMARY_GROUP *GroupInfo,
00237     OUT PTOKEN_DEFAULT_DACL *DefaultDaclInfo,
00238     OUT PTOKEN_OWNER *ServerOwner,
00239     OUT PTOKEN_PRIMARY_GROUP *ServerGroup
00240     );
00241 
00242 BOOLEAN <a class="code" href="../../d8/d6/sertl_8c.html#a29">RtlpValidateSDOffsetAndSize</a> (
00243     IN ULONG   Offset,
00244     IN ULONG   Length,
00245     IN ULONG   MinLength,
00246     OUT PULONG MaxLength
00247     );
00248 
00249 BOOLEAN
00250 <a class="code" href="../../d8/d6/sertl_8c.html#a30">RtlValidRelativeSecurityDescriptor</a> (
00251     IN PSECURITY_DESCRIPTOR SecurityDescriptorInput,
00252     IN ULONG SecurityDescriptorLength,
00253     IN SECURITY_INFORMATION RequiredInformation
00254     );
00255 
00256 <span class="preprocessor">#if defined(ALLOC_PRAGMA) &amp;&amp; defined(NTOS_KERNEL_RUNTIME)</span>
00257 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlRunEncodeUnicodeString)</span>
00258 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlRunDecodeUnicodeString)</span>
00259 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlEraseUnicodeString)</span>
00260 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlAdjustPrivilege)</span>
00261 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlValidSid)</span>
00262 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlEqualSid)</span>
00263 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlEqualPrefixSid)</span>
00264 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlLengthRequiredSid)</span>
00265 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlInitializeSid)</span>
00266 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlFreeSid)</span>
00267 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlIdentifierAuthoritySid)</span>
00268 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlSubAuthoritySid)</span>
00269 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlSubAuthorityCountSid)</span>
00270 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlLengthSid)</span>
00271 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlCopySid)</span>
00272 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlCopySidAndAttributesArray)</span>
00273 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlConvertSidToUnicodeString)</span>
00274 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlEqualLuid)</span>
00275 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlCopyLuid)</span>
00276 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlCopyLuidAndAttributesArray)</span>
00277 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlCreateSecurityDescriptor)</span>
00278 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlCreateSecurityDescriptorRelative)</span>
00279 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlValidSecurityDescriptor)</span>
00280 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlLengthSecurityDescriptor)</span>
00281 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlLengthUsedSecurityDescriptor)</span>
00282 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlGetControlSecurityDescriptor)</span>
00283 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlSetControlSecurityDescriptor)</span>
00284 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlSetDaclSecurityDescriptor)</span>
00285 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlGetDaclSecurityDescriptor)</span>
00286 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlSetSaclSecurityDescriptor)</span>
00287 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlGetSaclSecurityDescriptor)</span>
00288 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlSetOwnerSecurityDescriptor)</span>
00289 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlGetOwnerSecurityDescriptor)</span>
00290 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlSetGroupSecurityDescriptor)</span>
00291 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlGetGroupSecurityDescriptor)</span>
00292 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlGetSecurityDescriptorRMControl)</span>
00293 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlSetSecurityDescriptorRMControl)</span>
00294 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlAreAllAccessesGranted)</span>
00295 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlAreAnyAccessesGranted)</span>
00296 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlMapGenericMask)</span>
00297 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlpApplyAclToObject)</span>
00298 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlpContainsCreatorGroupSid)</span>
00299 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlpContainsCreatorOwnerSid)</span>
00300 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlpCopyEffectiveAce)</span>
00301 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlpCopyAces)</span>
00302 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlpGenerateInheritAcl)</span>
00303 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlpGenerateInheritedAce)</span>
00304 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlpInheritAcl)</span>
00305 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlpInheritAcl2)</span>
00306 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlpComputeMergedAcl)</span>
00307 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlpComputeMergedAcl2)</span>
00308 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlpValidOwnerSubjectContext)</span>
00309 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlpConvertToAutoInheritSecurityObject)</span>
00310 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlpCompareAces)</span>
00311 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlpCompareKnownAces)</span>
00312 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlpCompareKnownObjectAces)</span>
00313 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlpIsDuplicateAce)</span>
00314 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlpConvertAclToAutoInherit)</span>
00315 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlSetSecurityObjectEx)</span>
00316 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlpCreateServerAcl)</span>
00317 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlValidRelativeSecurityDescriptor)</span>
00318 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlpValidateSDOffsetAndSize)</span>
00319 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00320 <span class="preprocessor"></span>
00321 
00322 
00324 <span class="comment">//                                                                           //</span>
00325 <span class="comment">//    Local Macros and Symbols                                               //</span>
00326 <span class="comment">//                                                                           //</span>
00328 <span class="comment"></span>
00329 
<a name="l00330"></a><a class="code" href="../../d8/d6/sertl_8c.html#a0">00330</a> <span class="preprocessor">#define CREATOR_SID_SIZE 12</span>
00331 <span class="preprocessor"></span>
<a name="l00332"></a><a class="code" href="../../d8/d6/sertl_8c.html#a1">00332</a> <span class="preprocessor">#define max(a,b)            (((a) &gt; (b)) ? (a) : (b))</span>
00333 <span class="preprocessor"></span>
00334 <span class="comment">//</span>
00335 <span class="comment">// Define an array mapping all ACE types to their base type.</span>
00336 <span class="comment">//</span>
00337 <span class="comment">// For instance, all allowed ACE types are similar.  As are all denied ACE types.</span>
00338 <span class="comment">//</span>
00339 
<a name="l00340"></a><a class="code" href="../../d8/d6/sertl_8c.html#a7">00340</a> UCHAR <a class="code" href="../../d8/d6/sertl_8c.html#a7">RtlBaseAceType</a>[] = {
00341     ACCESS_ALLOWED_ACE_TYPE,    <span class="comment">// ACCESS_ALLOWED_ACE_TYPE (0x0)</span>
00342     ACCESS_DENIED_ACE_TYPE,     <span class="comment">// ACCESS_DENIED_ACE_TYPE (0x1)</span>
00343     SYSTEM_AUDIT_ACE_TYPE,      <span class="comment">// SYSTEM_AUDIT_ACE_TYPE (0x2)</span>
00344     SYSTEM_ALARM_ACE_TYPE,      <span class="comment">// SYSTEM_ALARM_ACE_TYPE (0x3)</span>
00345     ACCESS_ALLOWED_ACE_TYPE,    <span class="comment">// ACCESS_ALLOWED_COMPOUND_ACE_TYPE (0x4)</span>
00346     ACCESS_ALLOWED_ACE_TYPE,    <span class="comment">// ACCESS_ALLOWED_OBJECT_ACE_TYPE (0x5)</span>
00347     ACCESS_DENIED_ACE_TYPE,     <span class="comment">// ACCESS_DENIED_OBJECT_ACE_TYPE (0x6)</span>
00348     SYSTEM_AUDIT_ACE_TYPE,      <span class="comment">// SYSTEM_AUDIT_OBJECT_ACE_TYPE (0x7)</span>
00349     SYSTEM_ALARM_ACE_TYPE       <span class="comment">// SYSTEM_ALARM_OBJECT_ACE_TYPE (0x8)</span>
00350 };
00351 
00352 <span class="comment">//</span>
00353 <span class="comment">// Define an array defining whether an ACE is a system ACE</span>
00354 <span class="comment">//</span>
00355 
<a name="l00356"></a><a class="code" href="../../d8/d6/sertl_8c.html#a8">00356</a> UCHAR <a class="code" href="../../d8/d6/sertl_8c.html#a8">RtlIsSystemAceType</a>[] = {
00357     <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,    <span class="comment">// ACCESS_ALLOWED_ACE_TYPE (0x0)</span>
00358     <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,    <span class="comment">// ACCESS_DENIED_ACE_TYPE (0x1)</span>
00359     <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,     <span class="comment">// SYSTEM_AUDIT_ACE_TYPE (0x2)</span>
00360     <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,     <span class="comment">// SYSTEM_ALARM_ACE_TYPE (0x3)</span>
00361     <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,    <span class="comment">// ACCESS_ALLOWED_COMPOUND_ACE_TYPE (0x4)</span>
00362     <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,    <span class="comment">// ACCESS_ALLOWED_OBJECT_ACE_TYPE (0x5)</span>
00363     <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,    <span class="comment">// ACCESS_DENIED_OBJECT_ACE_TYPE (0x6)</span>
00364     <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,     <span class="comment">// SYSTEM_AUDIT_OBJECT_ACE_TYPE (0x7)</span>
00365     <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>      <span class="comment">// SYSTEM_ALARM_OBJECT_ACE_TYPE (0x8)</span>
00366 };
00367 
<a name="l00368"></a><a class="code" href="../../d8/d6/sertl_8c.html#a9">00368</a> BOOLEAN <a class="code" href="../../d8/d6/sertl_8c.html#a9">RtlpVerboseConvert</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00369 
<a name="l00370"></a><a class="code" href="../../d8/d6/sertl_8c.html#a2">00370</a> <span class="preprocessor">#define SE_VALID_CONTROL_BITS ( SE_DACL_UNTRUSTED | \</span>
00371 <span class="preprocessor">                                SE_SERVER_SECURITY | \</span>
00372 <span class="preprocessor">                                SE_DACL_AUTO_INHERIT_REQ | \</span>
00373 <span class="preprocessor">                                SE_SACL_AUTO_INHERIT_REQ | \</span>
00374 <span class="preprocessor">                                SE_DACL_AUTO_INHERITED | \</span>
00375 <span class="preprocessor">                                SE_SACL_AUTO_INHERITED | \</span>
00376 <span class="preprocessor">                                SE_DACL_PROTECTED | \</span>
00377 <span class="preprocessor">                                SE_SACL_PROTECTED )</span>
00378 <span class="preprocessor"></span>
00379 
00381 <span class="comment">//                                                                           //</span>
00382 <span class="comment">//    Exported Procedures                                                    //</span>
00383 <span class="comment">//                                                                           //</span>
00385 <span class="comment"></span>
00386 
00387 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00388"></a><a class="code" href="../../d8/d6/sertl_8c.html#a31">00388</a> <a class="code" href="../../d8/d6/sertl_8c.html#a31">RtlRunEncodeUnicodeString</a>(
00389     PUCHAR          Seed        OPTIONAL,
00390     PUNICODE_STRING String
00391     )
00392 
00393 <span class="comment">/*++</span>
00394 <span class="comment"></span>
00395 <span class="comment">Routine Description:</span>
00396 <span class="comment"></span>
00397 <span class="comment">    This function performs a trivial XOR run-encoding of a string.</span>
00398 <span class="comment">    The purpose of this run-encoding is to change the character values</span>
00399 <span class="comment">    to appear somewhat random and typically not printable.  This is</span>
00400 <span class="comment">    useful for transforming passwords that you don't want to be easily</span>
00401 <span class="comment">    distinguishable by visually scanning a paging file or memory dump.</span>
00402 <span class="comment"></span>
00403 <span class="comment"></span>
00404 <span class="comment">Arguments:</span>
00405 <span class="comment"></span>
00406 <span class="comment">    Seed - Points to a seed value to use in the encoding.  If the</span>
00407 <span class="comment">        pointed to value is zero, then this routine will assign</span>
00408 <span class="comment">        a value.</span>
00409 <span class="comment"></span>
00410 <span class="comment">    String - The string to encode.  This string may be decode</span>
00411 <span class="comment">        by passing it and the seed value to RtlRunDecodeUnicodeString().</span>
00412 <span class="comment"></span>
00413 <span class="comment"></span>
00414 <span class="comment">Return Value:</span>
00415 <span class="comment"></span>
00416 <span class="comment">    None - Nothing can really go wrong unless the caller passes bogus</span>
00417 <span class="comment">        parameters.  In this case, the caller can catch the access</span>
00418 <span class="comment">        violation.</span>
00419 <span class="comment"></span>
00420 <span class="comment"></span>
00421 <span class="comment">--*/</span>
00422 {
00423 
00424     LARGE_INTEGER <a class="code" href="../../d6/d6/ttime_8c.html#a14">Time</a>;
00425     PUCHAR        LocalSeed;
00426     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>      <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00427     ULONG         i;
00428     PSTRING       S;
00429 
00430 
00431     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
00432 
00433     <span class="comment">//</span>
00434     <span class="comment">// Typecast so we can work on bytes rather than WCHARs</span>
00435     <span class="comment">//</span>
00436 
00437     S = (PSTRING)((PVOID)<a class="code" href="../../d4/d9/talloc_8c.html#a0">String</a>);
00438 
00439     <span class="comment">//</span>
00440     <span class="comment">// If a seed wasn't passed, use the 2nd byte of current time.</span>
00441     <span class="comment">// This byte seems to be sufficiently random (by observation).</span>
00442     <span class="comment">//</span>
00443 
00444     <span class="keywordflow">if</span> ((*Seed) == 0) {
00445         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = NtQuerySystemTime ( &amp;<a class="code" href="../../d6/d6/ttime_8c.html#a14">Time</a> );
00446         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>));
00447 
00448         LocalSeed = (PUCHAR)((PVOID)&amp;<a class="code" href="../../d6/d6/ttime_8c.html#a14">Time</a>);
00449 
00450         i = 1;
00451 
00452         (*Seed) = LocalSeed[ i ];
00453 
00454         <span class="comment">//</span>
00455         <span class="comment">// Occasionally, this byte could be zero.  That would cause the</span>
00456         <span class="comment">// string to become un-decodable, since 0 is the magic value that</span>
00457         <span class="comment">// causes us to re-gen the seed.  This loop makes sure that we</span>
00458         <span class="comment">// never end up with a zero byte (unless time is zero, as well).</span>
00459         <span class="comment">//</span>
00460 
00461         <span class="keywordflow">while</span> ( ((*Seed) == 0) &amp;&amp; ( i &lt; <span class="keyword">sizeof</span>( <a class="code" href="../../d6/d6/ttime_8c.html#a14">Time</a> ) ) )
00462         {
00463             (*Seed) |= LocalSeed[ i++ ] ;
00464         }
00465 
00466         <span class="keywordflow">if</span> ( (*Seed) == 0 )
00467         {
00468             (*Seed) = 1;
00469         }
00470     }
00471 
00472     <span class="comment">//</span>
00473     <span class="comment">// Transform the initial byte.</span>
00474     <span class="comment">// The funny constant just keeps the first byte from propagating</span>
00475     <span class="comment">// into the second byte in the next step.  Without a funny constant</span>
00476     <span class="comment">// this would happen for many languages (which typically have every</span>
00477     <span class="comment">// other byte zero.</span>
00478     <span class="comment">//</span>
00479     <span class="comment">//</span>
00480 
00481     <span class="keywordflow">if</span> (S-&gt;Length &gt;= 1) {
00482         S-&gt;Buffer[0] ^= ((*Seed) | 0X43);
00483     }
00484 
00485 
00486     <span class="comment">//</span>
00487     <span class="comment">// Now transform the rest of the string</span>
00488     <span class="comment">//</span>
00489 
00490     <span class="keywordflow">for</span> (i=1; i&lt;S-&gt;Length; i++) {
00491 
00492         <span class="comment">//</span>
00493         <span class="comment">//  There are export issues that cause us to want to</span>
00494         <span class="comment">//  keep this algorithm simple.  Please don't change it</span>
00495         <span class="comment">//  without checking with JimK first.  Thanks.</span>
00496         <span class="comment">//</span>
00497 
00498         <span class="comment">//</span>
00499         <span class="comment">// In order to be compatible with zero terminated unicode strings,</span>
00500         <span class="comment">//  this algorithm is designed to not produce a wide character of</span>
00501         <span class="comment">//  zero as long a the seed is not zero.</span>
00502         <span class="comment">//</span>
00503 
00504         <span class="comment">//</span>
00505         <span class="comment">// Simple running XOR with the previous byte and the</span>
00506         <span class="comment">// seed value.</span>
00507         <span class="comment">//</span>
00508 
00509         S-&gt;Buffer[i] ^= (S-&gt;Buffer[i-1]^(*Seed));
00510 
00511     }
00512 
00513 
00514     <span class="keywordflow">return</span>;
00515 
00516 }
00517 
00518 
00519 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00520"></a><a class="code" href="../../d8/d6/sertl_8c.html#a32">00520</a> <a class="code" href="../../d8/d6/sertl_8c.html#a32">RtlRunDecodeUnicodeString</a>(
00521     UCHAR           Seed,
00522     PUNICODE_STRING String
00523     )
00524 <span class="comment">/*++</span>
00525 <span class="comment"></span>
00526 <span class="comment">Routine Description:</span>
00527 <span class="comment"></span>
00528 <span class="comment">    This function performs the inverse of the function performed</span>
00529 <span class="comment">    by RtlRunEncodeUnicodeString().  Please see RtlRunEncodeUnicodeString()</span>
00530 <span class="comment">    for details.</span>
00531 <span class="comment"></span>
00532 <span class="comment"></span>
00533 <span class="comment">Arguments:</span>
00534 <span class="comment"></span>
00535 <span class="comment">    Seed - The seed value to use in RtlRunEncodeUnicodeString().</span>
00536 <span class="comment"></span>
00537 <span class="comment">    String - The string to reveal.</span>
00538 <span class="comment"></span>
00539 <span class="comment"></span>
00540 <span class="comment">Return Value:</span>
00541 <span class="comment"></span>
00542 <span class="comment">    None - Nothing can really go wrong unless the caller passes bogus</span>
00543 <span class="comment">        parameters.  In this case, the caller can catch the access</span>
00544 <span class="comment">        violation.</span>
00545 <span class="comment"></span>
00546 <span class="comment"></span>
00547 <span class="comment">--*/</span>
00548 
00549 {
00550 
00551     ULONG
00552         i;
00553 
00554     PSTRING
00555         S;
00556 
00557     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
00558 
00559     <span class="comment">//</span>
00560     <span class="comment">// Typecast so we can work on bytes rather than WCHARs</span>
00561     <span class="comment">//</span>
00562 
00563     S = (PSTRING)((PVOID)<a class="code" href="../../d4/d9/talloc_8c.html#a0">String</a>);
00564 
00565 
00566     <span class="comment">//</span>
00567     <span class="comment">// Transform the end of the string</span>
00568     <span class="comment">//</span>
00569 
00570     <span class="keywordflow">for</span> (i=S-&gt;Length; i&gt;1; i--) {
00571 
00572         <span class="comment">//</span>
00573         <span class="comment">// a simple running XOR with the previous byte and the</span>
00574         <span class="comment">// seed value.</span>
00575         <span class="comment">//</span>
00576 
00577         S-&gt;Buffer[i-1] ^= (S-&gt;Buffer[i-2]^<a class="code" href="../../d4/d4/tprefix_8c.html#a2">Seed</a>);
00578 
00579     }
00580 
00581     <span class="comment">//</span>
00582     <span class="comment">// Finally, transform the initial byte</span>
00583     <span class="comment">//</span>
00584 
00585     <span class="keywordflow">if</span> (S-&gt;Length &gt;= 1) {
00586         S-&gt;Buffer[0] ^= (<a class="code" href="../../d4/d4/tprefix_8c.html#a2">Seed</a> | 0X43);
00587     }
00588 
00589 
00590     <span class="keywordflow">return</span>;
00591 }
00592 
00593 
00594 
00595 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00596"></a><a class="code" href="../../d8/d6/sertl_8c.html#a33">00596</a> <a class="code" href="../../d8/d6/sertl_8c.html#a33">RtlEraseUnicodeString</a>(
00597     PUNICODE_STRING String
00598     )
00599 <span class="comment">/*++</span>
00600 <span class="comment"></span>
00601 <span class="comment">Routine Description:</span>
00602 <span class="comment"></span>
00603 <span class="comment">    This function scrubs the passed string by over-writing all</span>
00604 <span class="comment">    characters in the string.  The entire string (i.e., MaximumLength)</span>
00605 <span class="comment">    is erased, not just the current length.</span>
00606 <span class="comment"></span>
00607 <span class="comment"></span>
00608 <span class="comment">Argumen ts:</span>
00609 <span class="comment"></span>
00610 <span class="comment">    String - The string to be erased.</span>
00611 <span class="comment"></span>
00612 <span class="comment"></span>
00613 <span class="comment">Return Value:</span>
00614 <span class="comment"></span>
00615 <span class="comment">    None - Nothing can really go wrong unless the caller passes bogus</span>
00616 <span class="comment">        parameters.  In this case, the caller can catch the access</span>
00617 <span class="comment">        violation.</span>
00618 <span class="comment"></span>
00619 <span class="comment"></span>
00620 <span class="comment">--*/</span>
00621 
00622 {
00623     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
00624 
00625     <span class="keywordflow">if</span> ((<a class="code" href="../../d4/d9/talloc_8c.html#a0">String</a>-&gt;Buffer == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) || (<a class="code" href="../../d4/d9/talloc_8c.html#a0">String</a>-&gt;MaximumLength == 0)) {
00626         <span class="keywordflow">return</span>;
00627     }
00628 
00629     RtlZeroMemory( (PVOID)<a class="code" href="../../d4/d9/talloc_8c.html#a0">String</a>-&gt;Buffer, (ULONG)<a class="code" href="../../d4/d9/talloc_8c.html#a0">String</a>-&gt;MaximumLength );
00630 
00631     <a class="code" href="../../d4/d9/talloc_8c.html#a0">String</a>-&gt;Length = 0;
00632 
00633     <span class="keywordflow">return</span>;
00634 }
00635 
00636 
00637 
00638 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00639"></a><a class="code" href="../../d8/d6/sertl_8c.html#a34">00639</a> <a class="code" href="../../d8/d6/sertl_8c.html#a34">RtlAdjustPrivilege</a>(
00640     ULONG Privilege,
00641     BOOLEAN Enable,
00642     BOOLEAN Client,
00643     PBOOLEAN WasEnabled
00644     )
00645 
00646 <span class="comment">/*++</span>
00647 <span class="comment"></span>
00648 <span class="comment">Routine Description:</span>
00649 <span class="comment"></span>
00650 <span class="comment">    This procedure enables or disables a privilege process-wide.</span>
00651 <span class="comment"></span>
00652 <span class="comment">Arguments:</span>
00653 <span class="comment"></span>
00654 <span class="comment">    Privilege - The lower 32-bits of the privilege ID to be enabled or</span>
00655 <span class="comment">        disabled.  The upper 32-bits is assumed to be zero.</span>
00656 <span class="comment"></span>
00657 <span class="comment">    Enable - A boolean indicating whether the privilege is to be enabled</span>
00658 <span class="comment">        or disabled.  TRUE indicates the privilege is to be enabled.</span>
00659 <span class="comment">        FALSE indicates the privilege is to be disabled.</span>
00660 <span class="comment"></span>
00661 <span class="comment">    Client - A boolean indicating whether the privilege should be adjusted</span>
00662 <span class="comment">        in a client token or the process's own token.   TRUE indicates</span>
00663 <span class="comment">        the client's token should be used (and an error returned if there</span>
00664 <span class="comment">        is no client token).  FALSE indicates the process's token should</span>
00665 <span class="comment">        be used.</span>
00666 <span class="comment"></span>
00667 <span class="comment">    WasEnabled - points to a boolean to receive an indication of whether</span>
00668 <span class="comment">        the privilege was previously enabled or disabled.  TRUE indicates</span>
00669 <span class="comment">        the privilege was previously enabled.  FALSE indicates the privilege</span>
00670 <span class="comment">        was previoulsy disabled.  This value is useful for returning the</span>
00671 <span class="comment">        privilege to its original state after using it.</span>
00672 <span class="comment"></span>
00673 <span class="comment"></span>
00674 <span class="comment">Return Value:</span>
00675 <span class="comment"></span>
00676 <span class="comment">    STATUS_SUCCESS - The privilege has been sucessfully enabled or disabled.</span>
00677 <span class="comment"></span>
00678 <span class="comment">    STATUS_PRIVILEGE_NOT_HELD - The privilege is not held by the specified context.</span>
00679 <span class="comment"></span>
00680 <span class="comment">    Other status values as may be returned by:</span>
00681 <span class="comment"></span>
00682 <span class="comment">            NtOpenProcessToken()</span>
00683 <span class="comment">            NtAdjustPrivilegesToken()</span>
00684 <span class="comment"></span>
00685 <span class="comment"></span>
00686 <span class="comment">--*/</span>
00687 
00688 {
00689     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00690         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>,
00691         TmpStatus;
00692 
00693     HANDLE
00694         <a class="code" href="../../d6/d0/ctaccess_8c.html#a29">Token</a>;
00695 
00696     LUID
00697         LuidPrivilege;
00698 
00699     PTOKEN_PRIVILEGES
00700         NewPrivileges,
00701         OldPrivileges;
00702 
00703     ULONG
00704         Length;
00705 
00706     UCHAR
00707         <a class="code" href="../../d9/d0/tfilmem_8c.html#a1">Buffer1</a>[<span class="keyword">sizeof</span>(TOKEN_PRIVILEGES)+
00708                 ((1-<a class="code" href="../../d5/d4/acpitabl_8h.html#a44">ANYSIZE_ARRAY</a>)*<span class="keyword">sizeof</span>(LUID_AND_ATTRIBUTES))],
00709         <a class="code" href="../../d9/d0/tfilmem_8c.html#a2">Buffer2</a>[<span class="keyword">sizeof</span>(TOKEN_PRIVILEGES)+
00710                 ((1-<a class="code" href="../../d5/d4/acpitabl_8h.html#a44">ANYSIZE_ARRAY</a>)*<span class="keyword">sizeof</span>(LUID_AND_ATTRIBUTES))];
00711 
00712 
00713     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
00714 
00715     NewPrivileges = (PTOKEN_PRIVILEGES)<a class="code" href="../../d9/d0/tfilmem_8c.html#a1">Buffer1</a>;
00716     OldPrivileges = (PTOKEN_PRIVILEGES)<a class="code" href="../../d9/d0/tfilmem_8c.html#a2">Buffer2</a>;
00717 
00718     <span class="comment">//</span>
00719     <span class="comment">// Open the appropriate token...</span>
00720     <span class="comment">//</span>
00721 
00722     <span class="keywordflow">if</span> (Client == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
00723         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d7/d3/tokenopn_8c.html#a3">NtOpenThreadToken</a>(
00724                      NtCurrentThread(),
00725                      TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
00726                      <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00727                      &amp;<a class="code" href="../../d6/d0/ctaccess_8c.html#a29">Token</a>
00728                      );
00729     } <span class="keywordflow">else</span> {
00730 
00731         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d7/d3/tokenopn_8c.html#a1">NtOpenProcessToken</a>(
00732                      NtCurrentProcess(),
00733                      TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
00734                      &amp;<a class="code" href="../../d6/d0/ctaccess_8c.html#a29">Token</a>
00735                     );
00736     }
00737 
00738     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
00739         <span class="keywordflow">return</span>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>);
00740     }
00741 
00742 
00743 
00744     <span class="comment">//</span>
00745     <span class="comment">// Initialize the privilege adjustment structure</span>
00746     <span class="comment">//</span>
00747 
00748     LuidPrivilege = RtlConvertUlongToLuid(Privilege);
00749 
00750 
00751     NewPrivileges-&gt;PrivilegeCount = 1;
00752     NewPrivileges-&gt;Privileges[0].Luid = LuidPrivilege;
00753     NewPrivileges-&gt;Privileges[0].Attributes = Enable ? SE_PRIVILEGE_ENABLED : 0;
00754 
00755 
00756 
00757     <span class="comment">//</span>
00758     <span class="comment">// Adjust the privilege</span>
00759     <span class="comment">//</span>
00760 
00761     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d5/d3/tokenadj_8c.html#a0">NtAdjustPrivilegesToken</a>(
00762                  <a class="code" href="../../d6/d0/ctaccess_8c.html#a29">Token</a>,                     <span class="comment">// TokenHandle</span>
00763                  <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,                     <span class="comment">// DisableAllPrivileges</span>
00764                  NewPrivileges,             <span class="comment">// NewPrivileges</span>
00765                  <span class="keyword">sizeof</span>(<a class="code" href="../../d9/d0/tfilmem_8c.html#a1">Buffer1</a>),           <span class="comment">// BufferLength</span>
00766                  OldPrivileges,             <span class="comment">// PreviousState (OPTIONAL)</span>
00767                  &amp;Length                    <span class="comment">// ReturnLength</span>
00768                  );
00769 
00770 
00771     TmpStatus = <a class="code" href="../../d5/d0/obclose_8c.html#a1">NtClose</a>(<a class="code" href="../../d6/d0/ctaccess_8c.html#a29">Token</a>);
00772     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(TmpStatus));
00773 
00774 
00775     <span class="comment">//</span>
00776     <span class="comment">// Map the success code NOT_ALL_ASSIGNED to an appropriate error</span>
00777     <span class="comment">// since we're only trying to adjust the one privilege.</span>
00778     <span class="comment">//</span>
00779 
00780     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_NOT_ALL_ASSIGNED) {
00781         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_PRIVILEGE_NOT_HELD;
00782     }
00783 
00784 
00785     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
00786 
00787         <span class="comment">//</span>
00788         <span class="comment">// If there are no privileges in the previous state, there were</span>
00789         <span class="comment">// no changes made. The previous state of the privilege</span>
00790         <span class="comment">// is whatever we tried to change it to.</span>
00791         <span class="comment">//</span>
00792 
00793         <span class="keywordflow">if</span> (OldPrivileges-&gt;PrivilegeCount == 0) {
00794 
00795             (*WasEnabled) = Enable;
00796 
00797         } <span class="keywordflow">else</span> {
00798 
00799             (*WasEnabled) =
00800                 (OldPrivileges-&gt;Privileges[0].Attributes &amp; SE_PRIVILEGE_ENABLED)
00801                 ? <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> : <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00802         }
00803     }
00804 
00805     <span class="keywordflow">return</span>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>);
00806 }
00807 
00808 
00809 BOOLEAN
<a name="l00810"></a><a class="code" href="../../d8/d6/sertl_8c.html#a35">00810</a> <a class="code" href="../../d8/d6/sertl_8c.html#a35">RtlValidSid</a> (
00811     IN PSID Sid
00812     )
00813 
00814 <span class="comment">/*++</span>
00815 <span class="comment"></span>
00816 <span class="comment">Routine Description:</span>
00817 <span class="comment"></span>
00818 <span class="comment">    This procedure validates an SID's structure.</span>
00819 <span class="comment"></span>
00820 <span class="comment">Arguments:</span>
00821 <span class="comment"></span>
00822 <span class="comment">    Sid - Pointer to the SID structure to validate.</span>
00823 <span class="comment"></span>
00824 <span class="comment">Return Value:</span>
00825 <span class="comment"></span>
00826 <span class="comment">    BOOLEAN - TRUE if the structure of Sid is valid.</span>
00827 <span class="comment"></span>
00828 <span class="comment">--*/</span>
00829 
00830 {
00831     PISID Isid = (PISID) Sid;
00832     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
00833     <span class="comment">//</span>
00834     <span class="comment">// Make sure revision is SID_REVISION and sub authority count is not</span>
00835     <span class="comment">// greater than maximum number of allowed sub-authorities.</span>
00836     <span class="comment">//</span>
00837 
00838     <span class="keywordflow">try</span> {
00839 
00840         <span class="keywordflow">if</span> ( Isid != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> &amp;&amp; (Isid-&gt;Revision &amp; 0x0f) == SID_REVISION) {
00841             <span class="keywordflow">if</span> (Isid-&gt;SubAuthorityCount &lt;= SID_MAX_SUB_AUTHORITIES) {
00842 
00843                 <span class="comment">//</span>
00844                 <span class="comment">// Verify the memory actually contains the last subauthority</span>
00845                 <span class="comment">//</span>
00846 <span class="preprocessor">#ifndef NTOS_KERNEL_RUNTIME</span>
00847 <span class="preprocessor"></span><span class="preprocessor">#define ProbeAndReadUlongUM(Address) \</span>
00848 <span class="preprocessor">        (*(volatile ULONG *)(Address))</span>
00849 <span class="preprocessor"></span>
00850                 <span class="keywordflow">if</span> (Isid-&gt;SubAuthorityCount &gt; 0) {
00851                     <a class="code" href="../../d8/d6/sertl_8c.html#a3">ProbeAndReadUlongUM</a>(
00852                         &amp;Isid-&gt;SubAuthority[Isid-&gt;SubAuthorityCount-1]
00853                         );
00854                 }
00855 <span class="preprocessor">#endif // !NTOS_KERNEL_RUNTIME</span>
00856 <span class="preprocessor"></span>                <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00857           }
00858         }
00859 
00860     } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
00861         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00862     }
00863 
00864     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00865 
00866 }
00867 
00868 
00869 
00870 BOOLEAN
<a name="l00871"></a><a class="code" href="../../d8/d6/sertl_8c.html#a36">00871</a> <a class="code" href="../../d8/d6/sertl_8c.html#a36">RtlEqualSid</a> (
00872     IN PSID Sid1,
00873     IN PSID Sid2
00874     )
00875 
00876 <span class="comment">/*++</span>
00877 <span class="comment"></span>
00878 <span class="comment">Routine Description:</span>
00879 <span class="comment"></span>
00880 <span class="comment">    This procedure tests two SID values for equality.</span>
00881 <span class="comment"></span>
00882 <span class="comment">Arguments:</span>
00883 <span class="comment"></span>
00884 <span class="comment">    Sid1, Sid2 - Supply pointers to the two SID values to compare.</span>
00885 <span class="comment">        The SID structures are assumed to be valid.</span>
00886 <span class="comment"></span>
00887 <span class="comment">Return Value:</span>
00888 <span class="comment"></span>
00889 <span class="comment">    BOOLEAN - TRUE if the value of Sid1 is equal to Sid2, and FALSE</span>
00890 <span class="comment">        otherwise.</span>
00891 <span class="comment"></span>
00892 <span class="comment">--*/</span>
00893 
00894 {
00895    ULONG SidLength;
00896 
00897    <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
00898 
00899    <span class="comment">//</span>
00900    <span class="comment">// Make sure they are the same revision</span>
00901    <span class="comment">//</span>
00902 
00903    <span class="keywordflow">if</span> ( ((SID *)Sid1)-&gt;Revision == ((SID *)Sid2)-&gt;Revision ) {
00904 
00905        <span class="comment">//</span>
00906        <span class="comment">// Check the SubAuthorityCount first, because it's fast and</span>
00907        <span class="comment">// can help us exit faster.</span>
00908        <span class="comment">//</span>
00909 
00910        <span class="keywordflow">if</span> ( *<a class="code" href="../../d8/d6/sertl_8c.html#a44">RtlSubAuthorityCountSid</a>( Sid1 ) == *<a class="code" href="../../d8/d6/sertl_8c.html#a44">RtlSubAuthorityCountSid</a>( Sid2 )) {
00911 
00912            SidLength = <a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>( Sid1 );
00913            <span class="keywordflow">return</span>( (BOOLEAN)RtlEqualMemory( Sid1, Sid2, SidLength) );
00914        }
00915    }
00916 
00917    <span class="keywordflow">return</span>( <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00918 
00919 }
00920 
00921 
00922 
00923 BOOLEAN
<a name="l00924"></a><a class="code" href="../../d8/d6/sertl_8c.html#a37">00924</a> <a class="code" href="../../d8/d6/sertl_8c.html#a37">RtlEqualPrefixSid</a> (
00925     IN PSID Sid1,
00926     IN PSID Sid2
00927     )
00928 
00929 <span class="comment">/*++</span>
00930 <span class="comment"></span>
00931 <span class="comment">Routine Description:</span>
00932 <span class="comment"></span>
00933 <span class="comment">    This procedure tests two SID prefix values for equality.</span>
00934 <span class="comment"></span>
00935 <span class="comment">    An SID prefix is the entire SID except for the last sub-authority</span>
00936 <span class="comment">    value.</span>
00937 <span class="comment"></span>
00938 <span class="comment">Arguments:</span>
00939 <span class="comment"></span>
00940 <span class="comment">    Sid1, Sid2 - Supply pointers to the two SID values to compare.</span>
00941 <span class="comment">        The SID structures are assumed to be valid.</span>
00942 <span class="comment"></span>
00943 <span class="comment">Return Value:</span>
00944 <span class="comment"></span>
00945 <span class="comment">    BOOLEAN - TRUE if the prefix value of Sid1 is equal to Sid2, and FALSE</span>
00946 <span class="comment">        otherwise.</span>
00947 <span class="comment"></span>
00948 <span class="comment">--*/</span>
00949 
00950 
00951 {
00952     LONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
00953 
00954     <span class="comment">//</span>
00955     <span class="comment">// Typecast to the opaque SID structures.</span>
00956     <span class="comment">//</span>
00957 
00958     SID *ISid1 = Sid1;
00959     SID *ISid2 = Sid2;
00960 
00961     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
00962 
00963     <span class="comment">//</span>
00964     <span class="comment">// Make sure they are the same revision</span>
00965     <span class="comment">//</span>
00966 
00967     <span class="keywordflow">if</span> (ISid1-&gt;Revision == ISid2-&gt;Revision ) {
00968 
00969         <span class="comment">//</span>
00970         <span class="comment">// Compare IdentifierAuthority values</span>
00971         <span class="comment">//</span>
00972 
00973         <span class="keywordflow">if</span> ( (ISid1-&gt;IdentifierAuthority.Value[0] ==
00974               ISid2-&gt;IdentifierAuthority.Value[0])  &amp;&amp;
00975              (ISid1-&gt;IdentifierAuthority.Value[1]==
00976               ISid2-&gt;IdentifierAuthority.Value[1])  &amp;&amp;
00977              (ISid1-&gt;IdentifierAuthority.Value[2] ==
00978               ISid2-&gt;IdentifierAuthority.Value[2])  &amp;&amp;
00979              (ISid1-&gt;IdentifierAuthority.Value[3] ==
00980               ISid2-&gt;IdentifierAuthority.Value[3])  &amp;&amp;
00981              (ISid1-&gt;IdentifierAuthority.Value[4] ==
00982               ISid2-&gt;IdentifierAuthority.Value[4])  &amp;&amp;
00983              (ISid1-&gt;IdentifierAuthority.Value[5] ==
00984               ISid2-&gt;IdentifierAuthority.Value[5])
00985             ) {
00986 
00987             <span class="comment">//</span>
00988             <span class="comment">// Compare SubAuthorityCount values</span>
00989             <span class="comment">//</span>
00990 
00991             <span class="keywordflow">if</span> (ISid1-&gt;SubAuthorityCount == ISid2-&gt;SubAuthorityCount) {
00992 
00993                 <span class="keywordflow">if</span> (ISid1-&gt;SubAuthorityCount == 0) {
00994                     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00995                 }
00996 
00997                 <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = 0;
00998                 <span class="keywordflow">while</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &lt; (ISid1-&gt;SubAuthorityCount - 1)) {
00999                     <span class="keywordflow">if</span> ((ISid1-&gt;SubAuthority[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>]) != (ISid2-&gt;SubAuthority[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>])) {
01000 
01001                         <span class="comment">//</span>
01002                         <span class="comment">// Found some SubAuthority values that weren't equal.</span>
01003                         <span class="comment">//</span>
01004 
01005                         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01006                     }
01007                     <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> += 1;
01008                 }
01009 
01010                 <span class="comment">//</span>
01011                 <span class="comment">// All SubAuthority values are equal.</span>
01012                 <span class="comment">//</span>
01013 
01014                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01015             }
01016         }
01017     }
01018 
01019     <span class="comment">//</span>
01020     <span class="comment">// Either the Revision, SubAuthorityCount, or IdentifierAuthority values</span>
01021     <span class="comment">// weren't equal.</span>
01022     <span class="comment">//</span>
01023 
01024     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01025 }
01026 
01027 
01028 
01029 ULONG
<a name="l01030"></a><a class="code" href="../../d8/d6/sertl_8c.html#a38">01030</a> <a class="code" href="../../d8/d6/sertl_8c.html#a38">RtlLengthRequiredSid</a> (
01031     IN ULONG SubAuthorityCount
01032     )
01033 
01034 <span class="comment">/*++</span>
01035 <span class="comment"></span>
01036 <span class="comment">Routine Description:</span>
01037 <span class="comment"></span>
01038 <span class="comment">    This routine returns the length, in bytes, required to store an SID</span>
01039 <span class="comment">    with the specified number of Sub-Authorities.</span>
01040 <span class="comment"></span>
01041 <span class="comment">Arguments:</span>
01042 <span class="comment"></span>
01043 <span class="comment">    SubAuthorityCount - The number of sub-authorities to be stored in the SID.</span>
01044 <span class="comment"></span>
01045 <span class="comment">Return Value:</span>
01046 <span class="comment"></span>
01047 <span class="comment">    ULONG - The length, in bytes, required to store the SID.</span>
01048 <span class="comment"></span>
01049 <span class="comment"></span>
01050 <span class="comment">--*/</span>
01051 
01052 {
01053     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
01054 
01055     <span class="keywordflow">return</span> (8<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a> + (4 * SubAuthorityCount));
01056 
01057 }
01058 
01059 <span class="preprocessor">#ifndef NTOS_KERNEL_RUNTIME</span>
01060 <span class="preprocessor"></span>
01061 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l01062"></a><a class="code" href="../../d8/d6/sertl_8c.html#a39">01062</a> <a class="code" href="../../d8/d6/sertl_8c.html#a39">RtlAllocateAndInitializeSid</a>(
01063     IN PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
01064     IN UCHAR SubAuthorityCount,
01065     IN ULONG SubAuthority0,
01066     IN ULONG SubAuthority1,
01067     IN ULONG SubAuthority2,
01068     IN ULONG SubAuthority3,
01069     IN ULONG SubAuthority4,
01070     IN ULONG SubAuthority5,
01071     IN ULONG SubAuthority6,
01072     IN ULONG SubAuthority7,
01073     OUT PSID *Sid
01074     )
01075 
01076 <span class="comment">/*++</span>
01077 <span class="comment"></span>
01078 <span class="comment">Routine Description:</span>
01079 <span class="comment"></span>
01080 <span class="comment">    This function allocates and initializes a sid with the specified</span>
01081 <span class="comment">    number of sub-authorities (up to 8).  A sid allocated with this</span>
01082 <span class="comment">    routine must be freed using RtlFreeSid().</span>
01083 <span class="comment"></span>
01084 <span class="comment">    THIS ROUTINE IS CURRENTLY NOT CALLABLE FROM KERNEL MODE.</span>
01085 <span class="comment"></span>
01086 <span class="comment">Arguments:</span>
01087 <span class="comment"></span>
01088 <span class="comment">    IdentifierAuthority - Pointer to the Identifier Authority value to</span>
01089 <span class="comment">        set in the SID.</span>
01090 <span class="comment"></span>
01091 <span class="comment">    SubAuthorityCount - The number of sub-authorities to place in the SID.</span>
01092 <span class="comment">        This also identifies how many of the SubAuthorityN parameters</span>
01093 <span class="comment">        have meaningful values.  This must contain a value from 0 through</span>
01094 <span class="comment">        8.</span>
01095 <span class="comment"></span>
01096 <span class="comment">    SubAuthority0-7 - Provides the corresponding sub-authority value to</span>
01097 <span class="comment">        place in the SID.  For example, a SubAuthorityCount value of 3</span>
01098 <span class="comment">        indicates that SubAuthority0, SubAuthority1, and SubAuthority0</span>
01099 <span class="comment">        have meaningful values and the rest are to be ignored.</span>
01100 <span class="comment"></span>
01101 <span class="comment">    Sid - Receives a pointer to the SID data structure to initialize.</span>
01102 <span class="comment"></span>
01103 <span class="comment">Return Value:</span>
01104 <span class="comment"></span>
01105 <span class="comment">    STATUS_SUCCESS - The SID has been allocated and initialized.</span>
01106 <span class="comment"></span>
01107 <span class="comment">    STATUS_NO_MEMORY - The attempt to allocate memory for the SID</span>
01108 <span class="comment">        failed.</span>
01109 <span class="comment"></span>
01110 <span class="comment">    STATUS_INVALID_SID - The number of sub-authorities specified did</span>
01111 <span class="comment">        not fall in the valid range for this api (0 through 8).</span>
01112 <span class="comment"></span>
01113 <span class="comment"></span>
01114 <span class="comment">--*/</span>
01115 {
01116     PISID ISid;
01117 
01118     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
01119 
01120     <span class="keywordflow">if</span> ( SubAuthorityCount &gt; 8 ) {
01121         <span class="keywordflow">return</span>( STATUS_INVALID_SID );
01122     }
01123 
01124     ISid = <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a0">RtlAllocateHeap</a>( RtlProcessHeap(), 0,
01125                             <a class="code" href="../../d8/d6/sertl_8c.html#a38">RtlLengthRequiredSid</a>(SubAuthorityCount)
01126                             );
01127     <span class="keywordflow">if</span> (ISid == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01128         <span class="keywordflow">return</span>(STATUS_NO_MEMORY);
01129     }
01130 
01131     ISid-&gt;SubAuthorityCount = (UCHAR)SubAuthorityCount;
01132     ISid-&gt;Revision = 1;
01133     ISid-&gt;IdentifierAuthority = *IdentifierAuthority;
01134 
01135     <span class="keywordflow">switch</span> (SubAuthorityCount) {
01136 
01137     <span class="keywordflow">case</span> 8:
01138         ISid-&gt;SubAuthority[7] = SubAuthority7;
01139     <span class="keywordflow">case</span> 7:
01140         ISid-&gt;SubAuthority[6] = SubAuthority6;
01141     <span class="keywordflow">case</span> 6:
01142         ISid-&gt;SubAuthority[5] = SubAuthority5;
01143     <span class="keywordflow">case</span> 5:
01144         ISid-&gt;SubAuthority[4] = SubAuthority4;
01145     <span class="keywordflow">case</span> 4:
01146         ISid-&gt;SubAuthority[3] = SubAuthority3;
01147     <span class="keywordflow">case</span> 3:
01148         ISid-&gt;SubAuthority[2] = SubAuthority2;
01149     <span class="keywordflow">case</span> 2:
01150         ISid-&gt;SubAuthority[1] = SubAuthority1;
01151     <span class="keywordflow">case</span> 1:
01152         ISid-&gt;SubAuthority[0] = SubAuthority0;
01153     <span class="keywordflow">case</span> 0:
01154         ;
01155     }
01156 
01157     (*Sid) = ISid;
01158     <span class="keywordflow">return</span>( STATUS_SUCCESS );
01159 
01160 }
01161 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
01162 <span class="preprocessor"></span>
01163 
01164 
01165 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l01166"></a><a class="code" href="../../d8/d6/sertl_8c.html#a40">01166</a> <a class="code" href="../../d8/d6/sertl_8c.html#a40">RtlInitializeSid</a>(
01167     IN PSID Sid,
01168     IN PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
01169     IN UCHAR SubAuthorityCount
01170     )
01171 <span class="comment">/*++</span>
01172 <span class="comment"></span>
01173 <span class="comment">Routine Description:</span>
01174 <span class="comment"></span>
01175 <span class="comment">    This function initializes an SID data structure.  It does not, however,</span>
01176 <span class="comment">    set the sub-authority values.  This must be done separately.</span>
01177 <span class="comment"></span>
01178 <span class="comment">Arguments:</span>
01179 <span class="comment"></span>
01180 <span class="comment">    Sid - Pointer to the SID data structure to initialize.</span>
01181 <span class="comment"></span>
01182 <span class="comment">    IdentifierAuthority - Pointer to the Identifier Authority value to</span>
01183 <span class="comment">        set in the SID.</span>
01184 <span class="comment"></span>
01185 <span class="comment">    SubAuthorityCount - The number of sub-authorities that will be placed in</span>
01186 <span class="comment">        the SID (a separate action).</span>
01187 <span class="comment"></span>
01188 <span class="comment">Return Value:</span>
01189 <span class="comment"></span>
01190 <span class="comment"></span>
01191 <span class="comment">--*/</span>
01192 {
01193     PISID ISid;
01194 
01195     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
01196 
01197     <span class="comment">//</span>
01198     <span class="comment">//  Typecast to the opaque SID</span>
01199     <span class="comment">//</span>
01200 
01201     ISid = (PISID)Sid;
01202 
01203     <span class="keywordflow">if</span> ( SubAuthorityCount &gt; SID_MAX_SUB_AUTHORITIES ) {
01204         <span class="keywordflow">return</span>( STATUS_INVALID_PARAMETER );
01205     }
01206 
01207     ISid-&gt;SubAuthorityCount = (UCHAR)SubAuthorityCount;
01208     ISid-&gt;Revision = 1;
01209     ISid-&gt;IdentifierAuthority = *IdentifierAuthority;
01210 
01211     <span class="keywordflow">return</span>( STATUS_SUCCESS );
01212 
01213 }
01214 
01215 <span class="preprocessor">#ifndef NTOS_KERNEL_RUNTIME</span>
01216 <span class="preprocessor"></span>
01217 PVOID
<a name="l01218"></a><a class="code" href="../../d8/d6/sertl_8c.html#a41">01218</a> <a class="code" href="../../d8/d6/sertl_8c.html#a41">RtlFreeSid</a>(
01219     IN PSID Sid
01220     )
01221 
01222 <span class="comment">/*++</span>
01223 <span class="comment"></span>
01224 <span class="comment">Routine Description:</span>
01225 <span class="comment"></span>
01226 <span class="comment">    This function is used to free a SID previously allocated using</span>
01227 <span class="comment">    RtlAllocateAndInitializeSid().</span>
01228 <span class="comment"></span>
01229 <span class="comment">    THIS ROUTINE IS CURRENTLY NOT CALLABLE FROM KERNEL MODE.</span>
01230 <span class="comment"></span>
01231 <span class="comment">Arguments:</span>
01232 <span class="comment"></span>
01233 <span class="comment">    Sid - Pointer to the SID to free.</span>
01234 <span class="comment"></span>
01235 <span class="comment">Return Value:</span>
01236 <span class="comment"></span>
01237 <span class="comment">    None.</span>
01238 <span class="comment"></span>
01239 <span class="comment"></span>
01240 <span class="comment">--*/</span>
01241 {
01242     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
01243 
01244     <span class="keywordflow">if</span> (<a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>( RtlProcessHeap(), 0, Sid ))
01245         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01246     <span class="keywordflow">else</span>
01247         <span class="keywordflow">return</span> Sid;
01248 }
01249 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
01250 <span class="preprocessor"></span>
01251 
01252 PSID_IDENTIFIER_AUTHORITY
<a name="l01253"></a><a class="code" href="../../d8/d6/sertl_8c.html#a42">01253</a> <a class="code" href="../../d8/d6/sertl_8c.html#a42">RtlIdentifierAuthoritySid</a>(
01254     IN PSID Sid
01255     )
01256 <span class="comment">/*++</span>
01257 <span class="comment"></span>
01258 <span class="comment">Routine Description:</span>
01259 <span class="comment"></span>
01260 <span class="comment">    This function returns the address of an SID's IdentifierAuthority field.</span>
01261 <span class="comment"></span>
01262 <span class="comment">Arguments:</span>
01263 <span class="comment"></span>
01264 <span class="comment">    Sid - Pointer to the SID data structure.</span>
01265 <span class="comment"></span>
01266 <span class="comment">Return Value:</span>
01267 <span class="comment"></span>
01268 <span class="comment"></span>
01269 <span class="comment">--*/</span>
01270 {
01271     PISID ISid;
01272 
01273     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
01274 
01275     <span class="comment">//</span>
01276     <span class="comment">//  Typecast to the opaque SID</span>
01277     <span class="comment">//</span>
01278 
01279     ISid = (PISID)Sid;
01280 
01281     <span class="keywordflow">return</span> &amp;(ISid-&gt;IdentifierAuthority);
01282 
01283 }
01284 
01285 PULONG
<a name="l01286"></a><a class="code" href="../../d8/d6/sertl_8c.html#a43">01286</a> <a class="code" href="../../d8/d6/sertl_8c.html#a43">RtlSubAuthoritySid</a>(
01287     IN PSID Sid,
01288     IN ULONG SubAuthority
01289     )
01290 <span class="comment">/*++</span>
01291 <span class="comment"></span>
01292 <span class="comment">Routine Description:</span>
01293 <span class="comment"></span>
01294 <span class="comment">    This function returns the address of a sub-authority array element of</span>
01295 <span class="comment">    an SID.</span>
01296 <span class="comment"></span>
01297 <span class="comment">Arguments:</span>
01298 <span class="comment"></span>
01299 <span class="comment">    Sid - Pointer to the SID data structure.</span>
01300 <span class="comment"></span>
01301 <span class="comment">    SubAuthority - An index indicating which sub-authority is being specified.</span>
01302 <span class="comment">        This value is not compared against the number of sub-authorities in the</span>
01303 <span class="comment">        SID for validity.</span>
01304 <span class="comment"></span>
01305 <span class="comment">Return Value:</span>
01306 <span class="comment"></span>
01307 <span class="comment"></span>
01308 <span class="comment">--*/</span>
01309 {
01310     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
01311 
01312     <span class="keywordflow">return</span> RtlpSubAuthoritySid( Sid, SubAuthority );
01313 }
01314 
01315 PUCHAR
<a name="l01316"></a><a class="code" href="../../d8/d6/sertl_8c.html#a44">01316</a> <a class="code" href="../../d8/d6/sertl_8c.html#a44">RtlSubAuthorityCountSid</a>(
01317     IN PSID Sid
01318     )
01319 <span class="comment">/*++</span>
01320 <span class="comment"></span>
01321 <span class="comment">Routine Description:</span>
01322 <span class="comment"></span>
01323 <span class="comment">    This function returns the address of the sub-authority count field of</span>
01324 <span class="comment">    an SID.</span>
01325 <span class="comment"></span>
01326 <span class="comment">Arguments:</span>
01327 <span class="comment"></span>
01328 <span class="comment">    Sid - Pointer to the SID data structure.</span>
01329 <span class="comment"></span>
01330 <span class="comment">Return Value:</span>
01331 <span class="comment"></span>
01332 <span class="comment"></span>
01333 <span class="comment">--*/</span>
01334 {
01335     PISID ISid;
01336 
01337     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
01338 
01339     <span class="comment">//</span>
01340     <span class="comment">//  Typecast to the opaque SID</span>
01341     <span class="comment">//</span>
01342 
01343     ISid = (PISID)Sid;
01344 
01345     <span class="keywordflow">return</span> &amp;(ISid-&gt;SubAuthorityCount);
01346 
01347 }
01348 
01349 ULONG
<a name="l01350"></a><a class="code" href="../../d8/d6/sertl_8c.html#a45">01350</a> <a class="code" href="../../d8/d6/sertl_8c.html#a45">RtlLengthSid</a> (
01351     IN PSID Sid
01352     )
01353 
01354 <span class="comment">/*++</span>
01355 <span class="comment"></span>
01356 <span class="comment">Routine Description:</span>
01357 <span class="comment"></span>
01358 <span class="comment">    This routine returns the length, in bytes, of a structurally valid SID.</span>
01359 <span class="comment"></span>
01360 <span class="comment">Arguments:</span>
01361 <span class="comment"></span>
01362 <span class="comment">    Sid - Points to the SID whose length is to be returned.  The</span>
01363 <span class="comment">        SID's structure is assumed to be valid.</span>
01364 <span class="comment"></span>
01365 <span class="comment">Return Value:</span>
01366 <span class="comment"></span>
01367 <span class="comment">    ULONG - The length, in bytes, of the SID.</span>
01368 <span class="comment"></span>
01369 <span class="comment"></span>
01370 <span class="comment">--*/</span>
01371 
01372 {
01373     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
01374 
01375     <span class="keywordflow">return</span> <a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>(Sid);
01376 }
01377 
01378 
01379 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l01380"></a><a class="code" href="../../d8/d6/sertl_8c.html#a46">01380</a> <a class="code" href="../../d8/d6/sertl_8c.html#a46">RtlCopySid</a> (
01381     IN ULONG DestinationSidLength,
01382     OUT PSID DestinationSid,
01383     IN PSID SourceSid
01384     )
01385 
01386 <span class="comment">/*++</span>
01387 <span class="comment"></span>
01388 <span class="comment">Routine Description:</span>
01389 <span class="comment"></span>
01390 <span class="comment">    This routine copies the value of the source SID to the destination</span>
01391 <span class="comment">    SID.</span>
01392 <span class="comment"></span>
01393 <span class="comment">Arguments:</span>
01394 <span class="comment"></span>
01395 <span class="comment">    DestinationSidLength - Indicates the length, in bytes, of the</span>
01396 <span class="comment">        destination SID buffer.</span>
01397 <span class="comment"></span>
01398 <span class="comment">    DestinationSid - Pointer to a buffer to receive a copy of the</span>
01399 <span class="comment">        source Sid value.</span>
01400 <span class="comment"></span>
01401 <span class="comment">    SourceSid - Supplies the Sid value to be copied.</span>
01402 <span class="comment"></span>
01403 <span class="comment">Return Value:</span>
01404 <span class="comment"></span>
01405 <span class="comment">    STATUS_SUCCESS - Indicates the SID was successfully copied.</span>
01406 <span class="comment"></span>
01407 <span class="comment">    STATUS_BUFFER_TOO_SMALL - Indicates the target buffer wasn't</span>
01408 <span class="comment">        large enough to receive a copy of the SID.</span>
01409 <span class="comment"></span>
01410 <span class="comment"></span>
01411 <span class="comment">--*/</span>
01412 
01413 {
01414     ULONG SidLength = <a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>(SourceSid);
01415 
01416     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
01417 
01418     <span class="keywordflow">if</span> (SidLength &gt; DestinationSidLength) {
01419 
01420         <span class="keywordflow">return</span> STATUS_BUFFER_TOO_SMALL;
01421 
01422     }
01423 
01424     <span class="comment">//</span>
01425     <span class="comment">// Buffer is large enough</span>
01426     <span class="comment">//</span>
01427 
01428     RtlMoveMemory( DestinationSid, SourceSid, SidLength );
01429 
01430     <span class="keywordflow">return</span> STATUS_SUCCESS;
01431 
01432 }
01433 
01434 
01435 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l01436"></a><a class="code" href="../../d8/d6/sertl_8c.html#a47">01436</a> <a class="code" href="../../d8/d6/sertl_8c.html#a47">RtlCopySidAndAttributesArray</a> (
01437     IN ULONG ArrayLength,
01438     IN PSID_AND_ATTRIBUTES Source,
01439     IN ULONG TargetSidBufferSize,
01440     OUT PSID_AND_ATTRIBUTES TargetArrayElement,
01441     OUT PSID TargetSid,
01442     OUT PSID *NextTargetSid,
01443     OUT PULONG RemainingTargetSidBufferSize
01444     )
01445 
01446 <span class="comment">/*++</span>
01447 <span class="comment"></span>
01448 <span class="comment">Routine Description:</span>
01449 <span class="comment"></span>
01450 <span class="comment">    This routine copies the value of the source SID_AND_ATTRIBUTES array</span>
01451 <span class="comment">    to the target.  The actual SID values are placed according to a separate</span>
01452 <span class="comment">    parameter.  This allows multiple arrays to be merged using this service</span>
01453 <span class="comment">    to copy each.</span>
01454 <span class="comment"></span>
01455 <span class="comment">Arguments:</span>
01456 <span class="comment"></span>
01457 <span class="comment">    ArrayLength - Number of elements in the source array to copy.</span>
01458 <span class="comment"></span>
01459 <span class="comment">    Source - Pointer to the source array.</span>
01460 <span class="comment"></span>
01461 <span class="comment">    TargetSidBufferSize - Indicates the length, in bytes, of the buffer</span>
01462 <span class="comment">        to receive the actual SID values.  If this value is less than</span>
01463 <span class="comment">        the actual amount needed, then STATUS_BUFFER_TOO_SMALL is returned.</span>
01464 <span class="comment"></span>
01465 <span class="comment">    TargetArrayElement - Indicates where the array elements are to be</span>
01466 <span class="comment">        copied to (but not the SID values themselves).</span>
01467 <span class="comment"></span>
01468 <span class="comment">    TargetSid - Indicates where the target SID values s are to be copied.  This</span>
01469 <span class="comment">        is assumed to be ULONG aligned.  Each SID value will be copied</span>
01470 <span class="comment">        into this buffer.  Each SID will be ULONG aligned.</span>
01471 <span class="comment"></span>
01472 <span class="comment">    NextTargetSid - On completion, will be set to point to the ULONG</span>
01473 <span class="comment">        aligned address following the last SID copied.</span>
01474 <span class="comment"></span>
01475 <span class="comment">    RemainingTargetSidBufferSize - On completion, receives an indicatation</span>
01476 <span class="comment">        of how much of the SID buffer is still unused.</span>
01477 <span class="comment"></span>
01478 <span class="comment"></span>
01479 <span class="comment">Return Value:</span>
01480 <span class="comment"></span>
01481 <span class="comment">    STATUS_SUCCESS - The call completed successfully.</span>
01482 <span class="comment"></span>
01483 <span class="comment">    STATUS_BUFFER_TOO_SMALL - Indicates the buffer to receive the SID</span>
01484 <span class="comment">        values wasn't large enough.</span>
01485 <span class="comment"></span>
01486 <span class="comment"></span>
01487 <span class="comment"></span>
01488 <span class="comment">--*/</span>
01489 
01490 {
01491 
01492     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = 0;
01493     PSID NextSid = TargetSid;
01494     ULONG NextSidLength;
01495     ULONG AlignedSidLength;
01496     ULONG RemainingLength = TargetSidBufferSize;
01497 
01498     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
01499 
01500     <span class="keywordflow">while</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &lt; ArrayLength) {
01501 
01502         NextSidLength = <a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>( Source[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].Sid );
01503         AlignedSidLength = PtrToUlong(<a class="code" href="../../d3/d8/fsrtlp_8h.html#a10">LongAlign</a>(NextSidLength));
01504 
01505         <span class="keywordflow">if</span> (NextSidLength &gt; RemainingLength) {
01506             <span class="keywordflow">return</span> STATUS_BUFFER_TOO_SMALL;
01507         }
01508 
01509         RemainingLength -= AlignedSidLength;
01510 
01511         TargetArrayElement[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].Sid = NextSid;
01512         TargetArrayElement[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].Attributes = Source[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].Attributes;
01513 
01514         <a class="code" href="../../d8/d6/sertl_8c.html#a46">RtlCopySid</a>( NextSidLength, NextSid, Source[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].Sid );
01515 
01516         NextSid = (PSID)((PCHAR)NextSid + AlignedSidLength);
01517 
01518         <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> += 1;
01519 
01520     } <span class="comment">//end_while</span>
01521 
01522     (*NextTargetSid) = NextSid;
01523     (*RemainingTargetSidBufferSize) = RemainingLength;
01524 
01525     <span class="keywordflow">return</span> STATUS_SUCCESS;
01526 
01527 }
01528 
01529 
01530 
01531 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l01532"></a><a class="code" href="../../d8/d6/sertl_8c.html#a48">01532</a> <a class="code" href="../../d8/d6/sertl_8c.html#a48">RtlLengthSidAsUnicodeString</a>(
01533     PSID Sid,
01534     PULONG StringLength
01535     )
01536 
01537 <span class="comment">/*++</span>
01538 <span class="comment"></span>
01539 <span class="comment">Routine Description:</span>
01540 <span class="comment"></span>
01541 <span class="comment"></span>
01542 <span class="comment">    This function returns the maximum length of the string needed</span>
01543 <span class="comment">    to represent the SID supplied.  The actual string may be shorter,</span>
01544 <span class="comment">    but this is intended to be a quick calculation.</span>
01545 <span class="comment"></span>
01546 <span class="comment">Arguments:</span>
01547 <span class="comment"></span>
01548 <span class="comment"></span>
01549 <span class="comment">    Sid - Supplies the SID that is to be converted to unicode.</span>
01550 <span class="comment"></span>
01551 <span class="comment">    StringLength - Receives the max length required in bytes.</span>
01552 <span class="comment"></span>
01553 <span class="comment">Return Value:</span>
01554 <span class="comment"></span>
01555 <span class="comment">    SUCCESS - The conversion was successful</span>
01556 <span class="comment"></span>
01557 <span class="comment">    STATUS_INVALID_SID - The sid provided does not have a valid structure,</span>
01558 <span class="comment">        or has too many sub-authorities (more than SID_MAX_SUB_AUTHORITIES).</span>
01559 <span class="comment"></span>
01560 <span class="comment">--*/</span>
01561 
01562 {
01563     ULONG   i ;
01564 
01565     PISID   iSid = (PISID)Sid;  <span class="comment">// pointer to opaque structure</span>
01566 
01567 
01568     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
01569 
01570     <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a35">RtlValidSid</a>( Sid ) != <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>)
01571     {
01572         <span class="keywordflow">return</span>(STATUS_INVALID_SID);
01573     }
01574 
01575     <span class="comment">//</span>
01576     <span class="comment">// if the SID's IA value has 5 or 6 significant bytes, the</span>
01577     <span class="comment">// representation will be in hex, with a 0x preceding.  Otherwise</span>
01578     <span class="comment">// it will be in decimal, with at most 10 characters.</span>
01579     <span class="comment">//</span>
01580 
01581     <span class="keywordflow">if</span> (  (iSid-&gt;IdentifierAuthority.Value[0] != 0)  ||
01582           (iSid-&gt;IdentifierAuthority.Value[1] != 0)  )
01583     {
01584         i = 14 ;    <span class="comment">// 0x665544332211</span>
01585 
01586     }
01587     <span class="keywordflow">else</span>
01588     {
01589         i = 10 ;    <span class="comment">// 4294967295 is the max ulong, at 10 chars</span>
01590     }
01591 
01592     i += 4 ;        <span class="comment">// room for the S-1-</span>
01593 
01594     <span class="comment">//</span>
01595     <span class="comment">// for each sub authority, it is a max of 10 chars (for a ulong),</span>
01596     <span class="comment">// plus the - separator</span>
01597     <span class="comment">//</span>
01598 
01599     i += 11 * iSid-&gt;SubAuthorityCount ;
01600 
01601     *<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a1158">StringLength</a> = i * <span class="keyword">sizeof</span>( WCHAR );
01602 
01603     <span class="keywordflow">return</span> STATUS_SUCCESS ;
01604 
01605 }
01606 
01607 
01608 
01609 
01610 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l01611"></a><a class="code" href="../../d8/d6/sertl_8c.html#a49">01611</a> <a class="code" href="../../d8/d6/sertl_8c.html#a49">RtlConvertSidToUnicodeString</a>(
01612     PUNICODE_STRING UnicodeString,
01613     PSID Sid,
01614     BOOLEAN AllocateDestinationString
01615     )
01616 
01617 <span class="comment">/*++</span>
01618 <span class="comment"></span>
01619 <span class="comment">Routine Description:</span>
01620 <span class="comment"></span>
01621 <span class="comment"></span>
01622 <span class="comment">    This function generates a printable unicode string representation</span>
01623 <span class="comment">    of a SID.</span>
01624 <span class="comment"></span>
01625 <span class="comment">    The resulting string will take one of two forms.  If the</span>
01626 <span class="comment">    IdentifierAuthority value is not greater than 2^32, then</span>
01627 <span class="comment">    the SID will be in the form:</span>
01628 <span class="comment"></span>
01629 <span class="comment"></span>
01630 <span class="comment">        S-1-281736-12-72-9-110</span>
01631 <span class="comment">              ^    ^^ ^^ ^ ^^^</span>
01632 <span class="comment">              |     |  | |  |</span>
01633 <span class="comment">              +-----+--+-+--+---- Decimal</span>
01634 <span class="comment"></span>
01635 <span class="comment"></span>
01636 <span class="comment"></span>
01637 <span class="comment">    Otherwise it will take the form:</span>
01638 <span class="comment"></span>
01639 <span class="comment"></span>
01640 <span class="comment">        S-1-0x173495281736-12-72-9-110</span>
01641 <span class="comment">            ^^^^^^^^^^^^^^ ^^ ^^ ^ ^^^</span>
01642 <span class="comment">             Hexidecimal    |  | |  |</span>
01643 <span class="comment">                            +--+-+--+---- Decimal</span>
01644 <span class="comment"></span>
01645 <span class="comment"></span>
01646 <span class="comment"></span>
01647 <span class="comment"></span>
01648 <span class="comment"></span>
01649 <span class="comment"></span>
01650 <span class="comment">Arguments:</span>
01651 <span class="comment"></span>
01652 <span class="comment"></span>
01653 <span class="comment"></span>
01654 <span class="comment">    UnicodeString - Returns a unicode string that is equivalent to</span>
01655 <span class="comment">        the SID. The maximum length field is only set if</span>
01656 <span class="comment">        AllocateDestinationString is TRUE.</span>
01657 <span class="comment"></span>
01658 <span class="comment">    Sid - Supplies the SID that is to be converted to unicode.</span>
01659 <span class="comment"></span>
01660 <span class="comment">    AllocateDestinationString - Supplies a flag that controls whether or</span>
01661 <span class="comment">        not this API allocates the buffer space for the destination</span>
01662 <span class="comment">        string.  If it does, then the buffer must be deallocated using</span>
01663 <span class="comment">        RtlFreeUnicodeString (note that only storage for</span>
01664 <span class="comment">        DestinationString-&gt;Buffer is allocated by this API).</span>
01665 <span class="comment"></span>
01666 <span class="comment">Return Value:</span>
01667 <span class="comment"></span>
01668 <span class="comment">    SUCCESS - The conversion was successful</span>
01669 <span class="comment"></span>
01670 <span class="comment">    STATUS_INVALID_SID - The sid provided does not have a valid structure,</span>
01671 <span class="comment">        or has too many sub-authorities (more than SID_MAX_SUB_AUTHORITIES).</span>
01672 <span class="comment"></span>
01673 <span class="comment">    STATUS_NO_MEMORY - There was not sufficient memory to allocate the</span>
01674 <span class="comment">        target string.  This is returned only if AllocateDestinationString</span>
01675 <span class="comment">        is specified as TRUE.</span>
01676 <span class="comment"></span>
01677 <span class="comment">    STATUS_BUFFER_OVERFLOW - This is returned only if</span>
01678 <span class="comment">        AllocateDestinationString is specified as FALSE.</span>
01679 <span class="comment"></span>
01680 <span class="comment"></span>
01681 <span class="comment">--*/</span>
01682 
01683 {
01684     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01685     WCHAR UniBuffer[ 256 ];
01686     PWSTR <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> ;
01687     UNICODE_STRING LocalString ;
01688 
01689     UCHAR   i;
01690     ULONG   Tmp;
01691     LARGE_INTEGER Auth ;
01692 
01693     PISID   iSid = (PISID)Sid;  <span class="comment">// pointer to opaque structure</span>
01694 
01695 
01696     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
01697 
01698     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d6/sertl_8c.html#a35">RtlValidSid</a>( Sid ) != <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
01699         <span class="keywordflow">return</span>(STATUS_INVALID_SID);
01700     }
01701 
01702     <span class="keywordflow">if</span> ( iSid-&gt;Revision != SID_REVISION )
01703     {
01704         <span class="keywordflow">return</span> STATUS_INVALID_SID ;
01705     }
01706 
01707     wcscpy( UniBuffer, <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="stringliteral">"S-1-"</span> );
01708 
01709     <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> = &amp;UniBuffer[ 4 ];
01710 
01711     <span class="keywordflow">if</span> (  (iSid-&gt;IdentifierAuthority.Value[0] != 0)  ||
01712           (iSid-&gt;IdentifierAuthority.Value[1] != 0)     ){
01713 
01714         <span class="comment">//</span>
01715         <span class="comment">// Ugly hex dump.</span>
01716         <span class="comment">//</span>
01717 
01718         Auth.HighPart = (LONG) (iSid-&gt;IdentifierAuthority.Value[ 0 ] &lt;&lt; 8) +
01719                         (LONG) iSid-&gt;IdentifierAuthority.Value[ 1 ] ;
01720 
01721         Auth.LowPart = (ULONG)iSid-&gt;IdentifierAuthority.Value[5]          +
01722                        (ULONG)(iSid-&gt;IdentifierAuthority.Value[4] &lt;&lt;  8)  +
01723                        (ULONG)(iSid-&gt;IdentifierAuthority.Value[3] &lt;&lt; 16)  +
01724                        (ULONG)(iSid-&gt;IdentifierAuthority.Value[2] &lt;&lt; 24);
01725 
01726         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d3/cnvint_8c.html#a8">RtlLargeIntegerToUnicode</a>(
01727                         &amp;Auth,
01728                         16,
01729                         256 - (LONG) (<a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> - UniBuffer),
01730                         <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> );
01731 
01732 
01733     } <span class="keywordflow">else</span> {
01734 
01735         Tmp = (ULONG)iSid-&gt;IdentifierAuthority.Value[5]          +
01736               (ULONG)(iSid-&gt;IdentifierAuthority.Value[4] &lt;&lt;  8)  +
01737               (ULONG)(iSid-&gt;IdentifierAuthority.Value[3] &lt;&lt; 16)  +
01738               (ULONG)(iSid-&gt;IdentifierAuthority.Value[2] &lt;&lt; 24);
01739 
01740         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d3/cnvint_8c.html#a5">RtlIntegerToUnicode</a>(
01741                         Tmp,
01742                         10,
01743                         256 - (LONG) (<a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> - UniBuffer),
01744                         <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> );
01745 
01746     }
01747 
01748     <span class="keywordflow">if</span> ( !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> ) )
01749     {
01750         <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> ;
01751     }
01752 
01753 
01754     <span class="keywordflow">for</span> (i=0;i&lt;iSid-&gt;SubAuthorityCount ;i++ ) {
01755 
01756         <span class="keywordflow">while</span> ( *<a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> &amp;&amp; ( <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> &lt; &amp;UniBuffer[ 255 ] ) )
01757         {
01758             <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>++ ;
01759         }
01760 
01761         *<a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>++ = <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'-'</span> ;
01762 
01763         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d3/cnvint_8c.html#a5">RtlIntegerToUnicode</a>(
01764                         iSid-&gt;SubAuthority[ i ],
01765                         10,
01766                         256 - (LONG) (<a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> - UniBuffer),
01767                         <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> );
01768 
01769         <span class="keywordflow">if</span> ( !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> ) )
01770         {
01771             <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> ;
01772         }
01773     }
01774 
01775     <span class="keywordflow">if</span> ( AllocateDestinationString )
01776     {
01777         <span class="keywordflow">if</span> ( <a class="code" href="../../d6/d6/nls_8c.html#a47">RtlCreateUnicodeString</a>( UnicodeString,
01778                                          UniBuffer ) )
01779         {
01780             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS ;
01781         }
01782         <span class="keywordflow">else</span>
01783         {
01784             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_NO_MEMORY ;
01785         }
01786 
01787     }
01788     <span class="keywordflow">else</span>
01789     {
01790 
01791         <span class="keywordflow">while</span> ( *<a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> &amp;&amp; ( <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> &lt; &amp;UniBuffer[ 255 ] ) )
01792         {
01793             <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>++ ;
01794         }
01795 
01796         Tmp = (ULONG) (<a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> - UniBuffer) * <span class="keyword">sizeof</span>( WCHAR );
01797 
01798         <span class="keywordflow">if</span> ( Tmp &lt; UnicodeString-&gt;MaximumLength )
01799         {
01800             LocalString.Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>) Tmp ;
01801             LocalString.MaximumLength = LocalString.Length + <span class="keyword">sizeof</span>( WCHAR );
01802             LocalString.Buffer = UniBuffer ;
01803 
01804             <a class="code" href="../../d6/d6/nls_8c.html#a44">RtlCopyUnicodeString</a>(
01805                         UnicodeString,
01806                         &amp;LocalString );
01807 
01808             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS ;
01809         }
01810         <span class="keywordflow">else</span>
01811         {
01812             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_BUFFER_OVERFLOW ;
01813         }
01814 
01815     }
01816 
01817     <span class="keywordflow">return</span>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>);
01818 }
01819 
01820 
01821 
01822 
01823 BOOLEAN
<a name="l01824"></a><a class="code" href="../../d8/d6/sertl_8c.html#a50">01824</a> <a class="code" href="../../d8/d6/sertl_8c.html#a50">RtlEqualLuid</a> (
01825     IN PLUID Luid1,
01826     IN PLUID Luid2
01827     )
01828 
01829 <span class="comment">/*++</span>
01830 <span class="comment"></span>
01831 <span class="comment">Routine Description:</span>
01832 <span class="comment"></span>
01833 <span class="comment">    This procedure test two LUID values for equality.</span>
01834 <span class="comment"></span>
01835 <span class="comment">    This routine is here for backwards compatibility only. New code</span>
01836 <span class="comment">    should use the macro.</span>
01837 <span class="comment"></span>
01838 <span class="comment">Arguments:</span>
01839 <span class="comment"></span>
01840 <span class="comment">    Luid1, Luid2 - Supply pointers to the two LUID values to compare.</span>
01841 <span class="comment"></span>
01842 <span class="comment">Return Value:</span>
01843 <span class="comment"></span>
01844 <span class="comment">    BOOLEAN - TRUE if the value of Luid1 is equal to Luid2, and FALSE</span>
01845 <span class="comment">        otherwise.</span>
01846 <span class="comment"></span>
01847 <span class="comment"></span>
01848 <span class="comment">--*/</span>
01849 
01850 {
01851     LUID UNALIGNED * TempLuid1;
01852     LUID UNALIGNED * TempLuid2;
01853 
01854     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
01855 
01856     <span class="keywordflow">return</span>((Luid1-&gt;HighPart == Luid2-&gt;HighPart) &amp;&amp;
01857            (Luid1-&gt;LowPart  == Luid2-&gt;LowPart));
01858 
01859 }
01860 
01861 
01862 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01863"></a><a class="code" href="../../d8/d6/sertl_8c.html#a51">01863</a> <a class="code" href="../../d8/d6/sertl_8c.html#a51">RtlCopyLuid</a> (
01864     OUT PLUID DestinationLuid,
01865     IN PLUID SourceLuid
01866     )
01867 
01868 <span class="comment">/*++</span>
01869 <span class="comment"></span>
01870 <span class="comment">Routine Description:</span>
01871 <span class="comment"></span>
01872 <span class="comment">    This routine copies the value of the source LUID to the</span>
01873 <span class="comment">    destination LUID.</span>
01874 <span class="comment"></span>
01875 <span class="comment">Arguments:</span>
01876 <span class="comment"></span>
01877 <span class="comment">    DestinationLuid - Receives a copy of the source Luid value.</span>
01878 <span class="comment"></span>
01879 <span class="comment">    SourceLuid - Supplies the Luid value to be copied.  This LUID is</span>
01880 <span class="comment">                 assumed to be structurally valid.</span>
01881 <span class="comment"></span>
01882 <span class="comment">Return Value:</span>
01883 <span class="comment"></span>
01884 <span class="comment">    None.</span>
01885 <span class="comment"></span>
01886 <span class="comment">--*/</span>
01887 
01888 {
01889     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
01890 
01891     (*DestinationLuid) = (*SourceLuid);
01892     <span class="keywordflow">return</span>;
01893 }
01894 
01895 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01896"></a><a class="code" href="../../d8/d6/sertl_8c.html#a52">01896</a> <a class="code" href="../../d8/d6/sertl_8c.html#a52">RtlCopyLuidAndAttributesArray</a> (
01897     IN ULONG ArrayLength,
01898     IN PLUID_AND_ATTRIBUTES Source,
01899     OUT PLUID_AND_ATTRIBUTES Target
01900     )
01901 
01902 <span class="comment">/*++</span>
01903 <span class="comment"></span>
01904 <span class="comment">Routine Description:</span>
01905 <span class="comment"></span>
01906 <span class="comment">    This routine copies the value of the source LUID_AND_ATTRIBUTES array</span>
01907 <span class="comment">    to the target.</span>
01908 <span class="comment"></span>
01909 <span class="comment">Arguments:</span>
01910 <span class="comment"></span>
01911 <span class="comment">    ArrayLength - Number of elements in the source array to copy.</span>
01912 <span class="comment"></span>
01913 <span class="comment">    Source - The source array.</span>
01914 <span class="comment"></span>
01915 <span class="comment">    Target - Indicates where the array elements are to be copied to.</span>
01916 <span class="comment"></span>
01917 <span class="comment"></span>
01918 <span class="comment">Return Value:</span>
01919 <span class="comment"></span>
01920 <span class="comment">    None.</span>
01921 <span class="comment"></span>
01922 <span class="comment"></span>
01923 <span class="comment">--*/</span>
01924 
01925 {
01926 
01927     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = 0;
01928 
01929     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
01930 
01931     <span class="keywordflow">while</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &lt; ArrayLength) {
01932 
01933         Target[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>] = Source[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>];
01934 
01935         <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> += 1;
01936 
01937     } <span class="comment">//end_while</span>
01938 
01939 
01940     <span class="keywordflow">return</span>;
01941 
01942 }
01943 
01944 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l01945"></a><a class="code" href="../../d8/d6/sertl_8c.html#a53">01945</a> <a class="code" href="../../d8/d6/sertl_8c.html#a53">RtlCreateSecurityDescriptor</a> (
01946     IN PSECURITY_DESCRIPTOR SecurityDescriptor,
01947     IN ULONG Revision
01948     )
01949 
01950 <span class="comment">/*++</span>
01951 <span class="comment"></span>
01952 <span class="comment">Routine Description:</span>
01953 <span class="comment"></span>
01954 <span class="comment">    This procedure initializes a new "absolute format" security descriptor.</span>
01955 <span class="comment">    After the procedure call the security descriptor is initialized with no</span>
01956 <span class="comment">    system ACL, no discretionary ACL, no owner, no primary group and</span>
01957 <span class="comment">    all control flags set to false (null).</span>
01958 <span class="comment"></span>
01959 <span class="comment">Arguments:</span>
01960 <span class="comment"></span>
01961 <span class="comment"></span>
01962 <span class="comment">    SecurityDescriptor - Supplies the security descriptor to</span>
01963 <span class="comment">        initialize.</span>
01964 <span class="comment"></span>
01965 <span class="comment">    Revision - Provides the revision level to assign to the security</span>
01966 <span class="comment">        descriptor.  This should be one (1) for this release.</span>
01967 <span class="comment"></span>
01968 <span class="comment">Return Value:</span>
01969 <span class="comment"></span>
01970 <span class="comment">    STATUS_SUCCESS - Indicates the call completed successfully.</span>
01971 <span class="comment"></span>
01972 <span class="comment">    STATUS_UNKNOWN_REVISION - Indicates the revision level provided</span>
01973 <span class="comment">        is not supported by this routine.</span>
01974 <span class="comment"></span>
01975 <span class="comment">--*/</span>
01976 
01977 {
01978     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
01979 
01980     <span class="comment">//</span>
01981     <span class="comment">// Check the requested revision</span>
01982     <span class="comment">//</span>
01983 
01984     <span class="keywordflow">if</span> (Revision == SECURITY_DESCRIPTOR_REVISION) {
01985 
01986         <span class="comment">//</span>
01987         <span class="comment">// Typecast to the opaque SECURITY_DESCRIPTOR structure.</span>
01988         <span class="comment">//</span>
01989 
01990         SECURITY_DESCRIPTOR *ISecurityDescriptor = SecurityDescriptor;
01991 
01992         RtlZeroMemory( ISecurityDescriptor, <span class="keyword">sizeof</span>(SECURITY_DESCRIPTOR));
01993 
01994         ISecurityDescriptor-&gt;Revision = SECURITY_DESCRIPTOR_REVISION;
01995 
01996         <span class="keywordflow">return</span> STATUS_SUCCESS;
01997     }
01998 
01999     <span class="keywordflow">return</span> STATUS_UNKNOWN_REVISION;
02000 }
02001 
02002 
02003 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l02004"></a><a class="code" href="../../d8/d6/sertl_8c.html#a54">02004</a> <a class="code" href="../../d8/d6/sertl_8c.html#a54">RtlCreateSecurityDescriptorRelative</a> (
02005     IN PISECURITY_DESCRIPTOR_RELATIVE SecurityDescriptor,
02006     IN ULONG Revision
02007     )
02008 
02009 <span class="comment">/*++</span>
02010 <span class="comment"></span>
02011 <span class="comment">Routine Description:</span>
02012 <span class="comment"></span>
02013 <span class="comment">    This procedure initializes a new "relative format" security descriptor.</span>
02014 <span class="comment">    After the procedure call the security descriptor is initialized with no</span>
02015 <span class="comment">    system ACL, no discretionary ACL, no owner, no primary group and</span>
02016 <span class="comment">    all control flags set to false (null).</span>
02017 <span class="comment"></span>
02018 <span class="comment">Arguments:</span>
02019 <span class="comment"></span>
02020 <span class="comment"></span>
02021 <span class="comment">    SecurityDescriptor - Supplies the security descriptor to</span>
02022 <span class="comment">        initialize.</span>
02023 <span class="comment"></span>
02024 <span class="comment">    Revision - Provides the revision level to assign to the security</span>
02025 <span class="comment">        descriptor.  This should be one (1) for this release.</span>
02026 <span class="comment"></span>
02027 <span class="comment">Return Value:</span>
02028 <span class="comment"></span>
02029 <span class="comment">    STATUS_SUCCESS - Indicates the call completed successfully.</span>
02030 <span class="comment"></span>
02031 <span class="comment">    STATUS_UNKNOWN_REVISION - Indicates the revision level provided</span>
02032 <span class="comment">        is not supported by this routine.</span>
02033 <span class="comment"></span>
02034 <span class="comment">Note:</span>
02035 <span class="comment">    Warning, this code assume the caller allocated a relative security</span>
02036 <span class="comment">    descriptor rather than a relative one.  Absolute is larger on systems</span>
02037 <span class="comment">    with 64-bit pointers.</span>
02038 <span class="comment"></span>
02039 <span class="comment">--*/</span>
02040 
02041 {
02042     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
02043 
02044     <span class="comment">//</span>
02045     <span class="comment">// Check the requested revision</span>
02046     <span class="comment">//</span>
02047 
02048     <span class="keywordflow">if</span> (Revision == SECURITY_DESCRIPTOR_REVISION) {
02049 
02050         <span class="comment">//</span>
02051         <span class="comment">// Typecast to the opaque SECURITY_DESCRIPTOR structure.</span>
02052         <span class="comment">//</span>
02053 
02054         RtlZeroMemory( SecurityDescriptor, <span class="keyword">sizeof</span>(SECURITY_DESCRIPTOR_RELATIVE));
02055 
02056         SecurityDescriptor-&gt;Revision = SECURITY_DESCRIPTOR_REVISION;
02057 
02058         <span class="keywordflow">return</span> STATUS_SUCCESS;
02059     }
02060 
02061     <span class="keywordflow">return</span> STATUS_UNKNOWN_REVISION;
02062 }
02063 
02064 
02065 BOOLEAN
<a name="l02066"></a><a class="code" href="../../d8/d6/sertl_8c.html#a55">02066</a> <a class="code" href="../../d8/d6/sertl_8c.html#a55">RtlValidSecurityDescriptor</a> (
02067     IN PSECURITY_DESCRIPTOR SecurityDescriptor
02068     )
02069 
02070 <span class="comment">/*++</span>
02071 <span class="comment"></span>
02072 <span class="comment">Routine Description:</span>
02073 <span class="comment"></span>
02074 <span class="comment">    This procedure validates a SecurityDescriptor's structure.  This</span>
02075 <span class="comment">    involves validating the revision levels of each component of the</span>
02076 <span class="comment">    security descriptor.</span>
02077 <span class="comment"></span>
02078 <span class="comment">Arguments:</span>
02079 <span class="comment"></span>
02080 <span class="comment">    SecurityDescriptor - Pointer to the SECURITY_DESCRIPTOR structure</span>
02081 <span class="comment">        to validate.</span>
02082 <span class="comment"></span>
02083 <span class="comment">Return Value:</span>
02084 <span class="comment"></span>
02085 <span class="comment">    BOOLEAN - TRUE if the structure of SecurityDescriptor is valid.</span>
02086 <span class="comment"></span>
02087 <span class="comment"></span>
02088 <span class="comment">--*/</span>
02089 
02090 {
02091     PSID <a class="code" href="../../d6/d0/ctaccess_8c.html#a53">Owner</a>;
02092     PSID <a class="code" href="../../d6/d0/ctaccess_8c.html#a54">Group</a>;
02093     PACL <a class="code" href="../../d6/d0/ctaccess_8c.html#a55">Dacl</a>;
02094     PACL Sacl;
02095 
02096     <span class="comment">//</span>
02097     <span class="comment">// Typecast to the opaque SECURITY_DESCRIPTOR structure.</span>
02098     <span class="comment">//</span>
02099 
02100     SECURITY_DESCRIPTOR *ISecurityDescriptor = SecurityDescriptor;
02101 
02102     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
02103 
02104     <span class="keywordflow">try</span> {
02105 
02106         <span class="comment">//</span>
02107         <span class="comment">// known revision ?</span>
02108         <span class="comment">//</span>
02109 
02110         <span class="keywordflow">if</span> (ISecurityDescriptor-&gt;Revision != SECURITY_DESCRIPTOR_REVISION) {
02111             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02112         }
02113 
02114 
02115         <span class="comment">//</span>
02116         <span class="comment">// Validate each element contained in the security descriptor</span>
02117         <span class="comment">//</span>
02118 
02119         <a class="code" href="../../d6/d0/ctaccess_8c.html#a53">Owner</a> = RtlpOwnerAddrSecurityDescriptor( ISecurityDescriptor );
02120 
02121         <span class="keywordflow">if</span> (<a class="code" href="../../d6/d0/ctaccess_8c.html#a53">Owner</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02122             <span class="keywordflow">if</span> (!<a class="code" href="../../d8/d6/sertl_8c.html#a35">RtlValidSid</a>( <a class="code" href="../../d6/d0/ctaccess_8c.html#a53">Owner</a> )) {
02123                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02124             }
02125         }
02126 
02127         <a class="code" href="../../d6/d0/ctaccess_8c.html#a54">Group</a> = RtlpGroupAddrSecurityDescriptor( ISecurityDescriptor );
02128 
02129         <span class="keywordflow">if</span> (<a class="code" href="../../d6/d0/ctaccess_8c.html#a54">Group</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02130             <span class="keywordflow">if</span> (!<a class="code" href="../../d8/d6/sertl_8c.html#a35">RtlValidSid</a>( <a class="code" href="../../d6/d0/ctaccess_8c.html#a54">Group</a> )) {
02131                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02132             }
02133         }
02134 
02135         <a class="code" href="../../d6/d0/ctaccess_8c.html#a55">Dacl</a> = RtlpDaclAddrSecurityDescriptor( ISecurityDescriptor );
02136         <span class="keywordflow">if</span> (<a class="code" href="../../d6/d0/ctaccess_8c.html#a55">Dacl</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
02137 
02138             <span class="keywordflow">if</span> (!<a class="code" href="../../d2/d4/acledit_8c.html#a7">RtlValidAcl</a>( <a class="code" href="../../d6/d0/ctaccess_8c.html#a55">Dacl</a> )) {
02139                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02140             }
02141         }
02142 
02143         Sacl = RtlpSaclAddrSecurityDescriptor( ISecurityDescriptor );
02144         <span class="keywordflow">if</span> ( Sacl != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
02145             <span class="keywordflow">if</span> (!<a class="code" href="../../d2/d4/acledit_8c.html#a7">RtlValidAcl</a>( Sacl )) {
02146                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02147             }
02148         }
02149 
02150     } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
02151         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02152     }
02153 
02154     <span class="comment">//</span>
02155     <span class="comment">// All components are valid</span>
02156     <span class="comment">//</span>
02157 
02158     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02159 
02160 
02161 }
02162 
02163 
02164 ULONG
<a name="l02165"></a><a class="code" href="../../d8/d6/sertl_8c.html#a56">02165</a> <a class="code" href="../../d8/d6/sertl_8c.html#a56">RtlLengthSecurityDescriptor</a> (
02166     IN PSECURITY_DESCRIPTOR SecurityDescriptor
02167     )
02168 
02169 <span class="comment">/*++</span>
02170 <span class="comment"></span>
02171 <span class="comment">Routine Description:</span>
02172 <span class="comment"></span>
02173 <span class="comment">    This routine returns the length, in bytes, necessary to capture a</span>
02174 <span class="comment">    structurally valid SECURITY_DESCRIPTOR.  The length includes the length</span>
02175 <span class="comment">    of all associated data structures (like SIDs and ACLs).  The length also</span>
02176 <span class="comment">    takes into account the alignment requirements of each component.</span>
02177 <span class="comment"></span>
02178 <span class="comment">    The minimum length of a security descriptor (one which has no associated</span>
02179 <span class="comment">    SIDs or ACLs) is SECURITY_DESCRIPTOR_MIN_LENGTH.</span>
02180 <span class="comment"></span>
02181 <span class="comment"></span>
02182 <span class="comment">Arguments:</span>
02183 <span class="comment"></span>
02184 <span class="comment">    SecurityDescriptor - Points to the SECURITY_DESCRIPTOR whose</span>
02185 <span class="comment">        length is to be returned.  The SECURITY_DESCRIPTOR's</span>
02186 <span class="comment">        structure is assumed to be valid.</span>
02187 <span class="comment"></span>
02188 <span class="comment">Return Value:</span>
02189 <span class="comment"></span>
02190 <span class="comment">    ULONG - The length, in bytes, of the SECURITY_DESCRIPTOR.</span>
02191 <span class="comment"></span>
02192 <span class="comment"></span>
02193 <span class="comment">--*/</span>
02194 
02195 {
02196     ULONG sum;
02197     PVOID Temp;
02198 
02199 
02200     <span class="comment">//</span>
02201     <span class="comment">// Typecast to the opaque SECURITY_DESCRIPTOR structure.</span>
02202     <span class="comment">//</span>
02203 
02204     SECURITY_DESCRIPTOR *ISecurityDescriptor = (SECURITY_DESCRIPTOR *)SecurityDescriptor;
02205 
02206     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
02207 
02208     <span class="comment">//</span>
02209     <span class="comment">// The length is the sum of the following:</span>
02210     <span class="comment">//</span>
02211     <span class="comment">//       SECURITY_DESCRIPTOR_MIN_LENGTH (or sizeof(SECURITY_DESCRIPTOR))</span>
02212     <span class="comment">//       length of Owner SID (if present)</span>
02213     <span class="comment">//       length of Group SID (if present)</span>
02214     <span class="comment">//       length of Discretionary ACL (if present and non-null)</span>
02215     <span class="comment">//       length of System ACL (if present and non-null)</span>
02216     <span class="comment">//</span>
02217 
02218     sum = ISecurityDescriptor-&gt;Control &amp; SE_SELF_RELATIVE ?
02219                             <span class="keyword">sizeof</span>(SECURITY_DESCRIPTOR_RELATIVE) :
02220                             <span class="keyword">sizeof</span>(SECURITY_DESCRIPTOR);
02221 
02222     <span class="comment">//</span>
02223     <span class="comment">// Add in length of Owner SID</span>
02224     <span class="comment">//</span>
02225 
02226     Temp = RtlpOwnerAddrSecurityDescriptor(ISecurityDescriptor);
02227     <span class="keywordflow">if</span> (Temp != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02228         sum += LongAlignSize(<a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>(Temp));
02229     }
02230 
02231     <span class="comment">//</span>
02232     <span class="comment">// Add in length of Group SID</span>
02233     <span class="comment">//</span>
02234 
02235     Temp = RtlpGroupAddrSecurityDescriptor(ISecurityDescriptor);
02236     <span class="keywordflow">if</span> (Temp != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02237         sum += LongAlignSize(<a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>(Temp));
02238     }
02239 
02240     <span class="comment">//</span>
02241     <span class="comment">// Add in used length of Discretionary ACL</span>
02242     <span class="comment">//</span>
02243 
02244     Temp = RtlpDaclAddrSecurityDescriptor(ISecurityDescriptor);
02245     <span class="keywordflow">if</span> ( Temp != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
02246 
02247         sum += LongAlignSize(((PACL) Temp)-&gt;AclSize );
02248     }
02249 
02250     <span class="comment">//</span>
02251     <span class="comment">// Add in used length of System Acl</span>
02252     <span class="comment">//</span>
02253 
02254     Temp = RtlpSaclAddrSecurityDescriptor(ISecurityDescriptor);
02255     <span class="keywordflow">if</span> ( Temp != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
02256 
02257         sum += LongAlignSize(((PACL) Temp)-&gt;AclSize );
02258     }
02259 
02260     <span class="keywordflow">return</span> sum;
02261 }
02262 
02263 
02264 ULONG
<a name="l02265"></a><a class="code" href="../../d8/d6/sertl_8c.html#a13">02265</a> <a class="code" href="../../d8/d6/sertl_8c.html#a13">RtlLengthUsedSecurityDescriptor</a> (
02266     IN PSECURITY_DESCRIPTOR SecurityDescriptor
02267     )
02268 
02269 <span class="comment">/*++</span>
02270 <span class="comment"></span>
02271 <span class="comment">Routine Description:</span>
02272 <span class="comment"></span>
02273 <span class="comment">    This routine returns the length, in bytes, in use in a structurally valid</span>
02274 <span class="comment">    SECURITY_DESCRIPTOR.</span>
02275 <span class="comment"></span>
02276 <span class="comment">    This is the number of bytes necessary to capture the security descriptor,</span>
02277 <span class="comment">    which may be less the the current actual length of the security descriptor</span>
02278 <span class="comment">    (RtlLengthSecurityDescriptor() is used to retrieve the actual length).</span>
02279 <span class="comment"></span>
02280 <span class="comment">    Notice that the used length and actual length may differ if either the SACL</span>
02281 <span class="comment">    or DACL include padding bytes.</span>
02282 <span class="comment"></span>
02283 <span class="comment">    The length includes the length of all associated data structures (like SIDs</span>
02284 <span class="comment">    and ACLs).  The length also takes into account the alignment requirements</span>
02285 <span class="comment">    of each component.</span>
02286 <span class="comment"></span>
02287 <span class="comment">    The minimum length of a security descriptor (one which has no associated</span>
02288 <span class="comment">    SIDs or ACLs) is SECURITY_DESCRIPTOR_MIN_LENGTH.</span>
02289 <span class="comment"></span>
02290 <span class="comment"></span>
02291 <span class="comment">Arguments:</span>
02292 <span class="comment"></span>
02293 <span class="comment">    SecurityDescriptor - Points to the SECURITY_DESCRIPTOR whose used</span>
02294 <span class="comment">        length is to be returned.  The SECURITY_DESCRIPTOR's</span>
02295 <span class="comment">        structure is assumed to be valid.</span>
02296 <span class="comment"></span>
02297 <span class="comment">Return Value:</span>
02298 <span class="comment"></span>
02299 <span class="comment">    ULONG - Number of bytes of the SECURITY_DESCRIPTOR that are in use.</span>
02300 <span class="comment"></span>
02301 <span class="comment"></span>
02302 <span class="comment">--*/</span>
02303 
02304 {
02305     ULONG sum;
02306 
02307     ACL_SIZE_INFORMATION AclSize;
02308     PVOID Temp;
02309 
02310     <span class="comment">//</span>
02311     <span class="comment">// Typecast to the opaque SECURITY_DESCRIPTOR structure.</span>
02312     <span class="comment">//</span>
02313 
02314     SECURITY_DESCRIPTOR *ISecurityDescriptor = (SECURITY_DESCRIPTOR *)SecurityDescriptor;
02315 
02316     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
02317 
02318     <span class="comment">//</span>
02319     <span class="comment">// The length is the sum of the following:</span>
02320     <span class="comment">//</span>
02321     <span class="comment">//       SECURITY_DESCRIPTOR_MIN_LENGTH (or sizeof(SECURITY_DESCRIPTOR))</span>
02322     <span class="comment">//       length of Owner SID (if present)</span>
02323     <span class="comment">//       length of Group SID (if present)</span>
02324     <span class="comment">//       length of Discretionary ACL (if present and non-null)</span>
02325     <span class="comment">//       length of System ACL (if present and non-null)</span>
02326     <span class="comment">//</span>
02327 
02328     sum = ISecurityDescriptor-&gt;Control &amp; SE_SELF_RELATIVE ?
02329                             <span class="keyword">sizeof</span>(SECURITY_DESCRIPTOR_RELATIVE) :
02330                             <span class="keyword">sizeof</span>(SECURITY_DESCRIPTOR);
02331 
02332     <span class="comment">//</span>
02333     <span class="comment">// Add in length of Owner SID</span>
02334     <span class="comment">//</span>
02335 
02336     Temp = RtlpOwnerAddrSecurityDescriptor(ISecurityDescriptor);
02337     <span class="keywordflow">if</span> (Temp != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02338         sum += LongAlignSize(<a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>(Temp));
02339     }
02340 
02341     <span class="comment">//</span>
02342     <span class="comment">// Add in length of Group SID</span>
02343     <span class="comment">//</span>
02344 
02345     Temp = RtlpGroupAddrSecurityDescriptor(ISecurityDescriptor);
02346     <span class="keywordflow">if</span> (Temp != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02347         sum += LongAlignSize(<a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>(Temp));
02348     }
02349 
02350     <span class="comment">//</span>
02351     <span class="comment">// Add in used length of Discretionary ACL</span>
02352     <span class="comment">//</span>
02353 
02354     Temp = RtlpDaclAddrSecurityDescriptor(ISecurityDescriptor);
02355     <span class="keywordflow">if</span> ( Temp != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
02356 
02357         <a class="code" href="../../d2/d4/acledit_8c.html#a8">RtlQueryInformationAcl</a>( Temp,
02358                                 (PVOID)&amp;AclSize,
02359                                 <span class="keyword">sizeof</span>(AclSize),
02360                                 AclSizeInformation );
02361 
02362         sum += LongAlignSize(AclSize.AclBytesInUse);
02363     }
02364 
02365     <span class="comment">//</span>
02366     <span class="comment">// Add in used length of System Acl</span>
02367     <span class="comment">//</span>
02368 
02369     Temp = RtlpSaclAddrSecurityDescriptor(ISecurityDescriptor);
02370     <span class="keywordflow">if</span> ( Temp != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
02371 
02372         <a class="code" href="../../d2/d4/acledit_8c.html#a8">RtlQueryInformationAcl</a>( Temp,
02373                                 (PVOID)&amp;AclSize,
02374                                 <span class="keyword">sizeof</span>(AclSize),
02375                                 AclSizeInformation );
02376 
02377         sum += LongAlignSize(AclSize.AclBytesInUse);
02378     }
02379 
02380     <span class="keywordflow">return</span> sum;
02381 }
02382 
02383 
02384 
02385 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l02386"></a><a class="code" href="../../d8/d6/sertl_8c.html#a57">02386</a> <a class="code" href="../../d8/d6/sertl_8c.html#a57">RtlSetAttributesSecurityDescriptor</a>(
02387     IN PSECURITY_DESCRIPTOR SecurityDescriptor,
02388     IN SECURITY_DESCRIPTOR_CONTROL Control,
02389     OUT PULONG Revision
02390     )
02391 {
02392     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
02393 
02394     <span class="comment">//</span>
02395     <span class="comment">// Always return the revision value - even if this isn't a valid</span>
02396     <span class="comment">// security descriptor</span>
02397     <span class="comment">//</span>
02398 
02399     *Revision = ((SECURITY_DESCRIPTOR *)SecurityDescriptor)-&gt;Revision;
02400 
02401     <span class="keywordflow">if</span> ( ((SECURITY_DESCRIPTOR *)SecurityDescriptor)-&gt;Revision
02402          != SECURITY_DESCRIPTOR_REVISION ) {
02403         <span class="keywordflow">return</span> STATUS_UNKNOWN_REVISION;
02404     }
02405 
02406     <span class="comment">// BUGBUG: This is a worthless API.  There is no way to turn any of the bits off.</span>
02407     <span class="comment">// Use the newer RtlSetControlSecurityDescriptor.</span>
02408     Control &amp;= <a class="code" href="../../d8/d6/sertl_8c.html#a2">SE_VALID_CONTROL_BITS</a>;
02409     <span class="keywordflow">return</span> <a class="code" href="../../d8/d6/sertl_8c.html#a59">RtlSetControlSecurityDescriptor</a> ( SecurityDescriptor, Control, Control );
02410 }
02411 
02412 
02413 
02414 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l02415"></a><a class="code" href="../../d8/d6/sertl_8c.html#a58">02415</a> <a class="code" href="../../d8/d6/sertl_8c.html#a58">RtlGetControlSecurityDescriptor</a> (
02416     IN PSECURITY_DESCRIPTOR SecurityDescriptor,
02417     OUT PSECURITY_DESCRIPTOR_CONTROL Control,
02418     OUT PULONG Revision
02419     )
02420 
02421 <span class="comment">/*++</span>
02422 <span class="comment"></span>
02423 <span class="comment">Routine Description:</span>
02424 <span class="comment"></span>
02425 <span class="comment">    This procedure retrieves the control information from a security descriptor.</span>
02426 <span class="comment"></span>
02427 <span class="comment">Arguments:</span>
02428 <span class="comment"></span>
02429 <span class="comment">    SecurityDescriptor - Supplies the security descriptor.</span>
02430 <span class="comment"></span>
02431 <span class="comment">    Control - Receives the control information.</span>
02432 <span class="comment"></span>
02433 <span class="comment">    Revision - Receives the revision of the security descriptor.</span>
02434 <span class="comment">               This value will always be returned, even if an error</span>
02435 <span class="comment">               is returned by this routine.</span>
02436 <span class="comment"></span>
02437 <span class="comment">Return Value:</span>
02438 <span class="comment"></span>
02439 <span class="comment">    STATUS_SUCCESS - Indicates the call completed successfully.</span>
02440 <span class="comment"></span>
02441 <span class="comment">    STATUS_UNKNOWN_REVISION - Indicates the revision of the security</span>
02442 <span class="comment">        descriptor is not known to the routine.  It may be a newer</span>
02443 <span class="comment">        revision than the routine knows about.</span>
02444 <span class="comment"></span>
02445 <span class="comment"></span>
02446 <span class="comment">--*/</span>
02447 
02448 {
02449     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
02450 
02451     <span class="comment">//</span>
02452     <span class="comment">// Always return the revision value - even if this isn't a valid</span>
02453     <span class="comment">// security descriptor</span>
02454     <span class="comment">//</span>
02455 
02456     *Revision = ((SECURITY_DESCRIPTOR *)SecurityDescriptor)-&gt;Revision;
02457 
02458 
02459     <span class="keywordflow">if</span> ( ((SECURITY_DESCRIPTOR *)SecurityDescriptor)-&gt;Revision
02460          != SECURITY_DESCRIPTOR_REVISION ) {
02461         <span class="keywordflow">return</span> STATUS_UNKNOWN_REVISION;
02462     }
02463 
02464 
02465     *Control = ((SECURITY_DESCRIPTOR *)SecurityDescriptor)-&gt;Control;
02466 
02467     <span class="keywordflow">return</span> STATUS_SUCCESS;
02468 
02469 }
02470 
02471 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l02472"></a><a class="code" href="../../d8/d6/sertl_8c.html#a59">02472</a> <a class="code" href="../../d8/d6/sertl_8c.html#a59">RtlSetControlSecurityDescriptor</a> (
02473     IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
02474     IN SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest,
02475     IN SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet
02476     )
02477 <span class="comment">/*++</span>
02478 <span class="comment"></span>
02479 <span class="comment">Routine Description:</span>
02480 <span class="comment"></span>
02481 <span class="comment">    This procedure sets the control information in a security descriptor.</span>
02482 <span class="comment"></span>
02483 <span class="comment"></span>
02484 <span class="comment">    For instance,</span>
02485 <span class="comment"></span>
02486 <span class="comment">        SetSecurityDescriptorControl( &amp;SecDesc,</span>
02487 <span class="comment">                                      SE_DACL_PROTECTED,</span>
02488 <span class="comment">                                      SE_DACL_PROTECTED );</span>
02489 <span class="comment"></span>
02490 <span class="comment">    marks the DACL on the security descriptor as protected. And</span>
02491 <span class="comment"></span>
02492 <span class="comment">        SetSecurityDescriptorControl( &amp;SecDesc,</span>
02493 <span class="comment">                                      SE_DACL_PROTECTED,</span>
02494 <span class="comment">                                      0 );</span>
02495 <span class="comment"></span>
02496 <span class="comment"></span>
02497 <span class="comment">    marks the DACL as not protected.</span>
02498 <span class="comment"></span>
02499 <span class="comment">Arguments:</span>
02500 <span class="comment"></span>
02501 <span class="comment">    pSecurityDescriptor - Supplies the security descriptor.</span>
02502 <span class="comment"></span>
02503 <span class="comment">    ControlBitsOfInterest - A mask of the control bits being changed, set,</span>
02504 <span class="comment">        or reset by this call.  The mask is the logical OR of one or more of</span>
02505 <span class="comment">        the following flags:</span>
02506 <span class="comment"></span>
02507 <span class="comment">            SE_DACL_UNTRUSTED</span>
02508 <span class="comment">            SE_SERVER_SECURITY</span>
02509 <span class="comment">            SE_DACL_AUTO_INHERIT_REQ</span>
02510 <span class="comment">            SE_SACL_AUTO_INHERIT_REQ</span>
02511 <span class="comment">            SE_DACL_AUTO_INHERITED</span>
02512 <span class="comment">            SE_SACL_AUTO_INHERITED</span>
02513 <span class="comment">            SE_DACL_PROTECTED</span>
02514 <span class="comment">            SE_SACL_PROTECTED</span>
02515 <span class="comment"></span>
02516 <span class="comment">    ControlBitsToSet - A mask indicating what the bits specified by ControlBitsOfInterest</span>
02517 <span class="comment">        should be set to.</span>
02518 <span class="comment"></span>
02519 <span class="comment">Return Value:</span>
02520 <span class="comment"></span>
02521 <span class="comment">    Returns TRUE for success, FALSE for failure.  Extended error status</span>
02522 <span class="comment">    is available using GetLastError.</span>
02523 <span class="comment"></span>
02524 <span class="comment">--*/</span>
02525 {
02526     <span class="comment">//</span>
02527     <span class="comment">// Ensure the caller passed valid bits.</span>
02528     <span class="comment">//</span>
02529 
02530     <span class="keywordflow">if</span> ( (ControlBitsOfInterest &amp; ~<a class="code" href="../../d8/d6/sertl_8c.html#a2">SE_VALID_CONTROL_BITS</a>) != 0 ||
02531          (ControlBitsToSet &amp; ~ControlBitsOfInterest) != 0 ) {
02532         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
02533     }
02534 
02535     ((SECURITY_DESCRIPTOR *)pSecurityDescriptor)-&gt;Control &amp;= ~ControlBitsOfInterest;
02536     ((SECURITY_DESCRIPTOR *)pSecurityDescriptor)-&gt;Control |= ControlBitsToSet;
02537 
02538     <span class="keywordflow">return</span> STATUS_SUCCESS;
02539 }
02540 
02541 
02542 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l02543"></a><a class="code" href="../../d8/d6/sertl_8c.html#a60">02543</a> <a class="code" href="../../d8/d6/sertl_8c.html#a60">RtlSetDaclSecurityDescriptor</a> (
02544     IN PSECURITY_DESCRIPTOR SecurityDescriptor,
02545     IN BOOLEAN DaclPresent,
02546     IN PACL Dacl OPTIONAL,
02547     IN BOOLEAN DaclDefaulted OPTIONAL
02548     )
02549 
02550 <span class="comment">/*++</span>
02551 <span class="comment"></span>
02552 <span class="comment">Routine Description:</span>
02553 <span class="comment"></span>
02554 <span class="comment">    This procedure sets the discretionary ACL information of an absolute</span>
02555 <span class="comment">    format security descriptor.  If there is already a discretionary ACL</span>
02556 <span class="comment">    present in the security descriptor, it is superseded.</span>
02557 <span class="comment"></span>
02558 <span class="comment">Arguments:</span>
02559 <span class="comment"></span>
02560 <span class="comment">    SecurityDescriptor - Supplies the security descriptor to be which</span>
02561 <span class="comment">        the discretionary ACL is to be added.</span>
02562 <span class="comment"></span>
02563 <span class="comment">    DaclPresent - If FALSE, indicates the DaclPresent flag in the</span>
02564 <span class="comment">        security descriptor should be set to FALSE.  In this case,</span>
02565 <span class="comment">        the remaining optional parameters are ignored.  Otherwise,</span>
02566 <span class="comment">        the DaclPresent control flag in the security descriptor is</span>
02567 <span class="comment">        set to TRUE and the remaining optional parameters are not</span>
02568 <span class="comment">        ignored.</span>
02569 <span class="comment"></span>
02570 <span class="comment">    Dacl - Supplies the discretionary ACL for the security</span>
02571 <span class="comment">        descriptor.  If this optional parameter is not passed, then a</span>
02572 <span class="comment">        null ACL is assigned to the security descriptor.  A null</span>
02573 <span class="comment">        discretionary ACL unconditionally grants access.  The ACL is</span>
02574 <span class="comment">        referenced by, not copied into, by the security descriptor.</span>
02575 <span class="comment"></span>
02576 <span class="comment">    DaclDefaulted - When set, indicates the discretionary ACL was</span>
02577 <span class="comment">        picked up from some default mechanism (rather than explicitly</span>
02578 <span class="comment">        specified by a user).  This value is set in the DaclDefaulted</span>
02579 <span class="comment">        control flag in the security descriptor.  If this optional</span>
02580 <span class="comment">        parameter is not passed, then the DaclDefaulted flag will be</span>
02581 <span class="comment">        cleared.</span>
02582 <span class="comment"></span>
02583 <span class="comment">Return Value:</span>
02584 <span class="comment"></span>
02585 <span class="comment">    STATUS_SUCCESS - Indicates the call completed successfully.</span>
02586 <span class="comment"></span>
02587 <span class="comment">    STATUS_UNKNOWN_REVISION - Indicates the revision of the security</span>
02588 <span class="comment">        descriptor is not known to the routine.  It may be a newer</span>
02589 <span class="comment">        revision than the routine knows about.</span>
02590 <span class="comment"></span>
02591 <span class="comment">    STATUS_INVALID_SECURITY_DESCR - Indicates the security descriptor</span>
02592 <span class="comment">        is not an absolute format security descriptor.</span>
02593 <span class="comment"></span>
02594 <span class="comment"></span>
02595 <span class="comment">--*/</span>
02596 
02597 {
02598 
02599     <span class="comment">//</span>
02600     <span class="comment">// Typecast to the opaque SECURITY_DESCRIPTOR structure.</span>
02601     <span class="comment">//</span>
02602 
02603     SECURITY_DESCRIPTOR *ISecurityDescriptor = SecurityDescriptor;
02604 
02605     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
02606 
02607     <span class="comment">//</span>
02608     <span class="comment">// Check the revision</span>
02609     <span class="comment">//</span>
02610 
02611     <span class="keywordflow">if</span> (ISecurityDescriptor-&gt;Revision != SECURITY_DESCRIPTOR_REVISION) {
02612        <span class="keywordflow">return</span> STATUS_UNKNOWN_REVISION;
02613     }
02614 
02615     <span class="comment">//</span>
02616     <span class="comment">// Make sure the descriptor is absolute format</span>
02617     <span class="comment">//</span>
02618 
02619     <span class="keywordflow">if</span> (ISecurityDescriptor-&gt;Control &amp; SE_SELF_RELATIVE) {
02620         <span class="keywordflow">return</span> STATUS_INVALID_SECURITY_DESCR;
02621     }
02622 
02623     <span class="comment">//</span>
02624     <span class="comment">// Assign the DaclPresent flag value passed</span>
02625     <span class="comment">//</span>
02626 
02627 
02628     <span class="keywordflow">if</span> (DaclPresent) {
02629 
02630         ISecurityDescriptor-&gt;Control |= SE_DACL_PRESENT;
02631 
02632         <span class="comment">//</span>
02633         <span class="comment">// Assign the ACL address if passed, otherwise set to null.</span>
02634         <span class="comment">//</span>
02635 
02636         ISecurityDescriptor-&gt;Dacl = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02637         <span class="keywordflow">if</span> (ARGUMENT_PRESENT(<a class="code" href="../../d6/d0/ctaccess_8c.html#a55">Dacl</a>)) {
02638             ISecurityDescriptor-&gt;Dacl = <a class="code" href="../../d6/d0/ctaccess_8c.html#a55">Dacl</a>;
02639         }
02640 
02641 
02642 
02643 
02644         <span class="comment">//</span>
02645         <span class="comment">// Assign DaclDefaulted flag if passed, otherwise clear it.</span>
02646         <span class="comment">//</span>
02647 
02648         ISecurityDescriptor-&gt;Control &amp;= ~SE_DACL_DEFAULTED;
02649         <span class="keywordflow">if</span> (DaclDefaulted == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
02650             ISecurityDescriptor-&gt;Control |= SE_DACL_DEFAULTED;
02651         }
02652     } <span class="keywordflow">else</span> {
02653 
02654         ISecurityDescriptor-&gt;Control &amp;= ~SE_DACL_PRESENT;
02655 
02656     }
02657 
02658 
02659     <span class="keywordflow">return</span> STATUS_SUCCESS;
02660 
02661 }
02662 
02663 
02664 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l02665"></a><a class="code" href="../../d8/d6/sertl_8c.html#a61">02665</a> <a class="code" href="../../d8/d6/sertl_8c.html#a61">RtlGetDaclSecurityDescriptor</a> (
02666     IN PSECURITY_DESCRIPTOR SecurityDescriptor,
02667     OUT PBOOLEAN DaclPresent,
02668     OUT PACL *Dacl,
02669     OUT PBOOLEAN DaclDefaulted
02670     )
02671 
02672 <span class="comment">/*++</span>
02673 <span class="comment"></span>
02674 <span class="comment">Routine Description:</span>
02675 <span class="comment"></span>
02676 <span class="comment">    This procedure retrieves the discretionary ACL information of a</span>
02677 <span class="comment">    security descriptor.</span>
02678 <span class="comment"></span>
02679 <span class="comment">Arguments:</span>
02680 <span class="comment"></span>
02681 <span class="comment">    SecurityDescriptor - Supplies the security descriptor.</span>
02682 <span class="comment"></span>
02683 <span class="comment">    DaclPresent - If TRUE, indicates that the security descriptor</span>
02684 <span class="comment">        does contain a discretionary ACL.  In this case, the</span>
02685 <span class="comment">        remaining OUT parameters will receive valid values.</span>
02686 <span class="comment">        Otherwise, the security descriptor does not contain a</span>
02687 <span class="comment">        discretionary ACL and the remaining OUT parameters will not</span>
02688 <span class="comment">        receive valid values.</span>
02689 <span class="comment"></span>
02690 <span class="comment">    Dacl - This value is returned only if the value returned for the</span>
02691 <span class="comment">        DaclPresent flag is TRUE.  In this case, the Dacl parameter</span>
02692 <span class="comment">        receives the address of the security descriptor's</span>
02693 <span class="comment">        discretionary ACL.  If this value is returned as null, then</span>
02694 <span class="comment">        the security descriptor has a null discretionary ACL.</span>
02695 <span class="comment"></span>
02696 <span class="comment">    DaclDefaulted - This value is returned only if the value returned</span>
02697 <span class="comment">        for the DaclPresent flag is TRUE.  In this case, the</span>
02698 <span class="comment">        DaclDefaulted parameter receives the value of the security</span>
02699 <span class="comment">        descriptor's DaclDefaulted control flag.</span>
02700 <span class="comment"></span>
02701 <span class="comment">Return Value:</span>
02702 <span class="comment"></span>
02703 <span class="comment">    STATUS_SUCCESS - Indicates the call completed successfully.</span>
02704 <span class="comment"></span>
02705 <span class="comment">    STATUS_UNKNOWN_REVISION - Indicates the revision of the security</span>
02706 <span class="comment">        descriptor is not known to the routine.  It may be a newer</span>
02707 <span class="comment">        revision than the routine knows about.</span>
02708 <span class="comment"></span>
02709 <span class="comment"></span>
02710 <span class="comment">--*/</span>
02711 
02712 {
02713     <span class="comment">//</span>
02714     <span class="comment">// Typecast to the opaque SECURITY_DESCRIPTOR structure.</span>
02715     <span class="comment">//</span>
02716 
02717     SECURITY_DESCRIPTOR *ISecurityDescriptor = SecurityDescriptor;
02718 
02719     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
02720 
02721     <span class="comment">//</span>
02722     <span class="comment">// Check the revision</span>
02723     <span class="comment">//</span>
02724 
02725     <span class="keywordflow">if</span> (ISecurityDescriptor-&gt;Revision != SECURITY_DESCRIPTOR_REVISION) {
02726         <span class="keywordflow">return</span> STATUS_UNKNOWN_REVISION;
02727     }
02728 
02729     <span class="comment">//</span>
02730     <span class="comment">// Assign the DaclPresent flag value</span>
02731     <span class="comment">//</span>
02732 
02733     *DaclPresent = RtlpAreControlBitsSet( ISecurityDescriptor, SE_DACL_PRESENT );
02734 
02735     <span class="keywordflow">if</span> (*DaclPresent) {
02736 
02737         <span class="comment">//</span>
02738         <span class="comment">// Assign the ACL address.</span>
02739         <span class="comment">//</span>
02740 
02741         *<a class="code" href="../../d6/d0/ctaccess_8c.html#a55">Dacl</a> = RtlpDaclAddrSecurityDescriptor(ISecurityDescriptor);
02742 
02743         <span class="comment">//</span>
02744         <span class="comment">// Assign DaclDefaulted flag.</span>
02745         <span class="comment">//</span>
02746 
02747         *DaclDefaulted = RtlpAreControlBitsSet( ISecurityDescriptor, SE_DACL_DEFAULTED );
02748     }
02749 
02750     <span class="keywordflow">return</span> STATUS_SUCCESS;
02751 
02752 }
02753 
02754 
02755 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l02756"></a><a class="code" href="../../d8/d6/sertl_8c.html#a62">02756</a> <a class="code" href="../../d8/d6/sertl_8c.html#a62">RtlSetSaclSecurityDescriptor</a> (
02757     IN PSECURITY_DESCRIPTOR SecurityDescriptor,
02758     IN BOOLEAN SaclPresent,
02759     IN PACL Sacl OPTIONAL,
02760     IN BOOLEAN SaclDefaulted OPTIONAL
02761     )
02762 
02763 <span class="comment">/*++</span>
02764 <span class="comment"></span>
02765 <span class="comment">Routine Description:</span>
02766 <span class="comment"></span>
02767 <span class="comment">    This procedure sets the system ACL information of an absolute security</span>
02768 <span class="comment">    descriptor.  If there is already a system ACL present in the</span>
02769 <span class="comment">    security descriptor, it is superseded.</span>
02770 <span class="comment"></span>
02771 <span class="comment">Arguments:</span>
02772 <span class="comment"></span>
02773 <span class="comment">    SecurityDescriptor - Supplies the security descriptor to be which</span>
02774 <span class="comment">        the system ACL is to be added.</span>
02775 <span class="comment"></span>
02776 <span class="comment">    SaclPresent - If FALSE, indicates the SaclPresent flag in the</span>
02777 <span class="comment">        security descriptor should be set to FALSE.  In this case,</span>
02778 <span class="comment">        the remaining optional parameters are ignored.  Otherwise,</span>
02779 <span class="comment">        the SaclPresent control flag in the security descriptor is</span>
02780 <span class="comment">        set to TRUE and the remaining optional parameters are not</span>
02781 <span class="comment">        ignored.</span>
02782 <span class="comment"></span>
02783 <span class="comment">    Sacl - Supplies the system ACL for the security descriptor.  If</span>
02784 <span class="comment">        this optional parameter is not passed, then a null ACL is</span>
02785 <span class="comment">        assigned to the security descriptor.  The ACL is referenced</span>
02786 <span class="comment">        by, not copied into, by the security descriptor.</span>
02787 <span class="comment"></span>
02788 <span class="comment">    SaclDefaulted - When set, indicates the system ACL was picked up</span>
02789 <span class="comment">        from some default mechanism (rather than explicitly specified</span>
02790 <span class="comment">        by a user).  This value is set in the SaclDefaulted control</span>
02791 <span class="comment">        flag in the security descriptor.  If this optional parameter</span>
02792 <span class="comment">        is not passed, then the SaclDefaulted flag will be cleared.</span>
02793 <span class="comment"></span>
02794 <span class="comment">Return Value:</span>
02795 <span class="comment"></span>
02796 <span class="comment">    STATUS_SUCCESS - Indicates the call completed successfully.</span>
02797 <span class="comment"></span>
02798 <span class="comment">    STATUS_UNKNOWN_REVISION - Indicates the revision of the security</span>
02799 <span class="comment">        descriptor is not known to the routine.  It may be a newer</span>
02800 <span class="comment">        revision than the routine knows about.</span>
02801 <span class="comment"></span>
02802 <span class="comment">    STATUS_INVALID_SECURITY_DESCR - Indicates the security descriptor</span>
02803 <span class="comment">        is not an absolute format security descriptor.</span>
02804 <span class="comment"></span>
02805 <span class="comment"></span>
02806 <span class="comment">--*/</span>
02807 
02808 {
02809 
02810     <span class="comment">//</span>
02811     <span class="comment">// Typecast to the opaque SECURITY_DESCRIPTOR structure.</span>
02812     <span class="comment">//</span>
02813 
02814     SECURITY_DESCRIPTOR *ISecurityDescriptor = SecurityDescriptor;
02815 
02816     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
02817 
02818     <span class="comment">//</span>
02819     <span class="comment">// Check the revision</span>
02820     <span class="comment">//</span>
02821 
02822     <span class="keywordflow">if</span> (ISecurityDescriptor-&gt;Revision != SECURITY_DESCRIPTOR_REVISION) {
02823         <span class="keywordflow">return</span> STATUS_UNKNOWN_REVISION;
02824     }
02825 
02826     <span class="comment">//</span>
02827     <span class="comment">// Make sure the descriptor is absolute format</span>
02828     <span class="comment">//</span>
02829 
02830     <span class="keywordflow">if</span> (ISecurityDescriptor-&gt;Control &amp; SE_SELF_RELATIVE) {
02831         <span class="keywordflow">return</span> STATUS_INVALID_SECURITY_DESCR;
02832     }
02833 
02834     <span class="comment">//</span>
02835     <span class="comment">// Assign the SaclPresent flag value passed</span>
02836     <span class="comment">//</span>
02837 
02838 
02839     <span class="keywordflow">if</span> (SaclPresent) {
02840 
02841         ISecurityDescriptor-&gt;Control |= SE_SACL_PRESENT;
02842 
02843         <span class="comment">//</span>
02844         <span class="comment">// Assign the ACL address if passed, otherwise set to null.</span>
02845         <span class="comment">//</span>
02846 
02847         ISecurityDescriptor-&gt;Sacl = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02848         <span class="keywordflow">if</span> (ARGUMENT_PRESENT(Sacl)) {
02849            ISecurityDescriptor-&gt;Sacl = Sacl;
02850         }
02851 
02852         <span class="comment">//</span>
02853         <span class="comment">// Assign SaclDefaulted flag if passed, otherwise clear it.</span>
02854         <span class="comment">//</span>
02855 
02856         ISecurityDescriptor-&gt;Control &amp;= ~ SE_SACL_DEFAULTED;
02857         <span class="keywordflow">if</span> (ARGUMENT_PRESENT(SaclDefaulted)) {
02858             ISecurityDescriptor-&gt;Control |= SE_SACL_DEFAULTED;
02859         }
02860     } <span class="keywordflow">else</span> {
02861 
02862         ISecurityDescriptor-&gt;Control &amp;= ~SE_SACL_PRESENT;
02863     }
02864 
02865     <span class="keywordflow">return</span> STATUS_SUCCESS;
02866 
02867 }
02868 
02869 
02870 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l02871"></a><a class="code" href="../../d8/d6/sertl_8c.html#a63">02871</a> <a class="code" href="../../d8/d6/sertl_8c.html#a63">RtlGetSaclSecurityDescriptor</a> (
02872     IN PSECURITY_DESCRIPTOR SecurityDescriptor,
02873     OUT PBOOLEAN SaclPresent,
02874     OUT PACL *Sacl,
02875     OUT PBOOLEAN SaclDefaulted
02876     )
02877 
02878 <span class="comment">/*++</span>
02879 <span class="comment"></span>
02880 <span class="comment">Routine Description:</span>
02881 <span class="comment"></span>
02882 <span class="comment">    This procedure retrieves the system ACL information of a security</span>
02883 <span class="comment">    descriptor.</span>
02884 <span class="comment"></span>
02885 <span class="comment">Arguments:</span>
02886 <span class="comment"></span>
02887 <span class="comment">    SecurityDescriptor - Supplies the security descriptor.</span>
02888 <span class="comment"></span>
02889 <span class="comment">    SaclPresent - If TRUE, indicates that the security descriptor</span>
02890 <span class="comment">        does contain a system ACL.  In this case, the remaining OUT</span>
02891 <span class="comment">        parameters will receive valid values.  Otherwise, the</span>
02892 <span class="comment">        security descriptor does not contain a system ACL and the</span>
02893 <span class="comment">        remaining OUT parameters will not receive valid values.</span>
02894 <span class="comment"></span>
02895 <span class="comment">    Sacl - This value is returned only if the value returned for the</span>
02896 <span class="comment">        SaclPresent flag is TRUE.  In this case, the Sacl parameter</span>
02897 <span class="comment">        receives the address of the security descriptor's system ACL.</span>
02898 <span class="comment">        If this value is returned as null, then the security</span>
02899 <span class="comment">        descriptor has a null system ACL.</span>
02900 <span class="comment"></span>
02901 <span class="comment">    SaclDefaulted - This value is returned only if the value returned</span>
02902 <span class="comment">        for the SaclPresent flag is TRUE.  In this case, the</span>
02903 <span class="comment">        SaclDefaulted parameter receives the value of the security</span>
02904 <span class="comment">        descriptor's SaclDefaulted control flag.</span>
02905 <span class="comment"></span>
02906 <span class="comment">Return Value:</span>
02907 <span class="comment"></span>
02908 <span class="comment">    STATUS_SUCCESS - Indicates the call completed successfully.</span>
02909 <span class="comment"></span>
02910 <span class="comment">    STATUS_UNKNOWN_REVISION - Indicates the revision of the security</span>
02911 <span class="comment">        descriptor is not known to the routine.  It may be a newer</span>
02912 <span class="comment">        revision than the routine knows about.</span>
02913 <span class="comment"></span>
02914 <span class="comment"></span>
02915 <span class="comment">--*/</span>
02916 
02917 {
02918 
02919     <span class="comment">//</span>
02920     <span class="comment">// Typecast to the opaque SECURITY_DESCRIPTOR structure.</span>
02921     <span class="comment">//</span>
02922 
02923     SECURITY_DESCRIPTOR *ISecurityDescriptor = SecurityDescriptor;
02924 
02925     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
02926 
02927     <span class="comment">//</span>
02928     <span class="comment">// Check the revision</span>
02929     <span class="comment">//</span>
02930 
02931     <span class="keywordflow">if</span> (ISecurityDescriptor-&gt;Revision != SECURITY_DESCRIPTOR_REVISION) {
02932         <span class="keywordflow">return</span> STATUS_UNKNOWN_REVISION;
02933     }
02934 
02935     <span class="comment">//</span>
02936     <span class="comment">// Assign the SaclPresent flag value</span>
02937     <span class="comment">//</span>
02938 
02939     *SaclPresent = RtlpAreControlBitsSet( ISecurityDescriptor, SE_SACL_PRESENT );
02940 
02941     <span class="keywordflow">if</span> (*SaclPresent) {
02942 
02943         <span class="comment">//</span>
02944         <span class="comment">// Assign the ACL address.</span>
02945         <span class="comment">//</span>
02946 
02947         *Sacl = RtlpSaclAddrSecurityDescriptor(ISecurityDescriptor);
02948 
02949         <span class="comment">//</span>
02950         <span class="comment">// Assign SaclDefaulted flag.</span>
02951         <span class="comment">//</span>
02952 
02953         *SaclDefaulted = RtlpAreControlBitsSet( ISecurityDescriptor, SE_SACL_DEFAULTED );
02954 
02955     }
02956 
02957     <span class="keywordflow">return</span> STATUS_SUCCESS;
02958 
02959 }
02960 
02961 
02962 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l02963"></a><a class="code" href="../../d8/d6/sertl_8c.html#a64">02963</a> <a class="code" href="../../d8/d6/sertl_8c.html#a64">RtlSetOwnerSecurityDescriptor</a> (
02964     IN PSECURITY_DESCRIPTOR SecurityDescriptor,
02965     IN PSID Owner OPTIONAL,
02966     IN BOOLEAN OwnerDefaulted OPTIONAL
02967     )
02968 
02969 <span class="comment">/*++</span>
02970 <span class="comment"></span>
02971 <span class="comment">Routine Description:</span>
02972 <span class="comment"></span>
02973 <span class="comment">    This procedure sets the owner information of an absolute security</span>
02974 <span class="comment">    descriptor.  If there is already an owner present in the security</span>
02975 <span class="comment">    descriptor, it is superseded.</span>
02976 <span class="comment"></span>
02977 <span class="comment">Arguments:</span>
02978 <span class="comment"></span>
02979 <span class="comment">    SecurityDescriptor - Supplies the security descriptor in which</span>
02980 <span class="comment">        the owner is to be set.  If the security descriptor already</span>
02981 <span class="comment">        includes an owner, it will be superseded by the new owner.</span>
02982 <span class="comment"></span>
02983 <span class="comment">    Owner - Supplies the owner SID for the security descriptor.  If</span>
02984 <span class="comment">        this optional parameter is not passed, then the owner is</span>
02985 <span class="comment">        cleared (indicating the security descriptor has no owner).</span>
02986 <span class="comment">        The SID is referenced by, not copied into, the security</span>
02987 <span class="comment">        descriptor.</span>
02988 <span class="comment"></span>
02989 <span class="comment">    OwnerDefaulted - When set, indicates the owner was picked up from</span>
02990 <span class="comment">        some default mechanism (rather than explicitly specified by a</span>
02991 <span class="comment">        user).  This value is set in the OwnerDefaulted control flag</span>
02992 <span class="comment">        in the security descriptor.  If this optional parameter is</span>
02993 <span class="comment">        not passed, then the SaclDefaulted flag will be cleared.</span>
02994 <span class="comment"></span>
02995 <span class="comment">Return Value:</span>
02996 <span class="comment"></span>
02997 <span class="comment">    STATUS_SUCCESS - Indicates the call completed successfully.</span>
02998 <span class="comment"></span>
02999 <span class="comment">    STATUS_UNKNOWN_REVISION - Indicates the revision of the security</span>
03000 <span class="comment">        descriptor is not known to the routine.  It may be a newer</span>
03001 <span class="comment">        revision than the routine knows about.</span>
03002 <span class="comment"></span>
03003 <span class="comment">    STATUS_INVALID_SECURITY_DESCR - Indicates the security descriptor</span>
03004 <span class="comment">        is not an absolute format security descriptor.</span>
03005 <span class="comment"></span>
03006 <span class="comment"></span>
03007 <span class="comment">--*/</span>
03008 
03009 {
03010 
03011     <span class="comment">//</span>
03012     <span class="comment">// Typecast to the opaque SECURITY_DESCRIPTOR structure.</span>
03013     <span class="comment">//</span>
03014 
03015     SECURITY_DESCRIPTOR *ISecurityDescriptor = SecurityDescriptor;
03016 
03017     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
03018 
03019     <span class="comment">//</span>
03020     <span class="comment">// Check the revision</span>
03021     <span class="comment">//</span>
03022 
03023     <span class="keywordflow">if</span> (ISecurityDescriptor-&gt;Revision != SECURITY_DESCRIPTOR_REVISION) {
03024         <span class="keywordflow">return</span> STATUS_UNKNOWN_REVISION;
03025     }
03026 
03027     <span class="comment">//</span>
03028     <span class="comment">// Make sure the descriptor is absolute format</span>
03029     <span class="comment">//</span>
03030 
03031     <span class="keywordflow">if</span> (ISecurityDescriptor-&gt;Control &amp; SE_SELF_RELATIVE) {
03032         <span class="keywordflow">return</span> STATUS_INVALID_SECURITY_DESCR;
03033     }
03034 
03035     <span class="comment">//</span>
03036     <span class="comment">// Assign the Owner field if passed, otherwise clear it.</span>
03037     <span class="comment">//</span>
03038 
03039     ISecurityDescriptor-&gt;Owner = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03040     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(<a class="code" href="../../d6/d0/ctaccess_8c.html#a53">Owner</a>)) {
03041         ISecurityDescriptor-&gt;Owner = <a class="code" href="../../d6/d0/ctaccess_8c.html#a53">Owner</a>;
03042     }
03043 
03044     <span class="comment">//</span>
03045     <span class="comment">// Assign the OwnerDefaulted flag if passed, otherwise clear it.</span>
03046     <span class="comment">//</span>
03047 
03048     ISecurityDescriptor-&gt;Control &amp;= ~SE_OWNER_DEFAULTED;
03049     <span class="keywordflow">if</span> (OwnerDefaulted == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
03050         ISecurityDescriptor-&gt;Control |= SE_OWNER_DEFAULTED;
03051     }
03052 
03053     <span class="keywordflow">return</span> STATUS_SUCCESS;
03054 
03055 }
03056 
03057 
03058 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l03059"></a><a class="code" href="../../d8/d6/sertl_8c.html#a65">03059</a> <a class="code" href="../../d8/d6/sertl_8c.html#a65">RtlGetOwnerSecurityDescriptor</a> (
03060     IN PSECURITY_DESCRIPTOR SecurityDescriptor,
03061     OUT PSID *Owner,
03062     OUT PBOOLEAN OwnerDefaulted
03063     )
03064 
03065 <span class="comment">/*++</span>
03066 <span class="comment"></span>
03067 <span class="comment">Routine Description:</span>
03068 <span class="comment"></span>
03069 <span class="comment">    This procedure retrieves the owner information of a security</span>
03070 <span class="comment">    descriptor.</span>
03071 <span class="comment"></span>
03072 <span class="comment">Arguments:</span>
03073 <span class="comment"></span>
03074 <span class="comment">    SecurityDescriptor - Supplies the security descriptor.</span>
03075 <span class="comment"></span>
03076 <span class="comment">    Owner - Receives a pointer to the owner SID.  If the security</span>
03077 <span class="comment">        descriptor does not currently contain an owner, then this</span>
03078 <span class="comment">        value will be returned as null.  In this case, the remaining</span>
03079 <span class="comment">        OUT parameters are not given valid return values.  Otherwise,</span>
03080 <span class="comment">        this parameter points to an SID and the remaining OUT</span>
03081 <span class="comment">        parameters are provided valid return values.</span>
03082 <span class="comment"></span>
03083 <span class="comment">    OwnerDefaulted - This value is returned only if the value</span>
03084 <span class="comment">        returned for the Owner parameter is not null.  In this case,</span>
03085 <span class="comment">        the OwnerDefaulted parameter receives the value of the</span>
03086 <span class="comment">        security descriptor's OwnerDefaulted control flag.</span>
03087 <span class="comment"></span>
03088 <span class="comment">Return Value:</span>
03089 <span class="comment"></span>
03090 <span class="comment">    STATUS_SUCCESS - Indicates the call completed successfully.</span>
03091 <span class="comment"></span>
03092 <span class="comment">    STATUS_UNKNOWN_REVISION - Indicates the revision of the security</span>
03093 <span class="comment">        descriptor is not known to the routine.  It may be a newer</span>
03094 <span class="comment">        revision than the routine knows about.</span>
03095 <span class="comment"></span>
03096 <span class="comment"></span>
03097 <span class="comment">--*/</span>
03098 
03099 {
03100 
03101     <span class="comment">//</span>
03102     <span class="comment">// Typecast to the opaque SECURITY_DESCRIPTOR structure.</span>
03103     <span class="comment">//</span>
03104 
03105     SECURITY_DESCRIPTOR *ISecurityDescriptor = SecurityDescriptor;
03106 
03107     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
03108 
03109     <span class="comment">//</span>
03110     <span class="comment">// Check the revision</span>
03111     <span class="comment">//</span>
03112 
03113     <span class="keywordflow">if</span> (ISecurityDescriptor-&gt;Revision != SECURITY_DESCRIPTOR_REVISION) {
03114         <span class="keywordflow">return</span> STATUS_UNKNOWN_REVISION;
03115     }
03116 
03117     <span class="comment">//</span>
03118     <span class="comment">// Return the Owner field value.</span>
03119     <span class="comment">//</span>
03120 
03121     *<a class="code" href="../../d6/d0/ctaccess_8c.html#a53">Owner</a> = RtlpOwnerAddrSecurityDescriptor(ISecurityDescriptor);
03122 
03123     <span class="comment">//</span>
03124     <span class="comment">// Return the OwnerDefaulted flag value.</span>
03125     <span class="comment">//</span>
03126 
03127     *OwnerDefaulted = RtlpAreControlBitsSet( ISecurityDescriptor, SE_OWNER_DEFAULTED );
03128 
03129     <span class="keywordflow">return</span> STATUS_SUCCESS;
03130 
03131 }
03132 
03133 
03134 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l03135"></a><a class="code" href="../../d8/d6/sertl_8c.html#a66">03135</a> <a class="code" href="../../d8/d6/sertl_8c.html#a66">RtlSetGroupSecurityDescriptor</a> (
03136     IN PSECURITY_DESCRIPTOR SecurityDescriptor,
03137     IN PSID Group OPTIONAL,
03138     IN BOOLEAN GroupDefaulted OPTIONAL
03139     )
03140 
03141 <span class="comment">/*++</span>
03142 <span class="comment"></span>
03143 <span class="comment">Routine Description:</span>
03144 <span class="comment"></span>
03145 <span class="comment">    This procedure sets the primary group information of an absolute security</span>
03146 <span class="comment">    descriptor.  If there is already an primary group present in the</span>
03147 <span class="comment">    security descriptor, it is superseded.</span>
03148 <span class="comment"></span>
03149 <span class="comment">Arguments:</span>
03150 <span class="comment"></span>
03151 <span class="comment">    SecurityDescriptor - Supplies the security descriptor in which</span>
03152 <span class="comment">        the primary group is to be set.  If the security descriptor</span>
03153 <span class="comment">        already includes a primary group, it will be superseded by</span>
03154 <span class="comment">        the new group.</span>
03155 <span class="comment"></span>
03156 <span class="comment">    Group - Supplies the primary group SID for the security</span>
03157 <span class="comment">        descriptor.  If this optional parameter is not passed, then</span>
03158 <span class="comment">        the primary group is cleared (indicating the security</span>
03159 <span class="comment">        descriptor has no primary group).  The SID is referenced by,</span>
03160 <span class="comment">        not copied into, the security descriptor.</span>
03161 <span class="comment"></span>
03162 <span class="comment">    GroupDefaulted - When set, indicates the owner was picked up from</span>
03163 <span class="comment">        some default mechanism (rather than explicitly specified by a</span>
03164 <span class="comment">        user).  This value is set in the OwnerDefaulted control flag</span>
03165 <span class="comment">        in the security descriptor.  If this optional parameter is</span>
03166 <span class="comment">        not passed, then the SaclDefaulted flag will be cleared.</span>
03167 <span class="comment"></span>
03168 <span class="comment">Return Value:</span>
03169 <span class="comment"></span>
03170 <span class="comment">    STATUS_SUCCESS - Indicates the call completed successfully.</span>
03171 <span class="comment"></span>
03172 <span class="comment">    STATUS_UNKNOWN_REVISION - Indicates the revision of the security</span>
03173 <span class="comment">        descriptor is not known to the routine.  It may be a newer</span>
03174 <span class="comment">        revision than the routine knows about.</span>
03175 <span class="comment"></span>
03176 <span class="comment">    STATUS_INVALID_SECURITY_DESCR - Indicates the security descriptor</span>
03177 <span class="comment">        is not an absolute format security descriptor.</span>
03178 <span class="comment"></span>
03179 <span class="comment"></span>
03180 <span class="comment">--*/</span>
03181 
03182 {
03183 
03184     <span class="comment">//</span>
03185     <span class="comment">// Typecast to the opaque SECURITY_DESCRIPTOR structure.</span>
03186     <span class="comment">//</span>
03187 
03188     SECURITY_DESCRIPTOR *ISecurityDescriptor = SecurityDescriptor;
03189 
03190     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
03191 
03192     <span class="comment">//</span>
03193     <span class="comment">// Check the revision</span>
03194     <span class="comment">//</span>
03195 
03196     <span class="keywordflow">if</span> (ISecurityDescriptor-&gt;Revision != SECURITY_DESCRIPTOR_REVISION) {
03197         <span class="keywordflow">return</span> STATUS_UNKNOWN_REVISION;
03198     }
03199 
03200     <span class="comment">//</span>
03201     <span class="comment">// Make sure the descriptor is absolute format</span>
03202     <span class="comment">//</span>
03203 
03204     <span class="keywordflow">if</span> (ISecurityDescriptor-&gt;Control &amp; SE_SELF_RELATIVE) {
03205         <span class="keywordflow">return</span> STATUS_INVALID_SECURITY_DESCR;
03206     }
03207 
03208     <span class="comment">//</span>
03209     <span class="comment">// Assign the Group field if passed, otherwise clear it.</span>
03210     <span class="comment">//</span>
03211 
03212     ISecurityDescriptor-&gt;Group = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03213     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(<a class="code" href="../../d6/d0/ctaccess_8c.html#a54">Group</a>)) {
03214         ISecurityDescriptor-&gt;Group = <a class="code" href="../../d6/d0/ctaccess_8c.html#a54">Group</a>;
03215     }
03216 
03217     <span class="comment">//</span>
03218     <span class="comment">// Assign the GroupDefaulted flag if passed, otherwise clear it.</span>
03219     <span class="comment">//</span>
03220 
03221     ISecurityDescriptor-&gt;Control &amp;= ~SE_GROUP_DEFAULTED;
03222     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(GroupDefaulted)) {
03223         ISecurityDescriptor-&gt;Control |= SE_GROUP_DEFAULTED;
03224     }
03225 
03226     <span class="keywordflow">return</span> STATUS_SUCCESS;
03227 
03228 }
03229 
03230 
03231 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l03232"></a><a class="code" href="../../d8/d6/sertl_8c.html#a67">03232</a> <a class="code" href="../../d8/d6/sertl_8c.html#a67">RtlGetGroupSecurityDescriptor</a> (
03233     IN PSECURITY_DESCRIPTOR SecurityDescriptor,
03234     OUT PSID *Group,
03235     OUT PBOOLEAN GroupDefaulted
03236     )
03237 
03238 <span class="comment">/*++</span>
03239 <span class="comment"></span>
03240 <span class="comment">Routine Description:</span>
03241 <span class="comment"></span>
03242 <span class="comment">    This procedure retrieves the primary group information of a</span>
03243 <span class="comment">    security descriptor.</span>
03244 <span class="comment"></span>
03245 <span class="comment">Arguments:</span>
03246 <span class="comment"></span>
03247 <span class="comment">    SecurityDescriptor - Supplies the security descriptor.</span>
03248 <span class="comment"></span>
03249 <span class="comment">    Group - Receives a pointer to the primary group SID.  If the</span>
03250 <span class="comment">        security descriptor does not currently contain a primary</span>
03251 <span class="comment">        group, then this value will be returned as null.  In this</span>
03252 <span class="comment">        case, the remaining OUT parameters are not given valid return</span>
03253 <span class="comment">        values.  Otherwise, this parameter points to an SID and the</span>
03254 <span class="comment">        remaining OUT parameters are provided valid return values.</span>
03255 <span class="comment"></span>
03256 <span class="comment">    GroupDefaulted - This value is returned only if the value</span>
03257 <span class="comment">        returned for the Group parameter is not null.  In this case,</span>
03258 <span class="comment">        the GroupDefaulted parameter receives the value of the</span>
03259 <span class="comment">        security descriptor's GroupDefaulted control flag.</span>
03260 <span class="comment"></span>
03261 <span class="comment">Return Value:</span>
03262 <span class="comment"></span>
03263 <span class="comment">    STATUS_SUCCESS - Indicates the call completed successfully.</span>
03264 <span class="comment"></span>
03265 <span class="comment">    STATUS_UNKNOWN_REVISION - Indicates the revision of the security</span>
03266 <span class="comment">        descriptor is not known to the routine.  It may be a newer</span>
03267 <span class="comment">        revision than the routine knows about.</span>
03268 <span class="comment"></span>
03269 <span class="comment"></span>
03270 <span class="comment">--*/</span>
03271 
03272 {
03273 
03274     <span class="comment">//</span>
03275     <span class="comment">// Typecast to the opaque SECURITY_DESCRIPTOR structure.</span>
03276     <span class="comment">//</span>
03277 
03278     SECURITY_DESCRIPTOR *ISecurityDescriptor =
03279         (SECURITY_DESCRIPTOR *)SecurityDescriptor;
03280 
03281     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
03282 
03283     <span class="comment">//</span>
03284     <span class="comment">// Check the revision</span>
03285     <span class="comment">//</span>
03286 
03287     <span class="keywordflow">if</span> (ISecurityDescriptor-&gt;Revision != SECURITY_DESCRIPTOR_REVISION) {
03288         <span class="keywordflow">return</span> STATUS_UNKNOWN_REVISION;
03289     }
03290 
03291     <span class="comment">//</span>
03292     <span class="comment">// Return the Group field value.</span>
03293     <span class="comment">//</span>
03294 
03295     *<a class="code" href="../../d6/d0/ctaccess_8c.html#a54">Group</a> = RtlpGroupAddrSecurityDescriptor(ISecurityDescriptor);
03296 
03297     <span class="comment">//</span>
03298     <span class="comment">// Return the GroupDefaulted flag value.</span>
03299     <span class="comment">//</span>
03300 
03301     *GroupDefaulted = RtlpAreControlBitsSet( ISecurityDescriptor, SE_GROUP_DEFAULTED );
03302 
03303     <span class="keywordflow">return</span> STATUS_SUCCESS;
03304 
03305 }
03306 
03307 
03308 BOOLEAN
<a name="l03309"></a><a class="code" href="../../d8/d6/sertl_8c.html#a68">03309</a> <a class="code" href="../../d8/d6/sertl_8c.html#a68">RtlAreAllAccessesGranted</a>(
03310     IN ACCESS_MASK GrantedAccess,
03311     IN ACCESS_MASK DesiredAccess
03312     )
03313 
03314 <span class="comment">/*++</span>
03315 <span class="comment"></span>
03316 <span class="comment">Routine Description:</span>
03317 <span class="comment"></span>
03318 <span class="comment">    This routine is used to check a desired access mask against a</span>
03319 <span class="comment">    granted access mask.  It is used by the Object Management</span>
03320 <span class="comment">    component when dereferencing a handle.</span>
03321 <span class="comment"></span>
03322 <span class="comment">Arguments:</span>
03323 <span class="comment"></span>
03324 <span class="comment">        GrantedAccess - Specifies the granted access mask.</span>
03325 <span class="comment"></span>
03326 <span class="comment">        DesiredAccess - Specifies the desired access mask.</span>
03327 <span class="comment"></span>
03328 <span class="comment">Return Value:</span>
03329 <span class="comment"></span>
03330 <span class="comment">    BOOLEAN - TRUE if the GrantedAccess mask has all the bits set</span>
03331 <span class="comment">        that the DesiredAccess mask has set.  That is, TRUE is</span>
03332 <span class="comment">        returned if all of the desired accesses have been granted.</span>
03333 <span class="comment"></span>
03334 <span class="comment">--*/</span>
03335 
03336 {
03337     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
03338 
03339     <span class="keywordflow">return</span> ((BOOLEAN)((~(GrantedAccess) &amp; (DesiredAccess)) == 0));
03340 }
03341 
03342 
03343 BOOLEAN
<a name="l03344"></a><a class="code" href="../../d8/d6/sertl_8c.html#a69">03344</a> <a class="code" href="../../d8/d6/sertl_8c.html#a69">RtlAreAnyAccessesGranted</a>(
03345     IN ACCESS_MASK GrantedAccess,
03346     IN ACCESS_MASK DesiredAccess
03347     )
03348 
03349 <span class="comment">/*++</span>
03350 <span class="comment"></span>
03351 <span class="comment">Routine Description:</span>
03352 <span class="comment"></span>
03353 <span class="comment">    This routine is used to test whether any of a set of desired</span>
03354 <span class="comment">    accesses are granted by a granted access mask.  It is used by</span>
03355 <span class="comment">    components other than the the Object Management component for</span>
03356 <span class="comment">    checking access mask subsets.</span>
03357 <span class="comment"></span>
03358 <span class="comment">Arguments:</span>
03359 <span class="comment"></span>
03360 <span class="comment">        GrantedAccess - Specifies the granted access mask.</span>
03361 <span class="comment"></span>
03362 <span class="comment">        DesiredAccess - Specifies the desired access mask.</span>
03363 <span class="comment"></span>
03364 <span class="comment">Return Value:</span>
03365 <span class="comment"></span>
03366 <span class="comment">    BOOLEAN - TRUE if the GrantedAccess mask contains any of the bits</span>
03367 <span class="comment">        specified in the DesiredAccess mask.  That is, if any of the</span>
03368 <span class="comment">        desired accesses have been granted, TRUE is returned.</span>
03369 <span class="comment"></span>
03370 <span class="comment"></span>
03371 <span class="comment">--*/</span>
03372 
03373 {
03374     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
03375 
03376     <span class="keywordflow">return</span> ((BOOLEAN)(((GrantedAccess) &amp; (DesiredAccess)) != 0));
03377 }
03378 
03379 
03380 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l03381"></a><a class="code" href="../../d8/d6/sertl_8c.html#a70">03381</a> <a class="code" href="../../d8/d6/sertl_8c.html#a70">RtlMapGenericMask</a>(
03382     IN OUT PACCESS_MASK AccessMask,
03383     IN PGENERIC_MAPPING GenericMapping
03384     )
03385 
03386 <span class="comment">/*++</span>
03387 <span class="comment"></span>
03388 <span class="comment">Routine Description:</span>
03389 <span class="comment"></span>
03390 <span class="comment">    This routine maps all generic accesses in the provided access mask</span>
03391 <span class="comment">    to specific and standard accesses according to the provided</span>
03392 <span class="comment">    GenericMapping.</span>
03393 <span class="comment"></span>
03394 <span class="comment">Arguments:</span>
03395 <span class="comment"></span>
03396 <span class="comment">        AccessMask - Points to the access mask to be mapped.</span>
03397 <span class="comment"></span>
03398 <span class="comment">        GenericMapping - The mapping of generic to specific and standard</span>
03399 <span class="comment">                         access types.</span>
03400 <span class="comment"></span>
03401 <span class="comment">Return Value:</span>
03402 <span class="comment"></span>
03403 <span class="comment">    None.</span>
03404 <span class="comment"></span>
03405 <span class="comment">--*/</span>
03406 
03407 {
03408     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
03409 
03410 <span class="comment">//    //</span>
03411 <span class="comment">//    // Make sure the pointer is properly aligned</span>
03412 <span class="comment">//    //</span>
03413 <span class="comment">//</span>
03414 <span class="comment">//    ASSERT( ((ULONG)AccessMask &gt;&gt; 2) &lt;&lt; 2 == (ULONG)AccessMask );</span>
03415 
03416     <span class="keywordflow">if</span> (*AccessMask &amp; GENERIC_READ) {
03417 
03418         *AccessMask |= GenericMapping-&gt;GenericRead;
03419     }
03420 
03421     <span class="keywordflow">if</span> (*AccessMask &amp; GENERIC_WRITE) {
03422 
03423         *AccessMask |= GenericMapping-&gt;GenericWrite;
03424     }
03425 
03426     <span class="keywordflow">if</span> (*AccessMask &amp; GENERIC_EXECUTE) {
03427 
03428         *AccessMask |= GenericMapping-&gt;GenericExecute;
03429     }
03430 
03431     <span class="keywordflow">if</span> (*AccessMask &amp; GENERIC_ALL) {
03432 
03433         *AccessMask |= GenericMapping-&gt;GenericAll;
03434     }
03435 
03436     <span class="comment">//</span>
03437     <span class="comment">// Now clear the generic flags</span>
03438     <span class="comment">//</span>
03439 
03440     *AccessMask &amp;= ~(GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | GENERIC_ALL);
03441 
03442     <span class="keywordflow">return</span>;
03443 }
03444 
03445 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l03446"></a><a class="code" href="../../d8/d6/sertl_8c.html#a71">03446</a> <a class="code" href="../../d8/d6/sertl_8c.html#a71">RtlImpersonateSelf</a>(
03447     IN SECURITY_IMPERSONATION_LEVEL ImpersonationLevel
03448     )
03449 
03450 <span class="comment">/*++</span>
03451 <span class="comment"></span>
03452 <span class="comment">Routine Description:</span>
03453 <span class="comment"></span>
03454 <span class="comment">    This routine may be used to obtain an Impersonation token representing</span>
03455 <span class="comment">    your own process's context.  This may be useful for enabling a privilege</span>
03456 <span class="comment">    for a single thread rather than for the entire process; or changing</span>
03457 <span class="comment">    the default DACL for a single thread.</span>
03458 <span class="comment"></span>
03459 <span class="comment">    The token is assigned to the callers thread.</span>
03460 <span class="comment"></span>
03461 <span class="comment"></span>
03462 <span class="comment"></span>
03463 <span class="comment">Arguments:</span>
03464 <span class="comment"></span>
03465 <span class="comment">    ImpersonationLevel - The level to make the impersonation token.</span>
03466 <span class="comment"></span>
03467 <span class="comment"></span>
03468 <span class="comment"></span>
03469 <span class="comment">Return Value:</span>
03470 <span class="comment"></span>
03471 <span class="comment">    STATUS_SUCCESS -  The thread is now impersonating the calling process.</span>
03472 <span class="comment"></span>
03473 <span class="comment">    Other - Status values returned by:</span>
03474 <span class="comment"></span>
03475 <span class="comment">            NtOpenProcessToken()</span>
03476 <span class="comment">            NtDuplicateToken()</span>
03477 <span class="comment">            NtSetInformationThread()</span>
03478 <span class="comment"></span>
03479 <span class="comment">--*/</span>
03480 
03481 {
03482     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
03483         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>,
03484         IgnoreStatus;
03485 
03486     HANDLE
03487         Token1,
03488         Token2;
03489 
03490     OBJECT_ATTRIBUTES
03491         <a class="code" href="../../d7/d0/ctlnpqos_8c.html#a4">ObjectAttributes</a>;
03492 
03493     SECURITY_QUALITY_OF_SERVICE
03494         Qos;
03495 
03496 
03497     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
03498 
03499     InitializeObjectAttributes(&amp;<a class="code" href="../../d7/d0/ctlnpqos_8c.html#a4">ObjectAttributes</a>, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, 0, 0, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
03500 
03501     Qos.Length = <span class="keyword">sizeof</span>(SECURITY_QUALITY_OF_SERVICE);
03502     Qos.ImpersonationLevel = ImpersonationLevel;
03503     Qos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
03504     Qos.EffectiveOnly = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03505     <a class="code" href="../../d7/d0/ctlnpqos_8c.html#a4">ObjectAttributes</a>.SecurityQualityOfService = &amp;Qos;
03506 
03507     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d7/d3/tokenopn_8c.html#a1">NtOpenProcessToken</a>( NtCurrentProcess(), TOKEN_DUPLICATE, &amp;Token1 );
03508 
03509     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
03510         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d6/d3/tokendup_8c.html#a1">NtDuplicateToken</a>(
03511                      Token1,
03512                      TOKEN_IMPERSONATE,
03513                      &amp;<a class="code" href="../../d7/d0/ctlnpqos_8c.html#a4">ObjectAttributes</a>,
03514                      <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,                 <span class="comment">//EffectiveOnly</span>
03515                      TokenImpersonation,
03516                      &amp;Token2
03517                      );
03518         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
03519             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d1/psquery_8c.html#a21">NtSetInformationThread</a>(
03520                          NtCurrentThread(),
03521                          ThreadImpersonationToken,
03522                          &amp;Token2,
03523                          <span class="keyword">sizeof</span>(HANDLE)
03524                          );
03525 
03526             IgnoreStatus = <a class="code" href="../../d5/d0/obclose_8c.html#a1">NtClose</a>( Token2 );
03527         }
03528 
03529 
03530         IgnoreStatus = <a class="code" href="../../d5/d0/obclose_8c.html#a1">NtClose</a>( Token1 );
03531     }
03532 
03533 
03534     <span class="keywordflow">return</span>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>);
03535 
03536 }
03537 
03538 <span class="preprocessor">#ifndef WIN16</span>
03539 <span class="preprocessor"></span>
03540 
03541 <span class="preprocessor">#ifndef NTOS_KERNEL_RUNTIME</span>
03542 <span class="preprocessor"></span>
03543 BOOLEAN
<a name="l03544"></a><a class="code" href="../../d8/d6/sertl_8c.html#a72">03544</a> <a class="code" href="../../d8/d6/sertl_8c.html#a72">RtlpValidOwnerSubjectContext</a>(
03545     IN HANDLE Token,
03546     IN PSID Owner,
03547     IN BOOLEAN ServerObject,
03548     OUT PNTSTATUS ReturnStatus
03549     )
03550 <span class="comment">/*++</span>
03551 <span class="comment"></span>
03552 <span class="comment">Routine Description:</span>
03553 <span class="comment"></span>
03554 <span class="comment">    This routine checks to see whether the provided SID is one the subject</span>
03555 <span class="comment">    is authorized to assign as the owner of objects.</span>
03556 <span class="comment"></span>
03557 <span class="comment">Arguments:</span>
03558 <span class="comment"></span>
03559 <span class="comment">    Token - Points to the subject's effective token</span>
03560 <span class="comment"></span>
03561 <span class="comment">    Owner - Points to the SID to be checked.</span>
03562 <span class="comment"></span>
03563 <span class="comment">    ServerObject - Boolean indicating whether or not this is a server</span>
03564 <span class="comment">       object, meaning it is protected by a primary-client combination.</span>
03565 <span class="comment"></span>
03566 <span class="comment">    ReturnStatus - Status to be passed back to the caller on failure.</span>
03567 <span class="comment"></span>
03568 <span class="comment">Return Value:</span>
03569 <span class="comment"></span>
03570 <span class="comment">    FALSE on failure.</span>
03571 <span class="comment"></span>
03572 <span class="comment">--*/</span>
03573 
03574 {
03575     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
03576 
03577     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
03578     BOOLEAN Found;
03579     ULONG ReturnLength;
03580     PTOKEN_GROUPS GroupIds = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03581     PTOKEN_USER UserId = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03582     PVOID <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
03583     HANDLE TokenToUse;
03584 
03585     BOOLEAN HasPrivilege;
03586     PRIVILEGE_SET PrivilegeSet;
03587 
03588     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
03589 
03590     <span class="comment">//</span>
03591     <span class="comment">// Get the handle to the current process heap</span>
03592     <span class="comment">//</span>
03593 
03594     <span class="keywordflow">if</span> ( <a class="code" href="../../d6/d0/ctaccess_8c.html#a53">Owner</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
03595         *ReturnStatus = STATUS_INVALID_OWNER;
03596         <span class="keywordflow">return</span>(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
03597     }
03598 
03599     <span class="comment">//</span>
03600     <span class="comment">// If it's not a server object, check the owner against the contents of the</span>
03601     <span class="comment">// client token.  If it is a server object, the owner must be valid in the</span>
03602     <span class="comment">// primary token.</span>
03603     <span class="comment">//</span>
03604 
03605     <span class="keywordflow">if</span> (!ServerObject) {
03606 
03607         TokenToUse = <a class="code" href="../../d6/d0/ctaccess_8c.html#a29">Token</a>;
03608 
03609     } <span class="keywordflow">else</span> {
03610 
03611         *ReturnStatus = <a class="code" href="../../d7/d3/tokenopn_8c.html#a1">NtOpenProcessToken</a>(
03612                             NtCurrentProcess(),
03613                             TOKEN_QUERY,
03614                             &amp;TokenToUse
03615                             );
03616 
03617         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( *ReturnStatus )) {
03618             <span class="keywordflow">return</span>( <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
03619         }
03620     }
03621 
03622     <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a> = RtlProcessHeap();
03623 
03624     <span class="comment">//</span>
03625     <span class="comment">//  Get the User from the Token</span>
03626     <span class="comment">//</span>
03627 
03628     *ReturnStatus = <a class="code" href="../../d9/d3/tokenqry_8c.html#a0">NtQueryInformationToken</a>(
03629                          TokenToUse,
03630                          TokenUser,
03631                          UserId,
03632                          0,
03633                          &amp;ReturnLength
03634                          );
03635 
03636     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( *ReturnStatus ) &amp;&amp; (STATUS_BUFFER_TOO_SMALL != *ReturnStatus)) {
03637         <span class="keywordflow">if</span> (ServerObject) {
03638             <a class="code" href="../../d5/d0/obclose_8c.html#a1">NtClose</a>( TokenToUse );
03639         }
03640         <span class="keywordflow">return</span>( <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
03641 
03642     }
03643 
03644     UserId = <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a0">RtlAllocateHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, 0, ReturnLength );
03645 
03646     <span class="keywordflow">if</span> (UserId == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03647 
03648         *ReturnStatus = STATUS_NO_MEMORY;
03649         <span class="keywordflow">if</span> (ServerObject) {
03650             <a class="code" href="../../d5/d0/obclose_8c.html#a1">NtClose</a>( TokenToUse );
03651         }
03652 
03653         <span class="keywordflow">return</span>( <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
03654     }
03655 
03656     *ReturnStatus = <a class="code" href="../../d9/d3/tokenqry_8c.html#a0">NtQueryInformationToken</a>(
03657                          TokenToUse,
03658                          TokenUser,
03659                          UserId,
03660                          ReturnLength,
03661                          &amp;ReturnLength
03662                          );
03663 
03664     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( *ReturnStatus )) {
03665         <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, 0, (PVOID)UserId );
03666         <span class="keywordflow">if</span> (ServerObject) {
03667             <a class="code" href="../../d5/d0/obclose_8c.html#a1">NtClose</a>( TokenToUse );
03668         }
03669         <span class="keywordflow">return</span>( <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
03670     }
03671 
03672     <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a36">RtlEqualSid</a>( <a class="code" href="../../d6/d0/ctaccess_8c.html#a53">Owner</a>, UserId-&gt;User.Sid ) ) {
03673 
03674         <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, 0, (PVOID)UserId );
03675         <span class="keywordflow">if</span> (ServerObject) {
03676             <a class="code" href="../../d5/d0/obclose_8c.html#a1">NtClose</a>( TokenToUse );
03677         }
03678         <span class="keywordflow">return</span>( <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
03679     }
03680 
03681     <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, 0, (PVOID)UserId );
03682 
03683     <span class="comment">//</span>
03684     <span class="comment">// Get the groups from the Token</span>
03685     <span class="comment">//</span>
03686 
03687     *ReturnStatus = <a class="code" href="../../d9/d3/tokenqry_8c.html#a0">NtQueryInformationToken</a>(
03688                          TokenToUse,
03689                          TokenGroups,
03690                          GroupIds,
03691                          0,
03692                          &amp;ReturnLength
03693                          );
03694 
03695     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( *ReturnStatus ) &amp;&amp; (STATUS_BUFFER_TOO_SMALL != *ReturnStatus)) {
03696 
03697         <span class="keywordflow">if</span> (ServerObject) {
03698             <a class="code" href="../../d5/d0/obclose_8c.html#a1">NtClose</a>( TokenToUse );
03699         }
03700         <span class="keywordflow">return</span>( <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
03701     }
03702 
03703     GroupIds = <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a0">RtlAllocateHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, 0, ReturnLength );
03704 
03705     <span class="keywordflow">if</span> (GroupIds == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03706 
03707         *ReturnStatus = STATUS_NO_MEMORY;
03708         <span class="keywordflow">if</span> (ServerObject) {
03709             <a class="code" href="../../d5/d0/obclose_8c.html#a1">NtClose</a>( TokenToUse );
03710         }
03711         <span class="keywordflow">return</span>( <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
03712     }
03713 
03714     *ReturnStatus = <a class="code" href="../../d9/d3/tokenqry_8c.html#a0">NtQueryInformationToken</a>(
03715                          TokenToUse,
03716                          TokenGroups,
03717                          GroupIds,
03718                          ReturnLength,
03719                          &amp;ReturnLength
03720                          );
03721 
03722     <span class="keywordflow">if</span> (ServerObject) {
03723         <a class="code" href="../../d5/d0/obclose_8c.html#a1">NtClose</a>( TokenToUse );
03724     }
03725 
03726     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( *ReturnStatus )) {
03727         <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, 0, GroupIds );
03728         <span class="keywordflow">return</span>( <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
03729     }
03730 
03731     <span class="comment">//</span>
03732     <span class="comment">//  Walk through the list of group IDs looking for a match to</span>
03733     <span class="comment">//  the specified SID.  If one is found, make sure it may be</span>
03734     <span class="comment">//  assigned as an owner.</span>
03735     <span class="comment">//</span>
03736     <span class="comment">//  This code is similar to that performed to set the default</span>
03737     <span class="comment">//  owner of a token (NtSetInformationToken).</span>
03738     <span class="comment">//</span>
03739 
03740     <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = 0;
03741     <span class="keywordflow">while</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &lt; GroupIds-&gt;GroupCount) {
03742 
03743         Found = <a class="code" href="../../d8/d6/sertl_8c.html#a36">RtlEqualSid</a>(
03744                     <a class="code" href="../../d6/d0/ctaccess_8c.html#a53">Owner</a>,
03745                     GroupIds-&gt;Groups[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].Sid
03746                     );
03747 
03748         <span class="keywordflow">if</span> ( Found ) {
03749 
03750             <span class="keywordflow">if</span> ( RtlpIdAssignableAsOwner(GroupIds-&gt;Groups[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>])) {
03751 
03752                 <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, 0, GroupIds );
03753                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03754 
03755             } <span class="keywordflow">else</span> {
03756 
03757                 <span class="keywordflow">break</span>;
03758 
03759             } <span class="comment">//endif assignable</span>
03760 
03761         }  <span class="comment">//endif Found</span>
03762 
03763         <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>++;
03764 
03765     } <span class="comment">//endwhile</span>
03766 
03767     <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, 0, GroupIds );
03768 
03769     <span class="comment">//</span>
03770     <span class="comment">// If we are going to fail this call, check for Restore privilege,</span>
03771     <span class="comment">// and succeed if he has it.</span>
03772     <span class="comment">//</span>
03773 
03774     <span class="comment">//</span>
03775     <span class="comment">// Check for appropriate Privileges</span>
03776     <span class="comment">//</span>
03777     <span class="comment">// Audit/Alarm messages need to be generated due to the attempt</span>
03778     <span class="comment">// to perform a privileged operation.</span>
03779     <span class="comment">//</span>
03780 
03781     PrivilegeSet.PrivilegeCount = 1;
03782     PrivilegeSet.Control = PRIVILEGE_SET_ALL_NECESSARY;
03783     PrivilegeSet.Privilege[0].Luid = RtlConvertLongToLuid(SE_RESTORE_PRIVILEGE);
03784     PrivilegeSet.Privilege[0].Attributes = 0;
03785 
03786     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d8/d4/privileg_8c.html#a2">NtPrivilegeCheck</a>(
03787                 <a class="code" href="../../d6/d0/ctaccess_8c.html#a29">Token</a>,
03788                 &amp;PrivilegeSet,
03789                 &amp;HasPrivilege
03790                 );
03791 
03792     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
03793         HasPrivilege = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03794     }
03795 
03796     <span class="keywordflow">if</span> ( HasPrivilege ) {
03797         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03798     } <span class="keywordflow">else</span> {
03799         *ReturnStatus = STATUS_INVALID_OWNER;
03800         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03801     }
03802 }
03803 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
03804 <span class="preprocessor"></span>
03805 <span class="preprocessor">#endif  // WIN16</span>
03806 <span class="preprocessor"></span>
03807 
03808 
03809 
03810 
03811 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l03812"></a><a class="code" href="../../d8/d6/sertl_8c.html#a73">03812</a> <a class="code" href="../../d8/d6/sertl_8c.html#a73">RtlpApplyAclToObject</a> (
03813     IN PACL Acl,
03814     IN PGENERIC_MAPPING GenericMapping
03815     )
03816 
03817 <span class="comment">/*++</span>
03818 <span class="comment"></span>
03819 <span class="comment">Routine Description:</span>
03820 <span class="comment"></span>
03821 <span class="comment">    This is a private routine that maps Access Masks of an ACL so that</span>
03822 <span class="comment">    they are applicable to the object type the ACL is being applied to.</span>
03823 <span class="comment"></span>
03824 <span class="comment">    Only known DSA ACEs are mapped.  Unknown ACE types are ignored.</span>
03825 <span class="comment"></span>
03826 <span class="comment">    Only access types in the GenericAll mapping for the target object</span>
03827 <span class="comment">    type will be non-zero upon return.</span>
03828 <span class="comment"></span>
03829 <span class="comment">Arguments:</span>
03830 <span class="comment"></span>
03831 <span class="comment">    Acl - Supplies the acl being applied.</span>
03832 <span class="comment"></span>
03833 <span class="comment">    GenericMapping - Specifies the generic mapping to use.</span>
03834 <span class="comment"></span>
03835 <span class="comment"></span>
03836 <span class="comment">Return Value:</span>
03837 <span class="comment"></span>
03838 <span class="comment">    None.</span>
03839 <span class="comment"></span>
03840 <span class="comment">--*/</span>
03841 
03842 {
03843     ULONG i;
03844 
03845     PACE_HEADER Ace;
03846 
03847     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
03848 
03849     <span class="comment">//</span>
03850     <span class="comment">//  First check if the acl is null</span>
03851     <span class="comment">//</span>
03852 
03853     <span class="keywordflow">if</span> (Acl == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03854 
03855         <span class="keywordflow">return</span>;
03856 
03857     }
03858 
03859 
03860     <span class="comment">//</span>
03861     <span class="comment">// Now walk the ACL, mapping each ACE as we go.</span>
03862     <span class="comment">//</span>
03863 
03864     <span class="keywordflow">for</span> (i = 0, Ace = <a class="code" href="../../d4/d1/rtdmpsec_8c.html#a1">FirstAce</a>(Acl);
03865          i &lt; Acl-&gt;AceCount;
03866          i += 1, Ace = <a class="code" href="../../d4/d1/rtdmpsec_8c.html#a2">NextAce</a>(Ace)) {
03867 
03868         <span class="keywordflow">if</span> (IsMSAceType( Ace )) {
03869 
03870             RtlApplyAceToObject( Ace, GenericMapping );
03871         }
03872 
03873     }
03874 
03875     <span class="keywordflow">return</span>;
03876 }
03877 
03878 
03879 BOOLEAN
<a name="l03880"></a><a class="code" href="../../d8/d6/sertl_8c.html#a16">03880</a> <a class="code" href="../../d8/d6/sertl_8c.html#a16">RtlpCopyEffectiveAce</a> (
03881     IN PACE_HEADER OldAce,
03882     IN BOOLEAN AutoInherit,
03883     IN BOOLEAN WillGenerateInheritAce,
03884     IN PSID ClientOwnerSid,
03885     IN PSID ClientGroupSid,
03886     IN PSID ServerOwnerSid OPTIONAL,
03887     IN PSID ServerGroupSid OPTIONAL,
03888     IN PGENERIC_MAPPING GenericMapping,
03889     IN GUID *NewObjectType OPTIONAL,
03890     IN OUT PVOID *AcePosition,
03891     OUT PULONG NewAceLength,
03892     OUT PACL NewAcl,
03893     OUT PBOOLEAN ObjectAceInherited OPTIONAL,
03894     OUT PBOOLEAN EffectiveAceMapped,
03895     OUT PBOOLEAN AclOverflowed
03896     )
03897 
03898 <span class="comment">/*++</span>
03899 <span class="comment"></span>
03900 <span class="comment">Routine Description:</span>
03901 <span class="comment"></span>
03902 <span class="comment">    This routine copy a specified ACE into an ACL as an effective ACE.</span>
03903 <span class="comment">    The resultant ACE has all the inheritance bits turned of.</span>
03904 <span class="comment">    The resultant ACE has the SID mapped from a generic SID to a specific SID</span>
03905 <span class="comment">    (e.g., From "creator owner" to the passed in owner sid).</span>
03906 <span class="comment"></span>
03907 <span class="comment">Arguments:</span>
03908 <span class="comment"></span>
03909 <span class="comment">    OldAce - Supplies the ace being inherited</span>
03910 <span class="comment"></span>
03911 <span class="comment">    AutoInherit - Specifies if the inheritance is an "automatic inheritance".</span>
03912 <span class="comment">        As such, the inherited ACEs will be marked as such.</span>
03913 <span class="comment"></span>
03914 <span class="comment">    WillGenerateInheritAce - Specifies if the caller intends to generate an</span>
03915 <span class="comment">        inheritable ACE the corresponds to OldAce.  If TRUE, this routine will</span>
03916 <span class="comment">        try to not map the effective ACE (increasing the likelyhood that</span>
03917 <span class="comment">        EffectiveAceMapped will return FALSE),</span>
03918 <span class="comment"></span>
03919 <span class="comment">    ClientOwnerSid - Specifies the owner Sid to use</span>
03920 <span class="comment"></span>
03921 <span class="comment">    ClientGroupSid - Specifies the new Group Sid to use</span>
03922 <span class="comment"></span>
03923 <span class="comment">    ServerSid - Optionally specifies the Server Sid to use in compound ACEs.</span>
03924 <span class="comment"></span>
03925 <span class="comment">    ClientSid - Optionally specifies the Client Sid to use in compound ACEs.</span>
03926 <span class="comment"></span>
03927 <span class="comment">    GenericMapping - Specifies the generic mapping to use</span>
03928 <span class="comment"></span>
03929 <span class="comment">    NewObjectType - Type of object being inherited to.  If not specified,</span>
03930 <span class="comment">        the object has no object type.</span>
03931 <span class="comment"></span>
03932 <span class="comment">    AcePosition - On entry and exit, specifies location of the next available ACE</span>
03933 <span class="comment">        position in NewAcl.</span>
03934 <span class="comment">        A NULL ACE position means there is no room at all in NewAcl.</span>
03935 <span class="comment"></span>
03936 <span class="comment">    NewAceLength - Returns the length (in bytes) needed in NewAcl to</span>
03937 <span class="comment">        copy the specified ACE. This might be zero to indicate that the ACE</span>
03938 <span class="comment">        need not be copied at all.</span>
03939 <span class="comment"></span>
03940 <span class="comment">    NewAcl - Provides a pointer to the ACL into which the ACE is to be</span>
03941 <span class="comment">        inherited.</span>
03942 <span class="comment"></span>
03943 <span class="comment">    ObjectAceInherited - Returns true if one or more object ACEs were inherited</span>
03944 <span class="comment">        based on NewObjectType</span>
03945 <span class="comment">        If NULL, NewObjectType is ignored and the object ACE is always inherited</span>
03946 <span class="comment"></span>
03947 <span class="comment">    EffectiveAceMapped - Return TRUE if the SID, guid, or access mask of Old Ace</span>
03948 <span class="comment">        was modifed when copying the ACE.</span>
03949 <span class="comment"></span>
03950 <span class="comment">    AclOverflowed - Returns TRUE if NewAcl wasn't long enough to contain NewAceLength.</span>
03951 <span class="comment"></span>
03952 <span class="comment">Return Value:</span>
03953 <span class="comment"></span>
03954 <span class="comment">    TRUE - No problem was detected.</span>
03955 <span class="comment">    FALSE - Indicates something went wrong preventing</span>
03956 <span class="comment">        the ACE from being compied.  This generally represents a bugcheck</span>
03957 <span class="comment">        situation when returned from this call.</span>
03958 <span class="comment"></span>
03959 <span class="comment">--*/</span>
03960 {
03961     ULONG LengthRequired;
03962     ACCESS_MASK LocalMask;
03963 
03964     PSID LocalServerOwner;
03965     PSID LocalServerGroup;
03966 
03967     ULONG <a class="code" href="../../d4/d6/tsevars_8c.html#a33">CreatorSid</a>[<a class="code" href="../../d8/d6/sertl_8c.html#a0">CREATOR_SID_SIZE</a>];
03968 
03969     SID_IDENTIFIER_AUTHORITY  CreatorSidAuthority = SECURITY_CREATOR_SID_AUTHORITY;
03970 
03971 
03972     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
03973 
03974     <span class="comment">//</span>
03975     <span class="comment">// Allocate and initialize the universal SIDs we're going to need</span>
03976     <span class="comment">// to look for inheritable ACEs.</span>
03977     <span class="comment">//</span>
03978 
03979     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(<a class="code" href="../../d8/d6/sertl_8c.html#a38">RtlLengthRequiredSid</a>( 1 ) == <a class="code" href="../../d8/d6/sertl_8c.html#a0">CREATOR_SID_SIZE</a>);
03980     <a class="code" href="../../d8/d6/sertl_8c.html#a40">RtlInitializeSid</a>( (PSID)<a class="code" href="../../d4/d6/tsevars_8c.html#a33">CreatorSid</a>, &amp;CreatorSidAuthority, 1 );
03981     *(RtlpSubAuthoritySid( (PSID)<a class="code" href="../../d4/d6/tsevars_8c.html#a33">CreatorSid</a>, 0 )) = SECURITY_CREATOR_OWNER_RID;
03982 
03983     LocalServerOwner = ARGUMENT_PRESENT(ServerOwnerSid) ? ServerOwnerSid : ClientOwnerSid;
03984     LocalServerGroup = ARGUMENT_PRESENT(ServerGroupSid) ? ServerGroupSid : ClientGroupSid;
03985 
03986 
03987     <span class="comment">//</span>
03988     <span class="comment">// Initialization</span>
03989     <span class="comment">//</span>
03990     *EffectiveAceMapped = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03991     <span class="keywordflow">if</span> ( ARGUMENT_PRESENT(ObjectAceInherited)) {
03992         *ObjectAceInherited = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03993     }
03994     *AclOverflowed = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03995     LengthRequired = (ULONG)OldAce-&gt;AceSize;
03996 
03997     <span class="comment">//</span>
03998     <span class="comment">// Process all MS ACE types specially</span>
03999     <span class="comment">//</span>
04000 
04001     <span class="keywordflow">if</span> ( IsMSAceType(OldAce) ) {
04002         ULONG Rid;
04003         PSID SidToCopy = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04004         ULONG AceHeaderToCopyLength;
04005         PACE_HEADER AceHeaderToCopy = OldAce;
04006         PSID ServerSidToCopy = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04007 
04008         UCHAR DummyAce[<span class="keyword">sizeof</span>(KNOWN_OBJECT_ACE)+<span class="keyword">sizeof</span>(GUID)];
04009 
04010         <span class="comment">//</span>
04011         <span class="comment">// Grab the Sid pointer and access mask as a function of the ACE type</span>
04012         <span class="comment">//</span>
04013         <span class="keywordflow">if</span> (IsKnownAceType( OldAce ) ) {
04014             SidToCopy = &amp;((<a class="code" href="../../d4/d7/struct__KNOWN__ACE.html">PKNOWN_ACE</a>)OldAce)-&gt;SidStart;
04015             AceHeaderToCopyLength = FIELD_OFFSET(<a class="code" href="../../d4/d7/struct__KNOWN__ACE.html">KNOWN_ACE</a>, SidStart);
04016 
04017         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (IsCompoundAceType(OldAce)) {
04018 
04019             SidToCopy = RtlCompoundAceClientSid( OldAce );
04020             AceHeaderToCopyLength = FIELD_OFFSET(KNOWN_COMPOUND_ACE, SidStart);
04021             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( FIELD_OFFSET(KNOWN_COMPOUND_ACE, Mask) ==
04022                     FIELD_OFFSET(<a class="code" href="../../d4/d7/struct__KNOWN__ACE.html">KNOWN_ACE</a>, Mask) );
04023 
04024             <span class="comment">//</span>
04025             <span class="comment">// Compound ACEs have two SIDs (Map one now).</span>
04026             <span class="comment">//</span>
04027             ServerSidToCopy = RtlCompoundAceServerSid( OldAce );
04028 
04029             <span class="keywordflow">if</span> (<a class="code" href="../../d8/d6/sertl_8c.html#a37">RtlEqualPrefixSid</a> ( ServerSidToCopy, <a class="code" href="../../d4/d6/tsevars_8c.html#a33">CreatorSid</a> )) {
04030 
04031                 Rid = *RtlpSubAuthoritySid( ServerSidToCopy, 0 );
04032                 <span class="keywordflow">switch</span> (Rid) {
04033                 <span class="keywordflow">case</span> SECURITY_CREATOR_OWNER_RID:
04034                     ServerSidToCopy = ClientOwnerSid;
04035                     LengthRequired = LengthRequired - <a class="code" href="../../d8/d6/sertl_8c.html#a0">CREATOR_SID_SIZE</a> + <a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>(ClientOwnerSid);
04036                     *EffectiveAceMapped = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04037                     <span class="keywordflow">break</span>;
04038                 <span class="keywordflow">case</span> SECURITY_CREATOR_GROUP_RID:
04039                     <span class="keywordflow">if</span> ( ClientGroupSid != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
04040                         ServerSidToCopy = ClientGroupSid;
04041                         LengthRequired = LengthRequired - <a class="code" href="../../d8/d6/sertl_8c.html#a0">CREATOR_SID_SIZE</a> + <a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>(ClientGroupSid);
04042                         *EffectiveAceMapped = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04043                     }
04044                     <span class="keywordflow">break</span>;
04045                 <span class="keywordflow">case</span> SECURITY_CREATOR_OWNER_SERVER_RID:
04046                     ServerSidToCopy = LocalServerOwner;
04047                     LengthRequired = LengthRequired - <a class="code" href="../../d8/d6/sertl_8c.html#a0">CREATOR_SID_SIZE</a> + <a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>(LocalServerOwner);
04048                     *EffectiveAceMapped = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04049                     <span class="keywordflow">break</span>;
04050                 <span class="keywordflow">case</span> SECURITY_CREATOR_GROUP_SERVER_RID:
04051                     ServerSidToCopy = LocalServerGroup;
04052                     LengthRequired = LengthRequired - <a class="code" href="../../d8/d6/sertl_8c.html#a0">CREATOR_SID_SIZE</a> + <a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>(LocalServerGroup);
04053                     *EffectiveAceMapped = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04054                     <span class="keywordflow">break</span>;
04055                 }
04056 
04057                 <span class="comment">//</span>
04058                 <span class="comment">// If we don't know what this SID is, just copy the original.</span>
04059                 <span class="comment">//</span>
04060                 <span class="keywordflow">if</span> ( !*EffectiveAceMapped ) {
04061                     AceHeaderToCopyLength += <a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>( ServerSidToCopy );
04062                     ServerSidToCopy = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04063                 }
04064 
04065             } <span class="keywordflow">else</span> {
04066                 <span class="comment">//</span>
04067                 <span class="comment">// We don't know what this SID is, just copy the original.</span>
04068                 <span class="comment">//</span>
04069                 AceHeaderToCopyLength += <a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>( ServerSidToCopy );
04070                 ServerSidToCopy = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04071             }
04072 
04073         <span class="comment">//</span>
04074         <span class="comment">// Handle Object ACEs</span>
04075         <span class="comment">//</span>
04076         } <span class="keywordflow">else</span> {
04077             GUID *InheritedObjectType;
04078 
04079             SidToCopy = RtlObjectAceSid( OldAce );
04080             AceHeaderToCopyLength = (ULONG) ((PUCHAR)SidToCopy - (PUCHAR)OldAce);
04081             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( FIELD_OFFSET(KNOWN_OBJECT_ACE, Mask) ==
04082                     FIELD_OFFSET(<a class="code" href="../../d4/d7/struct__KNOWN__ACE.html">KNOWN_ACE</a>, Mask) );
04083 
04084             <span class="comment">//</span>
04085             <span class="comment">// Handle ACEs that are only inherited for a specific object type,</span>
04086             <span class="comment">//</span>
04087             InheritedObjectType = RtlObjectAceInheritedObjectType( OldAce );
04088             <span class="keywordflow">if</span> ( ARGUMENT_PRESENT(ObjectAceInherited) &amp;&amp; InheritedObjectType != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
04089 
04090                 <span class="comment">//</span>
04091                 <span class="comment">// If the object type doesn't match the inherited object type,</span>
04092                 <span class="comment">//  don't inherit the ACE.</span>
04093                 <span class="comment">//</span>
04094 
04095                 <span class="keywordflow">if</span> ( NewObjectType == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ||
04096                      !RtlEqualMemory( InheritedObjectType,
04097                                       NewObjectType,
04098                                       <span class="keyword">sizeof</span>(GUID) ) ) {
04099 
04100                     LengthRequired = 0;
04101 
04102                 <span class="comment">//</span>
04103                 <span class="comment">// If the object type matches the inherited object type,</span>
04104                 <span class="comment">//  Inherit an ACE with no inherited object type.</span>
04105                 <span class="comment">//</span>
04106 
04107                 } <span class="keywordflow">else</span> {
04108 
04109                     <span class="comment">//</span>
04110                     <span class="comment">// Tell the caller we inherited an object type specific ACE.</span>
04111                     <span class="comment">//</span>
04112 
04113                     *ObjectAceInherited = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04114 
04115                     <span class="comment">//</span>
04116                     <span class="comment">// If the caller is not going to generate an inheritable ACE,</span>
04117                     <span class="comment">//  deleting the inherited object type GUID for the effective ACE.</span>
04118                     <span class="comment">//</span>
04119                     <span class="comment">// Otherwise, leave it so the caller can merge the two ACEs.</span>
04120                     <span class="comment">//</span>
04121 
04122                     <span class="keywordflow">if</span> ( !WillGenerateInheritAce ) {
04123                         *EffectiveAceMapped = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04124 
04125                         <span class="comment">//</span>
04126                         <span class="comment">// If an object type GUID is present,</span>
04127                         <span class="comment">//  simply delete the inherited object type GUID.</span>
04128                         <span class="comment">//</span>
04129                         <span class="keywordflow">if</span> ( RtlObjectAceObjectTypePresent( OldAce )) {
04130                             LengthRequired -= <span class="keyword">sizeof</span>(GUID);
04131                             AceHeaderToCopyLength -= <span class="keyword">sizeof</span>(GUID);
04132                             RtlCopyMemory( DummyAce, OldAce, AceHeaderToCopyLength );
04133 
04134                             AceHeaderToCopy = (PACE_HEADER)DummyAce;
04135                             ((PKNOWN_OBJECT_ACE)AceHeaderToCopy)-&gt;Flags &amp;= ~ACE_INHERITED_OBJECT_TYPE_PRESENT;
04136 
04137 
04138                         <span class="comment">//</span>
04139                         <span class="comment">// If an object type GUID is not present,</span>
04140                         <span class="comment">//  convert the ACE to non-object type specific.</span>
04141                         <span class="comment">//</span>
04142                         } <span class="keywordflow">else</span> {
04143                             AceHeaderToCopyLength = AceHeaderToCopyLength -
04144                                              <span class="keyword">sizeof</span>(GUID) +
04145                                              <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d1/rtdmpsec_8c.html#a3">KNOWN_ACE</a>) -
04146                                              <span class="keyword">sizeof</span>(KNOWN_OBJECT_ACE);
04147                             LengthRequired = LengthRequired -
04148                                              <span class="keyword">sizeof</span>(GUID) +
04149                                              <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d1/rtdmpsec_8c.html#a3">KNOWN_ACE</a>) -
04150                                              <span class="keyword">sizeof</span>(KNOWN_OBJECT_ACE);
04151 
04152                             RtlCopyMemory( DummyAce, OldAce, AceHeaderToCopyLength );
04153                             AceHeaderToCopy = (PACE_HEADER)DummyAce;
04154 
04155                             AceHeaderToCopy-&gt;AceType = <a class="code" href="../../d8/d6/sertl_8c.html#a7">RtlBaseAceType</a>[ OldAce-&gt;AceType ];
04156 
04157                         }
04158                     }
04159                 }
04160 
04161             }
04162         }
04163 
04164         <span class="comment">//</span>
04165         <span class="comment">// Only proceed if we've not already determined to drop the ACE.</span>
04166         <span class="comment">//</span>
04167 
04168         <span class="keywordflow">if</span> ( LengthRequired != 0 ) {
04169 
04170             <span class="comment">//</span>
04171             <span class="comment">// If after mapping the access mask, the access mask</span>
04172             <span class="comment">// is empty, then drop the ACE.</span>
04173             <span class="comment">//</span>
04174             <span class="comment">// This is incompatible with NT 4.0 which simply mapped and left</span>
04175             <span class="comment">//  undefined access bits set.</span>
04176 
04177             LocalMask = ((<a class="code" href="../../d4/d7/struct__KNOWN__ACE.html">PKNOWN_ACE</a>)(OldAce))-&gt;Mask;
04178             RtlApplyGenericMask( OldAce, &amp;LocalMask, GenericMapping);
04179 
04180             <span class="keywordflow">if</span> ( LocalMask != ((<a class="code" href="../../d4/d7/struct__KNOWN__ACE.html">PKNOWN_ACE</a>)(OldAce))-&gt;Mask ) {
04181                 *EffectiveAceMapped = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04182             }
04183 
04184             <span class="comment">//</span>
04185             <span class="comment">// Mask off any bits that aren't meaningful</span>
04186             <span class="comment">//</span>
04187 
04188             LocalMask &amp;= ( STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL | ACCESS_SYSTEM_SECURITY );
04189 
04190             <span class="keywordflow">if</span> (LocalMask == 0) {
04191 
04192                 LengthRequired = 0;
04193 
04194             } <span class="keywordflow">else</span> {
04195 
04196                 <span class="comment">//</span>
04197                 <span class="comment">// See if the SID in the ACE is one of the various CREATOR_* SIDs by</span>
04198                 <span class="comment">// comparing identifier authorities.</span>
04199                 <span class="comment">//</span>
04200 
04201                 <span class="keywordflow">if</span> (<a class="code" href="../../d8/d6/sertl_8c.html#a37">RtlEqualPrefixSid</a> ( SidToCopy, <a class="code" href="../../d4/d6/tsevars_8c.html#a33">CreatorSid</a> )) {
04202 
04203                     Rid = *RtlpSubAuthoritySid( SidToCopy, 0 );
04204 
04205                     <span class="keywordflow">switch</span> (Rid) {
04206                     <span class="keywordflow">case</span> SECURITY_CREATOR_OWNER_RID:
04207                         SidToCopy = ClientOwnerSid;
04208                         LengthRequired = LengthRequired - <a class="code" href="../../d8/d6/sertl_8c.html#a0">CREATOR_SID_SIZE</a> + <a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>(ClientOwnerSid);
04209                         *EffectiveAceMapped = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04210                         <span class="keywordflow">break</span>;
04211                     <span class="keywordflow">case</span> SECURITY_CREATOR_GROUP_RID:
04212                         <span class="keywordflow">if</span> ( ClientGroupSid != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
04213                             SidToCopy = ClientGroupSid;
04214                             LengthRequired = LengthRequired - <a class="code" href="../../d8/d6/sertl_8c.html#a0">CREATOR_SID_SIZE</a> + <a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>(ClientGroupSid);
04215                             *EffectiveAceMapped = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04216                         }
04217                         <span class="keywordflow">break</span>;
04218                     <span class="keywordflow">case</span> SECURITY_CREATOR_OWNER_SERVER_RID:
04219                         SidToCopy = LocalServerOwner;
04220                         LengthRequired = LengthRequired - <a class="code" href="../../d8/d6/sertl_8c.html#a0">CREATOR_SID_SIZE</a> + <a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>(LocalServerOwner);
04221                         *EffectiveAceMapped = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04222                         <span class="keywordflow">break</span>;
04223                     <span class="keywordflow">case</span> SECURITY_CREATOR_GROUP_SERVER_RID:
04224                         SidToCopy = LocalServerGroup;
04225                         LengthRequired = LengthRequired - <a class="code" href="../../d8/d6/sertl_8c.html#a0">CREATOR_SID_SIZE</a> + <a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>(LocalServerGroup);
04226                         *EffectiveAceMapped = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04227                         <span class="keywordflow">break</span>;
04228                     <span class="keywordflow">default</span> :
04229                         <span class="comment">//</span>
04230                         <span class="comment">// We don't know what this SID is, just copy the original.</span>
04231                         <span class="comment">//</span>
04232                         <span class="keywordflow">break</span>;
04233                     }
04234                 }
04235 
04236                 <span class="comment">//</span>
04237                 <span class="comment">// If the ACE doesn't fit,</span>
04238                 <span class="comment">//  just note the fact and don't copy the ACE.</span>
04239                 <span class="comment">//</span>
04240 
04241                 <span class="keywordflow">if</span> ( *AcePosition == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ||
04242                      LengthRequired &gt; (ULONG)NewAcl-&gt;AclSize - ((PUCHAR)(*AcePosition) - (PUCHAR)NewAcl) ) {
04243                     *AclOverflowed = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04244                 } <span class="keywordflow">else</span> {
04245 
04246                     PUCHAR Target;
04247 
04248                     <span class="comment">//</span>
04249                     <span class="comment">// Copy individual parts of the ACE separately.</span>
04250                     <span class="comment">//</span>
04251 
04252                     Target = (PUCHAR)*AcePosition;
04253 
04254                     RtlCopyMemory(
04255                         Target,
04256                         AceHeaderToCopy,
04257                         AceHeaderToCopyLength );
04258 
04259                     Target += AceHeaderToCopyLength;
04260 
04261                     <span class="comment">//</span>
04262                     <span class="comment">// Now copy the correct server SID</span>
04263                     <span class="comment">//</span>
04264 
04265                     <span class="keywordflow">if</span> ( ServerSidToCopy != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
04266                         RtlCopyMemory(
04267                             Target,
04268                             ServerSidToCopy,
04269                             <a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>(ServerSidToCopy)
04270                             );
04271                         Target += <a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>(ServerSidToCopy);
04272                     }
04273 
04274                     <span class="comment">//</span>
04275                     <span class="comment">// Now copy the correct SID</span>
04276                     <span class="comment">//</span>
04277 
04278                     RtlCopyMemory(
04279                         Target,
04280                         SidToCopy,
04281                         <a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>(SidToCopy)
04282                         );
04283                     Target += <a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>(SidToCopy);
04284 
04285                     <span class="comment">//</span>
04286                     <span class="comment">// Set the size of the ACE accordingly</span>
04287                     <span class="comment">//</span>
04288 
04289                     <span class="keywordflow">if</span> ( LengthRequired &lt; (ULONG)(Target - (PUCHAR)*AcePosition) ) {
04290                         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04291                     }
04292                     LengthRequired = (ULONG)(Target - (PUCHAR)*AcePosition);
04293                     ((<a class="code" href="../../d4/d7/struct__KNOWN__ACE.html">PKNOWN_ACE</a>)*AcePosition)-&gt;Header.AceSize =
04294                         (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)LengthRequired;
04295 
04296 
04297                     <span class="comment">//</span>
04298                     <span class="comment">// Put the mapped access mask in the new ACE</span>
04299                     <span class="comment">//</span>
04300 
04301                     ((<a class="code" href="../../d4/d7/struct__KNOWN__ACE.html">PKNOWN_ACE</a>)*AcePosition)-&gt;Mask = LocalMask;
04302 
04303                 }
04304             }
04305         }
04306 
04307     } <span class="keywordflow">else</span> {
04308 
04309         <span class="comment">//</span>
04310         <span class="comment">// If the ACE doesn't fit,</span>
04311         <span class="comment">//  just note the fact and don't copy the ACE.</span>
04312         <span class="comment">//</span>
04313 
04314         <span class="keywordflow">if</span> ( LengthRequired &gt; (ULONG)NewAcl-&gt;AclSize - ((PUCHAR)*AcePosition - (PUCHAR)NewAcl) ) {
04315             *AclOverflowed = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04316         } <span class="keywordflow">else</span> {
04317 
04318             <span class="comment">//</span>
04319             <span class="comment">// Not a known ACE type, copy ACE as is</span>
04320             <span class="comment">//</span>
04321 
04322             RtlCopyMemory(
04323                 *AcePosition,
04324                 OldAce,
04325                 LengthRequired );
04326          }
04327     }
04328 
04329     <span class="comment">//</span>
04330     <span class="comment">// If the ACE was actually kept, clear all the inherit flags</span>
04331     <span class="comment">// and update the ACE count of the ACL.</span>
04332     <span class="comment">//</span>
04333 
04334     <span class="keywordflow">if</span> ( !*AclOverflowed &amp;&amp; LengthRequired != 0 ) {
04335         ((PACE_HEADER)*AcePosition)-&gt;AceFlags &amp;= ~VALID_INHERIT_FLAGS;
04336         <span class="keywordflow">if</span> ( AutoInherit ) {
04337             ((PACE_HEADER)*AcePosition)-&gt;AceFlags |= INHERITED_ACE;
04338         }
04339         NewAcl-&gt;AceCount += 1;
04340     }
04341 
04342     <span class="comment">//</span>
04343     <span class="comment">// We have the length of the new ACE, but we've calculated</span>
04344     <span class="comment">// it with a ULONG.  It must fit into a USHORT.  See if it</span>
04345     <span class="comment">// does.</span>
04346     <span class="comment">//</span>
04347 
04348     <span class="keywordflow">if</span> (LengthRequired &gt; 0xFFFF) {
04349         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04350     }
04351 
04352     <span class="comment">//</span>
04353     <span class="comment">// Move the Ace Position to where the next ACE goes.</span>
04354     <span class="comment">//</span>
04355     <span class="keywordflow">if</span> ( !*AclOverflowed ) {
04356         *AcePosition = ((PUCHAR)*AcePosition) + LengthRequired;
04357     }
04358 
04359     <span class="comment">//</span>
04360     <span class="comment">//  Now return to our caller</span>
04361     <span class="comment">//</span>
04362 
04363     (*NewAceLength) = LengthRequired;
04364 
04365     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04366 }
04367 
04368 <span class="preprocessor">#ifndef WIN16</span>
04369 <span class="preprocessor"></span>
04370 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l04371"></a><a class="code" href="../../d8/d6/sertl_8c.html#a17">04371</a> <a class="code" href="../../d8/d6/sertl_8c.html#a17">RtlpCopyAces</a>(
04372     IN PACL Acl,
04373     IN PGENERIC_MAPPING GenericMapping,
04374     IN ACE_TYPE_TO_COPY AceTypeToCopy,
04375     IN UCHAR AceFlagsToReset,
04376     IN BOOLEAN MapSids,
04377     IN PSID ClientOwnerSid,
04378     IN PSID ClientGroupSid,
04379     IN PSID ServerOwnerSid OPTIONAL,
04380     IN PSID ServerGroupSid OPTIONAL,
04381     OUT PULONG NewAclSizeParam,
04382     OUT PACL NewAcl
04383     )
04384 
04385 <span class="comment">/*++</span>
04386 <span class="comment"></span>
04387 <span class="comment">Routine Description:</span>
04388 <span class="comment"></span>
04389 <span class="comment">    Copy ACEs from of an ACL and perform generic mapping.  Only ACEs specified</span>
04390 <span class="comment">    by 'AceFilter' are copied.</span>
04391 <span class="comment"></span>
04392 <span class="comment">Arguments:</span>
04393 <span class="comment"></span>
04394 <span class="comment">    Acl - Supplies the ACL to copy from.</span>
04395 <span class="comment"></span>
04396 <span class="comment">    GenericMapping - Specifies the generic mapping to use.</span>
04397 <span class="comment"></span>
04398 <span class="comment">    AceTypeToCopy - Describes which aces to copy.</span>
04399 <span class="comment"></span>
04400 <span class="comment">    AceFlagsToReset - Bit mask of ACE flags to reset (if set) on each ACE.</span>
04401 <span class="comment"></span>
04402 <span class="comment">    MapSids - TRUE if the SID in the ACE is to be mapped to the corresponding</span>
04403 <span class="comment">        actual SID.</span>
04404 <span class="comment"></span>
04405 <span class="comment">    ClientOwnerSid - Specifies the owner Sid to use</span>
04406 <span class="comment"></span>
04407 <span class="comment">    ClientGroupSid - Specifies the new Group Sid to use</span>
04408 <span class="comment"></span>
04409 <span class="comment">    ServerOwnerSid - Optionally specifies the Server Sid to use in compound ACEs.</span>
04410 <span class="comment"></span>
04411 <span class="comment">    ServerGroupSid - Optionally specifies the Server group Sid to use in compound ACEs.</span>
04412 <span class="comment"></span>
04413 <span class="comment">    NewAclSizeParam - Receives the cumulatiave length of the copies ACEs</span>
04414 <span class="comment"></span>
04415 <span class="comment">    NewAcl - Provides a pointer to the ACL to copy to.</span>
04416 <span class="comment">        This ACL must already be initialized.</span>
04417 <span class="comment"></span>
04418 <span class="comment"></span>
04419 <span class="comment">Return Value:</span>
04420 <span class="comment"></span>
04421 <span class="comment">    STATUS_SUCCESS - An inheritable ACL has been generated.</span>
04422 <span class="comment"></span>
04423 <span class="comment">    STATUS_BUFFER_TOO_SMALL - The ACL specified by NewAcl is too small for the</span>
04424 <span class="comment">        copied ACEs.  The required size is returned in NewAceLength.</span>
04425 <span class="comment"></span>
04426 <span class="comment"></span>
04427 <span class="comment">--*/</span>
04428 
04429 {
04430 
04431     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
04432     ULONG i;
04433 
04434     PACE_HEADER OldAce;
04435     ULONG NewAclSize, NewAceSize;
04436     BOOLEAN AclOverflowed = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04437     BOOLEAN CopyAce;
04438     PVOID AcePosition;
04439 
04440 
04441     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
04442 
04443     <span class="comment">//</span>
04444     <span class="comment">// Validate the ACL.</span>
04445     <span class="comment">//</span>
04446 
04447     <span class="keywordflow">if</span> ( !ValidAclRevision(NewAcl) ) {
04448         <span class="keywordflow">return</span> STATUS_UNKNOWN_REVISION;
04449     }
04450 
04451     <span class="comment">//</span>
04452     <span class="comment">// Find where the first ACE goes.</span>
04453     <span class="comment">//</span>
04454 
04455     <span class="keywordflow">if</span> (!<a class="code" href="../../d2/d4/acledit_8c.html#a25">RtlFirstFreeAce</a>( NewAcl, &amp;AcePosition )) {
04456         <span class="keywordflow">return</span> STATUS_BAD_INHERITANCE_ACL;
04457     }
04458 
04459     <span class="comment">//</span>
04460     <span class="comment">// Walk through the original ACL copying ACEs.</span>
04461     <span class="comment">//</span>
04462 
04463     NewAclSize = 0;
04464     <span class="keywordflow">for</span> (i = 0, OldAce = <a class="code" href="../../d4/d1/rtdmpsec_8c.html#a1">FirstAce</a>(Acl);
04465          i &lt; Acl-&gt;AceCount;
04466          i += 1, OldAce = <a class="code" href="../../d4/d1/rtdmpsec_8c.html#a2">NextAce</a>(OldAce)) {
04467 
04468         <span class="comment">//</span>
04469         <span class="comment">// If the ACE wasn't inherited,</span>
04470         <span class="comment">//  copy it.</span>
04471         <span class="comment">//</span>
04472 
04473         <span class="keywordflow">switch</span> (AceTypeToCopy) {
04474         <span class="keywordflow">case</span> <a class="code" href="../../d8/d6/sertl_8c.html#a80a10">CopyInheritedAces</a>:
04475             CopyAce = AceInherited(OldAce);
04476             <span class="keywordflow">break</span>;
04477         <span class="keywordflow">case</span> <a class="code" href="../../d8/d6/sertl_8c.html#a80a11">CopyNonInheritedAces</a>:
04478             CopyAce = !AceInherited(OldAce);
04479             <span class="keywordflow">break</span>;
04480         <span class="keywordflow">case</span> <a class="code" href="../../d8/d6/sertl_8c.html#a80a12">CopyAllAces</a>:
04481             CopyAce = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04482             <span class="keywordflow">break</span>;
04483         <span class="keywordflow">default</span>:
04484             CopyAce = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04485             <span class="keywordflow">break</span>;
04486         }
04487 
04488         <span class="keywordflow">if</span> ( CopyAce ) {
04489 
04490 
04491             <span class="comment">//</span>
04492             <span class="comment">// If SIDs are to be mapped,</span>
04493             <span class="comment">//  do so (and potentially create up to two ACEs).</span>
04494             <span class="comment">//</span>
04495 
04496             <span class="keywordflow">if</span> ( MapSids ) {
04497                 PVOID TempAcePosition;
04498                 ULONG EffectiveAceSize = 0;
04499 
04500                 BOOLEAN EffectiveAceMapped;
04501                 BOOLEAN GenerateInheritAce;
04502 
04503                 <span class="comment">//</span>
04504                 <span class="comment">// Remember where the next ACE will be copied.</span>
04505                 <span class="comment">//</span>
04506 
04507                 TempAcePosition = AcePosition;
04508                 NewAceSize = 0;
04509                 GenerateInheritAce =
04510                     (((PACE_HEADER)OldAce)-&gt;AceFlags &amp; (OBJECT_INHERIT_ACE|CONTAINER_INHERIT_ACE)) != 0;
04511 
04512 
04513                 <span class="comment">//</span>
04514                 <span class="comment">// If the orginal ACE is an effective ACE,</span>
04515                 <span class="comment">//  create an effective ACE.</span>
04516                 <span class="comment">//</span>
04517 
04518                 <span class="keywordflow">if</span> ( !(((PACE_HEADER)OldAce)-&gt;AceFlags &amp; INHERIT_ONLY_ACE)) {
04519                     BOOLEAN LocalAclOverflowed;
04520 
04521                     <span class="comment">//</span>
04522                     <span class="comment">// Copy the effective ACE into the ACL.</span>
04523                     <span class="comment">//</span>
04524                     <span class="keywordflow">if</span> ( !<a class="code" href="../../d8/d6/sertl_8c.html#a16">RtlpCopyEffectiveAce</a> (
04525                                     OldAce,
04526                                     <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,  <span class="comment">// Don't set the auto inherit bit</span>
04527                                     GenerateInheritAce,
04528                                     ClientOwnerSid,
04529                                     ClientGroupSid,
04530                                     ServerOwnerSid,
04531                                     ServerGroupSid,
04532                                     GenericMapping,
04533                                     <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,   <span class="comment">// Always copy object ACES</span>
04534                                     &amp;TempAcePosition,
04535                                     &amp;EffectiveAceSize,
04536                                     NewAcl,
04537                                     <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,   <span class="comment">// Always copy object ACES</span>
04538                                     &amp;EffectiveAceMapped,
04539                                     &amp;LocalAclOverflowed ) ) {
04540 
04541                         <span class="keywordflow">return</span> STATUS_BAD_INHERITANCE_ACL;
04542                     }
04543 
04544                     <span class="keywordflow">if</span> (LocalAclOverflowed) {
04545                         AclOverflowed = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04546                     }
04547                     NewAceSize += EffectiveAceSize;
04548 
04549                     <span class="comment">//</span>
04550                     <span class="comment">// Reset any undesirable AceFlags.</span>
04551                     <span class="comment">//</span>
04552 
04553                     <span class="keywordflow">if</span> ( !AclOverflowed ) {
04554                         ((PACE_HEADER)AcePosition)-&gt;AceFlags &amp;= ~AceFlagsToReset;
04555                     }
04556 
04557                 }
04558 
04559                 <span class="comment">//</span>
04560                 <span class="comment">// If the original ACE is inheritable,</span>
04561                 <span class="comment">//  create an inheritable ACE.</span>
04562                 <span class="comment">//</span>
04563                 <span class="comment">// ASSERT: AcePosition points to where the effective ACE was copied</span>
04564                 <span class="comment">// ASSERT: TempAcePosition points to where the inheritable ACE should be copied</span>
04565                 <span class="comment">//</span>
04566 
04567                 <span class="keywordflow">if</span> ( GenerateInheritAce ) {
04568 
04569                     <span class="comment">//</span>
04570                     <span class="comment">// If a effective ACE was created,</span>
04571                     <span class="comment">//  and it wasn't mapped,</span>
04572                     <span class="comment">//  avoid generating another ACE and simply merge the inheritance bits into</span>
04573                     <span class="comment">//      the effective ACE.</span>
04574                     <span class="comment">//</span>
04575 
04576                     <span class="keywordflow">if</span> ( EffectiveAceSize != 0 &amp;&amp; !EffectiveAceMapped ) {
04577 
04578                        <span class="comment">//</span>
04579                        <span class="comment">// Copy the inherit bits from the original ACE.</span>
04580                        <span class="comment">//</span>
04581                        <span class="keywordflow">if</span> ( !AclOverflowed ) {
04582                             ((PACE_HEADER)AcePosition)-&gt;AceFlags |=
04583                                 ((PACE_HEADER)OldAce)-&gt;AceFlags &amp; (VALID_INHERIT_FLAGS);
04584                             ((PACE_HEADER)AcePosition)-&gt;AceFlags &amp;= ~AceFlagsToReset;
04585                        }
04586 
04587 
04588                     <span class="comment">//</span>
04589                     <span class="comment">// Otherwise, generate an explicit inheritance ACE.</span>
04590                     <span class="comment">//</span>
04591                     <span class="comment">// But only if the access mask isn't zero.</span>
04592                     <span class="comment">//</span>
04593 
04594                     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( !IsMSAceType(OldAce) || ((<a class="code" href="../../d4/d7/struct__KNOWN__ACE.html">PKNOWN_ACE</a>)(OldAce))-&gt;Mask != 0 ) {
04595 
04596                         <span class="comment">//</span>
04597                         <span class="comment">// Account for the new ACE being added to the ACL.</span>
04598                         <span class="comment">//</span>
04599                         NewAceSize += (ULONG)(((PACE_HEADER)OldAce)-&gt;AceSize);
04600 
04601                         <span class="keywordflow">if</span> (NewAceSize &gt; 0xFFFF) {
04602                             <span class="keywordflow">return</span> STATUS_BAD_INHERITANCE_ACL;
04603                         }
04604 
04605                         <span class="comment">//</span>
04606                         <span class="comment">// If the ACE doesn't fit,</span>
04607                         <span class="comment">//  just note the fact and don't copy the ACE.</span>
04608                         <span class="comment">//</span>
04609 
04610                         <span class="keywordflow">if</span> ( ((PACE_HEADER)OldAce)-&gt;AceSize &gt; NewAcl-&gt;AclSize - ((PUCHAR)TempAcePosition - (PUCHAR)NewAcl) ) {
04611                             AclOverflowed = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04612                         } <span class="keywordflow">else</span> {
04613 
04614                             <span class="comment">//</span>
04615                             <span class="comment">// copy it as is, but make sure the InheritOnly bit is set.</span>
04616                             <span class="comment">//</span>
04617 
04618                             <span class="keywordflow">if</span> ( !AclOverflowed ) {
04619                                 RtlCopyMemory(
04620                                     TempAcePosition,
04621                                     OldAce,
04622                                     ((PACE_HEADER)OldAce)-&gt;AceSize
04623                                     );
04624 
04625                                 ((PACE_HEADER)TempAcePosition)-&gt;AceFlags |= INHERIT_ONLY_ACE;
04626                                 ((PACE_HEADER)TempAcePosition)-&gt;AceFlags &amp;= ~AceFlagsToReset;
04627                                 NewAcl-&gt;AceCount += 1;
04628                             }
04629                         }
04630                     }
04631 
04632                 }
04633 
04634             } <span class="keywordflow">else</span> {
04635                 NewAceSize = (ULONG)OldAce-&gt;AceSize;
04636 
04637                 <span class="comment">//</span>
04638                 <span class="comment">// If the ACE doesn't fit,</span>
04639                 <span class="comment">//  just note the fact and don't copy the ACE.</span>
04640                 <span class="comment">//</span>
04641 
04642                 <span class="keywordflow">if</span> ( AcePosition == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ||
04643                      NewAceSize &gt; (ULONG)NewAcl-&gt;AclSize - ((PUCHAR)AcePosition - (PUCHAR)NewAcl) ) {
04644                     AclOverflowed = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04645                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( !AclOverflowed ) {
04646 
04647 
04648                     <span class="comment">//</span>
04649                     <span class="comment">// Copy the ACE.</span>
04650                     <span class="comment">//</span>
04651 
04652                     RtlCopyMemory(
04653                         AcePosition,
04654                         OldAce,
04655                         NewAceSize );
04656 
04657                     <span class="comment">//</span>
04658                     <span class="comment">// Map the generic bits.</span>
04659                     <span class="comment">//</span>
04660                     <span class="comment">// Is it really right to map the generic bits on an ACE</span>
04661                     <span class="comment">// that's both effective and inheritable.  Shouldn't this</span>
04662                     <span class="comment">// be split into two ACEs in that case?  Or just skip the mapping?</span>
04663                     <span class="comment">//</span>
04664                     <span class="keywordflow">if</span> (IsMSAceType( AcePosition )) {
04665                         RtlApplyAceToObject( (PACE_HEADER)AcePosition, GenericMapping );
04666                     }
04667 
04668                     <span class="comment">//</span>
04669                     <span class="comment">// Reset any undesirable AceFlags.</span>
04670                     <span class="comment">//</span>
04671 
04672                     ((PACE_HEADER)AcePosition)-&gt;AceFlags &amp;= ~AceFlagsToReset;
04673 
04674                     <span class="comment">//</span>
04675                     <span class="comment">// Account for the new ACE.</span>
04676                     <span class="comment">//</span>
04677 
04678                     NewAcl-&gt;AceCount += 1;
04679                 }
04680             }
04681 
04682 
04683             <span class="comment">//</span>
04684             <span class="comment">// Move the Ace Position to where the next ACE goes.</span>
04685             <span class="comment">//</span>
04686             <span class="keywordflow">if</span> ( !AclOverflowed ) {
04687                 AcePosition = ((PUCHAR)AcePosition) + NewAceSize;
04688             } <span class="keywordflow">else</span> {
04689                 <span class="comment">// On overflow, ensure no other ACEs are actually output to the buffer</span>
04690                 AcePosition = ((PUCHAR)NewAcl) + NewAcl-&gt;AclSize;
04691             }
04692             NewAclSize += NewAceSize;
04693 
04694         }
04695     }
04696 
04697 
04698     <span class="comment">//</span>
04699     <span class="comment">// We have the length of the new ACE, but we've calculated</span>
04700     <span class="comment">// it with a ULONG.  It must fit into a USHORT.  See if it</span>
04701     <span class="comment">// does.</span>
04702     <span class="comment">//</span>
04703 
04704     <span class="keywordflow">if</span> (NewAclSize &gt; 0xFFFF) {
04705         <span class="keywordflow">return</span> STATUS_BAD_INHERITANCE_ACL;
04706     }
04707 
04708     (*NewAclSizeParam) = NewAclSize;
04709 
04710     <span class="keywordflow">return</span> AclOverflowed ? STATUS_BUFFER_TOO_SMALL : STATUS_SUCCESS;
04711 
04712 }
04713 
04714 
04715 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l04716"></a><a class="code" href="../../d8/d6/sertl_8c.html#a20">04716</a> <a class="code" href="../../d8/d6/sertl_8c.html#a20">RtlpInheritAcl2</a> (
04717     IN PACL DirectoryAcl,
04718     IN PACL ChildAcl,
04719     IN ULONG ChildGenericControl,
04720     IN BOOLEAN IsDirectoryObject,
04721     IN BOOLEAN AutoInherit,
04722     IN BOOLEAN DefaultDescriptorForObject,
04723     IN PSID OwnerSid,
04724     IN PSID GroupSid,
04725     IN PSID ServerOwnerSid OPTIONAL,
04726     IN PSID ServerGroupSid OPTIONAL,
04727     IN PGENERIC_MAPPING GenericMapping,
04728     IN BOOLEAN IsSacl,
04729     IN GUID *NewObjectType OPTIONAL,
04730     IN PULONG AclBufferSize,
04731     IN OUT PUCHAR AclBuffer,
04732     OUT PBOOLEAN NewAclExplicitlyAssigned,
04733     OUT PULONG NewGenericControl
04734     )
04735 
04736 <span class="comment">/*++</span>
04737 <span class="comment"></span>
04738 <span class="comment">Routine Description:</span>
04739 <span class="comment"></span>
04740 <span class="comment">    This is a private routine that produces an inherited acl from</span>
04741 <span class="comment">    a parent acl according to the rules of inheritance</span>
04742 <span class="comment"></span>
04743 <span class="comment">Arguments:</span>
04744 <span class="comment"></span>
04745 <span class="comment">    DirectoryAcl - Supplies the acl being inherited.</span>
04746 <span class="comment"></span>
04747 <span class="comment">    ChildAcl - Supplies the acl associated with the object.  This</span>
04748 <span class="comment">        is either the current acl on the object or the acl being assigned</span>
04749 <span class="comment">        to the object.</span>
04750 <span class="comment"></span>
04751 <span class="comment">    ChildGenericControl - Specifies the control flags from the SecurityDescriptor</span>
04752 <span class="comment">        describing the ChildAcl:</span>
04753 <span class="comment"></span>
04754 <span class="comment">        SEP_ACL_PRESENT: Specifies that the child ACL is explictly supplied by</span>
04755 <span class="comment">            the caller.</span>
04756 <span class="comment"></span>
04757 <span class="comment">        SEP_ACL_DEFAULTED: Specifies that the child ACL was supplied by some</span>
04758 <span class="comment">            defaulting mechanism.</span>
04759 <span class="comment"></span>
04760 <span class="comment">        SEP_ACL_PROTECTED: Specifies that the child ACL is protected and</span>
04761 <span class="comment">            should not inherit any ACE from the DirectoryACL</span>
04762 <span class="comment"></span>
04763 <span class="comment">    IsDirectoryObject - Specifies if the new acl is for a directory.</span>
04764 <span class="comment"></span>
04765 <span class="comment">    AutoInherit - Specifies if the inheritance is an "automatic inheritance".</span>
04766 <span class="comment">        As such, the non-inherited ACEs from the ChildAcl will be preserved and</span>
04767 <span class="comment">        the inherited ACEs from the DirectoryAcl will be marked as such.</span>
04768 <span class="comment"></span>
04769 <span class="comment">    DefaultDescriptorForObject - If set, the CreatorDescriptor</span>
04770 <span class="comment">        is the default descriptor for ObjectType.  As such, the</span>
04771 <span class="comment">        CreatorDescriptor will be ignored if any ObjectType specific</span>
04772 <span class="comment">        ACEs are inherited from the parent.  If not such ACEs are inherited,</span>
04773 <span class="comment">        the CreatorDescriptor is handled as though this flag were not</span>
04774 <span class="comment">        specified.</span>
04775 <span class="comment"></span>
04776 <span class="comment">    OwnerSid - Specifies the owner Sid to use.</span>
04777 <span class="comment"></span>
04778 <span class="comment">    GroupSid - Specifies the group SID to use.</span>
04779 <span class="comment"></span>
04780 <span class="comment">    GenericMapping - Specifies the generic mapping to use.</span>
04781 <span class="comment"></span>
04782 <span class="comment">    IsSacl - True if this is the SACL.  False if this is the DACL.</span>
04783 <span class="comment"></span>
04784 <span class="comment">    NewObjectType - Type of object being inherited to.  If not specified,</span>
04785 <span class="comment">        the object has no object type.</span>
04786 <span class="comment"></span>
04787 <span class="comment">    AclBufferSize - On input, specifies the size of AclBuffer.</span>
04788 <span class="comment">        On output, on success, returns the used size of AclBuffer.</span>
04789 <span class="comment">        On output, if the buffer is too small, returns the required size of AclBuffer.</span>
04790 <span class="comment"></span>
04791 <span class="comment">    AclBuffer - Receives a pointer to the new (inherited) acl.</span>
04792 <span class="comment"></span>
04793 <span class="comment">    NewAclExplicitlyAssigned - Returns true to indicate that some portion of</span>
04794 <span class="comment">        "NewAcl" was derived from an the explicit ChildAcl</span>
04795 <span class="comment"></span>
04796 <span class="comment">    NewGenericControl - Specifies the control flags for the newly</span>
04797 <span class="comment">        generated ACL.</span>
04798 <span class="comment"></span>
04799 <span class="comment">        SEP_ACL_AUTO_INHERITED: Set if the ACL was generated using the</span>
04800 <span class="comment">            Automatic Inheritance algorithm.</span>
04801 <span class="comment"></span>
04802 <span class="comment">        SEP_ACL_PROTECTED: Specifies that the ACL is protected and</span>
04803 <span class="comment">            was not inherited from the parent ACL.</span>
04804 <span class="comment"></span>
04805 <span class="comment">Return Value:</span>
04806 <span class="comment"></span>
04807 <span class="comment">    STATUS_SUCCESS - An inheritable ACL was successfully generated.</span>
04808 <span class="comment"></span>
04809 <span class="comment">    STATUS_NO_INHERITANCE - An inheritable ACL was not successfully generated.</span>
04810 <span class="comment">        This is a warning completion status.  The caller should use the default</span>
04811 <span class="comment">        ACL.</span>
04812 <span class="comment"></span>
04813 <span class="comment">    STATUS_BAD_INHERITANCE_ACL - Indicates the acl built was not a valid ACL.</span>
04814 <span class="comment">        This can becaused by a number of things.  One of the more probable</span>
04815 <span class="comment">        causes is the replacement of a CreatorId with an SID that didn't fit</span>
04816 <span class="comment">        into the ACE or ACL.</span>
04817 <span class="comment"></span>
04818 <span class="comment">    STATUS_UNKNOWN_REVISION - Indicates the source ACL is a revision that</span>
04819 <span class="comment">        is unknown to this routine.</span>
04820 <span class="comment"></span>
04821 <span class="comment">    STATUS_BUFFER_TOO_SMALL - The ACL specified by NewAcl is too small for the</span>
04822 <span class="comment">        inheritance ACEs.  The required size is returned in AclBufferSize.</span>
04823 <span class="comment"></span>
04824 <span class="comment">--*/</span>
04825 
04826 {
04827     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
04828     ULONG ChildNewAclSize = 0;
04829     ULONG UsedChildNewAclSize = 0;
04830     ULONG DirectoryNewAclSize = 0;
04831     ULONG AclRevision;
04832     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> ChildAceCount;
04833     PVOID ChildAcePosition;
04834     PVOID DirectoryAcePosition;
04835     BOOLEAN AclOverflowed = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04836     BOOLEAN AclProtected = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04837     BOOLEAN NullAclOk = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04838     BOOLEAN ObjectAceInherited;
04839 
04840     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
04841 
04842 
04843     <span class="comment">//</span>
04844     <span class="comment">// Assume the ACL revision.</span>
04845     <span class="comment">//</span>
04846 
04847     AclRevision = ACL_REVISION;
04848     <a class="code" href="../../d2/d4/acledit_8c.html#a6">RtlCreateAcl</a>( (PACL)AclBuffer, *AclBufferSize, AclRevision );
04849     *NewAclExplicitlyAssigned = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04850     *NewGenericControl = AutoInherit ? SEP_ACL_AUTO_INHERITED : 0;
04851 
04852     <span class="comment">//</span>
04853     <span class="comment">// If the a current child ACL is not defaulted,</span>
04854     <span class="comment">//  the non-inherited ACEs from the current child ACL are to be preserved.</span>
04855     <span class="comment">//</span>
04856 
04857     <span class="keywordflow">if</span> ( (ChildGenericControl &amp; SEP_ACL_DEFAULTED) == 0 ) {
04858 
04859         <span class="comment">//</span>
04860         <span class="comment">// The resultant ACL should be protected if the input ACL is</span>
04861         <span class="comment">//  protected.</span>
04862         <span class="comment">//</span>
04863 
04864         <span class="keywordflow">if</span> ( ChildGenericControl &amp; SEP_ACL_PROTECTED ) {
04865             AclProtected = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04866             *NewGenericControl |= SEP_ACL_PROTECTED;
04867         }
04868 
04869         <span class="comment">//</span>
04870         <span class="comment">// Only copy ACEs if the child ACL is actually present.</span>
04871         <span class="comment">//</span>
04872         <span class="keywordflow">if</span> ( (ChildGenericControl &amp; (SEP_ACL_PRESENT|SEP_ACL_PROTECTED)) != 0 ) {
04873 
04874 
04875             <span class="keywordflow">if</span> ( ChildAcl != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
04876                 <a class="code" href="../../d8/d6/sertl_8c.html#a80">ACE_TYPE_TO_COPY</a> AceTypeToCopy;
04877                 UCHAR AceFlagsToReset;
04878                 BOOLEAN MapSids;
04879 
04880 
04881                 AclRevision = <a class="code" href="../../d8/d6/sertl_8c.html#a1">max</a>( AclRevision, ChildAcl-&gt;AclRevision );
04882 
04883                 <span class="comment">//</span>
04884                 <span class="comment">// Since we're explicitly using the ACL specified by the caller,</span>
04885                 <span class="comment">//  we never want to return a NULL ACL.</span>
04886                 <span class="comment">//  Rather, if we have an ACL with no ACEs,</span>
04887                 <span class="comment">//  we'll return exactly that.  For a DACL, that results</span>
04888                 <span class="comment">//  in a DACL that grants no access rather than a DACL</span>
04889                 <span class="comment">//  that grants all access.</span>
04890                 <span class="comment">//</span>
04891 
04892                 NullAclOk = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04893 
04894                 <span class="comment">//</span>
04895                 <span class="comment">// If the caller doesn't understand auto inheritance,</span>
04896                 <span class="comment">//  simply preserve the specified ACL 100% intact.</span>
04897                 <span class="comment">//</span>
04898                 <span class="keywordflow">if</span> ( !AutoInherit ) {
04899 
04900                     AceTypeToCopy = <a class="code" href="../../d8/d6/sertl_8c.html#a80a12">CopyAllAces</a>;
04901                     AceFlagsToReset = 0;      <span class="comment">// Don't turn off any ACE Flags</span>
04902                     MapSids = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;          <span class="comment">// For backward compatibility</span>
04903 
04904                 <span class="comment">//</span>
04905                 <span class="comment">// If the child is protected,</span>
04906                 <span class="comment">//  keep all of the ACEs turning off the INHERITED ACE flags.</span>
04907                 <span class="comment">//</span>
04908                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ChildGenericControl &amp; SEP_ACL_PROTECTED ) {
04909 
04910                     AceTypeToCopy = <a class="code" href="../../d8/d6/sertl_8c.html#a80a12">CopyAllAces</a>;
04911                     AceFlagsToReset = INHERITED_ACE; <span class="comment">// Turn off all INHERITED_ACE flags</span>
04912                     MapSids = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04913 
04914                 <span class="comment">//</span>
04915                 <span class="comment">// If the child is not protected,</span>
04916                 <span class="comment">//  just copy the non-inherited ACEs.</span>
04917                 <span class="comment">//</span>
04918                 <span class="comment">// (The inherited ACEs will be recomputed from the parent.)</span>
04919                 <span class="comment">//</span>
04920                 } <span class="keywordflow">else</span> {
04921 
04922                     AceTypeToCopy = <a class="code" href="../../d8/d6/sertl_8c.html#a80a11">CopyNonInheritedAces</a>;
04923                     AceFlagsToReset = 0;      <span class="comment">// Don't turn off any ACE Flags</span>
04924                     MapSids = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04925 
04926                 }
04927 
04928                 <span class="comment">//</span>
04929                 <span class="comment">// Copy the requested ACEs.</span>
04930                 <span class="comment">//</span>
04931 
04932                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d8/d6/sertl_8c.html#a17">RtlpCopyAces</a>(
04933                             ChildAcl,
04934                             GenericMapping,
04935                             AceTypeToCopy,
04936                             AceFlagsToReset,
04937                             MapSids,
04938                             OwnerSid,
04939                             GroupSid,
04940                             ServerOwnerSid,
04941                             ServerGroupSid,
04942                             &amp;ChildNewAclSize,
04943                             (PACL)AclBuffer );
04944 
04945                 UsedChildNewAclSize = ChildNewAclSize;
04946                 <span class="keywordflow">if</span> ( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_BUFFER_TOO_SMALL ) {
04947                     AclOverflowed = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04948                     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
04949                 }
04950 
04951                 <span class="keywordflow">if</span> ( !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>) ) {
04952                     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
04953                 }
04954 
04955                 <span class="comment">//</span>
04956                 <span class="comment">// If this ACL might be ignored later,</span>
04957                 <span class="comment">//  remember the current state of the ACL.</span>
04958                 <span class="comment">//</span>
04959 
04960                 <span class="keywordflow">if</span> ( DefaultDescriptorForObject &amp;&amp; ChildNewAclSize != 0 ) {
04961                     ChildAceCount = ((PACL)AclBuffer)-&gt;AceCount;
04962 
04963                     <span class="keywordflow">if</span> (!<a class="code" href="../../d2/d4/acledit_8c.html#a25">RtlFirstFreeAce</a>( (PACL)AclBuffer, &amp;ChildAcePosition ) ) {
04964                         <span class="keywordflow">return</span> STATUS_BAD_INHERITANCE_ACL;
04965                     }
04966                 }
04967 
04968             <span class="comment">//</span>
04969             <span class="comment">// If the ACL isn't protected,</span>
04970             <span class="comment">//  don't allow NULL ACL semantics.</span>
04971             <span class="comment">//  (those semantics are ambiguous for auto inheritance)</span>
04972             <span class="comment">//</span>
04973             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( AutoInherit &amp;&amp;
04974                         !IsSacl &amp;&amp;
04975                         (ChildGenericControl &amp; (SEP_ACL_PRESENT|SEP_ACL_PROTECTED)) == SEP_ACL_PRESENT ) {
04976                 <span class="keywordflow">return</span> STATUS_INVALID_ACL;
04977 
04978             }
04979 
04980             *NewAclExplicitlyAssigned = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04981 
04982         }
04983 
04984     }
04985 
04986     <span class="comment">//</span>
04987     <span class="comment">// Inherit ACEs from the Directory ACL in any of the following cases:</span>
04988     <span class="comment">//  If !AutoInheriting,</span>
04989     <span class="comment">//      Inherit if there is no explicit child ACL (ignoring a defaulted child).</span>
04990     <span class="comment">//  If AutoInheriting,</span>
04991     <span class="comment">//      observe the protected flag.</span>
04992     <span class="comment">//</span>
04993 
04994     <span class="keywordflow">if</span> ( (!AutoInherit &amp;&amp;
04995             (ChildGenericControl &amp; SEP_ACL_PRESENT) == 0 ||
04996                 (ChildGenericControl &amp; SEP_ACL_DEFAULTED) != 0) ||
04997          (AutoInherit &amp;&amp; !AclProtected) ) {
04998 
04999         <span class="comment">//</span>
05000         <span class="comment">//  If there is no directory ACL,</span>
05001         <span class="comment">//      don't inherit from it.</span>
05002         <span class="comment">//</span>
05003 
05004         <span class="keywordflow">if</span> ( DirectoryAcl != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
05005 
05006             <span class="comment">//</span>
05007             <span class="comment">// If the DirectoryAcl is used,</span>
05008             <span class="comment">//  the revision of the Directory ACL is picked up.</span>
05009             <span class="comment">//</span>
05010 
05011             <span class="keywordflow">if</span> ( !ValidAclRevision(DirectoryAcl) ) {
05012                 <span class="keywordflow">return</span> STATUS_UNKNOWN_REVISION;
05013             }
05014 
05015             AclRevision = <a class="code" href="../../d8/d6/sertl_8c.html#a1">max</a>( AclRevision, DirectoryAcl-&gt;AclRevision );
05016 
05017             <span class="comment">//</span>
05018             <span class="comment">// Inherit the Parent's ACL.</span>
05019             <span class="comment">//</span>
05020 
05021             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d8/d6/sertl_8c.html#a19">RtlpGenerateInheritAcl</a>(
05022                          DirectoryAcl,
05023                          IsDirectoryObject,
05024                          AutoInherit,
05025                          OwnerSid,
05026                          GroupSid,
05027                          ServerOwnerSid,
05028                          ServerGroupSid,
05029                          GenericMapping,
05030                          NewObjectType,
05031                          &amp;DirectoryNewAclSize,
05032                          (PACL)AclBuffer,
05033                          &amp;ObjectAceInherited );
05034 
05035             <span class="keywordflow">if</span> ( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_BUFFER_TOO_SMALL ) {
05036                 AclOverflowed = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
05037                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
05038             }
05039 
05040             <span class="keywordflow">if</span> ( !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>) ) {
05041                 <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
05042             }
05043 
05044             <span class="comment">//</span>
05045             <span class="comment">// If the default descriptor for the object should be ditched,</span>
05046             <span class="comment">//  because object specific ACEs were inherited from the directory,</span>
05047             <span class="comment">//  ditch them now.</span>
05048             <span class="comment">//</span>
05049 
05050             <span class="keywordflow">if</span> ( DefaultDescriptorForObject &amp;&amp;
05051                  ChildNewAclSize != 0 &amp;&amp;
05052                  ObjectAceInherited &amp;&amp;
05053                  !AclOverflowed ) {
05054 
05055                 <span class="comment">//</span>
05056                 <span class="comment">// Compute the last used byte of the combined ACL</span>
05057                 <span class="comment">//</span>
05058                 <span class="keywordflow">if</span> (!<a class="code" href="../../d2/d4/acledit_8c.html#a25">RtlFirstFreeAce</a>( (PACL)AclBuffer, &amp;DirectoryAcePosition ) ) {
05059                     <span class="keywordflow">return</span> STATUS_BAD_INHERITANCE_ACL;
05060                 }
05061                 <span class="keywordflow">if</span> ( DirectoryAcePosition == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
05062                     DirectoryAcePosition = AclBuffer + ((PACL)AclBuffer)-&gt;AclSize;
05063                 }
05064 
05065 
05066 
05067                 <span class="comment">//</span>
05068                 <span class="comment">// Move all the inherited ACEs to the front of the ACL.</span>
05069                 <span class="comment">//</span>
05070 
05071                 RtlMoveMemory( <a class="code" href="../../d4/d1/rtdmpsec_8c.html#a1">FirstAce</a>( AclBuffer ),
05072                                ChildAcePosition,
05073                                (ULONG)(((PUCHAR)DirectoryAcePosition) -
05074                                 (PUCHAR)ChildAcePosition) );
05075 
05076                 <span class="comment">//</span>
05077                 <span class="comment">// Adjust the ACE count to remove the deleted ACEs</span>
05078                 <span class="comment">//</span>
05079 
05080                 ((PACL)AclBuffer)-&gt;AceCount -= ChildAceCount;
05081 
05082                 <span class="comment">//</span>
05083                 <span class="comment">// Save the number of bytes of the Child ACL that were</span>
05084                 <span class="comment">//  actually used.</span>
05085                 <span class="comment">//</span>
05086 
05087                 UsedChildNewAclSize = 0;
05088 
05089             }
05090         }
05091 
05092     }
05093 
05094     <span class="comment">//</span>
05095     <span class="comment">// If this routine didn't build the ACL,</span>
05096     <span class="comment">//  tell the caller.</span>
05097     <span class="comment">//</span>
05098 
05099     <span class="keywordflow">if</span> ( DirectoryNewAclSize + UsedChildNewAclSize == 0) {
05100 
05101         <span class="comment">//</span>
05102         <span class="comment">// If the ACL was not explicitly assigned,</span>
05103         <span class="comment">//  tell the caller to default the ACL.</span>
05104         <span class="comment">//</span>
05105         <span class="keywordflow">if</span> ( !(*NewAclExplicitlyAssigned) ) {
05106             *AclBufferSize = 0;
05107             <span class="keywordflow">return</span> STATUS_NO_INHERITANCE;
05108 
05109         <span class="comment">//</span>
05110         <span class="comment">// If the Acl was explictly assigned,</span>
05111         <span class="comment">//  generate a NULL ACL based on the path taken above.</span>
05112         <span class="comment">//</span>
05113 
05114         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( NullAclOk ) {
05115             *AclBufferSize = 0;
05116             <span class="keywordflow">return</span> STATUS_SUCCESS;
05117         }
05118 
05119         <span class="comment">// DbgBreakPoint();</span>
05120     }
05121 
05122 
05123     <span class="comment">//</span>
05124     <span class="comment">// And make sure we don't exceed the length limitations of an ACL (WORD)</span>
05125     <span class="comment">//</span>
05126 
05127     <span class="keywordflow">if</span> ( DirectoryNewAclSize + UsedChildNewAclSize + <span class="keyword">sizeof</span>(ACL) &gt; 0xFFFF) {
05128         <span class="keywordflow">return</span>(STATUS_BAD_INHERITANCE_ACL);
05129     }
05130 
05131     <span class="comment">// BUGBUG: The caller has to allocate a buffer large enough for</span>
05132     <span class="comment">// ChildNewAclSize rather than UsedChildNewAclSize.  Due to the nature of</span>
05133     <span class="comment">// my algorithm above.</span>
05134     (*AclBufferSize) = DirectoryNewAclSize + ChildNewAclSize + <span class="keyword">sizeof</span>(ACL);
05135 
05136     <span class="keywordflow">if</span> ( AclOverflowed ) {
05137         <span class="keywordflow">return</span> STATUS_BUFFER_TOO_SMALL;
05138     }
05139 
05140     <span class="comment">//</span>
05141     <span class="comment">// Patch the real ACL size and revision into the ACL</span>
05142     <span class="comment">//</span>
05143 
05144     ((PACL)AclBuffer)-&gt;AclSize = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)
05145         (DirectoryNewAclSize + UsedChildNewAclSize + <span class="keyword">sizeof</span>(ACL));
05146     ((PACL)AclBuffer)-&gt;AclRevision = (UCHAR) AclRevision;
05147 
05148     <span class="keywordflow">return</span> STATUS_SUCCESS;
05149 }
05150 
05151 
05152 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l05153"></a><a class="code" href="../../d8/d6/sertl_8c.html#a74">05153</a> <a class="code" href="../../d8/d6/sertl_8c.html#a74">RtlpInheritAcl</a> (
05154     IN PACL DirectoryAcl,
05155     IN PACL ChildAcl,
05156     IN ULONG ChildGenericControl,
05157     IN BOOLEAN IsDirectoryObject,
05158     IN BOOLEAN AutoInherit,
05159     IN BOOLEAN DefaultDescriptorForObject,
05160     IN PSID OwnerSid,
05161     IN PSID GroupSid,
05162     IN PSID ServerOwnerSid OPTIONAL,
05163     IN PSID ServerGroupSid OPTIONAL,
05164     IN PGENERIC_MAPPING GenericMapping,
05165     IN BOOLEAN IsSacl,
05166     IN GUID *NewObjectType OPTIONAL,
05167     OUT PACL *NewAcl,
05168     OUT PBOOLEAN NewAclExplicitlyAssigned,
05169     OUT PULONG NewGenericControl
05170     )
05171 
05172 <span class="comment">/*++</span>
05173 <span class="comment"></span>
05174 <span class="comment">Routine Description:</span>
05175 <span class="comment"></span>
05176 <span class="comment">    This is a private routine that produces an inherited acl from</span>
05177 <span class="comment">    a parent acl according to the rules of inheritance</span>
05178 <span class="comment"></span>
05179 <span class="comment">Arguments:</span>
05180 <span class="comment"></span>
05181 <span class="comment">    DirectoryAcl - Supplies the acl being inherited.</span>
05182 <span class="comment"></span>
05183 <span class="comment">    ChildAcl - Supplies the acl associated with the object.  This</span>
05184 <span class="comment">        is either the current acl on the object or the acl being assigned</span>
05185 <span class="comment">        to the object.</span>
05186 <span class="comment"></span>
05187 <span class="comment">    ChildGenericControl - Specifies the control flags from the SecurityDescriptor</span>
05188 <span class="comment">        describing the ChildAcl:</span>
05189 <span class="comment"></span>
05190 <span class="comment">        SEP_ACL_PRESENT: Specifies that the child ACL is explictly supplied by</span>
05191 <span class="comment">            the caller.</span>
05192 <span class="comment"></span>
05193 <span class="comment">        SEP_ACL_DEFAULTED: Specifies that the child ACL was supplied by some</span>
05194 <span class="comment">            defaulting mechanism.</span>
05195 <span class="comment"></span>
05196 <span class="comment">        SEP_ACL_PROTECTED: Specifies that the child ACL is protected and</span>
05197 <span class="comment">            should not inherit any ACE from the DirectoryACL</span>
05198 <span class="comment"></span>
05199 <span class="comment">    IsDirectoryObject - Specifies if the new acl is for a directory.</span>
05200 <span class="comment"></span>
05201 <span class="comment">    AutoInherit - Specifies if the inheritance is an "automatic inheritance".</span>
05202 <span class="comment">        As such, the non-inherited ACEs from the ChildAcl will be preserved and</span>
05203 <span class="comment">        the inherited ACEs from the DirectoryAcl will be marked as such.</span>
05204 <span class="comment"></span>
05205 <span class="comment">    DefaultDescriptorForObject - If set, the CreatorDescriptor</span>
05206 <span class="comment">        is the default descriptor for ObjectType.  As such, the</span>
05207 <span class="comment">        CreatorDescriptor will be ignored if any ObjectType specific</span>
05208 <span class="comment">        ACEs are inherited from the parent.  If not such ACEs are inherited,</span>
05209 <span class="comment">        the CreatorDescriptor is handled as though this flag were not</span>
05210 <span class="comment">        specified.</span>
05211 <span class="comment"></span>
05212 <span class="comment">    OwnerSid - Specifies the owner Sid to use.</span>
05213 <span class="comment"></span>
05214 <span class="comment">    GroupSid - Specifies the group SID to use.</span>
05215 <span class="comment"></span>
05216 <span class="comment">    GenericMapping - Specifies the generic mapping to use.</span>
05217 <span class="comment"></span>
05218 <span class="comment">    IsSacl - True if this is the SACL.  False if this is the DACL.</span>
05219 <span class="comment"></span>
05220 <span class="comment">    NewObjectType - Type of object being inherited to.  If not specified,</span>
05221 <span class="comment">        the object has no object type.</span>
05222 <span class="comment"></span>
05223 <span class="comment">    NewAcl - Receives a pointer to the new (inherited) acl.</span>
05224 <span class="comment"></span>
05225 <span class="comment">    NewAclExplicitlyAssigned - Returns true to indicate that some portion of</span>
05226 <span class="comment">        "NewAcl" was derived from an the explicit ChildAcl</span>
05227 <span class="comment"></span>
05228 <span class="comment">    NewGenericControl - Specifies the control flags for the newly</span>
05229 <span class="comment">        generated ACL.</span>
05230 <span class="comment"></span>
05231 <span class="comment">        SEP_ACL_AUTO_INHERITED: Set if the ACL was generated using the</span>
05232 <span class="comment">            Automatic Inheritance algorithm.</span>
05233 <span class="comment"></span>
05234 <span class="comment">        SEP_ACL_PROTECTED: Specifies that the ACL is protected and</span>
05235 <span class="comment">            was not inherited from the parent ACL.</span>
05236 <span class="comment"></span>
05237 <span class="comment">Return Value:</span>
05238 <span class="comment"></span>
05239 <span class="comment">    STATUS_SUCCESS - An inheritable ACL was successfully generated.</span>
05240 <span class="comment"></span>
05241 <span class="comment">    STATUS_NO_INHERITANCE - An inheritable ACL was not successfully generated.</span>
05242 <span class="comment">        This is a warning completion status.</span>
05243 <span class="comment"></span>
05244 <span class="comment">    STATUS_BAD_INHERITANCE_ACL - Indicates the acl built was not a valid ACL.</span>
05245 <span class="comment">        This can becaused by a number of things.  One of the more probable</span>
05246 <span class="comment">        causes is the replacement of a CreatorId with an SID that didn't fit</span>
05247 <span class="comment">        into the ACE or ACL.</span>
05248 <span class="comment"></span>
05249 <span class="comment">    STATUS_UNKNOWN_REVISION - Indicates the source ACL is a revision that</span>
05250 <span class="comment">        is unknown to this routine.</span>
05251 <span class="comment"></span>
05252 <span class="comment">--*/</span>
05253 
05254 {
05256 <span class="comment">//                                                                          //</span>
05257 <span class="comment">//   The logic in the ACL inheritance code must mirror the code for         //</span>
05258 <span class="comment">//   inheritance in the executive (in seassign.c).  Do not make changes     //</span>
05259 <span class="comment">//   here without also making changes in that module.                       //</span>
05260 <span class="comment">//                                                                          //</span>
05262 <span class="comment"></span>
05263 
05264 
05265     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
05266     ULONG AclBufferSize;
05267     ULONG i;
05268 
05269 <span class="preprocessor">#ifndef NTOS_KERNEL_RUNTIME</span>
05270 <span class="preprocessor"></span>    PVOID <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
05271 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
05272 <span class="preprocessor"></span>
05273     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
05274 
05275     <span class="comment">//</span>
05276     <span class="comment">// Get the handle to the current process heap</span>
05277     <span class="comment">//</span>
05278 
05279 <span class="preprocessor">#ifndef NTOS_KERNEL_RUNTIME</span>
05280 <span class="preprocessor"></span>    <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a> = RtlProcessHeap();
05281 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
05282 <span class="preprocessor"></span>
05283 
05284 
05285     <span class="comment">//</span>
05286     <span class="comment">// Implement a two pass strategy.</span>
05287     <span class="comment">//</span>
05288     <span class="comment">// First try to create the ACL in a fixed length buffer.</span>
05289     <span class="comment">// If that is too small,</span>
05290     <span class="comment">//  then use the buffer size determined on the first pass</span>
05291     <span class="comment">//</span>
05292 
05293     AclBufferSize = 1024;   <span class="comment">// Typical maximum size of an ACL</span>
05294     <span class="keywordflow">for</span> ( i=0; i&lt;2 ; i++ ) {
05295 
05296         <span class="comment">//</span>
05297         <span class="comment">// Allocate heap for the new ACL.</span>
05298         <span class="comment">//</span>
05299 
05300 <span class="preprocessor">#ifdef NTOS_KERNEL_RUNTIME</span>
05301 <span class="preprocessor"></span>        (*NewAcl) = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>(
05302                         <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>,
05303                         AclBufferSize,
05304                         'cAeS' );
05305 <span class="preprocessor">#else // NTOS_KERNEL_RUNTIME</span>
05306 <span class="preprocessor"></span>        (*NewAcl) = <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a0">RtlAllocateHeap</a>(
05307                         <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>,
05308                         <a class="code" href="../../d9/d2/ldrp_8h.html#a11">MAKE_TAG</a>(<a class="code" href="../../d9/d2/ldrp_8h.html#a17">SE_TAG</a>),
05309                         AclBufferSize );
05310 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
05311 <span class="preprocessor"></span>
05312         <span class="keywordflow">if</span> ((*NewAcl) == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
05313             <span class="keywordflow">return</span>( STATUS_NO_MEMORY );
05314         }
05315 
05316         <span class="comment">//</span>
05317         <span class="comment">// Actually build the inherited ACL.</span>
05318         <span class="comment">//</span>
05319 
05320         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d8/d6/sertl_8c.html#a20">RtlpInheritAcl2</a> (
05321                     DirectoryAcl,
05322                     ChildAcl,
05323                     ChildGenericControl,
05324                     IsDirectoryObject,
05325                     AutoInherit,
05326                     DefaultDescriptorForObject,
05327                     OwnerSid,
05328                     GroupSid,
05329                     ServerOwnerSid,
05330                     ServerGroupSid,
05331                     GenericMapping,
05332                     IsSacl,
05333                     NewObjectType,
05334                     &amp;AclBufferSize,
05335                     (PUCHAR) *NewAcl,
05336                     NewAclExplicitlyAssigned,
05337                     NewGenericControl );
05338 
05339 
05340         <span class="keywordflow">if</span> ( <a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>) ) {
05341 
05342             <span class="comment">//</span>
05343             <span class="comment">// If a NULL ACL should be used,</span>
05344             <span class="comment">//  tell the caller.</span>
05345             <span class="comment">//</span>
05346 
05347             <span class="keywordflow">if</span> ( AclBufferSize == 0 ) {
05348 
05349 <span class="preprocessor">#ifdef NTOS_KERNEL_RUNTIME</span>
05350 <span class="preprocessor"></span>                <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( *NewAcl );
05351 <span class="preprocessor">#else // NTOS_KERNEL_RUNTIME</span>
05352 <span class="preprocessor"></span>                <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, 0, *NewAcl );
05353 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
05354 <span class="preprocessor"></span>
05355                 *NewAcl = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
05356             }
05357 
05358             <span class="keywordflow">break</span>;
05359 
05360         } <span class="keywordflow">else</span> {
05361 <span class="preprocessor">#ifdef NTOS_KERNEL_RUNTIME</span>
05362 <span class="preprocessor"></span>            <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( *NewAcl );
05363 <span class="preprocessor">#else // NTOS_KERNEL_RUNTIME</span>
05364 <span class="preprocessor"></span>            <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, 0, *NewAcl );
05365 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
05366 <span class="preprocessor"></span>
05367             *NewAcl = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
05368 
05369             <span class="keywordflow">if</span> ( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> != STATUS_BUFFER_TOO_SMALL ) {
05370                 <span class="keywordflow">break</span>;
05371             }
05372         }
05373     }
05374 
05375 
05376     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
05377 }
05378 
05379 
05380 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l05381"></a><a class="code" href="../../d8/d6/sertl_8c.html#a18">05381</a> <a class="code" href="../../d8/d6/sertl_8c.html#a18">RtlpGenerateInheritedAce</a> (
05382     IN PACE_HEADER OldAce,
05383     IN BOOLEAN IsDirectoryObject,
05384     IN BOOLEAN AutoInherit,
05385     IN PSID ClientOwnerSid,
05386     IN PSID ClientGroupSid,
05387     IN PSID ServerOwnerSid OPTIONAL,
05388     IN PSID ServerGroupSid OPTIONAL,
05389     IN PGENERIC_MAPPING GenericMapping,
05390     IN GUID *NewObjectType OPTIONAL,
05391     OUT PULONG NewAceLength,
05392     OUT PACL NewAcl,
05393     OUT PULONG NewAceExtraLength,
05394     OUT PBOOLEAN ObjectAceInherited
05395     )
05396 
05397 <span class="comment">/*++</span>
05398 <span class="comment"></span>
05399 <span class="comment">Routine Description:</span>
05400 <span class="comment"></span>
05401 <span class="comment">    This is a private routine that checks if the input ace is inheritable</span>
05402 <span class="comment">    and produces 0, 1, or 2 inherited aces in the given buffer.</span>
05403 <span class="comment"></span>
05404 <span class="comment">Arguments:</span>
05405 <span class="comment"></span>
05406 <span class="comment">    OldAce - Supplies the ace being inherited</span>
05407 <span class="comment"></span>
05408 <span class="comment">    IsDirectoryObject - Specifies if the new ACE is for a directory</span>
05409 <span class="comment"></span>
05410 <span class="comment">    AutoInherit - Specifies if the inheritance is an "automatic inheritance".</span>
05411 <span class="comment">        As such, the inherited ACEs will be marked as such.</span>
05412 <span class="comment"></span>
05413 <span class="comment">    ClientOwnerSid - Specifies the owner Sid to use</span>
05414 <span class="comment"></span>
05415 <span class="comment">    ClientGroupSid - Specifies the new Group Sid to use</span>
05416 <span class="comment"></span>
05417 <span class="comment">    ServerSid - Optionally specifies the Server Sid to use in compound ACEs.</span>
05418 <span class="comment"></span>
05419 <span class="comment">    ClientSid - Optionally specifies the Client Sid to use in compound ACEs.</span>
05420 <span class="comment"></span>
05421 <span class="comment">    GenericMapping - Specifies the generic mapping to use</span>
05422 <span class="comment"></span>
05423 <span class="comment">    NewObjectType - Type of object being inherited to.  If not specified,</span>
05424 <span class="comment">        the object has no object type.</span>
05425 <span class="comment"></span>
05426 <span class="comment">    NewAceLength - Receives the length (number of bytes) needed to allow for</span>
05427 <span class="comment">        the inheritance of the specified ACE.  This might be zero.</span>
05428 <span class="comment"></span>
05429 <span class="comment">    NewAcl - Provides a pointer to the ACL into which the ACE is to be</span>
05430 <span class="comment">        inherited.</span>
05431 <span class="comment"></span>
05432 <span class="comment">    NewAceExtraLength - Receives a length (number of bytes) temporarily used</span>
05433 <span class="comment">        in the ACL for the inheritance ACE.  This might be zero</span>
05434 <span class="comment"></span>
05435 <span class="comment">    ObjectAceInherited - Returns true if one or more object ACEs were inherited</span>
05436 <span class="comment">        based on NewObjectType</span>
05437 <span class="comment"></span>
05438 <span class="comment">Return Value:</span>
05439 <span class="comment"></span>
05440 <span class="comment">    STATUS_SUCCESS - The ACE was inherited successfully.</span>
05441 <span class="comment"></span>
05442 <span class="comment">    STATUS_BAD_INHERITANCE_ACL - Indicates something went wrong preventing</span>
05443 <span class="comment">        the ACE from being inherited.  This generally represents a bugcheck</span>
05444 <span class="comment">        situation when returned from this call.</span>
05445 <span class="comment"></span>
05446 <span class="comment">    STATUS_BUFFER_TOO_SMALL - The ACL specified by NewAcl is too small for the</span>
05447 <span class="comment">        inheritance ACEs.  The required size is returned in NewAceLength.</span>
05448 <span class="comment"></span>
05449 <span class="comment"></span>
05450 <span class="comment">--*/</span>
05451 
05452 {
05454     <span class="comment">//                                                                       //</span>
05455     <span class="comment">// !!!!!!!!!  This is tricky  !!!!!!!!!!                                 //</span>
05456     <span class="comment">//                                                                       //</span>
05457     <span class="comment">// The inheritence flags AND the sid of the ACE determine whether        //</span>
05458     <span class="comment">// we need 0, 1, or 2 ACEs.                                              //</span>
05459     <span class="comment">//                                                                       //</span>
05460     <span class="comment">// BE CAREFUL WHEN CHANGING THIS CODE.  READ THE DSA ACL ARCHITECTURE    //</span>
05461     <span class="comment">// SECTION COVERING INHERITENCE BEFORE ASSUMING YOU KNOW WHAT THE HELL   //</span>
05462     <span class="comment">// YOU ARE DOING!!!!                                                     //</span>
05463     <span class="comment">//                                                                       //</span>
05464     <span class="comment">// The general gist of the algorithm is:                                 //</span>
05465     <span class="comment">//                                                                       //</span>
05466     <span class="comment">//       if ( (container  &amp;&amp; ContainerInherit) ||                        //</span>
05467     <span class="comment">//            (!container &amp;&amp; ObjectInherit)      ) {                     //</span>
05468     <span class="comment">//               GenerateEffectiveAce;                                   //</span>
05469     <span class="comment">//       }                                                               //</span>
05470     <span class="comment">//                                                                       //</span>
05471     <span class="comment">//                                                                       //</span>
05472     <span class="comment">//       if (Container &amp;&amp; Propagate) {                                   //</span>
05473     <span class="comment">//           Propogate copy of ACE and set InheritOnly;                  //</span>
05474     <span class="comment">//       }                                                               //</span>
05475     <span class="comment">//                                                                       //</span>
05476     <span class="comment">//                                                                       //</span>
05477     <span class="comment">// A slightly more accurate description of this algorithm is:            //</span>
05478     <span class="comment">//                                                                       //</span>
05479     <span class="comment">//   IO  === InheritOnly flag                                            //</span>
05480     <span class="comment">//   CI  === ContainerInherit flag                                       //</span>
05481     <span class="comment">//   OI  === ObjectInherit flag                                          //</span>
05482     <span class="comment">//   NPI === NoPropagateInherit flag                                     //</span>
05483     <span class="comment">//                                                                       //</span>
05484     <span class="comment">//   if ( (container  &amp;&amp; CI) ||                                          //</span>
05485     <span class="comment">//        (!container &amp;&amp; OI)   ) {                                       //</span>
05486     <span class="comment">//       Copy Header of ACE;                                             //</span>
05487     <span class="comment">//       Clear IO, NPI, CI, OI;                                          //</span>
05488     <span class="comment">//                                                                       //</span>
05489     <span class="comment">//       if (KnownAceType) {                                             //</span>
05490     <span class="comment">//           if (SID is a creator ID) {                                  //</span>
05491     <span class="comment">//               Copy appropriate creator SID;                           //</span>
05492     <span class="comment">//           } else {                                                    //</span>
05493     <span class="comment">//               Copy SID of original;                                   //</span>
05494     <span class="comment">//           }                                                           //</span>
05495     <span class="comment">//                                                                       //</span>
05496     <span class="comment">//           Copy AccessMask of original;                                //</span>
05497     <span class="comment">//           MapGenericAccesses;                                         //</span>
05498     <span class="comment">//           if (AccessMask == 0) {                                      //</span>
05499     <span class="comment">//               discard new ACE;                                        //</span>
05500     <span class="comment">//           }                                                           //</span>
05501     <span class="comment">//                                                                       //</span>
05502     <span class="comment">//       } else {                                                        //</span>
05503     <span class="comment">//           Copy body of ACE;                                           //</span>
05504     <span class="comment">//       }                                                               //</span>
05505     <span class="comment">//                                                                       //</span>
05506     <span class="comment">//   }                                                                   //</span>
05507     <span class="comment">//                                                                       //</span>
05508     <span class="comment">//   if (!NPI) {                                                         //</span>
05509     <span class="comment">//       Copy ACE as is;                                                 //</span>
05510     <span class="comment">//       Set IO;                                                         //</span>
05511     <span class="comment">//   }                                                                   //</span>
05512     <span class="comment">//                                                                       //</span>
05513     <span class="comment">//                                                                       //</span>
05514     <span class="comment">//                                                                       //</span>
05516 <span class="comment"></span>
05517 
05518 
05519     ULONG LengthRequired = 0;
05520     ULONG ExtraLengthRequired = 0;
05521     PVOID AcePosition;
05522     PVOID EffectiveAcePosition;
05523     ULONG EffectiveAceSize = 0;
05524 
05525     BOOLEAN EffectiveAceMapped;
05526     BOOLEAN AclOverflowed = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
05527     BOOLEAN GenerateInheritAce;
05528 
05529     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
05530 
05531     <span class="comment">//</span>
05532     <span class="comment">//  This is gross and ugly, but it's better than allocating</span>
05533     <span class="comment">//  virtual memory to hold the ClientSid, because that can</span>
05534     <span class="comment">//  fail, and propogating the error back is a tremendous pain</span>
05535     <span class="comment">//</span>
05536 
05537     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(<a class="code" href="../../d8/d6/sertl_8c.html#a38">RtlLengthRequiredSid</a>( 1 ) == <a class="code" href="../../d8/d6/sertl_8c.html#a0">CREATOR_SID_SIZE</a>);
05538     *ObjectAceInherited = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
05539     GenerateInheritAce = IsDirectoryObject &amp;&amp; Propagate(OldAce);
05540 
05541     <span class="comment">//</span>
05542     <span class="comment">// Allocate and initialize the universal SIDs we're going to need</span>
05543     <span class="comment">// to look for inheritable ACEs.</span>
05544     <span class="comment">//</span>
05545 
05546     <span class="keywordflow">if</span> (!<a class="code" href="../../d2/d4/acledit_8c.html#a25">RtlFirstFreeAce</a>( NewAcl, &amp;AcePosition ) ) {
05547         <span class="keywordflow">return</span> STATUS_BAD_INHERITANCE_ACL;
05548     }
05549 
05550     <span class="comment">//</span>
05551     <span class="comment">//  check to see if we will have a effective ACE (one mapped to</span>
05552     <span class="comment">//  the target object type).</span>
05553     <span class="comment">//</span>
05554 
05555     <span class="keywordflow">if</span> ( (IsDirectoryObject  &amp;&amp; ContainerInherit(OldAce)) ||
05556          (!IsDirectoryObject &amp;&amp; ObjectInherit(OldAce))      ) {
05557 
05558 
05559         <span class="comment">//</span>
05560         <span class="comment">// Remember where the effective ACE will be copied to.</span>
05561         <span class="comment">//</span>
05562         EffectiveAcePosition = AcePosition;
05563 
05564         <span class="comment">//</span>
05565         <span class="comment">// Copy the effective ACE into the ACL.</span>
05566         <span class="comment">//</span>
05567         <span class="keywordflow">if</span> ( !<a class="code" href="../../d8/d6/sertl_8c.html#a16">RtlpCopyEffectiveAce</a> (
05568                         OldAce,
05569                         AutoInherit,
05570                         GenerateInheritAce,
05571                         ClientOwnerSid,
05572                         ClientGroupSid,
05573                         ServerOwnerSid,
05574                         ServerGroupSid,
05575                         GenericMapping,
05576                         NewObjectType,
05577                         &amp;AcePosition,
05578                         &amp;EffectiveAceSize,
05579                         NewAcl,
05580                         ObjectAceInherited,
05581                         &amp;EffectiveAceMapped,
05582                         &amp;AclOverflowed ) ) {
05583 
05584             <span class="keywordflow">return</span> STATUS_BAD_INHERITANCE_ACL;
05585         }
05586 
05587         <span class="comment">//</span>
05588         <span class="comment">// If the effective ACE is a duplicate of existing inherited ACEs,</span>
05589         <span class="comment">//  Don't really generate it.</span>
05590         <span class="comment">//</span>
05591 
05592         <span class="keywordflow">if</span> ( !AclOverflowed &amp;&amp;
05593              EffectiveAceSize &gt; 0 &amp;&amp;
05594              EffectiveAcePosition != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> &amp;&amp;
05595                 <a class="code" href="../../d8/d6/sertl_8c.html#a26">RtlpIsDuplicateAce</a>(
05596                     NewAcl,
05597                     EffectiveAcePosition,
05598                     NewObjectType ) ) {
05599 
05600 
05601             <span class="comment">//</span>
05602             <span class="comment">// Truncate the ACE we just added.</span>
05603             <span class="comment">//</span>
05604 
05605             NewAcl-&gt;AceCount--;
05606             AcePosition = EffectiveAcePosition;
05607             ExtraLengthRequired = <a class="code" href="../../d8/d6/sertl_8c.html#a1">max</a>( ExtraLengthRequired, EffectiveAceSize );
05608             EffectiveAceSize = 0;
05609         }
05610 
05611         LengthRequired += EffectiveAceSize;
05612 
05613     }
05614 
05615     <span class="comment">//</span>
05616     <span class="comment">// If we are inheriting onto a container, then we may need to</span>
05617     <span class="comment">// propagate the inheritance as well.</span>
05618     <span class="comment">//</span>
05619 
05620     <span class="keywordflow">if</span> ( GenerateInheritAce ) {
05621 
05622         <span class="comment">//</span>
05623         <span class="comment">// If a effective ACE was created,</span>
05624         <span class="comment">//  and it wasn't mapped,</span>
05625         <span class="comment">//  avoid generating another ACE and simply merge the inheritance bits into</span>
05626         <span class="comment">//      the effective ACE.</span>
05627         <span class="comment">//</span>
05628 
05629         <span class="keywordflow">if</span> ( EffectiveAceSize != 0 &amp;&amp; !EffectiveAceMapped ) {
05630 
05631            <span class="comment">//</span>
05632            <span class="comment">// Copy the inherit bits from the original ACE.</span>
05633            <span class="comment">//</span>
05634            <span class="keywordflow">if</span> ( !AclOverflowed ) {
05635                ((PACE_HEADER)EffectiveAcePosition)-&gt;AceFlags |=
05636                     ((PACE_HEADER)OldAce)-&gt;AceFlags &amp; (CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE);
05637                <span class="keywordflow">if</span> ( AutoInherit ) {
05638                    ((PACE_HEADER)EffectiveAcePosition)-&gt;AceFlags |= INHERITED_ACE;
05639                }
05640            }
05641 
05642 
05643         <span class="comment">//</span>
05644         <span class="comment">// Otherwise, generate an explicit inheritance ACE.</span>
05645         <span class="comment">//</span>
05646         <span class="comment">// But only if the access mask isn't zero.</span>
05647         <span class="comment">//</span>
05648 
05649         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( !IsMSAceType(OldAce) || ((<a class="code" href="../../d4/d7/struct__KNOWN__ACE.html">PKNOWN_ACE</a>)(OldAce))-&gt;Mask != 0 ) {
05650 
05651             <span class="comment">//</span>
05652             <span class="comment">// Account for the new ACE being added to the ACL.</span>
05653             <span class="comment">//</span>
05654             LengthRequired += (ULONG)(((PACE_HEADER)OldAce)-&gt;AceSize);
05655 
05656             <span class="keywordflow">if</span> (LengthRequired &gt; 0xFFFF) {
05657                 <span class="keywordflow">return</span> STATUS_BAD_INHERITANCE_ACL;
05658             }
05659 
05660             <span class="comment">//</span>
05661             <span class="comment">// If the ACE doesn't fit,</span>
05662             <span class="comment">//  just note the fact and don't copy the ACE.</span>
05663             <span class="comment">//</span>
05664 
05665             <span class="keywordflow">if</span> ( ((PACE_HEADER)OldAce)-&gt;AceSize &gt; NewAcl-&gt;AclSize - ((PUCHAR)AcePosition - (PUCHAR)NewAcl) ) {
05666                 AclOverflowed = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
05667             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!AclOverflowed){
05668 
05669                 <span class="comment">//</span>
05670                 <span class="comment">// copy it as is, but make sure the InheritOnly bit is set.</span>
05671                 <span class="comment">//</span>
05672 
05673                 RtlCopyMemory(
05674                     AcePosition,
05675                     OldAce,
05676                     ((PACE_HEADER)OldAce)-&gt;AceSize
05677                     );
05678 
05679                 ((PACE_HEADER)AcePosition)-&gt;AceFlags |= INHERIT_ONLY_ACE;
05680                 NewAcl-&gt;AceCount += 1;
05681                 <span class="keywordflow">if</span> ( AutoInherit ) {
05682                     ((PACE_HEADER)AcePosition)-&gt;AceFlags |= INHERITED_ACE;
05683 
05684                     <span class="comment">//</span>
05685                     <span class="comment">// If the inheritance ACE is a duplicate of existing inherited ACEs,</span>
05686                     <span class="comment">//  Don't really generate it.</span>
05687                     <span class="comment">//</span>
05688 
05689                     <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a26">RtlpIsDuplicateAce</a>(
05690                                 NewAcl,
05691                                 AcePosition,
05692                                 NewObjectType ) ) {
05693 
05694 
05695                         <span class="comment">//</span>
05696                         <span class="comment">// Truncate the ACE we just added.</span>
05697                         <span class="comment">//</span>
05698 
05699                         NewAcl-&gt;AceCount--;
05700                         ExtraLengthRequired = <a class="code" href="../../d8/d6/sertl_8c.html#a1">max</a>( ExtraLengthRequired,
05701                                                    ((PACE_HEADER)OldAce)-&gt;AceSize );
05702                         LengthRequired -= (ULONG)(((PACE_HEADER)OldAce)-&gt;AceSize);
05703                     }
05704                 }
05705 
05706             }
05707         }
05708     }
05709 
05710     <span class="comment">//</span>
05711     <span class="comment">//  Now return to our caller</span>
05712     <span class="comment">//</span>
05713 
05714     (*NewAceLength) = LengthRequired;
05715     (*NewAceExtraLength) = ExtraLengthRequired;
05716 
05717     <span class="keywordflow">return</span> AclOverflowed ? STATUS_BUFFER_TOO_SMALL : STATUS_SUCCESS;
05718 }
05719 
05720 
05721 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l05722"></a><a class="code" href="../../d8/d6/sertl_8c.html#a19">05722</a> <a class="code" href="../../d8/d6/sertl_8c.html#a19">RtlpGenerateInheritAcl</a>(
05723     IN PACL Acl,
05724     IN BOOLEAN IsDirectoryObject,
05725     IN BOOLEAN AutoInherit,
05726     IN PSID ClientOwnerSid,
05727     IN PSID ClientGroupSid,
05728     IN PSID ServerOwnerSid OPTIONAL,
05729     IN PSID ServerGroupSid OPTIONAL,
05730     IN PGENERIC_MAPPING GenericMapping,
05731     IN GUID *NewObjectType OPTIONAL,
05732     OUT PULONG NewAclSizeParam,
05733     OUT PACL NewAcl,
05734     OUT PBOOLEAN ObjectAceInherited
05735     )
05736 
05737 <span class="comment">/*++</span>
05738 <span class="comment"></span>
05739 <span class="comment">Routine Description:</span>
05740 <span class="comment"></span>
05741 <span class="comment">    This is a private routine that produces an inheritable ACL.</span>
05742 <span class="comment"></span>
05743 <span class="comment">    The buffer to contain the inherted ACL is passed in.  If the buffer is</span>
05744 <span class="comment">    too small, the corect size is computed and STATUS_BUFFER_TOO_SMALL is</span>
05745 <span class="comment">    returned.</span>
05746 <span class="comment"></span>
05747 <span class="comment">Arguments:</span>
05748 <span class="comment"></span>
05749 <span class="comment">    Acl - Supplies the acl being inherited.</span>
05750 <span class="comment"></span>
05751 <span class="comment">    IsDirectoryObject - Specifies if the new acl is for a directory.</span>
05752 <span class="comment"></span>
05753 <span class="comment">    AutoInherit - Specifies if the inheritance is an "automatic inheritance".</span>
05754 <span class="comment">        As such, the inherited ACEs will be marked as such.</span>
05755 <span class="comment"></span>
05756 <span class="comment">    OwnerSid - Specifies the owner Sid to use.</span>
05757 <span class="comment"></span>
05758 <span class="comment">    GroupSid - Specifies the group SID to use.</span>
05759 <span class="comment"></span>
05760 <span class="comment">    GenericMapping - Specifies the generic mapping to use.</span>
05761 <span class="comment"></span>
05762 <span class="comment">    NewObjectType - Type of object being inherited to.  If not specified,</span>
05763 <span class="comment">        the object has no object type.</span>
05764 <span class="comment"></span>
05765 <span class="comment">    NewAclSizeParam - Receives the length of the inherited ACL.</span>
05766 <span class="comment"></span>
05767 <span class="comment">    NewAcl - Provides a pointer to the buffer to receive the new</span>
05768 <span class="comment">        (inherited) acl.  This ACL must already be initialized.</span>
05769 <span class="comment"></span>
05770 <span class="comment">    ObjectAceInherited - Returns true if one or more object ACEs were inherited</span>
05771 <span class="comment">        based on NewObjectType</span>
05772 <span class="comment"></span>
05773 <span class="comment"></span>
05774 <span class="comment">Return Value:</span>
05775 <span class="comment"></span>
05776 <span class="comment">    STATUS_SUCCESS - An inheritable ACL has been generated.</span>
05777 <span class="comment"></span>
05778 <span class="comment">    STATUS_BAD_INHERITANCE_ACL - Indicates the acl built was not a valid ACL.</span>
05779 <span class="comment">        This can becaused by a number of things.  One of the more probable</span>
05780 <span class="comment">        causes is the replacement of a CreatorId with an SID that didn't fit</span>
05781 <span class="comment">        into the ACE or ACL.</span>
05782 <span class="comment"></span>
05783 <span class="comment">    STATUS_BUFFER_TOO_SMALL - The ACL specified by NewAcl is too small for the</span>
05784 <span class="comment">        inheritance ACEs.  The required size is returned in NewAceLength.</span>
05785 <span class="comment"></span>
05786 <span class="comment"></span>
05787 <span class="comment">--*/</span>
05788 
05789 {
05790 
05791     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
05792     ULONG i;
05793 
05794     PACE_HEADER OldAce;
05795     ULONG NewAclSize, NewAceSize;
05796     ULONG NewAclExtraSize, NewAceExtraSize;
05797     BOOLEAN AclOverflowed = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
05798     BOOLEAN LocalObjectAceInherited;
05799 
05800 
05801     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
05802 
05803     <span class="comment">//</span>
05804     <span class="comment">// Walk through the original ACL generating any necessary</span>
05805     <span class="comment">// inheritable ACEs.</span>
05806     <span class="comment">//</span>
05807 
05808     NewAclSize = 0;
05809     NewAclExtraSize = 0;
05810     *ObjectAceInherited = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
05811     <span class="keywordflow">for</span> (i = 0, OldAce = <a class="code" href="../../d4/d1/rtdmpsec_8c.html#a1">FirstAce</a>(Acl);
05812          i &lt; Acl-&gt;AceCount;
05813          i += 1, OldAce = <a class="code" href="../../d4/d1/rtdmpsec_8c.html#a2">NextAce</a>(OldAce)) {
05814 
05815         <span class="comment">//</span>
05816         <span class="comment">//  RtlpGenerateInheritedAce() will generate the ACE(s) necessary</span>
05817         <span class="comment">//  to inherit a single ACE.  This may be 0, 1, or more ACEs.</span>
05818         <span class="comment">//</span>
05819 
05820         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d8/d6/sertl_8c.html#a18">RtlpGenerateInheritedAce</a>(
05821                      OldAce,
05822                      IsDirectoryObject,
05823                      AutoInherit,
05824                      ClientOwnerSid,
05825                      ClientGroupSid,
05826                      ServerOwnerSid,
05827                      ServerGroupSid,
05828                      GenericMapping,
05829                      NewObjectType,
05830                      &amp;NewAceSize,
05831                      NewAcl,
05832                      &amp;NewAceExtraSize,
05833                      &amp;LocalObjectAceInherited
05834                      );
05835 
05836         <span class="keywordflow">if</span> ( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_BUFFER_TOO_SMALL ) {
05837             AclOverflowed = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
05838             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
05839         }
05840 
05841         <span class="keywordflow">if</span> ( !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>) ) {
05842             <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
05843         }
05844 
05845         <span class="keywordflow">if</span> ( LocalObjectAceInherited ) {
05846             *ObjectAceInherited = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
05847         }
05848 
05849         <span class="comment">//</span>
05850         <span class="comment">// Make room in the ACL for the new ACE</span>
05851         <span class="comment">//</span>
05852         NewAclSize += NewAceSize;
05853 
05854         <span class="comment">//</span>
05855         <span class="comment">// If a previous ACE needed 'extra' space,</span>
05856         <span class="comment">//  reduce that requirement by the size of this ACE.</span>
05857         <span class="comment">//</span>
05858         <span class="comment">// The previous ACE can use this ACE's space temporarily</span>
05859         <span class="comment">//</span>
05860         <span class="keywordflow">if</span> ( NewAceSize &gt; NewAclExtraSize ) {
05861             NewAclExtraSize = 0 ;
05862         } <span class="keywordflow">else</span> {
05863             NewAclExtraSize -= NewAceSize;
05864         }
05865 
05866         <span class="comment">//</span>
05867         <span class="comment">// The 'extra' space needed is the larger of that needed by any</span>
05868         <span class="comment">//  previous ACE and that need by this ACE</span>
05869         <span class="comment">//</span>
05870         NewAclExtraSize = <a class="code" href="../../d8/d6/sertl_8c.html#a1">max</a>( NewAclExtraSize, NewAceExtraSize );
05871 
05872     }
05873 
05874     <span class="comment">//</span>
05875     <span class="comment">// We only need to include the "ExtraSize" if we've overflowed.</span>
05876     <span class="comment">//  In those cases, the caller will allocate the size we requested and</span>
05877     <span class="comment">//  try again.  Otherwise, the caller won't call back so we don't care</span>
05878     <span class="comment">//  if it knows about the extra size.</span>
05879     <span class="comment">//</span>
05880 
05881     <span class="keywordflow">if</span> ( AclOverflowed ) {
05882         (*NewAclSizeParam) = NewAclSize + NewAclExtraSize;
05883         <span class="keywordflow">return</span> STATUS_BUFFER_TOO_SMALL;
05884     } <span class="keywordflow">else</span> {
05885         (*NewAclSizeParam) = NewAclSize;
05886         <span class="keywordflow">return</span> STATUS_SUCCESS;
05887     }
05888 
05889 }
05890 
05891 
05892 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l05893"></a><a class="code" href="../../d8/d6/sertl_8c.html#a22">05893</a> <a class="code" href="../../d8/d6/sertl_8c.html#a22">RtlpComputeMergedAcl2</a> (
05894     IN PACL CurrentAcl,
05895     IN ULONG CurrentGenericControl,
05896     IN PACL ModificationAcl,
05897     IN ULONG ModificationGenericControl,
05898     IN PSID ClientOwnerSid,
05899     IN PSID ClientGroupSid,
05900     IN PGENERIC_MAPPING GenericMapping,
05901     IN BOOLEAN IsSacl,
05902     IN PULONG AclBufferSize,
05903     IN OUT PUCHAR AclBuffer,
05904     OUT PULONG NewGenericControl
05905     )
05906 
05907 <span class="comment">/*++</span>
05908 <span class="comment"></span>
05909 <span class="comment">Routine Description:</span>
05910 <span class="comment"></span>
05911 <span class="comment">    This routine implements the 'set' semantics for auto inheritance.</span>
05912 <span class="comment"></span>
05913 <span class="comment">    This routine builds the actual ACL that should be set on an object.</span>
05914 <span class="comment">    The built ACL is a composite of the previous ACL on an object and</span>
05915 <span class="comment">    the newly set ACL on the object.  The New ACL is built as follows:</span>
05916 <span class="comment"></span>
05917 <span class="comment">    If SEP_ACL_PROTECTED is set in neither CurrentAcl nor ModificationAcl,</span>
05918 <span class="comment">    the NewAcl is constructed from the inherited ACEs from the</span>
05919 <span class="comment">    CurrentAcl and the non-inherited ACEs from the ModificationAcl.</span>
05920 <span class="comment">    (That is, it is impossible to edit an inherited ACE by changing the</span>
05921 <span class="comment">    ACL on an object.)</span>
05922 <span class="comment"></span>
05923 <span class="comment">    If SEP_ACL_PROTECTED is set on ModificationAcl, CurrentAcl is ignored.</span>
05924 <span class="comment">    NewAcl is built as a copy of ModificationAcl with any INHERITED_ACE</span>
05925 <span class="comment">    bits turned off.</span>
05926 <span class="comment"></span>
05927 <span class="comment">    If SEP_ACL_PROTECTED is set on CurrentAcl and not ModificationAcl, the</span>
05928 <span class="comment">    CurrentAcl is ignored.  NewAcl is built as a copy of</span>
05929 <span class="comment">    ModificationDescriptor.  It is the callers responsibility to ensure</span>
05930 <span class="comment">    that the correct ACEs have the INHERITED_ACE bit turned on.</span>
05931 <span class="comment"></span>
05932 <span class="comment">Arguments:</span>
05933 <span class="comment"></span>
05934 <span class="comment">    CurrentAcl - The current ACL on the object.</span>
05935 <span class="comment"></span>
05936 <span class="comment">    CurrentGenericControl - Specifies the control flags from the SecurityDescriptor</span>
05937 <span class="comment">        describing the CurrentAcl.</span>
05938 <span class="comment"></span>
05939 <span class="comment">    ModificationAcl - The ACL being applied to the object.</span>
05940 <span class="comment"></span>
05941 <span class="comment">    ModificationGenericControl - Specifies the control flags from the SecurityDescriptor</span>
05942 <span class="comment">        describing the CurrentAcl.</span>
05943 <span class="comment"></span>
05944 <span class="comment">    ClientOwnerSid - Specifies the owner Sid to use</span>
05945 <span class="comment"></span>
05946 <span class="comment">    ClientGroupSid - Specifies the new Group Sid to use</span>
05947 <span class="comment"></span>
05948 <span class="comment">    GenericMapping - The mapping of generic to specific and standard</span>
05949 <span class="comment">                     access types.</span>
05950 <span class="comment"></span>
05951 <span class="comment">    IsSacl - True if this is the SACL.  False if this is the DACL.</span>
05952 <span class="comment"></span>
05953 <span class="comment">    AclBufferSize - On input, specifies the size of AclBuffer.</span>
05954 <span class="comment">        On output, on success, returns the used size of AclBuffer.</span>
05955 <span class="comment">        On output, if the buffer is too small, returns the required size of AclBuffer.</span>
05956 <span class="comment"></span>
05957 <span class="comment">    AclBuffer - Receives a pointer to the new (inherited) acl.</span>
05958 <span class="comment"></span>
05959 <span class="comment">    NewGenericControl - Specifies the control flags for the newly</span>
05960 <span class="comment">        generated ACL.</span>
05961 <span class="comment"></span>
05962 <span class="comment">        Only the Protected and AutoInherited bits are returned.</span>
05963 <span class="comment"></span>
05964 <span class="comment">Return Value:</span>
05965 <span class="comment"></span>
05966 <span class="comment">    STATUS_SUCCESS - An ACL was successfully generated.</span>
05967 <span class="comment"></span>
05968 <span class="comment">    STATUS_UNKNOWN_REVISION - Indicates the source ACL is a revision that</span>
05969 <span class="comment">        is unknown to this routine.</span>
05970 <span class="comment"></span>
05971 <span class="comment">--*/</span>
05972 
05973 {
05974     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
05975     ULONG ModificationNewAclSize = 0;
05976     ULONG CurrentNewAclSize = 0;
05977     ULONG AclRevision;
05978     BOOLEAN AclOverflowed = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
05979     BOOLEAN NullAclOk = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
05980 
05981     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
05982 
05983 
05984     <span class="comment">//</span>
05985     <span class="comment">// Assume the ACL revision.</span>
05986     <span class="comment">//</span>
05987 
05988     AclRevision = ACL_REVISION;
05989     <a class="code" href="../../d2/d4/acledit_8c.html#a6">RtlCreateAcl</a>( (PACL)AclBuffer, *AclBufferSize, AclRevision );
05990 
05991     <span class="comment">//</span>
05992     <span class="comment">// This routine is only called for the AutoInheritance case.</span>
05993     <span class="comment">//</span>
05994 
05995     *NewGenericControl = SEP_ACL_AUTO_INHERITED;
05996 
05997     <span class="comment">//</span>
05998     <span class="comment">// If the new ACL is protected,</span>
05999     <span class="comment">//  simply use the new ACL with the INHERITED_ACE bits turned off.</span>
06000     <span class="comment">//</span>
06001 
06002     <span class="keywordflow">if</span> ( (ModificationGenericControl &amp; SEP_ACL_PROTECTED) != 0 ) {
06003 
06004         <span class="comment">//</span>
06005         <span class="comment">// Set the Control bits for the resultant descriptor.</span>
06006         <span class="comment">//</span>
06007 
06008         *NewGenericControl |= SEP_ACL_PROTECTED;
06009 
06010         <span class="comment">//</span>
06011         <span class="comment">// Only copy the ACL if it is actually present</span>
06012         <span class="comment">//</span>
06013 
06014         <span class="keywordflow">if</span> ( ModificationAcl != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
06015 
06016             AclRevision = <a class="code" href="../../d8/d6/sertl_8c.html#a1">max</a>( AclRevision, ModificationAcl-&gt;AclRevision );
06017 
06018             <span class="comment">//</span>
06019             <span class="comment">// Copy all ACES, turn off the inherited bit, and generic map them.</span>
06020             <span class="comment">//</span>
06021 
06022             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d8/d6/sertl_8c.html#a17">RtlpCopyAces</a>(
06023                         ModificationAcl,
06024                         GenericMapping,
06025                         <a class="code" href="../../d8/d6/sertl_8c.html#a80a12">CopyAllAces</a>,
06026                         INHERITED_ACE,  <span class="comment">// Turn off all INHERITED_ACE flags</span>
06027                         <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,           <span class="comment">// Map sids as needed</span>
06028                         ClientOwnerSid,
06029                         ClientGroupSid,
06030                         ClientOwnerSid, <span class="comment">// Not technically correct. s.b. server sid</span>
06031                         ClientGroupSid, <span class="comment">// Not technically correct. s.b. server sid</span>
06032                         &amp;ModificationNewAclSize,
06033                         (PACL)AclBuffer );
06034 
06035             <span class="keywordflow">if</span> ( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_BUFFER_TOO_SMALL ) {
06036                 AclOverflowed = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
06037                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
06038             }
06039 
06040             <span class="keywordflow">if</span> ( !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>) ) {
06041                 <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
06042             }
06043 
06044             <span class="comment">//</span>
06045             <span class="comment">// If the caller specified an ACL with no ACES,</span>
06046             <span class="comment">//  make sure we generate an ACL with no ACES.</span>
06047             <span class="comment">//</span>
06048 
06049             NullAclOk = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
06050         }
06051 
06052     <span class="comment">//</span>
06053     <span class="comment">// If the old ACL is protected but the new one isn't,</span>
06054     <span class="comment">//  simply use the new ACL as is.</span>
06055     <span class="comment">//</span>
06056     <span class="comment">// Rely on the caller to get the INHERITED_ACE bits right.</span>
06057     <span class="comment">//</span>
06058 
06059     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( (CurrentGenericControl &amp; SEP_ACL_PROTECTED) != 0 ) {
06060 
06061         <span class="comment">//</span>
06062         <span class="comment">// Only do the copy if the new ACL is specified.</span>
06063         <span class="comment">//</span>
06064 
06065         <span class="keywordflow">if</span> ( ModificationAcl != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
06066             AclRevision = <a class="code" href="../../d8/d6/sertl_8c.html#a1">max</a>( AclRevision, ModificationAcl-&gt;AclRevision );
06067 
06068             <span class="comment">//</span>
06069             <span class="comment">// Copy all ACES, and generic map them.</span>
06070             <span class="comment">//</span>
06071 
06072             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d8/d6/sertl_8c.html#a17">RtlpCopyAces</a>(
06073                         ModificationAcl,
06074                         GenericMapping,
06075                         <a class="code" href="../../d8/d6/sertl_8c.html#a80a12">CopyAllAces</a>,
06076                         0,
06077                         <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,           <span class="comment">// Map sids as needed</span>
06078                         ClientOwnerSid,
06079                         ClientGroupSid,
06080                         ClientOwnerSid, <span class="comment">// Not technically correct. s.b. server sid</span>
06081                         ClientGroupSid, <span class="comment">// Not technically correct. s.b. server sid</span>
06082                         &amp;ModificationNewAclSize,
06083                         (PACL)AclBuffer );
06084 
06085             <span class="keywordflow">if</span> ( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_BUFFER_TOO_SMALL ) {
06086                 AclOverflowed = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
06087                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
06088             }
06089 
06090             <span class="keywordflow">if</span> ( !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>) ) {
06091                 <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
06092             }
06093 
06094             <span class="comment">//</span>
06095             <span class="comment">// If the caller specified an ACL with no ACES,</span>
06096             <span class="comment">//  make sure we generate an ACL with no ACES.</span>
06097             <span class="comment">//</span>
06098 
06099             NullAclOk = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
06100 
06101         <span class="comment">//</span>
06102         <span class="comment">// Since the ACL isn't protected,</span>
06103         <span class="comment">//  don't allow NULL ACL semantics.</span>
06104         <span class="comment">//  (those semantics are ambiguous for auto inheritance)</span>
06105         <span class="comment">//</span>
06106         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( !IsSacl ) {
06107             <span class="keywordflow">return</span> STATUS_INVALID_ACL;
06108         }
06109 
06110 
06111     <span class="comment">//</span>
06112     <span class="comment">// If neither are protected,</span>
06113     <span class="comment">//  use the non-inherited ACEs from the new ACL, and</span>
06114     <span class="comment">//  preserve the inherited ACEs from the old ACL.</span>
06115     <span class="comment">//</span>
06116 
06117     } <span class="keywordflow">else</span> {
06118 
06119         <span class="comment">//</span>
06120         <span class="comment">// NULL ACLs are always OK for a SACL.</span>
06121         <span class="comment">// NULL ACLs are never OK for a non-protected DACL.</span>
06122         <span class="comment">//</span>
06123 
06124         NullAclOk = IsSacl;
06125 
06126 
06127         <span class="comment">//</span>
06128         <span class="comment">// Only do the copy if the new ACL is specified.</span>
06129         <span class="comment">//</span>
06130 
06131         <span class="keywordflow">if</span> ( ModificationAcl != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
06132             AclRevision = <a class="code" href="../../d8/d6/sertl_8c.html#a1">max</a>( AclRevision, ModificationAcl-&gt;AclRevision );
06133 
06134             <span class="comment">//</span>
06135             <span class="comment">// Copy the non-inherited ACES, and generic map them.</span>
06136             <span class="comment">//</span>
06137 
06138             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d8/d6/sertl_8c.html#a17">RtlpCopyAces</a>(
06139                         ModificationAcl,
06140                         GenericMapping,
06141                         <a class="code" href="../../d8/d6/sertl_8c.html#a80a11">CopyNonInheritedAces</a>,
06142                         0,
06143                         <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,           <span class="comment">// Map sids as needed</span>
06144                         ClientOwnerSid,
06145                         ClientGroupSid,
06146                         ClientOwnerSid, <span class="comment">// Not technically correct. s.b. server sid</span>
06147                         ClientGroupSid, <span class="comment">// Not technically correct. s.b. server sid</span>
06148                         &amp;ModificationNewAclSize,
06149                         (PACL)AclBuffer );
06150 
06151             <span class="keywordflow">if</span> ( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_BUFFER_TOO_SMALL ) {
06152                 AclOverflowed = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
06153                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
06154             }
06155 
06156             <span class="keywordflow">if</span> ( !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>) ) {
06157                 <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
06158             }
06159 
06160             <span class="comment">//</span>
06161             <span class="comment">// If the caller specified an ACL with no ACES,</span>
06162             <span class="comment">//  make sure we generate an ACL with no ACES.</span>
06163             <span class="comment">//</span>
06164             <span class="comment">// If inherited aces were deleted, leave the flag alone allowing</span>
06165             <span class="comment">//  a NULL SACL to be generated.</span>
06166             <span class="comment">//</span>
06167 
06168             <span class="keywordflow">if</span> ( ModificationAcl-&gt;AceCount == 0 ) {
06169                 NullAclOk = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
06170             }
06171 
06172         <span class="comment">//</span>
06173         <span class="comment">// Since the ACL isn't protected,</span>
06174         <span class="comment">//  don't allow NULL ACL semantics.</span>
06175         <span class="comment">//  (those semantics are ambiguous for auto inheritance)</span>
06176         <span class="comment">//</span>
06177         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( !IsSacl ) {
06178             <span class="keywordflow">return</span> STATUS_INVALID_ACL;
06179         }
06180 
06181 
06182         <span class="comment">//</span>
06183         <span class="comment">// Only do the copy if the old ACL is specified.</span>
06184         <span class="comment">//</span>
06185 
06186         <span class="keywordflow">if</span> ( CurrentAcl != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
06187 
06188             AclRevision = <a class="code" href="../../d8/d6/sertl_8c.html#a1">max</a>( AclRevision, CurrentAcl-&gt;AclRevision );
06189 
06190 
06191             <span class="comment">//</span>
06192             <span class="comment">// Copy the inherited ACES, and generic map them.</span>
06193             <span class="comment">//</span>
06194             <span class="comment">// Don't bother mapping the sids in these ACEs.  They got mapped</span>
06195             <span class="comment">// during inheritance.</span>
06196             <span class="comment">//</span>
06197 
06198             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d8/d6/sertl_8c.html#a17">RtlpCopyAces</a>(
06199                         CurrentAcl,
06200                         GenericMapping,
06201                         <a class="code" href="../../d8/d6/sertl_8c.html#a80a10">CopyInheritedAces</a>,
06202                         0,
06203                         <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,          <span class="comment">// Don't map the sids,</span>
06204                         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
06205                         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
06206                         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
06207                         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
06208                         &amp;CurrentNewAclSize,
06209                         (PACL)AclBuffer );
06210 
06211             <span class="keywordflow">if</span> ( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_BUFFER_TOO_SMALL ) {
06212                 AclOverflowed = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
06213                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
06214             }
06215 
06216             <span class="keywordflow">if</span> ( !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>) ) {
06217                 <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
06218             }
06219         }
06220     }
06221 
06222     <span class="comment">//</span>
06223     <span class="comment">// If this routine didn't build the ACL,</span>
06224     <span class="comment">//  tell the caller to use an explict NULL ACL</span>
06225     <span class="comment">//</span>
06226 
06227     <span class="keywordflow">if</span> ( ModificationNewAclSize + CurrentNewAclSize == 0) {
06228         <span class="comment">//</span>
06229         <span class="comment">// If the Acl was explictly assigned,</span>
06230         <span class="comment">//  generate a NULL ACL based on the path taken above.</span>
06231         <span class="comment">//</span>
06232 
06233         <span class="keywordflow">if</span> ( NullAclOk ) {
06234             *AclBufferSize = 0;
06235             <span class="keywordflow">return</span> STATUS_SUCCESS;
06236         }
06237     }
06238 
06239 
06240     <span class="comment">//</span>
06241     <span class="comment">// And make sure we don't exceed the length limitations of an ACL (WORD)</span>
06242     <span class="comment">//</span>
06243 
06244     <span class="keywordflow">if</span> ( ModificationNewAclSize + CurrentNewAclSize + <span class="keyword">sizeof</span>(ACL) &gt; 0xFFFF) {
06245         <span class="keywordflow">return</span>(STATUS_BAD_INHERITANCE_ACL);
06246     }
06247 
06248     (*AclBufferSize) = ModificationNewAclSize + CurrentNewAclSize + <span class="keyword">sizeof</span>(ACL);
06249 
06250     <span class="keywordflow">if</span> ( AclOverflowed ) {
06251         <span class="keywordflow">return</span> STATUS_BUFFER_TOO_SMALL;
06252     }
06253 
06254     <span class="comment">//</span>
06255     <span class="comment">// Patch the real ACL size and revision into the ACL</span>
06256     <span class="comment">//</span>
06257 
06258     ((PACL)AclBuffer)-&gt;AclSize = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>) *AclBufferSize;
06259     ((PACL)AclBuffer)-&gt;AclRevision = (UCHAR) AclRevision;
06260 
06261     <span class="keywordflow">return</span> STATUS_SUCCESS;
06262 }
06263 
06264 
06265 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l06266"></a><a class="code" href="../../d8/d6/sertl_8c.html#a21">06266</a> <a class="code" href="../../d8/d6/sertl_8c.html#a21">RtlpComputeMergedAcl</a> (
06267     IN PACL CurrentAcl,
06268     IN ULONG CurrentGenericControl,
06269     IN PACL ModificationAcl,
06270     IN ULONG ModificationGenericControl,
06271     IN PSID ClientOwnerSid,
06272     IN PSID ClientGroupSid,
06273     IN PGENERIC_MAPPING GenericMapping,
06274     IN BOOLEAN IsSacl,
06275     OUT PACL *NewAcl,
06276     OUT PULONG NewGenericControl
06277     )
06278 
06279 <span class="comment">/*++</span>
06280 <span class="comment"></span>
06281 <span class="comment">Routine Description:</span>
06282 <span class="comment"></span>
06283 <span class="comment">    This routine builds the actual ACL that should be set on an object.</span>
06284 <span class="comment">    The built ACL is a composite of the previous ACL on an object and</span>
06285 <span class="comment">    the newly set ACL on the object.  The New ACL is built as follows:</span>
06286 <span class="comment"></span>
06287 <span class="comment">    If SEP_ACL_PROTECTED is set in neither CurrentAcl nor ModificationAcl,</span>
06288 <span class="comment">    the NewAcl is constructed from the inherited ACEs from the</span>
06289 <span class="comment">    CurrentAcl and the non-inherited ACEs from the ModificationAcl.</span>
06290 <span class="comment">    (That is, it is impossible to edit an inherited ACE by changing the</span>
06291 <span class="comment">    ACL on an object.)</span>
06292 <span class="comment"></span>
06293 <span class="comment">    If SEP_ACL_PROTECTED is set on ModificationAcl, CurrentAcl is ignored.</span>
06294 <span class="comment">    NewAcl is built as a copy of ModificationAcl with any INHERITED_ACE</span>
06295 <span class="comment">    bits turned off.</span>
06296 <span class="comment"></span>
06297 <span class="comment">    If SEP_ACL_PROTECTED is set on CurrentAcl and not ModificationAcl, the</span>
06298 <span class="comment">    CurrentAcl is ignored.  NewAcl is built as a copy of</span>
06299 <span class="comment">    ModificationDescriptor.  It is the callers responsibility to ensure</span>
06300 <span class="comment">    that the correct ACEs have the INHERITED_ACE bit turned on.</span>
06301 <span class="comment"></span>
06302 <span class="comment">Arguments:</span>
06303 <span class="comment"></span>
06304 <span class="comment">    CurrentAcl - The current ACL on the object.</span>
06305 <span class="comment"></span>
06306 <span class="comment">    CurrentGenericControl - Specifies the control flags from the SecurityDescriptor</span>
06307 <span class="comment">        describing the CurrentAcl.</span>
06308 <span class="comment"></span>
06309 <span class="comment">    ModificationAcl - The ACL being applied to the object.</span>
06310 <span class="comment"></span>
06311 <span class="comment">    ModificationGenericControl - Specifies the control flags from the SecurityDescriptor</span>
06312 <span class="comment">        describing the CurrentAcl.</span>
06313 <span class="comment"></span>
06314 <span class="comment">    ClientOwnerSid - Specifies the owner Sid to use</span>
06315 <span class="comment"></span>
06316 <span class="comment">    ClientGroupSid - Specifies the new Group Sid to use</span>
06317 <span class="comment"></span>
06318 <span class="comment">    GenericMapping - The mapping of generic to specific and standard</span>
06319 <span class="comment">                     access types.</span>
06320 <span class="comment"></span>
06321 <span class="comment">    IsSacl - True if this is the SACL.  False if this is the DACL.</span>
06322 <span class="comment"></span>
06323 <span class="comment">    NewAcl - Receives a pointer to the new resultant acl.</span>
06324 <span class="comment"></span>
06325 <span class="comment">    NewGenericControl - Specifies the control flags for the newly</span>
06326 <span class="comment">        generated ACL.</span>
06327 <span class="comment"></span>
06328 <span class="comment">        Only the Protected and AutoInherited bits are returned.</span>
06329 <span class="comment"></span>
06330 <span class="comment">Return Value:</span>
06331 <span class="comment"></span>
06332 <span class="comment">    STATUS_SUCCESS - An ACL was successfully generated.</span>
06333 <span class="comment"></span>
06334 <span class="comment">    STATUS_UNKNOWN_REVISION - Indicates the source ACL is a revision that</span>
06335 <span class="comment">        is unknown to this routine.</span>
06336 <span class="comment"></span>
06337 <span class="comment">--*/</span>
06338 
06339 {
06340     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
06341     ULONG AclBufferSize;
06342     ULONG i;
06343 <span class="preprocessor">#ifndef NTOS_KERNEL_RUNTIME</span>
06344 <span class="preprocessor"></span>    PVOID <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
06345 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
06346 <span class="preprocessor"></span>
06347     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
06348 
06349     <span class="comment">//</span>
06350     <span class="comment">// Get the handle to the current process heap</span>
06351     <span class="comment">//</span>
06352 
06353 <span class="preprocessor">#ifndef NTOS_KERNEL_RUNTIME</span>
06354 <span class="preprocessor"></span>    <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a> = RtlProcessHeap();
06355 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
06356 <span class="preprocessor"></span>
06357 
06358     <span class="comment">//</span>
06359     <span class="comment">// Implement a two pass strategy.</span>
06360     <span class="comment">//</span>
06361     <span class="comment">// First try to create the ACL in a fixed length buffer.</span>
06362     <span class="comment">// If that is too small,</span>
06363     <span class="comment">//  then use the buffer size determined on the first pass</span>
06364     <span class="comment">//</span>
06365 
06366     AclBufferSize = 1024;
06367     <span class="keywordflow">for</span> ( i=0; i&lt;2 ; i++ ) {
06368 
06369         <span class="comment">//</span>
06370         <span class="comment">// Allocate heap for the new ACL.</span>
06371         <span class="comment">//</span>
06372 
06373 <span class="preprocessor">#ifdef NTOS_KERNEL_RUNTIME</span>
06374 <span class="preprocessor"></span>        (*NewAcl) = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>(
06375                         <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>,
06376                         AclBufferSize,
06377                         'cAeS' );
06378 <span class="preprocessor">#else // NTOS_KERNEL_RUNTIME</span>
06379 <span class="preprocessor"></span>        (*NewAcl) = <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a0">RtlAllocateHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, 0, AclBufferSize );
06380 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
06381 <span class="preprocessor"></span>        <span class="keywordflow">if</span> ((*NewAcl) == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
06382             <span class="keywordflow">return</span>( STATUS_NO_MEMORY );
06383         }
06384 
06385         <span class="comment">//</span>
06386         <span class="comment">// Merge the ACLs</span>
06387         <span class="comment">//</span>
06388 
06389         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d8/d6/sertl_8c.html#a22">RtlpComputeMergedAcl2</a> (
06390                     CurrentAcl,
06391                     CurrentGenericControl,
06392                     ModificationAcl,
06393                     ModificationGenericControl,
06394                     ClientOwnerSid,
06395                     ClientGroupSid,
06396                     GenericMapping,
06397                     IsSacl,
06398                     &amp;AclBufferSize,
06399                     (PUCHAR) *NewAcl,
06400                     NewGenericControl );
06401 
06402 
06403         <span class="keywordflow">if</span> ( <a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>) ) {
06404 
06405             <span class="comment">//</span>
06406             <span class="comment">// If a NULL ACL should be used,</span>
06407             <span class="comment">//  tell the caller.</span>
06408             <span class="comment">//</span>
06409 
06410             <span class="keywordflow">if</span> ( AclBufferSize == 0 ) {
06411 <span class="preprocessor">#ifdef NTOS_KERNEL_RUNTIME</span>
06412 <span class="preprocessor"></span>                <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( *NewAcl );
06413 <span class="preprocessor">#else // NTOS_KERNEL_RUNTIME</span>
06414 <span class="preprocessor"></span>                <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, 0, *NewAcl );
06415 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
06416 <span class="preprocessor"></span>                *NewAcl = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
06417             }
06418 
06419             <span class="keywordflow">break</span>;
06420 
06421         } <span class="keywordflow">else</span> {
06422 <span class="preprocessor">#ifdef NTOS_KERNEL_RUNTIME</span>
06423 <span class="preprocessor"></span>            <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( *NewAcl );
06424 <span class="preprocessor">#else // NTOS_KERNEL_RUNTIME</span>
06425 <span class="preprocessor"></span>            <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, 0, *NewAcl );
06426 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
06427 <span class="preprocessor"></span>            *NewAcl = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
06428 
06429             <span class="keywordflow">if</span> ( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> != STATUS_BUFFER_TOO_SMALL ) {
06430                 <span class="keywordflow">break</span>;
06431             }
06432         }
06433     }
06434 
06435 
06436     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
06437 }
06438 
06439 <span class="preprocessor">#endif // WIN16</span>
06440 <span class="preprocessor"></span>
06441 <span class="preprocessor">#if DBG</span>
06442 <span class="preprocessor"></span><a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
06443 RtlDumpUserSid(
06444     VOID
06445     )
06446 {
06447     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
06448     HANDLE   TokenHandle;
06449     <a class="code" href="../../d1/d1/bench_8c.html#a16">CHAR</a>     <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>[200];
06450     ULONG    ReturnLength;
06451     PSID     pSid;
06452     UNICODE_STRING SidString;
06453     PTOKEN_USER  User;
06454 
06455     <span class="comment">//</span>
06456     <span class="comment">// Attempt to open the impersonation token first</span>
06457     <span class="comment">//</span>
06458 
06459     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d7/d3/tokenopn_8c.html#a3">NtOpenThreadToken</a>(
06460                  NtCurrentThread(),
06461                  GENERIC_READ,
06462                  FALSE,
06463                  &amp;TokenHandle
06464                  );
06465 
06466     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
06467 
06468         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"Not impersonating, status = %X, trying process token\n"</span>,Status);
06469 
06470         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d7/d3/tokenopn_8c.html#a1">NtOpenProcessToken</a>(
06471                      NtCurrentProcess(),
06472                      GENERIC_READ,
06473                      &amp;TokenHandle
06474                      );
06475 
06476         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
06477             <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"Unable to open process token, status = %X\n"</span>,Status);
06478             <span class="keywordflow">return</span>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> );
06479         }
06480     }
06481 
06482     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d3/tokenqry_8c.html#a0">NtQueryInformationToken</a> (
06483                  TokenHandle,
06484                  TokenUser,
06485                  Buffer,
06486                  200,
06487                  &amp;ReturnLength
06488                  );
06489 
06490     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
06491 
06492         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"Unable to query user sid, status = %X \n"</span>,Status);
06493         <a class="code" href="../../d5/d0/obclose_8c.html#a1">NtClose</a>(TokenHandle);
06494         <span class="keywordflow">return</span>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> );
06495     }
06496 
06497     User = (PTOKEN_USER)<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>;
06498 
06499     pSid = User-&gt;User.Sid;
06500 
06501     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d8/d6/sertl_8c.html#a49">RtlConvertSidToUnicodeString</a>( &amp;SidString, pSid, TRUE );
06502 
06503     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
06504         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"Unable to format sid string, status = %X \n"</span>,Status);
06505         <a class="code" href="../../d5/d0/obclose_8c.html#a1">NtClose</a>(TokenHandle);
06506         <span class="keywordflow">return</span>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> );
06507     }
06508 
06509     <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"Current Sid = %wZ \n"</span>,&amp;SidString);
06510 
06511     <a class="code" href="../../d6/d6/nls_8c.html#a34">RtlFreeUnicodeString</a>( &amp;SidString );
06512 
06513     <span class="keywordflow">return</span>( STATUS_SUCCESS );
06514 }
06515 
06516 <span class="preprocessor">#endif</span>
06517 <span class="preprocessor"></span>
06518 
06519 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l06520"></a><a class="code" href="../../d8/d6/sertl_8c.html#a75">06520</a> <a class="code" href="../../d8/d6/sertl_8c.html#a75">RtlpConvertToAutoInheritSecurityObject</a>(
06521     IN PSECURITY_DESCRIPTOR ParentDescriptor OPTIONAL,
06522     IN PSECURITY_DESCRIPTOR CurrentSecurityDescriptor,
06523     OUT PSECURITY_DESCRIPTOR *NewSecurityDescriptor,
06524     IN GUID *ObjectType OPTIONAL,
06525     IN BOOLEAN IsDirectoryObject,
06526     IN PGENERIC_MAPPING GenericMapping
06527     )
06528 <span class="comment">/*++</span>
06529 <span class="comment"></span>
06530 <span class="comment">Routine Description:</span>
06531 <span class="comment"></span>
06532 <span class="comment">    This routine a converts a security descriptor whose ACLs are not marked</span>
06533 <span class="comment">    as AutoInherit to a security descriptor whose ACLs are marked as</span>
06534 <span class="comment">    AutoInherit.</span>
06535 <span class="comment"></span>
06536 <span class="comment">    See comments for RtlConvertToAutoInheritSecurityObject.</span>
06537 <span class="comment"></span>
06538 <span class="comment">Arguments:</span>
06539 <span class="comment"></span>
06540 <span class="comment">    ParentDescriptor - Supplies the Security Descriptor for the parent</span>
06541 <span class="comment">        directory under which a object exists.  If there is</span>
06542 <span class="comment">        no parent directory, then this argument is specified as NULL.</span>
06543 <span class="comment"></span>
06544 <span class="comment">    CurrentSecurityDescriptor - Supplies a pointer to the objects security descriptor</span>
06545 <span class="comment">        that is going to be altered by this procedure.</span>
06546 <span class="comment"></span>
06547 <span class="comment">    NewSecurityDescriptor Points to a pointer that is to be made to point to the</span>
06548 <span class="comment">        newly allocated self-relative security descriptor. When no</span>
06549 <span class="comment">        longer needed, this descriptor must be freed using</span>
06550 <span class="comment">        DestroyPrivateObjectSecurity().</span>
06551 <span class="comment"></span>
06552 <span class="comment">    ObjectType - GUID of the object type being created.  If the object being</span>
06553 <span class="comment">        created has no GUID associated with it, then this argument is</span>
06554 <span class="comment">        specified as NULL.</span>
06555 <span class="comment"></span>
06556 <span class="comment">    IsDirectoryObject - Specifies if the object is a</span>
06557 <span class="comment">        directory object.  A value of TRUE indicates the object is a</span>
06558 <span class="comment">        container of other objects.</span>
06559 <span class="comment"></span>
06560 <span class="comment">    GenericMapping - Supplies a pointer to a generic mapping array denoting</span>
06561 <span class="comment">        the mapping between each generic right to specific rights.</span>
06562 <span class="comment"></span>
06563 <span class="comment">Return Value:</span>
06564 <span class="comment"></span>
06565 <span class="comment">    STATUS_SUCCESS - The operation was successful.</span>
06566 <span class="comment"></span>
06567 <span class="comment">    See comments for RtlConvertToAutoInheritSecurityObject.</span>
06568 <span class="comment"></span>
06569 <span class="comment"></span>
06570 <span class="comment">--*/</span>
06571 {
06572     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
06573     PISECURITY_DESCRIPTOR CurrentDescriptor;
06574     PACL CurrentSacl;
06575     PACL CurrentDacl;
06576 
06577     PSID NewOwner;
06578     PSID NewGroup;
06579 
06580     PACL NewSacl = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
06581     ULONG NewSaclControl = 0;
06582     BOOLEAN NewSaclAllocated = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
06583 
06584     PACL NewDacl = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
06585     ULONG NewDaclControl = 0;
06586     BOOLEAN NewDaclAllocated = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
06587     PACL TemplateInheritedDacl = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
06588     ULONG GenericControl;
06589 
06590     ULONG AllocationSize;
06591     ULONG NewOwnerSize;
06592     ULONG NewGroupSize;
06593     ULONG NewSaclSize;
06594     ULONG NewDaclSize;
06595 
06596     PCHAR Field;
06597     PCHAR Base;
06598 
06599     PISECURITY_DESCRIPTOR_RELATIVE INewDescriptor = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
06600     ULONG ReturnLength;
06601     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> PassedStatus;
06602     HANDLE <a class="code" href="../../d6/d0/ctaccess_8c.html#a31">PrimaryToken</a>;
06603 
06604 <span class="preprocessor">#ifndef NTOS_KERNEL_RUNTIME</span>
06605 <span class="preprocessor"></span>    PVOID <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
06606 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
06607 <span class="preprocessor"></span>
06608     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
06609 
06610     <span class="comment">//</span>
06611     <span class="comment">// Get the handle to the current process heap</span>
06612     <span class="comment">//</span>
06613 
06614 <span class="preprocessor">#ifndef NTOS_KERNEL_RUNTIME</span>
06615 <span class="preprocessor"></span>    <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a> = RtlProcessHeap();
06616 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
06617 <span class="preprocessor"></span>
06618 
06619 
06620     <span class="comment">//</span>
06621     <span class="comment">//</span>
06622 
06623     CurrentDescriptor = CurrentSecurityDescriptor;
06624 
06625     <span class="comment">//</span>
06626     <span class="comment">// Validate the incoming security descriptor.</span>
06627     <span class="comment">//</span>
06628 
06629     <span class="keywordflow">if</span> (!<a class="code" href="../../d8/d6/sertl_8c.html#a55">RtlValidSecurityDescriptor</a> ( CurrentDescriptor )) {
06630         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_SECURITY_DESCR;
06631         <span class="keywordflow">goto</span> Cleanup;
06632     }
06633 
06634 
06635     NewOwner = RtlpOwnerAddrSecurityDescriptor( CurrentDescriptor );
06636     <span class="keywordflow">if</span> ( NewOwner == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
06637         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_SECURITY_DESCR;
06638         <span class="keywordflow">goto</span> Cleanup;
06639     }
06640 
06641     NewGroup = RtlpGroupAddrSecurityDescriptor( CurrentDescriptor );
06642 
06643 
06644 
06645 
06646     <span class="comment">//</span>
06647     <span class="comment">// Handle the SACL.</span>
06648     <span class="comment">//</span>
06649     <span class="comment">//</span>
06650     <span class="comment">// If the SACL isn't present,</span>
06651     <span class="comment">//  special case it.</span>
06652     <span class="comment">//</span>
06653 
06654     CurrentSacl = RtlpSaclAddrSecurityDescriptor( CurrentDescriptor );
06655 
06656     <span class="keywordflow">if</span> ( CurrentSacl == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
06657         PACL ParentSacl;
06658 
06659         <span class="comment">// Preserve the Acl Present bit and protected bit from the existing descriptor.</span>
06660         NewSaclControl |= CurrentDescriptor-&gt;Control &amp; (SE_SACL_PROTECTED|SE_SACL_PRESENT);
06661 
06662         <span class="comment">// Always set the autoinherited bit.</span>
06663         NewSaclControl |= SE_SACL_AUTO_INHERITED;
06664 
06665 
06666         <span class="comment">//</span>
06667         <span class="comment">// If the Parent also has a NULL SACL,</span>
06668         <span class="comment">//  just consider this SACL as inherited.</span>
06669         <span class="comment">//  otherwise, this SACL is protected.</span>
06670         <span class="comment">//</span>
06671 
06672         ParentSacl = ARGUMENT_PRESENT(ParentDescriptor) ?
06673                         RtlpSaclAddrSecurityDescriptor( ((SECURITY_DESCRIPTOR *)ParentDescriptor)) :
06674                         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
06675         <span class="keywordflow">if</span> ( ParentSacl != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
06676             NewSaclControl |= SE_SACL_PROTECTED;
06677         }
06678 
06679 
06680     <span class="comment">//</span>
06681     <span class="comment">// If the SACL is already converted,</span>
06682     <span class="comment">//  or if this object is at the root of the tree,</span>
06683     <span class="comment">//  simply leave it alone.</span>
06684     <span class="comment">//</span>
06685     <span class="comment">// Don't force the Protect bit on at the root of the tree since it is semantically</span>
06686     <span class="comment">//  a no-op and gets in the way if the object is ever moved.</span>
06687     <span class="comment">//</span>
06688 
06689     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( RtlpAreControlBitsSet( CurrentDescriptor, SE_SACL_AUTO_INHERITED) ||
06690                 RtlpAreControlBitsSet( CurrentDescriptor, SE_SACL_PROTECTED ) ||
06691                 !ARGUMENT_PRESENT(ParentDescriptor) ) {
06692 
06693         <span class="comment">// Preserve the Acl Present bit and protected bit from the existing descriptor.</span>
06694         NewSaclControl |= CurrentDescriptor-&gt;Control &amp; (SE_SACL_PROTECTED|SE_SACL_PRESENT);
06695 
06696         <span class="comment">// Always set the autoinherited bit.</span>
06697         NewSaclControl |= SE_SACL_AUTO_INHERITED;
06698 
06699         NewSacl = CurrentSacl;
06700 
06701 
06702     <span class="comment">//</span>
06703     <span class="comment">// If the SACL is present,</span>
06704     <span class="comment">//  compute a new SACL with appropriate ACEs marked as inherited.</span>
06705     <span class="comment">//</span>
06706 
06707     } <span class="keywordflow">else</span> {
06708 
06709 
06710         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d8/d6/sertl_8c.html#a15">RtlpConvertAclToAutoInherit</a> (
06711                     ARGUMENT_PRESENT(ParentDescriptor) ?
06712                         RtlpSaclAddrSecurityDescriptor(
06713                             ((SECURITY_DESCRIPTOR *)ParentDescriptor)) :
06714                         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
06715                     RtlpSaclAddrSecurityDescriptor(CurrentDescriptor),
06716                     ObjectType,
06717                     IsDirectoryObject,
06718                     RtlpOwnerAddrSecurityDescriptor(CurrentDescriptor),
06719                     RtlpGroupAddrSecurityDescriptor(CurrentDescriptor),
06720                     GenericMapping,
06721                     &amp;NewSacl,
06722                     &amp;GenericControl );
06723 
06724         <span class="keywordflow">if</span> ( !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>) ) {
06725             <span class="keywordflow">goto</span> Cleanup;
06726         }
06727 
06728         NewSaclAllocated = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
06729         NewSaclControl |= SE_SACL_PRESENT | SeControlGenericToSacl( GenericControl );
06730     }
06731 
06732 
06733     <span class="comment">//</span>
06734     <span class="comment">// Handle the DACL.</span>
06735     <span class="comment">//</span>
06736     <span class="comment">//</span>
06737     <span class="comment">// If the DACL isn't present,</span>
06738     <span class="comment">//  special case it.</span>
06739     <span class="comment">//</span>
06740 
06741     CurrentDacl = RtlpDaclAddrSecurityDescriptor( CurrentDescriptor );
06742 
06743     <span class="keywordflow">if</span> ( CurrentDacl == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
06744         <span class="comment">// Preserve the Dacl Present bit from the existing descriptor.</span>
06745         NewDaclControl |= CurrentDescriptor-&gt;Control &amp; SE_DACL_PRESENT;
06746 
06747         <span class="comment">// Always set the autoinherited bit.</span>
06748         <span class="comment">// Force it protected.</span>
06749         NewDaclControl |= SE_DACL_AUTO_INHERITED | SE_DACL_PROTECTED;
06750 
06751 
06752 
06753     <span class="comment">//</span>
06754     <span class="comment">// If the DACL is already converted,</span>
06755     <span class="comment">//  or if this object is at the root of the tree,</span>
06756     <span class="comment">//  simply leave it alone.</span>
06757     <span class="comment">//</span>
06758     <span class="comment">// Don't force the Protect bit on at the root of the tree since it is semantically</span>
06759     <span class="comment">//  a no-op and gets in the way if the object is ever moved.</span>
06760     <span class="comment">//</span>
06761 
06762     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( RtlpAreControlBitsSet( CurrentDescriptor, SE_DACL_AUTO_INHERITED) ||
06763                 RtlpAreControlBitsSet( CurrentDescriptor, SE_DACL_PROTECTED ) ||
06764                 !ARGUMENT_PRESENT(ParentDescriptor) ) {
06765 
06766         <span class="comment">// Preserve the Acl Present bit and protected bit from the existing descriptor.</span>
06767         NewDaclControl |= CurrentDescriptor-&gt;Control &amp; (SE_DACL_PROTECTED|SE_DACL_PRESENT);
06768 
06769         <span class="comment">// Always set the autoinherited bit.</span>
06770         NewDaclControl |= SE_DACL_AUTO_INHERITED;
06771 
06772         NewDacl = CurrentDacl;
06773 
06774 
06775 
06776     <span class="comment">//</span>
06777     <span class="comment">// If the DACL is present,</span>
06778     <span class="comment">//  compute a new DACL with appropriate ACEs marked as inherited.</span>
06779     <span class="comment">//</span>
06780 
06781     } <span class="keywordflow">else</span> {
06782 
06783 
06784         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d8/d6/sertl_8c.html#a15">RtlpConvertAclToAutoInherit</a> (
06785                     ARGUMENT_PRESENT(ParentDescriptor) ?
06786                         RtlpDaclAddrSecurityDescriptor(
06787                             ((SECURITY_DESCRIPTOR *)ParentDescriptor)) :
06788                         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
06789                     RtlpDaclAddrSecurityDescriptor(CurrentDescriptor),
06790                     ObjectType,
06791                     IsDirectoryObject,
06792                     RtlpOwnerAddrSecurityDescriptor(CurrentDescriptor),
06793                     RtlpGroupAddrSecurityDescriptor(CurrentDescriptor),
06794                     GenericMapping,
06795                     &amp;NewDacl,
06796                     &amp;GenericControl );
06797 
06798         <span class="keywordflow">if</span> ( !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>) ) {
06799             <span class="keywordflow">goto</span> Cleanup;
06800         }
06801 
06802         NewDaclAllocated = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
06803         NewDaclControl |= SE_DACL_PRESENT | SeControlGenericToDacl( GenericControl );
06804     }
06805 
06806 
06807 
06808     <span class="comment">//</span>
06809     <span class="comment">// Build the resultant security descriptor</span>
06810     <span class="comment">//</span>
06811     <span class="comment">// Also map the ACEs for application to the target object</span>
06812     <span class="comment">// type, if they haven't already been mapped.</span>
06813     <span class="comment">//</span>
06814 
06815     NewOwnerSize = LongAlignSize(<a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>(NewOwner));
06816 
06817     <span class="keywordflow">if</span> ( NewGroup != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
06818         NewGroupSize = LongAlignSize(<a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>(NewGroup));
06819     } <span class="keywordflow">else</span> {
06820         NewGroupSize = 0;
06821     }
06822 
06823     <span class="keywordflow">if</span> (NewSacl != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
06824         NewSaclSize = LongAlignSize(NewSacl-&gt;AclSize);
06825     } <span class="keywordflow">else</span> {
06826         NewSaclSize = 0;
06827     }
06828 
06829     <span class="keywordflow">if</span> (NewDacl != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
06830         NewDaclSize = LongAlignSize(NewDacl-&gt;AclSize);
06831     } <span class="keywordflow">else</span> {
06832         NewDaclSize = 0;
06833     }
06834 
06835     AllocationSize = LongAlignSize(<span class="keyword">sizeof</span>(SECURITY_DESCRIPTOR_RELATIVE)) +
06836                      NewOwnerSize +
06837                      NewGroupSize +
06838                      NewSaclSize  +
06839                      NewDaclSize;
06840 
06841     <span class="comment">//</span>
06842     <span class="comment">// Allocate and initialize the security descriptor as</span>
06843     <span class="comment">// self-relative form.</span>
06844     <span class="comment">//</span>
06845 
06846 
06847 <span class="preprocessor">#ifdef NTOS_KERNEL_RUNTIME</span>
06848 <span class="preprocessor"></span>    INewDescriptor = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>(
06849                         <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>,
06850                         AllocationSize,
06851                         'dSeS' );
06852 <span class="preprocessor">#else // NTOS_KERNEL_RUNTIME</span>
06853 <span class="preprocessor"></span>    INewDescriptor = <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a0">RtlAllocateHeap</a>(
06854                         <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>,
06855                         <a class="code" href="../../d9/d2/ldrp_8h.html#a11">MAKE_TAG</a>(<a class="code" href="../../d9/d2/ldrp_8h.html#a17">SE_TAG</a>),
06856                         AllocationSize );
06857 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
06858 <span class="preprocessor"></span>
06859     <span class="keywordflow">if</span> ( INewDescriptor == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
06860         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_NO_MEMORY;
06861         <span class="keywordflow">goto</span> Cleanup;
06862     }
06863 
06864 
06865     <span class="comment">//</span>
06866     <span class="comment">// Initialize the security descriptor as self-relative form.</span>
06867     <span class="comment">//</span>
06868 
06869     <a class="code" href="../../d8/d6/sertl_8c.html#a54">RtlCreateSecurityDescriptorRelative</a>(
06870         INewDescriptor,
06871         SECURITY_DESCRIPTOR_REVISION
06872         );
06873 
06874     RtlpSetControlBits( INewDescriptor, SE_SELF_RELATIVE );
06875 
06876     Base = (PCHAR)(INewDescriptor);
06877     Field =  Base + <span class="keyword">sizeof</span>(SECURITY_DESCRIPTOR_RELATIVE);
06878 
06879     <span class="comment">//</span>
06880     <span class="comment">// Copy the Sacl</span>
06881     <span class="comment">//</span>
06882 
06883     RtlpSetControlBits( INewDescriptor, NewSaclControl );
06884     <span class="keywordflow">if</span> (NewSacl != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
06885 
06886         RtlCopyMemory( Field, NewSacl, NewSacl-&gt;AclSize );
06887         INewDescriptor-&gt;Sacl = RtlPointerToOffset(Base,Field);
06888         Field += NewSaclSize;
06889 
06890     } <span class="keywordflow">else</span> {
06891 
06892         INewDescriptor-&gt;Sacl = 0;
06893     }
06894 
06895     <span class="comment">//</span>
06896     <span class="comment">// Copy the Dacl</span>
06897     <span class="comment">//</span>
06898 
06899     RtlpSetControlBits( INewDescriptor, NewDaclControl );
06900     <span class="keywordflow">if</span> (NewDacl != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
06901 
06902         RtlCopyMemory( Field, NewDacl, NewDacl-&gt;AclSize );
06903         INewDescriptor-&gt;Dacl = RtlPointerToOffset(Base,Field);
06904         Field += NewDaclSize;
06905 
06906     } <span class="keywordflow">else</span> {
06907 
06908         INewDescriptor-&gt;Dacl = 0;
06909     }
06910 
06911     <span class="comment">//</span>
06912     <span class="comment">// Assign the owner</span>
06913     <span class="comment">//</span>
06914 
06915     RtlCopyMemory( Field, NewOwner, <a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>(NewOwner) );
06916     INewDescriptor-&gt;Owner = RtlPointerToOffset(Base,Field);
06917     Field += NewOwnerSize;
06918 
06919     <span class="keywordflow">if</span> ( NewGroup != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
06920         RtlCopyMemory( Field, NewGroup, <a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>(NewGroup) );
06921         INewDescriptor-&gt;Group = RtlPointerToOffset(Base,Field);
06922     }
06923 
06924     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
06925 
06926 
06927 
06928     <span class="comment">//</span>
06929     <span class="comment">// Cleanup any locally used resources.</span>
06930     <span class="comment">//</span>
06931 Cleanup:
06932     <span class="keywordflow">if</span> (NewDaclAllocated) {
06933 <span class="preprocessor">#ifdef NTOS_KERNEL_RUNTIME</span>
06934 <span class="preprocessor"></span>            <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( NewDacl );
06935 <span class="preprocessor">#else // NTOS_KERNEL_RUNTIME</span>
06936 <span class="preprocessor"></span>            <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, 0, NewDacl );
06937 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
06938 <span class="preprocessor"></span>    }
06939     <span class="keywordflow">if</span> (NewSaclAllocated) {
06940 <span class="preprocessor">#ifdef NTOS_KERNEL_RUNTIME</span>
06941 <span class="preprocessor"></span>            <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( NewSacl );
06942 <span class="preprocessor">#else // NTOS_KERNEL_RUNTIME</span>
06943 <span class="preprocessor"></span>            <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, 0, NewSacl );
06944 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
06945 <span class="preprocessor"></span>    }
06946 
06947     *NewSecurityDescriptor = (PSECURITY_DESCRIPTOR) INewDescriptor;
06948 
06949     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
06950 
06951 
06952 }
06953 
06954 <span class="comment">//</span>
06955 <span class="comment">// Local macro to classify the ACE flags in an ACE.</span>
06956 <span class="comment">//</span>
06957 <span class="comment">// Returns one or more of the following ACE flags:</span>
06958 <span class="comment">//</span>
06959 <span class="comment">//  CONTAINER_INHERIT_ACE - ACE is inherited to child containers</span>
06960 <span class="comment">//  OBJECT_INHERIT_ACE - ACE is inherited to child leaf objects</span>
06961 <span class="comment">//  EFFECTIVE_ACE - ACE is used during access validation</span>
06962 <span class="comment">//</span>
06963 
<a name="l06964"></a><a class="code" href="../../d8/d6/sertl_8c.html#a4">06964</a> <span class="preprocessor">#define MAX_CHILD_SID_GROUP_SIZE 3 // Number of bits in above list</span>
<a name="l06965"></a><a class="code" href="../../d8/d6/sertl_8c.html#a5">06965</a> <span class="preprocessor"></span><span class="preprocessor">#define EFFECTIVE_ACE INHERIT_ONLY_ACE</span>
<a name="l06966"></a><a class="code" href="../../d8/d6/sertl_8c.html#a6">06966</a> <span class="preprocessor"></span><span class="preprocessor">#define AceFlagsInAce( _Ace) \</span>
06967 <span class="preprocessor">            (((PACE_HEADER)(_Ace))-&gt;AceFlags &amp; (OBJECT_INHERIT_ACE|CONTAINER_INHERIT_ACE) | \</span>
06968 <span class="preprocessor">             (((PACE_HEADER)(_Ace))-&gt;AceFlags &amp; INHERIT_ONLY_ACE) ^ INHERIT_ONLY_ACE )</span>
06969 <span class="preprocessor"></span>
06970 
06971 BOOLEAN
<a name="l06972"></a><a class="code" href="../../d8/d6/sertl_8c.html#a23">06972</a> <a class="code" href="../../d8/d6/sertl_8c.html#a23">RtlpCompareAces</a>(
06973     IN <a class="code" href="../../d4/d7/struct__KNOWN__ACE.html">PKNOWN_ACE</a> InheritedAce,
06974     IN <a class="code" href="../../d4/d7/struct__KNOWN__ACE.html">PKNOWN_ACE</a> ChildAce,
06975     IN PSID OwnerSid,
06976     IN PSID GroupSid
06977     )
06978 <span class="comment">/*++</span>
06979 <span class="comment"></span>
06980 <span class="comment">Routine Description:</span>
06981 <span class="comment"></span>
06982 <span class="comment">    Compare two aces to see if they are "substantially" the same.</span>
06983 <span class="comment"></span>
06984 <span class="comment">Arguments:</span>
06985 <span class="comment"></span>
06986 <span class="comment">    InheritedAce - Computed ACE as inherited from DirectoryAcl.</span>
06987 <span class="comment"></span>
06988 <span class="comment">    ChildAce - The current acl on the object.  This ACL must be a revision 2 ACL.</span>
06989 <span class="comment"></span>
06990 <span class="comment">    ObjectType - GUID of the object type being created.  If the object being</span>
06991 <span class="comment">        created has no GUID associated with it, then this argument is</span>
06992 <span class="comment">        specified as NULL.</span>
06993 <span class="comment"></span>
06994 <span class="comment">    OwnerSid - Specifies the owner Sid to use.</span>
06995 <span class="comment">        If not specified, the owner sid is not treated as special.</span>
06996 <span class="comment"></span>
06997 <span class="comment">    GroupSid - Specifies the group SID to use.</span>
06998 <span class="comment">        If not specified, the group sid is not treated as special.</span>
06999 <span class="comment"></span>
07000 <span class="comment">Return Value:</span>
07001 <span class="comment"></span>
07002 <span class="comment">    TRUE - The ACEs are substantially the same.</span>
07003 <span class="comment">    FALSE - The ACEs are not substantially the same.</span>
07004 <span class="comment"></span>
07005 <span class="comment">--*/</span>
07006 {
07007     BOOLEAN AcesCompare = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
07008 
07009     <span class="keywordflow">if</span> (IsObjectAceType(InheritedAce) &amp;&amp; IsObjectAceType(ChildAce)) {
07010 
07011         AcesCompare = <a class="code" href="../../d8/d6/sertl_8c.html#a24">RtlpCompareKnownObjectAces</a>( (PKNOWN_OBJECT_ACE)InheritedAce,
07012                                                   (PKNOWN_OBJECT_ACE)ChildAce,
07013                                                   OwnerSid,
07014                                                   GroupSid
07015                                                   );
07016     } <span class="keywordflow">else</span> {
07017 
07018         <span class="keywordflow">if</span> (!IsObjectAceType(InheritedAce) &amp;&amp; !IsObjectAceType(ChildAce)) {
07019 
07020             AcesCompare = <a class="code" href="../../d8/d6/sertl_8c.html#a25">RtlpCompareKnownAces</a>( InheritedAce,
07021                                                 ChildAce,
07022                                                 OwnerSid,
07023                                                 GroupSid
07024                                                 );
07025         }
07026     }
07027 
07028     <span class="keywordflow">return</span>( AcesCompare );
07029 }
07030 
07031 
07032 BOOLEAN
<a name="l07033"></a><a class="code" href="../../d8/d6/sertl_8c.html#a25">07033</a> <a class="code" href="../../d8/d6/sertl_8c.html#a25">RtlpCompareKnownAces</a>(
07034     IN <a class="code" href="../../d4/d7/struct__KNOWN__ACE.html">PKNOWN_ACE</a> InheritedAce,
07035     IN <a class="code" href="../../d4/d7/struct__KNOWN__ACE.html">PKNOWN_ACE</a> ChildAce,
07036     IN PSID OwnerSid OPTIONAL,
07037     IN PSID GroupSid OPTIONAL
07038     )
07039 
07040 <span class="comment">/*++</span>
07041 <span class="comment"></span>
07042 <span class="comment">Routine Description:</span>
07043 <span class="comment"></span>
07044 <span class="comment">    Compare two aces to see if they are "substantially" the same.</span>
07045 <span class="comment"></span>
07046 <span class="comment">Arguments:</span>
07047 <span class="comment"></span>
07048 <span class="comment">    InheritedAce - Computed ACE as inherited from DirectoryAcl.</span>
07049 <span class="comment"></span>
07050 <span class="comment">    ChildAce - The current acl on the object.  This ACL must be a revision 2 ACL.</span>
07051 <span class="comment"></span>
07052 <span class="comment">    OwnerSid - Specifies the owner Sid to use.</span>
07053 <span class="comment">        If not specified, the owner sid is not treated as special.</span>
07054 <span class="comment"></span>
07055 <span class="comment">    GroupSid - Specifies the group SID to use.</span>
07056 <span class="comment">        If not specified, the group sid is not treated as special.</span>
07057 <span class="comment"></span>
07058 <span class="comment">Return Value:</span>
07059 <span class="comment"></span>
07060 <span class="comment">    TRUE - The ACEs are substantially the same.</span>
07061 <span class="comment">    FALSE - The ACEs are not substantially the same.</span>
07062 <span class="comment"></span>
07063 <span class="comment">--*/</span>
07064 
07065 {
07066     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
07067     ACE_HEADER <span class="keyword">volatile</span> *InheritedAceHdr = &amp;InheritedAce-&gt;Header;
07068 
07069     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
07070 
07071     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(!IsObjectAceType(InheritedAce));
07072     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(!IsObjectAceType(ChildAce));
07073 
07074     <span class="comment">//</span>
07075     <span class="comment">// If the Ace types are different,</span>
07076     <span class="comment">//  we don't match.</span>
07077     <span class="comment">//</span>
07078     <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a7">RtlBaseAceType</a>[ChildAce-&gt;Header.AceType] != <a class="code" href="../../d8/d6/sertl_8c.html#a7">RtlBaseAceType</a>[InheritedAceHdr-&gt;AceType] ) {
07079 <span class="preprocessor">#if DBG</span>
07080 <span class="preprocessor"></span>        <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a9">RtlpVerboseConvert</a> ) {
07081             KdPrint((<span class="stringliteral">"AceType mismatch"</span>));
07082         }
07083 <span class="preprocessor">#endif // DBG</span>
07084 <span class="preprocessor"></span>        <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
07085     }
07086 
07087     <span class="comment">//</span>
07088     <span class="comment">// If this is a system ACE,</span>
07089     <span class="comment">//  ensure the SUCCESS/FAILURE flags match.</span>
07090     <span class="comment">//</span>
07091 
07092     <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a8">RtlIsSystemAceType</a>[ChildAce-&gt;Header.AceType] ) {
07093         <span class="keywordflow">if</span> ( (ChildAce-&gt;Header.AceFlags &amp; (SUCCESSFUL_ACCESS_ACE_FLAG|FAILED_ACCESS_ACE_FLAG)) !=
07094              (InheritedAceHdr-&gt;AceFlags &amp; (SUCCESSFUL_ACCESS_ACE_FLAG|FAILED_ACCESS_ACE_FLAG)) ) {
07095 <span class="preprocessor">#if DBG</span>
07096 <span class="preprocessor"></span>            <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a9">RtlpVerboseConvert</a> ) {
07097                 KdPrint((<span class="stringliteral">"System ace success/fail mismatch"</span>));
07098             }
07099 <span class="preprocessor">#endif // DBG</span>
07100 <span class="preprocessor"></span>            <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
07101         }
07102     }
07103 
07104     <span class="comment">//</span>
07105     <span class="comment">// If the SID of the inherited ACE doesn't match,</span>
07106     <span class="comment">//  we don't match.</span>
07107     <span class="comment">//</span>
07108 
07109     <span class="keywordflow">if</span> ( !<a class="code" href="../../d8/d6/sertl_8c.html#a36">RtlEqualSid</a>( (PSID)&amp;ChildAce-&gt;SidStart, (PSID)&amp;InheritedAce-&gt;SidStart )) {
07110 
07111         <span class="comment">//</span>
07112         <span class="comment">// The inheritance algorithm only does SID mapping when building the effective</span>
07113         <span class="comment">//  ace.  So, we only check for a mapped SID if the child ACE is an effective ACE.</span>
07114         <span class="comment">//</span>
07115 
07116         <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a6">AceFlagsInAce</a>(ChildAce) != <a class="code" href="../../d8/d6/sertl_8c.html#a5">EFFECTIVE_ACE</a> ) {
07117 <span class="preprocessor">#if DBG</span>
07118 <span class="preprocessor"></span>            <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a9">RtlpVerboseConvert</a> ) {
07119                 KdPrint((<span class="stringliteral">"SID mismatch"</span>));
07120             }
07121 <span class="preprocessor">#endif // DBG</span>
07122 <span class="preprocessor"></span>            <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
07123         }
07124 
07125         <span class="comment">//</span>
07126         <span class="comment">// In the case of CreatorOwner and CreatorGroup, the SIDs don't have to</span>
07127         <span class="comment">//  exactly match.  When the InheritedAce was generated, care was taken</span>
07128         <span class="comment">//  to NOT map these sids.  The SID may (or may not) have been mapped in</span>
07129         <span class="comment">//  the ChildAce.  We want to compare equal in both cases.</span>
07130         <span class="comment">//</span>
07131         <span class="comment">// If the InheritedAce contains a CreatorOwner/Group SID,</span>
07132         <span class="comment">//  do the another comparison of the SID in the child ACE with the</span>
07133         <span class="comment">//  real owner/group from the child security descriptor.</span>
07134         <span class="comment">//</span>
07135 
07136         <span class="keywordflow">if</span> ( OwnerSid != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> || GroupSid != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
07137             SID_IDENTIFIER_AUTHORITY  CreatorSidAuthority = SECURITY_CREATOR_SID_AUTHORITY;
07138             ULONG <a class="code" href="../../d4/d6/tsevars_8c.html#a33">CreatorSid</a>[<a class="code" href="../../d8/d6/sertl_8c.html#a0">CREATOR_SID_SIZE</a>];
07139 
07140             <span class="comment">//</span>
07141             <span class="comment">// Allocate and initialize the universal SIDs we're going to need</span>
07142             <span class="comment">// to look for inheritable ACEs.</span>
07143             <span class="comment">//</span>
07144 
07145             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(<a class="code" href="../../d8/d6/sertl_8c.html#a38">RtlLengthRequiredSid</a>( 1 ) == <a class="code" href="../../d8/d6/sertl_8c.html#a0">CREATOR_SID_SIZE</a>);
07146             <a class="code" href="../../d8/d6/sertl_8c.html#a40">RtlInitializeSid</a>( (PSID)<a class="code" href="../../d4/d6/tsevars_8c.html#a33">CreatorSid</a>, &amp;CreatorSidAuthority, 1 );
07147             *(RtlpSubAuthoritySid( (PSID)<a class="code" href="../../d4/d6/tsevars_8c.html#a33">CreatorSid</a>, 0 )) = SECURITY_CREATOR_OWNER_RID;
07148 
07149             <span class="keywordflow">if</span> (<a class="code" href="../../d8/d6/sertl_8c.html#a37">RtlEqualPrefixSid</a> ( (PSID)&amp;InheritedAce-&gt;SidStart, <a class="code" href="../../d4/d6/tsevars_8c.html#a33">CreatorSid</a> )) {
07150                 ULONG Rid;
07151 
07152                 Rid = *RtlpSubAuthoritySid( (PSID)&amp;InheritedAce-&gt;SidStart, 0 );
07153                 <span class="keywordflow">switch</span> (Rid) {
07154                 <span class="keywordflow">case</span> SECURITY_CREATOR_OWNER_RID:
07155                     <span class="keywordflow">if</span> ( OwnerSid == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ||
07156                          !<a class="code" href="../../d8/d6/sertl_8c.html#a36">RtlEqualSid</a>( (PSID)&amp;ChildAce-&gt;SidStart, OwnerSid )) {
07157 <span class="preprocessor">#if DBG</span>
07158 <span class="preprocessor"></span>                        <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a9">RtlpVerboseConvert</a> ) {
07159                             KdPrint((<span class="stringliteral">"SID mismatch (Creator Owner)"</span>));
07160                         }
07161 <span class="preprocessor">#endif // DBG</span>
07162 <span class="preprocessor"></span>                        <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
07163                     }
07164                     <span class="keywordflow">break</span>;
07165                 <span class="keywordflow">case</span> SECURITY_CREATOR_GROUP_RID:
07166                     <span class="keywordflow">if</span> ( GroupSid == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ||
07167                          !<a class="code" href="../../d8/d6/sertl_8c.html#a36">RtlEqualSid</a>( (PSID)&amp;ChildAce-&gt;SidStart, GroupSid )) {
07168 <span class="preprocessor">#if DBG</span>
07169 <span class="preprocessor"></span>                        <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a9">RtlpVerboseConvert</a> ) {
07170                             KdPrint((<span class="stringliteral">"SID mismatch (Creator Group)"</span>));
07171                         }
07172 <span class="preprocessor">#endif // DBG</span>
07173 <span class="preprocessor"></span>                        <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
07174                     }
07175                     <span class="keywordflow">break</span>;
07176                 <span class="keywordflow">default</span>:
07177 <span class="preprocessor">#if DBG</span>
07178 <span class="preprocessor"></span>                    <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a9">RtlpVerboseConvert</a> ) {
07179                         KdPrint((<span class="stringliteral">"SID mismatch (Creator)"</span>));
07180                     }
07181 <span class="preprocessor">#endif // DBG</span>
07182 <span class="preprocessor"></span>                    <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
07183                 }
07184 
07185             } <span class="keywordflow">else</span> {
07186 <span class="preprocessor">#if DBG</span>
07187 <span class="preprocessor"></span>                <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a9">RtlpVerboseConvert</a> ) {
07188                     KdPrint((<span class="stringliteral">"SID mismatch"</span>));
07189                 }
07190 <span class="preprocessor">#endif // DBG</span>
07191 <span class="preprocessor"></span>                <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
07192             }
07193         } <span class="keywordflow">else</span> {
07194 <span class="preprocessor">#if DBG</span>
07195 <span class="preprocessor"></span>            <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a9">RtlpVerboseConvert</a> ) {
07196                 KdPrint((<span class="stringliteral">"SID mismatch"</span>));
07197             }
07198 <span class="preprocessor">#endif // DBG</span>
07199 <span class="preprocessor"></span>            <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
07200         }
07201     }
07202 
07203     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
07204 
07205 }
07206 
07207 
07208 BOOLEAN
<a name="l07209"></a><a class="code" href="../../d8/d6/sertl_8c.html#a24">07209</a> <a class="code" href="../../d8/d6/sertl_8c.html#a24">RtlpCompareKnownObjectAces</a>(
07210     IN PKNOWN_OBJECT_ACE InheritedAce,
07211     IN PKNOWN_OBJECT_ACE ChildAce,
07212     IN PSID OwnerSid OPTIONAL,
07213     IN PSID GroupSid OPTIONAL
07214     )
07215 
07216 <span class="comment">/*++</span>
07217 <span class="comment"></span>
07218 <span class="comment">Routine Description:</span>
07219 <span class="comment"></span>
07220 <span class="comment">    Compare two aces to see if they are "substantially" the same.</span>
07221 <span class="comment"></span>
07222 <span class="comment">Arguments:</span>
07223 <span class="comment"></span>
07224 <span class="comment">    InheritedAce - Computed ACE as inherited from DirectoryAcl.</span>
07225 <span class="comment"></span>
07226 <span class="comment">    ChildAce - The current acl on the object.  This ACL must be a revision 2 ACL.</span>
07227 <span class="comment"></span>
07228 <span class="comment">    ObjectType - GUID of the object type being created.  If the object being</span>
07229 <span class="comment">        created has no GUID associated with it, then this argument is</span>
07230 <span class="comment">        specified as NULL.</span>
07231 <span class="comment"></span>
07232 <span class="comment">    OwnerSid - Specifies the owner Sid to use.</span>
07233 <span class="comment">        If not specified, the owner sid is not treated as special.</span>
07234 <span class="comment"></span>
07235 <span class="comment">    GroupSid - Specifies the group SID to use.</span>
07236 <span class="comment">        If not specified, the group sid is not treated as special.</span>
07237 <span class="comment"></span>
07238 <span class="comment">Return Value:</span>
07239 <span class="comment"></span>
07240 <span class="comment">    TRUE - The ACEs are substantially the same.</span>
07241 <span class="comment">    FALSE - The ACEs are not substantially the same.</span>
07242 <span class="comment"></span>
07243 <span class="comment">--*/</span>
07244 
07245 {
07246     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
07247     BOOLEAN DoingObjectAces;
07248     GUID *ChildObjectGuid;
07249     GUID *InhObjectGuid;
07250     GUID *ChildInheritedObjectGuid;
07251     GUID *InhInheritedObjectGuid;
07252     ACE_HEADER <span class="keyword">volatile</span> *InheritedAceHdr = &amp;InheritedAce-&gt;Header;
07253 
07254     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
07255 
07256     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(IsObjectAceType(InheritedAce));
07257     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(IsObjectAceType(ChildAce));
07258     <span class="comment">//</span>
07259     <span class="comment">// If the Ace types are different,</span>
07260     <span class="comment">//  we don't match.</span>
07261     <span class="comment">//</span>
07262     <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a7">RtlBaseAceType</a>[ChildAce-&gt;Header.AceType] != <a class="code" href="../../d8/d6/sertl_8c.html#a7">RtlBaseAceType</a>[InheritedAceHdr-&gt;AceType] ) {
07263 <span class="preprocessor">#if DBG</span>
07264 <span class="preprocessor"></span>        <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a9">RtlpVerboseConvert</a> ) {
07265             KdPrint((<span class="stringliteral">"AceType mismatch"</span>));
07266         }
07267 <span class="preprocessor">#endif // DBG</span>
07268 <span class="preprocessor"></span>        <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
07269     }
07270 
07271     <span class="comment">//</span>
07272     <span class="comment">// If this is a system ACE,</span>
07273     <span class="comment">//  ensure the SUCCESS/FAILURE flags match.</span>
07274     <span class="comment">//</span>
07275 
07276     <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a8">RtlIsSystemAceType</a>[ChildAce-&gt;Header.AceType] ) {
07277         <span class="keywordflow">if</span> ( (ChildAce-&gt;Header.AceFlags &amp; (SUCCESSFUL_ACCESS_ACE_FLAG|FAILED_ACCESS_ACE_FLAG)) !=
07278              (InheritedAceHdr-&gt;AceFlags &amp; (SUCCESSFUL_ACCESS_ACE_FLAG|FAILED_ACCESS_ACE_FLAG)) ) {
07279 <span class="preprocessor">#if DBG</span>
07280 <span class="preprocessor"></span>            <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a9">RtlpVerboseConvert</a> ) {
07281                 KdPrint((<span class="stringliteral">"System ace success/fail mismatch"</span>));
07282             }
07283 <span class="preprocessor">#endif // DBG</span>
07284 <span class="preprocessor"></span>            <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
07285         }
07286     }
07287 
07288     <span class="comment">//</span>
07289     <span class="comment">// Get the GUIDs from the Object Aces</span>
07290     <span class="comment">//</span>
07291 
07292     ChildObjectGuid = RtlObjectAceObjectType(ChildAce);
07293     ChildInheritedObjectGuid = RtlObjectAceInheritedObjectType(ChildAce);
07294 
07295     InhObjectGuid = RtlObjectAceObjectType(InheritedAce);
07296     InhInheritedObjectGuid = RtlObjectAceInheritedObjectType(InheritedAce);
07297 
07298     <span class="comment">//</span>
07299     <span class="comment">// If the InheritedObjectGuid is present in either ACE,</span>
07300     <span class="comment">//  they must be equal.</span>
07301     <span class="comment">//</span>
07302 
07303     <span class="keywordflow">if</span> ( ChildInheritedObjectGuid != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> || InhInheritedObjectGuid != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
07304 
07305         <span class="keywordflow">if</span> ( ChildInheritedObjectGuid == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ||
07306              InhInheritedObjectGuid == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ||
07307              !RtlpIsEqualGuid( ChildInheritedObjectGuid, InhInheritedObjectGuid )) {
07308 <span class="preprocessor">#if DBG</span>
07309 <span class="preprocessor"></span>            <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a9">RtlpVerboseConvert</a> ) {
07310                 KdPrint((<span class="stringliteral">"InheritedObject GUID mismatch"</span>));
07311             }
07312 <span class="preprocessor">#endif // DBG</span>
07313 <span class="preprocessor"></span>            <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
07314         }
07315     }
07316 
07317     <span class="comment">//</span>
07318     <span class="comment">// If the ObjectGUID is present in either ACE,</span>
07319     <span class="comment">//  they must be equal.</span>
07320     <span class="comment">//</span>
07321     <span class="comment">// Any missing object GUID defaults to the passed in object GUID.</span>
07322     <span class="comment">//</span>
07323 
07324     <span class="keywordflow">if</span> ( (ChildObjectGuid != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp; (InhObjectGuid != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) ) {
07325 
07326         <span class="keywordflow">if</span> (!RtlpIsEqualGuid( ChildObjectGuid, InhObjectGuid )) {
07327 <span class="preprocessor">#if DBG</span>
07328 <span class="preprocessor"></span>            <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a9">RtlpVerboseConvert</a> ) {
07329                 KdPrint((<span class="stringliteral">"Object GUID mismatch"</span>));
07330             }
07331 <span class="preprocessor">#endif // DBG</span>
07332 <span class="preprocessor"></span>
07333             <span class="keywordflow">return</span>( <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
07334         }
07335     } <span class="keywordflow">else</span> {
07336 
07337         <span class="comment">//</span>
07338         <span class="comment">// One or both is NULL, if it's only one, they don't match.</span>
07339         <span class="comment">//</span>
07340 
07341         <span class="keywordflow">if</span> ( !((ChildObjectGuid == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp; (InhObjectGuid == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) ) {
07342 <span class="preprocessor">#if DBG</span>
07343 <span class="preprocessor"></span>            <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a9">RtlpVerboseConvert</a> ) {
07344                 KdPrint((<span class="stringliteral">"Object GUID mismatch"</span>));
07345             }
07346 <span class="preprocessor">#endif // DBG</span>
07347 <span class="preprocessor"></span>
07348             <span class="keywordflow">return</span>( <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
07349         }
07350     }
07351 
07352     <span class="comment">//</span>
07353     <span class="comment">// If the SID of the inherited ACE doesn't match,</span>
07354     <span class="comment">//  we don't match.</span>
07355     <span class="comment">//</span>
07356 
07357     <span class="keywordflow">if</span> ( !<a class="code" href="../../d8/d6/sertl_8c.html#a36">RtlEqualSid</a>( RtlObjectAceSid(ChildAce), RtlObjectAceSid(InheritedAce))) {
07358 
07359         <span class="comment">//</span>
07360         <span class="comment">// The inheritance algorithm only does SID mapping when building the effective</span>
07361         <span class="comment">//  ace.  So, we only check for a mapped SID if the child ACE is an effective ACE.</span>
07362         <span class="comment">//</span>
07363 
07364         <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a6">AceFlagsInAce</a>(ChildAce) != <a class="code" href="../../d8/d6/sertl_8c.html#a5">EFFECTIVE_ACE</a> ) {
07365 <span class="preprocessor">#if DBG</span>
07366 <span class="preprocessor"></span>            <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a9">RtlpVerboseConvert</a> ) {
07367                 KdPrint((<span class="stringliteral">"SID mismatch"</span>));
07368             }
07369 <span class="preprocessor">#endif // DBG</span>
07370 <span class="preprocessor"></span>            <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
07371         }
07372 
07373 
07374 
07375         <span class="comment">//</span>
07376         <span class="comment">// In the case of CreatorOwner and CreatorGroup, the SIDs don't have to</span>
07377         <span class="comment">//  exactly match.  When the InheritedAce was generated, care was taken</span>
07378         <span class="comment">//  to NOT map these sids.  The SID may (or may not) have been mapped in</span>
07379         <span class="comment">//  the ChildAce.  We want to compare equal in both cases.</span>
07380         <span class="comment">//</span>
07381         <span class="comment">// If the InheritedAce contains a CreatorOwner/Group SID,</span>
07382         <span class="comment">//  do the another comparison of the SID in the child ACE with the</span>
07383         <span class="comment">//  real owner/group from the child security descriptor.</span>
07384         <span class="comment">//</span>
07385 
07386         <span class="keywordflow">if</span> ( OwnerSid != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> || GroupSid != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
07387             SID_IDENTIFIER_AUTHORITY  CreatorSidAuthority = SECURITY_CREATOR_SID_AUTHORITY;
07388             ULONG <a class="code" href="../../d4/d6/tsevars_8c.html#a33">CreatorSid</a>[<a class="code" href="../../d8/d6/sertl_8c.html#a0">CREATOR_SID_SIZE</a>];
07389 
07390             <span class="comment">//</span>
07391             <span class="comment">// Allocate and initialize the universal SIDs we're going to need</span>
07392             <span class="comment">// to look for inheritable ACEs.</span>
07393             <span class="comment">//</span>
07394 
07395             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(<a class="code" href="../../d8/d6/sertl_8c.html#a38">RtlLengthRequiredSid</a>( 1 ) == <a class="code" href="../../d8/d6/sertl_8c.html#a0">CREATOR_SID_SIZE</a>);
07396             <a class="code" href="../../d8/d6/sertl_8c.html#a40">RtlInitializeSid</a>( (PSID)<a class="code" href="../../d4/d6/tsevars_8c.html#a33">CreatorSid</a>, &amp;CreatorSidAuthority, 1 );
07397             *(RtlpSubAuthoritySid( (PSID)<a class="code" href="../../d4/d6/tsevars_8c.html#a33">CreatorSid</a>, 0 )) = SECURITY_CREATOR_OWNER_RID;
07398 
07399             <span class="keywordflow">if</span> (<a class="code" href="../../d8/d6/sertl_8c.html#a37">RtlEqualPrefixSid</a> ( RtlObjectAceSid(InheritedAce), <a class="code" href="../../d4/d6/tsevars_8c.html#a33">CreatorSid</a> )) {
07400                 ULONG Rid;
07401 
07402                 Rid = *RtlpSubAuthoritySid( RtlObjectAceSid(InheritedAce), 0 );
07403                 <span class="keywordflow">switch</span> (Rid) {
07404                 <span class="keywordflow">case</span> SECURITY_CREATOR_OWNER_RID:
07405                     <span class="keywordflow">if</span> ( OwnerSid == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ||
07406                          !<a class="code" href="../../d8/d6/sertl_8c.html#a36">RtlEqualSid</a>( RtlObjectAceSid(ChildAce), OwnerSid )) {
07407 <span class="preprocessor">#if DBG</span>
07408 <span class="preprocessor"></span>                        <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a9">RtlpVerboseConvert</a> ) {
07409                             KdPrint((<span class="stringliteral">"SID mismatch (Creator Owner)"</span>));
07410                         }
07411 <span class="preprocessor">#endif // DBG</span>
07412 <span class="preprocessor"></span>                        <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
07413                     }
07414                     <span class="keywordflow">break</span>;
07415                 <span class="keywordflow">case</span> SECURITY_CREATOR_GROUP_RID:
07416                     <span class="keywordflow">if</span> ( GroupSid == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ||
07417                          !<a class="code" href="../../d8/d6/sertl_8c.html#a36">RtlEqualSid</a>( RtlObjectAceSid(ChildAce), GroupSid )) {
07418 <span class="preprocessor">#if DBG</span>
07419 <span class="preprocessor"></span>                        <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a9">RtlpVerboseConvert</a> ) {
07420                             KdPrint((<span class="stringliteral">"SID mismatch (Creator Group)"</span>));
07421                         }
07422 <span class="preprocessor">#endif // DBG</span>
07423 <span class="preprocessor"></span>                        <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
07424                     }
07425                     <span class="keywordflow">break</span>;
07426                 <span class="keywordflow">default</span>:
07427 <span class="preprocessor">#if DBG</span>
07428 <span class="preprocessor"></span>                    <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a9">RtlpVerboseConvert</a> ) {
07429                         KdPrint((<span class="stringliteral">"SID mismatch (Creator)"</span>));
07430                     }
07431 <span class="preprocessor">#endif // DBG</span>
07432 <span class="preprocessor"></span>                    <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
07433                 }
07434 
07435             } <span class="keywordflow">else</span> {
07436 <span class="preprocessor">#if DBG</span>
07437 <span class="preprocessor"></span>                <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a9">RtlpVerboseConvert</a> ) {
07438                     KdPrint((<span class="stringliteral">"SID mismatch"</span>));
07439                 }
07440 <span class="preprocessor">#endif // DBG</span>
07441 <span class="preprocessor"></span>                <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
07442             }
07443         } <span class="keywordflow">else</span> {
07444 <span class="preprocessor">#if DBG</span>
07445 <span class="preprocessor"></span>            <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a9">RtlpVerboseConvert</a> ) {
07446                 KdPrint((<span class="stringliteral">"SID mismatch"</span>));
07447             }
07448 <span class="preprocessor">#endif // DBG</span>
07449 <span class="preprocessor"></span>            <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
07450         }
07451     }
07452 
07453     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
07454 
07455 }
07456 
07457 
07458 
07459 
07460 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l07461"></a><a class="code" href="../../d8/d6/sertl_8c.html#a15">07461</a> <a class="code" href="../../d8/d6/sertl_8c.html#a15">RtlpConvertAclToAutoInherit</a> (
07462     IN PACL ParentAcl OPTIONAL,
07463     IN PACL ChildAcl,
07464     IN GUID *ObjectType OPTIONAL,
07465     IN BOOLEAN IsDirectoryObject,
07466     IN PSID OwnerSid,
07467     IN PSID GroupSid,
07468     IN PGENERIC_MAPPING GenericMapping,
07469     OUT PACL *NewAcl,
07470     OUT PULONG NewGenericControl
07471     )
07472 
07473 <span class="comment">/*++</span>
07474 <span class="comment"></span>
07475 <span class="comment">Routine Description:</span>
07476 <span class="comment"></span>
07477 <span class="comment">    This is a private routine that produces an auto inherited acl from</span>
07478 <span class="comment">    a ChildAcl that is not marked as auto inherited.  The passed in InheritedAcl</span>
07479 <span class="comment">    is computed as the pure inherited ACL of Parent ACL of the object.</span>
07480 <span class="comment"></span>
07481 <span class="comment">    See comments for RtlConvertToAutoInheritSecurityObject.</span>
07482 <span class="comment"></span>
07483 <span class="comment">Arguments:</span>
07484 <span class="comment"></span>
07485 <span class="comment">    ParentAcl - Supplies the ACL of the parent object.</span>
07486 <span class="comment"></span>
07487 <span class="comment">    ChildAcl - Supplies the acl associated with the object.  This</span>
07488 <span class="comment">        is the current acl on the object.</span>
07489 <span class="comment"></span>
07490 <span class="comment">    ObjectType - GUID of the object type being created.  If the object being</span>
07491 <span class="comment">        created has no GUID associated with it, then this argument is</span>
07492 <span class="comment">        specified as NULL.</span>
07493 <span class="comment"></span>
07494 <span class="comment">    IsDirectoryObject - Specifies if the object is a</span>
07495 <span class="comment">        directory object.  A value of TRUE indicates the object is a</span>
07496 <span class="comment">        container of other objects.</span>
07497 <span class="comment"></span>
07498 <span class="comment">    OwnerSid - Specifies the owner Sid to use.</span>
07499 <span class="comment"></span>
07500 <span class="comment">    GroupSid - Specifies the group SID to use.</span>
07501 <span class="comment"></span>
07502 <span class="comment">    GenericMapping - Specifies the generic mapping to use.</span>
07503 <span class="comment"></span>
07504 <span class="comment">    NewAcl - Receives a pointer to the new (auto inherited) acl.</span>
07505 <span class="comment">        The ACL must be deallocated using the pool (kernel mode) or</span>
07506 <span class="comment">            heap (user mode) deallocator.</span>
07507 <span class="comment"></span>
07508 <span class="comment">    NewGenericControl - Specifies the control flags for the newly</span>
07509 <span class="comment">        generated ACL.</span>
07510 <span class="comment"></span>
07511 <span class="comment">        SEP_ACL_PRESENT: Specifies that the ACL is explictly supplied by</span>
07512 <span class="comment">            the caller. ?? Ever set?</span>
07513 <span class="comment"></span>
07514 <span class="comment">        SEP_ACL_DEFAULTED: Specifies that the ACL was supplied by some</span>
07515 <span class="comment">            defaulting mechanism. ?? Ever set</span>
07516 <span class="comment"></span>
07517 <span class="comment">        SEP_ACL_AUTO_INHERITED: Set if the ACL was generated using the</span>
07518 <span class="comment">            Automatic Inheritance algorithm.</span>
07519 <span class="comment"></span>
07520 <span class="comment">        SEP_ACL_PROTECTED: Specifies that the ACL is protected and</span>
07521 <span class="comment">            was not inherited from the parent ACL.</span>
07522 <span class="comment"></span>
07523 <span class="comment">Return Value:</span>
07524 <span class="comment"></span>
07525 <span class="comment">    STATUS_SUCCESS - An inheritable ACL was successfully generated.</span>
07526 <span class="comment"></span>
07527 <span class="comment">    STATUS_UNKNOWN_REVISION - Indicates the source ACL is a revision that</span>
07528 <span class="comment">        is unknown to this routine.</span>
07529 <span class="comment"></span>
07530 <span class="comment">    STATUS_INVALID_ACL - The structure of one of the ACLs in invalid.</span>
07531 <span class="comment"></span>
07532 <span class="comment">--*/</span>
07533 
07534 {
07535     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
07536 
07537     PACL InheritedAcl = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
07538     PACL RealInheritedAcl = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
07539     BOOLEAN AclExplicitlyAssigned;
07540     ULONG GenericControl;
07541 
07542     <a class="code" href="../../d4/d7/struct__KNOWN__ACE.html">PKNOWN_ACE</a> ChildAce = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
07543     <a class="code" href="../../d4/d7/struct__KNOWN__ACE.html">PKNOWN_ACE</a> InheritedAce;
07544 
07545     LONG ChildAceIndex;
07546     LONG InheritedAceIndex;
07547 
07548     BOOLEAN InheritedAllowFound;
07549     BOOLEAN InheritedDenyFound;
07550 
07551     BOOLEAN AcesCompare;
07552 
07553     ACCESS_MASK InheritedContainerInheritMask;
07554     ACCESS_MASK InheritedObjectInheritMask;
07555     ACCESS_MASK InheritedEffectiveMask;
07556     ACCESS_MASK OriginalInheritedContainerInheritMask;
07557     ACCESS_MASK OriginalInheritedObjectInheritMask;
07558     ACCESS_MASK OriginalInheritedEffectiveMask;
07559 
07560     ULONG InheritedAceFlags;
07561     ULONG MatchedFlags;
07562     ULONG NonInheritedAclSize;
07563 
07564 
07565     PACE_HEADER AceHeader;
07566     PUCHAR Where;
07567 
07568     <span class="comment">// ULONG i;</span>
07569 
07570     <span class="comment">//</span>
07571     <span class="comment">// This routine maintains an array of the structure below (one element per ACE in</span>
07572     <span class="comment">// the ChildAcl).</span>
07573     <span class="comment">//</span>
07574     <span class="comment">// The ACE is broken down into its component parts.  The access mask is triplicated.</span>
07575     <span class="comment">// That is, if the ACE is a ContainerInherit ACE, the access mask is remembered as</span>
07576     <span class="comment">// being a "ContainerInheritMask".  The same is true if the ACE is an ObjectInherit ACE</span>
07577     <span class="comment">// on an effective ACE.  This is done since each of the resultant 96 bits are</span>
07578     <span class="comment">// individually matched against corresponding bits in the computed inherited ACE.</span>
07579     <span class="comment">//</span>
07580     <span class="comment">// Each of the above mentioned masks are maintained in two forms.  The first is never</span>
07581     <span class="comment">// changed and represents the bits as the originally appeared in the child ACL.</span>
07582     <span class="comment">// This second is modified as the corresponding bits are matched in the inherited ACL.</span>
07583     <span class="comment">// When the algorithm is completed, bits that haven't been matched represent ACEs</span>
07584     <span class="comment">// that weren't inherited from the parent.</span>
07585     <span class="comment">//</span>
07586 
07587     <span class="keyword">typedef</span> <span class="keyword">struct </span>{
07588         ACCESS_MASK OriginalContainerInheritMask;
07589         ACCESS_MASK OriginalObjectInheritMask;
07590         ACCESS_MASK OriginalEffectiveMask;
07591 
07592         ACCESS_MASK ContainerInheritMask;
07593         ACCESS_MASK ObjectInheritMask;
07594         ACCESS_MASK EffectiveMask;
07595     } ACE_INFO, *PACE_INFO;
07596 
07597     PACE_INFO ChildAceInfo = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
07598 
07599     ULONG <a class="code" href="../../d4/d1/rtdmpsec_8c.html#a10">CreatorOwnerSid</a>[<a class="code" href="../../d8/d6/sertl_8c.html#a0">CREATOR_SID_SIZE</a>];
07600     ULONG CreatorGroupSid[<a class="code" href="../../d8/d6/sertl_8c.html#a0">CREATOR_SID_SIZE</a>];
07601 
07602     SID_IDENTIFIER_AUTHORITY  CreatorSidAuthority = SECURITY_CREATOR_SID_AUTHORITY;
07603 
07604 <span class="preprocessor">#ifndef NTOS_KERNEL_RUNTIME</span>
07605 <span class="preprocessor"></span>    PVOID <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
07606 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
07607 <span class="preprocessor"></span>
07608     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
07609 
07610     <span class="comment">//</span>
07611     <span class="comment">// Get the handle to the current process heap</span>
07612     <span class="comment">//</span>
07613 
07614 <span class="preprocessor">#ifndef NTOS_KERNEL_RUNTIME</span>
07615 <span class="preprocessor"></span>    <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a> = RtlProcessHeap();
07616 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
07617 <span class="preprocessor"></span>
07618     <span class="comment">//</span>
07619     <span class="comment">// Allocate and initialize the universal SIDs we're going to need</span>
07620     <span class="comment">// to look for inheritable ACEs.</span>
07621     <span class="comment">//</span>
07622 
07623     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(<a class="code" href="../../d8/d6/sertl_8c.html#a38">RtlLengthRequiredSid</a>( 1 ) == <a class="code" href="../../d8/d6/sertl_8c.html#a0">CREATOR_SID_SIZE</a>);
07624     <a class="code" href="../../d8/d6/sertl_8c.html#a40">RtlInitializeSid</a>( (PSID)<a class="code" href="../../d4/d1/rtdmpsec_8c.html#a10">CreatorOwnerSid</a>, &amp;CreatorSidAuthority, 1 );
07625     *(RtlpSubAuthoritySid( (PSID)<a class="code" href="../../d4/d1/rtdmpsec_8c.html#a10">CreatorOwnerSid</a>, 0 )) = SECURITY_CREATOR_OWNER_RID;
07626 
07627     <a class="code" href="../../d8/d6/sertl_8c.html#a40">RtlInitializeSid</a>( (PSID)CreatorGroupSid, &amp;CreatorSidAuthority, 1 );
07628     *(RtlpSubAuthoritySid( (PSID)CreatorGroupSid, 0 )) = SECURITY_CREATOR_GROUP_RID;
07629 
07630     <span class="comment">//</span>
07631     <span class="comment">// Ensure the passed in ACLs are valid.</span>
07632     <span class="comment">//</span>
07633 
07634     *NewGenericControl = SEP_ACL_AUTO_INHERITED;
07635     *NewAcl = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
07636 
07637     <span class="keywordflow">if</span> ( ParentAcl != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> &amp;&amp; !<a class="code" href="../../d2/d4/acledit_8c.html#a7">RtlValidAcl</a>( ParentAcl ) ) {
07638         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_ACL;
07639         <span class="keywordflow">goto</span> Cleanup;
07640     }
07641 
07642     <span class="keywordflow">if</span> (!<a class="code" href="../../d2/d4/acledit_8c.html#a7">RtlValidAcl</a>( ChildAcl ) ) {
07643         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_ACL;
07644         <span class="keywordflow">goto</span> Cleanup;
07645     }
07646 
07647 
07648     <span class="comment">//</span>
07649     <span class="comment">// Compute what the inherited ACL "should" look like.</span>
07650     <span class="comment">//</span>
07651     <span class="comment">// The inherited ACL is computed to NOT SID-map Creator Owner and Creator Group.</span>
07652     <span class="comment">// This allows use to later recognize the constant SIDs and special case them</span>
07653     <span class="comment">// rather than mistakenly confuse them with the mapped SID.</span>
07654     <span class="comment">//</span>
07655 
07656     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d8/d6/sertl_8c.html#a74">RtlpInheritAcl</a> (
07657                 ParentAcl,
07658                 <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,   <span class="comment">// No explicit child ACL</span>
07659                 0,      <span class="comment">// No Child Generic Control</span>
07660                 IsDirectoryObject,
07661                 <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,   <span class="comment">// AutoInherit the DACL</span>
07662                 <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,  <span class="comment">// Not default descriptor for object</span>
07663                 <a class="code" href="../../d4/d1/rtdmpsec_8c.html#a10">CreatorOwnerSid</a>,   <span class="comment">// Subsitute a constant SID</span>
07664                 CreatorGroupSid,   <span class="comment">// Subsitute a constant SID</span>
07665                 <a class="code" href="../../d4/d1/rtdmpsec_8c.html#a10">CreatorOwnerSid</a>,   <span class="comment">// Server Owner (Technically incorrect, but OK since we don't support compound ACEs)</span>
07666                 CreatorGroupSid,   <span class="comment">// Server Group</span>
07667                 GenericMapping,
07668                 <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,   <span class="comment">// Is a SACL</span>
07669                 ObjectType,
07670                 &amp;InheritedAcl,
07671                 &amp;AclExplicitlyAssigned,
07672                 &amp;GenericControl );
07673 
07674     <span class="keywordflow">if</span> ( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_NO_INHERITANCE ) {
07675         *NewGenericControl |= SEP_ACL_PROTECTED;
07676 <span class="preprocessor">#if DBG</span>
07677 <span class="preprocessor"></span>        <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a9">RtlpVerboseConvert</a> ) {
07678             KdPrint((<span class="stringliteral">"NO_INHERITANCE of the parent ACL\n"</span> ));
07679         }
07680 <span class="preprocessor">#endif // DBG</span>
07681 <span class="preprocessor"></span>        <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
07682         <span class="keywordflow">goto</span> Cleanup;
07683     }
07684 
07685     <span class="keywordflow">if</span> ( !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>) ) {
07686 <span class="preprocessor">#if DBG</span>
07687 <span class="preprocessor"></span>        <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a9">RtlpVerboseConvert</a> ) {
07688             KdPrint((<span class="stringliteral">"Can't build inherited ACL %lX\n"</span>, <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> ));
07689         }
07690 <span class="preprocessor">#endif // DBG</span>
07691 <span class="preprocessor"></span>        <span class="keywordflow">goto</span> Cleanup;
07692     }
07693 
07694 
07695 
07696 
07697 
07698     <span class="comment">//</span>
07699     <span class="comment">// Allocate a work buffer describing the ChildAcl</span>
07700     <span class="comment">//</span>
07701 
07702 <span class="preprocessor">#ifdef NTOS_KERNEL_RUNTIME</span>
07703 <span class="preprocessor"></span>    ChildAceInfo = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>(
07704                         <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>,
07705                         ChildAcl-&gt;AceCount * <span class="keyword">sizeof</span>(ACE_INFO),
07706                         'cAeS' );
07707 <span class="preprocessor">#else // NTOS_KERNEL_RUNTIME</span>
07708 <span class="preprocessor"></span>    ChildAceInfo = <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a0">RtlAllocateHeap</a>(
07709                         <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>,
07710                         <a class="code" href="../../d9/d2/ldrp_8h.html#a11">MAKE_TAG</a>(<a class="code" href="../../d9/d2/ldrp_8h.html#a17">SE_TAG</a>),
07711                         ChildAcl-&gt;AceCount * <span class="keyword">sizeof</span>(ACE_INFO) );
07712 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
07713 <span class="preprocessor"></span>
07714     <span class="keywordflow">if</span> (ChildAceInfo == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
07715         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_NO_MEMORY;
07716         <span class="keywordflow">goto</span> Cleanup;
07717     }
07718 
07719     <span class="keywordflow">for</span> (ChildAceIndex = 0, ChildAce = <a class="code" href="../../d4/d1/rtdmpsec_8c.html#a1">FirstAce</a>(ChildAcl);
07720          ChildAceIndex &lt; ChildAcl-&gt;AceCount;
07721          ChildAceIndex += 1, ChildAce = <a class="code" href="../../d4/d1/rtdmpsec_8c.html#a2">NextAce</a>(ChildAce)) {
07722         ACCESS_MASK LocalMask;
07723         ULONG ChildAceFlags;
07724 
07725         <span class="keywordflow">if</span> ( !IsV4AceType(ChildAce) || IsCompoundAceType(ChildAce)) {
07726              *NewGenericControl |= SEP_ACL_PROTECTED;
07727 <span class="preprocessor">#if DBG</span>
07728 <span class="preprocessor"></span>             <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a9">RtlpVerboseConvert</a> ) {
07729                  KdPrint((<span class="stringliteral">"Inherited Ace type (%ld) not known\n"</span>, ChildAce-&gt;Header.AceType ));
07730              }
07731 <span class="preprocessor">#endif // DBG</span>
07732 <span class="preprocessor"></span>             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
07733              <span class="keywordflow">goto</span> Cleanup;
07734         }
07735 
07736         <span class="comment">//</span>
07737         <span class="comment">// Compute the generic mapped mask for use in all comparisons.  The</span>
07738         <span class="comment">//  generic mapping will be undone if needed later.</span>
07739         <span class="comment">//</span>
07740         <span class="comment">// All V4 aces have an access mask in the same location.</span>
07741         <span class="comment">//</span>
07742         LocalMask = ((<a class="code" href="../../d4/d7/struct__KNOWN__ACE.html">PKNOWN_ACE</a>)(ChildAce))-&gt;Mask;
07743         RtlApplyGenericMask( ChildAce, &amp;LocalMask, GenericMapping);
07744 
07745 
07746         <span class="comment">//</span>
07747         <span class="comment">// Break the ACE into its component parts.</span>
07748         <span class="comment">//</span>
07749         ChildAceFlags = <a class="code" href="../../d8/d6/sertl_8c.html#a6">AceFlagsInAce</a>( ChildAce );
07750         <span class="keywordflow">if</span> ( ChildAceFlags &amp; CONTAINER_INHERIT_ACE ) {
07751             ChildAceInfo[ChildAceIndex].OriginalContainerInheritMask = LocalMask;
07752             ChildAceInfo[ChildAceIndex].ContainerInheritMask = LocalMask;
07753         } <span class="keywordflow">else</span> {
07754             ChildAceInfo[ChildAceIndex].OriginalContainerInheritMask = 0;
07755             ChildAceInfo[ChildAceIndex].ContainerInheritMask = 0;
07756         }
07757 
07758         <span class="keywordflow">if</span> ( ChildAceFlags &amp; OBJECT_INHERIT_ACE ) {
07759             ChildAceInfo[ChildAceIndex].OriginalObjectInheritMask = LocalMask;
07760             ChildAceInfo[ChildAceIndex].ObjectInheritMask = LocalMask;
07761         } <span class="keywordflow">else</span> {
07762             ChildAceInfo[ChildAceIndex].OriginalObjectInheritMask = 0;
07763             ChildAceInfo[ChildAceIndex].ObjectInheritMask = 0;
07764         }
07765 
07766         <span class="keywordflow">if</span> ( ChildAceFlags &amp; <a class="code" href="../../d8/d6/sertl_8c.html#a5">EFFECTIVE_ACE</a> ) {
07767             ChildAceInfo[ChildAceIndex].OriginalEffectiveMask = LocalMask;
07768             ChildAceInfo[ChildAceIndex].EffectiveMask = LocalMask;
07769         } <span class="keywordflow">else</span> {
07770             ChildAceInfo[ChildAceIndex].OriginalEffectiveMask = 0;
07771             ChildAceInfo[ChildAceIndex].EffectiveMask = 0;
07772         }
07773 
07774     }
07775 
07776 
07777     <span class="comment">//</span>
07778     <span class="comment">// Walk through the computed inherited ACL one ACE at a time.</span>
07779     <span class="comment">//</span>
07780 
07781     <span class="keywordflow">for</span> (InheritedAceIndex = 0, InheritedAce = <a class="code" href="../../d4/d1/rtdmpsec_8c.html#a1">FirstAce</a>(InheritedAcl);
07782          InheritedAceIndex &lt; InheritedAcl-&gt;AceCount;
07783          InheritedAceIndex += 1, InheritedAce = <a class="code" href="../../d4/d1/rtdmpsec_8c.html#a2">NextAce</a>(InheritedAce)) {
07784 
07785         ACCESS_MASK LocalMask;
07786 
07787         <span class="comment">//</span>
07788         <span class="comment">// If the ACE isn't a valid version 4 ACE,</span>
07789         <span class="comment">//  this isn't an ACL we're interested in handling.</span>
07790         <span class="comment">//</span>
07791 
07792         <span class="keywordflow">if</span> ( !IsV4AceType(InheritedAce) || IsCompoundAceType(InheritedAce)) {
07793              *NewGenericControl |= SEP_ACL_PROTECTED;
07794 <span class="preprocessor">#if DBG</span>
07795 <span class="preprocessor"></span>             <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a9">RtlpVerboseConvert</a> ) {
07796                  KdPrint((<span class="stringliteral">"Inherited Ace type (%ld) not known\n"</span>, InheritedAce-&gt;Header.AceType ));
07797              }
07798 <span class="preprocessor">#endif // DBG</span>
07799 <span class="preprocessor"></span>             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
07800              <span class="keywordflow">goto</span> Cleanup;
07801         }
07802 
07803         <span class="comment">//</span>
07804         <span class="comment">// Compute the generic mapped mask for use in all comparisons.  The</span>
07805         <span class="comment">//  generic mapping will be undone if needed later.</span>
07806         <span class="comment">//</span>
07807         <span class="comment">// All V4 aces have an access mask in the same location.</span>
07808         <span class="comment">//</span>
07809         LocalMask = ((<a class="code" href="../../d4/d7/struct__KNOWN__ACE.html">PKNOWN_ACE</a>)(InheritedAce))-&gt;Mask;
07810         RtlApplyGenericMask( InheritedAce, &amp;LocalMask, GenericMapping);
07811 
07812         <span class="keywordflow">if</span> ( LocalMask == 0 ) {
07813 <span class="preprocessor">#if DBG</span>
07814 <span class="preprocessor"></span>            <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a9">RtlpVerboseConvert</a> ) {
07815                 KdPrint((<span class="stringliteral">"Worthless INH ACE: %ld 0x%8.8lx\n"</span>, InheritedAceIndex, LocalMask ));
07816             }
07817 <span class="preprocessor">#endif // DBG</span>
07818 <span class="preprocessor"></span>            <span class="keywordflow">continue</span>;
07819         }
07820 
07821         <span class="comment">//</span>
07822         <span class="comment">// This ACE is some combination of an effective ACE, a container</span>
07823         <span class="comment">//  inherit ACE and an object inherit ACE.  Process each of those</span>
07824         <span class="comment">//  attributes separately since they might be represented separately</span>
07825         <span class="comment">//  in the ChildAcl.</span>
07826         <span class="comment">//</span>
07827 
07828         InheritedAceFlags = <a class="code" href="../../d8/d6/sertl_8c.html#a6">AceFlagsInAce</a>( InheritedAce );
07829 
07830         <span class="keywordflow">if</span>  ( InheritedAceFlags == 0 ) {
07831 <span class="preprocessor">#if DBG</span>
07832 <span class="preprocessor"></span>            <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a9">RtlpVerboseConvert</a> ) {
07833                 KdPrint((<span class="stringliteral">"Worthless INH ACE: %ld 0x%lx\n"</span>, InheritedAceIndex, InheritedAceFlags ));
07834             }
07835 <span class="preprocessor">#endif // DBG</span>
07836 <span class="preprocessor"></span>            <span class="keywordflow">continue</span>;
07837         }
07838 
07839         <span class="keywordflow">if</span> ( InheritedAceFlags &amp; CONTAINER_INHERIT_ACE ) {
07840             OriginalInheritedContainerInheritMask = InheritedContainerInheritMask = LocalMask;
07841         } <span class="keywordflow">else</span> {
07842             OriginalInheritedContainerInheritMask = InheritedContainerInheritMask = 0;
07843         }
07844 
07845         <span class="keywordflow">if</span> ( InheritedAceFlags &amp; OBJECT_INHERIT_ACE ) {
07846             OriginalInheritedObjectInheritMask = InheritedObjectInheritMask = LocalMask;
07847         } <span class="keywordflow">else</span> {
07848             OriginalInheritedObjectInheritMask = InheritedObjectInheritMask = 0;
07849         }
07850 
07851         <span class="keywordflow">if</span> ( InheritedAceFlags &amp; <a class="code" href="../../d8/d6/sertl_8c.html#a5">EFFECTIVE_ACE</a> ) {
07852             OriginalInheritedEffectiveMask = InheritedEffectiveMask = LocalMask;
07853         } <span class="keywordflow">else</span> {
07854             OriginalInheritedEffectiveMask = InheritedEffectiveMask = 0;
07855         }
07856 
07857 <span class="preprocessor">#if DBG</span>
07858 <span class="preprocessor"></span>        <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a9">RtlpVerboseConvert</a> ) {
07859             KdPrint((<span class="stringliteral">"Doing INH ACE:  %ld %8.8lX %8.8lX %8.8lX\n"</span>, InheritedAceIndex, InheritedEffectiveMask, InheritedContainerInheritMask, InheritedObjectInheritMask ));
07860         }
07861 <span class="preprocessor">#endif // DBG</span>
07862 <span class="preprocessor"></span>
07863 
07864         <span class="comment">//</span>
07865         <span class="comment">// Loop through the entire child ACL comparing each inherited ACE with</span>
07866         <span class="comment">//  each child ACE.  Don't stop simply because we've matched once.</span>
07867         <span class="comment">//  Multiple ACEs in the one ACL may have been condensed into a single ACE</span>
07868         <span class="comment">//  in the other ACL in any combination (by any of our friendly ACL editors).</span>
07869         <span class="comment">//  In all cases, it is better to compute a resultant auto inherited ACL</span>
07870         <span class="comment">//  than it is to compute a protected ACL.</span>
07871         <span class="comment">//</span>
07872 
07873         <span class="keywordflow">for</span> (ChildAceIndex = 0, ChildAce = <a class="code" href="../../d4/d1/rtdmpsec_8c.html#a1">FirstAce</a>(ChildAcl);
07874              ChildAceIndex &lt; ChildAcl-&gt;AceCount;
07875              ChildAceIndex += 1, ChildAce = <a class="code" href="../../d4/d1/rtdmpsec_8c.html#a2">NextAce</a>(ChildAce)) {
07876 
07877 
07878             <span class="comment">//</span>
07879             <span class="comment">// Ensure the ACE represents the same principal and object,</span>
07880             <span class="comment">//</span>
07881 
07882 <span class="preprocessor">#if DBG</span>
07883 <span class="preprocessor"></span>            <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a9">RtlpVerboseConvert</a> ) {
07884                 KdPrint((<span class="stringliteral">"Compare Child Ace: %ld "</span>, ChildAceIndex ));
07885             }
07886 <span class="preprocessor">#endif // DBG</span>
07887 <span class="preprocessor"></span>
07888             <span class="keywordflow">if</span> ( !<a class="code" href="../../d8/d6/sertl_8c.html#a23">RtlpCompareAces</a>( InheritedAce,
07889                                    ChildAce,
07890                                    OwnerSid,
07891                                    GroupSid ) ) {
07892 <span class="preprocessor">#if DBG</span>
07893 <span class="preprocessor"></span>                <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a9">RtlpVerboseConvert</a> ) {
07894                     KdPrint((<span class="stringliteral">"\n"</span> ));
07895                 }
07896 <span class="preprocessor">#endif // DBG</span>
07897 <span class="preprocessor"></span>                <span class="keywordflow">continue</span>;
07898             }
07899 <span class="preprocessor">#if DBG</span>
07900 <span class="preprocessor"></span>            <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a9">RtlpVerboseConvert</a> ) {
07901                 KdPrint((<span class="stringliteral">"\n"</span> ));
07902             }
07903 <span class="preprocessor">#endif // DBG</span>
07904 <span class="preprocessor"></span>
07905 
07906             <span class="comment">//</span>
07907             <span class="comment">// Match as many access bits in the INH ACE as possible.</span>
07908             <span class="comment">//</span>
07909             <span class="comment">// Don't pay any attention to whether the bits have been previously matched</span>
07910             <span class="comment">// in the CHILD ACE.  To do so, would imply that there is a one-to-one</span>
07911             <span class="comment">// correspondance between bits in the INH ACL and Child ACL.  Unfortunately,</span>
07912             <span class="comment">// ACL editors feel free to compress out duplicate bits in both</span>
07913             <span class="comment">// the CHILD ACL and PARENT ACL as they see fit.</span>
07914             <span class="comment">//</span>
07915 
07916             InheritedEffectiveMask &amp;= ~ChildAceInfo[ChildAceIndex].OriginalEffectiveMask;
07917             InheritedContainerInheritMask &amp;= ~ChildAceInfo[ChildAceIndex].OriginalContainerInheritMask;
07918             InheritedObjectInheritMask &amp;= ~ChildAceInfo[ChildAceIndex].OriginalObjectInheritMask;
07919 
07920 <span class="preprocessor">#if DBG</span>
07921 <span class="preprocessor"></span>            <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a9">RtlpVerboseConvert</a> ) {
07922                 KdPrint((<span class="stringliteral">"New   INH MASKs %ld %8.8lX %8.8lX %8.8lX\n"</span>, InheritedAceIndex, InheritedEffectiveMask, InheritedContainerInheritMask, InheritedObjectInheritMask ));
07923             }
07924 <span class="preprocessor">#endif // DBG</span>
07925 <span class="preprocessor"></span>
07926 
07927             <span class="comment">//</span>
07928             <span class="comment">// Match as many access bits in the child ACE as possible.</span>
07929             <span class="comment">//</span>
07930             <span class="comment">// Same reasoning as above.</span>
07931             <span class="comment">//</span>
07932 
07933             ChildAceInfo[ChildAceIndex].EffectiveMask &amp;= ~OriginalInheritedEffectiveMask;
07934             ChildAceInfo[ChildAceIndex].ContainerInheritMask &amp;= ~OriginalInheritedContainerInheritMask;
07935             ChildAceInfo[ChildAceIndex].ObjectInheritMask &amp;= ~OriginalInheritedObjectInheritMask;
07936 
07937 <span class="preprocessor">#if DBG</span>
07938 <span class="preprocessor"></span>            <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a9">RtlpVerboseConvert</a> ) {
07939                 KdPrint((<span class="stringliteral">"New Child MASKs %ld %8.8lX %8.8lX %8.8lX\n"</span>, ChildAceIndex, ChildAceInfo[ChildAceIndex].EffectiveMask, ChildAceInfo[ChildAceIndex].ContainerInheritMask, ChildAceInfo[ChildAceIndex].ObjectInheritMask ));
07940             }
07941 <span class="preprocessor">#endif // DBG</span>
07942 <span class="preprocessor"></span>
07943         }
07944 
07945 
07946         <span class="comment">//</span>
07947         <span class="comment">// If we couldn't process this inherited ACE,</span>
07948         <span class="comment">//  then the child ACL wasn't inherited.</span>
07949         <span class="comment">//</span>
07950 
07951         <span class="keywordflow">if</span> ( (InheritedEffectiveMask | InheritedContainerInheritMask | InheritedObjectInheritMask) != 0 ) {
07952             *NewGenericControl |= SEP_ACL_PROTECTED;
07953 <span class="preprocessor">#if DBG</span>
07954 <span class="preprocessor"></span>            <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a9">RtlpVerboseConvert</a> ) {
07955                 KdPrint((<span class="stringliteral">"INH ACE not completely matched: %ld %8.8lX %8.8lX %8.8lX\n"</span>, InheritedAceIndex, InheritedEffectiveMask, InheritedContainerInheritMask, InheritedObjectInheritMask ));
07956             }
07957 <span class="preprocessor">#endif // DBG</span>
07958 <span class="preprocessor"></span>            <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
07959             <span class="keywordflow">goto</span> Cleanup;
07960         }
07961 
07962 
07963     }
07964 
07965     <span class="comment">//</span>
07966     <span class="comment">// ASSERT: All of the inherited ACEs have been processed.</span>
07967     <span class="comment">//</span>
07968 
07969     <span class="comment">//</span>
07970     <span class="comment">// Loop through the Child ACL ensuring we can build a valid auto inherited ACL</span>
07971     <span class="comment">//</span>
07972 
07973     InheritedAllowFound = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
07974     InheritedDenyFound = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
07975     NonInheritedAclSize = 0;
07976     <span class="keywordflow">for</span> (ChildAceIndex = 0, ChildAce = <a class="code" href="../../d4/d1/rtdmpsec_8c.html#a1">FirstAce</a>(ChildAcl);
07977          ChildAceIndex &lt; ChildAcl-&gt;AceCount;
07978          ChildAceIndex += 1, ChildAce = <a class="code" href="../../d4/d1/rtdmpsec_8c.html#a2">NextAce</a>(ChildAce)) {
07979 
07980         ACCESS_MASK ResultantMask;
07981 
07982         <span class="comment">//</span>
07983         <span class="comment">// Any Child ACE access bits not eliminated above required than an</span>
07984         <span class="comment">//  explicit non-inherited ACE by built.  That ACE will have an</span>
07985         <span class="comment">//  access mask that is the combined access mask of the unmatched bit</span>
07986         <span class="comment">//  in the effective, container inherit, and object inherit categories.</span>
07987         <span class="comment">//  Even though, the combined mask may include access bits not absolutely</span>
07988         <span class="comment">//  required (since they were already inherited), this strategy prevents</span>
07989         <span class="comment">//  us from having to build multiple ACEs (one for each category) for this</span>
07990         <span class="comment">//  single ACE.</span>
07991         <span class="comment">//</span>
07992 
07993         ResultantMask =
07994             ChildAceInfo[ChildAceIndex].EffectiveMask |
07995             ChildAceInfo[ChildAceIndex].ContainerInheritMask |
07996             ChildAceInfo[ChildAceIndex].ObjectInheritMask;
07997 
07998 
07999         <span class="comment">//</span>
08000         <span class="comment">// Handle an inherited ACE</span>
08001         <span class="comment">//</span>
08002 
08003         <span class="keywordflow">if</span> ( ResultantMask == 0 ) {
08004 
08005             <span class="comment">//</span>
08006             <span class="comment">// Keep track of whether inherited "allow" and "deny" ACEs are found.</span>
08007             <span class="comment">//</span>
08008 
08009             <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a7">RtlBaseAceType</a>[ChildAce-&gt;Header.AceType] == ACCESS_ALLOWED_ACE_TYPE ) {
08010                 InheritedAllowFound = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
08011             }
08012 
08013             <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a7">RtlBaseAceType</a>[ChildAce-&gt;Header.AceType] == ACCESS_DENIED_ACE_TYPE ) {
08014                 InheritedDenyFound = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
08015             }
08016 
08017         <span class="comment">//</span>
08018         <span class="comment">// Handle a non-inherited ACE</span>
08019         <span class="comment">//</span>
08020 
08021         } <span class="keywordflow">else</span> {
08022 
08023             <span class="comment">//</span>
08024             <span class="comment">// Keep a running tab of the size of the non-inherited ACEs.</span>
08025             <span class="comment">//</span>
08026 
08027             NonInheritedAclSize += ChildAce-&gt;Header.AceSize;
08028 
08029             <span class="comment">//</span>
08030             <span class="comment">// Since non-inherited ACEs will be moved to the front of the ACL,</span>
08031             <span class="comment">//  we have to be careful that we don't move a deny ACE in front of a</span>
08032             <span class="comment">//  previously found inherited allow ACE (and vice-versa).  To do so would</span>
08033             <span class="comment">//  change the semantics of the ACL.</span>
08034             <span class="comment">//</span>
08035 
08036             <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a7">RtlBaseAceType</a>[ChildAce-&gt;Header.AceType] == ACCESS_ALLOWED_ACE_TYPE &amp;&amp; InheritedDenyFound ) {
08037                 *NewGenericControl |= SEP_ACL_PROTECTED;
08038 <span class="preprocessor">#if DBG</span>
08039 <span class="preprocessor"></span>                <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a9">RtlpVerboseConvert</a> ) {
08040                     KdPrint((<span class="stringliteral">"Previous deny found Child ACE: %ld\n"</span>, ChildAceIndex ));
08041                 }
08042 <span class="preprocessor">#endif // DBG</span>
08043 <span class="preprocessor"></span>                <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
08044                 <span class="keywordflow">goto</span> Cleanup;
08045             }
08046 
08047             <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a7">RtlBaseAceType</a>[ChildAce-&gt;Header.AceType] == ACCESS_DENIED_ACE_TYPE &amp;&amp; InheritedAllowFound ) {
08048                 *NewGenericControl |= SEP_ACL_PROTECTED;
08049 <span class="preprocessor">#if DBG</span>
08050 <span class="preprocessor"></span>                <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a9">RtlpVerboseConvert</a> ) {
08051                     KdPrint((<span class="stringliteral">"Previous allow found Child ACE: %ld\n"</span>, ChildAceIndex ));
08052                 }
08053 <span class="preprocessor">#endif // DBG</span>
08054 <span class="preprocessor"></span>                <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
08055                 <span class="keywordflow">goto</span> Cleanup;
08056             }
08057 
08058         }
08059 
08060     }
08061 
08062     <span class="comment">//</span>
08063     <span class="comment">// The resultant ACL is composed of the non-inherited ACEs followed by</span>
08064     <span class="comment">// the inherited ACE. The inherited ACEs are built by running the</span>
08065     <span class="comment">// inheritance algorithm over the Parent ACL.</span>
08066     <span class="comment">//</span>
08067     <span class="comment">// The Inherited ACL computed below is almost identical to InhertedAcl.</span>
08068     <span class="comment">// However, InheritedAcl didn't properly substitute the correct owner and</span>
08069     <span class="comment">// group SID.</span>
08070     <span class="comment">//</span>
08071 
08072     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d8/d6/sertl_8c.html#a74">RtlpInheritAcl</a> (
08073                 ParentAcl,
08074                 <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,   <span class="comment">// No explicit child ACL</span>
08075                 0,      <span class="comment">// No Child Generic Control</span>
08076                 IsDirectoryObject,
08077                 <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,   <span class="comment">// AutoInherit the DACL</span>
08078                 <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,  <span class="comment">// Not default descriptor for object</span>
08079                 OwnerSid,   <span class="comment">// Subsitute a constant SID</span>
08080                 GroupSid,   <span class="comment">// Subsitute a constant SID</span>
08081                 OwnerSid,   <span class="comment">// Server Owner (Technically incorrect, but OK since we don't support compound ACEs)</span>
08082                 GroupSid,   <span class="comment">// Server Group</span>
08083                 GenericMapping,
08084                 <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,   <span class="comment">// Is a SACL</span>
08085                 ObjectType,
08086                 &amp;RealInheritedAcl,
08087                 &amp;AclExplicitlyAssigned,
08088                 &amp;GenericControl );
08089 
08090     <span class="keywordflow">if</span> ( !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>) ) {
08091 <span class="preprocessor">#if DBG</span>
08092 <span class="preprocessor"></span>        <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a9">RtlpVerboseConvert</a> ) {
08093             KdPrint((<span class="stringliteral">"Can't build real inherited ACL %lX\n"</span>, <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> ));
08094         }
08095 <span class="preprocessor">#endif // DBG</span>
08096 <span class="preprocessor"></span>        <span class="keywordflow">goto</span> Cleanup;
08097     }
08098 
08099 
08100 
08101     <span class="comment">//</span>
08102     <span class="comment">// Allocate a buffer for the inherited ACL</span>
08103     <span class="comment">//</span>
08104 
08105 <span class="preprocessor">#ifdef NTOS_KERNEL_RUNTIME</span>
08106 <span class="preprocessor"></span>    *NewAcl = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>(
08107                         <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>,
08108                         RealInheritedAcl-&gt;AclSize + NonInheritedAclSize,
08109                         'cAeS' );
08110 <span class="preprocessor">#else // NTOS_KERNEL_RUNTIME</span>
08111 <span class="preprocessor"></span>    *NewAcl = <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a0">RtlAllocateHeap</a>(
08112                         <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>,
08113                         <a class="code" href="../../d9/d2/ldrp_8h.html#a11">MAKE_TAG</a>(<a class="code" href="../../d9/d2/ldrp_8h.html#a17">SE_TAG</a>),
08114                         RealInheritedAcl-&gt;AclSize + NonInheritedAclSize );
08115 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
08116 <span class="preprocessor"></span>
08117     <span class="keywordflow">if</span> ( *NewAcl == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
08118         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_NO_MEMORY;
08119         <span class="keywordflow">goto</span> Cleanup;
08120     }
08121 
08122     <span class="comment">//</span>
08123     <span class="comment">// All non-inherited ACEs are copied first.</span>
08124     <span class="comment">// The inherited ACES are grabbed from real inherited ACL.</span>
08125     <span class="comment">//</span>
08126     <span class="comment">// Build an ACL Header.</span>
08127     <span class="comment">//</span>
08128 
08129     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d2/d4/acledit_8c.html#a6">RtlCreateAcl</a>( *NewAcl,
08130                            RealInheritedAcl-&gt;AclSize + NonInheritedAclSize,
08131                            <a class="code" href="../../d8/d6/sertl_8c.html#a1">max</a>( RealInheritedAcl-&gt;AclRevision, ChildAcl-&gt;AclRevision ) );
08132 
08133     <span class="keywordflow">if</span> ( !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>) ) {
08134 <span class="preprocessor">#if DBG</span>
08135 <span class="preprocessor"></span>        <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a9">RtlpVerboseConvert</a> ) {
08136             KdPrint((<span class="stringliteral">"Can't create final ACL %lX\n"</span>, <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> ));
08137         }
08138 <span class="preprocessor">#endif // DBG</span>
08139 <span class="preprocessor"></span>        <span class="comment">//</span>
08140         <span class="comment">// The only reason for failure would be if the combined ACL is too large.</span>
08141         <span class="comment">// So just create a protected ACL (better than a failure).</span>
08142         <span class="comment">//</span>
08143         *NewGenericControl |= SEP_ACL_PROTECTED;
08144         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
08145         <span class="keywordflow">goto</span> Cleanup;
08146     }
08147 
08148     <span class="comment">//</span>
08149     <span class="comment">// Copy the non-inherited ACES.</span>
08150     <span class="comment">//</span>
08151 
08152     Where = ((PUCHAR)(*NewAcl)) + <span class="keyword">sizeof</span>(ACL);
08153     <span class="keywordflow">for</span> (ChildAceIndex = 0, ChildAce = <a class="code" href="../../d4/d1/rtdmpsec_8c.html#a1">FirstAce</a>(ChildAcl);
08154          ChildAceIndex &lt; ChildAcl-&gt;AceCount;
08155          ChildAceIndex += 1, ChildAce = <a class="code" href="../../d4/d1/rtdmpsec_8c.html#a2">NextAce</a>(ChildAce)) {
08156 
08157         ACCESS_MASK ResultantMask;
08158 
08159         <span class="comment">//</span>
08160         <span class="comment">// Copy the non-inherited ACE from the Child only if there's a non-zero access mask.</span>
08161         <span class="comment">//</span>
08162 
08163         ResultantMask =
08164             ChildAceInfo[ChildAceIndex].EffectiveMask |
08165             ChildAceInfo[ChildAceIndex].ContainerInheritMask |
08166             ChildAceInfo[ChildAceIndex].ObjectInheritMask;
08167 
08168         <span class="keywordflow">if</span> ( ResultantMask != 0 ) {
08169             <a class="code" href="../../d4/d7/struct__KNOWN__ACE.html">PKNOWN_ACE</a> NewAce;
08170             ULONG GenericBitToTry;
08171 
08172             <span class="comment">//</span>
08173             <span class="comment">// Use the original ChildAce as the template.</span>
08174             <span class="comment">//</span>
08175 
08176             RtlCopyMemory( Where, ChildAce, ChildAce-&gt;Header.AceSize );
08177             NewAce = (<a class="code" href="../../d4/d7/struct__KNOWN__ACE.html">PKNOWN_ACE</a>)Where;
08178             NewAce-&gt;<a class="code" href="../../d4/d7/struct__KNOWN__ACE.html#o0">Header</a>.AceFlags &amp;= ~INHERITED_ACE;  <span class="comment">// Clear stray bits</span>
08179             Where += ChildAce-&gt;Header.AceSize;
08180 
08181             (*NewAcl)-&gt;AceCount ++;
08182 
08183             <span class="comment">//</span>
08184             <span class="comment">// The AccessMask on the ACE are those access bits that didn't get matched</span>
08185             <span class="comment">//  by inherited ACEs.</span>
08186             <span class="comment">//</span>
08187 
08188             NewAce-&gt;<a class="code" href="../../d4/d7/struct__KNOWN__ACE.html#o1">Mask</a> = ChildAce-&gt;Mask &amp; ResultantMask;
08189             ResultantMask &amp;= ~ChildAce-&gt;Mask;
08190 <span class="preprocessor">#if DBG</span>
08191 <span class="preprocessor"></span>            <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a9">RtlpVerboseConvert</a> ) {
08192                 KdPrint((<span class="stringliteral">"Original non-inherited: %ld %8.8lX %8.8lX\n"</span>, ChildAceIndex, NewAce-&gt;<a class="code" href="../../d4/d7/struct__KNOWN__ACE.html#o1">Mask</a>, ResultantMask ));
08193             }
08194 <span class="preprocessor">#endif // DBG</span>
08195 <span class="preprocessor"></span>
08196             <span class="comment">//</span>
08197             <span class="comment">// Map any remaining bits back to generic access bits.</span>
08198             <span class="comment">// Doing so might expand the ResultantMask to beyond what was computed above.</span>
08199             <span class="comment">// Doing so will never expand the computed ACE to beyond what the original</span>
08200             <span class="comment">//  ChildAce granted.</span>
08201             <span class="comment">//</span>
08202 
08203             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( GENERIC_WRITE == (GENERIC_READ &gt;&gt; 1));
08204             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( GENERIC_EXECUTE == (GENERIC_WRITE &gt;&gt; 1));
08205             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( GENERIC_ALL == (GENERIC_EXECUTE &gt;&gt; 1));
08206 
08207             GenericBitToTry = GENERIC_READ;
08208 
08209             <span class="keywordflow">while</span> ( ResultantMask &amp;&amp; GenericBitToTry &gt;= GENERIC_ALL ) {
08210 
08211                 <span class="comment">//</span>
08212                 <span class="comment">// Only map generic bits that are in the ChildAce.</span>
08213                 <span class="comment">//</span>
08214 
08215                 <span class="keywordflow">if</span> ( GenericBitToTry &amp; ChildAce-&gt;Mask ) {
08216                     ACCESS_MASK GenericMask;
08217 
08218                     <span class="comment">//</span>
08219                     <span class="comment">// Compute the real access mask corresponding to the Generic bit.</span>
08220                     <span class="comment">//</span>
08221 
08222                     GenericMask = GenericBitToTry;
08223                     <a class="code" href="../../d8/d6/sertl_8c.html#a70">RtlMapGenericMask</a>( &amp;GenericMask, GenericMapping );
08224 
08225                     <span class="comment">//</span>
08226                     <span class="comment">// If the current generic bit matches any of the bits remaining,</span>
08227                     <span class="comment">//  set the generic bit in the current ACE.</span>
08228                     <span class="comment">//</span>
08229 
08230                     <span class="keywordflow">if</span> ( (ResultantMask &amp; GenericMask) != 0 ) {
08231                         NewAce-&gt;<a class="code" href="../../d4/d7/struct__KNOWN__ACE.html#o1">Mask</a> |= GenericBitToTry;
08232                         ResultantMask &amp;= ~GenericMask;
08233                     }
08234 <span class="preprocessor">#if DBG</span>
08235 <span class="preprocessor"></span>                    <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a9">RtlpVerboseConvert</a> ) {
08236                         KdPrint((<span class="stringliteral">"Generic  non-inherited: %ld %8.8lX %8.8lX\n"</span>, ChildAceIndex, NewAce-&gt;<a class="code" href="../../d4/d7/struct__KNOWN__ACE.html#o1">Mask</a>, ResultantMask ));
08237                     }
08238 <span class="preprocessor">#endif // DBG</span>
08239 <span class="preprocessor"></span>                }
08240 
08241                 <span class="comment">//</span>
08242                 <span class="comment">// Try the next Generic bit.</span>
08243                 <span class="comment">//</span>
08244 
08245                 GenericBitToTry &gt;&gt;= 1;
08246             }
08247 
08248 
08249             <span class="comment">//</span>
08250             <span class="comment">// This is really an internal error, but press on regardless.</span>
08251             <span class="comment">//</span>
08252 
08253             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(ResultantMask == 0 );
08254             NewAce-&gt;<a class="code" href="../../d4/d7/struct__KNOWN__ACE.html#o1">Mask</a> |= ResultantMask;
08255 <span class="preprocessor">#if DBG</span>
08256 <span class="preprocessor"></span>            <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a9">RtlpVerboseConvert</a> ) {
08257                 KdPrint((<span class="stringliteral">"Final    non-inherited: %ld %8.8lX %8.8lX\n"</span>, ChildAceIndex, NewAce-&gt;<a class="code" href="../../d4/d7/struct__KNOWN__ACE.html#o1">Mask</a>, ResultantMask ));
08258             }
08259 <span class="preprocessor">#endif // DBG</span>
08260 <span class="preprocessor"></span>
08261         }
08262     }
08263 
08264     <span class="comment">//</span>
08265     <span class="comment">// Copy the inherited ACES.</span>
08266     <span class="comment">//  Simply copy computed Inherited ACL.</span>
08267     <span class="comment">//</span>
08268 
08269     RtlCopyMemory( Where,
08270                    <a class="code" href="../../d4/d1/rtdmpsec_8c.html#a1">FirstAce</a>(RealInheritedAcl),
08271                    RealInheritedAcl-&gt;AclSize - (ULONG)(((PUCHAR)<a class="code" href="../../d4/d1/rtdmpsec_8c.html#a1">FirstAce</a>(RealInheritedAcl)) - (PUCHAR)RealInheritedAcl));
08272     Where += RealInheritedAcl-&gt;AclSize - (ULONG)(((PUCHAR)<a class="code" href="../../d4/d1/rtdmpsec_8c.html#a1">FirstAce</a>(RealInheritedAcl)) - (PUCHAR)RealInheritedAcl);
08273 
08274     (*NewAcl)-&gt;AceCount += RealInheritedAcl-&gt;AceCount;
08275     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( (*NewAcl)-&gt;AclSize == Where - (PUCHAR)(*NewAcl) );
08276 
08277 
08278     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
08279 Cleanup:
08280 
08281     <span class="comment">//</span>
08282     <span class="comment">// If successful,</span>
08283     <span class="comment">//  build the resultant autoinherited ACL.</span>
08284     <span class="comment">//</span>
08285 
08286     <span class="keywordflow">if</span> ( <a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>) ) {
08287 
08288         <span class="comment">//</span>
08289         <span class="comment">// If the Child ACL is protected,</span>
08290         <span class="comment">//  just build it as a copy of the original ACL</span>
08291         <span class="comment">//</span>
08292 
08293         <span class="keywordflow">if</span> ( *NewGenericControl &amp; SEP_ACL_PROTECTED ) {
08294 
08295             <span class="comment">//</span>
08296             <span class="comment">// If we've already allocated a new ACL (and couldn't finish it for some reason),</span>
08297             <span class="comment">//  free it.</span>
08298 
08299             <span class="keywordflow">if</span> ( *NewAcl != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
08300 <span class="preprocessor">#ifdef NTOS_KERNEL_RUNTIME</span>
08301 <span class="preprocessor"></span>                <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( *NewAcl );
08302 <span class="preprocessor">#else // NTOS_KERNEL_RUNTIME</span>
08303 <span class="preprocessor"></span>                <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, 0, *NewAcl );
08304 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
08305 <span class="preprocessor"></span>                *NewAcl = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
08306             }
08307 
08308             <span class="comment">//</span>
08309             <span class="comment">// Allocate a buffer for the protected ACL.</span>
08310             <span class="comment">//</span>
08311 
08312 <span class="preprocessor">#ifdef NTOS_KERNEL_RUNTIME</span>
08313 <span class="preprocessor"></span>            *NewAcl = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>(
08314                                 <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>,
08315                                 ChildAcl-&gt;AclSize,
08316                                 'cAeS' );
08317 <span class="preprocessor">#else // NTOS_KERNEL_RUNTIME</span>
08318 <span class="preprocessor"></span>            *NewAcl = <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a0">RtlAllocateHeap</a>(
08319                                 <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>,
08320                                 <a class="code" href="../../d9/d2/ldrp_8h.html#a11">MAKE_TAG</a>(<a class="code" href="../../d9/d2/ldrp_8h.html#a17">SE_TAG</a>),
08321                                 ChildAcl-&gt;AclSize );
08322 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
08323 <span class="preprocessor"></span>
08324             <span class="keywordflow">if</span> ( *NewAcl == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
08325                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_NO_MEMORY;
08326             } <span class="keywordflow">else</span> {
08327                 RtlCopyMemory( *NewAcl, ChildAcl, ChildAcl-&gt;AclSize );
08328             }
08329         }
08330 
08331     }
08332 
08333     <span class="keywordflow">if</span> ( ChildAceInfo != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
08334 <span class="preprocessor">#ifdef NTOS_KERNEL_RUNTIME</span>
08335 <span class="preprocessor"></span>        <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( ChildAceInfo );
08336 <span class="preprocessor">#else // NTOS_KERNEL_RUNTIME</span>
08337 <span class="preprocessor"></span>        <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, 0, ChildAceInfo );
08338 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
08339 <span class="preprocessor"></span>    }
08340 
08341     <span class="keywordflow">if</span> ( InheritedAcl != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
08342 <span class="preprocessor">#ifdef NTOS_KERNEL_RUNTIME</span>
08343 <span class="preprocessor"></span>        <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( InheritedAcl );
08344 <span class="preprocessor">#else // NTOS_KERNEL_RUNTIME</span>
08345 <span class="preprocessor"></span>        <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, 0, InheritedAcl );
08346 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
08347 <span class="preprocessor"></span>    }
08348 
08349     <span class="keywordflow">if</span> ( RealInheritedAcl != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
08350 <span class="preprocessor">#ifdef NTOS_KERNEL_RUNTIME</span>
08351 <span class="preprocessor"></span>        <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( RealInheritedAcl );
08352 <span class="preprocessor">#else // NTOS_KERNEL_RUNTIME</span>
08353 <span class="preprocessor"></span>        <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, 0, RealInheritedAcl );
08354 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
08355 <span class="preprocessor"></span>    }
08356 
08357     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
08358 }
08359 
08360 
08361 BOOLEAN
<a name="l08362"></a><a class="code" href="../../d8/d6/sertl_8c.html#a26">08362</a> <a class="code" href="../../d8/d6/sertl_8c.html#a26">RtlpIsDuplicateAce</a>(
08363     IN PACL Acl,
08364     IN <a class="code" href="../../d4/d7/struct__KNOWN__ACE.html">PKNOWN_ACE</a> NewAce,
08365     IN GUID *ObjectType OPTIONAL
08366     )
08367 
08368 <span class="comment">/*++</span>
08369 <span class="comment"></span>
08370 <span class="comment">Routine Description:</span>
08371 <span class="comment"></span>
08372 <span class="comment">    This routine determine if an ACE is a duplicate of an ACE already in an</span>
08373 <span class="comment">    ACL.  If so, the NewAce can be removed from the end of the ACL.</span>
08374 <span class="comment"></span>
08375 <span class="comment">    This routine currently only detects duplicate version 4 ACEs.  If the</span>
08376 <span class="comment">    ACE isn't version 4, the ACE will be declared to be a non-duplicate.</span>
08377 <span class="comment"></span>
08378 <span class="comment">    This routine only detects duplicate INHERTED ACEs.</span>
08379 <span class="comment"></span>
08380 <span class="comment">Arguments:</span>
08381 <span class="comment"></span>
08382 <span class="comment">    Acl - Existing ACL</span>
08383 <span class="comment"></span>
08384 <span class="comment">    NewAce - Ace to determine if it is already in Acl.</span>
08385 <span class="comment">        NewAce is expected to be the last ACE in "Acl".</span>
08386 <span class="comment"></span>
08387 <span class="comment">    ObjectType - GUID of the object type represented by Acl.  If the object</span>
08388 <span class="comment">        has no GUID associated with it, then this argument is</span>
08389 <span class="comment">        specified as NULL.</span>
08390 <span class="comment"></span>
08391 <span class="comment">Return Value:</span>
08392 <span class="comment"></span>
08393 <span class="comment">    TRUE - NewAce is a duplicate of another ACE on the Acl</span>
08394 <span class="comment">    FALSE - NewAce is NOT a duplicate of another ACE on the Acl</span>
08395 <span class="comment"></span>
08396 <span class="comment">--*/</span>
08397 
08398 {
08399     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
08400     BOOLEAN RetVal = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
08401 
08402     LONG AceIndex;
08403 
08404     ACCESS_MASK NewAceContainerInheritMask;
08405     ACCESS_MASK NewAceObjectInheritMask;
08406     ACCESS_MASK NewAceEffectiveMask;
08407 
08408     ACCESS_MASK LocalMask;
08409 
08410     <a class="code" href="../../d4/d7/struct__KNOWN__ACE.html">PKNOWN_ACE</a> AceFromAcl;
08411 
08412     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
08413 
08414 
08415     <span class="comment">//</span>
08416     <span class="comment">// Ensure the passed in ACE is one this routine understands</span>
08417     <span class="comment">//</span>
08418 
08419     <span class="keywordflow">if</span> ( !IsV4AceType(NewAce) || IsCompoundAceType(NewAce)) {
08420 <span class="preprocessor">#if DBG</span>
08421 <span class="preprocessor"></span>        <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a9">RtlpVerboseConvert</a> ) {
08422             KdPrint((<span class="stringliteral">"New Ace type (%ld) not known\n"</span>, NewAce-&gt;Header.AceType ));
08423         }
08424 <span class="preprocessor">#endif // DBG</span>
08425 <span class="preprocessor"></span>        RetVal = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
08426         <span class="keywordflow">goto</span> Cleanup;
08427     }
08428 
08429     <span class="comment">//</span>
08430     <span class="comment">// This routine only works for ACEs marked as INHERITED.</span>
08431     <span class="comment">//</span>
08432 
08433     <span class="keywordflow">if</span> ( (NewAce-&gt;Header.AceFlags &amp; INHERITED_ACE ) == 0 ) {
08434 <span class="preprocessor">#if DBG</span>
08435 <span class="preprocessor"></span>        <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a9">RtlpVerboseConvert</a> ) {
08436             KdPrint((<span class="stringliteral">"New Ace type isn't inherited\n"</span> ));
08437         }
08438 <span class="preprocessor">#endif // DBG</span>
08439 <span class="preprocessor"></span>        RetVal = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
08440         <span class="keywordflow">goto</span> Cleanup;
08441     }
08442 
08443 
08444     <span class="comment">//</span>
08445     <span class="comment">// Break the new ACE into its component parts.</span>
08446     <span class="comment">//</span>
08447     <span class="comment">// All V4 aces have an access mask in the same location.</span>
08448     <span class="comment">//</span>
08449     LocalMask = ((<a class="code" href="../../d4/d7/struct__KNOWN__ACE.html">PKNOWN_ACE</a>)(NewAce))-&gt;Mask;
08450 
08451     <span class="keywordflow">if</span> ( NewAce-&gt;Header.AceFlags &amp; CONTAINER_INHERIT_ACE ) {
08452         NewAceContainerInheritMask = LocalMask;
08453     } <span class="keywordflow">else</span> {
08454         NewAceContainerInheritMask = 0;
08455     }
08456 
08457     <span class="keywordflow">if</span> ( NewAce-&gt;Header.AceFlags &amp; OBJECT_INHERIT_ACE ) {
08458         NewAceObjectInheritMask = LocalMask;
08459     } <span class="keywordflow">else</span> {
08460         NewAceObjectInheritMask = 0;
08461     }
08462 
08463     <span class="keywordflow">if</span> ( (NewAce-&gt;Header.AceFlags &amp; INHERIT_ONLY_ACE) == 0 ) {
08464         NewAceEffectiveMask = LocalMask;
08465     } <span class="keywordflow">else</span> {
08466         NewAceEffectiveMask = 0;
08467     }
08468 <span class="preprocessor">#if DBG</span>
08469 <span class="preprocessor"></span>    <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a9">RtlpVerboseConvert</a> ) {
08470         KdPrint((<span class="stringliteral">"Starting MASKs:  %8.8lX %8.8lX %8.8lX"</span>, NewAceEffectiveMask, NewAceContainerInheritMask, NewAceObjectInheritMask ));
08471     }
08472 <span class="preprocessor">#endif // DBG</span>
08473 <span class="preprocessor"></span>
08474 
08475 
08476 
08477     <span class="comment">//</span>
08478     <span class="comment">// Walk through the ACL one ACE at a time.</span>
08479     <span class="comment">//</span>
08480 
08481     <span class="keywordflow">for</span> (AceIndex = 0, AceFromAcl = <a class="code" href="../../d4/d1/rtdmpsec_8c.html#a1">FirstAce</a>(Acl);
08482          AceIndex &lt; Acl-&gt;AceCount-1;    <span class="comment">// NewAce is the last ACE</span>
08483          AceIndex += 1, AceFromAcl = <a class="code" href="../../d4/d1/rtdmpsec_8c.html#a2">NextAce</a>(AceFromAcl)) {
08484 
08485 
08486         <span class="comment">//</span>
08487         <span class="comment">// If the ACE isn't a valid version 4 ACE,</span>
08488         <span class="comment">//  this isn't an ACE we're interested in handling.</span>
08489         <span class="comment">//</span>
08490 
08491         <span class="keywordflow">if</span> ( !IsV4AceType(AceFromAcl) || IsCompoundAceType(AceFromAcl)) {
08492             <span class="keywordflow">continue</span>;
08493         }
08494 
08495         <span class="comment">//</span>
08496         <span class="comment">// This routine only works for ACEs marked as INHERITED.</span>
08497         <span class="comment">//</span>
08498 
08499         <span class="keywordflow">if</span> ( (AceFromAcl-&gt;Header.AceFlags &amp; INHERITED_ACE ) == 0 ) {
08500             <span class="keywordflow">continue</span>;
08501         }
08502 
08503 
08504         <span class="comment">//</span>
08505         <span class="comment">// Compare the Ace from the ACL with the New ACE</span>
08506         <span class="comment">//</span>
08507         <span class="comment">//  Don't stop simply because we've matched once.</span>
08508         <span class="comment">//  Multiple ACEs in the one ACL may have been condensed into a single ACE</span>
08509         <span class="comment">//  in the other ACL in any combination (by any of our friendly ACL editors).</span>
08510         <span class="comment">//</span>
08511 <span class="preprocessor">#if DBG</span>
08512 <span class="preprocessor"></span>        <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a9">RtlpVerboseConvert</a> ) {
08513             KdPrint((<span class="stringliteral">"Compare Ace: %ld "</span>, AceIndex ));
08514         }
08515 <span class="preprocessor">#endif // DBG</span>
08516 <span class="preprocessor"></span>
08517         <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a23">RtlpCompareAces</a>( AceFromAcl,
08518                               NewAce,
08519                               <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
08520                               <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) ) {
08521 
08522 
08523             <span class="comment">//</span>
08524             <span class="comment">// Match the bits from the current ACE with bits from the New ACE.</span>
08525             <span class="comment">//</span>
08526             <span class="comment">// All V4 aces have an access mask in the same location.</span>
08527             <span class="comment">//</span>
08528 
08529             LocalMask = ((<a class="code" href="../../d4/d7/struct__KNOWN__ACE.html">PKNOWN_ACE</a>)(AceFromAcl))-&gt;Mask;
08530 
08531             <span class="keywordflow">if</span> ( AceFromAcl-&gt;Header.AceFlags &amp; CONTAINER_INHERIT_ACE ) {
08532                 NewAceContainerInheritMask &amp;= ~LocalMask;
08533             }
08534 
08535             <span class="keywordflow">if</span> ( AceFromAcl-&gt;Header.AceFlags &amp; OBJECT_INHERIT_ACE ) {
08536                 NewAceObjectInheritMask &amp;= ~LocalMask;
08537             }
08538 
08539             <span class="keywordflow">if</span> ( (AceFromAcl-&gt;Header.AceFlags &amp; INHERIT_ONLY_ACE) == 0 ) {
08540                 NewAceEffectiveMask &amp;= ~LocalMask;
08541             }
08542 
08543 <span class="preprocessor">#if DBG</span>
08544 <span class="preprocessor"></span>            <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a9">RtlpVerboseConvert</a> ) {
08545                 KdPrint((<span class="stringliteral">"Remaining MASKs:  %8.8lX %8.8lX %8.8lX"</span>, NewAceEffectiveMask, NewAceContainerInheritMask, NewAceObjectInheritMask ));
08546             }
08547 <span class="preprocessor">#endif // DBG</span>
08548 <span class="preprocessor"></span>
08549             <span class="comment">//</span>
08550             <span class="comment">// If all bits have been matched in the New Ace,</span>
08551             <span class="comment">//  then this is a duplicate ACE.</span>
08552             <span class="comment">//</span>
08553 
08554             <span class="keywordflow">if</span> ( (NewAceEffectiveMask | NewAceContainerInheritMask | NewAceObjectInheritMask) == 0 ) {
08555 <span class="preprocessor">#if DBG</span>
08556 <span class="preprocessor"></span>                <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a9">RtlpVerboseConvert</a> ) {
08557                     KdPrint((<span class="stringliteral">"\n"</span>));
08558                 }
08559 <span class="preprocessor">#endif // DBG</span>
08560 <span class="preprocessor"></span>                RetVal = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
08561                 <span class="keywordflow">goto</span> Cleanup;
08562             }
08563         }
08564 <span class="preprocessor">#if DBG</span>
08565 <span class="preprocessor"></span>        <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d6/sertl_8c.html#a9">RtlpVerboseConvert</a> ) {
08566               KdPrint((<span class="stringliteral">"\n"</span>));
08567         }
08568 <span class="preprocessor">#endif // DBG</span>
08569 <span class="preprocessor"></span>
08570 
08571     }
08572 
08573     <span class="comment">//</span>
08574     <span class="comment">// All of the ACEs of the ACL have been processed.</span>
08575     <span class="comment">//</span>
08576     <span class="comment">// We haven't matched all of the bits in the New Ace so this is not a duplicate ACE.</span>
08577     <span class="comment">//</span>
08578 
08579     RetVal = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
08580 Cleanup:
08581 
08582     <span class="keywordflow">return</span> RetVal;
08583 
08584 }
08585 
08586 
08587 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l08588"></a><a class="code" href="../../d8/d6/sertl_8c.html#a27">08588</a> <a class="code" href="../../d8/d6/sertl_8c.html#a27">RtlpCreateServerAcl</a>(
08589     IN PACL Acl,
08590     IN BOOLEAN AclUntrusted,
08591     IN PSID ServerSid,
08592     OUT PACL *ServerAcl,
08593     OUT BOOLEAN *ServerAclAllocated
08594     )
08595 
08596 <span class="comment">/*++</span>
08597 <span class="comment"></span>
08598 <span class="comment">Routine Description:</span>
08599 <span class="comment"></span>
08600 <span class="comment">    This routine takes an ACL and converts it into a server ACL.</span>
08601 <span class="comment">    Currently, that means converting all of the GRANT ACEs into</span>
08602 <span class="comment">    Compount Grants, and if necessary sanitizing any Compound</span>
08603 <span class="comment">    Grants that are encountered.</span>
08604 <span class="comment"></span>
08605 <span class="comment">Arguments:</span>
08606 <span class="comment"></span>
08607 <span class="comment"></span>
08608 <span class="comment"></span>
08609 <span class="comment">Return Value:</span>
08610 <span class="comment"></span>
08611 <span class="comment"></span>
08612 <span class="comment">--*/</span>
08613 
08614 {
08615     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> RequiredSize = <span class="keyword">sizeof</span>(ACL);
08616     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> AceSizeAdjustment;
08617     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> ServerSidSize;
08618     PACE_HEADER Ace;
08619     ULONG i;
08620     PVOID Target;
08621     PVOID AcePosition;
08622     PSID UntrustedSid;
08623     PSID ClientSid;
08624     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
08625 
08626     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
08627 
08628     <span class="keywordflow">if</span> (Acl == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
08629         *ServerAclAllocated = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
08630         *ServerAcl = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
08631         <span class="keywordflow">return</span>( STATUS_SUCCESS );
08632     }
08633 
08634     AceSizeAdjustment = <span class="keyword">sizeof</span>( KNOWN_COMPOUND_ACE ) - <span class="keyword">sizeof</span>( <a class="code" href="../../d4/d7/struct__KNOWN__ACE.html">KNOWN_ACE</a> );
08635     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <span class="keyword">sizeof</span>( KNOWN_COMPOUND_ACE ) &gt;= <span class="keyword">sizeof</span>( <a class="code" href="../../d4/d7/struct__KNOWN__ACE.html">KNOWN_ACE</a> ) );
08636 
08637     ServerSidSize = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)<a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>( ServerSid );
08638 
08639     <span class="comment">//</span>
08640     <span class="comment">// Do this in two passes.  First, determine how big the final</span>
08641     <span class="comment">// result is going to be, and then allocate the space and make</span>
08642     <span class="comment">// the changes.</span>
08643     <span class="comment">//</span>
08644 
08645     <span class="keywordflow">for</span> (i = 0, Ace = <a class="code" href="../../d4/d1/rtdmpsec_8c.html#a1">FirstAce</a>(Acl);
08646          i &lt; Acl-&gt;AceCount;
08647          i += 1, Ace = <a class="code" href="../../d4/d1/rtdmpsec_8c.html#a2">NextAce</a>(Ace)) {
08648 
08649         <span class="comment">//</span>
08650         <span class="comment">// If it's an ACCESS_ALLOWED_ACE_TYPE, we'll need to add in the</span>
08651         <span class="comment">// size of the Server SID.</span>
08652         <span class="comment">//</span>
08653 
08654         <span class="keywordflow">if</span> (Ace-&gt;AceType == ACCESS_ALLOWED_ACE_TYPE) {
08655 
08656             <span class="comment">//</span>
08657             <span class="comment">// Simply add the size of the new Server SID plus whatever</span>
08658             <span class="comment">// adjustment needs to be made to increase the size of the ACE.</span>
08659             <span class="comment">//</span>
08660 
08661             RequiredSize += ( ServerSidSize + AceSizeAdjustment );
08662 
08663         } <span class="keywordflow">else</span> {
08664 
08665             <span class="keywordflow">if</span> (AclUntrusted &amp;&amp; Ace-&gt;AceType == ACCESS_ALLOWED_COMPOUND_ACE_TYPE ) {
08666 
08667                 <span class="comment">//</span>
08668                 <span class="comment">// Since the Acl is untrusted, we don't care what is in the</span>
08669                 <span class="comment">// server SID, we're going to replace it.</span>
08670                 <span class="comment">//</span>
08671 
08672                 UntrustedSid = RtlCompoundAceServerSid( Ace );
08673                 <span class="keywordflow">if</span> ((<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)<a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>(UntrustedSid) &gt; ServerSidSize) {
08674                     RequiredSize += ((<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)<a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>(UntrustedSid) - ServerSidSize);
08675                 } <span class="keywordflow">else</span> {
08676                     RequiredSize += (ServerSidSize - (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)<a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>(UntrustedSid));
08677 
08678                 }
08679             }
08680         }
08681 
08682         RequiredSize += Ace-&gt;AceSize;
08683     }
08684 
08685 <span class="preprocessor">#ifdef NTOS_KERNEL_RUNTIME</span>
08686 <span class="preprocessor"></span>    (*ServerAcl) = (PACL)<a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>, RequiredSize, 'cAeS' );
08687 <span class="preprocessor">#else // NTOS_KERNEL_RUNTIME</span>
08688 <span class="preprocessor"></span>    (*ServerAcl) = (PACL)<a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a0">RtlAllocateHeap</a>( RtlProcessHeap(), <a class="code" href="../../d9/d2/ldrp_8h.html#a11">MAKE_TAG</a>( <a class="code" href="../../d9/d2/ldrp_8h.html#a17">SE_TAG</a> ), RequiredSize );
08689 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
08690 <span class="preprocessor"></span>
08691     <span class="keywordflow">if</span> ((*ServerAcl) == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
08692         <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
08693     }
08694 
08695     <span class="comment">//</span>
08696     <span class="comment">// Mark as allocated so caller knows to free it.</span>
08697     <span class="comment">//</span>
08698 
08699     *ServerAclAllocated = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
08700 
08701     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d2/d4/acledit_8c.html#a6">RtlCreateAcl</a>( (*ServerAcl), RequiredSize, ACL_REVISION3 );
08702     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> ));
08703 
08704     <span class="keywordflow">for</span> (i = 0, Ace = <a class="code" href="../../d4/d1/rtdmpsec_8c.html#a1">FirstAce</a>(Acl), Target=<a class="code" href="../../d4/d1/rtdmpsec_8c.html#a1">FirstAce</a>( *ServerAcl );
08705          i &lt; Acl-&gt;AceCount;
08706          i += 1, Ace = <a class="code" href="../../d4/d1/rtdmpsec_8c.html#a2">NextAce</a>(Ace)) {
08707 
08708         <span class="comment">//</span>
08709         <span class="comment">// If it's an ACCESS_ALLOWED_ACE_TYPE, convert to a Server ACE.</span>
08710         <span class="comment">//</span>
08711 
08712         <span class="keywordflow">if</span> (Ace-&gt;AceType == ACCESS_ALLOWED_ACE_TYPE ||
08713            (AclUntrusted &amp;&amp; Ace-&gt;AceType == ACCESS_ALLOWED_COMPOUND_ACE_TYPE )) {
08714 
08715             AcePosition = Target;
08716 
08717             <span class="keywordflow">if</span> (Ace-&gt;AceType == ACCESS_ALLOWED_ACE_TYPE) {
08718                 ClientSid =  &amp;((<a class="code" href="../../d4/d7/struct__KNOWN__ACE.html">PKNOWN_ACE</a>)Ace)-&gt;SidStart;
08719             } <span class="keywordflow">else</span> {
08720                 ClientSid = RtlCompoundAceClientSid( Ace );
08721             }
08722 
08723             <span class="comment">//</span>
08724             <span class="comment">// Copy up to the access mask.</span>
08725             <span class="comment">//</span>
08726 
08727             RtlCopyMemory(
08728                 Target,
08729                 Ace,
08730                 FIELD_OFFSET(<a class="code" href="../../d4/d1/rtdmpsec_8c.html#a3">KNOWN_ACE</a>, SidStart)
08731                 );
08732 
08733             <span class="comment">//</span>
08734             <span class="comment">// Now copy the correct Server SID</span>
08735             <span class="comment">//</span>
08736 
08737             Target = ((PCHAR)Target + (UCHAR)(FIELD_OFFSET(KNOWN_COMPOUND_ACE, SidStart)));
08738 
08739             RtlCopyMemory(
08740                 Target,
08741                 ServerSid,
08742                 <a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>(ServerSid)
08743                 );
08744 
08745             Target = ((PCHAR)Target + (UCHAR)<a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>(ServerSid));
08746 
08747             <span class="comment">//</span>
08748             <span class="comment">// Now copy in the correct client SID.  We can copy this right out of</span>
08749             <span class="comment">// the original ACE.</span>
08750             <span class="comment">//</span>
08751 
08752             RtlCopyMemory(
08753                 Target,
08754                 ClientSid,
08755                 <a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>(ClientSid)
08756                 );
08757 
08758             Target = ((PCHAR)Target + <a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>(ClientSid));
08759 
08760             <span class="comment">//</span>
08761             <span class="comment">// Set the size of the ACE accordingly</span>
08762             <span class="comment">//</span>
08763 
08764             ((PKNOWN_COMPOUND_ACE)AcePosition)-&gt;Header.AceSize =
08765                 (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)FIELD_OFFSET(KNOWN_COMPOUND_ACE, SidStart) +
08766                 (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)<a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>(ServerSid) +
08767                 (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)<a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>(ClientSid);
08768 
08769             <span class="comment">//</span>
08770             <span class="comment">// Set the type</span>
08771             <span class="comment">//</span>
08772 
08773             ((PKNOWN_COMPOUND_ACE)AcePosition)-&gt;Header.AceType = ACCESS_ALLOWED_COMPOUND_ACE_TYPE;
08774             ((PKNOWN_COMPOUND_ACE)AcePosition)-&gt;CompoundAceType = COMPOUND_ACE_IMPERSONATION;
08775 
08776         } <span class="keywordflow">else</span> {
08777 
08778             <span class="comment">//</span>
08779             <span class="comment">// Just copy the ACE as is.</span>
08780             <span class="comment">//</span>
08781 
08782             RtlCopyMemory( Target, Ace, Ace-&gt;AceSize );
08783 
08784             Target = ((PCHAR)Target + Ace-&gt;AceSize);
08785         }
08786     }
08787 
08788     (*ServerAcl)-&gt;AceCount = Acl-&gt;AceCount;
08789 
08790     <span class="keywordflow">return</span>( STATUS_SUCCESS );
08791 }
08792 
08793 <span class="preprocessor">#ifndef NTOS_KERNEL_RUNTIME</span>
08794 <span class="preprocessor"></span><a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l08795"></a><a class="code" href="../../d8/d6/sertl_8c.html#a28">08795</a> <a class="code" href="../../d8/d6/sertl_8c.html#a28">RtlpGetDefaultsSubjectContext</a>(
08796     HANDLE ClientToken,
08797     OUT PTOKEN_OWNER *OwnerInfo,
08798     OUT PTOKEN_PRIMARY_GROUP *GroupInfo,
08799     OUT PTOKEN_DEFAULT_DACL *DefaultDaclInfo,
08800     OUT PTOKEN_OWNER *ServerOwner,
08801     OUT PTOKEN_PRIMARY_GROUP *ServerGroup
08802     )
08803 {
08804     HANDLE <a class="code" href="../../d6/d0/ctaccess_8c.html#a31">PrimaryToken</a>;
08805     PVOID <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
08806     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
08807     ULONG ServerGroupInfoSize;
08808     ULONG ServerOwnerInfoSize;
08809     ULONG TokenDaclInfoSize;
08810     ULONG TokenGroupInfoSize;
08811     ULONG TokenOwnerInfoSize;
08812 
08813     BOOLEAN ClosePrimaryToken = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
08814 
08815     *OwnerInfo = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
08816     *GroupInfo = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
08817     *DefaultDaclInfo = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
08818     *ServerOwner = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
08819     *ServerGroup = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
08820 
08821     <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a> = RtlProcessHeap();
08822 
08823     <span class="comment">//</span>
08824     <span class="comment">// If the caller doesn't know the client token,</span>
08825     <span class="comment">//  simply don't return any information.</span>
08826     <span class="comment">//</span>
08827 
08828     <span class="keywordflow">if</span> ( <a class="code" href="../../d7/d0/ctlnpqos_8c.html#a16">ClientToken</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
08829         <span class="comment">//</span>
08830         <span class="comment">// Obtain the default owner from the client.</span>
08831         <span class="comment">//</span>
08832 
08833         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d3/tokenqry_8c.html#a0">NtQueryInformationToken</a>(
08834                      <a class="code" href="../../d7/d0/ctlnpqos_8c.html#a16">ClientToken</a>,                        <span class="comment">// Handle</span>
08835                      TokenOwner,                   <span class="comment">// TokenInformationClass</span>
08836                      <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,                         <span class="comment">// TokenInformation</span>
08837                      0,                            <span class="comment">// TokenInformationLength</span>
08838                      &amp;TokenOwnerInfoSize           <span class="comment">// ReturnLength</span>
08839                      );
08840 
08841         <span class="keywordflow">if</span> ( STATUS_BUFFER_TOO_SMALL != <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> ) {
08842             <span class="keywordflow">goto</span> Cleanup;
08843         }
08844 
08845         *OwnerInfo = <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a0">RtlAllocateHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, <a class="code" href="../../d9/d2/ldrp_8h.html#a11">MAKE_TAG</a>( <a class="code" href="../../d9/d2/ldrp_8h.html#a17">SE_TAG</a> ), TokenOwnerInfoSize );
08846 
08847         <span class="keywordflow">if</span> ( *OwnerInfo == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
08848             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_NO_MEMORY;
08849             <span class="keywordflow">goto</span> Cleanup;
08850         }
08851 
08852         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d3/tokenqry_8c.html#a0">NtQueryInformationToken</a>(
08853                      <a class="code" href="../../d7/d0/ctlnpqos_8c.html#a16">ClientToken</a>,                        <span class="comment">// Handle</span>
08854                      TokenOwner,                   <span class="comment">// TokenInformationClass</span>
08855                      *OwnerInfo,               <span class="comment">// TokenInformation</span>
08856                      TokenOwnerInfoSize,           <span class="comment">// TokenInformationLength</span>
08857                      &amp;TokenOwnerInfoSize           <span class="comment">// ReturnLength</span>
08858                      );
08859 
08860         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
08861             <span class="keywordflow">goto</span> Cleanup;
08862         }
08863 
08864         <span class="comment">//</span>
08865         <span class="comment">// Obtain the default group from the client token.</span>
08866         <span class="comment">//</span>
08867 
08868         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d3/tokenqry_8c.html#a0">NtQueryInformationToken</a>(
08869                      <a class="code" href="../../d7/d0/ctlnpqos_8c.html#a16">ClientToken</a>,                        <span class="comment">// Handle</span>
08870                      TokenPrimaryGroup,            <span class="comment">// TokenInformationClass</span>
08871                      *GroupInfo,                   <span class="comment">// TokenInformation</span>
08872                      0,                            <span class="comment">// TokenInformationLength</span>
08873                      &amp;TokenGroupInfoSize           <span class="comment">// ReturnLength</span>
08874                      );
08875 
08876         <span class="keywordflow">if</span> ( STATUS_BUFFER_TOO_SMALL != <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> ) {
08877             <span class="keywordflow">goto</span> Cleanup;
08878         }
08879 
08880         *GroupInfo = <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a0">RtlAllocateHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, <a class="code" href="../../d9/d2/ldrp_8h.html#a11">MAKE_TAG</a>( <a class="code" href="../../d9/d2/ldrp_8h.html#a17">SE_TAG</a> ), TokenGroupInfoSize );
08881 
08882         <span class="keywordflow">if</span> ( *GroupInfo == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
08883 
08884             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_NO_MEMORY;
08885             <span class="keywordflow">goto</span> Cleanup;
08886         }
08887 
08888         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d3/tokenqry_8c.html#a0">NtQueryInformationToken</a>(
08889                      <a class="code" href="../../d7/d0/ctlnpqos_8c.html#a16">ClientToken</a>,                  <span class="comment">// Handle</span>
08890                      TokenPrimaryGroup,            <span class="comment">// TokenInformationClass</span>
08891                      *GroupInfo,                   <span class="comment">// TokenInformation</span>
08892                      TokenGroupInfoSize,           <span class="comment">// TokenInformationLength</span>
08893                      &amp;TokenGroupInfoSize           <span class="comment">// ReturnLength</span>
08894                      );
08895 
08896         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
08897             <span class="keywordflow">goto</span> Cleanup;
08898         }
08899 
08900         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d3/tokenqry_8c.html#a0">NtQueryInformationToken</a>(
08901                      <a class="code" href="../../d7/d0/ctlnpqos_8c.html#a16">ClientToken</a>,                        <span class="comment">// Handle</span>
08902                      TokenDefaultDacl,             <span class="comment">// TokenInformationClass</span>
08903                      *DefaultDaclInfo,             <span class="comment">// TokenInformation</span>
08904                      0,                            <span class="comment">// TokenInformationLength</span>
08905                      &amp;TokenDaclInfoSize            <span class="comment">// ReturnLength</span>
08906                      );
08907 
08908         <span class="keywordflow">if</span> ( STATUS_BUFFER_TOO_SMALL != <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> ) {
08909             <span class="keywordflow">goto</span> Cleanup;
08910         }
08911 
08912         *DefaultDaclInfo = <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a0">RtlAllocateHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, <a class="code" href="../../d9/d2/ldrp_8h.html#a11">MAKE_TAG</a>( <a class="code" href="../../d9/d2/ldrp_8h.html#a17">SE_TAG</a> ), TokenDaclInfoSize );
08913 
08914         <span class="keywordflow">if</span> ( *DefaultDaclInfo == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
08915 
08916             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_NO_MEMORY;
08917             <span class="keywordflow">goto</span> Cleanup;
08918         }
08919 
08920         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d3/tokenqry_8c.html#a0">NtQueryInformationToken</a>(
08921                      <a class="code" href="../../d7/d0/ctlnpqos_8c.html#a16">ClientToken</a>,                        <span class="comment">// Handle</span>
08922                      TokenDefaultDacl,             <span class="comment">// TokenInformationClass</span>
08923                      *DefaultDaclInfo,             <span class="comment">// TokenInformation</span>
08924                      TokenDaclInfoSize,            <span class="comment">// TokenInformationLength</span>
08925                      &amp;TokenDaclInfoSize            <span class="comment">// ReturnLength</span>
08926                      );
08927 
08928         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
08929             <span class="keywordflow">goto</span> Cleanup;
08930         }
08931     }
08932 
08933     <span class="comment">//</span>
08934     <span class="comment">// Now open the primary token to determine how to substitute for</span>
08935     <span class="comment">// ServerOwner and ServerGroup.</span>
08936     <span class="comment">//</span>
08937 
08938     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d7/d3/tokenopn_8c.html#a1">NtOpenProcessToken</a>(
08939                  NtCurrentProcess(),
08940                  TOKEN_QUERY,
08941                  &amp;<a class="code" href="../../d6/d0/ctaccess_8c.html#a31">PrimaryToken</a>
08942                  );
08943 
08944     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
08945         ClosePrimaryToken = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
08946         <span class="keywordflow">goto</span> Cleanup;
08947     } <span class="keywordflow">else</span> {
08948         ClosePrimaryToken = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
08949     }
08950 
08951     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d3/tokenqry_8c.html#a0">NtQueryInformationToken</a>(
08952                  <a class="code" href="../../d6/d0/ctaccess_8c.html#a31">PrimaryToken</a>,                 <span class="comment">// Handle</span>
08953                  TokenOwner,                   <span class="comment">// TokenInformationClass</span>
08954                  <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,                         <span class="comment">// TokenInformation</span>
08955                  0,                            <span class="comment">// TokenInformationLength</span>
08956                  &amp;ServerOwnerInfoSize          <span class="comment">// ReturnLength</span>
08957                  );
08958 
08959     <span class="keywordflow">if</span> ( STATUS_BUFFER_TOO_SMALL != <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> ) {
08960         <span class="keywordflow">goto</span> Cleanup;
08961     }
08962 
08963     *ServerOwner = <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a0">RtlAllocateHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, <a class="code" href="../../d9/d2/ldrp_8h.html#a11">MAKE_TAG</a>( <a class="code" href="../../d9/d2/ldrp_8h.html#a17">SE_TAG</a> ), ServerOwnerInfoSize );
08964 
08965     <span class="keywordflow">if</span> ( *ServerOwner == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
08966         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_NO_MEMORY;
08967         <span class="keywordflow">goto</span> Cleanup;
08968     }
08969 
08970     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d3/tokenqry_8c.html#a0">NtQueryInformationToken</a>(
08971                  <a class="code" href="../../d6/d0/ctaccess_8c.html#a31">PrimaryToken</a>,                 <span class="comment">// Handle</span>
08972                  TokenOwner,                   <span class="comment">// TokenInformationClass</span>
08973                  *ServerOwner,                 <span class="comment">// TokenInformation</span>
08974                  ServerOwnerInfoSize,          <span class="comment">// TokenInformationLength</span>
08975                  &amp;ServerOwnerInfoSize          <span class="comment">// ReturnLength</span>
08976                  );
08977 
08978     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
08979         <span class="keywordflow">goto</span> Cleanup;
08980     }
08981 
08982     <span class="comment">//</span>
08983     <span class="comment">// Find the server group.</span>
08984     <span class="comment">//</span>
08985 
08986     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d3/tokenqry_8c.html#a0">NtQueryInformationToken</a>(
08987                  <a class="code" href="../../d6/d0/ctaccess_8c.html#a31">PrimaryToken</a>,                 <span class="comment">// Handle</span>
08988                  TokenPrimaryGroup,            <span class="comment">// TokenInformationClass</span>
08989                  *ServerGroup,                 <span class="comment">// TokenInformation</span>
08990                  0,                            <span class="comment">// TokenInformationLength</span>
08991                  &amp;ServerGroupInfoSize          <span class="comment">// ReturnLength</span>
08992                  );
08993 
08994     <span class="keywordflow">if</span> ( STATUS_BUFFER_TOO_SMALL != <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> ) {
08995         <span class="keywordflow">goto</span> Cleanup;
08996     }
08997 
08998     *ServerGroup = <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a0">RtlAllocateHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, <a class="code" href="../../d9/d2/ldrp_8h.html#a11">MAKE_TAG</a>( <a class="code" href="../../d9/d2/ldrp_8h.html#a17">SE_TAG</a> ), ServerGroupInfoSize );
08999 
09000     <span class="keywordflow">if</span> ( *ServerGroup == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
09001         <span class="keywordflow">goto</span> Cleanup;
09002     }
09003 
09004     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d3/tokenqry_8c.html#a0">NtQueryInformationToken</a>(
09005                  <a class="code" href="../../d6/d0/ctaccess_8c.html#a31">PrimaryToken</a>,                 <span class="comment">// Handle</span>
09006                  TokenPrimaryGroup,            <span class="comment">// TokenInformationClass</span>
09007                  *ServerGroup,                 <span class="comment">// TokenInformation</span>
09008                  ServerGroupInfoSize,          <span class="comment">// TokenInformationLength</span>
09009                  &amp;ServerGroupInfoSize          <span class="comment">// ReturnLength</span>
09010                  );
09011 
09012     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
09013         <span class="keywordflow">goto</span> Cleanup;
09014     }
09015 
09016     <a class="code" href="../../d5/d0/obclose_8c.html#a1">NtClose</a>( <a class="code" href="../../d6/d0/ctaccess_8c.html#a31">PrimaryToken</a> );
09017 
09018     <span class="keywordflow">return</span>( STATUS_SUCCESS );
09019 
09020 Cleanup:
09021 
09022     <span class="keywordflow">if</span> (*OwnerInfo != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
09023         <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, 0, (PVOID)*OwnerInfo );
09024         *OwnerInfo = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
09025     }
09026 
09027     <span class="keywordflow">if</span> (*GroupInfo != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
09028         <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, 0, (PVOID)*GroupInfo );
09029         *GroupInfo = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
09030     }
09031 
09032     <span class="keywordflow">if</span> (*DefaultDaclInfo != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
09033         <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, 0, (PVOID)*DefaultDaclInfo );
09034         *DefaultDaclInfo = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
09035     }
09036 
09037     <span class="keywordflow">if</span> (*ServerOwner != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
09038         <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, 0, (PVOID)*ServerOwner );
09039         *ServerOwner = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
09040     }
09041 
09042     <span class="keywordflow">if</span> (*ServerGroup != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
09043         <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, 0, (PVOID)*ServerGroup );
09044         *ServerGroup = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
09045     }
09046 
09047     <span class="keywordflow">if</span> (ClosePrimaryToken  == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
09048         <a class="code" href="../../d5/d0/obclose_8c.html#a1">NtClose</a>( <a class="code" href="../../d6/d0/ctaccess_8c.html#a31">PrimaryToken</a> );
09049     }
09050 
09051     <span class="keywordflow">return</span>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> );
09052 }
09053 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
09054 <span class="preprocessor"></span>
09055 
09056 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l09057"></a><a class="code" href="../../d8/d6/sertl_8c.html#a76">09057</a> <a class="code" href="../../d8/d6/sertl_8c.html#a76">RtlpNewSecurityObject</a> (
09058     IN PSECURITY_DESCRIPTOR ParentDescriptor OPTIONAL,
09059     IN PSECURITY_DESCRIPTOR CreatorDescriptor OPTIONAL,
09060     OUT PSECURITY_DESCRIPTOR * NewDescriptor,
09061     IN GUID *ObjectType OPTIONAL,
09062     IN BOOLEAN IsDirectoryObject,
09063     IN ULONG AutoInheritFlags,
09064     IN HANDLE Token OPTIONAL,
09065     IN PGENERIC_MAPPING GenericMapping
09066     )
09067 <span class="comment">/*++</span>
09068 <span class="comment"></span>
09069 <span class="comment">Routine Description:</span>
09070 <span class="comment"></span>
09071 <span class="comment">    The procedure is used to allocate and initialize a self-relative</span>
09072 <span class="comment">    Security Descriptor for a new protected server's object.  It is called</span>
09073 <span class="comment">    when a new protected server object is being created.  The generated</span>
09074 <span class="comment">    security descriptor will be in self-relative form.</span>
09075 <span class="comment"></span>
09076 <span class="comment">    This procedure, called only from user mode, is used to establish a</span>
09077 <span class="comment">    security descriptor for a new protected server's object.  Memory is</span>
09078 <span class="comment">    allocated to hold each of the security descriptor's components (using</span>
09079 <span class="comment">    NtAllocateVirtualMemory()).  The final security descriptor generated by</span>
09080 <span class="comment">    this procedure is produced according to the rules stated in ???</span>
09081 <span class="comment"></span>
09082 <span class="comment">    System and Discretionary ACL Assignment</span>
09083 <span class="comment">    ---------------------------------------</span>
09084 <span class="comment"></span>
09085 <span class="comment">    The assignment of system and discretionary ACLs is governed by the</span>
09086 <span class="comment">    logic illustrated in the following table:</span>
09087 <span class="comment"></span>
09088 <span class="comment">                 |  Explicit      |  Explicit     |</span>
09089 <span class="comment">                 | (non-default)  |  Default      |   No</span>
09090 <span class="comment">                 |  Acl           |  Acl          |   Acl</span>
09091 <span class="comment">                 |  Specified     |  Specified    |   Specified</span>
09092 <span class="comment">    -------------+----------------+---------------+--------------</span>
09093 <span class="comment">                 |                |               |</span>
09094 <span class="comment">    Inheritable  | Assign         |  Assign       | Assign</span>
09095 <span class="comment">    Acl From     | Specified      |  Inherited    | Inherited</span>
09096 <span class="comment">    Parent       | Acl(1)(2)      |  Acl          | Acl</span>
09097 <span class="comment">                 |                |               |</span>
09098 <span class="comment">    -------------+----------------+---------------+--------------</span>
09099 <span class="comment">    No           |                |               |</span>
09100 <span class="comment">    Inheritable  | Assign         |  Assign       | Assign</span>
09101 <span class="comment">    Acl From     | Specified      |  Default      | No Acl</span>
09102 <span class="comment">    Parent       | Acl(1)         |  Acl          |</span>
09103 <span class="comment">                 |                |               |</span>
09104 <span class="comment">    -------------+----------------+---------------+--------------</span>
09105 <span class="comment"></span>
09106 <span class="comment">    (1) Any ACEs with the INHERITED_ACE bit set are NOT copied to the assigned</span>
09107 <span class="comment">    security descriptor.</span>
09108 <span class="comment"></span>
09109 <span class="comment">    (2) If the AutoInheritFlags is flagged to automatically inherit ACEs from</span>
09110 <span class="comment">    parent (SEF_DACL_AUTO_INHERIT or SEF_SACL_AUTO_INHERIT), inherited</span>
09111 <span class="comment">    ACEs from the parent will be appended after explicit ACEs from the</span>
09112 <span class="comment">    CreatorDescriptor.</span>
09113 <span class="comment"></span>
09114 <span class="comment"></span>
09115 <span class="comment">    Note that an explicitly specified ACL, whether a default ACL or</span>
09116 <span class="comment">    not, may be empty or null.</span>
09117 <span class="comment"></span>
09118 <span class="comment">    If the caller is explicitly assigning a system acl, default or</span>
09119 <span class="comment">    non-default, the caller must either be a kernel mode client or</span>
09120 <span class="comment">    must be appropriately privileged.</span>
09121 <span class="comment"></span>
09122 <span class="comment"></span>
09123 <span class="comment">    Owner and Group Assignment</span>
09124 <span class="comment">    --------------------------</span>
09125 <span class="comment"></span>
09126 <span class="comment">    The assignment of the new object's owner and group is governed</span>
09127 <span class="comment">    by the following logic:</span>
09128 <span class="comment"></span>
09129 <span class="comment">       1)   If the passed security descriptor includes an owner, it</span>
09130 <span class="comment">            is assigned as the new object's owner.  Otherwise, the</span>
09131 <span class="comment">            caller's token is looked in for the owner.  Within the</span>
09132 <span class="comment">            token, if there is a default owner, it is assigned.</span>
09133 <span class="comment">            Otherwise, the caller's user ID is assigned.</span>
09134 <span class="comment"></span>
09135 <span class="comment">       2)   If the passed security descriptor includes a group, it</span>
09136 <span class="comment">            is assigned as the new object's group.  Otherwise, the</span>
09137 <span class="comment">            caller's token is looked in for the group.  Within the</span>
09138 <span class="comment">            token, if there is a default group, it is assigned.</span>
09139 <span class="comment">            Otherwise, the caller's primary group ID is assigned.</span>
09140 <span class="comment"></span>
09141 <span class="comment"></span>
09142 <span class="comment">Arguments:</span>
09143 <span class="comment"></span>
09144 <span class="comment">    ParentDescriptor - Supplies the Security Descriptor for the parent</span>
09145 <span class="comment">        directory under which a new object is being created.  If there is</span>
09146 <span class="comment">        no parent directory, then this argument is specified as NULL.</span>
09147 <span class="comment"></span>
09148 <span class="comment">    CreatorDescriptor - (Optionally) Points to a security descriptor</span>
09149 <span class="comment">        presented by the creator of the object.  If the creator of the</span>
09150 <span class="comment">        object did not explicitly pass security information for the new</span>
09151 <span class="comment">        object, then a null pointer should be passed.</span>
09152 <span class="comment"></span>
09153 <span class="comment">    NewDescriptor - Points to a pointer that is to be made to point to the</span>
09154 <span class="comment">        newly allocated self-relative security descriptor.</span>
09155 <span class="comment"></span>
09156 <span class="comment">    ObjectType - GUID of the object type being created.  If the object being</span>
09157 <span class="comment">        created has no GUID associated with it, then this argument is</span>
09158 <span class="comment">        specified as NULL.</span>
09159 <span class="comment"></span>
09160 <span class="comment">    IsDirectoryObject - Specifies if the new object is going to be a</span>
09161 <span class="comment">        directory object.  A value of TRUE indicates the object is a</span>
09162 <span class="comment">        container of other objects.</span>
09163 <span class="comment"></span>
09164 <span class="comment">    AutoInheritFlags - Controls automatic inheritance of ACES from the Parent</span>
09165 <span class="comment">        Descriptor.  Valid values are a bits mask of the logical OR of</span>
09166 <span class="comment">        one or more of the following bits:</span>
09167 <span class="comment"></span>
09168 <span class="comment">        SEF_DACL_AUTO_INHERIT - If set, inherit ACEs from the</span>
09169 <span class="comment">            DACL ParentDescriptor are inherited to NewDescriptor in addition</span>
09170 <span class="comment">            to any explicit ACEs specified by the CreatorDescriptor.</span>
09171 <span class="comment"></span>
09172 <span class="comment">        SEF_SACL_AUTO_INHERIT - If set, inherit ACEs from the</span>
09173 <span class="comment">            SACL ParentDescriptor are inherited to NewDescriptor in addition</span>
09174 <span class="comment">            to any explicit ACEs specified by the CreatorDescriptor.</span>
09175 <span class="comment"></span>
09176 <span class="comment">        SEF_DEFAULT_DESCRIPTOR_FOR_OBJECT - If set, the CreatorDescriptor</span>
09177 <span class="comment">            is the default descriptor for ObjectType.  As such, the</span>
09178 <span class="comment">            CreatorDescriptor will be ignored if any ObjectType specific</span>
09179 <span class="comment">            ACEs are inherited from the parent.  If no such ACEs are inherited,</span>
09180 <span class="comment">            the CreatorDescriptor is handled as though this flag were not</span>
09181 <span class="comment">            specified.</span>
09182 <span class="comment"></span>
09183 <span class="comment">        SEF_AVOID_PRIVILEGE_CHECK - If set, no privilege checking is done by this</span>
09184 <span class="comment">            routine.  This flag is useful while implementing automatic inheritance</span>
09185 <span class="comment">            to avoid checking privileges on each child updated.</span>
09186 <span class="comment"></span>
09187 <span class="comment">        SEF_AVOID_OWNER_CHECK - If set, no owner checking is done by this routine.</span>
09188 <span class="comment"></span>
09189 <span class="comment">        SEF_DEFAULT_OWNER_FROM_PARENT - If set, the owner of NewDescriptor will</span>
09190 <span class="comment">            default to the owner from ParentDescriptor.  If not set, the owner</span>
09191 <span class="comment">            of NewDescriptor will default to the user specified in Token.</span>
09192 <span class="comment"></span>
09193 <span class="comment">            In either case, the owner of NewDescriptor is set to the owner from</span>
09194 <span class="comment">            the CreatorDescriptor if that field is specified.</span>
09195 <span class="comment"></span>
09196 <span class="comment">        SEF_DEFAULT_GROUP_FROM_PARENT - If set, the group of NewDescriptor will</span>
09197 <span class="comment">            default to the group from ParentDescriptor.  If not set, the group</span>
09198 <span class="comment">            of NewDescriptor will default to the group specified in Token.</span>
09199 <span class="comment"></span>
09200 <span class="comment">            In either case, the group of NewDescriptor is set to the group from</span>
09201 <span class="comment">            the CreatorDescriptor if that field is specified.</span>
09202 <span class="comment"></span>
09203 <span class="comment">    Token - Supplies the token for the client on whose behalf the</span>
09204 <span class="comment">        object is being created.  If it is an impersonation token,</span>
09205 <span class="comment">        then it must be at SecurityIdentification level or higher.  If</span>
09206 <span class="comment">        it is not an impersonation token, the operation proceeds</span>
09207 <span class="comment">        normally.</span>
09208 <span class="comment"></span>
09209 <span class="comment">        A client token is used to retrieve default security</span>
09210 <span class="comment">        information for the new object, such as default owner, primary</span>
09211 <span class="comment">        group, and discretionary access control.  The token must be</span>
09212 <span class="comment">        open for TOKEN_QUERY access.</span>
09213 <span class="comment"></span>
09214 <span class="comment">        For calls from the kernel, Supplies the security context of the subject creating the</span>
09215 <span class="comment">        object. This is used to retrieve default security information for the</span>
09216 <span class="comment">        new object, such as default owner, primary group, and discretionary</span>
09217 <span class="comment">        access control.</span>
09218 <span class="comment"></span>
09219 <span class="comment">        If not specified, the Owner and Primary group must be specified in the</span>
09220 <span class="comment">        CreatorDescriptor.</span>
09221 <span class="comment"></span>
09222 <span class="comment">    GenericMapping - Supplies a pointer to a generic mapping array denoting</span>
09223 <span class="comment">        the mapping between each generic right to specific rights.</span>
09224 <span class="comment"></span>
09225 <span class="comment">Return Value:</span>
09226 <span class="comment"></span>
09227 <span class="comment">    STATUS_SUCCESS - The operation was successful.</span>
09228 <span class="comment"></span>
09229 <span class="comment">    STATUS_INVALID_OWNER - The owner SID provided as the owner of the</span>
09230 <span class="comment">        target security descriptor is not one the subject is authorized to</span>
09231 <span class="comment">        assign as the owner of an object.</span>
09232 <span class="comment"></span>
09233 <span class="comment">    STATUS_NO_CLIENT_TOKEN - Indicates a client token was not explicitly</span>
09234 <span class="comment">        provided and the caller is not currently impersonating a client.</span>
09235 <span class="comment"></span>
09236 <span class="comment">    STATUS_PRIVILEGE_NOT_HELD - The caller does not have the privilege</span>
09237 <span class="comment">        necessary to explicitly assign the specified system ACL.</span>
09238 <span class="comment">        SeSecurityPrivilege privilege is needed to explicitly assign</span>
09239 <span class="comment">        system ACLs to objects.</span>
09240 <span class="comment"></span>
09241 <span class="comment"></span>
09242 <span class="comment">--*/</span>
09243 {
09244 
09245 
09246     SECURITY_DESCRIPTOR *CapturedDescriptor;
09247     SECURITY_DESCRIPTOR InCaseOneNotPassed;
09248     BOOLEAN SecurityDescriptorPassed;
09249 
09250     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
09251 
09252     PACL NewSacl = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
09253     BOOLEAN NewSaclInherited = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
09254 
09255     PACL NewDacl = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
09256     PACL ServerDacl = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
09257     BOOLEAN NewDaclInherited = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
09258 
09259     PSID NewOwner = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
09260     PSID NewGroup = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
09261 
09262     BOOLEAN SaclExplicitlyAssigned = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
09263     BOOLEAN OwnerExplicitlyAssigned = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
09264     BOOLEAN DaclExplicitlyAssigned = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
09265 
09266     BOOLEAN ServerDaclAllocated = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
09267 
09268     BOOLEAN ServerObject;
09269     BOOLEAN DaclUntrusted;
09270 
09271     BOOLEAN HasPrivilege;
09272     PRIVILEGE_SET PrivilegeSet;
09273 
09274     PSID SubjectContextOwner = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
09275     PSID SubjectContextGroup = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
09276     PSID ServerOwner = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
09277     PSID ServerGroup = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
09278 
09279     PACL SubjectContextDacl = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
09280 
09281     ULONG AllocationSize;
09282     ULONG NewOwnerSize;
09283     ULONG NewGroupSize;
09284     ULONG NewSaclSize;
09285     ULONG NewDaclSize;
09286 
09287     PCHAR Field;
09288     PCHAR Base;
09289 
09290 
09291 
09292     PISECURITY_DESCRIPTOR_RELATIVE INewDescriptor = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
09293     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> PassedStatus;
09294     <a class="code" href="../../d0/d9/ntosdef_8h.html#a39">KPROCESSOR_MODE</a> RequestorMode;
09295 
09296     ULONG GenericControl;
09297     ULONG NewControlBits = SE_SELF_RELATIVE;
09298 
09299 <span class="preprocessor">#ifndef NTOS_KERNEL_RUNTIME</span>
09300 <span class="preprocessor"></span>    PTOKEN_OWNER         TokenOwnerInfo = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
09301     PTOKEN_PRIMARY_GROUP TokenPrimaryGroupInfo = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
09302     PTOKEN_DEFAULT_DACL  TokenDefaultDaclInfo = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
09303 
09304     PTOKEN_OWNER         ServerOwnerInfo = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
09305     PTOKEN_PRIMARY_GROUP ServerGroupInfo = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
09306     PVOID <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
09307 
09308 <span class="preprocessor">#else</span>
09309 <span class="preprocessor"></span>
09310     <span class="comment">//</span>
09311     <span class="comment">// For kernel mode callers, the Token parameter is really</span>
09312     <span class="comment">// a pointer to a subject context structure.</span>
09313     <span class="comment">//</span>
09314 
09315     <a class="code" href="../../d0/d1/struct__SECURITY__SUBJECT__CONTEXT.html">PSECURITY_SUBJECT_CONTEXT</a> SubjectSecurityContext;
09316     PVOID SubjectContextInfo = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
09317 
09318     SubjectSecurityContext = (<a class="code" href="../../d0/d1/struct__SECURITY__SUBJECT__CONTEXT.html">PSECURITY_SUBJECT_CONTEXT</a>)<a class="code" href="../../d6/d0/ctaccess_8c.html#a29">Token</a>;
09319 
09320 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
09321 <span class="preprocessor"></span>
09322 
09323 <span class="preprocessor">#ifdef NTOS_KERNEL_RUNTIME</span>
09324 <span class="preprocessor"></span>    <span class="comment">//</span>
09325     <span class="comment">//  Get the previous mode of the caller</span>
09326     <span class="comment">//</span>
09327 
09328     RequestorMode = KeGetPreviousMode();
09329 <span class="preprocessor">#else // NTOS_KERNEL_RUNTIME</span>
09330 <span class="preprocessor"></span>    RequestorMode = <a class="code" href="../../d0/d9/ntosdef_8h.html#a76a70">UserMode</a>;
09331 
09332     <span class="comment">//</span>
09333     <span class="comment">// Get the handle to the current process heap</span>
09334     <span class="comment">//</span>
09335 
09336     <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a> = RtlProcessHeap();
09337 
09338     <span class="comment">//</span>
09339     <span class="comment">// Ensure the token is an impersonation token.</span>
09340     <span class="comment">//</span>
09341     <span class="keywordflow">if</span> ( <a class="code" href="../../d6/d0/ctaccess_8c.html#a29">Token</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
09342         TOKEN_STATISTICS    ThreadTokenStatistics;
09343         ULONG ReturnLength;
09344 
09345         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d3/tokenqry_8c.html#a0">NtQueryInformationToken</a>(
09346                      <a class="code" href="../../d6/d0/ctaccess_8c.html#a29">Token</a>,                        <span class="comment">// Handle</span>
09347                      TokenStatistics,              <span class="comment">// TokenInformationClass</span>
09348                      &amp;ThreadTokenStatistics,       <span class="comment">// TokenInformation</span>
09349                      <span class="keyword">sizeof</span>(TOKEN_STATISTICS),     <span class="comment">// TokenInformationLength</span>
09350                      &amp;ReturnLength                 <span class="comment">// ReturnLength</span>
09351                      );
09352 
09353         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
09354             <span class="keywordflow">return</span>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> );
09355         }
09356 
09357         <span class="comment">//</span>
09358         <span class="comment">//  If it is an impersonation token, then make sure it is at a</span>
09359         <span class="comment">//  high enough level.</span>
09360         <span class="comment">//</span>
09361 
09362         <span class="keywordflow">if</span> (ThreadTokenStatistics.TokenType == TokenImpersonation) {
09363 
09364             <span class="keywordflow">if</span> (ThreadTokenStatistics.ImpersonationLevel &lt; SecurityIdentification ) {
09365 
09366                 <span class="keywordflow">return</span>( STATUS_BAD_IMPERSONATION_LEVEL );
09367             }
09368         }
09369 
09370     }
09371 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
09372 <span class="preprocessor"></span>
09373 
09374     <span class="comment">//</span>
09375     <span class="comment">//  The desired end result is to build a self-relative security descriptor.</span>
09376     <span class="comment">//  This means that a single block of memory will be allocated and all</span>
09377     <span class="comment">//  security information copied into it.  To minimize work along the way,</span>
09378     <span class="comment">//  it is desirable to reference (rather than copy) each field as we</span>
09379     <span class="comment">//  determine its source.  This can not be done with inherited ACLs, however,</span>
09380     <span class="comment">//  since they must be built from another ACL.  So, explicitly assigned</span>
09381     <span class="comment">//  and defaulted SIDs and ACLs are just referenced until they are copied</span>
09382     <span class="comment">//  into the self-relative descriptor.  Inherited ACLs are built in a</span>
09383     <span class="comment">//  temporary buffer which must be deallocated after being copied to the</span>
09384     <span class="comment">//  self-relative descriptor.</span>
09385     <span class="comment">//</span>
09386 
09387 
09388 
09389     <span class="comment">//</span>
09390     <span class="comment">//  If a security descriptor has been passed, capture it, otherwise</span>
09391     <span class="comment">//  cobble up a fake one to simplify the code that follows.</span>
09392     <span class="comment">//</span>
09393 
09394     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(CreatorDescriptor)) {
09395 
09396         CapturedDescriptor = CreatorDescriptor;
09397         SecurityDescriptorPassed = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
09398 
09399     } <span class="keywordflow">else</span> {
09400 
09401         <span class="comment">//</span>
09402         <span class="comment">//  No descriptor passed, make a fake one</span>
09403         <span class="comment">//</span>
09404 
09405         SecurityDescriptorPassed = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
09406 
09407         <a class="code" href="../../d8/d6/sertl_8c.html#a53">RtlCreateSecurityDescriptor</a>(&amp;InCaseOneNotPassed,
09408                                     SECURITY_DESCRIPTOR_REVISION);
09409         CapturedDescriptor = &amp;InCaseOneNotPassed;
09410 
09411     }
09412 
09413 
09414     <span class="keywordflow">if</span> ( CapturedDescriptor-&gt;Control &amp; SE_SERVER_SECURITY ) {
09415         ServerObject = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
09416     } <span class="keywordflow">else</span> {
09417         ServerObject = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
09418     }
09419 
09420     <span class="keywordflow">if</span> ( CapturedDescriptor-&gt;Control &amp; SE_DACL_UNTRUSTED ) {
09421         DaclUntrusted = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
09422     } <span class="keywordflow">else</span> {
09423         DaclUntrusted = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
09424     }
09425 
09426 
09427 
09428     <span class="comment">//</span>
09429     <span class="comment">// Get the required information from the token.</span>
09430     <span class="comment">//</span>
09431     <span class="comment">//</span>
09432     <span class="comment">// Grab pointers to the default owner, primary group, and</span>
09433     <span class="comment">// discretionary ACL.</span>
09434     <span class="comment">//</span>
09435     <span class="keywordflow">if</span> ( <a class="code" href="../../d6/d0/ctaccess_8c.html#a29">Token</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> || ServerObject ) {
09436 
09437 <span class="preprocessor">#ifdef NTOS_KERNEL_RUNTIME</span>
09438 <span class="preprocessor"></span>
09439         PSID TmpSubjectContextOwner = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
09440         PSID TmpSubjectContextGroup = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
09441         PSID TmpServerOwner = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
09442         PSID TmpServerGroup = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
09443 
09444         PACL TmpSubjectContextDacl = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
09445 
09446         SIZE_T SubjectContextInfoSize = 0;
09447 
09448         <span class="comment">//</span>
09449         <span class="comment">// Lock the subject context for read access so that the pointers</span>
09450         <span class="comment">// we copy out of it don't disappear on us at random</span>
09451         <span class="comment">//</span>
09452 
09453         <a class="code" href="../../d0/d8/subject_8c.html#a1">SeLockSubjectContext</a>( SubjectSecurityContext );
09454 
09455         <a class="code" href="../../d0/d8/subject_8c.html#a4">SepGetDefaultsSubjectContext</a>(
09456             SubjectSecurityContext,
09457             &amp;TmpSubjectContextOwner,
09458             &amp;TmpSubjectContextGroup,
09459             &amp;TmpServerOwner,
09460             &amp;TmpServerGroup,
09461             &amp;TmpSubjectContextDacl
09462             );
09463 
09464         <span class="comment">//</span>
09465         <span class="comment">// We can't keep the subject context locked, because</span>
09466         <span class="comment">// we may have to do a privilege check later, which calls</span>
09467         <span class="comment">// PsLockProcessSecurityFields, which can cause a deadlock</span>
09468         <span class="comment">// with PsImpersonateClient, which takes them in the reverse</span>
09469         <span class="comment">// order.</span>
09470         <span class="comment">//</span>
09471         <span class="comment">// Since we're giving up our read lock on the token, we</span>
09472         <span class="comment">// need to copy all the stuff that we just got back.  Since</span>
09473         <span class="comment">// it's not going to change, we can save some cycles and copy</span>
09474         <span class="comment">// it all into a single chunck of memory.</span>
09475         <span class="comment">//</span>
09476 
09477         SubjectContextInfoSize = <a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>( TmpSubjectContextOwner ) +
09478                                  <a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>( TmpServerOwner )         +
09479                                  (TmpSubjectContextGroup != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ? <a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>( TmpSubjectContextGroup ) : 0) +
09480                                  (TmpServerGroup         != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ? <a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>( TmpServerGroup )         : 0) +
09481                                  (TmpSubjectContextDacl  != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ? TmpSubjectContextDacl-&gt;AclSize        : 0);
09482 
09483         SubjectContextInfo = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>, SubjectContextInfoSize, 'dSeS');
09484 
09485         <span class="keywordflow">if</span> (SubjectContextInfo) {
09486 
09487             <span class="comment">//</span>
09488             <span class="comment">// Copy in the data</span>
09489             <span class="comment">//</span>
09490 
09491             Base = SubjectContextInfo;
09492 
09493             <span class="comment">//</span>
09494             <span class="comment">// There will always be an owner.</span>
09495             <span class="comment">//</span>
09496 
09497             SubjectContextOwner = (PSID)Base;
09498             <a class="code" href="../../d8/d6/sertl_8c.html#a46">RtlCopySid</a>( <a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>( TmpSubjectContextOwner), Base, TmpSubjectContextOwner );
09499             Base += <a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>( TmpSubjectContextOwner);
09500 
09501             <span class="comment">//</span>
09502             <span class="comment">// Groups may be NULL</span>
09503             <span class="comment">//</span>
09504 
09505             <span class="keywordflow">if</span> (TmpSubjectContextGroup != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
09506                 SubjectContextGroup = (PSID)Base;
09507                 <a class="code" href="../../d8/d6/sertl_8c.html#a46">RtlCopySid</a>( <a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>( TmpSubjectContextGroup), Base, TmpSubjectContextGroup );
09508                 Base += <a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>( TmpSubjectContextGroup );
09509             } <span class="keywordflow">else</span> {
09510                 SubjectContextGroup = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
09511             }
09512 
09513             ServerOwner = (PSID)Base;
09514             <a class="code" href="../../d8/d6/sertl_8c.html#a46">RtlCopySid</a>( <a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>( TmpServerOwner ), Base, TmpServerOwner );
09515             Base += <a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>( TmpServerOwner );
09516 
09517             <span class="comment">//</span>
09518             <span class="comment">// Groups may be NULL</span>
09519             <span class="comment">//</span>
09520 
09521             <span class="keywordflow">if</span> (TmpServerGroup != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
09522                 ServerGroup = (PSID)Base;
09523                 <a class="code" href="../../d8/d6/sertl_8c.html#a46">RtlCopySid</a>( <a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>( TmpServerGroup ), Base, TmpServerGroup );
09524                 Base += <a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>( TmpServerGroup );
09525             } <span class="keywordflow">else</span> {
09526                 ServerGroup = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
09527             }
09528 
09529             <span class="keywordflow">if</span> (TmpSubjectContextDacl != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
09530                 SubjectContextDacl = (PACL)Base;
09531                 RtlCopyMemory( Base, TmpSubjectContextDacl, TmpSubjectContextDacl-&gt;AclSize );
09532                 <span class="comment">// Base += TmpSubjectContextDacl-&gt;AclSize;</span>
09533             } <span class="keywordflow">else</span> {
09534                 SubjectContextDacl = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
09535             }
09536 
09537         } <span class="keywordflow">else</span> {
09538 
09539             <a class="code" href="../../d0/d8/subject_8c.html#a2">SeUnlockSubjectContext</a>( SubjectSecurityContext );
09540 
09541             <span class="keywordflow">return</span>( STATUS_INSUFFICIENT_RESOURCES );
09542         }
09543 
09544         <a class="code" href="../../d0/d8/subject_8c.html#a2">SeUnlockSubjectContext</a>( SubjectSecurityContext );
09545 
09546 
09547 <span class="preprocessor">#else // NTOS_KERNEL_RUNTIME</span>
09548 <span class="preprocessor"></span>        <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d8/d6/sertl_8c.html#a28">RtlpGetDefaultsSubjectContext</a>(
09549                      <a class="code" href="../../d6/d0/ctaccess_8c.html#a29">Token</a>,
09550                      &amp;TokenOwnerInfo,
09551                      &amp;TokenPrimaryGroupInfo,
09552                      &amp;TokenDefaultDaclInfo,
09553                      &amp;ServerOwnerInfo,
09554                      &amp;ServerGroupInfo
09555                      );
09556 
09557         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
09558             <span class="keywordflow">return</span>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> );
09559         }
09560 
09561         SubjectContextOwner = TokenOwnerInfo-&gt;Owner;
09562         SubjectContextGroup = TokenPrimaryGroupInfo-&gt;PrimaryGroup;
09563         SubjectContextDacl  = TokenDefaultDaclInfo-&gt;DefaultDacl;
09564         ServerOwner         = ServerOwnerInfo-&gt;Owner;
09565         ServerGroup         = ServerGroupInfo-&gt;PrimaryGroup;
09566 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
09567 <span class="preprocessor"></span>    }
09568 
09569 
09570 
09571     <span class="comment">//</span>
09572     <span class="comment">// Establish an owner SID</span>
09573     <span class="comment">//</span>
09574 
09575     NewOwner = RtlpOwnerAddrSecurityDescriptor(CapturedDescriptor);
09576 
09577     <span class="keywordflow">if</span> ((NewOwner) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
09578 
09579         <span class="comment">//</span>
09580         <span class="comment">// Use the specified owner</span>
09581         <span class="comment">//</span>
09582 
09583         OwnerExplicitlyAssigned = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
09584 
09585     } <span class="keywordflow">else</span> {
09586 
09587         <span class="comment">//</span>
09588         <span class="comment">// If the caller said to default the owner from the parent descriptor,</span>
09589         <span class="comment">//  grab it now.</span>
09590         <span class="comment">//</span>
09591 
09592         <span class="keywordflow">if</span> ( AutoInheritFlags &amp; SEF_DEFAULT_OWNER_FROM_PARENT) {
09593             <span class="keywordflow">if</span> ( !ARGUMENT_PRESENT(ParentDescriptor) ) {
09594                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_OWNER;
09595                 <span class="keywordflow">goto</span> Cleanup;
09596             }
09597             NewOwner = RtlpOwnerAddrSecurityDescriptor((SECURITY_DESCRIPTOR *)ParentDescriptor);
09598             OwnerExplicitlyAssigned = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
09599 
09600             <span class="keywordflow">if</span> ( NewOwner == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
09601                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_OWNER;
09602                 <span class="keywordflow">goto</span> Cleanup;
09603             }
09604         } <span class="keywordflow">else</span> {
09605 
09606             <span class="comment">//</span>
09607             <span class="comment">// Pick up the default from the subject's security context.</span>
09608             <span class="comment">//</span>
09609             <span class="comment">// This does NOT constitute explicit assignment of owner</span>
09610             <span class="comment">// and does not have to be checked as an ID that can be</span>
09611             <span class="comment">// assigned as owner.  This is because a default can not</span>
09612             <span class="comment">// be established in a token unless the user of the token</span>
09613             <span class="comment">// can assign it as an owner.</span>
09614             <span class="comment">//</span>
09615 
09616             <span class="comment">//</span>
09617             <span class="comment">// If we've been asked to create a ServerObject, we need to</span>
09618             <span class="comment">// make sure to pick up the new owner from the Primary token,</span>
09619             <span class="comment">// not the client token.  If we're not impersonating, they will</span>
09620             <span class="comment">// end up being the same.</span>
09621             <span class="comment">//</span>
09622 
09623             NewOwner = ServerObject ? ServerOwner : SubjectContextOwner;
09624 
09625             <span class="comment">//</span>
09626             <span class="comment">// Ensure an owner is now defined.</span>
09627             <span class="comment">//</span>
09628 
09629             <span class="keywordflow">if</span> ( NewOwner == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
09630                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_NO_TOKEN;
09631                 <span class="keywordflow">goto</span> Cleanup;
09632             }
09633         }
09634     }
09635 
09636 
09637     <span class="comment">//</span>
09638     <span class="comment">// Establish a Group SID</span>
09639     <span class="comment">//</span>
09640 
09641     NewGroup = RtlpGroupAddrSecurityDescriptor(CapturedDescriptor);
09642 
09643     <span class="keywordflow">if</span> (NewGroup == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
09644 
09645         <span class="comment">//</span>
09646         <span class="comment">// If the caller said to default the group from the parent descriptor,</span>
09647         <span class="comment">//  grab it now.</span>
09648         <span class="comment">//</span>
09649 
09650         <span class="keywordflow">if</span> ( AutoInheritFlags &amp; SEF_DEFAULT_GROUP_FROM_PARENT) {
09651             <span class="keywordflow">if</span> ( !ARGUMENT_PRESENT(ParentDescriptor) ) {
09652                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_PRIMARY_GROUP;
09653                 <span class="keywordflow">goto</span> Cleanup;
09654             }
09655             NewGroup = RtlpGroupAddrSecurityDescriptor((SECURITY_DESCRIPTOR *)ParentDescriptor);
09656         } <span class="keywordflow">else</span> {
09657             <span class="comment">//</span>
09658             <span class="comment">// Pick up the primary group from the subject's security context</span>
09659             <span class="comment">//</span>
09660             <span class="comment">// If we're creating a Server object, use the group from the server</span>
09661             <span class="comment">// context.</span>
09662             <span class="comment">//</span>
09663 
09664             NewGroup = ServerObject ? ServerGroup : SubjectContextGroup;
09665         }
09666 
09667     }
09668 
09669     <span class="keywordflow">if</span> (NewGroup != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
09670         <span class="keywordflow">if</span> (!<a class="code" href="../../d8/d6/sertl_8c.html#a35">RtlValidSid</a>( NewGroup )) {
09671             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_PRIMARY_GROUP;
09672             <span class="keywordflow">goto</span> Cleanup;
09673         }
09674     } <span class="keywordflow">else</span> {
09675         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_PRIMARY_GROUP;
09676         <span class="keywordflow">goto</span> Cleanup;
09677     }
09678 
09679 
09680 
09681 
09682     <span class="comment">//</span>
09683     <span class="comment">// Establish System Acl</span>
09684     <span class="comment">//</span>
09685 
09686     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d8/d6/sertl_8c.html#a74">RtlpInheritAcl</a> (
09687                 ARGUMENT_PRESENT(ParentDescriptor) ?
09688                     RtlpSaclAddrSecurityDescriptor(
09689                         ((SECURITY_DESCRIPTOR *)ParentDescriptor)) :
09690                     <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
09691                 RtlpSaclAddrSecurityDescriptor(CapturedDescriptor),
09692                 SeControlSaclToGeneric( CapturedDescriptor-&gt;Control ),
09693                 IsDirectoryObject,
09694                 (BOOLEAN)((AutoInheritFlags &amp; SEF_SACL_AUTO_INHERIT) != 0),
09695                 (BOOLEAN)((AutoInheritFlags &amp; SEF_DEFAULT_DESCRIPTOR_FOR_OBJECT) != 0),
09696                 NewOwner,
09697                 NewGroup,
09698                 ServerOwner,
09699                 ServerGroup,
09700                 GenericMapping,
09701                 <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,   <span class="comment">// Is a SACL</span>
09702                 ObjectType,
09703                 &amp;NewSacl,
09704                 &amp;SaclExplicitlyAssigned,
09705                 &amp;GenericControl );
09706 
09707     <span class="keywordflow">if</span> ( <a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>) ) {
09708         NewSaclInherited = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
09709         NewControlBits |= SE_SACL_PRESENT | SeControlGenericToSacl( GenericControl );
09710 
09711     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_NO_INHERITANCE ) {
09712 
09713         <span class="comment">//</span>
09714         <span class="comment">// Always set the auto inherit bit if the caller requested it.</span>
09715         <span class="comment">//</span>
09716 
09717         <span class="keywordflow">if</span> ( AutoInheritFlags &amp; SEF_SACL_AUTO_INHERIT) {
09718             NewControlBits |= SE_SACL_AUTO_INHERITED;
09719         }
09720 
09721         <span class="comment">//</span>
09722         <span class="comment">// No inheritable ACL - check for a defaulted one.</span>
09723         <span class="comment">//</span>
09724         <span class="keywordflow">if</span> ( RtlpAreControlBitsSet( CapturedDescriptor,
09725                                 SE_SACL_PRESENT | SE_SACL_DEFAULTED ) ) {
09726 
09727             <span class="comment">//</span>
09728             <span class="comment">// Reference the default ACL</span>
09729             <span class="comment">//</span>
09730 
09731             NewSacl = RtlpSaclAddrSecurityDescriptor(CapturedDescriptor);
09732             NewControlBits |= SE_SACL_PRESENT;
09733             NewControlBits |= (CapturedDescriptor-&gt;Control &amp; SE_SACL_PROTECTED);
09734 
09735             <span class="comment">//</span>
09736             <span class="comment">// This counts as an explicit assignment.</span>
09737             <span class="comment">//</span>
09738             SaclExplicitlyAssigned = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
09739         }
09740 
09741     } <span class="keywordflow">else</span> {
09742 
09743         <span class="comment">//</span>
09744         <span class="comment">// Some unusual error occured</span>
09745         <span class="comment">//</span>
09746 
09747         <span class="keywordflow">goto</span> Cleanup;
09748     }
09749 
09750 
09751 
09752 
09753     <span class="comment">//</span>
09754     <span class="comment">// Establish Discretionary Acl</span>
09755     <span class="comment">//</span>
09756 
09757     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d8/d6/sertl_8c.html#a74">RtlpInheritAcl</a> (
09758                 ARGUMENT_PRESENT(ParentDescriptor) ?
09759                     RtlpDaclAddrSecurityDescriptor(
09760                         ((SECURITY_DESCRIPTOR *)ParentDescriptor)) :
09761                     <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
09762                 RtlpDaclAddrSecurityDescriptor(CapturedDescriptor),
09763                 SeControlDaclToGeneric( CapturedDescriptor-&gt;Control ),
09764                 IsDirectoryObject,
09765                 (BOOLEAN)((AutoInheritFlags &amp; SEF_DACL_AUTO_INHERIT) != 0),
09766                 (BOOLEAN)((AutoInheritFlags &amp; SEF_DEFAULT_DESCRIPTOR_FOR_OBJECT) != 0),
09767                 NewOwner,
09768                 NewGroup,
09769                 ServerOwner,
09770                 ServerGroup,
09771                 GenericMapping,
09772                 <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,   <span class="comment">// Is a DACL</span>
09773                 ObjectType,
09774                 &amp;NewDacl,
09775                 &amp;DaclExplicitlyAssigned,
09776                 &amp;GenericControl );
09777 
09778     <span class="keywordflow">if</span> ( <a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>) ) {
09779         NewDaclInherited = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
09780         NewControlBits |= SE_DACL_PRESENT | SeControlGenericToDacl( GenericControl );
09781 
09782     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_NO_INHERITANCE ) {
09783 
09784         <span class="comment">//</span>
09785         <span class="comment">// Always set the auto inherit bit if the caller requested it.</span>
09786         <span class="comment">//</span>
09787 
09788         <span class="keywordflow">if</span> ( AutoInheritFlags &amp; SEF_DACL_AUTO_INHERIT) {
09789             NewControlBits |= SE_DACL_AUTO_INHERITED;
09790         }
09791 
09792         <span class="comment">//</span>
09793         <span class="comment">// No inheritable ACL - check for a defaulted one.</span>
09794         <span class="comment">//</span>
09795         <span class="keywordflow">if</span> ( RtlpAreControlBitsSet( CapturedDescriptor,
09796                                 SE_DACL_PRESENT | SE_DACL_DEFAULTED ) ) {
09797 
09798             <span class="comment">//</span>
09799             <span class="comment">// Reference the default ACL</span>
09800             <span class="comment">//</span>
09801 
09802             NewDacl = RtlpDaclAddrSecurityDescriptor(CapturedDescriptor);
09803             NewControlBits |= SE_DACL_PRESENT;
09804             NewControlBits |= (CapturedDescriptor-&gt;Control &amp; SE_DACL_PROTECTED);
09805 
09806             <span class="comment">//</span>
09807             <span class="comment">// This counts as an explicit assignment.</span>
09808             <span class="comment">//</span>
09809             DaclExplicitlyAssigned = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
09810 
09811         <span class="comment">//</span>
09812         <span class="comment">// Default to the DACL on the token.</span>
09813         <span class="comment">//</span>
09814         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ARGUMENT_PRESENT(SubjectContextDacl)) {
09815 
09816             NewDacl = SubjectContextDacl;
09817             NewControlBits |= SE_DACL_PRESENT;
09818 
09819         }
09820 
09821 
09822     } <span class="keywordflow">else</span> {
09823 
09824         <span class="comment">//</span>
09825         <span class="comment">// Some unusual error occured</span>
09826         <span class="comment">//</span>
09827 
09828         <span class="keywordflow">goto</span> Cleanup;
09829     }
09830 
09831     <span class="comment">//</span>
09832     <span class="comment">// If auto inheriting and the computed child DACL is NULL,</span>
09833     <span class="comment">//  mark it as protected.</span>
09834     <span class="comment">//</span>
09835     <span class="comment">// NULL DACLs are problematic when ACEs are actually inherited from the</span>
09836     <span class="comment">// parent DACL.  It is better to mark them as protected NOW (even if we don't</span>
09837     <span class="comment">// end up inheriting any ACEs) to avoid confusion later.</span>
09838     <span class="comment">//</span>
09839 
09840     <span class="keywordflow">if</span> ( (AutoInheritFlags &amp; SEF_DACL_AUTO_INHERIT) != 0 &amp;&amp;
09841          NewDacl == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
09842         NewControlBits |= SE_DACL_PROTECTED;
09843     }
09844 
09845 
09846 
09847     <span class="comment">//</span>
09848     <span class="comment">// Now make sure that the caller has the right to assign</span>
09849     <span class="comment">// everything in the descriptor.  The requestor is subjected</span>
09850     <span class="comment">// to privilege and restriction tests for some assignments.</span>
09851     <span class="comment">//</span>
09852     <span class="keywordflow">if</span> (RequestorMode == <a class="code" href="../../d0/d9/ntosdef_8h.html#a76a70">UserMode</a>) {
09853 
09854 
09855         <span class="comment">//</span>
09856         <span class="comment">// Anybody can assign any Discretionary ACL or group that they want to.</span>
09857         <span class="comment">//</span>
09858 
09859         <span class="comment">//</span>
09860         <span class="comment">//  See if the system ACL was explicitly specified</span>
09861         <span class="comment">//</span>
09862 
09863         <span class="keywordflow">if</span> ( SaclExplicitlyAssigned &amp;&amp;
09864              (AutoInheritFlags &amp; SEF_AVOID_PRIVILEGE_CHECK) == 0 ) {
09865 
09866             <span class="comment">//</span>
09867             <span class="comment">// Require a Token if we're to do the privilege check.</span>
09868             <span class="comment">//</span>
09869 
09870             <span class="keywordflow">if</span> ( <a class="code" href="../../d6/d0/ctaccess_8c.html#a29">Token</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
09871                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_NO_TOKEN;
09872                 <span class="keywordflow">goto</span> Cleanup;
09873             }
09874 
09875 <span class="preprocessor">#ifdef NTOS_KERNEL_RUNTIME</span>
09876 <span class="preprocessor"></span>
09877             <span class="comment">//</span>
09878             <span class="comment">// Check for appropriate Privileges</span>
09879             <span class="comment">// Audit/Alarm messages need to be generated due to the attempt</span>
09880             <span class="comment">// to perform a privileged operation.</span>
09881             <span class="comment">//</span>
09882 
09883             <span class="comment">//</span>
09884             <span class="comment">// Note: be sure to do the privilege check against</span>
09885             <span class="comment">// the passed subject context!</span>
09886             <span class="comment">//</span>
09887 
09888             PrivilegeSet.PrivilegeCount = 1;
09889             PrivilegeSet.Control = PRIVILEGE_SET_ALL_NECESSARY;
09890             PrivilegeSet.Privilege[0].Luid = <a class="code" href="../../d0/d5/se_8h.html#a85">SeSecurityPrivilege</a>;
09891             PrivilegeSet.Privilege[0].Attributes = 0;
09892 
09893             HasPrivilege = <a class="code" href="../../d8/d4/privileg_8c.html#a1">SePrivilegeCheck</a>(
09894                                &amp;PrivilegeSet,
09895                                SubjectSecurityContext,
09896                                RequestorMode
09897                                );
09898 
09899             <span class="keywordflow">if</span> ( RequestorMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a> ) {
09900 
09901                 <a class="code" href="../../d3/d5/seaudit_8c.html#a15">SePrivilegedServiceAuditAlarm</a> (
09902                     <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,                              <span class="comment">// BUGWARNING need service name</span>
09903                     SubjectSecurityContext,
09904                     &amp;PrivilegeSet,
09905                     HasPrivilege
09906                     );
09907             }
09908 
09909 <span class="preprocessor">#else // NTOS_KERNEL_RUNTIME</span>
09910 <span class="preprocessor"></span>            <span class="comment">//</span>
09911             <span class="comment">// Check for appropriate Privileges</span>
09912             <span class="comment">//</span>
09913             <span class="comment">// Audit/Alarm messages need to be generated due to the attempt</span>
09914             <span class="comment">// to perform a privileged operation.</span>
09915             <span class="comment">//</span>
09916 
09917             PrivilegeSet.PrivilegeCount = 1;
09918             PrivilegeSet.Control = PRIVILEGE_SET_ALL_NECESSARY;
09919             PrivilegeSet.Privilege[0].Luid = RtlConvertLongToLuid(SE_SECURITY_PRIVILEGE);
09920             PrivilegeSet.Privilege[0].Attributes = 0;
09921 
09922             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d8/d4/privileg_8c.html#a2">NtPrivilegeCheck</a>(
09923                         <a class="code" href="../../d6/d0/ctaccess_8c.html#a29">Token</a>,
09924                         &amp;PrivilegeSet,
09925                         &amp;HasPrivilege
09926                         );
09927 
09928             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
09929                 <span class="keywordflow">goto</span> Cleanup;
09930             }
09931 
09932 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
09933 <span class="preprocessor"></span>
09934             <span class="keywordflow">if</span> ( !HasPrivilege ) {
09935                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_PRIVILEGE_NOT_HELD;
09936                 <span class="keywordflow">goto</span> Cleanup;
09937             }
09938 
09939         }
09940 
09941         <span class="comment">//</span>
09942         <span class="comment">// See if the owner field is one the requestor can assign</span>
09943         <span class="comment">//</span>
09944 
09945         <span class="keywordflow">if</span> (OwnerExplicitlyAssigned &amp;&amp;
09946             (AutoInheritFlags &amp; SEF_AVOID_OWNER_CHECK) == 0 ) {
09947 
09948 <span class="preprocessor">#ifdef NTOS_KERNEL_RUNTIME</span>
09949 <span class="preprocessor"></span>
09950 
09951             <span class="keywordflow">if</span> (!<a class="code" href="../../d0/d8/subject_8c.html#a6">SepValidOwnerSubjectContext</a>(
09952                     SubjectSecurityContext,
09953                     NewOwner,
09954                     ServerObject)
09955                     ) {
09956 
09957                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_OWNER;
09958                 <span class="keywordflow">goto</span> Cleanup;
09959             }
09960 
09961 <span class="preprocessor">#else // NTOS_KERNEL_RUNTIME</span>
09962 <span class="preprocessor"></span>
09963             <span class="comment">//</span>
09964             <span class="comment">// Require a Token if we're to do the privilege check.</span>
09965             <span class="comment">//</span>
09966 
09967             <span class="keywordflow">if</span> ( <a class="code" href="../../d6/d0/ctaccess_8c.html#a29">Token</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
09968                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_NO_TOKEN;
09969                 <span class="keywordflow">goto</span> Cleanup;
09970             }
09971 
09972             <span class="keywordflow">if</span> (!<a class="code" href="../../d8/d6/sertl_8c.html#a72">RtlpValidOwnerSubjectContext</a>(
09973                     <a class="code" href="../../d6/d0/ctaccess_8c.html#a29">Token</a>,
09974                     NewOwner,
09975                     ServerObject,
09976                     &amp;PassedStatus) ) {
09977 
09978                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = PassedStatus;
09979                 <span class="keywordflow">goto</span> Cleanup;
09980             }
09981 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
09982 <span class="preprocessor"></span>        }
09983 
09984 
09985         <span class="comment">//</span>
09986         <span class="comment">// If the DACL was explictly assigned and this is a server object,</span>
09987         <span class="comment">//  convert the DACL to be a server DACL</span>
09988         <span class="comment">//</span>
09989 
09990         <span class="keywordflow">if</span> (DaclExplicitlyAssigned &amp;&amp; ServerObject) {
09991 
09992             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d8/d6/sertl_8c.html#a27">RtlpCreateServerAcl</a>(
09993                          NewDacl,
09994                          DaclUntrusted,
09995                          ServerOwner,
09996                          &amp;ServerDacl,
09997                          &amp;ServerDaclAllocated
09998                          );
09999 
10000             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
10001                 <span class="keywordflow">goto</span> Cleanup;
10002             }
10003 
10004             NewDacl = ServerDacl;
10005         }
10006     }
10007 
10008 
10009     <span class="comment">//</span>
10010     <span class="comment">// Everything is assignable by the requestor.</span>
10011     <span class="comment">// Calculate the memory needed to house all the information in</span>
10012     <span class="comment">// a self-relative security descriptor.</span>
10013     <span class="comment">//</span>
10014     <span class="comment">// Also map the ACEs for application to the target object</span>
10015     <span class="comment">// type, if they haven't already been mapped.</span>
10016     <span class="comment">//</span>
10017 
10018     NewOwnerSize = LongAlignSize(<a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>(NewOwner));
10019     <span class="keywordflow">if</span> (NewGroup != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
10020         NewGroupSize = LongAlignSize(<a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>(NewGroup));
10021     }
10022 
10023     <span class="keywordflow">if</span> ((NewControlBits &amp; SE_SACL_PRESENT) &amp;&amp; (NewSacl != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
10024         NewSaclSize = LongAlignSize(NewSacl-&gt;AclSize);
10025     } <span class="keywordflow">else</span> {
10026         NewSaclSize = 0;
10027     }
10028 
10029     <span class="keywordflow">if</span> ( (NewControlBits &amp; SE_DACL_PRESENT) &amp;&amp; (NewDacl != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
10030         NewDaclSize = LongAlignSize(NewDacl-&gt;AclSize);
10031     } <span class="keywordflow">else</span> {
10032         NewDaclSize = 0;
10033     }
10034 
10035     AllocationSize = LongAlignSize(<span class="keyword">sizeof</span>(SECURITY_DESCRIPTOR_RELATIVE)) +
10036                      NewOwnerSize +
10037                      NewGroupSize +
10038                      NewSaclSize  +
10039                      NewDaclSize;
10040 
10041     <span class="comment">//</span>
10042     <span class="comment">// Allocate and initialize the security descriptor as</span>
10043     <span class="comment">// self-relative form.</span>
10044     <span class="comment">//</span>
10045 
10046 <span class="preprocessor">#ifdef NTOS_KERNEL_RUNTIME</span>
10047 <span class="preprocessor"></span>    INewDescriptor = (PSECURITY_DESCRIPTOR)<a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>, AllocationSize, 'dSeS');
10048 <span class="preprocessor">#else // NTOS_KERNEL_RUNTIME</span>
10049 <span class="preprocessor"></span>    INewDescriptor = <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a0">RtlAllocateHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, <a class="code" href="../../d9/d2/ldrp_8h.html#a11">MAKE_TAG</a>( <a class="code" href="../../d9/d2/ldrp_8h.html#a17">SE_TAG</a> ), AllocationSize );
10050 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
10051 <span class="preprocessor"></span>
10052     <span class="keywordflow">if</span> ( INewDescriptor == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
10053 <span class="preprocessor">#ifdef NTOS_KERNEL_RUNTIME</span>
10054 <span class="preprocessor"></span>        <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INSUFFICIENT_RESOURCES;
10055 <span class="preprocessor">#else // NTOS_KERNEL_RUNTIME</span>
10056 <span class="preprocessor"></span>        <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_NO_MEMORY;
10057 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
10058 <span class="preprocessor"></span>        <span class="keywordflow">goto</span> Cleanup;
10059     }
10060 
10061     <a class="code" href="../../d8/d6/sertl_8c.html#a54">RtlCreateSecurityDescriptorRelative</a>(
10062         INewDescriptor,
10063         SECURITY_DESCRIPTOR_REVISION
10064         );
10065 
10066     RtlpSetControlBits( INewDescriptor, NewControlBits );
10067 
10068     Base = (PCHAR)(INewDescriptor);
10069     Field =  Base + <span class="keyword">sizeof</span>(SECURITY_DESCRIPTOR_RELATIVE);
10070 
10071     <span class="comment">//</span>
10072     <span class="comment">// Map and Copy in the Sacl</span>
10073     <span class="comment">//</span>
10074 
10075     <span class="keywordflow">if</span> (NewControlBits &amp; SE_SACL_PRESENT) {
10076 
10077         <span class="keywordflow">if</span> (NewSacl != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
10078 
10079             RtlCopyMemory( Field, NewSacl, NewSacl-&gt;AclSize );
10080 
10081             <span class="keywordflow">if</span> (!NewSaclInherited) {
10082                 <a class="code" href="../../d8/d6/sertl_8c.html#a73">RtlpApplyAclToObject</a>( (PACL)Field, GenericMapping );
10083             }
10084 
10085             INewDescriptor-&gt;Sacl = RtlPointerToOffset(Base,Field);
10086             Field += NewSaclSize;
10087 
10088         } <span class="keywordflow">else</span> {
10089 
10090             INewDescriptor-&gt;Sacl = 0;
10091         }
10092 
10093     }
10094 
10095     <span class="comment">//</span>
10096     <span class="comment">// Map and Copy in the Dacl</span>
10097     <span class="comment">//</span>
10098 
10099     <span class="keywordflow">if</span> (NewControlBits &amp; SE_DACL_PRESENT) {
10100 
10101         <span class="keywordflow">if</span> (NewDacl != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
10102 
10103             RtlCopyMemory( Field, NewDacl, NewDacl-&gt;AclSize );
10104 
10105             <span class="keywordflow">if</span> (!NewDaclInherited) {
10106                 <a class="code" href="../../d8/d6/sertl_8c.html#a73">RtlpApplyAclToObject</a>( (PACL)Field, GenericMapping );
10107             }
10108 
10109             INewDescriptor-&gt;Dacl = RtlPointerToOffset(Base,Field);
10110             Field += NewDaclSize;
10111 
10112         } <span class="keywordflow">else</span> {
10113 
10114             INewDescriptor-&gt;Dacl = 0;
10115         }
10116 
10117     }
10118 
10119     <span class="comment">//</span>
10120     <span class="comment">// Assign the owner</span>
10121     <span class="comment">//</span>
10122 
10123     RtlCopyMemory( Field, NewOwner, <a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>(NewOwner) );
10124     INewDescriptor-&gt;Owner = RtlPointerToOffset(Base,Field);
10125     Field += NewOwnerSize;
10126 
10127     <span class="keywordflow">if</span> (NewGroup != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
10128         RtlCopyMemory( Field, NewGroup, <a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>(NewGroup) );
10129         INewDescriptor-&gt;Group = RtlPointerToOffset(Base,Field);
10130     }
10131 
10132     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
10133 
10134 
10135 
10136 Cleanup:
10137     <span class="comment">//</span>
10138     <span class="comment">// If we allocated memory for a Server DACL, free it now.</span>
10139     <span class="comment">//</span>
10140 
10141     <span class="keywordflow">if</span> (ServerDaclAllocated) {
10142 <span class="preprocessor">#ifdef NTOS_KERNEL_RUNTIME</span>
10143 <span class="preprocessor"></span>        <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( ServerDacl );
10144 <span class="preprocessor">#else // NTOS_KERNEL_RUNTIME</span>
10145 <span class="preprocessor"></span>        <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>(RtlProcessHeap(), 0, ServerDacl );
10146 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
10147 <span class="preprocessor"></span>    }
10148 
10149     <span class="comment">//</span>
10150     <span class="comment">// Either an error was encountered or the assignment has completed</span>
10151     <span class="comment">// successfully.  In either case, we have to clean up any memory.</span>
10152     <span class="comment">//</span>
10153 
10154 <span class="preprocessor">#ifdef NTOS_KERNEL_RUNTIME</span>
10155 <span class="preprocessor"></span><span class="comment">//     if ( SubjectSecurityContext != NULL ) {</span>
10156 <span class="comment">//         SeUnlockSubjectContext( SubjectSecurityContext );</span>
10157 <span class="comment">//     }</span>
10158 
10159     <span class="keywordflow">if</span> (SubjectContextInfo != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
10160         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( SubjectContextInfo );
10161     }
10162 
10163 <span class="preprocessor">#else // NTOS_KERNEL_RUNTIME</span>
10164 <span class="preprocessor"></span>    <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, 0, (PVOID)TokenOwnerInfo );
10165     <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, 0, (PVOID)TokenPrimaryGroupInfo );
10166     <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, 0, (PVOID)TokenDefaultDaclInfo );
10167     <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, 0, (PVOID)ServerOwnerInfo );
10168     <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, 0, (PVOID)ServerGroupInfo );
10169 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
10170 <span class="preprocessor"></span>
10171     <span class="keywordflow">if</span> (NewSaclInherited &amp;&amp; NewSacl != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
10172 <span class="preprocessor">#ifdef NTOS_KERNEL_RUNTIME</span>
10173 <span class="preprocessor"></span>        <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( NewSacl );
10174 <span class="preprocessor">#else // NTOS_KERNEL_RUNTIME</span>
10175 <span class="preprocessor"></span>        <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, 0, (PVOID)NewSacl );
10176 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
10177 <span class="preprocessor"></span>    }
10178 
10179     <span class="keywordflow">if</span> (NewDaclInherited &amp;&amp; NewDacl != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
10180 <span class="preprocessor">#ifdef NTOS_KERNEL_RUNTIME</span>
10181 <span class="preprocessor"></span>        <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( NewDacl );
10182 <span class="preprocessor">#else // NTOS_KERNEL_RUNTIME</span>
10183 <span class="preprocessor"></span>        <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, 0, (PVOID)NewDacl );
10184 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
10185 <span class="preprocessor"></span>    }
10186 
10187     *NewDescriptor = (PSECURITY_DESCRIPTOR) INewDescriptor;
10188 
10189 
10190     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
10191 }
10192 
10193 
10194 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l10195"></a><a class="code" href="../../d8/d6/sertl_8c.html#a77">10195</a> <a class="code" href="../../d8/d6/sertl_8c.html#a77">RtlpSetSecurityObject</a> (
10196     IN PVOID Object OPTIONAL,
10197     IN SECURITY_INFORMATION SecurityInformation,
10198     IN PSECURITY_DESCRIPTOR ModificationDescriptor,
10199     IN OUT PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
10200     IN ULONG AutoInheritFlags,
10201     IN ULONG PoolType,
10202     IN PGENERIC_MAPPING GenericMapping,
10203     IN HANDLE Token OPTIONAL
10204     )
10205 
10206 
10207 <span class="comment">/*++</span>
10208 <span class="comment"></span>
10209 <span class="comment">Routine Description:</span>
10210 <span class="comment"></span>
10211 <span class="comment">    Modify an object's existing self-relative form security descriptor.</span>
10212 <span class="comment"></span>
10213 <span class="comment">    This procedure, called only from user mode, is used to update a</span>
10214 <span class="comment">    security descriptor on an existing protected server's object.  It</span>
10215 <span class="comment">    applies changes requested by a new security descriptor to the existing</span>
10216 <span class="comment">    security descriptor.  If necessary, this routine will allocate</span>
10217 <span class="comment">    additional memory to produce a larger security descriptor.  All access</span>
10218 <span class="comment">    checking is expected to be done before calling this routine.  This</span>
10219 <span class="comment">    includes checking for WRITE_OWNER, WRITE_DAC, and privilege to assign a</span>
10220 <span class="comment">    system ACL as appropriate.</span>
10221 <span class="comment"></span>
10222 <span class="comment">    The caller of this routine must not be impersonating a client.</span>
10223 <span class="comment"></span>
10224 <span class="comment">                                  - - WARNING - -</span>
10225 <span class="comment"></span>
10226 <span class="comment">    This service is for use by protected subsystems that project their own</span>
10227 <span class="comment">    type of object.  This service is explicitly not for use by the</span>
10228 <span class="comment">    executive for executive objects and must not be called from kernel</span>
10229 <span class="comment">    mode.</span>
10230 <span class="comment"></span>
10231 <span class="comment">Arguments:</span>
10232 <span class="comment"></span>
10233 <span class="comment">    Object - Optionally supplies the object whose security is</span>
10234 <span class="comment">        being adjusted.  This is used to update security quota</span>
10235 <span class="comment">        information.</span>
10236 <span class="comment"></span>
10237 <span class="comment">    SecurityInformation - Indicates which security information is</span>
10238 <span class="comment">        to be applied to the object.  The value(s) to be assigned are</span>
10239 <span class="comment">        passed in the ModificationDescriptor parameter.</span>
10240 <span class="comment"></span>
10241 <span class="comment">    ModificationDescriptor - Supplies the input security descriptor to be</span>
10242 <span class="comment">        applied to the object.  The caller of this routine is expected</span>
10243 <span class="comment">        to probe and capture the passed security descriptor before calling</span>
10244 <span class="comment">        and release it after calling.</span>
10245 <span class="comment"></span>
10246 <span class="comment">    ObjectsSecurityDescriptor - Supplies the address of a pointer to</span>
10247 <span class="comment">        the objects security descriptor that is going to be altered by</span>
10248 <span class="comment">        this procedure.  This security descriptor must be in self-</span>
10249 <span class="comment">        relative form or an error will be returned.</span>
10250 <span class="comment"></span>
10251 <span class="comment">    AutoInheritFlags - Controls automatic inheritance of ACES.</span>
10252 <span class="comment">        Valid values are a bits mask of the logical OR of</span>
10253 <span class="comment">        one or more of the following bits:</span>
10254 <span class="comment"></span>
10255 <span class="comment">        SEF_DACL_AUTO_INHERIT - If set, inherited ACEs from the</span>
10256 <span class="comment">            DACL in the ObjectsSecurityDescriptor are preserved and inherited ACEs from</span>
10257 <span class="comment">            the ModificationDescriptor are ignored. Inherited ACEs are not supposed</span>
10258 <span class="comment">            to be modified; so preserving them across this call is appropriate.</span>
10259 <span class="comment">            If a protected server does not itself implement auto inheritance, it should</span>
10260 <span class="comment">            not set this bit.  The caller of the protected server may implement</span>
10261 <span class="comment">            auto inheritance and my indeed be modifying inherited ACEs.</span>
10262 <span class="comment"></span>
10263 <span class="comment">        SEF_SACL_AUTO_INHERIT - If set, inherited ACEs from the</span>
10264 <span class="comment">            SACL in the ObjectsSecurityDescriptor are preserved and inherited ACEs from</span>
10265 <span class="comment">            the ModificationDescriptor are ignored. Inherited ACEs are not supposed</span>
10266 <span class="comment">            to be modified; so preserving them across this call is appropriate.</span>
10267 <span class="comment">            If a protected server does not itself implement auto inheritance, it should</span>
10268 <span class="comment">            not set this bit.  The caller of the protected server may implement</span>
10269 <span class="comment">            auto inheritance and my indeed be modifying inherited ACEs.</span>
10270 <span class="comment"></span>
10271 <span class="comment">         SEF_AVOID_PRIVILEGE_CHECK - If set, the Token in not used to ensure the</span>
10272 <span class="comment">            Owner passed in ModificationDescriptor is valid.</span>
10273 <span class="comment"></span>
10274 <span class="comment">    PoolType - Specifies the type of pool to allocate for the objects</span>
10275 <span class="comment">        security descriptor.</span>
10276 <span class="comment"></span>
10277 <span class="comment">    GenericMapping - This argument provides the mapping of generic to</span>
10278 <span class="comment">        specific/standard access types for the object being accessed.</span>
10279 <span class="comment">        This mapping structure is expected to be safe to access</span>
10280 <span class="comment">        (i.e., captured if necessary) prior to be passed to this routine.</span>
10281 <span class="comment"></span>
10282 <span class="comment">    Token - (optionally) Supplies the token for the client on whose</span>
10283 <span class="comment">        behalf the security is being modified.  This parameter is only</span>
10284 <span class="comment">        required to ensure that the client has provided a legitimate</span>
10285 <span class="comment">        value for a new owner SID.  The token must be open for</span>
10286 <span class="comment">        TOKEN_QUERY access.</span>
10287 <span class="comment"></span>
10288 <span class="comment">Return Value:</span>
10289 <span class="comment"></span>
10290 <span class="comment">    STATUS_SUCCESS - The operation was successful.</span>
10291 <span class="comment"></span>
10292 <span class="comment">    STATUS_INVALID_OWNER - The owner SID provided as the new owner of the</span>
10293 <span class="comment">        target security descriptor is not one the caller is authorized to</span>
10294 <span class="comment">        assign as the owner of an object, or the client did not pass</span>
10295 <span class="comment">        a token at all.</span>
10296 <span class="comment"></span>
10297 <span class="comment">    STATUS_NO_CLIENT_TOKEN - Indicates a client token was not explicitly</span>
10298 <span class="comment">        provided and the caller is not currently impersonating a client.</span>
10299 <span class="comment"></span>
10300 <span class="comment">    STATUS_BAD_DESCRIPTOR_FORMAT - Indicates the provided object's security</span>
10301 <span class="comment">        descriptor was not in self-relative format.</span>
10302 <span class="comment"></span>
10303 <span class="comment">--*/</span>
10304 
10305 {
10306     BOOLEAN NewGroupPresent = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
10307     BOOLEAN NewOwnerPresent = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
10308 
10309     BOOLEAN ServerAclAllocated = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
10310     BOOLEAN LocalDaclAllocated = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
10311     BOOLEAN LocalSaclAllocated = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
10312     BOOLEAN ServerObject;
10313     BOOLEAN DaclUntrusted;
10314 
10315     PCHAR Field;
10316     PCHAR Base;
10317 
10318     PISECURITY_DESCRIPTOR_RELATIVE NewDescriptor = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
10319 
10320     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
10321 
10322     TOKEN_STATISTICS ThreadTokenStatistics;
10323 
10324     ULONG ReturnLength;
10325 
10326     PSID NewGroup;
10327     PSID NewOwner;
10328 
10329     PACL NewDacl;
10330     PACL LocalDacl;
10331     PACL NewSacl;
10332     PACL LocalSacl;
10333 
10334     ULONG NewDaclSize;
10335     ULONG NewSaclSize;
10336     ULONG NewOwnerSize;
10337     ULONG NewGroupSize;
10338     ULONG AllocationSize;
10339     ULONG ServerOwnerInfoSize;
10340 
10341     HANDLE <a class="code" href="../../d6/d0/ctaccess_8c.html#a31">PrimaryToken</a>;
10342     ULONG GenericControl;
10343     ULONG NewControlBits = SE_SELF_RELATIVE;
10344 
10345     PACL ServerDacl;
10346 
10347     <a class="code" href="../../d0/d1/struct__SECURITY__SUBJECT__CONTEXT.html">SECURITY_SUBJECT_CONTEXT</a> SubjectContext;
10348 
10349 
10350     <span class="comment">//</span>
10351     <span class="comment">// Typecast to internal representation of security descriptor.</span>
10352     <span class="comment">// Note that the internal one is not a pointer to a pointer.</span>
10353     <span class="comment">// It is just a pointer to a security descriptor.</span>
10354     <span class="comment">//</span>
10355     PISECURITY_DESCRIPTOR IModificationDescriptor =
10356        (PISECURITY_DESCRIPTOR)ModificationDescriptor;
10357 
10358     PISECURITY_DESCRIPTOR *IObjectsSecurityDescriptor =
10359        (PISECURITY_DESCRIPTOR *)(ObjectsSecurityDescriptor);
10360 
10361 <span class="preprocessor">#ifndef NTOS_KERNEL_RUNTIME</span>
10362 <span class="preprocessor"></span>    PVOID <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
10363 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
10364 <span class="preprocessor"></span>
10365     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
10366 
10367     <span class="comment">//</span>
10368     <span class="comment">// Get the handle to the current process heap</span>
10369     <span class="comment">//</span>
10370 
10371 <span class="preprocessor">#ifndef NTOS_KERNEL_RUNTIME</span>
10372 <span class="preprocessor"></span>    <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a> = RtlProcessHeap();
10373 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
10374 <span class="preprocessor"></span>
10375     <span class="comment">//</span>
10376     <span class="comment">//  Validate that the provided SD is in self-relative form</span>
10377     <span class="comment">//</span>
10378 
10379     <span class="keywordflow">if</span> ( !RtlpAreControlBitsSet(*IObjectsSecurityDescriptor, SE_SELF_RELATIVE) ) {
10380         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_BAD_DESCRIPTOR_FORMAT;
10381         <span class="keywordflow">goto</span> Cleanup;
10382     }
10383 
10384     <span class="comment">//</span>
10385     <span class="comment">// Check to see if we need to edit the passed acl</span>
10386     <span class="comment">// either because we're creating a server object, or because</span>
10387     <span class="comment">// we were passed an untrusted ACL.</span>
10388     <span class="comment">//</span>
10389 
10390     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(ModificationDescriptor)) {
10391 
10392         <span class="keywordflow">if</span> ( RtlpAreControlBitsSet(IModificationDescriptor, SE_SERVER_SECURITY)) {
10393             ServerObject = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
10394         } <span class="keywordflow">else</span> {
10395             ServerObject = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
10396         }
10397 
10398         <span class="keywordflow">if</span> ( RtlpAreControlBitsSet(IModificationDescriptor, SE_DACL_UNTRUSTED)) {
10399             DaclUntrusted = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
10400         } <span class="keywordflow">else</span> {
10401             DaclUntrusted = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
10402         }
10403 
10404     } <span class="keywordflow">else</span> {
10405 
10406         ServerObject = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
10407         DaclUntrusted = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
10408 
10409     }
10410 
10411 
10412     <span class="comment">//</span>
10413     <span class="comment">// For each item specified in the SecurityInformation, extract it</span>
10414     <span class="comment">// and get it to the point where it can be copied into a new</span>
10415     <span class="comment">// descriptor.</span>
10416     <span class="comment">//</span>
10417 
10418     <span class="comment">//</span>
10419     <span class="comment">// if he's setting the owner field, make sure he's</span>
10420     <span class="comment">// allowed to set that value as an owner.</span>
10421     <span class="comment">//</span>
10422 
10423     <span class="keywordflow">if</span> (SecurityInformation &amp; OWNER_SECURITY_INFORMATION) {
10424 
10425         NewOwner = RtlpOwnerAddrSecurityDescriptor( IModificationDescriptor );
10426         NewOwnerPresent = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
10427 
10428         <span class="keywordflow">if</span> ((AutoInheritFlags &amp; SEF_AVOID_PRIVILEGE_CHECK) == 0 ) {
10429 
10430 <span class="preprocessor">#ifdef NTOS_KERNEL_RUNTIME</span>
10431 <span class="preprocessor"></span>
10432             <a class="code" href="../../d0/d8/subject_8c.html#a0">SeCaptureSubjectContext</a>( &amp;SubjectContext );
10433 
10434             <span class="keywordflow">if</span> (!<a class="code" href="../../d0/d8/subject_8c.html#a6">SepValidOwnerSubjectContext</a>( &amp;SubjectContext, NewOwner, ServerObject ) ) {
10435 
10436                 <a class="code" href="../../d0/d8/subject_8c.html#a3">SeReleaseSubjectContext</a>( &amp;SubjectContext );
10437                 <span class="keywordflow">return</span>( STATUS_INVALID_OWNER );
10438 
10439             } <span class="keywordflow">else</span> {
10440 
10441                 <a class="code" href="../../d0/d8/subject_8c.html#a3">SeReleaseSubjectContext</a>( &amp;SubjectContext );
10442             }
10443 <span class="preprocessor">#else // NTOS_KERNEL_RUNTIME</span>
10444 <span class="preprocessor"></span>
10445             <span class="keywordflow">if</span> ( ARGUMENT_PRESENT( <a class="code" href="../../d6/d0/ctaccess_8c.html#a29">Token</a> )) {
10446 
10447                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d3/tokenqry_8c.html#a0">NtQueryInformationToken</a>(
10448                              <a class="code" href="../../d6/d0/ctaccess_8c.html#a29">Token</a>,                        <span class="comment">// Handle</span>
10449                              TokenStatistics,              <span class="comment">// TokenInformationClass</span>
10450                              &amp;ThreadTokenStatistics,       <span class="comment">// TokenInformation</span>
10451                              <span class="keyword">sizeof</span>(TOKEN_STATISTICS),     <span class="comment">// TokenInformationLength</span>
10452                              &amp;ReturnLength                 <span class="comment">// ReturnLength</span>
10453                              );
10454 
10455                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
10456                     <span class="keywordflow">goto</span> Cleanup;
10457                 }
10458 
10459                 <span class="comment">//</span>
10460                 <span class="comment">//  If it is an impersonation token, then make sure it is at a</span>
10461                 <span class="comment">//  high enough level.</span>
10462                 <span class="comment">//</span>
10463 
10464                 <span class="keywordflow">if</span> (ThreadTokenStatistics.TokenType == TokenImpersonation) {
10465 
10466                     <span class="keywordflow">if</span> (ThreadTokenStatistics.ImpersonationLevel &lt; SecurityIdentification ) {
10467                         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_BAD_IMPERSONATION_LEVEL;
10468                         <span class="keywordflow">goto</span> Cleanup;
10469                     }
10470                 }
10471 
10472             } <span class="keywordflow">else</span> {
10473 
10474                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_OWNER;
10475                 <span class="keywordflow">goto</span> Cleanup;
10476             }
10477 
10478             <span class="keywordflow">if</span> (!<a class="code" href="../../d8/d6/sertl_8c.html#a72">RtlpValidOwnerSubjectContext</a>(
10479                     <a class="code" href="../../d6/d0/ctaccess_8c.html#a29">Token</a>,
10480                     NewOwner,
10481                     ServerObject,
10482                     &amp;<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>) ) {
10483 
10484                     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_OWNER;
10485                     <span class="keywordflow">goto</span> Cleanup;
10486             }
10487 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
10488 <span class="preprocessor"></span>        }
10489 
10490     } <span class="keywordflow">else</span> {
10491 
10492         NewOwner = RtlpOwnerAddrSecurityDescriptor ( *IObjectsSecurityDescriptor );
10493         <span class="keywordflow">if</span> (NewOwner == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
10494             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_OWNER;
10495             <span class="keywordflow">goto</span> Cleanup;
10496         }
10497 
10498     }
10499     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( NewOwner != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
10500     <span class="keywordflow">if</span> (!<a class="code" href="../../d8/d6/sertl_8c.html#a35">RtlValidSid</a>( NewOwner )) {
10501         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_OWNER;
10502         <span class="keywordflow">goto</span> Cleanup;
10503     }
10504 
10505 
10506     <span class="keywordflow">if</span> (SecurityInformation &amp; GROUP_SECURITY_INFORMATION) {
10507 
10508         NewGroup = RtlpGroupAddrSecurityDescriptor(IModificationDescriptor);
10509         NewGroupPresent = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
10510 
10511     } <span class="keywordflow">else</span> {
10512 
10513         NewGroup = RtlpGroupAddrSecurityDescriptor( *IObjectsSecurityDescriptor );
10514     }
10515 
10516     <span class="keywordflow">if</span> (NewGroup != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
10517         <span class="keywordflow">if</span> (!<a class="code" href="../../d8/d6/sertl_8c.html#a35">RtlValidSid</a>( NewGroup )) {
10518             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_PRIMARY_GROUP;
10519             <span class="keywordflow">goto</span> Cleanup;
10520         }
10521     } <span class="keywordflow">else</span> {
10522         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_PRIMARY_GROUP;
10523         <span class="keywordflow">goto</span> Cleanup;
10524     }
10525 
10526 
10527     <span class="keywordflow">if</span> (SecurityInformation &amp; DACL_SECURITY_INFORMATION) {
10528 
10529         <span class="comment">//</span>
10530         <span class="comment">// If AutoInherit is requested,</span>
10531         <span class="comment">//  build a merged ACL.</span>
10532         <span class="comment">//</span>
10533 
10534         <span class="keywordflow">if</span> ( AutoInheritFlags &amp; SEF_DACL_AUTO_INHERIT ) {
10535             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d8/d6/sertl_8c.html#a21">RtlpComputeMergedAcl</a>(
10536                         RtlpDaclAddrSecurityDescriptor( *IObjectsSecurityDescriptor ),
10537                         SeControlDaclToGeneric( (*IObjectsSecurityDescriptor)-&gt;Control ),
10538                         RtlpDaclAddrSecurityDescriptor( IModificationDescriptor ),
10539                         SeControlDaclToGeneric( IModificationDescriptor-&gt;Control ),
10540                         NewOwner,
10541                         NewGroup,
10542                         GenericMapping,
10543                         <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,      <span class="comment">// Not a SACL</span>
10544                         &amp;LocalDacl,
10545                         &amp;GenericControl );
10546 
10547             <span class="keywordflow">if</span> ( !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
10548                 <span class="keywordflow">goto</span> Cleanup;
10549             }
10550 
10551             LocalDaclAllocated = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
10552             NewDacl = LocalDacl;
10553             NewControlBits |= SE_DACL_PRESENT;
10554             NewControlBits |= SeControlGenericToDacl( GenericControl );
10555 
10556         <span class="comment">//</span>
10557         <span class="comment">// If AutoInherit isn't requested,</span>
10558         <span class="comment">//  just grab a copy of the input DACL.</span>
10559         <span class="comment">//</span>
10560 
10561         } <span class="keywordflow">else</span> {
10562             NewDacl = RtlpDaclAddrSecurityDescriptor( IModificationDescriptor );
10563             NewControlBits |= SE_DACL_PRESENT;
10564             NewControlBits |= IModificationDescriptor-&gt;Control &amp; SE_DACL_PROTECTED;
10565 
10566             <span class="comment">//</span>
10567             <span class="comment">// If the original caller claims he understands auto inheritance,</span>
10568             <span class="comment">//  preserve the AutoInherited flag.</span>
10569             <span class="comment">//</span>
10570 
10571             <span class="keywordflow">if</span> ( RtlpAreControlBitsSet(IModificationDescriptor, SE_DACL_AUTO_INHERIT_REQ|SE_DACL_AUTO_INHERITED) ) {
10572                 NewControlBits |= SE_DACL_AUTO_INHERITED;
10573             }
10574         }
10575 
10576         <span class="keywordflow">if</span> (ServerObject) {
10577 
10578 <span class="preprocessor">#ifdef NTOS_KERNEL_RUNTIME</span>
10579 <span class="preprocessor"></span>
10580             PSID SubjectContextOwner;
10581             PSID SubjectContextGroup;
10582             PSID SubjectContextServerOwner;
10583             PSID SubjectContextServerGroup;
10584             PACL SubjectContextDacl;
10585 
10586             <a class="code" href="../../d0/d8/subject_8c.html#a0">SeCaptureSubjectContext</a>( &amp;SubjectContext );
10587 
10588             <a class="code" href="../../d0/d8/subject_8c.html#a4">SepGetDefaultsSubjectContext</a>(
10589                 &amp;SubjectContext,
10590                 &amp;SubjectContextOwner,
10591                 &amp;SubjectContextGroup,
10592                 &amp;SubjectContextServerOwner,
10593                 &amp;SubjectContextServerGroup,
10594                 &amp;SubjectContextDacl
10595                 );
10596 
10597             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d8/d6/sertl_8c.html#a27">RtlpCreateServerAcl</a>(
10598                          NewDacl,
10599                          DaclUntrusted,
10600                          SubjectContextServerOwner,
10601                          &amp;ServerDacl,
10602                          &amp;ServerAclAllocated
10603                          );
10604 
10605             <a class="code" href="../../d0/d8/subject_8c.html#a3">SeReleaseSubjectContext</a>( &amp;SubjectContext );
10606 <span class="preprocessor">#else // NTOS_KERNEL_RUNTIME</span>
10607 <span class="preprocessor"></span>            PTOKEN_OWNER ServerSid;
10608 
10609             <span class="comment">//</span>
10610             <span class="comment">// Obtain the default Server SID to substitute in the</span>
10611             <span class="comment">// ACL if necessary.</span>
10612             <span class="comment">//</span>
10613 
10614             ServerOwnerInfoSize = <a class="code" href="../../d8/d6/sertl_8c.html#a38">RtlLengthRequiredSid</a>( SID_MAX_SUB_AUTHORITIES );
10615 
10616             ServerSid = <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a0">RtlAllocateHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, <a class="code" href="../../d9/d2/ldrp_8h.html#a11">MAKE_TAG</a>( <a class="code" href="../../d9/d2/ldrp_8h.html#a17">SE_TAG</a> ), ServerOwnerInfoSize );
10617 
10618             <span class="keywordflow">if</span> (ServerSid == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
10619                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_NO_MEMORY;
10620                 <span class="keywordflow">goto</span> Cleanup;
10621             }
10622 
10623             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d7/d3/tokenopn_8c.html#a1">NtOpenProcessToken</a>(
10624                          NtCurrentProcess(),
10625                          TOKEN_QUERY,
10626                          &amp;<a class="code" href="../../d6/d0/ctaccess_8c.html#a31">PrimaryToken</a>
10627                          );
10628 
10629             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
10630                 <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, 0, ServerSid );
10631                 <span class="keywordflow">goto</span> Cleanup;
10632             }
10633 
10634             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d3/tokenqry_8c.html#a0">NtQueryInformationToken</a>(
10635                          <a class="code" href="../../d6/d0/ctaccess_8c.html#a31">PrimaryToken</a>,                 <span class="comment">// Handle</span>
10636                          TokenOwner,                   <span class="comment">// TokenInformationClass</span>
10637                          ServerSid,                    <span class="comment">// TokenInformation</span>
10638                          ServerOwnerInfoSize,          <span class="comment">// TokenInformationLength</span>
10639                          &amp;ServerOwnerInfoSize          <span class="comment">// ReturnLength</span>
10640                          );
10641 
10642             <a class="code" href="../../d5/d0/obclose_8c.html#a1">NtClose</a>( <a class="code" href="../../d6/d0/ctaccess_8c.html#a31">PrimaryToken</a> );
10643 
10644             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
10645                 <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, 0, ServerSid );
10646                 <span class="keywordflow">goto</span> Cleanup;
10647             }
10648 
10649             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d8/d6/sertl_8c.html#a27">RtlpCreateServerAcl</a>(
10650                          NewDacl,
10651                          DaclUntrusted,
10652                          ServerSid-&gt;Owner,
10653                          &amp;ServerDacl,
10654                          &amp;ServerAclAllocated
10655                          );
10656 
10657             <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, 0, ServerSid );
10658 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
10659 <span class="preprocessor"></span>
10660             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
10661                 <span class="keywordflow">goto</span> Cleanup;
10662             }
10663 
10664             NewDacl = ServerDacl;
10665 
10666         }
10667 
10668     } <span class="keywordflow">else</span> {
10669 
10670         NewDacl = RtlpDaclAddrSecurityDescriptor( *IObjectsSecurityDescriptor );
10671     }
10672 
10673 
10674 
10675     <span class="keywordflow">if</span> (SecurityInformation &amp; SACL_SECURITY_INFORMATION) {
10676 
10677 
10678         <span class="comment">//</span>
10679         <span class="comment">// If AutoInherit is requested,</span>
10680         <span class="comment">//  build a merged ACL.</span>
10681         <span class="comment">//</span>
10682 
10683         <span class="keywordflow">if</span> ( AutoInheritFlags &amp; SEF_SACL_AUTO_INHERIT ) {
10684             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d8/d6/sertl_8c.html#a21">RtlpComputeMergedAcl</a>(
10685                         RtlpSaclAddrSecurityDescriptor( *IObjectsSecurityDescriptor ),
10686                         SeControlSaclToGeneric( (*IObjectsSecurityDescriptor)-&gt;Control ),
10687                         RtlpSaclAddrSecurityDescriptor( IModificationDescriptor ),
10688                         SeControlSaclToGeneric( IModificationDescriptor-&gt;Control ),
10689                         NewOwner,
10690                         NewGroup,
10691                         GenericMapping,
10692                         <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,      <span class="comment">// Is a SACL</span>
10693                         &amp;LocalSacl,
10694                         &amp;GenericControl );
10695 
10696             <span class="keywordflow">if</span> ( !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
10697                 <span class="keywordflow">goto</span> Cleanup;
10698             }
10699             LocalSaclAllocated = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
10700             NewSacl = LocalSacl;
10701             NewControlBits |= SE_SACL_PRESENT;
10702             NewControlBits |= SeControlGenericToSacl( GenericControl );
10703         } <span class="keywordflow">else</span> {
10704             NewSacl = RtlpSaclAddrSecurityDescriptor( IModificationDescriptor );
10705             NewControlBits |= SE_SACL_PRESENT;
10706             NewControlBits |= IModificationDescriptor-&gt;Control &amp; SE_SACL_PROTECTED;
10707 
10708             <span class="comment">//</span>
10709             <span class="comment">// If the original caller claims he understands auto inheritance,</span>
10710             <span class="comment">//  preserve the AutoInherited flag.</span>
10711             <span class="comment">//</span>
10712 
10713             <span class="keywordflow">if</span> ( RtlpAreControlBitsSet(IModificationDescriptor, SE_SACL_AUTO_INHERIT_REQ|SE_SACL_AUTO_INHERITED) ) {
10714                 NewControlBits |= SE_SACL_AUTO_INHERITED;
10715             }
10716         }
10717 
10718     } <span class="keywordflow">else</span> {
10719 
10720         NewSacl = RtlpSaclAddrSecurityDescriptor( *IObjectsSecurityDescriptor );
10721     }
10722 
10723 
10724     <span class="comment">//</span>
10725     <span class="comment">// Everything is assignable by the requestor.</span>
10726     <span class="comment">// Calculate the memory needed to house all the information in</span>
10727     <span class="comment">// a self-relative security descriptor.</span>
10728     <span class="comment">//</span>
10729     <span class="comment">// Also map the ACEs for application to the target object</span>
10730     <span class="comment">// type, if they haven't already been mapped.</span>
10731     <span class="comment">//</span>
10732 
10733     NewOwnerSize = LongAlignSize(<a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>(NewOwner));
10734 
10735     <span class="keywordflow">if</span> (NewGroup != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
10736         NewGroupSize = LongAlignSize(<a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>(NewGroup));
10737     } <span class="keywordflow">else</span> {
10738         NewGroupSize = 0;
10739     }
10740 
10741     <span class="keywordflow">if</span> (NewSacl != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
10742         NewSaclSize = LongAlignSize(NewSacl-&gt;AclSize);
10743     } <span class="keywordflow">else</span> {
10744         NewSaclSize = 0;
10745     }
10746 
10747     <span class="keywordflow">if</span> (NewDacl !=<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
10748         NewDaclSize = LongAlignSize(NewDacl-&gt;AclSize);
10749     } <span class="keywordflow">else</span> {
10750         NewDaclSize = 0;
10751     }
10752 
10753     AllocationSize = LongAlignSize(<span class="keyword">sizeof</span>(SECURITY_DESCRIPTOR_RELATIVE)) +
10754                      NewOwnerSize +
10755                      NewGroupSize +
10756                      NewSaclSize  +
10757                      NewDaclSize;
10758 
10759     <span class="comment">//</span>
10760     <span class="comment">// Allocate and initialize the security descriptor as</span>
10761     <span class="comment">// self-relative form.</span>
10762     <span class="comment">//</span>
10763 
10764 <span class="preprocessor">#ifdef NTOS_KERNEL_RUNTIME</span>
10765 <span class="preprocessor"></span>    NewDescriptor = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>(PoolType, AllocationSize, 'dSeS');
10766 <span class="preprocessor">#else // NTOS_KERNEL_RUNTIME</span>
10767 <span class="preprocessor"></span>    NewDescriptor = <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a0">RtlAllocateHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, <a class="code" href="../../d9/d2/ldrp_8h.html#a11">MAKE_TAG</a>( <a class="code" href="../../d9/d2/ldrp_8h.html#a17">SE_TAG</a> ), AllocationSize );
10768 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
10769 <span class="preprocessor"></span>
10770     <span class="keywordflow">if</span> ( NewDescriptor == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
10771         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_NO_MEMORY;
10772         <span class="keywordflow">goto</span> Cleanup;
10773     }
10774 
10775     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d8/d6/sertl_8c.html#a54">RtlCreateSecurityDescriptorRelative</a>(
10776                  NewDescriptor,
10777                  SECURITY_DESCRIPTOR_REVISION
10778                  );
10779 
10780     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> ) );
10781 
10782 <span class="preprocessor">#ifdef NTOS_KERNEL_RUNTIME</span>
10783 <span class="preprocessor"></span>    <span class="comment">//</span>
10784     <span class="comment">// We must check to make sure that the Group and Dacl size</span>
10785     <span class="comment">// do not exceed the quota preallocated for this object's</span>
10786     <span class="comment">// security when it was created.</span>
10787     <span class="comment">//</span>
10788     <span class="comment">// Update SeComputeSecurityQuota if this changes.</span>
10789     <span class="comment">//</span>
10790 
10791 
10792     <span class="keywordflow">if</span> (ARGUMENT_PRESENT( Object )) {
10793 
10794         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d1/obse_8c.html#a10">ObValidateSecurityQuota</a>(
10795                      Object,
10796                      NewGroupSize + NewDaclSize
10797                      );
10798 
10799         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
10800 
10801             <span class="comment">//</span>
10802             <span class="comment">// The new information is too big.</span>
10803             <span class="comment">//</span>
10804 
10805             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( NewDescriptor );
10806             <span class="keywordflow">goto</span> Cleanup;
10807         }
10808 
10809     }
10810 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
10811 <span class="preprocessor"></span>
10812 
10813     Base = (PCHAR)NewDescriptor;
10814     Field =  Base + <span class="keyword">sizeof</span>(SECURITY_DESCRIPTOR_RELATIVE);
10815 
10816     <span class="comment">//</span>
10817     <span class="comment">// Map and Copy in the Sacl</span>
10818     <span class="comment">//</span>
10819 
10820 
10821     <span class="comment">//         if new item {</span>
10822     <span class="comment">//             PRESENT=TRUE</span>
10823     <span class="comment">//             DEFAULTED=FALSE</span>
10824     <span class="comment">//             if (NULL) {</span>
10825     <span class="comment">//                 set new pointer to NULL</span>
10826     <span class="comment">//             } else {</span>
10827     <span class="comment">//                 copy into new SD</span>
10828     <span class="comment">//             }</span>
10829     <span class="comment">//         } else {</span>
10830     <span class="comment">//             copy PRESENT bit</span>
10831     <span class="comment">//             copy DEFAULTED bit</span>
10832     <span class="comment">//             if (NULL) {</span>
10833     <span class="comment">//                 set new pointer to NULL</span>
10834     <span class="comment">//             } else {</span>
10835     <span class="comment">//                 copy old one into new SD</span>
10836     <span class="comment">//             }</span>
10837     <span class="comment">//         }</span>
10838 
10839     RtlpSetControlBits( NewDescriptor, NewControlBits );
10840 
10841 
10842     <span class="keywordflow">if</span> (IModificationDescriptor-&gt;Control &amp; SE_RM_CONTROL_VALID) {
10843         NewDescriptor-&gt;Sbz1 = IModificationDescriptor-&gt;Sbz1;
10844         NewDescriptor-&gt;Control |= SE_RM_CONTROL_VALID;
10845     }
10846 
10847     <span class="keywordflow">if</span> (NewSacl == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
10848         NewDescriptor-&gt;Sacl = 0;
10849 
10850     } <span class="keywordflow">else</span> {
10851         RtlCopyMemory( Field, NewSacl, NewSacl-&gt;AclSize );
10852         <a class="code" href="../../d8/d6/sertl_8c.html#a73">RtlpApplyAclToObject</a>( (PACL)Field, GenericMapping );
10853         NewDescriptor-&gt;Sacl = RtlPointerToOffset(Base,Field);
10854         Field += NewSaclSize;
10855     }
10856 
10857 
10858 
10859 
10860     <span class="keywordflow">if</span> ( (NewControlBits &amp; SE_SACL_PRESENT) == 0 ) {
10861 
10862         <span class="comment">//</span>
10863         <span class="comment">// Propagate the SE_SACL_DEFAULTED and SE_SACL_PRESENT</span>
10864         <span class="comment">// bits from the old security descriptor into the new</span>
10865         <span class="comment">// one.</span>
10866         <span class="comment">//</span>
10867 
10868         RtlpPropagateControlBits(
10869             NewDescriptor,
10870             *IObjectsSecurityDescriptor,
10871             SE_SACL_DEFAULTED | SE_SACL_PRESENT | SE_SACL_PROTECTED
10872             );
10873 
10874     }
10875 
10876 
10877 
10878     <span class="comment">//</span>
10879     <span class="comment">// Fill in Dacl field in new SD</span>
10880     <span class="comment">//</span>
10881 
10882     <span class="keywordflow">if</span> (NewDacl == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
10883         NewDescriptor-&gt;Dacl = 0;
10884 
10885     } <span class="keywordflow">else</span> {
10886         RtlCopyMemory( Field, NewDacl, NewDacl-&gt;AclSize );
10887         <a class="code" href="../../d8/d6/sertl_8c.html#a73">RtlpApplyAclToObject</a>( (PACL)Field, GenericMapping );
10888         NewDescriptor-&gt;Dacl = RtlPointerToOffset(Base,Field);
10889         Field += NewDaclSize;
10890     }
10891 
10892 
10893     <span class="keywordflow">if</span> ( (NewControlBits &amp; SE_DACL_PRESENT) == 0 ) {
10894 
10895         <span class="comment">//</span>
10896         <span class="comment">// Propagate the SE_DACL_DEFAULTED and SE_DACL_PRESENT</span>
10897         <span class="comment">// bits from the old security descriptor into the new</span>
10898         <span class="comment">// one.</span>
10899         <span class="comment">//</span>
10900 
10901         RtlpPropagateControlBits(
10902             NewDescriptor,
10903             *IObjectsSecurityDescriptor,
10904             SE_DACL_DEFAULTED | SE_DACL_PRESENT | SE_DACL_PROTECTED
10905             );
10906 
10907     }
10908 
10909 <span class="comment">//         if new item {</span>
10910 <span class="comment">//             PRESENT=TRUE</span>
10911 <span class="comment">//             DEFAULTED=FALSE</span>
10912 <span class="comment">//             if (NULL) {</span>
10913 <span class="comment">//                 set new pointer to NULL</span>
10914 <span class="comment">//             } else {</span>
10915 <span class="comment">//                 copy into new SD</span>
10916 <span class="comment">//             }</span>
10917 <span class="comment">//         } else {</span>
10918 <span class="comment">//             copy PRESENT bit</span>
10919 <span class="comment">//             copy DEFAULTED bit</span>
10920 <span class="comment">//             if (NULL) {</span>
10921 <span class="comment">//                 set new pointer to NULL</span>
10922 <span class="comment">//             } else {</span>
10923 <span class="comment">//                 copy old one into new SD</span>
10924 <span class="comment">//             }</span>
10925 <span class="comment">//         }</span>
10926 
10927 
10928     <span class="comment">//</span>
10929     <span class="comment">// Fill in Owner field in new SD</span>
10930     <span class="comment">//</span>
10931 
10932     RtlCopyMemory( Field, NewOwner, <a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>(NewOwner) );
10933     NewDescriptor-&gt;Owner = RtlPointerToOffset(Base,Field);
10934     Field += NewOwnerSize;
10935 
10936     <span class="keywordflow">if</span> (!NewOwnerPresent) {
10937 
10938         <span class="comment">//</span>
10939         <span class="comment">// Propagate the SE_OWNER_DEFAULTED bit from the old SD.</span>
10940         <span class="comment">// If a new owner is being assigned, we want to leave</span>
10941         <span class="comment">// SE_OWNER_DEFAULTED off, which means leave it alone.</span>
10942         <span class="comment">//</span>
10943 
10944         RtlpPropagateControlBits(
10945             NewDescriptor,
10946             *IObjectsSecurityDescriptor,
10947             SE_OWNER_DEFAULTED
10948             );
10949 
10950     } <span class="keywordflow">else</span> {
10951         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( !RtlpAreControlBitsSet( NewDescriptor, SE_OWNER_DEFAULTED ) );
10952     }
10953 
10954 
10955     <span class="comment">//</span>
10956     <span class="comment">// Fill in Group field in new SD</span>
10957     <span class="comment">//</span>
10958 
10959     <span class="keywordflow">if</span> ( NewGroup != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
10960         RtlCopyMemory( Field, NewGroup, <a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>(NewGroup) );
10961         NewDescriptor-&gt;Group = RtlPointerToOffset(Base,Field);
10962     }
10963 
10964     <span class="keywordflow">if</span> (!NewGroupPresent) {
10965 
10966         <span class="comment">//</span>
10967         <span class="comment">// Propagate the SE_GROUP_DEFAULTED bit from the old SD</span>
10968         <span class="comment">// If a new owner is being assigned, we want to leave</span>
10969         <span class="comment">// SE_GROUP_DEFAULTED off, which means leave it alone.</span>
10970         <span class="comment">//</span>
10971 
10972         RtlpPropagateControlBits(
10973             NewDescriptor,
10974             *IObjectsSecurityDescriptor,
10975             SE_GROUP_DEFAULTED
10976             );
10977     } <span class="keywordflow">else</span> {
10978         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( !RtlpAreControlBitsSet( NewDescriptor, SE_GROUP_DEFAULTED ) );
10979 
10980     }
10981 
10982     <span class="comment">//</span>
10983     <span class="comment">// Free old descriptor</span>
10984     <span class="comment">//</span>
10985 
10986     <span class="comment">// Kernel version doesn't free the old descriptor</span>
10987 <span class="preprocessor">#ifndef NTOS_KERNEL_RUNTIME</span>
10988 <span class="preprocessor"></span>    <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, 0, (PVOID) *IObjectsSecurityDescriptor );
10989 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
10990 <span class="preprocessor"></span>
10991     *ObjectsSecurityDescriptor = (PSECURITY_DESCRIPTOR)NewDescriptor;
10992     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
10993 
10994 Cleanup:
10995     <span class="keywordflow">if</span> ( LocalDaclAllocated ) {
10996 <span class="preprocessor">#ifdef NTOS_KERNEL_RUNTIME</span>
10997 <span class="preprocessor"></span>        <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( LocalDacl );
10998 <span class="preprocessor">#else // NTOS_KERNEL_RUNTIME</span>
10999 <span class="preprocessor"></span>        <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, 0, LocalDacl );
11000 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
11001 <span class="preprocessor"></span>    }
11002     <span class="keywordflow">if</span> ( LocalSaclAllocated ) {
11003 <span class="preprocessor">#ifdef NTOS_KERNEL_RUNTIME</span>
11004 <span class="preprocessor"></span>        <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( LocalSacl );
11005 <span class="preprocessor">#else // NTOS_KERNEL_RUNTIME</span>
11006 <span class="preprocessor"></span>        <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, 0, LocalSacl );
11007 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
11008 <span class="preprocessor"></span>    }
11009     <span class="keywordflow">if</span> (ServerAclAllocated) {
11010 <span class="preprocessor">#ifdef NTOS_KERNEL_RUNTIME</span>
11011 <span class="preprocessor"></span>        <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( ServerDacl );
11012 <span class="preprocessor">#else // NTOS_KERNEL_RUNTIME</span>
11013 <span class="preprocessor"></span>        <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, 0, ServerDacl );
11014 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
11015 <span class="preprocessor"></span>    }
11016 
11017     <span class="keywordflow">return</span>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> );
11018 }
11019 
<a name="l11020"></a><a class="code" href="../../d8/d6/sertl_8c.html#a29">11020</a> BOOLEAN <a class="code" href="../../d8/d6/sertl_8c.html#a29">RtlpValidateSDOffsetAndSize</a> (
11021     IN ULONG   Offset,
11022     IN ULONG   Length,
11023     IN ULONG   MinLength,
11024     OUT PULONG MaxLength
11025     )
11026 <span class="comment">/*++</span>
11027 <span class="comment"></span>
11028 <span class="comment">Routine Description:</span>
11029 <span class="comment"></span>
11030 <span class="comment">    This procedure validates offsets within a SecurityDescriptor.</span>
11031 <span class="comment">    It checks that the structure can have the minimum length,</span>
11032 <span class="comment">    not overlap with the fixed header and returns the maximum size</span>
11033 <span class="comment">    of the item and longword alignment.</span>
11034 <span class="comment"></span>
11035 <span class="comment">Arguments:</span>
11036 <span class="comment"></span>
11037 <span class="comment">    Offset - Offset from start of SD of structure to validate</span>
11038 <span class="comment">    Length - Total size of SD</span>
11039 <span class="comment">    MinLength - Minimum size this structure can be</span>
11040 <span class="comment">    MaxLength - Retuns the maximum length this item can be given by</span>
11041 <span class="comment">                the enclosing structure.</span>
11042 <span class="comment"></span>
11043 <span class="comment">Return Value:</span>
11044 <span class="comment"></span>
11045 <span class="comment">    BOOLEAN - TRUE if the item is valid</span>
11046 <span class="comment"></span>
11047 <span class="comment"></span>
11048 <span class="comment">--*/</span>
11049 
11050 {
11051     ULONG Left;
11052 
11053     *MaxLength = 0;
11054     <span class="comment">//</span>
11055     <span class="comment">// Don't allow overlap with header just in case caller modifies control bits etc</span>
11056     <span class="comment">//</span>
11057     <span class="keywordflow">if</span> (<a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> &lt; <span class="keyword">sizeof</span> (SECURITY_DESCRIPTOR_RELATIVE)) {
11058        <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
11059     }
11060 
11061     <span class="comment">//</span>
11062     <span class="comment">// Don't allow offsets beyond the end of the buffer</span>
11063     <span class="comment">//</span>
11064     <span class="keywordflow">if</span> (<a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> &gt;= Length) {
11065        <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
11066     }
11067 
11068     <span class="comment">//</span>
11069     <span class="comment">// Calculate maximim size of segment and check its limits</span>
11070     <span class="comment">//</span>
11071     Left = Length - <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>;
11072 
11073     <span class="keywordflow">if</span> (Left &lt; MinLength) {
11074        <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
11075     }
11076 
11077     <span class="comment">//</span>
11078     <span class="comment">// Reject unaligned offsets</span>
11079     <span class="comment">//</span>
11080     <span class="keywordflow">if</span> (<a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> &amp; (<span class="keyword">sizeof</span> (ULONG) - 1)) {
11081        <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
11082     }
11083     *MaxLength = Left;
11084     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
11085 }
11086 
11087 
11088 BOOLEAN
<a name="l11089"></a><a class="code" href="../../d8/d6/sertl_8c.html#a30">11089</a> <a class="code" href="../../d8/d6/sertl_8c.html#a30">RtlValidRelativeSecurityDescriptor</a> (
11090     IN PSECURITY_DESCRIPTOR SecurityDescriptorInput,
11091     IN ULONG SecurityDescriptorLength,
11092     IN SECURITY_INFORMATION RequiredInformation
11093     )
11094 
11095 <span class="comment">/*++</span>
11096 <span class="comment"></span>
11097 <span class="comment">Routine Description:</span>
11098 <span class="comment"></span>
11099 <span class="comment">    This procedure validates a SecurityDescriptor's structure</span>
11100 <span class="comment">    contained within a flat buffer.  This involves validating</span>
11101 <span class="comment">    the revision levels of each component of the security</span>
11102 <span class="comment">    descriptor.</span>
11103 <span class="comment"></span>
11104 <span class="comment">Arguments:</span>
11105 <span class="comment"></span>
11106 <span class="comment">    SecurityDescriptor - Pointer to the SECURITY_DESCRIPTOR structure</span>
11107 <span class="comment">        to validate.</span>
11108 <span class="comment">    SecurityDescriptorLength - Size of flat buffer containing the security</span>
11109 <span class="comment">        descriptor.</span>
11110 <span class="comment">    RequiredInformation - Which SD components must be present to be valid.</span>
11111 <span class="comment">        OWNER_SECURITY_INFORMATION etc as a bit mask.</span>
11112 <span class="comment">        OWNER_SECURITY_INFORMATION - There must be a valid owner SID</span>
11113 <span class="comment">        GROUP_SECURITY_INFORMATION - There must be a valid group SID</span>
11114 <span class="comment">        DACL_SECURITY_INFORMATION - Ignored</span>
11115 <span class="comment">        SACL_SECURITY_INFORMATION - Ignored</span>
11116 <span class="comment"></span>
11117 <span class="comment">Return Value:</span>
11118 <span class="comment"></span>
11119 <span class="comment">    BOOLEAN - TRUE if the structure of SecurityDescriptor is valid.</span>
11120 <span class="comment"></span>
11121 <span class="comment"></span>
11122 <span class="comment">--*/</span>
11123 
11124 {
11125     PISECURITY_DESCRIPTOR_RELATIVE SecurityDescriptor;
11126     PISID OwnerSid;
11127     PISID GroupSid;
11128     PACE_HEADER Ace;
11129     PACL <a class="code" href="../../d6/d0/ctaccess_8c.html#a55">Dacl</a>;
11130     PACL Sacl;
11131     ULONG MaxOwnerSidLength;
11132     ULONG MaxGroupSidLength;
11133     ULONG MaxDaclLength;
11134     ULONG MaxSaclLength;
11135 
11136     <span class="keywordflow">if</span> (SecurityDescriptorLength &lt; <span class="keyword">sizeof</span>(SECURITY_DESCRIPTOR_RELATIVE)) {
11137         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
11138     }
11139 
11140     <span class="comment">//</span>
11141     <span class="comment">// Check the revision information.</span>
11142     <span class="comment">//</span>
11143 
11144     <span class="keywordflow">if</span> (((PISECURITY_DESCRIPTOR) SecurityDescriptorInput)-&gt;Revision !=
11145              SECURITY_DESCRIPTOR_REVISION) {
11146         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
11147     }
11148 
11149     <span class="comment">//</span>
11150     <span class="comment">// Make sure the passed SecurityDescriptor is in self-relative form</span>
11151     <span class="comment">//</span>
11152 
11153     <span class="keywordflow">if</span> (!(((PISECURITY_DESCRIPTOR) SecurityDescriptorInput)-&gt;Control &amp; SE_SELF_RELATIVE)) {
11154         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
11155     }
11156 
11157     SecurityDescriptor = (PISECURITY_DESCRIPTOR_RELATIVE) SecurityDescriptorInput;
11158 
11159     <span class="comment">//</span>
11160     <span class="comment">// Validate the owner if it's there and see if its allowed to be missing</span>
11161     <span class="comment">//</span>
11162     <span class="keywordflow">if</span> (SecurityDescriptor-&gt;Owner == 0) {
11163         <span class="keywordflow">if</span> (RequiredInformation &amp; OWNER_SECURITY_INFORMATION) {
11164             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
11165         }
11166     } <span class="keywordflow">else</span> {
11167         <span class="keywordflow">if</span> (!<a class="code" href="../../d8/d6/sertl_8c.html#a29">RtlpValidateSDOffsetAndSize</a> (SecurityDescriptor-&gt;Owner,
11168                                           SecurityDescriptorLength,
11169                                           sizeof (SID),
11170                                           &amp;MaxOwnerSidLength)) {
11171             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
11172         }
11173         <span class="comment">//</span>
11174         <span class="comment">// It is safe to reference the owner's SubAuthorityCount, compute the</span>
11175         <span class="comment">// expected length of the SID</span>
11176         <span class="comment">//</span>
11177 
11178         OwnerSid = (PSID)RtlOffsetToPointer (SecurityDescriptor,
11179                                              SecurityDescriptor-&gt;Owner);
11180 
11181         <span class="keywordflow">if</span> (OwnerSid-&gt;Revision != SID_REVISION) {
11182             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
11183         }
11184 
11185         <span class="keywordflow">if</span> (OwnerSid-&gt;SubAuthorityCount &gt; SID_MAX_SUB_AUTHORITIES) {
11186             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
11187         }
11188 
11189         <span class="keywordflow">if</span> (MaxOwnerSidLength &lt; (ULONG) <a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a> (OwnerSid)) {
11190             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
11191         }
11192 
11193     }
11194 
11195     <span class="comment">//</span>
11196     <span class="comment">// The owner appears to be a structurally valid SID that lies within</span>
11197     <span class="comment">// the bounds of the security descriptor.  Do the same for the Group</span>
11198     <span class="comment">// if there is one.</span>
11199     <span class="comment">//</span>
11200     <span class="comment">//</span>
11201     <span class="comment">// Validate the group if it's there and see if its allowed to be missing</span>
11202     <span class="comment">//</span>
11203     <span class="keywordflow">if</span> (SecurityDescriptor-&gt;Group == 0) {
11204         <span class="keywordflow">if</span> (RequiredInformation &amp; GROUP_SECURITY_INFORMATION) {
11205             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
11206         }
11207     } <span class="keywordflow">else</span> {
11208         <span class="keywordflow">if</span> (!<a class="code" href="../../d8/d6/sertl_8c.html#a29">RtlpValidateSDOffsetAndSize</a> (SecurityDescriptor-&gt;Group,
11209                                           SecurityDescriptorLength,
11210                                           sizeof (SID),
11211                                           &amp;MaxGroupSidLength)) {
11212             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
11213         }
11214         <span class="comment">//</span>
11215         <span class="comment">// It is safe to reference the group's SubAuthorityCount, compute the</span>
11216         <span class="comment">// expected length of the SID</span>
11217         <span class="comment">//</span>
11218 
11219         GroupSid = (PSID)RtlOffsetToPointer (SecurityDescriptor,
11220                                              SecurityDescriptor-&gt;Group);
11221 
11222         <span class="keywordflow">if</span> (GroupSid-&gt;Revision != SID_REVISION) {
11223             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
11224         }
11225 
11226         <span class="keywordflow">if</span> (GroupSid-&gt;SubAuthorityCount &gt; SID_MAX_SUB_AUTHORITIES) {
11227             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
11228         }
11229 
11230         <span class="keywordflow">if</span> (MaxGroupSidLength &lt; (ULONG) <a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a> (GroupSid)) {
11231              <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
11232         }
11233 
11234     }
11235 
11236     <span class="comment">//</span>
11237     <span class="comment">// Validate the DACL if it's there and check if its allowed to be missing.</span>
11238     <span class="comment">//</span>
11239 
11240     <span class="keywordflow">if</span> (!RtlpAreControlBitsSet (SecurityDescriptor, SE_DACL_PRESENT)) {
11241 <span class="comment">//</span>
11242 <span class="comment">// Some code does this kind of thing:</span>
11243 <span class="comment">//</span>
11244 <span class="comment">// InitializeSecurityDescriptor (&amp;sd, SECURITY_DESCRIPTOR_REVISION);</span>
11245 <span class="comment">// RegSetKeySecurity(hKey, DACL_SECURITY_INFORMATION, &amp;sd) )</span>
11246 <span class="comment">//</span>
11247 <span class="comment">// With the current system this works the same as passing in a NULL DACL but it looks</span>
11248 <span class="comment">// almost by accident</span>
11249 <span class="comment">//</span>
11250 <span class="comment">//        if (RequiredInformation &amp; DACL_SECURITY_INFORMATION) {</span>
11251 <span class="comment">//            return FALSE;</span>
11252 <span class="comment">//        }</span>
11253     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (SecurityDescriptor-&gt;Dacl) {
11254         <span class="keywordflow">if</span> (!<a class="code" href="../../d8/d6/sertl_8c.html#a29">RtlpValidateSDOffsetAndSize</a> (SecurityDescriptor-&gt;Dacl,
11255                                           SecurityDescriptorLength,
11256                                           sizeof (ACL),
11257                                           &amp;MaxDaclLength)) {
11258             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
11259         }
11260 
11261         <a class="code" href="../../d6/d0/ctaccess_8c.html#a55">Dacl</a> = (PACL) RtlOffsetToPointer (SecurityDescriptor,
11262                                           SecurityDescriptor-&gt;Dacl);
11263 
11264         <span class="comment">//</span>
11265         <span class="comment">// Make sure the DACL length fits within the bounds of the security descriptor.</span>
11266         <span class="comment">//</span>
11267         <span class="keywordflow">if</span> (MaxDaclLength &lt; <a class="code" href="../../d6/d0/ctaccess_8c.html#a55">Dacl</a>-&gt;AclSize) {
11268             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
11269         }
11270 
11271         <span class="comment">//</span>
11272         <span class="comment">// Make sure the ACL is structurally valid.</span>
11273         <span class="comment">//</span>
11274         <span class="keywordflow">if</span> (!<a class="code" href="../../d2/d4/acledit_8c.html#a7">RtlValidAcl</a> (<a class="code" href="../../d6/d0/ctaccess_8c.html#a55">Dacl</a>)) {
11275             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
11276         }
11277     }
11278 
11279     <span class="comment">//</span>
11280     <span class="comment">// Validate the SACL if it's there and check if its allowed to be missing.</span>
11281     <span class="comment">//</span>
11282 
11283     <span class="keywordflow">if</span> (!RtlpAreControlBitsSet (SecurityDescriptor, SE_SACL_PRESENT)) {
11284 <span class="comment">//        if (RequiredInformation &amp; SACL_SECURITY_INFORMATION) {</span>
11285 <span class="comment">//            return FALSE;</span>
11286 <span class="comment">//        }</span>
11287     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (SecurityDescriptor-&gt;Sacl) {
11288         <span class="keywordflow">if</span> (!<a class="code" href="../../d8/d6/sertl_8c.html#a29">RtlpValidateSDOffsetAndSize</a> (SecurityDescriptor-&gt;Sacl,
11289                                           SecurityDescriptorLength,
11290                                           sizeof (ACL),
11291                                           &amp;MaxSaclLength)) {
11292             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
11293         }
11294 
11295         Sacl = (PACL) RtlOffsetToPointer (SecurityDescriptor,
11296                                           SecurityDescriptor-&gt;Sacl);
11297 
11298         <span class="comment">//</span>
11299         <span class="comment">// Make sure the SACL length fits within the bounds of the security descriptor.</span>
11300         <span class="comment">//</span>
11301 
11302         <span class="keywordflow">if</span> (MaxSaclLength &lt; Sacl-&gt;AclSize) {
11303             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
11304         }
11305 
11306         <span class="comment">//</span>
11307         <span class="comment">// Make sure the ACL is structurally valid.</span>
11308         <span class="comment">//</span>
11309 
11310         <span class="keywordflow">if</span> (!<a class="code" href="../../d2/d4/acledit_8c.html#a7">RtlValidAcl</a> (Sacl)) {
11311             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
11312         }
11313     }
11314 
11315     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
11316 }
11317 
11318 
11319 
11320 
11321 
11322 BOOLEAN
<a name="l11323"></a><a class="code" href="../../d8/d6/sertl_8c.html#a78">11323</a> <a class="code" href="../../d8/d6/sertl_8c.html#a78">RtlGetSecurityDescriptorRMControl</a>(
11324     IN PSECURITY_DESCRIPTOR SecurityDescriptor,
11325     OUT PUCHAR RMControl
11326     )
11327 
11328 <span class="comment">/*++</span>
11329 <span class="comment"></span>
11330 <span class="comment">Routine Description:</span>
11331 <span class="comment"></span>
11332 <span class="comment">    This procedure returns the RM Control flags from a SecurityDescriptor if</span>
11333 <span class="comment">    SE_RM_CONTROL_VALID flags is present in the control field.</span>
11334 <span class="comment"></span>
11335 <span class="comment">Arguments:</span>
11336 <span class="comment"></span>
11337 <span class="comment">    SecurityDescriptor - Pointer to the SECURITY_DESCRIPTOR structure</span>
11338 <span class="comment">    RMControl          - Returns the flags in the SecurityDescriptor if</span>
11339 <span class="comment">                         SE_RM_CONTROL_VALID is set in the control bits of the</span>
11340 <span class="comment">                         SecurityDescriptor.</span>
11341 <span class="comment"></span>
11342 <span class="comment"></span>
11343 <span class="comment">Return Value:</span>
11344 <span class="comment"></span>
11345 <span class="comment">    BOOLEAN - TRUE if SE_RM_CONTROL_VALID is set in the Control bits of the</span>
11346 <span class="comment">              SecurityDescriptor.</span>
11347 <span class="comment"></span>
11348 <span class="comment">Note:</span>
11349 <span class="comment">    Parameter validation has already been done in Advapi.</span>
11350 <span class="comment"></span>
11351 <span class="comment"></span>
11352 <span class="comment">--*/</span>
11353 
11354 {
11355     PISECURITY_DESCRIPTOR ISecurityDescriptor = (PISECURITY_DESCRIPTOR) SecurityDescriptor;
11356 
11357     <span class="keywordflow">if</span> (!(ISecurityDescriptor-&gt;Control &amp; SE_RM_CONTROL_VALID))
11358     {
11359         *RMControl = 0;
11360         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
11361     }
11362 
11363     *RMControl = ISecurityDescriptor-&gt;Sbz1;
11364 
11365     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
11366 }
11367 
11368 
11369 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l11370"></a><a class="code" href="../../d8/d6/sertl_8c.html#a79">11370</a> <a class="code" href="../../d8/d6/sertl_8c.html#a79">RtlSetSecurityDescriptorRMControl</a>(
11371     IN OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
11372     IN PUCHAR RMControl OPTIONAL
11373     )
11374 
11375 <span class="comment">/*++</span>
11376 <span class="comment"></span>
11377 <span class="comment">Routine Description:</span>
11378 <span class="comment"></span>
11379 <span class="comment">    This procedure sets the RM Control flag in the control field of</span>
11380 <span class="comment">    SecurityDescriptor and sets Sbz1 to the the byte to which RMContol points.</span>
11381 <span class="comment">    If RMControl is NULL then the bits are cleared.</span>
11382 <span class="comment"></span>
11383 <span class="comment">Arguments:</span>
11384 <span class="comment"></span>
11385 <span class="comment">    SecurityDescriptor - Pointer to the SECURITY_DESCRIPTOR structure</span>
11386 <span class="comment">    RMControl          - Pointer to the flags to set. If NULL then the bits</span>
11387 <span class="comment">                         are cleared.</span>
11388 <span class="comment"></span>
11389 <span class="comment">Note:</span>
11390 <span class="comment">    Parameter validation has already been done in Advapi.</span>
11391 <span class="comment"></span>
11392 <span class="comment"></span>
11393 <span class="comment">--*/</span>
11394 
11395 {
11396     PISECURITY_DESCRIPTOR ISecurityDescriptor = (PISECURITY_DESCRIPTOR) SecurityDescriptor;
11397 
11398     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(RMControl)) {
11399         ISecurityDescriptor-&gt;Control |= SE_RM_CONTROL_VALID;
11400         ISecurityDescriptor-&gt;Sbz1 = *RMControl;
11401     } <span class="keywordflow">else</span> {
11402         ISecurityDescriptor-&gt;Control &amp;= ~SE_RM_CONTROL_VALID;
11403         ISecurityDescriptor-&gt;Sbz1 = 0;
11404     }
11405 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:41:47 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
