<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: hashirp.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>hashirp.c</h1><a href="../../d8/d8/hashirp_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="preprocessor">#include "<a class="code" href="../../d0/d6/iop_8h.html">iop.h</a>"</span>
00002 
00003 <span class="comment">//</span>
00004 <span class="comment">// This entire file is only present if NO_SPECIAL_IRP isn't defined</span>
00005 <span class="comment">//</span>
00006 <span class="preprocessor">#ifndef NO_SPECIAL_IRP</span>
00007 <span class="preprocessor"></span>
00008 <span class="comment">//</span>
00009 <span class="comment">// When enabled, everything is locked down on demand...</span>
00010 <span class="comment">//</span>
00011 <span class="preprocessor">#ifdef ALLOC_PRAGMA</span>
00012 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,     IovpTrackingDataInit)</span>
00013 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY, IovpTrackingDataFindPointer)</span>
00014 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY, IovpTrackingDataFindAndLock)</span>
00015 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY, IovpTrackingDataCreateAndLock)</span>
00016 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY, IovpTrackingDataGetCurrentSessionData)</span>
00017 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY, IovpTrackingDataFree)</span>
00018 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY, IovpTrackingDataAcquireLock)</span>
00019 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY, IovpTrackingDataReleaseLock)</span>
00020 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY, IovpTrackingDataReference)</span>
00021 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY, IovpTrackingDataDereference)</span>
00022 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY, IovpWatermarkIrp)</span>
00023 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00024 <span class="preprocessor"></span>
<a name="l00025"></a><a class="code" href="../../d8/d8/hashirp_8c.html#a0">00025</a> <span class="preprocessor">#define POOL_TAG_TRACKING_DATA      'tprI'</span>
<a name="l00026"></a><a class="code" href="../../d8/d8/hashirp_8c.html#a1">00026</a> <span class="preprocessor"></span><span class="preprocessor">#define POOL_TAG_PROTECTED_IRP      '+prI'</span>
00027 <span class="preprocessor"></span>
00028 <span class="comment">//</span>
00029 <span class="comment">// Debug spew level</span>
00030 <span class="comment">//</span>
<a name="l00031"></a><a class="code" href="../../d8/d8/hashirp_8c.html#a2">00031</a> ULONG <a class="code" href="../../d8/d8/hashirp_8c.html#a2">IovpIrpTrackingSpewLevel</a> = 0 ;
00032 
00033 <span class="comment">//</span>
00034 <span class="comment">// This is our IRP tracking table, a hash table that points to a block of</span>
00035 <span class="comment">// data associated with each IRP.</span>
00036 <span class="comment">//</span>
<a name="l00037"></a><a class="code" href="../../d8/d8/hashirp_8c.html#a3">00037</a> LIST_ENTRY  <a class="code" href="../../d8/d8/hashirp_8c.html#a3">IovpIrpTrackingTable</a>[<a class="code" href="../../d9/d8/hashirp_8h.html#a0">IRP_TRACKING_HASH_SIZE</a>];
<a name="l00038"></a><a class="code" href="../../d8/d8/hashirp_8c.html#a4">00038</a> KSPIN_LOCK  <a class="code" href="../../d8/d8/hashirp_8c.html#a4">IovpIrpHashLock</a>;
00039 
00040 <span class="comment">/*</span>
00041 <span class="comment"> * The 10 routines listed below -</span>
00042 <span class="comment"> *   IovpTrackingDataInit</span>
00043 <span class="comment"> *   IovpTrackingDataCreateAndLock</span>
00044 <span class="comment"> *   IovpTrackingDataFindAndLock</span>
00045 <span class="comment"> *   IovpTrackingDataGetCurrentSessionData</span>
00046 <span class="comment"> *   IovpTrackingDataReference</span>
00047 <span class="comment"> *   IovpTrackingDataDereference</span>
00048 <span class="comment"> *   IovpTrackingDataAcquireLock</span>
00049 <span class="comment"> *   IovpTrackingDataReleaseLock</span>
00050 <span class="comment"> *   IovpTrackingDataFree                    - (internal)</span>
00051 <span class="comment"> *   IovpTrackingDataFindPointer             - (internal)</span>
00052 <span class="comment"> *</span>
00053 <span class="comment"> * - handle the IRP tracking structures. This is an allocation of memory</span>
00054 <span class="comment"> * that lives alongside the IRP. We need this as the IRP structure and</span>
00055 <span class="comment"> * size are things that drivers must pass around, so we cannot add this</span>
00056 <span class="comment"> * information into the IRP itself by expanding it's size. We use a hash</span>
00057 <span class="comment"> * table setup to quickly find the IRPs in our table, so not too much time</span>
00058 <span class="comment"> * is lost.</span>
00059 <span class="comment"> *</span>
00060 <span class="comment"> * Locking semantics: No IRP may be removed from or inserted into the table</span>
00061 <span class="comment"> * without the HashLock being taken. Furthermore at some point in the lifetime</span>
00062 <span class="comment"> * of the tracking data the pointer to the IRP may be zero'd, making it</span>
00063 <span class="comment"> * "unreachable". This zeroing of the IRP pointer must also happen under the</span>
00064 <span class="comment"> * hash lock.</span>
00065 <span class="comment"> *</span>
00066 <span class="comment"> * Three functions may be called to retrieve tracking data, the create and find</span>
00067 <span class="comment"> * instructions. The acquire lock function can be used if you already have a</span>
00068 <span class="comment"> * referenced pointer to the tracking data and merely need to lock it. None of</span>
00069 <span class="comment"> * these functions add a reference to the object. Reference counts aren't</span>
00070 <span class="comment"> * examined until the lock on the tracking data is dropped (ReleaseLock).</span>
00071 <span class="comment"> * First the PointerCount member is first checked to see if the tracking</span>
00072 <span class="comment"> * data should be marked "unreachable" (TrackedIrp = NULL). Then ReferenceCount</span>
00073 <span class="comment"> * is examined to see if the tracking data can be freed.</span>
00074 <span class="comment"> *</span>
00075 <span class="comment"> * Note that find searches the table holding the hashlock. If an entry is found</span>
00076 <span class="comment"> * a handoff to the IRP specific lock must be executed. This is done by</span>
00077 <span class="comment"> * incrementing the ReferenceCount and then releasing the hash lock to ensure</span>
00078 <span class="comment"> * the packet stays in the table. The hash lock is then dropped and the IRPlock</span>
00079 <span class="comment"> * picked up. Note that ReferenceCount is only dropped under the held IRPlock</span>
00080 <span class="comment"> * though, allowing us to avoid taking it to examining the count under the</span>
00081 <span class="comment"> * hash lock as often as possible.</span>
00082 <span class="comment"> *</span>
00083 <span class="comment"> * Perf - The hashlock should be replaced with an array of</span>
00084 <span class="comment"> *        IRP_TRACKING_HASH_SIZE hashlocks with little cost.</span>
00085 <span class="comment"> */</span>
00086 
00087 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00088 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l00089"></a><a class="code" href="../../d9/d8/hashirp_8h.html#a6">00089</a> <a class="code" href="../../d9/d8/hashirp_8h.html#a6">IovpTrackingDataInit</a>(
00090     VOID
00091     )
00092 <span class="comment">/*++</span>
00093 <span class="comment"></span>
00094 <span class="comment">  Description:</span>
00095 <span class="comment"></span>
00096 <span class="comment">    This routine initializes all the important structures we use to track</span>
00097 <span class="comment">    IRPs through the hash tables.</span>
00098 <span class="comment"></span>
00099 <span class="comment">  Arguments:</span>
00100 <span class="comment"></span>
00101 <span class="comment">    None</span>
00102 <span class="comment"></span>
00103 <span class="comment">  Return Value:</span>
00104 <span class="comment"></span>
00105 <span class="comment">    None</span>
00106 <span class="comment"></span>
00107 <span class="comment">--*/</span>
00108 {
00109     ULONG i;
00110 
00111     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00112 
00113     <a class="code" href="../../d4/d9/ke_8h.html#a354">KeInitializeSpinLock</a>( &amp;<a class="code" href="../../d8/d8/hashirp_8c.html#a4">IovpIrpHashLock</a> );
00114     <span class="keywordflow">for</span>(i=0; i&lt;<a class="code" href="../../d9/d8/hashirp_8h.html#a0">IRP_TRACKING_HASH_SIZE</a>; i++) {
00115 
00116         InitializeListHead(<a class="code" href="../../d8/d8/hashirp_8c.html#a3">IovpIrpTrackingTable</a>+i);
00117     }
00118 }
00119 
00120 <a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html">PIOV_REQUEST_PACKET</a>
00121 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l00122"></a><a class="code" href="../../d9/d8/hashirp_8h.html#a8">00122</a> <a class="code" href="../../d9/d8/hashirp_8h.html#a8">IovpTrackingDataCreateAndLock</a>(
00123     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>           Irp
00124     )
00125 <span class="comment">/*++</span>
00126 <span class="comment"></span>
00127 <span class="comment">  Description:</span>
00128 <span class="comment"></span>
00129 <span class="comment">    This routine creates a tracking packet for a new IRP. The IRP does not get</span>
00130 <span class="comment">    an initial reference count however. IovpTrackingDataReleaseLock must be</span>
00131 <span class="comment">    called to drop the lock.</span>
00132 <span class="comment"></span>
00133 <span class="comment">  Arguments:</span>
00134 <span class="comment"></span>
00135 <span class="comment">    Irp                    - Irp to begin tracking.</span>
00136 <span class="comment"></span>
00137 <span class="comment">  Return Value:</span>
00138 <span class="comment"></span>
00139 <span class="comment">    iovPacket block, NULL if no memory.</span>
00140 <span class="comment"></span>
00141 <span class="comment">--*/</span>
00142 {
00143     KIRQL oldIrql;
00144     <a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html">PIOV_REQUEST_PACKET</a> iovPacket;
00145     PLIST_ENTRY hashHead;
00146     ULONG trackingDataSize;
00147     LONG newCount;
00148 
00149     ExAcquireSpinLock( &amp;<a class="code" href="../../d8/d8/hashirp_8c.html#a4">IovpIrpHashLock</a>, &amp;oldIrql );
00150 
00151     iovPacket = <a class="code" href="../../d9/d8/hashirp_8h.html#a10">IovpTrackingDataFindPointer</a>(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, &amp;hashHead) ;
00152 
00153     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(!iovPacket) ;
00154 
00155     <span class="comment">//</span>
00156     <span class="comment">// One extra stack location is allocated as the "zero'th" is used to</span>
00157     <span class="comment">// simplify some logic...</span>
00158     <span class="comment">//</span>
00159     trackingDataSize = <span class="keyword">sizeof</span>(<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html">IOV_REQUEST_PACKET</a>)+<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o12">StackCount</a>*<span class="keyword">sizeof</span>(<a class="code" href="../../d9/d1/struct__IOV__STACK__LOCATION.html">IOV_STACK_LOCATION</a>) ;
00160 
00161     iovPacket = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>(
00162         <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>,
00163         trackingDataSize,
00164         <a class="code" href="../../d8/d8/hashirp_8c.html#a0">POOL_TAG_TRACKING_DATA</a>
00165         );
00166 
00167     <span class="keywordflow">if</span> (!iovPacket) {
00168 
00169         ExReleaseSpinLock( &amp;<a class="code" href="../../d8/d8/hashirp_8c.html#a4">IovpIrpHashLock</a>, oldIrql );
00170         <span class="keywordflow">return</span> iovPacket;
00171     }
00172 
00173     <span class="comment">//RtlZeroMemory(iovPacket, trackingDataSize) ;</span>
00174 
00175     <span class="comment">//</span>
00176     <span class="comment">// From top to bottom, initialize the fields. Note that there is not a</span>
00177     <span class="comment">// "surrogateHead". If any code needs to find out the first entry in the</span>
00178     <span class="comment">// circularly linked list of IRPs (the first is the only non-surrogate IRP),</span>
00179     <span class="comment">// then HeadPacket should be used. Note that the link to the session is</span>
00180     <span class="comment">// stored by the headPacket, more on this later.</span>
00181     <span class="comment">//</span>
00182     iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o0">TrackedIrp</a> = <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>;
00183     <a class="code" href="../../d4/d9/ke_8h.html#a354">KeInitializeSpinLock</a>( &amp;iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o1">IrpLock</a> );
00184     iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o3">ReferenceCount</a> = 1;
00185     iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o4">PointerCount</a> = 0;
00186     iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o5">Flags</a> = 0;
00187     InitializeListHead(&amp;iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o6">HashLink</a>);
00188     InitializeListHead(&amp;iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o7">SurrogateLink</a>);
00189     InitializeListHead(&amp;iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o8">SessionHead</a>);
00190     iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o9">HeadPacket</a> = iovPacket;
00191     iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o10">StackCount</a> = <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o12">StackCount</a>;
00192     iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o11">AssertFlags</a> = <a class="code" href="../../d8/d4/trackirp_8c.html#a7">IovpTrackingFlags</a>;
00193     iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o12">RealIrpCompletionRoutine</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00194     iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o13">RealIrpControl</a> = 0;
00195     iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o14">RealIrpContext</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00196     iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o16">TopStackLocation</a> = 0;
00197     iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o17">PriorityBoost</a> = 0;
00198     iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o18">LastLocation</a> = 0;
00199     iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o19">RefTrackingCount</a> =0;
00200     iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o20">RestoreHandle</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00201     iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o21">pIovSessionData</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00202 
00203     <span class="comment">//</span>
00204     <span class="comment">// Place into hash table under lock (with the initial reference count)</span>
00205     <span class="comment">//</span>
00206     InsertHeadList(hashHead, &amp;iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o6">HashLink</a>);
00207 
00208     ExReleaseSpinLock( &amp;<a class="code" href="../../d8/d8/hashirp_8c.html#a4">IovpIrpHashLock</a>, oldIrql );
00209 
00210     ExAcquireSpinLock( &amp;iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o1">IrpLock</a>, &amp;iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o2">CallerIrql</a> );
00211 
00212     newCount = InterlockedDecrement(&amp;iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o3">ReferenceCount</a>);
00213 
00214     <span class="comment">//</span>
00215     <span class="comment">// If this assert gets hit it means somebody got hold of tracking data</span>
00216     <span class="comment">// at a very odd (and probably buggy) time. Actually, this might happen</span>
00217     <span class="comment">// if an IRP was cancelled right as it entered IoCallDriver...</span>
00218     <span class="comment">//</span>
00219     <span class="comment">//ASSERT(newCount == 0);</span>
00220 
00221     <a class="code" href="../../d9/d4/trackirp_8h.html#a88">TRACKIRP_DBGPRINT</a>((
00222         <span class="stringliteral">"  VRP CREATE(%x)-&gt;%x\n"</span>,
00223         <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>,
00224         iovPacket
00225         ), 3) ;
00226 
00227     <span class="keywordflow">return</span> iovPacket ;
00228 }
00229 
00230 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00231 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l00232"></a><a class="code" href="../../d9/d8/hashirp_8h.html#a9">00232</a> <a class="code" href="../../d9/d8/hashirp_8h.html#a9">IovpTrackingDataFree</a>(
00233     IN <a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html">PIOV_REQUEST_PACKET</a> IovPacket
00234     )
00235 <span class="comment">/*++</span>
00236 <span class="comment"></span>
00237 <span class="comment">  Description:</span>
00238 <span class="comment"></span>
00239 <span class="comment">    This routine free's the tracking data. The tracking data should already</span>
00240 <span class="comment">    have been removed from the table by a call to IovpTrackingDataReleaseLock</span>
00241 <span class="comment">    with the ReferenceCount at 0.</span>
00242 <span class="comment"></span>
00243 <span class="comment">  Arguments:</span>
00244 <span class="comment"></span>
00245 <span class="comment">    IovPacket        - Tracking data to free.</span>
00246 <span class="comment"></span>
00247 <span class="comment">  Return Value:</span>
00248 <span class="comment"></span>
00249 <span class="comment">    Nope.</span>
00250 <span class="comment"></span>
00251 <span class="comment">--*/</span>
00252 {
00253     <span class="comment">//</span>
00254     <span class="comment">// The list entry is inited to point back to itself when removed. The</span>
00255     <span class="comment">// pointer count should of course still be zero.</span>
00256     <span class="comment">//</span>
00257     IovPacket-&gt;Flags|=<a class="code" href="../../d9/d4/trackirp_8h.html#a40">TRACKFLAG_REMOVED_FROM_TABLE</a> ;
00258     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(IsListEmpty(&amp;IovPacket-&gt;HashLink)) ;
00259 
00260     <span class="comment">//</span>
00261     <span class="comment">// with no reference counts...</span>
00262     <span class="comment">//</span>
00263     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(!IovPacket-&gt;ReferenceCount) ;
00264     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(!IovPacket-&gt;PointerCount) ;
00265 
00266     <a class="code" href="../../d9/d4/trackirp_8h.html#a88">TRACKIRP_DBGPRINT</a>((
00267         <span class="stringliteral">"  VRP FREE(%x)x\n"</span>,
00268         IovPacket
00269         ), 3) ;
00270 
00271     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(IovPacket) ;
00272 }
00273 
00274 <a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html">PIOV_REQUEST_PACKET</a>
00275 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l00276"></a><a class="code" href="../../d9/d8/hashirp_8h.html#a7">00276</a> <a class="code" href="../../d9/d8/hashirp_8h.html#a7">IovpTrackingDataFindAndLock</a>(
00277     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>           Irp
00278     )
00279 <span class="comment">/*++</span>
00280 <span class="comment"></span>
00281 <span class="comment">  Description:</span>
00282 <span class="comment"></span>
00283 <span class="comment">    This routine will return the tracking data for an IRP that is</span>
00284 <span class="comment">    being tracked without a surrogate or the tracking data for with</span>
00285 <span class="comment">    a surrogate if the surrogate IRP is what was passed in.</span>
00286 <span class="comment"></span>
00287 <span class="comment">  Arguments:</span>
00288 <span class="comment"></span>
00289 <span class="comment">    Irp                    - Irp to find.</span>
00290 <span class="comment"></span>
00291 <span class="comment">  Return Value:</span>
00292 <span class="comment"></span>
00293 <span class="comment">    IovPacket block, iff above conditions are satified.</span>
00294 <span class="comment"></span>
00295 <span class="comment">--*/</span>
00296 {
00297     KIRQL oldIrql ;
00298     <a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html">PIOV_REQUEST_PACKET</a> iovPacket ;
00299     PLIST_ENTRY listHead;
00300 
00301     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>) ;
00302     ExAcquireSpinLock( &amp;<a class="code" href="../../d8/d8/hashirp_8c.html#a4">IovpIrpHashLock</a>, &amp;oldIrql );
00303 
00304     iovPacket = <a class="code" href="../../d9/d8/hashirp_8h.html#a10">IovpTrackingDataFindPointer</a>(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, &amp;listHead) ;
00305 
00306     <span class="keywordflow">if</span> (!iovPacket) {
00307 
00308         ExReleaseSpinLock( &amp;<a class="code" href="../../d8/d8/hashirp_8c.html#a4">IovpIrpHashLock</a>, oldIrql );
00309         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00310     }
00311 
00312     InterlockedIncrement(&amp;iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o3">ReferenceCount</a>);
00313 
00314     ExReleaseSpinLock( &amp;<a class="code" href="../../d8/d8/hashirp_8c.html#a4">IovpIrpHashLock</a>, oldIrql );
00315 
00316     <a class="code" href="../../d9/d8/hashirp_8h.html#a11">IovpTrackingDataAcquireLock</a>(iovPacket) ;
00317     iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o2">CallerIrql</a> = oldIrql;
00318 
00319     InterlockedDecrement(&amp;iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o3">ReferenceCount</a>);
00320 
00321     <span class="keywordflow">if</span> (iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o0">TrackedIrp</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00322 
00323         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(0);
00324         <span class="comment">//</span>
00325         <span class="comment">// Someone IRP is being mishandled, we got in a race condition where</span>
00326         <span class="comment">// we got the packet but the pointer count decayed to zero. Therefore</span>
00327         <span class="comment">// we do not want this packet so we will return NULL after dropping</span>
00328         <span class="comment">// it's lock. This sort of thing really shouldn't happen ya know.</span>
00329         <span class="comment">//</span>
00330         <a class="code" href="../../d9/d8/hashirp_8h.html#a12">IovpTrackingDataReleaseLock</a>(iovPacket);
00331         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00332     }
00333 
00334     <a class="code" href="../../d9/d4/trackirp_8h.html#a88">TRACKIRP_DBGPRINT</a>((
00335         <span class="stringliteral">"  VRP FIND(%x)-&gt;%x\n"</span>,
00336         <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>,
00337         iovPacket
00338         ), 3) ;
00339 
00340     <span class="keywordflow">return</span> iovPacket;
00341 }
00342 
00343 <a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html">PIOV_REQUEST_PACKET</a>
00344 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l00345"></a><a class="code" href="../../d9/d8/hashirp_8h.html#a10">00345</a> <a class="code" href="../../d9/d8/hashirp_8h.html#a10">IovpTrackingDataFindPointer</a>(
00346     IN  <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>               Irp,
00347     OUT PLIST_ENTRY        *HashHead
00348     )
00349 <span class="comment">/*++</span>
00350 <span class="comment"></span>
00351 <span class="comment">  Description:</span>
00352 <span class="comment"></span>
00353 <span class="comment">    This routine returns a pointer to a pointer to the Irp tracking data.</span>
00354 <span class="comment">    This function is meant to be called by other routines in this file.</span>
00355 <span class="comment"></span>
00356 <span class="comment">    N.B. The tracking lock is assumed to be held by the caller.</span>
00357 <span class="comment"></span>
00358 <span class="comment">  Arguments:</span>
00359 <span class="comment"></span>
00360 <span class="comment">    Irp                        - Irp to locate in the tracking table.</span>
00361 <span class="comment"></span>
00362 <span class="comment">    HashHead                   - If return is non-null, points to the</span>
00363 <span class="comment">                                 list head that should be used to insert</span>
00364 <span class="comment">                                 the IRP.</span>
00365 <span class="comment"></span>
00366 <span class="comment">  Return Value:</span>
00367 <span class="comment"></span>
00368 <span class="comment">     IrpTrackingData iff found, NULL otherwise.</span>
00369 <span class="comment"></span>
00370 <span class="comment">--*/</span>
00371 {
00372     KIRQL oldIrql ;
00373     <a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html">PIOV_REQUEST_PACKET</a> iovPacket ;
00374     PLIST_ENTRY listEntry, listHead;
00375     UINT_PTR hash ;
00376 
00377     <a class="code" href="../../d2/d5/ioassert_8h.html#a24">ASSERT_SPINLOCK_HELD</a>(&amp;<a class="code" href="../../d8/d8/hashirp_8c.html#a4">IovpIrpHashLock</a>) ;
00378 
00379     hash = (((UINT_PTR) <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>)/<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>)*<a class="code" href="../../d9/d8/hashirp_8h.html#a1">IRP_TRACKING_HASH_PRIME</a> ;
00380     hash %= <a class="code" href="../../d9/d8/hashirp_8h.html#a0">IRP_TRACKING_HASH_SIZE</a> ;
00381 
00382     *HashHead = listHead = <a class="code" href="../../d8/d8/hashirp_8c.html#a3">IovpIrpTrackingTable</a> + hash ;
00383 
00384     <span class="keywordflow">for</span>(listEntry = listHead;
00385         listEntry-&gt;Flink != listHead;
00386         listEntry = listEntry-&gt;Flink) {
00387 
00388         iovPacket = CONTAINING_RECORD(listEntry-&gt;Flink, <a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html">IOV_REQUEST_PACKET</a>, HashLink);
00389 
00390         <span class="keywordflow">if</span> (iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o0">TrackedIrp</a> == <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>) {
00391 
00392             <span class="keywordflow">return</span> iovPacket;
00393         }
00394     }
00395 
00396     <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ;
00397 }
00398 
00399 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00400 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l00401"></a><a class="code" href="../../d8/d8/hashirp_8c.html#a10">00401</a> <a class="code" href="../../d9/d8/hashirp_8h.html#a11">IovpTrackingDataAcquireLock</a>(
00402     IN  <a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html">PIOV_REQUEST_PACKET</a> IovPacket OPTIONAL
00403     )
00404 <span class="comment">/*++</span>
00405 <span class="comment"></span>
00406 <span class="comment">  Description:</span>
00407 <span class="comment"></span>
00408 <span class="comment">    This routine is called by to acquire the IRPs tracking data lock.</span>
00409 <span class="comment"></span>
00410 <span class="comment">    Incoming IRQL must be the same as the callers (IoCallDriver, IoCompleteRequest)</span>
00411 <span class="comment">    We may be at DPC level when we return. Callers *must* follow up with</span>
00412 <span class="comment">    IovpTrackingDataReleaseLock.</span>
00413 <span class="comment"></span>
00414 <span class="comment">  Arguments:</span>
00415 <span class="comment"></span>
00416 <span class="comment">    IovPacket        - Pointer to the IRP tracking data (or NULL, in which</span>
00417 <span class="comment">                       case this routine does nothing).</span>
00418 <span class="comment"></span>
00419 <span class="comment">  Return Value:</span>
00420 <span class="comment"></span>
00421 <span class="comment">     None.</span>
00422 <span class="comment">--*/</span>
00423 {
00424     KIRQL oldIrql ;
00425     <a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html">PIOV_REQUEST_PACKET</a> iovCurPacket;
00426 
00427     <span class="keywordflow">if</span> (!IovPacket) {
00428 
00429         <span class="keywordflow">return</span> ;
00430     }
00431 
00432     iovCurPacket = IovPacket;
00433     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(iovCurPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o3">ReferenceCount</a> != 0);
00434     <span class="keywordflow">while</span>(1) {
00435 
00436         ExAcquireSpinLock( &amp;iovCurPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o1">IrpLock</a>, &amp;oldIrql );
00437         iovCurPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o2">CallerIrql</a> = oldIrql ;
00438 
00439         <span class="keywordflow">if</span> (iovCurPacket == IovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o9">HeadPacket</a>) {
00440 
00441             <span class="keywordflow">break</span>;
00442         }
00443 
00444         iovCurPacket = CONTAINING_RECORD(
00445             iovCurPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o7">SurrogateLink</a>.Blink,
00446             <a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html">IOV_REQUEST_PACKET</a>,
00447             SurrogateLink
00448             );
00449     }
00450 }
00451 
00452 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00453 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l00454"></a><a class="code" href="../../d9/d8/hashirp_8h.html#a12">00454</a> <a class="code" href="../../d9/d8/hashirp_8h.html#a12">IovpTrackingDataReleaseLock</a>(
00455     IN  <a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html">PIOV_REQUEST_PACKET</a> IovPacket
00456     )
00457 <span class="comment">/*++</span>
00458 <span class="comment"></span>
00459 <span class="comment">  Description:</span>
00460 <span class="comment"></span>
00461 <span class="comment">    This routine releases the IRPs tracking data lock and adjusts the ref count</span>
00462 <span class="comment">    as appropriate. If the reference count drops to zero, the tracking data is</span>
00463 <span class="comment">    freed.</span>
00464 <span class="comment"></span>
00465 <span class="comment">  Arguments:</span>
00466 <span class="comment"></span>
00467 <span class="comment">    IovPacket              - Pointer to the IRP tracking data.</span>
00468 <span class="comment"></span>
00469 <span class="comment">  Return Value:</span>
00470 <span class="comment"></span>
00471 <span class="comment">     None.</span>
00472 <span class="comment"></span>
00473 <span class="comment">--*/</span>
00474 {
00475     BOOLEAN freeTrackingData;
00476     <a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html">PIOV_REQUEST_PACKET</a> iovCurPacket, iovHeadPacket, iovNextPacket;
00477     KIRQL oldIrql;
00478 
00479     <span class="comment">//</span>
00480     <span class="comment">// Pass one, delink anyone from the tree who's leaving, and assert that</span>
00481     <span class="comment">// no surrogates are left after a freed one.</span>
00482     <span class="comment">//</span>
00483     iovCurPacket = iovHeadPacket = IovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o9">HeadPacket</a>;
00484     <span class="keywordflow">while</span>(1) {
00485 
00486         <a class="code" href="../../d2/d5/ioassert_8h.html#a24">ASSERT_SPINLOCK_HELD</a>(&amp;iovCurPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o1">IrpLock</a>);
00487 
00488         iovNextPacket = CONTAINING_RECORD(
00489             iovCurPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o7">SurrogateLink</a>.Flink,
00490             <a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html">IOV_REQUEST_PACKET</a>,
00491             SurrogateLink
00492             );
00493 
00494         <span class="comment">//</span>
00495         <span class="comment">// PointerCount is always referenced under the IRP lock.</span>
00496         <span class="comment">//</span>
00497         <span class="keywordflow">if</span> (iovCurPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o4">PointerCount</a> == 0) {
00498 
00499             ExAcquireSpinLock( &amp;<a class="code" href="../../d8/d8/hashirp_8c.html#a4">IovpIrpHashLock</a>, &amp;oldIrql );
00500 
00501             <span class="comment">//</span>
00502             <span class="comment">// This field may be examined only under the hash lock.</span>
00503             <span class="comment">//</span>
00504             <span class="keywordflow">if</span> (iovCurPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o0">TrackedIrp</a>) {
00505 
00506                 iovCurPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o0">TrackedIrp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> &amp;=~ IRPFLAG_EXAMINE_MASK;
00507                 iovCurPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o0">TrackedIrp</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00508             }
00509 
00510             ExReleaseSpinLock( &amp;<a class="code" href="../../d8/d8/hashirp_8c.html#a4">IovpIrpHashLock</a>, oldIrql );
00511         }
00512 
00513         <span class="comment">//</span>
00514         <span class="comment">// We now remove any entries that will be leaving from the hash table.</span>
00515         <span class="comment">// Note that the ReferenceCount may be incremented outside the IRP lock</span>
00516         <span class="comment">// (but under the hash lock) but ReferenceCount can never be dropped</span>
00517         <span class="comment">// outside of the IRP lock. Therefore for performance we check once</span>
00518         <span class="comment">// and then take the lock to prevent anyone finding it and incrementing</span>
00519         <span class="comment">// it.</span>
00520         <span class="comment">//</span>
00521 
00522         <span class="keywordflow">if</span> (iovCurPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o3">ReferenceCount</a> == 0) {
00523 
00524             ExAcquireSpinLock( &amp;<a class="code" href="../../d8/d8/hashirp_8c.html#a4">IovpIrpHashLock</a>, &amp;oldIrql );
00525 
00526             <span class="keywordflow">if</span> (iovCurPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o3">ReferenceCount</a> ==0) {
00527 
00528                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(iovCurPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o4">PointerCount</a> == 0);
00529                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>((iovCurPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o21">pIovSessionData</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) ||
00530                        (iovCurPacket != iovHeadPacket));
00531                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>((iovNextPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o3">ReferenceCount</a> == 0) ||
00532                        (iovNextPacket == iovHeadPacket));
00533 
00534                 RemoveEntryList(&amp;iovCurPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o6">HashLink</a>);
00535 
00536                 InitializeListHead(&amp;iovCurPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o6">HashLink</a>);
00537             }
00538             ExReleaseSpinLock( &amp;<a class="code" href="../../d8/d8/hashirp_8c.html#a4">IovpIrpHashLock</a>, oldIrql );
00539         }
00540 
00541         <span class="keywordflow">if</span> (iovCurPacket == IovPacket) {
00542 
00543             <span class="keywordflow">break</span>;
00544         }
00545 
00546         iovCurPacket = iovNextPacket;
00547     }
00548 
00549     <span class="comment">//</span>
00550     <span class="comment">// Pass two, drop locks and free neccessary data.</span>
00551     <span class="comment">//</span>
00552     iovCurPacket = iovHeadPacket;
00553     <span class="keywordflow">while</span>(1) {
00554 
00555         freeTrackingData = IsListEmpty(&amp;iovCurPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o6">HashLink</a>);
00556 
00557         iovNextPacket = CONTAINING_RECORD(
00558             iovCurPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o7">SurrogateLink</a>.Flink,
00559             <a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html">IOV_REQUEST_PACKET</a>,
00560             SurrogateLink
00561             );
00562 
00563         ExReleaseSpinLock(&amp;iovCurPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o1">IrpLock</a>, iovCurPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o2">CallerIrql</a>) ;
00564 
00565         <span class="keywordflow">if</span> (freeTrackingData) {
00566 
00567             RemoveEntryList(&amp;iovCurPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o7">SurrogateLink</a>);
00568             InitializeListHead(&amp;iovCurPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o7">SurrogateLink</a>);
00569 
00570             <a class="code" href="../../d9/d8/hashirp_8h.html#a9">IovpTrackingDataFree</a>(iovCurPacket) ;
00571         }
00572 
00573         <span class="keywordflow">if</span> (iovCurPacket == IovPacket) {
00574 
00575             <span class="keywordflow">break</span>;
00576         }
00577 
00578         iovCurPacket = iovNextPacket;
00579     }
00580 }
00581 
00582 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00583 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l00584"></a><a class="code" href="../../d9/d8/hashirp_8h.html#a13">00584</a> <a class="code" href="../../d9/d8/hashirp_8h.html#a13">IovpTrackingDataReference</a>(
00585     IN <a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html">PIOV_REQUEST_PACKET</a> IovPacket,
00586     IN <a class="code" href="../../d9/d8/hashirp_8h.html#a3">IOV_REFERENCE_TYPE</a>  IovRefType
00587     )
00588 {
00589     <a class="code" href="../../d2/d5/ioassert_8h.html#a24">ASSERT_SPINLOCK_HELD</a>(&amp;IovPacket-&gt;IrpLock);
00590 
00591     <a class="code" href="../../d9/d4/trackirp_8h.html#a88">TRACKIRP_DBGPRINT</a>((
00592         <span class="stringliteral">"  VRP REF(%x) %x++\n"</span>,
00593         IovPacket,
00594         IovPacket-&gt;ReferenceCount
00595         ), 3) ;
00596 
00597     InterlockedIncrement(&amp;IovPacket-&gt;ReferenceCount);
00598     <span class="keywordflow">if</span> (IovRefType == <a class="code" href="../../d9/d8/hashirp_8h.html#a21a5">IOVREFTYPE_POINTER</a>) {
00599 
00600         <a class="code" href="../../d9/d4/trackirp_8h.html#a88">TRACKIRP_DBGPRINT</a>((
00601             <span class="stringliteral">"  VRP REF2(%x) %x++\n"</span>,
00602             IovPacket,
00603             IovPacket-&gt;PointerCount
00604             ), 3) ;
00605 
00606         IovPacket-&gt;PointerCount++;
00607     }
00608 }
00609 
00610 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00611 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l00612"></a><a class="code" href="../../d9/d8/hashirp_8h.html#a14">00612</a> <a class="code" href="../../d9/d8/hashirp_8h.html#a14">IovpTrackingDataDereference</a>(
00613     IN <a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html">PIOV_REQUEST_PACKET</a> IovPacket,
00614     IN IOV_REFERENCE_TYPE  IovRefType
00615     )
00616 {
00617     KIRQL oldIrql;
00618 
00619     <a class="code" href="../../d2/d5/ioassert_8h.html#a24">ASSERT_SPINLOCK_HELD</a>(&amp;IovPacket-&gt;IrpLock);
00620     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(IovPacket-&gt;ReferenceCount &gt; 0);
00621 
00622     <a class="code" href="../../d9/d4/trackirp_8h.html#a88">TRACKIRP_DBGPRINT</a>((
00623         <span class="stringliteral">"  VRP DEREF(%x) %x--\n"</span>,
00624         IovPacket,
00625         IovPacket-&gt;ReferenceCount
00626         ), 3) ;
00627 
00628     <span class="keywordflow">if</span> (IovRefType == <a class="code" href="../../d9/d8/hashirp_8h.html#a21a5">IOVREFTYPE_POINTER</a>) {
00629 
00630         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(IovPacket-&gt;PointerCount &gt; 0);
00631 
00632         <a class="code" href="../../d9/d4/trackirp_8h.html#a88">TRACKIRP_DBGPRINT</a>((
00633             <span class="stringliteral">"  VRP DEREF2(%x) %x--\n"</span>,
00634             IovPacket,
00635             IovPacket-&gt;PointerCount
00636             ), 3) ;
00637 
00638         IovPacket-&gt;PointerCount--;
00639 
00640         <span class="keywordflow">if</span> (IovPacket-&gt;PointerCount == 0) {
00641 
00642             ExAcquireSpinLock( &amp;<a class="code" href="../../d8/d8/hashirp_8c.html#a4">IovpIrpHashLock</a>, &amp;oldIrql );
00643 
00644             IovPacket-&gt;TrackedIrp-&gt;Flags &amp;=~ IRPFLAG_EXAMINE_MASK;
00645             IovPacket-&gt;TrackedIrp = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00646 
00647             ExReleaseSpinLock( &amp;<a class="code" href="../../d8/d8/hashirp_8c.html#a4">IovpIrpHashLock</a>, oldIrql );
00648         }
00649     }
00650     InterlockedDecrement(&amp;IovPacket-&gt;ReferenceCount);
00651 
00652     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(IovPacket-&gt;ReferenceCount &gt;= IovPacket-&gt;PointerCount);
00653 }
00654 
00655 <a class="code" href="../../d8/d1/struct__IOV__SESSION__DATA.html">PIOV_SESSION_DATA</a>
00656 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l00657"></a><a class="code" href="../../d9/d8/hashirp_8h.html#a16">00657</a> <a class="code" href="../../d9/d8/hashirp_8h.html#a16">IovpTrackingDataGetCurrentSessionData</a>(
00658     IN <a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html">PIOV_REQUEST_PACKET</a> IovPacket
00659     )
00660 {
00661     <a class="code" href="../../d2/d5/ioassert_8h.html#a24">ASSERT_SPINLOCK_HELD</a>(&amp;IovPacket-&gt;IrpLock);
00662     <a class="code" href="../../d2/d5/ioassert_8h.html#a24">ASSERT_SPINLOCK_HELD</a>(&amp;IovPacket-&gt;HeadPacket-&gt;IrpLock);
00663     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>((IovPacket-&gt;HeadPacket-&gt;pIovSessionData == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)||
00664            (IovPacket-&gt;Flags&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a25">TRACKFLAG_ACTIVE</a>)) ;
00665 
00666     <span class="keywordflow">return</span> IovPacket-&gt;HeadPacket-&gt;pIovSessionData;
00667 }
00668 
00669 <span class="comment">/*</span>
00670 <span class="comment"> * The 4 routines listed below -</span>
00671 <span class="comment"> *   IovpProtectedIrpAllocate</span>
00672 <span class="comment"> *   IovpProtectedIrpMakeTouchable</span>
00673 <span class="comment"> *   IovpProtectedIrpMakeUntouchable</span>
00674 <span class="comment"> *   IovpProtectedIrpFree</span>
00675 <span class="comment"> *</span>
00676 <span class="comment"> * - handle management of the replacement IRP. Specifically, we want to be</span>
00677 <span class="comment"> * able to allocate a set of non-paged bytes we can remove the backing</span>
00678 <span class="comment"> * physical memory from, and release the virtual addresses for later (we</span>
00679 <span class="comment"> * are essentially breaking free into it's two components). We do this with</span>
00680 <span class="comment"> * help from the special pool.</span>
00681 <span class="comment"> *</span>
00682 <span class="comment"> */</span>
00683 
00684 <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>
00685 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l00686"></a><a class="code" href="../../d9/d8/hashirp_8h.html#a20">00686</a> <a class="code" href="../../d9/d8/hashirp_8h.html#a20">IovpProtectedIrpAllocate</a>(
00687     IN CCHAR    StackSize,
00688     IN BOOLEAN  ChargeQuota,
00689     IN <a class="code" href="../../d5/d6/struct__ETHREAD.html">PETHREAD</a> QuotaThread OPTIONAL
00690     )
00691 <span class="comment">/*++</span>
00692 <span class="comment"></span>
00693 <span class="comment">  Description:</span>
00694 <span class="comment"></span>
00695 <span class="comment">    This routine allocates an IRP from the special pool using the</span>
00696 <span class="comment">    "replacement IRP" tag.</span>
00697 <span class="comment"></span>
00698 <span class="comment">  Arguments:</span>
00699 <span class="comment"></span>
00700 <span class="comment">     StackSize   - Number of stack locations to give the new IRP</span>
00701 <span class="comment"></span>
00702 <span class="comment">     ChargeQuota - TRUE iff quota should be charged against QuotaThread</span>
00703 <span class="comment"></span>
00704 <span class="comment">     QuotaThread - See above</span>
00705 <span class="comment"></span>
00706 <span class="comment">  Return Value:</span>
00707 <span class="comment"></span>
00708 <span class="comment">     Pointer to the memory allocated.</span>
00709 <span class="comment"></span>
00710 <span class="comment">--*/</span>
00711 {
00712     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> pSurrogateIrp;
00713     ULONG_PTR irpPtr;
00714     SIZE_T sizeOfAllocation;
00715 
00716     <span class="comment">//</span>
00717     <span class="comment">// We are allocating an IRP from the special pool. Since IRPs may come from</span>
00718     <span class="comment">// lookaside lists they may be ULONG aligned. The memory manager on the</span>
00719     <span class="comment">// other hand gaurentees quad-aligned allocations. So to catch all special</span>
00720     <span class="comment">// pool overrun bugs we "skew" the IRP right up to the edge.</span>
00721     <span class="comment">//</span>
00722     sizeOfAllocation = <a class="code" href="../../d0/d5/io_8h.html#a245">IoSizeOfIrp</a>(StackSize);
00723 
00724     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>((sizeOfAllocation % (<span class="keyword">sizeof</span>(ULONG))) == 0);
00725 
00726     <span class="comment">//</span>
00727     <span class="comment">// ADRIAO BUGBUG 08/16/98 - Use a quota'd alloc function if one is available</span>
00728     <span class="comment">// later...</span>
00729     <span class="comment">//</span>
00730     irpPtr = (ULONG_PTR) <a class="code" href="../../d5/d8/ex_8h.html#a222">ExAllocatePoolWithTagPriority</a>(
00731         <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>,
00732         sizeOfAllocation,
00733         <a class="code" href="../../d8/d8/hashirp_8c.html#a1">POOL_TAG_PROTECTED_IRP</a>,
00734         <a class="code" href="../../d5/d8/ex_8h.html#a330a195">HighPoolPrioritySpecialPoolOverrun</a>
00735         );
00736 
00737     pSurrogateIrp = (<a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>) (irpPtr);
00738 
00739     <span class="keywordflow">return</span> pSurrogateIrp;
00740 }
00741 
00742 PVOID
00743 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l00744"></a><a class="code" href="../../d9/d8/hashirp_8h.html#a17">00744</a> <a class="code" href="../../d9/d8/hashirp_8h.html#a17">IovpProtectedIrpMakeUntouchable</a>(
00745     IN  <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>    Irp OPTIONAL,
00746     IN  BOOLEAN Permanent
00747     )
00748 <span class="comment">/*++</span>
00749 <span class="comment"></span>
00750 <span class="comment">  Description:</span>
00751 <span class="comment"></span>
00752 <span class="comment">    This routine makes the surrogate IRP untouchable. Currently, this is</span>
00753 <span class="comment">    done by freeing the IRP back to the special pool.</span>
00754 <span class="comment"></span>
00755 <span class="comment">  Arguments:</span>
00756 <span class="comment"></span>
00757 <span class="comment">    Irp        - Pointer to the Irp to make untouchable</span>
00758 <span class="comment">    Permanent  - TRUE iff Irp should not be made touchable again</span>
00759 <span class="comment"></span>
00760 <span class="comment"></span>
00761 <span class="comment">  Return Value:</span>
00762 <span class="comment"></span>
00763 <span class="comment">     RestoreHandle to be passed to make the Irp touchable again, or to free it.</span>
00764 <span class="comment"></span>
00765 <span class="comment">--*/</span>
00766 {
00767     ULONG howModified;
00768 
00769     <span class="keywordflow">if</span> (!<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>) {
00770         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ;
00771     }
00772 
00773     <span class="keywordflow">if</span> (Permanent) {
00774         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>) ;
00775         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00776     }
00777 
00778     howModified = (ULONG) <a class="code" href="../../d1/d6/allocpag_8c.html#a67">MmProtectSpecialPool</a>(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, PAGE_NOACCESS);
00779 
00780     <span class="keywordflow">switch</span>(howModified) {
00781 
00782         <span class="keywordflow">case</span> (ULONG) -1:
00783 
00784             <span class="comment">//</span>
00785             <span class="comment">// Didn't come from special pool.</span>
00786             <span class="comment">//</span>
00787             <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00788 
00789         <span class="keywordflow">case</span> 0:
00790 
00791             <span class="comment">//</span>
00792             <span class="comment">// Can't comply with request, ref counts, etc hold down page.</span>
00793             <span class="comment">//</span>
00794             <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00795 
00796         <span class="keywordflow">default</span>:
00797 
00798             <span class="comment">//</span>
00799             <span class="comment">// Allocation has been successfully marked as untouchable.</span>
00800             <span class="comment">//</span>
00801             <span class="keywordflow">return</span> (PVOID) <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>;
00802     }
00803 }
00804 
00805 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00806 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l00807"></a><a class="code" href="../../d9/d8/hashirp_8h.html#a18">00807</a> <a class="code" href="../../d9/d8/hashirp_8h.html#a18">IovpProtectedIrpMakeTouchable</a>(
00808     IN  <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>    Irp,
00809     IN  PVOID   *RestoreHandle
00810     )
00811 <span class="comment">/*++</span>
00812 <span class="comment"></span>
00813 <span class="comment">  Description:</span>
00814 <span class="comment"></span>
00815 <span class="comment">    This routine makes the an IRP touchable if previously untouchable.</span>
00816 <span class="comment"></span>
00817 <span class="comment">  Arguments:</span>
00818 <span class="comment"></span>
00819 <span class="comment">    Irp           - Pointer to the Irp to make untouchable</span>
00820 <span class="comment">    RestoreHandle - Pointer to handle returned by IovpProtectedIrpMakeUntouchable</span>
00821 <span class="comment"></span>
00822 <span class="comment"></span>
00823 <span class="comment">  Return Value:</span>
00824 <span class="comment"></span>
00825 <span class="comment">     None.</span>
00826 <span class="comment">--*/</span>
00827 {
00828     <span class="keywordflow">if</span> (*RestoreHandle) {
00829 
00830         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(*RestoreHandle == <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>);
00831         <a class="code" href="../../d1/d6/allocpag_8c.html#a67">MmProtectSpecialPool</a>(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, PAGE_READWRITE) ;
00832         *RestoreHandle = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ;
00833     }
00834 }
00835 
00836 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00837 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l00838"></a><a class="code" href="../../d9/d8/hashirp_8h.html#a19">00838</a> <a class="code" href="../../d9/d8/hashirp_8h.html#a19">IovpProtectedIrpFree</a>(
00839     IN  <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>  Irp OPTIONAL,
00840     IN  PVOID *RestoreHandle
00841     )
00842 <span class="comment">/*++</span>
00843 <span class="comment"></span>
00844 <span class="comment">  Description:</span>
00845 <span class="comment"></span>
00846 <span class="comment">    This routine is called when the call stack has entirely unwound</span>
00847 <span class="comment">    and the IRP has completed. At this point it is no longer really</span>
00848 <span class="comment">    useful to hold the surrogate IRP around. As we are using the</span>
00849 <span class="comment">    special pool currently, this routine needs to do nothing.</span>
00850 <span class="comment"></span>
00851 <span class="comment">  Arguments:</span>
00852 <span class="comment"></span>
00853 <span class="comment">    IrpTrackingData        - Pointer to the IRP tracking data.</span>
00854 <span class="comment"></span>
00855 <span class="comment">  Return Value:</span>
00856 <span class="comment"></span>
00857 <span class="comment">     None.</span>
00858 <span class="comment">--*/</span>
00859 {
00860     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>((*RestoreHandle) == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00861 }
00862 
00863 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00864 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l00865"></a><a class="code" href="../../d9/d8/hashirp_8h.html#a15">00865</a> <a class="code" href="../../d9/d8/hashirp_8h.html#a15">IovpWatermarkIrp</a>(
00866     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>  Irp,
00867     IN ULONG Flags
00868     )
00869 {
00870     <a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html">PIOV_REQUEST_PACKET</a> iovPacket;
00871 
00872     iovPacket = <a class="code" href="../../d9/d8/hashirp_8h.html#a7">IovpTrackingDataFindAndLock</a>(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>);
00873 
00874     <span class="keywordflow">if</span> (iovPacket == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00875 
00876         <span class="keywordflow">return</span>;
00877     }
00878 
00879     <span class="keywordflow">if</span> (Flags &amp; <a class="code" href="../../d9/d4/trackirp_8h.html#a58">IRP_SYSTEM_RESTRICTED</a>) {
00880 
00881         <span class="comment">//</span>
00882         <span class="comment">// Note that calling this function is not in itself enough to get the</span>
00883         <span class="comment">// system to prevent drivers from sending restricted IRPs. Those IRPs to</span>
00884         <span class="comment">// be protected must also be added to IovpIsSystemRestrictedIrp in</span>
00885         <span class="comment">// flunkirp.c</span>
00886         <span class="comment">//</span>
00887         iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o5">Flags</a> |= <a class="code" href="../../d9/d4/trackirp_8h.html#a34">TRACKFLAG_WATERMARKED</a>;
00888     }
00889 
00890     <span class="keywordflow">if</span> (Flags &amp; <a class="code" href="../../d9/d4/trackirp_8h.html#a59">IRP_BOGUS</a>) {
00891 
00892         iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o5">Flags</a> |= <a class="code" href="../../d9/d4/trackirp_8h.html#a30">TRACKFLAG_BOGUS</a>;
00893     }
00894 
00895     <a class="code" href="../../d9/d8/hashirp_8h.html#a12">IovpTrackingDataReleaseLock</a>(iovPacket);
00896 }
00897 
00898 <span class="preprocessor">#endif // NO_SPECIAL_IRP</span>
00899 <span class="preprocessor"></span>
00900 
00901 
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:40:15 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
