<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: udfs/fsctrl.c File Reference</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>fsctrl.c File Reference</h1><code>#include "UdfProcs.h"</code><br>

<p>
<a href="../../d0/d7/udfs_2fsctrl_8c-source.html">Go to the source code of this file.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d9/d7/udfs_2fsctrl_8c.html#a0">BugCheckFileId</a>&nbsp;&nbsp;&nbsp;(UDFS_BUG_CHECK_FSCTRL)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d9/d7/udfs_2fsctrl_8c.html#a1">Dbg</a>&nbsp;&nbsp;&nbsp;(UDFS_DEBUG_LEVEL_FSCTRL)</td></tr>

<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>INLINE VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d9/d7/udfs_2fsctrl_8c.html#a3">UdfStoreFileSetDescriptorIfPrevailing</a> (IN OUT <a class="el" href="../../d2/d2/structNSR__FSD.html">PNSR_FSD</a> *StoredFSD, IN OUT <a class="el" href="../../d2/d2/structNSR__FSD.html">PNSR_FSD</a> *NewFSD)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d9/d7/udfs_2fsctrl_8c.html#a4">UdfDetermineVolumeBounding</a> (IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext, IN <a class="el" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb, IN PULONG S, IN PULONG N)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d9/d7/udfs_2fsctrl_8c.html#a5">UdfDismountVolume</a> (IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext, IN <a class="el" href="../../d0/d2/struct__IRP.html">PIRP</a> <a class="el" href="../../d0/d6/iop_8h.html#a35">Irp</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d9/d7/udfs_2fsctrl_8c.html#a6">UdfFindAnchorVolumeDescriptor</a> (IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext, IN <a class="el" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb, IN OUT <a class="el" href="../../d7/d1/structNSR__ANCHOR.html">PNSR_ANCHOR</a> *AnchorVolumeDescriptor)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d9/d7/udfs_2fsctrl_8c.html#a7">UdfFindFileSetDescriptor</a> (IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext, IN <a class="el" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb, IN <a class="el" href="../../d4/d9/structLONGAD.html">PLONGAD</a> LongAd, IN OUT <a class="el" href="../../d2/d2/structNSR__FSD.html">PNSR_FSD</a> *FileSetDescriptor)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d9/d7/udfs_2fsctrl_8c.html#a8">UdfFindVolumeDescriptors</a> (IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext, IN <a class="el" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb, IN <a class="el" href="../../d3/d9/structEXTENTAD.html">PEXTENTAD</a> Extent, IN OUT <a class="el" href="../../d4/d9/struct__PCB.html">PPCB</a> *Pcb, IN OUT <a class="el" href="../../d0/d3/structNSR__PVD.html">PNSR_PVD</a> *PrimaryVolumeDescriptor, IN OUT <a class="el" href="../../d6/d2/structNSR__LVOL.html">PNSR_LVOL</a> *LogicalVolumeDescriptor)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d9/d7/udfs_2fsctrl_8c.html#a9">UdfInvalidateVolumes</a> (IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext, IN <a class="el" href="../../d0/d2/struct__IRP.html">PIRP</a> <a class="el" href="../../d0/d6/iop_8h.html#a35">Irp</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d9/d7/udfs_2fsctrl_8c.html#a10">UdfIsPathnameValid</a> (IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext, IN <a class="el" href="../../d0/d2/struct__IRP.html">PIRP</a> <a class="el" href="../../d0/d6/iop_8h.html#a35">Irp</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d9/d7/udfs_2fsctrl_8c.html#a11">UdfIsRemount</a> (IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext, IN <a class="el" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb, OUT <a class="el" href="../../d7/d5/struct__VCB.html">PVCB</a> *OldVcb)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d9/d7/udfs_2fsctrl_8c.html#a12">UdfIsVolumeDirty</a> (IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext, IN <a class="el" href="../../d0/d2/struct__IRP.html">PIRP</a> <a class="el" href="../../d0/d6/iop_8h.html#a35">Irp</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d9/d7/udfs_2fsctrl_8c.html#a13">UdfIsVolumeMounted</a> (IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext, IN <a class="el" href="../../d0/d2/struct__IRP.html">PIRP</a> <a class="el" href="../../d0/d6/iop_8h.html#a35">Irp</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d9/d7/udfs_2fsctrl_8c.html#a14">UdfLockVolume</a> (IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext, IN <a class="el" href="../../d0/d2/struct__IRP.html">PIRP</a> <a class="el" href="../../d0/d6/iop_8h.html#a35">Irp</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d9/d7/udfs_2fsctrl_8c.html#a15">UdfMountVolume</a> (IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext, IN <a class="el" href="../../d0/d2/struct__IRP.html">PIRP</a> <a class="el" href="../../d0/d6/iop_8h.html#a35">Irp</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d9/d7/udfs_2fsctrl_8c.html#a16">UdfOplockRequest</a> (IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext, IN <a class="el" href="../../d0/d2/struct__IRP.html">PIRP</a> <a class="el" href="../../d0/d6/iop_8h.html#a35">Irp</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d9/d7/udfs_2fsctrl_8c.html#a17">UdfRecognizeVolume</a> (IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext, IN <a class="el" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject, IN ULONG SectorSize, IN OUT PBOOLEAN Bridge)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d9/d7/udfs_2fsctrl_8c.html#a18">UdfScanForDismountedVcb</a> (IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d9/d7/udfs_2fsctrl_8c.html#a19">UdfUnlockVolume</a> (IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext, IN <a class="el" href="../../d0/d2/struct__IRP.html">PIRP</a> <a class="el" href="../../d0/d6/iop_8h.html#a35">Irp</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d9/d7/udfs_2fsctrl_8c.html#a20">UdfUpdateVolumeLabel</a> (IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext, IN PWCHAR VolumeLabel, IN OUT <a class="el" href="../../d0/d6/jul98_2test_2icc__i386_8h.html#a22">PUSHORT</a> VolumeLabelLength, IN PUCHAR Dstring, IN UCHAR FieldLength)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d9/d7/udfs_2fsctrl_8c.html#a21">UdfUpdateVolumeSerialNumber</a> (IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext, IN OUT PULONG VolumeSerialNumber, IN <a class="el" href="../../d2/d2/structNSR__FSD.html">PNSR_FSD</a> Fsd)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d9/d7/udfs_2fsctrl_8c.html#a22">UdfUserFsctl</a> (IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext, IN <a class="el" href="../../d0/d2/struct__IRP.html">PIRP</a> <a class="el" href="../../d0/d6/iop_8h.html#a35">Irp</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d9/d7/udfs_2fsctrl_8c.html#a23">UdfVerifyVolume</a> (IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext, IN <a class="el" href="../../d0/d2/struct__IRP.html">PIRP</a> <a class="el" href="../../d0/d6/iop_8h.html#a35">Irp</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d9/d7/udfs_2fsctrl_8c.html#a24">UdfStoreVolumeDescriptorIfPrevailing</a> (IN OUT <a class="el" href="../../d4/d3/structNSR__VD__GENERIC.html">PNSR_VD_GENERIC</a> *StoredVD, IN OUT <a class="el" href="../../d4/d3/structNSR__VD__GENERIC.html">PNSR_VD_GENERIC</a> NewVD)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d9/d7/udfs_2fsctrl_8c.html#a25">UdfCommonFsControl</a> (IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext, IN <a class="el" href="../../d0/d2/struct__IRP.html">PIRP</a> <a class="el" href="../../d0/d6/iop_8h.html#a35">Irp</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d9/d7/udfs_2fsctrl_8c.html#a26">UdfLockVolumeInternal</a> (IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext, IN <a class="el" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb, IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject OPTIONAL)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d9/d7/udfs_2fsctrl_8c.html#a27">UdfUnlockVolumeInternal</a> (IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext, IN <a class="el" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb, IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject OPTIONAL)</td></tr>

<tr><td colspan=2><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d9/d7/udfs_2fsctrl_8c.html#a2">UdfDisable</a> = FALSE</td></tr>

</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="a0" doxytag="udfs/fsctrl.c::BugCheckFileId" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define BugCheckFileId&nbsp;&nbsp;&nbsp;(UDFS_BUG_CHECK_FSCTRL)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l00028">28</a> of file <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html">udfs/fsctrl.c</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a1" doxytag="udfs/fsctrl.c::Dbg" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define Dbg&nbsp;&nbsp;&nbsp;(UDFS_DEBUG_LEVEL_FSCTRL)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l00034">34</a> of file <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html">udfs/fsctrl.c</a>.    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a25" doxytag="udfs/fsctrl.c::UdfCommonFsControl" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS UdfCommonFsControl           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>IrpContext</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d0/d2/struct__IRP.html">PIRP</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>Irp</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l00283">283</a> of file <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html">udfs/fsctrl.c</a>.
<p>
References <a class="el" href="../../d2/d7/udfdata_8h-source.html#l00356">ASSERT_IRP</a>, <a class="el" href="../../d2/d7/udfdata_8h-source.html#l00352">ASSERT_IRP_CONTEXT</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l03252">IoGetCurrentIrpStackLocation</a>, <a class="el" href="../../d1/d5/iop_8h-source.html#l00130">Irp</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l00113">IRP_MN_MOUNT_VOLUME</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l00112">IRP_MN_USER_FS_REQUEST</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l00114">IRP_MN_VERIFY_VOLUME</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02029">_IO_STACK_LOCATION::MinorFunction</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, <a class="el" href="../../d1/d7/udfdata_8c-source.html#l00809">UdfCompleteRequest()</a>, <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l01444">UdfMountVolume()</a>, <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l00363">UdfUserFsctl()</a>, and <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l02043">UdfVerifyVolume()</a>.
<p>
Referenced by <a class="el" href="../../d1/d7/udfdata_8c-source.html#l00218">UdfFsdDispatch()</a>, and <a class="el" href="../../d1/d7/fspdisp_8c-source.html#l00038">UdfFspDispatch()</a>.
<p>
<pre class="fragment"><div>00290                    :
00291 
00292     This <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> common routine <span class="keywordflow">for</span> doing FileSystem <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a58">control</a> operations called
00293     by both <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> fsd and fsp threads
00294 
00295 Arguments:
00296 
00297     <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> to process
00298 
00299 Return Value:
00300 
00301     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> - The <span class="keywordflow">return</span> status <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> operation
00302 
00303 --*/
00304 
00305 {
00306     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00307     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> IrpSp = <a class="code" href="../../d0/d5/io_8h.html#a228">IoGetCurrentIrpStackLocation</a>( Irp );
00308 
00309     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00310 
00311     <span class="comment">//</span>
00312     <span class="comment">//  Check the input parameters</span>
00313     <span class="comment">//</span>
00314 
00315     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
00316     <a class="code" href="../../d1/d8/udfdata_8h.html#a32">ASSERT_IRP</a>( Irp );
00317 
00318     <span class="comment">//</span>
00319     <span class="comment">//  Get a pointer to the current Irp stack location</span>
00320     <span class="comment">//</span>
00321 
00322     IrpSp = <a class="code" href="../../d0/d5/io_8h.html#a228">IoGetCurrentIrpStackLocation</a>( Irp );
00323 
00324     <span class="comment">//</span>
00325     <span class="comment">//  We know this is a file system control so we'll case on the</span>
00326     <span class="comment">//  minor function, and call a internal worker routine to complete</span>
00327     <span class="comment">//  the irp.</span>
00328     <span class="comment">//</span>
00329 
00330     <span class="keywordflow">switch</span> (IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o1">MinorFunction</a>) {
00331 
00332     <span class="keywordflow">case</span> <a class="code" href="../../d0/d5/io_8h.html#a47">IRP_MN_MOUNT_VOLUME</a>:
00333 
00334         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a15">UdfMountVolume</a>( IrpContext, Irp );
00335         <span class="keywordflow">break</span>;
00336 
00337     <span class="keywordflow">case</span> <a class="code" href="../../d0/d5/io_8h.html#a48">IRP_MN_VERIFY_VOLUME</a>:
00338 
00339         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a23">UdfVerifyVolume</a>( IrpContext, Irp );
00340         <span class="keywordflow">break</span>;
00341 
00342     <span class="keywordflow">case</span> <a class="code" href="../../d0/d5/io_8h.html#a46">IRP_MN_USER_FS_REQUEST</a>:
00343 
00344         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a22">UdfUserFsctl</a>( IrpContext, Irp );
00345         <span class="keywordflow">break</span>;
00346 
00347     <span class="keywordflow">default</span>:
00348 
00349         <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, Irp, STATUS_INVALID_DEVICE_REQUEST );
00350         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_DEVICE_REQUEST;
00351         <span class="keywordflow">break</span>;
00352     }
00353 
00354     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00355 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="udfs/fsctrl.c::UdfDetermineVolumeBounding" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID UdfDetermineVolumeBounding           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>IrpContext</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d7/d5/struct__VCB.html">PVCB</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>Vcb</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>S</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>N</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l03817">3817</a> of file <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html">udfs/fsctrl.c</a>.
<p>
References <a class="el" href="../../d2/d7/udfdata_8h-source.html#l00352">ASSERT_IRP_CONTEXT</a>, <a class="el" href="../../d2/d7/udfdata_8h-source.html#l00336">ASSERT_VCB</a>, <a class="el" href="../../d0/d5/cdfs__rec_8c-source.html#l00032">Dbg</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02290">DebugTrace</a>, <a class="el" href="../../d9/d2/lfsdata_8h-source.html#l00187">DebugUnwind</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d2/d7/fsrtl_8h-source.html#l01101">FsRtlAllocatePoolWithTag</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l00348">SwapCopyUchar4</a>, <a class="el" href="../../d2/d6/udfs_2nodetype_8h-source.html#l00158">TAG_CDROM_TOC</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l00436">try_leave</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l00453">UdfFreePool()</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l00443">UdfPagedPool</a>, <a class="el" href="../../d4/d6/deviosup_8c-source.html#l00573">UdfPerformDevIoCtrl()</a>, and <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l00406">UdfRaiseStatus()</a>.
<p>
Referenced by <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l01444">UdfMountVolume()</a>.
<p>
<pre class="fragment"><div>03826                    :
03827 
03828     This routine will figure <a class="code" href="../../d6/d0/wsprintf_8c.html#a0">out</a> where <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> base offset to discover volume descriptors
03829     lies and where <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> end of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> disc <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a>.  In <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <span class="keywordflow">case</span> where <span class="keyword">this</span> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> a non-CD media,
03830     <span class="keyword">this</span> will tend to not to set <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> end bound since there <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> no uniform way to figure
03831     that piece of information <a class="code" href="../../d6/d0/wsprintf_8c.html#a0">out</a>.
03832     
03833     The bounding information <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> used to start <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> hunt <span class="keywordflow">for</span> CD-UDF (UDF 1.5) volumes.
03834     Anyone who puts CD-UDF on non-CD media deserves what they get.
03835 
03836 Arguments:
03837 
03838     Vcb - the volume we are operating on
03839     
03840     S - an address to store the start of the volume for the purposes of finding descriptors
03841     
03842     N - an address to store the end of the volume for the purposes of finding descriptors
03843 
03844 Return Value:
03845 
03846     None.
03847     
03848     Benign inability find the S/N information will result in 0/0 being returned.
03849 
03850 --*/
03851 
03852 {
03853     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
03854     PCDROM_TOC CdromToc;
03855     PTRACK_DATA TrackData;
03856 
03857     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
03858 
03859     <span class="comment">//</span>
03860     <span class="comment">//  Check input.</span>
03861     <span class="comment">//</span>
03862 
03863     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
03864     <a class="code" href="../../d1/d8/udfdata_8h.html#a12">ASSERT_VCB</a>( Vcb );
03865 
03866     <span class="comment">//</span>
03867     <span class="comment">//  Allocate a buffer for the last session information.</span>
03868     <span class="comment">//</span>
03869 
03870     CdromToc = <a class="code" href="../../d1/d8/fsrtl_8h.html#a37">FsRtlAllocatePoolWithTag</a>( UdfPagedPool,
03871                                          <span class="keyword">sizeof</span>( CDROM_TOC ),
03872                                          TAG_CDROM_TOC );
03873 
03874     RtlZeroMemory( CdromToc, <span class="keyword">sizeof</span>( CDROM_TOC ));
03875 
03876     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( +1, Dbg,
03877                <span class="stringliteral">"UdfDetermineVolumeBounding, Vcb %08x S %08x N %08x\n"</span>,
03878                Vcb,
03879                S,
03880                N ));
03881         
03882     <span class="comment">//</span>
03883     <span class="comment">//  Whack the inputs to the benign state.</span>
03884     <span class="comment">//</span>
03885     
03886     *S = *N = 0;
03887 
03888     <span class="comment">//</span>
03889     <span class="comment">//  Try to retrieve the CDROM last session information.</span>
03890     <span class="comment">//</span>
03891 
03892     <span class="keywordflow">try</span> {
03893 
03894         <span class="comment">//</span>
03895         <span class="comment">//  Pull up the TOC.  The information for track AA (start of leadout)</span>
03896         <span class="comment">//  will get us the end of disc within some tolerance dependent on how</span>
03897         <span class="comment">//  much the device manufacturer paid attention to specifications.</span>
03898         <span class="comment">//  (-152, -150, -2, and 0 are possible offsets to the real end).</span>
03899         <span class="comment">//</span>
03900         
03901         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d3/d8/udfprocs_8h.html#a159">UdfPerformDevIoCtrl</a>( IrpContext,
03902                                       IOCTL_CDROM_READ_TOC,
03903                                       Vcb-&gt;TargetDeviceObject,
03904                                       CdromToc,
03905                                       <span class="keyword">sizeof</span>( CDROM_TOC ),
03906                                       FALSE,
03907                                       TRUE,
03908                                       NULL );
03909 
03910         <span class="comment">//</span>
03911         <span class="comment">//  Raise an exception if there was an allocation failure.</span>
03912         <span class="comment">//</span>
03913 
03914         <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_INSUFFICIENT_RESOURCES) {
03915 
03916             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg, <span class="stringliteral">"UdfDetermineVolumeBounding, READ_TOC failed INSUFFICIENT_RESOURCES\n"</span> ));
03917             <a class="code" href="../../d3/d8/udfprocs_8h.html#a122">UdfRaiseStatus</a>( IrpContext, Status );
03918         }
03919 
03920         <span class="comment">//</span>
03921         <span class="comment">//  For other errors, just fail.  Perhaps this will turn out to be benign, in any case</span>
03922         <span class="comment">//  the mount will rapidly and correctly fail if it really was dependant on this work.</span>
03923         <span class="comment">//</span>
03924         
03925         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
03926 
03927             <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( NOTHING );
03928         }
03929 
03930         <span class="comment">//</span>
03931         <span class="comment">//  Sanity chck that the TOC is well-bounded.</span>
03932         <span class="comment">//</span>
03933         
03934         <span class="keywordflow">if</span> (CdromToc-&gt;LastTrack - CdromToc-&gt;FirstTrack &gt;= MAXIMUM_NUMBER_TRACKS) {
03935 
03936             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg, <span class="stringliteral">"UdfDetermineVolumeBounding, TOC malf (too many tracks)\n"</span> ));
03937             <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( NOTHING );
03938         }
03939 
03940         TrackData = &amp;CdromToc-&gt;TrackData[(CdromToc-&gt;LastTrack - CdromToc-&gt;FirstTrack + 1)];
03941 
03942 <span class="preprocessor">#if 0</span>
03943 <span class="preprocessor"></span>        <span class="comment">//</span>
03944         <span class="comment">//  Better be AA ...</span>
03945         <span class="comment">//</span>
03946         
03947         <span class="keywordflow">if</span> (TrackData-&gt;TrackNumber != 0xaa) {
03948 
03949             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg, <span class="stringliteral">"UdfDetermineVolumeBounding, TOC malf (aa not last)\n"</span> ));
03950             <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( NOTHING );
03951         }
03952 <span class="preprocessor">#endif</span>
03953 <span class="preprocessor"></span>
03954         <span class="comment">//</span>
03955         <span class="comment">//  Now, find the AA info and convert MSF to a logical block address.  75 frames/sectors</span>
03956         <span class="comment">//  per second, 60 seconds per minute.  The MSF address is stored LSB (the F byte) high</span>
03957         <span class="comment">//  in the word.</span>
03958         <span class="comment">//</span>
03959 
03960         <span class="comment">//</span>
03961         <span class="comment">//  NOTE: MSF is only capable of representing 256*(256+256*60)*75 = 0x11ce20 sectors.</span>
03962         <span class="comment">//  This is 2.3gb, much less than the size of DVD media, which will respond to CDROM_TOC.</span>
03963         <span class="comment">//  Caveat user.</span>
03964         <span class="comment">//</span>
03965 
03966         *N = (TrackData-&gt;Address[3] + (TrackData-&gt;Address[2] + TrackData-&gt;Address[1] * 60) * 75) - 1;
03967 
03968         <span class="comment">//</span>
03969         <span class="comment">//  We must bias back by 0/2/0 MSF since that is the defined location of sector 0.  This</span>
03970         <span class="comment">//  works out to 150 sectors.</span>
03971         <span class="comment">//</span>
03972         
03973         <span class="keywordflow">if</span> (*N &lt;= 150) {
03974 
03975             *N = 0;
03976             <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( NOTHING );
03977         }
03978 
03979         *N -= 150;
03980 
03981         <span class="comment">//</span>
03982         <span class="comment">//  Query the last session information from the driver.</span>
03983         <span class="comment">//</span>
03984 
03985         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d3/d8/udfprocs_8h.html#a159">UdfPerformDevIoCtrl</a>( IrpContext,
03986                                       IOCTL_CDROM_GET_LAST_SESSION,
03987                                       Vcb-&gt;TargetDeviceObject,
03988                                       CdromToc,
03989                                       <span class="keyword">sizeof</span>( CDROM_TOC ),
03990                                       FALSE,
03991                                       TRUE,
03992                                       NULL );
03993 
03994         <span class="comment">//</span>
03995         <span class="comment">//  Raise an exception if there was an allocation failure.</span>
03996         <span class="comment">//</span>
03997 
03998         <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_INSUFFICIENT_RESOURCES) {
03999 
04000             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg, <span class="stringliteral">"UdfDetermineVolumeBounding, GET_LAST_SESSION failed INSUFFICIENT_RESOURCES\n"</span> ));
04001             <a class="code" href="../../d3/d8/udfprocs_8h.html#a122">UdfRaiseStatus</a>( IrpContext, Status );
04002         }
04003 
04004         <span class="comment">//</span>
04005         <span class="comment">//  Now, if we got anything interesting out of this try, return it.  If this                                                </span>
04006         <span class="comment">//  failed for any other reason, we don't really care - it just means that</span>
04007         <span class="comment">//  if this was CDUDF media, we're gonna fail to figure it out pretty quickly.</span>
04008         <span class="comment">//</span>
04009         <span class="comment">//  Life is tough.</span>
04010         <span class="comment">//</span>
04011 
04012         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status ) &amp;&amp;
04013             CdromToc-&gt;FirstTrack != CdromToc-&gt;LastTrack) {
04014 
04015             <span class="comment">//</span>
04016             <span class="comment">//  The 0 entry in TrackData tells us about the start of the session as a</span>
04017             <span class="comment">//  logical block address.</span>
04018             <span class="comment">//</span>
04019 
04020             <a class="code" href="../../d3/d8/udfprocs_8h.html#a60">SwapCopyUchar4</a>( S, &amp;CdromToc-&gt;TrackData[0].Address );
04021 
04022             <span class="comment">//</span>
04023             <span class="comment">//  Save grief if the session info is screwed up.</span>
04024             <span class="comment">//</span>
04025             
04026             <span class="keywordflow">if</span> (*N &lt;= *S) {
04027 
04028                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg, <span class="stringliteral">"UdfDetermineVolumeBounding, N before S, whacking both back!\n"</span> ));
04029                 *S = *N = 0;
04030             }
04031         }
04032 
04033         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg, <span class="stringliteral">"UdfDetermineVolumeBounding, S %08x N %08x\n"</span>, *S, *N ));
04034 
04035     } finally {
04036 
04037         <a class="code" href="../../d8/d3/lfsdata_8h.html#a3">DebugUnwind</a>( <span class="stringliteral">"UdfDetermineVolumeBounding"</span> );
04038         
04039         <span class="keywordflow">if</span> (CdromToc != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
04040             
04041             <a class="code" href="../../d3/d8/udfprocs_8h.html#a124">UdfFreePool</a>( &amp;CdromToc );
04042         }
04043     }
04044 
04045     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, Dbg, <span class="stringliteral">"UdfDetermineVolumeBounding -&gt; VOID\n"</span> ));
04046 
04047     <span class="keywordflow">return</span>;
04048 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="udfs/fsctrl.c::UdfDismountVolume" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS UdfDismountVolume           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>IrpContext</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d0/d2/struct__IRP.html">PIRP</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>Irp</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l00966">966</a> of file <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html">udfs/fsctrl.c</a>.
<p>
References <a class="el" href="../../d1/d4/io_8h-source.html#l01153">DO_VERIFY_VOLUME</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02494">_IO_STACK_LOCATION::FileObject</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01184">_DEVICE_OBJECT::Flags</a>, <a class="el" href="../../d2/d7/fsrtl_8h-source.html#l01421">FSRTL_VOLUME_DISMOUNT</a>, <a class="el" href="../../d2/d7/fsrtl_8h-source.html#l01422">FSRTL_VOLUME_DISMOUNT_FAILED</a>, <a class="el" href="../../d4/d8/fsrtl_2pnp_8c-source.html#l00041">FsRtlNotifyVolumeEvent()</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l03252">IoGetCurrentIrpStackLocation</a>, <a class="el" href="../../d1/d5/iop_8h-source.html#l00130">Irp</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01073">_VPB::RealDevice</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00505">SetFlag</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l01515">UdfAcquireVcbExclusive</a>, <a class="el" href="../../d1/d7/udfdata_8c-source.html#l00809">UdfCompleteRequest()</a>, <a class="el" href="../../d7/d2/filobsup_8c-source.html#l00133">UdfDecodeFileObject()</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l01521">UdfReleaseVcb</a>, <a class="el" href="../../d3/d8/udfprocs_8h.html#a263a115">UserVolumeOpen</a>, <a class="el" href="../../d7/d7/udfstruc_8h-source.html#l00941">_FCB::Vcb</a>, <a class="el" href="../../d7/d7/udfstruc_8h-source.html#l00685">VCB_STATE_NOTIFY_REMOUNT</a>, <a class="el" href="../../d7/d7/udfstruc_8h-source.html#l00559">_VCB::VcbCondition</a>, <a class="el" href="../../d6/d8/udfstruc_8h.html#a130a119">VcbMounted</a>, <a class="el" href="../../d7/d7/udfstruc_8h-source.html#l00558">_VCB::VcbState</a>, <a class="el" href="../../d7/d7/udfstruc_8h-source.html#l00565">_VCB::VolumeLockFileObject</a>, and <a class="el" href="../../d7/d7/udfstruc_8h-source.html#l00529">_VCB::Vpb</a>.
<p>
Referenced by <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l00363">UdfUserFsctl()</a>.
<p>
<pre class="fragment"><div>00973                    :
00974 
00975     This routine performs <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> dismount volume operation.  It <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> responsible <span class="keywordflow">for</span>
00976     either completing of enqueuing <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> input <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>.  We <a class="code" href="../../d3/d0/imm32_8def.html#a1">only</a> dismount a volume which
00977     has been locked.  The intent here <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> that someone has locked <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> volume (they are the
00978     only remaining handle).  We set <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> volume state to invalid so that <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> will be torn
00979     down quickly.
00980 
00981 Arguments:
00982 
00983     <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> to process
00984 
00985 Return Value:
00986 
00987     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> - The <span class="keywordflow">return</span> status <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> operation
00988 
00989 --*/
00990 
00991 {
00992     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00993     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> IrpSp = <a class="code" href="../../d0/d5/io_8h.html#a228">IoGetCurrentIrpStackLocation</a>( Irp );
00994 
00995     <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb;
00996     <a class="code" href="../../d7/d9/struct__FCB.html">PFCB</a> Fcb;
00997     <a class="code" href="../../d2/d9/struct__CCB.html">PCCB</a> Ccb;
00998 
00999     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01000 
01001     <span class="keywordflow">if</span> (<a class="code" href="../../d3/d8/udfprocs_8h.html#a174">UdfDecodeFileObject</a>( IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a>, &amp;Fcb, &amp;Ccb ) != <a class="code" href="../../d3/d8/udfprocs_8h.html#a263a115">UserVolumeOpen</a> ) {
01002 
01003         <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, Irp, STATUS_INVALID_PARAMETER );
01004         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
01005     }
01006 
01007     <span class="comment">//</span>
01008     <span class="comment">//  Send notification.</span>
01009     <span class="comment">//</span>
01010     
01011     <a class="code" href="../../d1/d8/fsrtl_8h.html#a168">FsRtlNotifyVolumeEvent</a>( IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a>, FSRTL_VOLUME_DISMOUNT );
01012 
01013     <span class="comment">//</span>
01014     <span class="comment">//  Acquire exclusive access to the Vcb.</span>
01015     <span class="comment">//</span>
01016 
01017     Vcb = Fcb-&gt;<a class="code" href="../../d7/d9/struct__FCB.html#o2">Vcb</a>;
01018 
01019     <a class="code" href="../../d3/d8/udfprocs_8h.html#a74">UdfAcquireVcbExclusive</a>( IrpContext, Vcb, FALSE );
01020 
01021     <span class="comment">//</span>
01022     <span class="comment">//  Mark the volume as invalid, but only do it if the vcb is locked</span>
01023     <span class="comment">//  by this handle and the volume is currently mounted.  No more</span>
01024     <span class="comment">//  operations will occur on this vcb except cleanup/close.</span>
01025     <span class="comment">//</span>
01026 
01027     <span class="keywordflow">if</span> ((Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o8">VcbCondition</a> != <a class="code" href="../../d6/d8/udfstruc_8h.html#a130a119">VcbMounted</a>) &amp;&amp;
01028         (Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o9">VolumeLockFileObject</a> != IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a>)) {
01029 
01030         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_NOT_IMPLEMENTED;
01031 
01032     } <span class="keywordflow">else</span> {
01033 
01034         <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>( Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o2">Vpb</a>-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o5">RealDevice</a>-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o8">Flags</a>, DO_VERIFY_VOLUME );
01035         <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>( Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o7">VcbState</a>, VCB_STATE_NOTIFY_REMOUNT );
01036 
01037         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
01038     }
01039 
01040     <span class="comment">//</span>
01041     <span class="comment">//  Release all of our resources</span>
01042     <span class="comment">//</span>
01043 
01044     <a class="code" href="../../d3/d8/udfprocs_8h.html#a76">UdfReleaseVcb</a>( IrpContext, Vcb );
01045 
01046     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
01047 
01048         <a class="code" href="../../d1/d8/fsrtl_8h.html#a168">FsRtlNotifyVolumeEvent</a>( IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a>, FSRTL_VOLUME_DISMOUNT_FAILED );
01049     }
01050 
01051     <span class="comment">//</span>
01052     <span class="comment">//  Complete the request if there haven't been any exceptions.</span>
01053     <span class="comment">//</span>
01054 
01055     <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, Irp, Status );
01056     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01057 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="udfs/fsctrl.c::UdfFindAnchorVolumeDescriptor" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS UdfFindAnchorVolumeDescriptor           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>IrpContext</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d7/d5/struct__VCB.html">PVCB</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>Vcb</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN OUT <a class="el" href="../../d7/d1/structNSR__ANCHOR.html">PNSR_ANCHOR</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>AnchorVolumeDescriptor</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l03307">3307</a> of file <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html">udfs/fsctrl.c</a>.
<p>
References <a class="el" href="../../d1/d6/iso13346_8h-source.html#l00361">ANCHOR_SECTOR</a>, <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d2/d7/udfdata_8h-source.html#l00352">ASSERT_IRP_CONTEXT</a>, <a class="el" href="../../d2/d7/udfdata_8h-source.html#l00336">ASSERT_VCB</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00509">ClearFlag</a>, <a class="el" href="../../d0/d5/cdfs__rec_8c-source.html#l00032">Dbg</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02290">DebugTrace</a>, <a class="el" href="../../d1/d6/iso13346_8h-source.html#l00319">DESTAG_ID_NSR_ANCHOR</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d2/d7/fsrtl_8h-source.html#l01101">FsRtlAllocatePoolWithTag</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l00220">LlBytesFromSectors</a>, <a class="el" href="../../d0/d7/iso13346_8h.html#a205">NSR_ANCHOR</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00505">SetFlag</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, <a class="el" href="../../d2/d6/udfs_2nodetype_8h-source.html#l00179">TAG_NSR_VDSD</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, <a class="el" href="../../d0/d7/udf_8h-source.html#l00184">UdfMethod2TransformSector</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l00444">UdfNonPagedPool</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l00931">UdfRawBufferSize()</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l00941">UdfRawReadSize()</a>, <a class="el" href="../../d4/d6/deviosup_8c-source.html#l00685">UdfReadSectors()</a>, <a class="el" href="../../d0/d7/udfs_2strucsup_8c-source.html#l02617">UdfVerifyDescriptor()</a>, and <a class="el" href="../../d7/d7/udfstruc_8h-source.html#l00686">VCB_STATE_METHOD_2_FIXUP</a>.
<p>
Referenced by <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l01444">UdfMountVolume()</a>, and <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l02043">UdfVerifyVolume()</a>.
<p>
<pre class="fragment"><div>03315                    :
03316 
03317     This routine will find <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Anchor Volume Descriptor <span class="keywordflow">for</span> a piece of media
03318 
03319 Arguments:
03320 
03321     Vcb - Vcb of volume to search
03322 
03323     AnchorVolumeDescriptor - Caller's pointer to an AVD
03324 
03325 Return Value:
03326 
03327     <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a21">Boolean</a> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> <span class="keywordflow">if</span> AVD <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> discovered, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> otherwise.
03328 
03329 --*/
03330 
03331 {
03332     ULONG ThisPass;
03333     ULONG ReadLsn;
03334     ULONG Lsn;
03335     BOOLEAN Found = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03336     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
03337 
03338     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
03339 
03340     <span class="comment">//</span>
03341     <span class="comment">//  Check the input parameters</span>
03342     <span class="comment">//</span>
03343 
03344     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext);
03345     <a class="code" href="../../d1/d8/udfdata_8h.html#a12">ASSERT_VCB</a>( Vcb );
03346 
03347     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(*AnchorVolumeDescriptor == NULL);
03348 
03349     <span class="comment">//</span>
03350     <span class="comment">//  Discover the Anchor Volume Descriptor, which will point towards the</span>
03351     <span class="comment">//  Volume Set Descriptor Sequence.  The AVD may exist at sector 256 or</span>
03352     <span class="comment">//  in the last sector of the volume.</span>
03353     <span class="comment">//</span>
03354 
03355     *AnchorVolumeDescriptor = (<a class="code" href="../../d7/d1/structNSR__ANCHOR.html">PNSR_ANCHOR</a>) <a class="code" href="../../d1/d8/fsrtl_8h.html#a37">FsRtlAllocatePoolWithTag</a>( UdfNonPagedPool,
03356                                                                       <a class="code" href="../../d3/d8/udfprocs_8h.html#a163">UdfRawBufferSize</a>( Vcb, <span class="keyword">sizeof</span>(<a class="code" href="../../d7/d1/structNSR__ANCHOR.html">NSR_ANCHOR</a>) ),
03357                                                                       TAG_NSR_VDSD );
03358 
03359 
03360     <span class="comment">//</span>
03361     <span class="comment">//  Search the three possible locations for an AVD to exist on the volume,</span>
03362     <span class="comment">//  plus check for the possibility of a method 2 fixup requirement.</span>
03363     <span class="comment">//</span>
03364 
03365     <span class="keywordflow">for</span> ( ThisPass = 1; ThisPass &lt;= 4; ThisPass++ ) {
03366 
03367         <span class="keywordflow">if</span> (ThisPass == 1) {
03368 
03369             ReadLsn = Lsn = <a class="code" href="../../d0/d7/iso13346_8h.html#a63">ANCHOR_SECTOR</a> + Vcb-&gt;BoundS;
03370 
03371         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ThisPass == 2) {
03372 
03373             <span class="comment">//</span>
03374             <span class="comment">//  It is so unlikely that we will get a disk that doesn't have</span>
03375             <span class="comment">//  an anchor at 256 that this is a pretty good indication we</span>
03376             <span class="comment">//  have a CD-RW here and the drive is method 2 goofy.  Take</span>
03377             <span class="comment">//  a shot.</span>
03378             <span class="comment">//</span>
03379 
03380             ReadLsn = <a class="code" href="../../d9/d7/udf_8h.html#a9">UdfMethod2TransformSector</a>( Vcb, ANCHOR_SECTOR );
03381             Lsn = <a class="code" href="../../d0/d7/iso13346_8h.html#a63">ANCHOR_SECTOR</a>;
03382 
03383         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ThisPass == 3) {
03384 
03385             <span class="comment">//</span>
03386             <span class="comment">//  Our remaining two chances depend on being able to determine</span>
03387             <span class="comment">//  the last recorded sector for the volume.  If we were unable</span>
03388             <span class="comment">//  to do this, stop.</span>
03389             <span class="comment">//</span>
03390 
03391             <span class="keywordflow">if</span> (!Vcb-&gt;BoundN) {
03392 
03393                 <span class="keywordflow">break</span>;
03394             }
03395 
03396             ReadLsn = Lsn = Vcb-&gt;BoundN;
03397 
03398         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ThisPass == 4) {
03399 
03400             ReadLsn = Lsn = Vcb-&gt;BoundN - <a class="code" href="../../d0/d7/iso13346_8h.html#a63">ANCHOR_SECTOR</a>;
03401         }
03402 
03403         <span class="comment">//</span>
03404         <span class="comment">//  We may have more chances to succeed if failure occurs.</span>
03405         <span class="comment">//</span>
03406 
03407         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d3/d8/udfprocs_8h.html#a160">UdfReadSectors</a>( IrpContext,
03408                                  <a class="code" href="../../d3/d8/udfprocs_8h.html#a39">LlBytesFromSectors</a>( Vcb, ReadLsn ),
03409                                  <a class="code" href="../../d3/d8/udfprocs_8h.html#a164">UdfRawReadSize</a>( Vcb, <span class="keyword">sizeof</span>(<a class="code" href="../../d7/d1/structNSR__ANCHOR.html">NSR_ANCHOR</a>) ),
03410                                  TRUE,
03411                                  *AnchorVolumeDescriptor,
03412                                  Vcb-&gt;TargetDeviceObject );
03413 
03414         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
03415             <span class="keywordflow">continue</span>;
03416         }
03417 
03418         <span class="keywordflow">if</span> (!<a class="code" href="../../d3/d8/udfprocs_8h.html#a219">UdfVerifyDescriptor</a>( IrpContext,
03419                                   &amp;(*AnchorVolumeDescriptor)-&gt;Destag,
03420                                   DESTAG_ID_NSR_ANCHOR,
03421                                   <span class="keyword">sizeof</span>(<a class="code" href="../../d7/d1/structNSR__ANCHOR.html">NSR_ANCHOR</a>),
03422                                   Lsn,
03423                                   TRUE)) {
03424 
03425             <span class="keywordflow">continue</span>;
03426         }
03427         
03428         <span class="comment">//</span>
03429         <span class="comment">//  Got one!  Set the method 2 fixup appropriately.</span>
03430         <span class="comment">//</span>
03431 
03432         <span class="keywordflow">if</span> (ThisPass == 2) {
03433 
03434             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg, <span class="stringliteral">"************************************************\n"</span>));
03435             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg, <span class="stringliteral">"METHOD 2 FIXUPS ACTIVATED FOR Vcb @ %08x\n"</span>, Vcb ));
03436             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg, <span class="stringliteral">"************************************************\n"</span>));
03437 
03438             <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>( Vcb-&gt;VcbState, VCB_STATE_METHOD_2_FIXUP );
03439         
03440         } <span class="keywordflow">else</span> {
03441             
03442             <a class="code" href="../../d5/d5/cc_8h.html#a61">ClearFlag</a>( Vcb-&gt;VcbState, VCB_STATE_METHOD_2_FIXUP );
03443         }
03444         
03445         <span class="keywordflow">return</span> STATUS_SUCCESS;
03446     }
03447 
03448     <span class="keywordflow">return</span> STATUS_UNRECOGNIZED_VOLUME;
03449 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a7" doxytag="udfs/fsctrl.c::UdfFindFileSetDescriptor" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS UdfFindFileSetDescriptor           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>IrpContext</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d7/d5/struct__VCB.html">PVCB</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>Vcb</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d4/d9/structLONGAD.html">PLONGAD</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>LongAd</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN OUT <a class="el" href="../../d2/d2/structNSR__FSD.html">PNSR_FSD</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>FileSetDescriptor</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l02558">2558</a> of file <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html">udfs/fsctrl.c</a>.
<p>
References <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d2/d7/udfdata_8h-source.html#l00352">ASSERT_IRP_CONTEXT</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l00280">BlockOffset</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l00278">BlockSize</a>, <a class="el" href="../../d0/d5/cdfs__rec_8c-source.html#l00032">Dbg</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02290">DebugTrace</a>, <a class="el" href="../../d1/d6/iso13346_8h-source.html#l00721">NSR_FSD::Destag</a>, <a class="el" href="../../d1/d6/iso13346_8h-source.html#l00317">DESTAG_ID_NOTSPEC</a>, <a class="el" href="../../d1/d6/iso13346_8h-source.html#l00334">DESTAG_ID_NSR_FSD</a>, <a class="el" href="../../d1/d6/iso13346_8h-source.html#l00325">DESTAG_ID_NSR_TERM</a>, <a class="el" href="../../d2/d7/fsrtl_8h-source.html#l01101">FsRtlAllocatePoolWithTag</a>, <a class="el" href="../../d1/d6/iso13346_8h-source.html#l00304">DESTAG::Ident</a>, <a class="el" href="../../d1/d6/iso13346_8h-source.html#l00141">NSRLENGTH::Length</a>, <a class="el" href="../../d1/d6/iso13346_8h-source.html#l00170">LONGAD::Length</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l00268">LlBytesFromBlocks</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l00220">LlBytesFromSectors</a>, <a class="el" href="../../d1/d6/iso13346_8h-source.html#l00737">NSR_FSD::NextExtent</a>, <a class="el" href="../../d0/d7/iso13346_8h.html#a231">NSR_FSD</a>, <a class="el" href="../../d1/d6/iso13346_8h-source.html#l00145">NSRLENGTH_TYPE_RECORDED</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l00033">Offset</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, <a class="el" href="../../d2/d6/udfs_2nodetype_8h-source.html#l00177">TAG_NSR_FSD</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l00436">try_leave</a>, <a class="el" href="../../d1/d7/udfdata_8c-source.html#l00448">UdfExceptionFilter()</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l00453">UdfFreePool()</a>, <a class="el" href="../../d3/d5/allocsup_8c-source.html#l01017">UdfLookupPsnOfExtent()</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l00444">UdfNonPagedPool</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l00931">UdfRawBufferSize()</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l00941">UdfRawReadSize()</a>, <a class="el" href="../../d4/d6/deviosup_8c-source.html#l00685">UdfReadSectors()</a>, <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l00048">UdfStoreFileSetDescriptorIfPrevailing()</a>, and <a class="el" href="../../d0/d7/udfs_2strucsup_8c-source.html#l02617">UdfVerifyDescriptor()</a>.
<p>
Referenced by <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l01444">UdfMountVolume()</a>, and <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l02043">UdfVerifyVolume()</a>.
<p>
<pre class="fragment"><div>02567                    :
02568 
02569     This routine walks a Fileset Descriptor Sequence looking <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <span class="keywordflow">default</span>
02570     descriptor.  This will reveal <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> location of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> root directory on <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
02571     volume.
02572 
02573 Arguments:
02574 
02575     Vcb - Vcb of volume to search
02576 
02577     LongAd - Long allocation descriptor describing <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> start of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> sequence
02578 
02579     FileSetDescriptor - Address of caller's pointer to an FSD
02580 
02581 Return Value:
02582 
02583     STATUS_SUCCESS <span class="keywordflow">if</span> all descriptors are found, read, and are valid.
02584 
02585     STATUS_DISK_CORRUPT_ERROR <span class="keywordflow">if</span> corrupt/bad descriptors are found (may be raised)
02586 
02587 --*/
02588 
02589 {
02590     <a class="code" href="../../d2/d2/structNSR__FSD.html">PNSR_FSD</a> FSD = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02591     ULONGLONG <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>;
02592     ULONG Lbn, Len;
02593 
02594     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
02595 
02596     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
02597 
02598     <span class="comment">//</span>
02599     <span class="comment">//  Check inputs</span>
02600     <span class="comment">//</span>
02601 
02602     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
02603     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( *FileSetDescriptor == NULL );
02604 
02605     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( +1, Dbg,
02606                  <span class="stringliteral">"UdfFindFileSetDescriptor, Vcb %08x, LongAd %08x %x/%08x +%08x (type %x)\n"</span>,
02607                  Vcb,
02608                  LongAd,
02609                  LongAd-&gt;Start.Partition,
02610                  LongAd-&gt;Start.Lbn,
02611                  LongAd-&gt;Length.Length,
02612                  LongAd-&gt;Length.Type ));
02613     
02614     <span class="comment">//</span>
02615     <span class="comment">//  If the extent we begin from is not a whole number of recorded logical blocks,</span>
02616     <span class="comment">//  we can't continue.</span>
02617     <span class="comment">//</span>
02618 
02619 <span class="preprocessor">#ifndef UDF_SUPPORT_NONSTANDARD_ALLSTOR</span>
02620 <span class="preprocessor"></span>    
02621     <span class="comment">//</span>
02622     <span class="comment">//  Disable checking the sanity of the longad here.</span>
02623     <span class="comment">//</span>
02624     <span class="comment">//  Reason: first drop of Allstor media recorded the type as unrecorded (!)</span>
02625     <span class="comment">//</span>
02626 
02627     <span class="keywordflow">if</span> (LongAd-&gt;Length.Length == 0 ||
02628         LongAd-&gt;Length.Type != <a class="code" href="../../d0/d7/iso13346_8h.html#a21">NSRLENGTH_TYPE_RECORDED</a> ||
02629         <a class="code" href="../../d3/d8/udfprocs_8h.html#a55">BlockOffset</a>( Vcb, LongAd-&gt;Length.Length )) {
02630 
02631         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( +0, Dbg,
02632                      <span class="stringliteral">"UdfFindFileSetDescriptor, bad longad length\n"</span> ));
02633         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, Dbg,
02634                      <span class="stringliteral">"UdfFindFileSetDescriptor -&gt;  STATUS_DISK_CORRUPT_ERROR\n"</span> ));
02635         
02636         <span class="keywordflow">return</span> STATUS_DISK_CORRUPT_ERROR;
02637     }
02638 
02639 <span class="preprocessor">#endif</span>
02640 <span class="preprocessor"></span>
02641     <span class="comment">//</span>
02642     <span class="comment">//  Use a try-finally for cleanup</span>
02643     <span class="comment">//</span>
02644 
02645     <span class="keywordflow">try</span> {
02646 
02647         <span class="keywordflow">try</span> {
02648             
02649             <span class="keywordflow">for</span> ( <span class="comment">//</span>
02650                   <span class="comment">//  Home ourselves in the search and make a pass through the sequence.</span>
02651                   <span class="comment">//</span>
02652 
02653                   Len = LongAd-&gt;Length.Length,
02654                   Lbn = LongAd-&gt;Start.Lbn,
02655                   <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> = <a class="code" href="../../d3/d8/udfprocs_8h.html#a39">LlBytesFromSectors</a>( Vcb, <a class="code" href="../../d3/d8/udfprocs_8h.html#a152">UdfLookupPsnOfExtent</a>( IrpContext,
02656                                                                           Vcb,
02657                                                                           LongAd-&gt;Start.Partition,
02658                                                                           Lbn,
02659                                                                           Len ));
02660 
02661                   Len;
02662 
02663                   <span class="comment">//</span>
02664                   <span class="comment">//  Advance to the next descriptor offset in the sequence.</span>
02665                   <span class="comment">//</span>
02666 
02667                   Len -= <a class="code" href="../../d3/d8/udfprocs_8h.html#a54">BlockSize</a>( Vcb ),
02668                   Lbn++,
02669                   <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> += <a class="code" href="../../d3/d8/udfprocs_8h.html#a54">BlockSize</a>( Vcb )) {
02670 
02671                 <span class="comment">//</span>
02672                 <span class="comment">//  Allocate a buffer to read fileset descriptors.</span>
02673                 <span class="comment">//</span>
02674 
02675                 <span class="keywordflow">if</span> (FSD == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02676 
02677                     FSD = <a class="code" href="../../d1/d8/fsrtl_8h.html#a37">FsRtlAllocatePoolWithTag</a>( UdfNonPagedPool,
02678                                                     <a class="code" href="../../d3/d8/udfprocs_8h.html#a163">UdfRawBufferSize</a>( Vcb, <span class="keyword">sizeof</span>(<a class="code" href="../../d2/d2/structNSR__FSD.html">NSR_FSD</a>) ),
02679                                                     TAG_NSR_FSD );
02680                 }
02681 
02682                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d3/d8/udfprocs_8h.html#a160">UdfReadSectors</a>( IrpContext,
02683                                          Offset,
02684                                          <a class="code" href="../../d3/d8/udfprocs_8h.html#a164">UdfRawReadSize</a>( Vcb, <span class="keyword">sizeof</span>(<a class="code" href="../../d2/d2/structNSR__FSD.html">NSR_FSD</a>) ),
02685                                          TRUE,
02686                                          FSD,
02687                                          Vcb-&gt;TargetDeviceObject );
02688 
02689                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status ) ||
02690                     FSD-&gt;<a class="code" href="../../d2/d2/structNSR__FSD.html#o0">Destag</a>.<a class="code" href="../../d7/d7/structDESTAG.html#o0">Ident</a> == <a class="code" href="../../d0/d7/iso13346_8h.html#a37">DESTAG_ID_NOTSPEC</a>) {
02691 
02692                     <span class="comment">//</span>
02693                     <span class="comment">//  These are both an excellent sign that this is an unrecorded sector, which</span>
02694                     <span class="comment">//  is defined to terminate the sequence. (3/8.4.2)</span>
02695                     <span class="comment">//</span>
02696 
02697                     <span class="keywordflow">break</span>;
02698                 }
02699 
02700                 <span class="keywordflow">if</span> ((FSD-&gt;<a class="code" href="../../d2/d2/structNSR__FSD.html#o0">Destag</a>.<a class="code" href="../../d7/d7/structDESTAG.html#o0">Ident</a> != <a class="code" href="../../d0/d7/iso13346_8h.html#a49">DESTAG_ID_NSR_FSD</a> &amp;&amp;
02701                      FSD-&gt;<a class="code" href="../../d2/d2/structNSR__FSD.html#o0">Destag</a>.<a class="code" href="../../d7/d7/structDESTAG.html#o0">Ident</a> != <a class="code" href="../../d0/d7/iso13346_8h.html#a45">DESTAG_ID_NSR_TERM</a>) ||
02702 
02703                     !<a class="code" href="../../d3/d8/udfprocs_8h.html#a219">UdfVerifyDescriptor</a>( IrpContext,
02704                                           &amp;FSD-&gt;<a class="code" href="../../d2/d2/structNSR__FSD.html#o0">Destag</a>,
02705                                           FSD-&gt;<a class="code" href="../../d2/d2/structNSR__FSD.html#o0">Destag</a>.<a class="code" href="../../d7/d7/structDESTAG.html#o0">Ident</a>,
02706                                           <span class="keyword">sizeof</span>(<a class="code" href="../../d2/d2/structNSR__FSD.html">NSR_FSD</a>),
02707                                           Lbn,
02708                                           TRUE)) {
02709 
02710                     <span class="comment">//</span>
02711                     <span class="comment">//  If we spot an illegal descriptor type in the stream, there is no reasonable</span>
02712                     <span class="comment">//  way to guess that we can continue (the disc may be trash beyond this point).</span>
02713                     <span class="comment">//  Clearly, we also cannot trust the next extent pointed to by a corrupt</span>
02714                     <span class="comment">//  descriptor.</span>
02715                     <span class="comment">//</span>
02716 
02717                     <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( Status = STATUS_DISK_CORRUPT_ERROR );
02718                 }
02719 
02720                 <span class="keywordflow">if</span> (FSD-&gt;<a class="code" href="../../d2/d2/structNSR__FSD.html#o0">Destag</a>.<a class="code" href="../../d7/d7/structDESTAG.html#o0">Ident</a> == <a class="code" href="../../d0/d7/iso13346_8h.html#a45">DESTAG_ID_NSR_TERM</a>) {
02721 
02722                     <span class="comment">//</span>
02723                     <span class="comment">//  This is a way to terminate the sequence.</span>
02724                     <span class="comment">//</span>
02725 
02726                     <span class="keywordflow">break</span>;
02727                 }
02728 
02729                 <span class="comment">//</span>
02730                 <span class="comment">//  Reset the pointers to the possible next extent</span>
02731                 <span class="comment">//</span>
02732 
02733                 LongAd = &amp;FSD-&gt;<a class="code" href="../../d2/d2/structNSR__FSD.html#o16">NextExtent</a>;
02734 
02735                 <span class="keywordflow">if</span> (LongAd-&gt;Length.Length) {
02736 
02737                     <span class="comment">//</span>
02738                     <span class="comment">//  A fileset descriptor containing a nonzero next extent pointer also</span>
02739                     <span class="comment">//  terminates this extent of the FSD sequence. (4/8.3.1)</span>
02740                     <span class="comment">//</span>
02741                     <span class="comment">//  If the extent referred to is not fully recorded, this will</span>
02742                     <span class="comment">//  terminate the sequence.</span>
02743                     <span class="comment">//</span>
02744 
02745                     <span class="keywordflow">if</span> (LongAd-&gt;Length.Type != <a class="code" href="../../d0/d7/iso13346_8h.html#a21">NSRLENGTH_TYPE_RECORDED</a>) {
02746 
02747                         <span class="keywordflow">break</span>;
02748                     }
02749 
02750                     Len = LongAd-&gt;<a class="code" href="../../d4/d9/structLONGAD.html#o0">Length</a>.<a class="code" href="../../d7/d3/structNSRLENGTH.html#o0">Length</a>;
02751 
02752                     <span class="comment">//</span>
02753                     <span class="comment">//  The extent must be a multiple of a block size.</span>
02754                     <span class="comment">//</span>
02755 
02756                     <span class="keywordflow">if</span> (<a class="code" href="../../d3/d8/udfprocs_8h.html#a55">BlockOffset</a>( Vcb, Len )) {
02757 
02758                         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( +0, Dbg,
02759                                      <span class="stringliteral">"UdfFindFileSetDescriptor, interior extent not blocksize in length\n"</span> ));
02760                         <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a> ( Status = STATUS_DISK_CORRUPT_ERROR );
02761                     }
02762 
02763                     Lbn = LongAd-&gt;Start.Lbn;
02764 
02765                     <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> = <a class="code" href="../../d3/d8/udfprocs_8h.html#a51">LlBytesFromBlocks</a>( Vcb, <a class="code" href="../../d3/d8/udfprocs_8h.html#a152">UdfLookupPsnOfExtent</a>( IrpContext,
02766                                                                            Vcb,
02767                                                                            LongAd-&gt;Start.Partition,
02768                                                                            Lbn,
02769                                                                            Len ));
02770 
02771                 }
02772 
02773                 <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a3">UdfStoreFileSetDescriptorIfPrevailing</a>( FileSetDescriptor, &amp;FSD );
02774             }
02775         
02776         } finally {
02777             
02778             <span class="comment">//</span>
02779             <span class="comment">//  Free up the buffer space we may have allocated</span>
02780             <span class="comment">//</span>
02781 
02782             <a class="code" href="../../d3/d8/udfprocs_8h.html#a124">UdfFreePool</a>( &amp;FSD );
02783 
02784         }
02785     
02786     } except( <a class="code" href="../../d3/d8/udfprocs_8h.html#a127">UdfExceptionFilter</a>( IrpContext, GetExceptionInformation() )) {
02787 
02788         <span class="comment">//</span>
02789         <span class="comment">//  Transmute raised apparent file corruption to disk corruption - we are not</span>
02790         <span class="comment">//  yet touching the visible filesystem.</span>
02791         <span class="comment">//</span>
02792 
02793         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = IrpContext-&gt;ExceptionStatus;
02794         
02795         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( +0, Dbg,
02796                      <span class="stringliteral">"UdfFindFileSetDescriptor, exception %08x thrown\n"</span>, Status ));
02797 
02798         <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_FILE_CORRUPT_ERROR) {
02799 
02800             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( +0, Dbg,
02801                          <span class="stringliteral">"UdfFindFileSetDescriptor, translating file corrupt to disk corrupt\n"</span> ));
02802             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_DISK_CORRUPT_ERROR;
02803         }
02804     }
02805 
02806     <span class="comment">//</span>
02807     <span class="comment">//  Success is when we've really found something.  If we failed to find the</span>
02808     <span class="comment">//  descriptor, commute whatever intermediate status was involved and clean up.</span>
02809     <span class="comment">//</span>
02810 
02811     <span class="keywordflow">if</span> (*FileSetDescriptor == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02812         
02813         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_UNRECOGNIZED_VOLUME;
02814     }
02815 
02816     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
02817 
02818         <a class="code" href="../../d3/d8/udfprocs_8h.html#a124">UdfFreePool</a>( FileSetDescriptor );
02819     }
02820     
02821     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, Dbg,
02822                  <span class="stringliteral">"UdfFindFileSetDescriptor -&gt; %08x\n"</span>, Status ));
02823     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
02824 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a8" doxytag="udfs/fsctrl.c::UdfFindVolumeDescriptors" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS UdfFindVolumeDescriptors           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>IrpContext</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d7/d5/struct__VCB.html">PVCB</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>Vcb</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d3/d9/structEXTENTAD.html">PEXTENTAD</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>Extent</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN OUT <a class="el" href="../../d4/d9/struct__PCB.html">PPCB</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>Pcb</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN OUT <a class="el" href="../../d0/d3/structNSR__PVD.html">PNSR_PVD</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>PrimaryVolumeDescriptor</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN OUT <a class="el" href="../../d6/d2/structNSR__LVOL.html">PNSR_LVOL</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>LogicalVolumeDescriptor</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l02832">2832</a> of file <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html">udfs/fsctrl.c</a>.
<p>
References <a class="el" href="../../d2/d7/udfdata_8h-source.html#l00352">ASSERT_IRP_CONTEXT</a>, <a class="el" href="../../d2/d7/udfdata_8h-source.html#l00349">ASSERT_OPTIONAL_PCB</a>, <a class="el" href="../../d2/d7/udfdata_8h-source.html#l00336">ASSERT_VCB</a>, <a class="el" href="../../d1/d6/iso13346_8h-source.html#l00543">NSR_LVOL::BlockSize</a>, <a class="el" href="../../d1/d6/iso13346_8h-source.html#l00541">NSR_LVOL::Charset</a>, <a class="el" href="../../d1/d6/iso13346_8h-source.html#l00415">NSR_PVD::CharsetDesc</a>, <a class="el" href="../../d1/d6/iso13346_8h-source.html#l00416">NSR_PVD::CharsetExplan</a>, <a class="el" href="../../d1/d6/iso13346_8h-source.html#l00412">NSR_PVD::CharSetList</a>, <a class="el" href="../../d1/d6/iso13346_8h-source.html#l00413">NSR_PVD::CharSetListMax</a>, <a class="el" href="../../d1/d6/iso13346_8h-source.html#l00043">CHARSPEC_T_CS0</a>, <a class="el" href="../../d1/d6/iso13346_8h-source.html#l00486">NSR_PART::ContentsID</a>, <a class="el" href="../../d0/d5/cdfs__rec_8c-source.html#l00032">Dbg</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02290">DebugTrace</a>, <a class="el" href="../../d9/d2/lfsdata_8h-source.html#l00187">DebugUnwind</a>, <a class="el" href="../../d1/d6/iso13346_8h-source.html#l00482">NSR_PART::Destag</a>, <a class="el" href="../../d1/d6/iso13346_8h-source.html#l00391">NSR_VD_GENERIC::Destag</a>, <a class="el" href="../../d1/d6/iso13346_8h-source.html#l00329">DESTAG_ID_MAXIMUM_PART3</a>, <a class="el" href="../../d1/d6/iso13346_8h-source.html#l00323">DESTAG_ID_NSR_LVOL</a>, <a class="el" href="../../d1/d6/iso13346_8h-source.html#l00322">DESTAG_ID_NSR_PART</a>, <a class="el" href="../../d1/d6/iso13346_8h-source.html#l00318">DESTAG_ID_NSR_PVD</a>, <a class="el" href="../../d1/d6/iso13346_8h-source.html#l00325">DESTAG_ID_NSR_TERM</a>, <a class="el" href="../../d1/d6/iso13346_8h-source.html#l00320">DESTAG_ID_NSR_VDP</a>, <a class="el" href="../../d1/d6/iso13346_8h-source.html#l00544">NSR_LVOL::DomainID</a>, <a class="el" href="../../d2/d7/fsrtl_8h-source.html#l01101">FsRtlAllocatePoolWithTag</a>, <a class="el" href="../../d1/d6/iso13346_8h-source.html#l00304">DESTAG::Ident</a>, <a class="el" href="../../d1/d6/iso13346_8h-source.html#l00558">ISONsrLvolSize</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l00220">LlBytesFromSectors</a>, <a class="el" href="../../d1/d6/iso13346_8h-source.html#l00547">NSR_LVOL::MapTableCount</a>, <a class="el" href="../../d0/d7/iso13346_8h.html#a201">NSR_VD_GENERIC</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l00033">Offset</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>, <a class="el" href="../../d0/d7/iso13346_8h.html#a208">PNSR_VDP</a>, <a class="el" href="../../d4/d7/fsrtlp_8h-source.html#l00222">SectorsFromBytes</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l00230">SectorSize</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, <a class="el" href="../../d2/d6/udfs_2nodetype_8h-source.html#l00179">TAG_NSR_VDSD</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l00436">try_leave</a>, <a class="el" href="../../d0/d7/udf_8h-source.html#l00345">UDF_CHARSETLIST</a>, <a class="el" href="../../d0/d7/udf_8h-source.html#l00145">UDF_VERSION_MINIMUM</a>, <a class="el" href="../../d0/d7/udf_8h-source.html#l00143">UDF_VERSION_RECOGNIZED</a>, <a class="el" href="../../d3/d5/allocsup_8c-source.html#l00724">UdfAddToPcb()</a>, <a class="el" href="../../d1/d7/udfdata_8c-source.html#l00094">UdfCS0Identifier</a>, <a class="el" href="../../d1/d7/udfdata_8c-source.html#l00104">UdfDomainIdentifier</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l02027">UdfDomainIdentifierContained()</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l02228">UdfEqualCharspec()</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l01988">UdfEqualEntityId()</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l00453">UdfFreePool()</a>, <a class="el" href="../../d3/d5/allocsup_8c-source.html#l00367">UdfInitializePcb()</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l00444">UdfNonPagedPool</a>, <a class="el" href="../../d1/d7/udfdata_8c-source.html#l00153">UdfNSR02Identifier</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l00931">UdfRawBufferSize()</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l00941">UdfRawReadSize()</a>, <a class="el" href="../../d4/d6/deviosup_8c-source.html#l00685">UdfReadSectors()</a>, <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l00235">UdfStoreVolumeDescriptorIfPrevailing()</a>, <a class="el" href="../../d0/d7/udfs_2strucsup_8c-source.html#l02617">UdfVerifyDescriptor()</a>, <a class="el" href="../../d1/d6/iso13346_8h-source.html#l00408">NSR_PVD::VolSetSeq</a>, and <a class="el" href="../../d1/d6/iso13346_8h-source.html#l00409">NSR_PVD::VolSetSeqMax</a>.
<p>
Referenced by <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l01444">UdfMountVolume()</a>, and <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l02043">UdfVerifyVolume()</a>.
<p>
<pre class="fragment"><div>02843                    :
02844 
02845     This routine walks <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> indicated Volume Descriptor Sequence searching <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
02846     active descriptors <span class="keywordflow">for</span> <span class="keyword">this</span> volume and generates an initializing Pcb from <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
02847     referenced partitions.  No updating of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Vcb occurs.
02848 
02849 Arguments:
02850 
02851     Vcb - Vcb of volume to search
02852 
02853     Extent - Extent to search
02854 
02855     Pcb - Address of a caller's pointer to a Pcb
02856 
02857     PrimaryVolumeDescriptor - Address of caller's pointer to a PVD
02858 
02859     LogicalVolumeDescriptor - Address of caller's pointer to an LVD
02860 
02861 Return Value:
02862 
02863     STATUS_SUCCESS <span class="keywordflow">if</span> all descriptors are found, read, and are valid.
02864 
02865     STATUS_DISK_CORRUPT_ERROR <span class="keywordflow">if</span> corrupt descriptors are found.
02866 
02867     STATUS_UNRECOGNIZED_VOLUME <span class="keywordflow">if</span> noncompliant descriptors are found.
02868     
02869     Descriptors are <a class="code" href="../../d3/d0/imm32_8def.html#a1">only</a> returned on success.
02870 
02871 --*/
02872 
02873 {
02874     <a class="code" href="../../d4/d3/structNSR__VD__GENERIC.html">PNSR_VD_GENERIC</a> GenericVD = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02875     ULONGLONG <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>;
02876     ULONG Len;
02877     ULONG UnitSize = <a class="code" href="../../d3/d8/udfprocs_8h.html#a164">UdfRawReadSize</a>( Vcb, <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d3/structNSR__VD__GENERIC.html">NSR_VD_GENERIC</a>) );
02878 
02879     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
02880     ULONG ThisPass = 1;
02881 
02882     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
02883 
02884     <span class="comment">//</span>
02885     <span class="comment">//  Check the input parameters</span>
02886     <span class="comment">//</span>
02887 
02888     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext);
02889     <a class="code" href="../../d1/d8/udfdata_8h.html#a12">ASSERT_VCB</a>( Vcb );
02890     <a class="code" href="../../d1/d8/udfdata_8h.html#a25">ASSERT_OPTIONAL_PCB</a>( *Pcb );
02891 
02892     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( +1, Dbg,
02893                  <span class="stringliteral">"UdfFindVolumeDescriptors, Vcb %08x, Extent %08x +%08x\n"</span>,
02894                  Vcb,
02895                  Extent-&gt;Lsn,
02896                  Extent-&gt;Len ));
02897 
02898     <span class="comment">//</span>
02899     <span class="comment">//  If the extent we begin from is not at least the size of an aligned descriptor</span>
02900     <span class="comment">//  or is sized in base units other than aligned descriptors, we can't continue.</span>
02901     <span class="comment">//</span>
02902 
02903     <span class="keywordflow">if</span> (Extent-&gt;Len &lt; UnitSize ||
02904         Extent-&gt;Len % UnitSize) {
02905 
02906         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg,
02907                      <span class="stringliteral">"UdfFindVolumeDescriptors, Base extent length %08x is mismatched with read size %08x\n"</span>,
02908                      Extent-&gt;Len,
02909                      UnitSize ));
02910 
02911         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, Dbg,
02912                      <span class="stringliteral">"UdfFindVolumeDescriptors -&gt; STATUS_DISK_CORRUPT_ERROR\n"</span> ));
02913 
02914         <span class="keywordflow">return</span> STATUS_DISK_CORRUPT_ERROR;
02915     }
02916 
02917     <span class="comment">//</span>
02918     <span class="comment">//  Use a try-finally to facilitate cleanup.</span>
02919     <span class="comment">//</span>
02920 
02921     <span class="keywordflow">try</span> {
02922 
02923         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg,
02924                      <span class="stringliteral">"UdfFindVolumeDescriptors, starting pass 1, find LVD/PVD\n"</span> ));
02925 
02926         <span class="comment">//</span>
02927         <span class="comment">//  We will make at least one pass through the Volume Descriptor Sequence to find</span>
02928         <span class="comment">//  the prevailing versions of the two controlling descriptors - the PVD and LVD.</span>
02929         <span class="comment">//  In order to avoid picking up partition descriptors that aren't actually going</span>
02930         <span class="comment">//  to be referenced by the LVD, we will pick them up in a second pass if we find</span>
02931         <span class="comment">//  a PVD and LVD that look reasonable and then stick them in a Pcb.</span>
02932         <span class="comment">//</span>
02933 
02934         <span class="keywordflow">for</span> (ThisPass = 1; ThisPass &lt;= 2; ThisPass++) {
02935 
02936             <span class="keywordflow">for</span> ( <span class="comment">//</span>
02937                   <span class="comment">//  Home ourselves in the search and make a pass through the sequence.</span>
02938                   <span class="comment">//</span>
02939 
02940                   <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> = <a class="code" href="../../d3/d8/udfprocs_8h.html#a39">LlBytesFromSectors</a>( Vcb, Extent-&gt;Lsn ),
02941                   Len = Extent-&gt;Len;
02942 
02943                   <span class="comment">//</span>
02944                   <span class="comment">//  If we have reached the end of the extent's indicated valid</span>
02945                   <span class="comment">//  length, we are done. This usually will not happen.</span>
02946                   <span class="comment">//</span>
02947 
02948                   Len;
02949 
02950                   <span class="comment">//</span>
02951                   <span class="comment">//  Advance to the next descriptor offset in the sequence.</span>
02952                   <span class="comment">//</span>
02953 
02954                   <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> += UnitSize,
02955                   Len -= UnitSize ) {
02956 
02957                 <span class="comment">//</span>
02958                 <span class="comment">//  Allocate a buffer to read generic volume descriptors.</span>
02959                 <span class="comment">//</span>
02960 
02961                 <span class="keywordflow">if</span> (GenericVD == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02962 
02963                     GenericVD = (<a class="code" href="../../d4/d3/structNSR__VD__GENERIC.html">PNSR_VD_GENERIC</a>) <a class="code" href="../../d1/d8/fsrtl_8h.html#a37">FsRtlAllocatePoolWithTag</a>( UdfNonPagedPool,
02964                                                                             <a class="code" href="../../d3/d8/udfprocs_8h.html#a163">UdfRawBufferSize</a>( Vcb, <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d3/structNSR__VD__GENERIC.html">NSR_VD_GENERIC</a>) ),
02965                                                                             TAG_NSR_VDSD );
02966                 }
02967 
02968                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d3/d8/udfprocs_8h.html#a160">UdfReadSectors</a>( IrpContext,
02969                                          Offset,
02970                                          UnitSize,
02971                                          TRUE,
02972                                          GenericVD,
02973                                          Vcb-&gt;TargetDeviceObject );
02974 
02975                 <span class="comment">//</span>
02976                 <span class="comment">//  Thise is a decent sign that this is an unrecorded sector and is</span>
02977                 <span class="comment">//  defined to terminate the sequence.</span>
02978                 <span class="comment">//</span>
02979 
02980                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
02981 
02982                     <span class="keywordflow">break</span>;
02983                 }
02984 
02985                 <span class="keywordflow">if</span> (GenericVD-&gt;<a class="code" href="../../d4/d3/structNSR__VD__GENERIC.html#o0">Destag</a>.<a class="code" href="../../d7/d7/structDESTAG.html#o0">Ident</a> &gt; <a class="code" href="../../d0/d7/iso13346_8h.html#a48">DESTAG_ID_MAXIMUM_PART3</a> ||
02986 
02987                     !<a class="code" href="../../d3/d8/udfprocs_8h.html#a219">UdfVerifyDescriptor</a>( IrpContext,
02988                                           &amp;GenericVD-&gt;<a class="code" href="../../d4/d3/structNSR__VD__GENERIC.html#o0">Destag</a>,
02989                                           GenericVD-&gt;<a class="code" href="../../d4/d3/structNSR__VD__GENERIC.html#o0">Destag</a>.<a class="code" href="../../d7/d7/structDESTAG.html#o0">Ident</a>,
02990                                           <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d3/structNSR__VD__GENERIC.html">NSR_VD_GENERIC</a>),
02991                                           (ULONG) <a class="code" href="../../d3/d8/fsrtlp_8h.html#a13">SectorsFromBytes</a>( Vcb, Offset ),
02992                                           TRUE)) {
02993 
02994                     <span class="comment">//</span>
02995                     <span class="comment">//  If we spot an illegal descriptor type in the stream, there is no reasonable</span>
02996                     <span class="comment">//  way to guess that we can continue (the disc may be trash beyond this point).</span>
02997                     <span class="comment">//  Likewise, even if we have a single corrupt descriptor we cannot continue because</span>
02998                     <span class="comment">//  this may be corruption of a descriptor we may have otherwise required for operation</span>
02999                     <span class="comment">//  (i.e., one of the prevailing descriptors).</span>
03000                     <span class="comment">//</span>
03001 
03002                     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg,
03003                                  <span class="stringliteral">"UdfFindVolumeDescriptors, descriptor didn't verify\n"</span> ));
03004 
03005                     <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( Status = STATUS_DISK_CORRUPT_ERROR );
03006                 }
03007 
03008                 <span class="keywordflow">if</span> (GenericVD-&gt;<a class="code" href="../../d4/d3/structNSR__VD__GENERIC.html#o0">Destag</a>.<a class="code" href="../../d7/d7/structDESTAG.html#o0">Ident</a> == <a class="code" href="../../d0/d7/iso13346_8h.html#a45">DESTAG_ID_NSR_TERM</a>) {
03009 
03010                     <span class="comment">//</span>
03011                     <span class="comment">//  The Terminating Descriptor (3/10.9) is the usual way to stop a search.</span>
03012                     <span class="comment">//</span>
03013 
03014                     <span class="keywordflow">break</span>;
03015                 }
03016 
03017                 <span class="keywordflow">if</span> (GenericVD-&gt;<a class="code" href="../../d4/d3/structNSR__VD__GENERIC.html#o0">Destag</a>.<a class="code" href="../../d7/d7/structDESTAG.html#o0">Ident</a> == <a class="code" href="../../d0/d7/iso13346_8h.html#a40">DESTAG_ID_NSR_VDP</a>) {
03018 
03019                     <span class="comment">//</span>
03020                     <span class="comment">//  Follow a Volume Desciptor Pointer (3/10.3) to the next extent of the sequence.</span>
03021                     <span class="comment">//</span>
03022 
03023                     <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> = <a class="code" href="../../d3/d8/udfprocs_8h.html#a39">LlBytesFromSectors</a>( Vcb, ((<a class="code" href="../../d5/d3/structNSR__VDP.html">PNSR_VDP</a>) GenericVD)-&gt;Next.Lsn );
03024                     Len = ((<a class="code" href="../../d5/d3/structNSR__VDP.html">PNSR_VDP</a>) GenericVD)-&gt;Next.Len;
03025 
03026                     <span class="comment">//</span>
03027                     <span class="comment">//  We cannot do anything if the extent is invalid</span>
03028                     <span class="comment">//</span>
03029 
03030                     <span class="keywordflow">if</span> (Len &lt; UnitSize ||
03031                         Len % UnitSize) {
03032 
03033                         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg,
03034                                      <span class="stringliteral">"UdfFindVolumeDescriptors, following extent length %08x is mismatched with read size %08x\n"</span>,
03035                                      Extent-&gt;Len,
03036                                      UnitSize ));
03037 
03038                         <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( Status = STATUS_DISK_CORRUPT_ERROR );
03039                     }
03040                 }
03041 
03042                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg,
03043                              <span class="stringliteral">"UdfFindVolumeDescriptors, descriptor tag %08x\n"</span>,
03044                              GenericVD-&gt;<a class="code" href="../../d4/d3/structNSR__VD__GENERIC.html#o0">Destag</a>.<a class="code" href="../../d7/d7/structDESTAG.html#o0">Ident</a> ));
03045 
03046                 <span class="keywordflow">if</span> (ThisPass == 1) {
03047 
03048                     <span class="comment">//</span>
03049                     <span class="comment">//  Our first pass is to find prevailing LVD and PVD.</span>
03050                     <span class="comment">//</span>
03051 
03052                     <span class="keywordflow">switch</span> (GenericVD-&gt;<a class="code" href="../../d4/d3/structNSR__VD__GENERIC.html#o0">Destag</a>.<a class="code" href="../../d7/d7/structDESTAG.html#o0">Ident</a>) {
03053 
03054                         <span class="keywordflow">case</span> <a class="code" href="../../d0/d7/iso13346_8h.html#a38">DESTAG_ID_NSR_PVD</a>:
03055 
03056                             <a class="code" href="../../d3/d8/udfprocs_8h.html#a176">UdfStoreVolumeDescriptorIfPrevailing</a>( (<a class="code" href="../../d4/d3/structNSR__VD__GENERIC.html">PNSR_VD_GENERIC</a> *) PrimaryVolumeDescriptor,
03057                                                                   GenericVD );
03058                             <span class="keywordflow">break</span>;
03059 
03060                         <span class="keywordflow">case</span> <a class="code" href="../../d0/d7/iso13346_8h.html#a43">DESTAG_ID_NSR_LVOL</a>:
03061 
03062                             <a class="code" href="../../d3/d8/udfprocs_8h.html#a176">UdfStoreVolumeDescriptorIfPrevailing</a>( (<a class="code" href="../../d4/d3/structNSR__VD__GENERIC.html">PNSR_VD_GENERIC</a> *) LogicalVolumeDescriptor,
03063                                                                   GenericVD );
03064                             <span class="keywordflow">break</span>;
03065 
03066                         <span class="keywordflow">default</span>:
03067 
03068                             <span class="keywordflow">break</span>;
03069                     }
03070 
03071                 } <span class="keywordflow">else</span> {
03072 
03073                     <a class="code" href="../../d7/d2/structNSR__PART.html">PNSR_PART</a> PartitionDescriptor = (<a class="code" href="../../d7/d2/structNSR__PART.html">PNSR_PART</a>) GenericVD;
03074 
03075                     <span class="comment">//</span>
03076                     <span class="comment">//  Our second pass is to pick up all relavent NSR02 PD</span>
03077                     <span class="comment">//</span>
03078 
03079                     <span class="keywordflow">if</span> (PartitionDescriptor-&gt;<a class="code" href="../../d7/d2/structNSR__PART.html#o0">Destag</a>.<a class="code" href="../../d7/d7/structDESTAG.html#o0">Ident</a> != <a class="code" href="../../d0/d7/iso13346_8h.html#a42">DESTAG_ID_NSR_PART</a> ||
03080                         !<a class="code" href="../../d3/d8/udfprocs_8h.html#a229">UdfEqualEntityId</a>( &amp;PartitionDescriptor-&gt;<a class="code" href="../../d7/d2/structNSR__PART.html#o4">ContentsID</a>, &amp;UdfNSR02Identifier, NULL )) {
03081 
03082                         <span class="keywordflow">continue</span>;
03083                     }
03084 
03085                     <a class="code" href="../../d3/d8/udfprocs_8h.html#a149">UdfAddToPcb</a>( *Pcb, (<a class="code" href="../../d7/d2/structNSR__PART.html">PNSR_PART</a>) GenericVD );
03086                 }
03087             }
03088 
03089             <span class="comment">//</span>
03090             <span class="comment">//  Now that a pass through the VDS has been completed, analyze the results.</span>
03091             <span class="comment">//</span>
03092 
03093             <span class="keywordflow">if</span> (ThisPass == 1) {
03094 
03095                 <a class="code" href="../../d0/d3/structNSR__PVD.html">PNSR_PVD</a> PVD;
03096                 <a class="code" href="../../d6/d2/structNSR__LVOL.html">PNSR_LVOL</a> LVD;
03097 
03098                 <span class="comment">//</span>
03099                 <span class="comment">//  Reference the descriptors for ease of use</span>
03100                 <span class="comment">//</span>
03101 
03102                 PVD = *PrimaryVolumeDescriptor;
03103                 LVD = *LogicalVolumeDescriptor;
03104 
03105                 <span class="comment">//</span>
03106                 <span class="comment">//  Check that the descriptors indicate a logical volume which appears to</span>
03107                 <span class="comment">//  be a valid UDF volume.</span>
03108                 <span class="comment">//</span>
03109 
03110                 <span class="keywordflow">if</span> ((PVD == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> &amp;&amp;
03111                      <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg,
03112                                   <span class="stringliteral">"UdfFindVolumeDescriptors, don't have a PVD\n"</span> ))) ||
03113                     (LVD == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> &amp;&amp;
03114                      <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg,
03115                                   <span class="stringliteral">"UdfFindVolumeDescriptors, don't have an LVD\n"</span> ))) ||
03116 
03117                     <span class="comment">//</span>
03118                     <span class="comment">//  Now check the PVD</span>
03119                     <span class="comment">//</span>
03120 
03121                     <span class="comment">//</span>
03122                     <span class="comment">//  The Volume Set Sequence fields indicates how many volumes form</span>
03123                     <span class="comment">//  the volume set and what number this volume is in that sequence.</span>
03124                     <span class="comment">//  We are a level 2 implementation, meaning that the volumes we read</span>
03125                     <span class="comment">//  consist of a single volume. (3/11)</span>
03126                     <span class="comment">//</span>
03127 
03128                     (PVD-&gt;<a class="code" href="../../d0/d3/structNSR__PVD.html#o4">VolSetSeq</a> &gt; 1 &amp;&amp;
03129                      <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg,
03130                                   <span class="stringliteral">"UdfFindVolumeDescriptors, PVD VolSetSeq %08x - not volume 1 of a volume set\n"</span>,
03131                                   PVD-&gt;<a class="code" href="../../d0/d3/structNSR__PVD.html#o4">VolSetSeq</a> ))) ||
03132                     (PVD-&gt;<a class="code" href="../../d0/d3/structNSR__PVD.html#o5">VolSetSeqMax</a> &gt; 1 &amp;&amp;
03133                      <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg,
03134                                   <span class="stringliteral">"UdfFindVolumeDescriptors, PVD VolSetSeqMax %08x - volume in a non-unit volume set\n"</span>,
03135                                   PVD-&gt;<a class="code" href="../../d0/d3/structNSR__PVD.html#o5">VolSetSeqMax</a> ))) ||
03136 
03137                     
03138 <span class="preprocessor">#ifndef UDF_SUPPORT_NONSTANDARD_ALLSTOR</span>
03139 <span class="preprocessor"></span>
03140                     <span class="comment">//</span>
03141                     <span class="comment">//  Disable checking of character set lists.</span>
03142                     <span class="comment">//</span>
03143                     <span class="comment">//  Reason: first drop of Allstor media recorded these fields as 0x0.</span>
03144                     <span class="comment">//</span>
03145 
03146                     <span class="comment">//</span>
03147                     <span class="comment">//  Insure that Character Set Lists conform to UDF</span>
03148                     <span class="comment">//</span>
03149 
03150                     (PVD-&gt;<a class="code" href="../../d0/d3/structNSR__PVD.html#o8">CharSetList</a> != <a class="code" href="../../d9/d7/udf_8h.html#a55">UDF_CHARSETLIST</a> &amp;&amp;
03151                      <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg,
03152                                   <span class="stringliteral">"UdfFindVolumeDescriptors, PVD CharSetList %08x != CS0 only\n"</span>,
03153                                   PVD-&gt;<a class="code" href="../../d0/d3/structNSR__PVD.html#o8">CharSetList</a> ))) ||
03154                     (PVD-&gt;<a class="code" href="../../d0/d3/structNSR__PVD.html#o9">CharSetListMax</a> != <a class="code" href="../../d9/d7/udf_8h.html#a55">UDF_CHARSETLIST</a> &amp;&amp;
03155                      <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg,
03156                                   <span class="stringliteral">"UdfFindVolumeDescriptors, PVD CharSetListMax %08x != CS0 only\n"</span>,
03157                                   PVD-&gt;<a class="code" href="../../d0/d3/structNSR__PVD.html#o9">CharSetListMax</a> ))) ||
03158 
03159                     <span class="comment">//</span>
03160                     <span class="comment">//  Disable checking of character set lists.</span>
03161                     <span class="comment">//</span>
03162                     <span class="comment">//  Reason: first drop of Allstor media misspelled "Compressed" as "Copmressed"</span>
03163                     <span class="comment">//</span>
03164 
03165                     <span class="comment">//</span>
03166                     <span class="comment">//  The two character sets must be UDF CS0.  CS0 is a "by convention"</span>
03167                     <span class="comment">//  character set in ISO 13346, which UDF specifies for our domain.</span>
03168                     <span class="comment">//</span>
03169 
03170                     (!<a class="code" href="../../d3/d8/udfprocs_8h.html#a248">UdfEqualCharspec</a>( &amp;PVD-&gt;<a class="code" href="../../d0/d3/structNSR__PVD.html#o11">CharsetDesc</a>, &amp;UdfCS0Identifier, CHARSPEC_T_CS0 ) &amp;&amp;
03171                      <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg,
03172                                  <span class="stringliteral">"UdfFindVolumeDescriptors, PVD CharsetDesc != CS0 only\n"</span> ))) ||
03173                     (!<a class="code" href="../../d3/d8/udfprocs_8h.html#a248">UdfEqualCharspec</a>( &amp;PVD-&gt;<a class="code" href="../../d0/d3/structNSR__PVD.html#o12">CharsetExplan</a>, &amp;UdfCS0Identifier, CHARSPEC_T_CS0 ) &amp;&amp;
03174                      <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg,
03175                                   <span class="stringliteral">"UdfFindVolumeDescriptors, PVD CharsetExplan != CS0 only\n"</span> ))) ||
03176 
03177 <span class="preprocessor">#endif</span>
03178 <span class="preprocessor"></span>                    <span class="comment">//</span>
03179                     <span class="comment">//  Now check the LVD</span>
03180                     <span class="comment">//</span>
03181 
03182                     <span class="comment">//</span>
03183                     <span class="comment">//  The LVD is a variant sized structure.  Check that the claimed size fits in a single</span>
03184                     <span class="comment">//  logical sector.  Although an LVD may legally exceed a single sector, we will never</span>
03185                     <span class="comment">//  want to deal with such a volume.</span>
03186                     <span class="comment">//</span>
03187 
03188                     (<a class="code" href="../../d0/d7/iso13346_8h.html#a80">ISONsrLvolSize</a>( LVD ) &gt; <a class="code" href="../../d3/d8/udfprocs_8h.html#a42">SectorSize</a>( Vcb ) &amp;&amp;
03189                      <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg,
03190                                   <span class="stringliteral">"UdfFindVolumeDescriptors, LVD is bigger than a sector\n"</span> ))) ||
03191 
03192 <span class="preprocessor">#ifndef UDF_SUPPORT_NONSTANDARD_ALLSTOR</span>
03193 <span class="preprocessor"></span>                    
03194                     <span class="comment">//</span>
03195                     <span class="comment">//  Disable checking of character set lists.</span>
03196                     <span class="comment">//</span>
03197                     <span class="comment">//  Reason: first drop of Allstor media recorded these fields as 0x0.</span>
03198                     <span class="comment">//</span>
03199 
03200                     <span class="comment">//</span>
03201                     <span class="comment">//  The character set used in the LVD must be UDF CS0 as well.</span>
03202                     <span class="comment">//</span>
03203 
03204                     (!<a class="code" href="../../d3/d8/udfprocs_8h.html#a248">UdfEqualCharspec</a>( &amp;LVD-&gt;<a class="code" href="../../d6/d2/structNSR__LVOL.html#o2">Charset</a>, &amp;UdfCS0Identifier, CHARSPEC_T_CS0 ) &amp;&amp;
03205                      <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg,
03206                                  <span class="stringliteral">"UdfFindVolumeDescriptors, LVD Charset != CS0 only\n"</span> ))) ||
03207 <span class="preprocessor">#endif</span>
03208 <span class="preprocessor"></span>
03209                     <span class="comment">//</span>
03210                     <span class="comment">//  The specified block size must equal the physical sector size.</span>
03211                     <span class="comment">//</span>
03212 
03213                     (LVD-&gt;<a class="code" href="../../d6/d2/structNSR__LVOL.html#o4">BlockSize</a> != <a class="code" href="../../d3/d8/udfprocs_8h.html#a42">SectorSize</a>( Vcb ) &amp;&amp;
03214                      <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg,
03215                                   <span class="stringliteral">"UdfFindVolumeDescriptors, LVD BlockSize %08x != SectorSize %08x\n"</span> ))) ||
03216 
03217                     <span class="comment">//</span>
03218                     <span class="comment">//  The domain must be within the version we read</span>
03219                     <span class="comment">//</span>
03220 
03221                     (!<a class="code" href="../../d3/d8/udfprocs_8h.html#a230">UdfDomainIdentifierContained</a>( &amp;LVD-&gt;<a class="code" href="../../d6/d2/structNSR__LVOL.html#o5">DomainID</a>,
03222                                                     &amp;UdfDomainIdentifier,
03223                                                     UDF_VERSION_MINIMUM,
03224                                                     UDF_VERSION_RECOGNIZED ) &amp;&amp;
03225                      <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg,
03226                                   <span class="stringliteral">"UdfFindVolumeDescriptors, domain ID indicates unreadable volume\n"</span> ))) ||
03227 
03228                     <span class="comment">//</span>
03229                     <span class="comment">//  Although we can handle any number of partitions, UDF only specifies</span>
03230                     <span class="comment">//  a single partition or special dual partition formats.</span>
03231                     <span class="comment">//</span>
03232 
03233                     (LVD-&gt;<a class="code" href="../../d6/d2/structNSR__LVOL.html#o8">MapTableCount</a> &gt; 2 &amp;&amp;
03234                      <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg,
03235                                   <span class="stringliteral">"UdfFindVolumeDescriptors, LVD MapTableCount %08x greater than allowed (2)\n"</span>,
03236                                   LVD-&gt;<a class="code" href="../../d6/d2/structNSR__LVOL.html#o8">MapTableCount</a> )))
03237                     ) {
03238 
03239                     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg,
03240                                  <span class="stringliteral">"UdfFindVolumeDescriptors, ... so returning STATUS_UNRECOGNIZED_VOLUME\n"</span> ));
03241 
03242                     <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( Status = STATUS_UNRECOGNIZED_VOLUME );
03243                 }
03244 
03245                 <span class="comment">//</span>
03246                 <span class="comment">//  Now that we have performed the simple field checks, build a Pcb.</span>
03247                 <span class="comment">//</span>
03248 
03249                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d3/d8/udfprocs_8h.html#a148">UdfInitializePcb</a>( IrpContext, Vcb, Pcb, LVD );
03250 
03251                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(Status)) {
03252 
03253                     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg,
03254                                  <span class="stringliteral">"UdfFindVolumeDescriptors, Pcb intialization failed (!)\n"</span> ));
03255 
03256                     <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( Status );
03257                 }
03258             }
03259 
03260             <span class="comment">//</span>
03261             <span class="comment">//  Go onto Pass 2 to find the Partition Descriptors</span>
03262             <span class="comment">//</span>
03263 
03264             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg,
03265                          <span class="stringliteral">"UdfFindVolumeDescriptors, starting pass 2, find associated PD\n"</span> ));
03266         }
03267 
03268     } finally {
03269 
03270         <a class="code" href="../../d8/d3/lfsdata_8h.html#a3">DebugUnwind</a>( <span class="stringliteral">"UdfFindVolumeDescriptors"</span> );
03271 
03272         <span class="comment">//</span>
03273         <span class="comment">//  Free up the buffer space we may have allocated</span>
03274         <span class="comment">//</span>
03275 
03276         <a class="code" href="../../d3/d8/udfprocs_8h.html#a124">UdfFreePool</a>( &amp;GenericVD );
03277     }
03278 
03279     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, Dbg,
03280                  <span class="stringliteral">"UdfFindVolumeDescriptors -&gt; %08x\n"</span>, Status ));
03281 
03282     <span class="comment">//</span>
03283     <span class="comment">//  Success is when we've really found something.  If we failed to find both</span>
03284     <span class="comment">//  descriptors, commute whatever intermediate status was involved and clean up.</span>
03285     <span class="comment">//</span>
03286 
03287     <span class="keywordflow">if</span> (*PrimaryVolumeDescriptor == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> || *LogicalVolumeDescriptor == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03288         
03289         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_UNRECOGNIZED_VOLUME;
03290     }
03291 
03292     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
03293         
03294         <a class="code" href="../../d3/d8/udfprocs_8h.html#a124">UdfFreePool</a>(PrimaryVolumeDescriptor);
03295         <a class="code" href="../../d3/d8/udfprocs_8h.html#a124">UdfFreePool</a>(LogicalVolumeDescriptor);
03296     }
03297     
03298     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
03299 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a9" doxytag="udfs/fsctrl.c::UdfInvalidateVolumes" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS UdfInvalidateVolumes           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>IrpContext</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d0/d2/struct__IRP.html">PIRP</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>Irp</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l01271">1271</a> of file <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html">udfs/fsctrl.c</a>.
<p>
References <a class="el" href="../../d0/d2/struct__IRP.html#o7">_IRP::AssociatedIrp</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00509">ClearFlag</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01517">_FILE_OBJECT::DeviceObject</a>, <a class="el" href="../../d6/d7/ex_8h-source.html#l00253">ExAllocatePoolWithTag</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00497">FlagOn</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01070">_VPB::Flags</a>, <a class="el" href="../../d8/d9/cmdat2_8c-source.html#l00091">Handle</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l00044">IO_TYPE_VPB</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l00134">IoAcquireVpbSpinLock()</a>, <a class="el" href="../../d6/d7/fssup_8c-source.html#l00044">IoFileObjectType</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l03252">IoGetCurrentIrpStackLocation</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l09644">IoReleaseVpbSpinLock()</a>, <a class="el" href="../../d1/d5/iop_8h-source.html#l00130">Irp</a>, <a class="el" href="../../d7/d7/udfstruc_8h-source.html#l01236">IRP_CONTEXT_FLAG_FORCE_POST</a>, <a class="el" href="../../d7/d7/udfstruc_8h-source.html#l01235">IRP_CONTEXT_FLAG_WAIT</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00624">KernelMode</a>, <a class="el" href="../../d5/d8/ex_8h.html#a329a175">NonPagedPoolMustSucceed</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00494">ObDereferenceObject</a>, <a class="el" href="../../d8/d0/obref_8c-source.html#l00542">ObReferenceObjectByHandle()</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02069">_IO_STACK_LOCATION::Parameters</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01073">_VPB::RealDevice</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01641">_IRP::RequestorMode</a>, <a class="el" href="../../d9/d3/privileg_8c-source.html#l00436">SeSinglePrivilegeCheck()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00505">SetFlag</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01069">_VPB::Size</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, <a class="el" href="../../d2/d6/udfs_2nodetype_8h-source.html#l00174">TAG_VPB</a>, <a class="el" href="../../d5/d5/tsevars_8c-source.html#l00146">TcbPrivilege</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01068">_VPB::Type</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l01509">UdfAcquireUdfData</a>, <a class="el" href="../../d9/d4/udfs_2verfysup_8c-source.html#l00236">UdfCheckForDismount()</a>, <a class="el" href="../../d1/d7/udfdata_8c-source.html#l00809">UdfCompleteRequest()</a>, <a class="el" href="../../d1/d7/udfdata_8c-source.html#l00042">UdfData</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l01559">UdfLockVcb</a>, <a class="el" href="../../d9/d1/udfs_2cachesup_8c-source.html#l00417">UdfPurgeVolume()</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l01512">UdfReleaseUdfData</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l01563">UdfUnlockVcb</a>, <a class="el" href="../../d6/d8/udfstruc_8h.html#a73">VCB</a>, <a class="el" href="../../d7/d7/udfstruc_8h-source.html#l00559">_VCB::VcbCondition</a>, <a class="el" href="../../d6/d8/udfstruc_8h.html#a130a121">VcbDismountInProgress</a>, <a class="el" href="../../d6/d8/udfstruc_8h.html#a130a120">VcbInvalid</a>, <a class="el" href="../../d7/d7/udfstruc_8h-source.html#l00216">_UDF_DATA::VcbQueue</a>, <a class="el" href="../../d7/d7/udfstruc_8h-source.html#l00529">_VCB::Vpb</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01186">_DEVICE_OBJECT::Vpb</a>, <a class="el" href="../../d0/d5/io_8h.html#a332">VPB</a>, and <a class="el" href="../../d1/d4/io_8h-source.html#l01057">VPB_REMOVE_PENDING</a>.
<p>
Referenced by <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l00363">UdfUserFsctl()</a>.
<p>
<pre class="fragment"><div>01278                    :
01279 
01280     This routine searches <span class="keywordflow">for</span> all <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> volumes mounted on <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> same real device
01281     of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> current DASD handle, and marks them all bad.  The <a class="code" href="../../d3/d0/imm32_8def.html#a1">only</a> operation
01282     that can be done on such handles <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> cleanup and close.
01283 
01284 Arguments:
01285 
01286     <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> to process
01287 
01288 Return Value:
01289 
01290     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> - The <span class="keywordflow">return</span> status <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> operation
01291 
01292 --*/
01293 
01294 {
01295     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01296     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> IrpSp = <a class="code" href="../../d0/d5/io_8h.html#a228">IoGetCurrentIrpStackLocation</a>( Irp );
01297     KIRQL SavedIrql;
01298 
01299     LUID <a class="code" href="../../d4/d6/tsevars_8c.html#a45">TcbPrivilege</a> = {SE_TCB_PRIVILEGE, 0};
01300 
01301     HANDLE <a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a>;
01302 
01303     <a class="code" href="../../d7/d7/struct__VPB.html">PVPB</a> NewVpb;
01304     <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb;
01305 
01306     PLIST_ENTRY Links;
01307 
01308     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileToMarkBad;
01309     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceToMarkBad;
01310 
01311     <span class="comment">//</span>
01312     <span class="comment">//  Check for the correct security access.</span>
01313     <span class="comment">//  The caller must have the SeTcbPrivilege.</span>
01314     <span class="comment">//</span>
01315 
01316     <span class="keywordflow">if</span> (!<a class="code" href="../../d8/d4/privileg_8c.html#a3">SeSinglePrivilegeCheck</a>( TcbPrivilege, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o10">RequestorMode</a> )) {
01317 
01318         <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, Irp, STATUS_PRIVILEGE_NOT_HELD );
01319 
01320         <span class="keywordflow">return</span> STATUS_PRIVILEGE_NOT_HELD;
01321     }
01322 
01323     <span class="comment">//</span>
01324     <span class="comment">//  Try to get a pointer to the device object from the handle passed in.</span>
01325     <span class="comment">//</span>
01326 
01327     <span class="keywordflow">if</span> (IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.FileSystemControl.InputBufferLength != <span class="keyword">sizeof</span>( HANDLE )) {
01328 
01329         <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, Irp, STATUS_INVALID_PARAMETER );
01330         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
01331     }
01332 
01333     <a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a> = *((PHANDLE) <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.SystemBuffer);
01334 
01335     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d7/d1/obref_8c.html#a4">ObReferenceObjectByHandle</a>( Handle,
01336                                         0,
01337                                         *IoFileObjectType,
01338                                         KernelMode,
01339                                         &amp;FileToMarkBad,
01340                                         NULL );
01341 
01342     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(Status)) {
01343 
01344         <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, Irp, Status );
01345         <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01346     }
01347 
01348     <span class="comment">//</span>
01349     <span class="comment">//  Grab the DeviceObject from the FileObject.</span>
01350     <span class="comment">//</span>
01351 
01352     DeviceToMarkBad = FileToMarkBad-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o2">DeviceObject</a>;
01353 
01354     <span class="comment">//</span>
01355     <span class="comment">//  We only needed the device object involved, not a reference to the file.</span>
01356     <span class="comment">//</span>
01357 
01358     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( FileToMarkBad );
01359 
01360     <span class="comment">//</span>
01361     <span class="comment">//  Create a new Vpb for this device so that any new opens will mount</span>
01362     <span class="comment">//  a new volume.</span>
01363     <span class="comment">//</span>
01364 
01365     NewVpb = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( NonPagedPoolMustSucceed, <span class="keyword">sizeof</span>( <a class="code" href="../../d7/d7/struct__VPB.html">VPB</a> ), TAG_VPB );
01366     RtlZeroMemory( NewVpb, <span class="keyword">sizeof</span>( <a class="code" href="../../d7/d7/struct__VPB.html">VPB</a> ) );
01367 
01368     NewVpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o0">Type</a> = <a class="code" href="../../d0/d5/io_8h.html#a9">IO_TYPE_VPB</a>;
01369     NewVpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o1">Size</a> = <span class="keyword">sizeof</span>( <a class="code" href="../../d7/d7/struct__VPB.html">VPB</a> );
01370     NewVpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o5">RealDevice</a> = DeviceToMarkBad;
01371     NewVpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o2">Flags</a> = <a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( DeviceToMarkBad-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o10">Vpb</a>-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o2">Flags</a>, VPB_REMOVE_PENDING );
01372 
01373     <span class="comment">//</span>
01374     <span class="comment">//  Make sure this request can wait.</span>
01375     <span class="comment">//</span>
01376 
01377     <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>( IrpContext-&gt;Flags, IRP_CONTEXT_FLAG_WAIT );
01378     <a class="code" href="../../d5/d5/cc_8h.html#a61">ClearFlag</a>( IrpContext-&gt;Flags, IRP_CONTEXT_FLAG_FORCE_POST );
01379 
01380     <a class="code" href="../../d3/d8/udfprocs_8h.html#a72">UdfAcquireUdfData</a>( IrpContext );
01381 
01382     <span class="comment">//</span>
01383     <span class="comment">//  Nothing can go wrong now.</span>
01384     <span class="comment">//</span>
01385 
01386     <a class="code" href="../../d4/d6/iosubs_8c.html#a10">IoAcquireVpbSpinLock</a>( &amp;SavedIrql );
01387     DeviceToMarkBad-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o10">Vpb</a> = NewVpb;
01388     <a class="code" href="../../d4/d6/iosubs_8c.html#a102">IoReleaseVpbSpinLock</a>( SavedIrql );
01389 
01390     <span class="comment">//</span>
01391     <span class="comment">//  Now walk through all the mounted Vcb's looking for candidates to</span>
01392     <span class="comment">//  mark invalid.</span>
01393     <span class="comment">//</span>
01394     <span class="comment">//  On volumes we mark invalid, check for dismount possibility (which is</span>
01395     <span class="comment">//  why we have to get the next link so early).</span>
01396     <span class="comment">//</span>
01397 
01398     Links = <a class="code" href="../../d0/d8/udfdata_8c.html#a2">UdfData</a>.<a class="code" href="../../d2/d3/struct__UDF__DATA.html#o3">VcbQueue</a>.Flink;
01399 
01400     <span class="keywordflow">while</span> (Links != &amp;<a class="code" href="../../d0/d8/udfdata_8c.html#a2">UdfData</a>.<a class="code" href="../../d2/d3/struct__UDF__DATA.html#o3">VcbQueue</a>) {
01401 
01402         Vcb = CONTAINING_RECORD( Links, <a class="code" href="../../d7/d5/struct__VCB.html">VCB</a>, VcbLinks);
01403 
01404         Links = Links-&gt;Flink;
01405 
01406         <span class="comment">//</span>
01407         <span class="comment">//  If we get a match, mark the volume Bad, and also check to</span>
01408         <span class="comment">//  see if the volume should go away.</span>
01409         <span class="comment">//</span>
01410 
01411         <a class="code" href="../../d3/d8/udfprocs_8h.html#a88">UdfLockVcb</a>( IrpContext, Vcb );
01412 
01413         <span class="keywordflow">if</span> (Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o2">Vpb</a>-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o5">RealDevice</a> == DeviceToMarkBad) {
01414 
01415             <span class="keywordflow">if</span> (Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o8">VcbCondition</a> != <a class="code" href="../../d6/d8/udfstruc_8h.html#a130a121">VcbDismountInProgress</a>) {
01416                 
01417                 Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o8">VcbCondition</a> = <a class="code" href="../../d6/d8/udfstruc_8h.html#a130a120">VcbInvalid</a>;
01418             }
01419 
01420             <a class="code" href="../../d3/d8/udfprocs_8h.html#a89">UdfUnlockVcb</a>( IrpContext, Vcb );
01421 
01422             <a class="code" href="../../d3/d8/udfprocs_8h.html#a158">UdfPurgeVolume</a>( IrpContext, Vcb, FALSE );
01423 
01424             <a class="code" href="../../d8/d5/udfs_2verfysup_8c.html#a3">UdfCheckForDismount</a>( IrpContext, Vcb, FALSE );
01425 
01426         } <span class="keywordflow">else</span> {
01427 
01428             <a class="code" href="../../d3/d8/udfprocs_8h.html#a89">UdfUnlockVcb</a>( IrpContext, Vcb );
01429         }
01430     }
01431 
01432     <a class="code" href="../../d3/d8/udfprocs_8h.html#a73">UdfReleaseUdfData</a>( IrpContext );
01433 
01434     <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, Irp, STATUS_SUCCESS );
01435     <span class="keywordflow">return</span> STATUS_SUCCESS;
01436 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a10" doxytag="udfs/fsctrl.c::UdfIsPathnameValid" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS UdfIsPathnameValid           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>IrpContext</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d0/d2/struct__IRP.html">PIRP</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>Irp</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l01236">1236</a> of file <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html">udfs/fsctrl.c</a>.
<p>
References <a class="el" href="../../d1/d5/iop_8h-source.html#l00130">Irp</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>, and <a class="el" href="../../d1/d7/udfdata_8c-source.html#l00809">UdfCompleteRequest()</a>.
<p>
Referenced by <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l00363">UdfUserFsctl()</a>.
<p>
<pre class="fragment"><div>01243                    :
01244 
01245     This routine determines <span class="keywordflow">if</span> pathname <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> a valid UDFS pathname.
01246     We always succeed <span class="keyword">this</span> request.
01247 
01248 Arguments:
01249 
01250     <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> to process.
01251 
01252 Return Value:
01253 
01254     None
01255 
01256 --*/
01257 
01258 {
01259     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01260 
01261     <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, Irp, STATUS_SUCCESS );
01262     <span class="keywordflow">return</span> STATUS_SUCCESS;
01263 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a11" doxytag="udfs/fsctrl.c::UdfIsRemount" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> BOOLEAN UdfIsRemount           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>IrpContext</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d7/d5/struct__VCB.html">PVCB</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>Vcb</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT <a class="el" href="../../d7/d5/struct__VCB.html">PVCB</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>OldVcb</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l02439">2439</a> of file <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html">udfs/fsctrl.c</a>.
<p>
References <a class="el" href="../../d2/d7/udfdata_8h-source.html#l00352">ASSERT_IRP_CONTEXT</a>, <a class="el" href="../../d2/d7/udfdata_8h-source.html#l00336">ASSERT_VCB</a>, <a class="el" href="../../d0/d5/cdfs__rec_8c-source.html#l00032">Dbg</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02290">DebugTrace</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01073">_VPB::RealDevice</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01074">_VPB::SerialNumber</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, <a class="el" href="../../d1/d7/udfdata_8c-source.html#l00042">UdfData</a>, <a class="el" href="../../d6/d8/udfstruc_8h.html#a130a117">VcbNotMounted</a>, <a class="el" href="../../d7/d7/udfstruc_8h-source.html#l00216">_UDF_DATA::VcbQueue</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01076">_VPB::VolumeLabel</a>, and <a class="el" href="../../d1/d4/io_8h-source.html#l01071">_VPB::VolumeLabelLength</a>.
<p>
Referenced by <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l01444">UdfMountVolume()</a>.
<p>
<pre class="fragment"><div>02447                    :
02448 
02449     This routine walks through <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> links of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Vcb chain in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> global
02450     data structure.  The remount condition <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> met when <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> following
02451     conditions are all met:
02452 
02453             1 - The 32 serial <span class="keywordflow">for</span> <span class="keyword">this</span> <a class="code" href="../../d7/d7/struct__VPB.html">VPB</a> matches that in a previous
02454                 <a class="code" href="../../d7/d7/struct__VPB.html">VPB</a>.
02455 
02456             2 - The volume label <span class="keywordflow">for</span> <span class="keyword">this</span> <a class="code" href="../../d7/d7/struct__VPB.html">VPB</a> matches that in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> previous
02457                 <a class="code" href="../../d7/d7/struct__VPB.html">VPB</a>.
02458 
02459             3 - The system pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> real device object in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> current
02460                 <a class="code" href="../../d7/d7/struct__VPB.html">VPB</a> matches that in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> same previous <a class="code" href="../../d7/d7/struct__VPB.html">VPB</a>.
02461 
02462             4 - Finally <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> previous Vcb cannot be invalid or have a dismount
02463                 underway.
02464 
02465     If a <a class="code" href="../../d7/d7/struct__VPB.html">VPB</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> found which matches these conditions, then <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> address of
02466     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Vcb <span class="keywordflow">for</span> that <a class="code" href="../../d7/d7/struct__VPB.html">VPB</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> returned via <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> pointer OldVcb.
02467 
02468     Skip over <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> current Vcb.
02469 
02470 Arguments:
02471 
02472     Vcb - This <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Vcb we are checking <span class="keywordflow">for</span> a remount.
02473 
02474     OldVcb -  <a class="code" href="../../d2/d1/bench_8h.html#a5">A</a> pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> address to store <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> address <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Vcb
02475               <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> volume <span class="keywordflow">if</span> <span class="keyword">this</span> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> a remount.  (This <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> a pointer to
02476               a pointer)
02477 
02478 Return Value:
02479 
02480     BOOLEAN - <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> <span class="keywordflow">if</span> <span class="keyword">this</span> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> in fact a remount, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> otherwise.
02481 
02482 --*/
02483 
02484 {
02485     PLIST_ENTRY Link;
02486 
02487     <a class="code" href="../../d7/d7/struct__VPB.html">PVPB</a> Vpb = Vcb-&gt;Vpb;
02488     <a class="code" href="../../d7/d7/struct__VPB.html">PVPB</a> OldVpb;
02489 
02490     BOOLEAN Remount = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02491 
02492     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
02493 
02494     <span class="comment">//</span>
02495     <span class="comment">//  Check input.</span>
02496     <span class="comment">//</span>
02497 
02498     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
02499     <a class="code" href="../../d1/d8/udfdata_8h.html#a12">ASSERT_VCB</a>( Vcb );
02500 
02501     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( +1, Dbg, <span class="stringliteral">"UdfIsRemount, Vcb %08x\n"</span>, Vcb ));
02502 
02503     <span class="keywordflow">for</span> (Link = <a class="code" href="../../d0/d8/udfdata_8c.html#a2">UdfData</a>.<a class="code" href="../../d2/d3/struct__UDF__DATA.html#o3">VcbQueue</a>.Flink;
02504          Link != &amp;<a class="code" href="../../d0/d8/udfdata_8c.html#a2">UdfData</a>.<a class="code" href="../../d2/d3/struct__UDF__DATA.html#o3">VcbQueue</a>;
02505          Link = Link-&gt;Flink) {
02506 
02507         *OldVcb = CONTAINING_RECORD( Link, <a class="code" href="../../d7/d5/struct__VCB.html">VCB</a>, VcbLinks );
02508 
02509         <span class="comment">//</span>
02510         <span class="comment">//  Skip ourselves.</span>
02511         <span class="comment">//</span>
02512 
02513         <span class="keywordflow">if</span> (Vcb == *OldVcb) { <span class="keywordflow">continue</span>; }
02514 
02515         <span class="comment">//</span>
02516         <span class="comment">//  Look at the Vpb and state of the previous Vcb.</span>
02517         <span class="comment">//</span>
02518 
02519         OldVpb = (*OldVcb)-&gt;Vpb;
02520 
02521         <span class="keywordflow">if</span> ((OldVpb != Vpb) &amp;&amp;
02522             (OldVpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o5">RealDevice</a> == Vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o5">RealDevice</a>) &amp;&amp;
02523             ((*OldVcb)-&gt;VcbCondition == <a class="code" href="../../d6/d8/udfstruc_8h.html#a130a117">VcbNotMounted</a>)) {
02524 
02525             <span class="comment">//</span>
02526             <span class="comment">//  Go ahead and compare serial numbers and volume label.</span>
02527             <span class="comment">//</span>
02528 
02529             <span class="keywordflow">if</span> ((OldVpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o6">SerialNumber</a> == Vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o6">SerialNumber</a>) &amp;&amp;
02530                        (Vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o3">VolumeLabelLength</a> == OldVpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o3">VolumeLabelLength</a>) &amp;&amp;
02531                        (RtlEqualMemory( OldVpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o8">VolumeLabel</a>,
02532                                         Vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o8">VolumeLabel</a>,
02533                                         Vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o3">VolumeLabelLength</a> ))) {
02534 
02535                 <span class="comment">//</span>
02536                 <span class="comment">//  Got it.</span>
02537                 <span class="comment">//</span>
02538 
02539                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg, <span class="stringliteral">"UdfIsRemount, matched OldVcb %08x\n"</span>, *OldVcb ));
02540 
02541                 Remount = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02542                 <span class="keywordflow">break</span>;
02543             }
02544         }
02545     }
02546 
02547     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, Dbg, <span class="stringliteral">"UdfIsRemount -&gt; %c\n"</span>, (Remount? <span class="charliteral">'T'</span> : <span class="charliteral">'F'</span> )));
02548 
02549     <span class="keywordflow">return</span> Remount;
02550 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a12" doxytag="udfs/fsctrl.c::UdfIsVolumeDirty" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> UdfIsVolumeDirty           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>IrpContext</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d0/d2/struct__IRP.html">PIRP</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>Irp</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l01064">1064</a> of file <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html">udfs/fsctrl.c</a>.
<p>
References <a class="el" href="../../d0/d2/struct__IRP.html#o7">_IRP::AssociatedIrp</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02494">_IO_STACK_LOCATION::FileObject</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l03252">IoGetCurrentIrpStackLocation</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01635">_IRP::IoStatus</a>, <a class="el" href="../../d1/d5/iop_8h-source.html#l00130">Irp</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01596">_IRP::MdlAddress</a>, <a class="el" href="../../d3/d0/mm_8h-source.html#l01833">MmGetSystemAddressForMdlSafe</a>, <a class="el" href="../../d2/d1/mm_8h.html#a347a182">NormalPagePriority</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02069">_IO_STACK_LOCATION::Parameters</a>, <a class="el" href="../../d3/d8/udfprocs_8h.html#a109">TYPE_OF_OPEN</a>, <a class="el" href="../../d1/d7/udfdata_8c-source.html#l00809">UdfCompleteRequest()</a>, <a class="el" href="../../d7/d2/filobsup_8c-source.html#l00133">UdfDecodeFileObject()</a>, <a class="el" href="../../d3/d8/udfprocs_8h.html#a263a115">UserVolumeOpen</a>, <a class="el" href="../../d7/d7/udfstruc_8h-source.html#l00941">_FCB::Vcb</a>, <a class="el" href="../../d7/d7/udfstruc_8h-source.html#l00559">_VCB::VcbCondition</a>, and <a class="el" href="../../d6/d8/udfstruc_8h.html#a130a119">VcbMounted</a>.
<p>
Referenced by <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l00363">UdfUserFsctl()</a>.
<p>
<pre class="fragment"><div>01071                    :
01072 
01073     This routine determines <span class="keywordflow">if</span> a volume <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> currently dirty.
01074 
01075 Arguments:
01076 
01077     <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> to process
01078 
01079 Return Value:
01080 
01081     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> - The <span class="keywordflow">return</span> status <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> operation
01082 
01083 --*/
01084 
01085 {
01086     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> IrpSp;
01087 
01088     <a class="code" href="../../d3/d8/udfprocs_8h.html#a109">TYPE_OF_OPEN</a> TypeOfOpen;
01089     <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb;
01090     <a class="code" href="../../d7/d9/struct__FCB.html">PFCB</a> Fcb;
01091     <a class="code" href="../../d2/d9/struct__CCB.html">PCCB</a> Ccb;
01092 
01093     PULONG VolumeState;
01094     
01095     <span class="comment">//</span>
01096     <span class="comment">//  Get the current stack location and extract the output</span>
01097     <span class="comment">//  buffer information.</span>
01098     <span class="comment">//</span>
01099 
01100     IrpSp = <a class="code" href="../../d0/d5/io_8h.html#a228">IoGetCurrentIrpStackLocation</a>( Irp );
01101 
01102     <span class="comment">//</span>
01103     <span class="comment">//  Get a pointer to the output buffer.  Look at the system buffer field in the</span>
01104     <span class="comment">//  irp first.  Then the Irp Mdl.</span>
01105     <span class="comment">//</span>
01106 
01107     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.SystemBuffer != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01108 
01109         VolumeState = <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.SystemBuffer;
01110 
01111     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o2">MdlAddress</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01112 
01113         VolumeState = <a class="code" href="../../d2/d1/mm_8h.html#a25">MmGetSystemAddressForMdlSafe</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o2">MdlAddress</a>, NormalPagePriority );
01114 
01115         <span class="keywordflow">if</span> (<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> == VolumeState)  {
01116         
01117             <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, Irp, STATUS_INSUFFICIENT_RESOURCES );
01118             <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
01119         }
01120     } <span class="keywordflow">else</span> {
01121 
01122         <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, Irp, STATUS_INVALID_USER_BUFFER );
01123         <span class="keywordflow">return</span> STATUS_INVALID_USER_BUFFER;
01124     }
01125 
01126     <span class="comment">//</span>
01127     <span class="comment">//  Make sure the output buffer is large enough and then initialize</span>
01128     <span class="comment">//  the answer to be that the volume isn't dirty.</span>
01129     <span class="comment">//</span>
01130 
01131     <span class="keywordflow">if</span> (IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.FileSystemControl.OutputBufferLength &lt; <span class="keyword">sizeof</span>(ULONG)) {
01132 
01133         <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, Irp, STATUS_INVALID_PARAMETER );
01134         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
01135     }
01136 
01137     *VolumeState = 0;
01138 
01139     <span class="comment">//</span>
01140     <span class="comment">//  Decode the file object</span>
01141     <span class="comment">//</span>
01142 
01143     TypeOfOpen = <a class="code" href="../../d3/d8/udfprocs_8h.html#a174">UdfDecodeFileObject</a>( IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a>, &amp;Fcb, &amp;Ccb );
01144 
01145     <span class="keywordflow">if</span> (TypeOfOpen != <a class="code" href="../../d3/d8/udfprocs_8h.html#a263a115">UserVolumeOpen</a>) {
01146 
01147         <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, Irp, STATUS_INVALID_PARAMETER );
01148         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
01149     }
01150 
01151     <span class="keywordflow">if</span> (Fcb-&gt;<a class="code" href="../../d7/d9/struct__FCB.html#o2">Vcb</a>-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o8">VcbCondition</a> != <a class="code" href="../../d6/d8/udfstruc_8h.html#a130a119">VcbMounted</a>) {
01152 
01153         <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, Irp, STATUS_VOLUME_DISMOUNTED );
01154         <span class="keywordflow">return</span> STATUS_VOLUME_DISMOUNTED;
01155     }
01156 
01157     <span class="comment">//</span>
01158     <span class="comment">//  Now set up to return the clean state.  If we paid attention to the dirty</span>
01159     <span class="comment">//  state of the media we could be more accurate, but since this is a readonly</span>
01160     <span class="comment">//  implementation at the moment we think it is clean all of the time.</span>
01161     <span class="comment">//</span>
01162     
01163     <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Information = <span class="keyword">sizeof</span>( ULONG );
01164 
01165     <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, Irp, STATUS_SUCCESS );
01166     <span class="keywordflow">return</span> STATUS_SUCCESS;
01167 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a13" doxytag="udfs/fsctrl.c::UdfIsVolumeMounted" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS UdfIsVolumeMounted           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>IrpContext</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d0/d2/struct__IRP.html">PIRP</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>Irp</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l01175">1175</a> of file <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html">udfs/fsctrl.c</a>.
<p>
References <a class="el" href="../../d1/d4/io_8h-source.html#l02494">_IO_STACK_LOCATION::FileObject</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l03252">IoGetCurrentIrpStackLocation</a>, <a class="el" href="../../d1/d5/iop_8h-source.html#l00130">Irp</a>, <a class="el" href="../../d7/d7/udfstruc_8h-source.html#l01242">IRP_CONTEXT_FLAG_DISABLE_POPUPS</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00505">SetFlag</a>, <a class="el" href="../../d1/d7/udfdata_8c-source.html#l00809">UdfCompleteRequest()</a>, <a class="el" href="../../d7/d2/filobsup_8c-source.html#l00133">UdfDecodeFileObject()</a>, <a class="el" href="../../d9/d4/udfs_2verfysup_8c-source.html#l00603">UdfVerifyVcb()</a>, and <a class="el" href="../../d7/d7/udfstruc_8h-source.html#l00941">_FCB::Vcb</a>.
<p>
Referenced by <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l00363">UdfUserFsctl()</a>.
<p>
<pre class="fragment"><div>01182                    :
01183 
01184     This routine determines <span class="keywordflow">if</span> a volume <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> currently mounted.
01185 
01186 Arguments:
01187 
01188     <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> to process
01189 
01190 Return Value:
01191 
01192     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> - The <span class="keywordflow">return</span> status <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> operation
01193 
01194 --*/
01195 
01196 {
01197     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> IrpSp = <a class="code" href="../../d0/d5/io_8h.html#a228">IoGetCurrentIrpStackLocation</a>( Irp );
01198 
01199     <a class="code" href="../../d7/d9/struct__FCB.html">PFCB</a> Fcb;
01200     <a class="code" href="../../d2/d9/struct__CCB.html">PCCB</a> Ccb;
01201 
01202     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01203 
01204     <span class="comment">//</span>
01205     <span class="comment">//  Decode the file object.</span>
01206     <span class="comment">//</span>
01207 
01208     <a class="code" href="../../d3/d8/udfprocs_8h.html#a174">UdfDecodeFileObject</a>( IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a>, &amp;Fcb, &amp;Ccb );
01209 
01210     <span class="keywordflow">if</span> (Fcb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01211 
01212         <span class="comment">//</span>
01213         <span class="comment">//  Disable PopUps, we want to return any error.</span>
01214         <span class="comment">//</span>
01215 
01216         <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>( IrpContext-&gt;Flags, IRP_CONTEXT_FLAG_DISABLE_POPUPS );
01217 
01218         <span class="comment">//</span>
01219         <span class="comment">//  Verify the Vcb.  This will raise in the error condition.</span>
01220         <span class="comment">//</span>
01221 
01222         <a class="code" href="../../d8/d5/udfs_2verfysup_8c.html#a5">UdfVerifyVcb</a>( IrpContext, Fcb-&gt;<a class="code" href="../../d7/d9/struct__FCB.html#o2">Vcb</a> );
01223     }
01224 
01225     <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, Irp, STATUS_SUCCESS );
01226 
01227     <span class="keywordflow">return</span> STATUS_SUCCESS;
01228 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a14" doxytag="udfs/fsctrl.c::UdfLockVolume" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS UdfLockVolume           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>IrpContext</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d0/d2/struct__IRP.html">PIRP</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>Irp</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l00780">780</a> of file <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html">udfs/fsctrl.c</a>.
<p>
References <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02494">_IO_STACK_LOCATION::FileObject</a>, <a class="el" href="../../d2/d7/fsrtl_8h-source.html#l01423">FSRTL_VOLUME_LOCK</a>, <a class="el" href="../../d2/d7/fsrtl_8h-source.html#l01424">FSRTL_VOLUME_LOCK_FAILED</a>, <a class="el" href="../../d4/d8/fsrtl_2pnp_8c-source.html#l00041">FsRtlNotifyVolumeEvent()</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l03252">IoGetCurrentIrpStackLocation</a>, <a class="el" href="../../d1/d5/iop_8h-source.html#l00130">Irp</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l01515">UdfAcquireVcbExclusive</a>, <a class="el" href="../../d1/d7/udfdata_8c-source.html#l00809">UdfCompleteRequest()</a>, <a class="el" href="../../d7/d2/filobsup_8c-source.html#l00133">UdfDecodeFileObject()</a>, <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l00621">UdfLockVolumeInternal()</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l01521">UdfReleaseVcb</a>, <a class="el" href="../../d9/d4/udfs_2verfysup_8c-source.html#l00603">UdfVerifyVcb()</a>, <a class="el" href="../../d3/d8/udfprocs_8h.html#a263a115">UserVolumeOpen</a>, and <a class="el" href="../../d7/d7/udfstruc_8h-source.html#l00941">_FCB::Vcb</a>.
<p>
Referenced by <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l00363">UdfUserFsctl()</a>.
<p>
<pre class="fragment"><div>00787                    :
00788 
00789     This routine performs <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> lock volume operation.  It <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> responsible <span class="keywordflow">for</span>
00790     either completing of enqueuing <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> input <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>.
00791 
00792 Arguments:
00793 
00794     <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> to process
00795 
00796 Return Value:
00797 
00798     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> - The <span class="keywordflow">return</span> status <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> operation
00799 
00800 --*/
00801 
00802 {
00803     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00804 
00805     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> IrpSp = <a class="code" href="../../d0/d5/io_8h.html#a228">IoGetCurrentIrpStackLocation</a>( Irp );
00806 
00807     <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb;
00808     <a class="code" href="../../d7/d9/struct__FCB.html">PFCB</a> Fcb;
00809     <a class="code" href="../../d2/d9/struct__CCB.html">PCCB</a> Ccb;
00810 
00811     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00812 
00813     <span class="comment">//</span>
00814     <span class="comment">//  Decode the file object, the only type of opens we accept are</span>
00815     <span class="comment">//  user volume opens.</span>
00816     <span class="comment">//</span>
00817 
00818     <span class="keywordflow">if</span> (<a class="code" href="../../d3/d8/udfprocs_8h.html#a174">UdfDecodeFileObject</a>( IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a>, &amp;Fcb, &amp;Ccb ) != <a class="code" href="../../d3/d8/udfprocs_8h.html#a263a115">UserVolumeOpen</a>) {
00819 
00820         <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, Irp, STATUS_INVALID_PARAMETER );
00821 
00822         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
00823     }
00824 
00825     <span class="comment">//</span>
00826     <span class="comment">//  Send our notification so that folks that like to hold handles on</span>
00827     <span class="comment">//  volumes can get out of the way.</span>
00828     <span class="comment">//</span>
00829 
00830     <a class="code" href="../../d1/d8/fsrtl_8h.html#a168">FsRtlNotifyVolumeEvent</a>( IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a>, FSRTL_VOLUME_LOCK );
00831 
00832     <span class="comment">//</span>
00833     <span class="comment">//  Acquire exclusive access to the Vcb.</span>
00834     <span class="comment">//</span>
00835 
00836     Vcb = Fcb-&gt;<a class="code" href="../../d7/d9/struct__FCB.html#o2">Vcb</a>;
00837     <a class="code" href="../../d3/d8/udfprocs_8h.html#a74">UdfAcquireVcbExclusive</a>( IrpContext, Vcb, FALSE );
00838 
00839     <span class="keywordflow">try</span> {
00840 
00841         <span class="comment">//</span>
00842         <span class="comment">//  Verify the Vcb.</span>
00843         <span class="comment">//</span>
00844 
00845         <a class="code" href="../../d8/d5/udfs_2verfysup_8c.html#a5">UdfVerifyVcb</a>( IrpContext, Vcb );
00846 
00847         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d3/d8/udfprocs_8h.html#a190">UdfLockVolumeInternal</a>( IrpContext, Vcb, IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a> );
00848 
00849     } finally {
00850 
00851         <span class="comment">//</span>
00852         <span class="comment">//  Release the Vcb.</span>
00853         <span class="comment">//</span>
00854 
00855         <a class="code" href="../../d3/d8/udfprocs_8h.html#a76">UdfReleaseVcb</a>( IrpContext, Vcb );
00856 
00857         <span class="keywordflow">if</span> (AbnormalTermination() || !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
00858 
00859             <a class="code" href="../../d1/d8/fsrtl_8h.html#a168">FsRtlNotifyVolumeEvent</a>( IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a>, FSRTL_VOLUME_LOCK_FAILED );
00860         }
00861     }
00862 
00863     <span class="comment">//</span>
00864     <span class="comment">//  Complete the request if there haven't been any exceptions.</span>
00865     <span class="comment">//</span>
00866 
00867     <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, Irp, Status );
00868     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00869 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a26" doxytag="udfs/fsctrl.c::UdfLockVolumeInternal" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS UdfLockVolumeInternal           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>IrpContext</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d7/d5/struct__VCB.html">PVCB</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>Vcb</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l00621">621</a> of file <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html">udfs/fsctrl.c</a>.
<p>
References <a class="el" href="../../d2/d7/udfdata_8h-source.html#l00364">ASSERT_EXCLUSIVE_VCB</a>, <a class="el" href="../../d6/d0/lazyrite_8c-source.html#l00158">CcWaitForCurrentLazyWriterActivity()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00497">FlagOn</a>, <a class="el" href="../../d7/d7/udfstruc_8h-source.html#l01235">IRP_CONTEXT_FLAG_WAIT</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00505">SetFlag</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l01515">UdfAcquireVcbExclusive</a>, <a class="el" href="../../d3/d8/close_8c-source.html#l00099">UdfFspClose()</a>, <a class="el" href="../../d9/d1/udfs_2cachesup_8c-source.html#l00417">UdfPurgeVolume()</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l01521">UdfReleaseVcb</a>, and <a class="el" href="../../d7/d7/udfstruc_8h-source.html#l00683">VCB_STATE_LOCKED</a>.
<p>
Referenced by <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l00780">UdfLockVolume()</a>, and <a class="el" href="../../d5/d8/udfs_2pnp_8c-source.html#l00194">UdfPnpQueryRemove()</a>.
<p>
<pre class="fragment"><div>00629                    :
00630 
00631     This routine performs <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> actual lock volume operation.  It will be called
00632     by anyone wishing to <span class="keywordflow">try</span> to protect <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> volume <span class="keywordflow">for</span> a <span class="keywordtype">long</span> duration.  PNP
00633     operations are such a user.
00634     
00635     The volume must be held exclusive by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller.
00636 
00637 Arguments:
00638 
00639     Vcb - The volume being locked.
00640     
00641     FileObject - <a class="code" href="../../d1/d9/icmui_8def.html#a0">File</a> corresponding to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> handle locking <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> volume.  If <span class="keyword">this</span>
00642         <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> not specified, a system lock <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> assumed.
00643 
00644 Return Value:
00645 
00646     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> - The <span class="keywordflow">return</span> status <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> operation
00647 
00648 --*/
00649 
00650 {
00651     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00652     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> FinalStatus = (FileObject? STATUS_ACCESS_DENIED: STATUS_DEVICE_BUSY);
00653     ULONG RemainingUserReferences = (FileObject? 1: 0);
00654 
00655     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00656 
00657     <a class="code" href="../../d1/d8/udfdata_8h.html#a40">ASSERT_EXCLUSIVE_VCB</a>( Vcb );
00658     
00659     <span class="comment">//</span>
00660     <span class="comment">//  If the volume is already locked then complete with success if this file</span>
00661     <span class="comment">//  object has the volume locked, fail otherwise.</span>
00662     <span class="comment">//</span>
00663 
00664     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( Vcb-&gt;VcbState, VCB_STATE_LOCKED )) {
00665 
00666         <span class="keywordflow">if</span> (FileObject &amp;&amp; Vcb-&gt;VolumeLockFileObject == FileObject) {
00667 
00668             FinalStatus = STATUS_SUCCESS;
00669         }
00670 
00671     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Vcb-&gt;VcbCleanup == RemainingUserReferences) {
00672 
00673         <span class="comment">//</span>
00674         <span class="comment">//  The cleanup count for the volume only reflects the fileobject that</span>
00675         <span class="comment">//  will lock the volume.  Otherwise, we must fail the request.</span>
00676         <span class="comment">//</span>
00677         <span class="comment">//  Since the only cleanup is for the provided fileobject, we will try</span>
00678         <span class="comment">//  to get rid of all of the other user references.  If there is only one</span>
00679         <span class="comment">//  remaining after the purge then we can allow the volume to be locked.</span>
00680         <span class="comment">//</span>
00681         
00682         <a class="code" href="../../d3/d8/udfprocs_8h.html#a158">UdfPurgeVolume</a>( IrpContext, Vcb, FALSE );
00683 
00684         <span class="comment">//</span>
00685         <span class="comment">//  Now back out of our synchronization and wait for the lazy writer</span>
00686         <span class="comment">//  to finish off any lazy closes that could have been outstanding.</span>
00687         <span class="comment">//</span>
00688         <span class="comment">//  Since we purged, we know that the lazy writer will issue all</span>
00689         <span class="comment">//  possible lazy closes in the next tick - if we hadn't, an otherwise</span>
00690         <span class="comment">//  unopened file with a large amount of dirty data could have hung</span>
00691         <span class="comment">//  around for a while as the data trickled out to the disk.</span>
00692         <span class="comment">//</span>
00693         <span class="comment">//  This is even more important now since we send notification to</span>
00694         <span class="comment">//  alert other folks that this style of check is about to happen so</span>
00695         <span class="comment">//  that they can close their handles.  We don't want to enter a fast</span>
00696         <span class="comment">//  race with the lazy writer tearing down his references to the file.</span>
00697         <span class="comment">//</span>
00698 
00699         <a class="code" href="../../d3/d8/udfprocs_8h.html#a76">UdfReleaseVcb</a>( IrpContext, Vcb );
00700 
00701         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d5/d1/lazyrite_8c.html#a6">CcWaitForCurrentLazyWriterActivity</a>();
00702 
00703         <span class="comment">//</span>
00704         <span class="comment">//  This is intentional. If we were able to get the Vcb before, just</span>
00705         <span class="comment">//  wait for it and take advantage of knowing that it is OK to leave</span>
00706         <span class="comment">//  the flag up.</span>
00707         <span class="comment">//</span>
00708 
00709         <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>( IrpContext-&gt;Flags, IRP_CONTEXT_FLAG_WAIT );
00710         <a class="code" href="../../d3/d8/udfprocs_8h.html#a74">UdfAcquireVcbExclusive</a>( IrpContext, Vcb, FALSE );
00711         
00712         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
00713 
00714             <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00715         }
00716 
00717         <a class="code" href="../../d3/d8/udfprocs_8h.html#a250">UdfFspClose</a>( Vcb );
00718 
00719         <span class="keywordflow">if</span> (Vcb-&gt;VcbUserReference == Vcb-&gt;VcbResidualUserReference + RemainingUserReferences) {
00720 
00721             <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>( Vcb-&gt;VcbState, VCB_STATE_LOCKED );
00722             Vcb-&gt;VolumeLockFileObject = FileObject;
00723             FinalStatus = STATUS_SUCCESS;
00724         }
00725     }
00726     
00727     <span class="keywordflow">return</span> FinalStatus;
00728 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a15" doxytag="udfs/fsctrl.c::UdfMountVolume" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS UdfMountVolume           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>IrpContext</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d0/d2/struct__IRP.html">PIRP</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>Irp</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l01444">1444</a> of file <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html">udfs/fsctrl.c</a>.
<p>
References <a class="el" href="../../d1/d4/io_8h-source.html#l01194">_DEVICE_OBJECT::AlignmentRequirement</a>, <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d2/d7/udfdata_8h-source.html#l00356">ASSERT_IRP</a>, <a class="el" href="../../d2/d7/udfdata_8h-source.html#l00352">ASSERT_IRP_CONTEXT</a>, <a class="el" href="../../d7/d7/udfstruc_8h-source.html#l00601">_VCB::BoundN</a>, <a class="el" href="../../d7/d7/udfstruc_8h-source.html#l00600">_VCB::BoundS</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00509">ClearFlag</a>, <a class="el" href="../../d0/d5/cdfs__rec_8c-source.html#l00032">Dbg</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02290">DebugTrace</a>, <a class="el" href="../../d9/d2/lfsdata_8h-source.html#l00187">DebugUnwind</a>, <a class="el" href="../../d0/d5/io_8h.html#a339">DEVICE_OBJECT</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01072">_VPB::DeviceObject</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01188">_DEVICE_OBJECT::DeviceType</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01159">DO_DEVICE_INITIALIZING</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01153">DO_VERIFY_VOLUME</a>, <a class="el" href="../../d7/d7/udfstruc_8h-source.html#l00210">_UDF_DATA::DriverObject</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00497">FlagOn</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01184">_DEVICE_OBJECT::Flags</a>, <a class="el" href="../../d1/d6/iso13346_8h-source.html#l00545">NSR_LVOL::FSD</a>, <a class="el" href="../../d2/d7/fsrtl_8h-source.html#l01426">FSRTL_VOLUME_MOUNT</a>, <a class="el" href="../../d4/d8/fsrtl_2pnp_8c-source.html#l00041">FsRtlNotifyVolumeEvent()</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l04073">IoCreateDevice()</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l05951">IoDeleteDevice()</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l03252">IoGetCurrentIrpStackLocation</a>, <a class="el" href="../../d1/d5/iop_8h-source.html#l00130">Irp</a>, <a class="el" href="../../d7/d7/udfstruc_8h-source.html#l01235">IRP_CONTEXT_FLAG_WAIT</a>, <a class="el" href="../../d4/d9/ke_8h.html#a354">KeInitializeSpinLock()</a>, <a class="el" href="../../d1/d6/iso13346_8h-source.html#l00441">NSR_ANCHOR::Main</a>, <a class="el" href="../../d7/d7/udfstruc_8h-source.html#l00572">_VCB::MediaChangeCount</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00494">ObDereferenceObject</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00514">ObReferenceObject</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02069">_IO_STACK_LOCATION::Parameters</a>, <a class="el" href="../../d7/d7/udfstruc_8h-source.html#l00535">_VCB::Pcb</a>, <a class="el" href="../../d6/d8/udfstruc_8h.html#a76">PVOLUME_DEVICE_OBJECT</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01073">_VPB::RealDevice</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01075">_VPB::ReferenceCount</a>, <a class="el" href="../../d1/d6/iso13346_8h-source.html#l00442">NSR_ANCHOR::Reserve</a>, <a class="el" href="../../d7/d7/udfstruc_8h-source.html#l00629">_VCB::RootIndexFcb</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01074">_VPB::SerialNumber</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00505">SetFlag</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01189">_DEVICE_OBJECT::StackSize</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, <a class="el" href="../../d7/d7/udfstruc_8h-source.html#l00541">_VCB::TargetDeviceObject</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l00436">try_leave</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l01509">UdfAcquireUdfData</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l01515">UdfAcquireVcbExclusive</a>, <a class="el" href="../../d3/d5/allocsup_8c-source.html#l00804">UdfCompletePcb()</a>, <a class="el" href="../../d1/d7/udfdata_8c-source.html#l00809">UdfCompleteRequest()</a>, <a class="el" href="../../d1/d7/udfdata_8c-source.html#l00042">UdfData</a>, <a class="el" href="../../d3/d5/allocsup_8c-source.html#l00309">UdfDeletePcb()</a>, <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l03817">UdfDetermineVolumeBounding()</a>, <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l00040">UdfDisable</a>, <a class="el" href="../../d9/d4/udfs_2verfysup_8c-source.html#l00365">UdfDismountVcb()</a>, <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l03307">UdfFindAnchorVolumeDescriptor()</a>, <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l02558">UdfFindFileSetDescriptor()</a>, <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l02832">UdfFindVolumeDescriptors()</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l00453">UdfFreePool()</a>, <a class="el" href="../../d1/d7/udfdata_8c-source.html#l01239">UdfHighBit()</a>, <a class="el" href="../../d0/d7/udfs_2strucsup_8c-source.html#l00331">UdfInitializeVcb()</a>, <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l02439">UdfIsRemount()</a>, <a class="el" href="../../d4/d6/deviosup_8c-source.html#l00573">UdfPerformDevIoCtrl()</a>, <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l03457">UdfRecognizeVolume()</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l01512">UdfReleaseUdfData</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l01521">UdfReleaseVcb</a>, <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l03749">UdfScanForDismountedVcb()</a>, <a class="el" href="../../d0/d7/udfs_2strucsup_8c-source.html#l00477">UdfUpdateVcbPhase0()</a>, <a class="el" href="../../d0/d7/udfs_2strucsup_8c-source.html#l00997">UdfUpdateVcbPhase1()</a>, <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l04056">UdfUpdateVolumeLabel()</a>, <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l04165">UdfUpdateVolumeSerialNumber()</a>, <a class="el" href="../../d7/d7/udfstruc_8h-source.html#l00686">VCB_STATE_METHOD_2_FIXUP</a>, <a class="el" href="../../d7/d7/udfstruc_8h-source.html#l00685">VCB_STATE_NOTIFY_REMOUNT</a>, <a class="el" href="../../d7/d7/udfstruc_8h-source.html#l00559">_VCB::VcbCondition</a>, <a class="el" href="../../d6/d8/udfstruc_8h.html#a130a119">VcbMounted</a>, <a class="el" href="../../d7/d7/udfstruc_8h-source.html#l00612">_VCB::VcbReference</a>, <a class="el" href="../../d7/d7/udfstruc_8h-source.html#l00620">_VCB::VcbResidualReference</a>, <a class="el" href="../../d7/d7/udfstruc_8h-source.html#l00558">_VCB::VcbState</a>, <a class="el" href="../../d6/d8/udfstruc_8h.html#a75">VOLUME_DEVICE_OBJECT</a>, <a class="el" href="../../d1/d6/iso13346_8h-source.html#l00542">NSR_LVOL::VolumeID</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01076">_VPB::VolumeLabel</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01071">_VPB::VolumeLabelLength</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01186">_DEVICE_OBJECT::Vpb</a>, and <a class="el" href="../../d7/d7/udfstruc_8h-source.html#l00529">_VCB::Vpb</a>.
<p>
Referenced by <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l00283">UdfCommonFsControl()</a>.
<p>
<pre class="fragment"><div>01451                    :
01452 
01453     This routine performs <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> mount volume operation.  It <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> responsible <span class="keywordflow">for</span>
01454     either completing of enqueuing <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> input <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>.
01455 
01456     Its job <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> to verify that <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> volume denoted in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d0/d2/struct__IRP.html">IRP</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> a UDF volume,
01457     and create <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d7/d5/struct__VCB.html">VCB</a> and root directory <a class="code" href="../../d7/d9/struct__FCB.html">FCB</a> structures.  The algorithm <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a>
01458     uses <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> essentially as follows:
01459 
01460     1. <a class="code" href="../../d4/d5/conimep_8h.html#a111">Create</a> a <span class="keyword">new</span> Vcb Structure, and initialize <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> enough to <span class="keywordflow">do</span> I/O
01461        through <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> on-disk volume descriptors.
01462 
01463     2. Read <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> disk and check <span class="keywordflow">if</span> <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> a UDF volume.
01464 
01465     3. If <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> not a UDF volume then <span class="keyword">delete</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Vcb and
01466        complete <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d0/d2/struct__IRP.html">IRP</a> with STATUS_UNRECOGNIZED_VOLUME
01467 
01468     4. Check <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> volume was previously mounted and <span class="keywordflow">if</span> <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> was then <span class="keywordflow">do</span> a
01469        remount operation.  This involves deleting <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d7/d5/struct__VCB.html">VCB</a>, hook in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
01470        old <a class="code" href="../../d6/d8/udfstruc_8h.html#a73">VCB</a>, and complete <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d0/d2/struct__IRP.html">IRP</a>.
01471 
01472     5. Otherwise create a Vcb and root directory <a class="code" href="../../d7/d9/struct__FCB.html">FCB</a>
01473 
01474 Arguments:
01475 
01476     <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> to process
01477 
01478 Return Value:
01479 
01480     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> - The <span class="keywordflow">return</span> status <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> operation
01481 
01482 --*/
01483 
01484 {
01485     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01486 
01487     <a class="code" href="../../d6/d7/struct__VOLUME__DEVICE__OBJECT.html">PVOLUME_DEVICE_OBJECT</a> VolDo = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01488     <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01489     <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> OldVcb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01490     <a class="code" href="../../d4/d9/struct__PCB.html">PPCB</a> Pcb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01491 
01492     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> IrpSp = <a class="code" href="../../d0/d5/io_8h.html#a228">IoGetCurrentIrpStackLocation</a>( Irp );
01493     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObjectWeTalkTo = IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.MountVolume.DeviceObject;
01494     <a class="code" href="../../d7/d7/struct__VPB.html">PVPB</a> Vpb = IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.MountVolume.Vpb;
01495 
01496     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObjectToNotify = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01497 
01498     ULONG MediaChangeCount = 0;
01499 
01500     DISK_GEOMETRY DiskGeometry;
01501 
01502     <a class="code" href="../../d7/d1/structNSR__ANCHOR.html">PNSR_ANCHOR</a> AnchorVolumeDescriptor = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01503     <a class="code" href="../../d0/d3/structNSR__PVD.html">PNSR_PVD</a> PrimaryVolumeDescriptor = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01504     <a class="code" href="../../d6/d2/structNSR__LVOL.html">PNSR_LVOL</a> LogicalVolumeDescriptor = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01505     <a class="code" href="../../d2/d2/structNSR__FSD.html">PNSR_FSD</a> FileSetDescriptor = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01506 
01507     BOOLEAN BridgeMedia;
01508 
01509     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01510 
01511     <span class="comment">//</span>
01512     <span class="comment">//  Check the input parameters</span>
01513     <span class="comment">//</span>
01514 
01515     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
01516     <a class="code" href="../../d1/d8/udfdata_8h.html#a32">ASSERT_IRP</a>( Irp );
01517 
01518     <span class="comment">//</span>
01519     <span class="comment">//  Check that we are talking to a Cdrom or Disk device.  This request should</span>
01520     <span class="comment">//  always be waitable.</span>
01521     <span class="comment">//</span>
01522 
01523     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( Vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o5">RealDevice</a>-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o12">DeviceType</a> == FILE_DEVICE_CD_ROM ||
01524             Vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o5">RealDevice</a>-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o12">DeviceType</a> == FILE_DEVICE_DISK );
01525     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( IrpContext-&gt;Flags, IRP_CONTEXT_FLAG_WAIT ));
01526 
01527     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( +1, Dbg, <span class="stringliteral">"UdfMountVolume\n"</span> ));
01528 
01529     <span class="comment">//</span>
01530     <span class="comment">//  Update the real device in the IrpContext from the Vpb.  There was no available</span>
01531     <span class="comment">//  file object when the IrpContext was created.</span>
01532     <span class="comment">//</span>
01533 
01534     IrpContext-&gt;RealDevice = Vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o5">RealDevice</a>;
01535 
01536     <span class="comment">//</span>
01537     <span class="comment">//  Check if we have disabled the mount process.</span>
01538     <span class="comment">//</span>
01539 
01540     <span class="keywordflow">if</span> (<a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a2">UdfDisable</a>) {
01541 
01542         <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, Irp, STATUS_UNRECOGNIZED_VOLUME );
01543         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg, <span class="stringliteral">"UdfMountVolume, disabled\n"</span> ));
01544         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, Dbg, <span class="stringliteral">"UdfMountVolume -&gt; STATUS_UNRECOGNIZED_VOLUME\n"</span> ));
01545 
01546         <span class="keywordflow">return</span> STATUS_UNRECOGNIZED_VOLUME;
01547     }
01548 
01549     <span class="comment">//</span>
01550     <span class="comment">//  Do a CheckVerify here to lift the MediaChange ticker from the driver</span>
01551     <span class="comment">//</span>
01552 
01553     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d3/d8/udfprocs_8h.html#a159">UdfPerformDevIoCtrl</a>( IrpContext,
01554                                   ( Vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o5">RealDevice</a>-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o12">DeviceType</a> == FILE_DEVICE_CD_ROM ?
01555                                     IOCTL_CDROM_CHECK_VERIFY :
01556                                     IOCTL_DISK_CHECK_VERIFY ),
01557                                   DeviceObjectWeTalkTo,
01558                                   &amp;MediaChangeCount,
01559                                   <span class="keyword">sizeof</span>(ULONG),
01560                                   FALSE,
01561                                   TRUE,
01562                                   NULL );
01563 
01564     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
01565         
01566         <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, Irp, Status );
01567         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg,
01568                      <span class="stringliteral">"UdfMountVolume, CHECK_VERIFY handed back status %08x (so don't continue)\n"</span>,
01569                      Status ));
01570         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, Dbg,
01571                      <span class="stringliteral">"UdfMountVolume -&gt; %08x\n"</span>,
01572                      Status ));
01573 
01574         <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01575     }
01576     
01577     <span class="comment">//</span>
01578     <span class="comment">//  Now let's make Jeff delirious and call to get the disk geometry.  This</span>
01579     <span class="comment">//  will fix the case where the first change line is swallowed.</span>
01580     <span class="comment">//</span>
01581     <span class="comment">//  This IOCTL does not have a generic STORAGE equivalent, so we must figure</span>
01582     <span class="comment">//  our which variant to pass down from the real underlying device object (as</span>
01583     <span class="comment">//  opposed to the top of the driver filter stack we will really be attaching</span>
01584     <span class="comment">//  on top of).</span>
01585     <span class="comment">//</span>
01586 
01587     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d3/d8/udfprocs_8h.html#a159">UdfPerformDevIoCtrl</a>( IrpContext,
01588                                   ( Vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o5">RealDevice</a>-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o12">DeviceType</a> == FILE_DEVICE_CD_ROM ?
01589                                     IOCTL_CDROM_GET_DRIVE_GEOMETRY :
01590                                     IOCTL_DISK_GET_DRIVE_GEOMETRY ),
01591                                   DeviceObjectWeTalkTo,
01592                                   &amp;DiskGeometry,
01593                                   <span class="keyword">sizeof</span>( DISK_GEOMETRY ),
01594                                   FALSE,
01595                                   TRUE,
01596                                   NULL );
01597 
01598     <span class="comment">//</span>
01599     <span class="comment">//  If this call failed, we might be able to get away with a heuristic guess as to</span>
01600     <span class="comment">//  what the sector size is (per CDFS), but that is playing with fire.  Nearly every</span>
01601     <span class="comment">//  failure here will be a permanent problem of some form.</span>
01602     <span class="comment">//</span>
01603 
01604     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
01605 
01606         <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, Irp, Status );
01607         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg, <span class="stringliteral">"UdfMountVolume, GET_DRIVE_GEOMETRY failed\n"</span> ));
01608         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, Dbg,
01609                      <span class="stringliteral">"UdfMountVolume -&gt; %08x\n"</span>,
01610                      Status ));
01611 
01612         <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01613     }
01614 
01615     <span class="comment">//</span>
01616     <span class="comment">//  Acquire the global resource to do mount operations.</span>
01617     <span class="comment">//</span>
01618 
01619     <a class="code" href="../../d3/d8/udfprocs_8h.html#a72">UdfAcquireUdfData</a>( IrpContext );
01620 
01621     <span class="comment">//</span>
01622     <span class="comment">//  Use a try-finally to facilitate cleanup.</span>
01623     <span class="comment">//</span>
01624 
01625     <span class="keywordflow">try</span> {
01626 
01627         <span class="comment">//</span>
01628         <span class="comment">//  Do a quick check to see if there any Vcb's which can be removed.</span>
01629         <span class="comment">//</span>
01630 
01631         <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a18">UdfScanForDismountedVcb</a>( IrpContext );
01632 
01633         <span class="comment">//</span>
01634         <span class="comment">//  Make sure that the driver/drive is not screwing up underneath of us by</span>
01635         <span class="comment">//  feeding us garbage for the sector size.</span>
01636         <span class="comment">//</span>
01637 
01638         <span class="keywordflow">if</span> (DiskGeometry.BytesPerSector == 0 ||
01639             (DiskGeometry.BytesPerSector &amp; ~( 1 &lt;&lt; <a class="code" href="../../d3/d8/udfprocs_8h.html#a136">UdfHighBit</a>( DiskGeometry.BytesPerSector ))) != 0) {
01640 
01641             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, 0,
01642                          <span class="stringliteral">"UdfMountVolume, bad DiskGeometry (%08x) .BytesPerSector == %08x\n"</span>,
01643                          &amp;DiskGeometry,
01644                          DiskGeometry.BytesPerSector ));
01645 
01646             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( FALSE );
01647 
01648             <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( Status = STATUS_DRIVER_INTERNAL_ERROR );
01649         }
01650 
01651         <span class="comment">//</span>
01652         <span class="comment">//  Now go confirm that this volume may be a UDF image by looking for a</span>
01653         <span class="comment">//  valid ISO 13346 Volume Recognition Sequence.</span>
01654         <span class="comment">//</span>
01655 
01656         <span class="keywordflow">if</span> (!<a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a17">UdfRecognizeVolume</a>( IrpContext,
01657                                  DeviceObjectWeTalkTo,
01658                                  DiskGeometry.BytesPerSector,
01659                                  &amp;BridgeMedia )) {
01660 
01661             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg, <span class="stringliteral">"UdfMountVolume, recognition failed so not mounting\n"</span> ));
01662 
01663             <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( Status = STATUS_UNRECOGNIZED_VOLUME );
01664         }
01665 
01666         <span class="comment">//</span>
01667         <span class="comment">//  Create the DeviceObject for this mount attempt</span>
01668         <span class="comment">//</span>
01669 
01670         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d4/d6/iosubs_8c.html#a45">IoCreateDevice</a>( <a class="code" href="../../d0/d8/udfdata_8c.html#a2">UdfData</a>.<a class="code" href="../../d2/d3/struct__UDF__DATA.html#o2">DriverObject</a>,
01671                                  <span class="keyword">sizeof</span>( <a class="code" href="../../d6/d7/struct__VOLUME__DEVICE__OBJECT.html">VOLUME_DEVICE_OBJECT</a> ) - <span class="keyword">sizeof</span>( <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">DEVICE_OBJECT</a> ),
01672                                  NULL,
01673                                  FILE_DEVICE_CD_ROM_FILE_SYSTEM,
01674                                  0,
01675                                  FALSE,
01676                                  (<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> *) &amp;VolDo );
01677 
01678         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
01679 
01680             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg, <span class="stringliteral">"UdfMountVolume, couldn't get voldo! (%08x)\n"</span>, Status ));
01681             <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( Status );
01682         }
01683 
01684         <span class="comment">//</span>
01685         <span class="comment">//  Our alignment requirement is the larger of the processor alignment requirement</span>
01686         <span class="comment">//  already in the volume device object and that in the DeviceObjectWeTalkTo</span>
01687         <span class="comment">//</span>
01688 
01689         <span class="keywordflow">if</span> (DeviceObjectWeTalkTo-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o17">AlignmentRequirement</a> &gt; VolDo-&gt;<a class="code" href="../../d6/d7/struct__VOLUME__DEVICE__OBJECT.html#o0">DeviceObject</a>.<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o17">AlignmentRequirement</a>) {
01690 
01691             VolDo-&gt;<a class="code" href="../../d6/d7/struct__VOLUME__DEVICE__OBJECT.html#o0">DeviceObject</a>.<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o17">AlignmentRequirement</a> = DeviceObjectWeTalkTo-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o17">AlignmentRequirement</a>;
01692         }
01693 
01694         <a class="code" href="../../d5/d5/cc_8h.html#a61">ClearFlag</a>( VolDo-&gt;<a class="code" href="../../d6/d7/struct__VOLUME__DEVICE__OBJECT.html#o0">DeviceObject</a>.<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o8">Flags</a>, DO_DEVICE_INITIALIZING );
01695 
01696         <span class="comment">//</span>
01697         <span class="comment">//  Initialize the overflow queue for the volume</span>
01698         <span class="comment">//</span>
01699 
01700         VolDo-&gt;<a class="code" href="../../d6/d7/struct__VOLUME__DEVICE__OBJECT.html#o2">OverflowQueueCount</a> = 0;
01701         InitializeListHead( &amp;VolDo-&gt;<a class="code" href="../../d6/d7/struct__VOLUME__DEVICE__OBJECT.html#o3">OverflowQueue</a> );
01702 
01703         VolDo-&gt;<a class="code" href="../../d6/d7/struct__VOLUME__DEVICE__OBJECT.html#o1">PostedRequestCount</a> = 0;
01704         <a class="code" href="../../d4/d9/ke_8h.html#a354">KeInitializeSpinLock</a>( &amp;VolDo-&gt;<a class="code" href="../../d6/d7/struct__VOLUME__DEVICE__OBJECT.html#o4">OverflowQueueSpinLock</a> );
01705 
01706         <span class="comment">//</span>
01707         <span class="comment">//  Now before we can initialize the Vcb we need to set up the</span>
01708         <span class="comment">//  device object field in the VPB to point to our new volume device</span>
01709         <span class="comment">//  object.</span>
01710         <span class="comment">//</span>
01711 
01712         Vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o4">DeviceObject</a> = (<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>) VolDo;
01713 
01714         <span class="comment">//</span>
01715         <span class="comment">//  Initialize the Vcb.  This routine will raise on an allocation</span>
01716         <span class="comment">//  failure.</span>
01717         <span class="comment">//</span>
01718 
01719         <a class="code" href="../../d3/d8/udfprocs_8h.html#a203">UdfInitializeVcb</a>( IrpContext,
01720                           &amp;VolDo-&gt;<a class="code" href="../../d6/d7/struct__VOLUME__DEVICE__OBJECT.html#o5">Vcb</a>,
01721                           DeviceObjectWeTalkTo,
01722                           Vpb,
01723                           &amp;DiskGeometry,
01724                           MediaChangeCount );
01725 
01726         <span class="comment">//</span>
01727         <span class="comment">//  We must initialize the stack size in our device object before</span>
01728         <span class="comment">//  the following reads, because the I/O system has not done it yet.</span>
01729         <span class="comment">//</span>
01730 
01731         ((<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>) VolDo)-&gt;StackSize = (CCHAR) (DeviceObjectWeTalkTo-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o13">StackSize</a> + 1);
01732 
01733         <span class="comment">//</span>
01734         <span class="comment">//  Pick up a local pointer to the new Vcb.  Here is where we start</span>
01735         <span class="comment">//  thinking about cleanup of structures if the mount is failed.</span>
01736         <span class="comment">//</span>
01737 
01738         Vcb = &amp;VolDo-&gt;<a class="code" href="../../d6/d7/struct__VOLUME__DEVICE__OBJECT.html#o5">Vcb</a>;
01739         Vpb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01740         VolDo = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01741 
01742         <span class="comment">//</span>
01743         <span class="comment">//  Store the Vcb in the IrpContext as we didn't have one before.</span>
01744         <span class="comment">//</span>
01745 
01746         IrpContext-&gt;Vcb = Vcb;
01747 
01748         <a class="code" href="../../d3/d8/udfprocs_8h.html#a74">UdfAcquireVcbExclusive</a>( IrpContext, Vcb, FALSE );
01749 
01750         <span class="comment">//</span>
01751         <span class="comment">//  Let's reference the Vpb to make sure we are the one to</span>
01752         <span class="comment">//  have the last dereference.</span>
01753         <span class="comment">//</span>
01754 
01755         Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o2">Vpb</a>-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o7">ReferenceCount</a> += 1;
01756 
01757         <span class="comment">//</span>
01758         <span class="comment">//  Clear the verify bit for the start of mount.</span>
01759         <span class="comment">//</span>
01760 
01761         <a class="code" href="../../d5/d5/cc_8h.html#a61">ClearFlag</a>( Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o2">Vpb</a>-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o5">RealDevice</a>-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o8">Flags</a>, DO_VERIFY_VOLUME );
01762 
01763         <span class="comment">//</span>
01764         <span class="comment">//  Now find the multi-session bounds on this media.</span>
01765         <span class="comment">//</span>
01766 
01767         <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a4">UdfDetermineVolumeBounding</a>( IrpContext,
01768                                     Vcb,
01769                                     &amp;Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o13">BoundS</a>,
01770                                     &amp;Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o14">BoundN</a> );
01771 
01772         <span class="comment">//</span>
01773         <span class="comment">//  Now find the Anchor Volume Descriptor so we can discover the Volume Set</span>
01774         <span class="comment">//  Descriptor Sequence extent.</span>
01775         <span class="comment">//</span>
01776 
01777         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a6">UdfFindAnchorVolumeDescriptor</a>( IrpContext,
01778                                                 Vcb,
01779                                                 &amp;AnchorVolumeDescriptor );
01780 
01781         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(Status)) {
01782 
01783             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg, <span class="stringliteral">"UdfMountVolume, couldn't find anchor descriptors\n"</span> ));
01784             <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( Status );
01785         }
01786 
01787         <span class="comment">//</span>
01788         <span class="comment">//  Now search for the prevailing copies of the PVD, LVD, and related PD in the</span>
01789         <span class="comment">//  extents indicated by the AVD.</span>
01790         <span class="comment">//</span>
01791 
01792         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a8">UdfFindVolumeDescriptors</a>( IrpContext,
01793                                            Vcb,
01794                                            &amp;AnchorVolumeDescriptor-&gt;<a class="code" href="../../d7/d1/structNSR__ANCHOR.html#o1">Main</a>,
01795                                            &amp;Pcb,
01796                                            &amp;PrimaryVolumeDescriptor,
01797                                            &amp;LogicalVolumeDescriptor );
01798 
01799         <span class="comment">//</span>
01800         <span class="comment">//  If we discovered invalid structures on the main extent, we may still</span>
01801         <span class="comment">//  be able to use the reserve extent.  By definition the two extents</span>
01802         <span class="comment">//  must be logically equal, so just plow into it on any error.</span>
01803         <span class="comment">//</span>
01804 
01805         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
01806 
01807             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a8">UdfFindVolumeDescriptors</a>( IrpContext,
01808                                                Vcb,
01809                                                &amp;AnchorVolumeDescriptor-&gt;<a class="code" href="../../d7/d1/structNSR__ANCHOR.html#o2">Reserve</a>,
01810                                                &amp;Pcb,
01811                                                &amp;PrimaryVolumeDescriptor,
01812                                                &amp;LogicalVolumeDescriptor );
01813         }
01814 
01815         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(Status)) {
01816 
01817             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg, <span class="stringliteral">"UdfMountVolume, couldn't find good VSD descriptors (PVD/LVD/PD)\n"</span> ));
01818             <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( Status );
01819         }
01820 
01821         <span class="comment">//</span>
01822         <span class="comment">//  Now go complete initialization of the Pcb.  After this point, we can perform</span>
01823         <span class="comment">//  physical partition mappings and know that the partition table is good.</span>
01824         <span class="comment">//</span>
01825 
01826         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d3/d8/udfprocs_8h.html#a150">UdfCompletePcb</a>( IrpContext,
01827                                  Vcb,
01828                                  Pcb );
01829 
01830         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(Status)) {
01831 
01832             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg, <span class="stringliteral">"UdfMountVolume, Pcb completion failed\n"</span> ));
01833             <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( Status );
01834         }
01835 
01836         Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o3">Pcb</a> = Pcb;
01837         Pcb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01838 
01839         <span class="comment">//</span>
01840         <span class="comment">//  Set up all the support we need to do reads into the volume.</span>
01841         <span class="comment">//</span>
01842 
01843         <a class="code" href="../../d3/d8/udfprocs_8h.html#a204">UdfUpdateVcbPhase0</a>( IrpContext, Vcb );
01844 
01845         <span class="comment">//</span>
01846         <span class="comment">//  Now go get the fileset descriptor that will finally reveal the location</span>
01847         <span class="comment">//  of the root directory on this volume.</span>
01848         <span class="comment">//</span>
01849 
01850         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a7">UdfFindFileSetDescriptor</a>( IrpContext,
01851                                            Vcb,
01852                                            &amp;LogicalVolumeDescriptor-&gt;<a class="code" href="../../d6/d2/structNSR__LVOL.html#o6">FSD</a>,
01853                                            &amp;FileSetDescriptor );
01854 
01855         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(Status)) {
01856 
01857             <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( NOTHING );
01858         }
01859 
01860         <span class="comment">//</span>
01861         <span class="comment">//  Now that we have everything together, update the Vpb with identification</span>
01862         <span class="comment">//  of this volume.</span>
01863         <span class="comment">//</span>
01864 
01865         <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a20">UdfUpdateVolumeLabel</a>( IrpContext,
01866                               Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o2">Vpb</a>-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o8">VolumeLabel</a>,
01867                               &amp;Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o2">Vpb</a>-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o3">VolumeLabelLength</a>,
01868                               LogicalVolumeDescriptor-&gt;<a class="code" href="../../d6/d2/structNSR__LVOL.html#o3">VolumeID</a>,
01869                               <span class="keyword">sizeof</span>( LogicalVolumeDescriptor-&gt;<a class="code" href="../../d6/d2/structNSR__LVOL.html#o3">VolumeID</a> ));
01870 
01871         <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a21">UdfUpdateVolumeSerialNumber</a>( IrpContext,
01872                                      &amp;Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o2">Vpb</a>-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o6">SerialNumber</a>,
01873                                      FileSetDescriptor );
01874 
01875         <span class="comment">//</span>
01876         <span class="comment">//  Check if this is a remount operation.  If so then clean up</span>
01877         <span class="comment">//  the data structures passed in and created here.</span>
01878         <span class="comment">//</span>
01879 
01880         <span class="keywordflow">if</span> (<a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a11">UdfIsRemount</a>( IrpContext, Vcb, &amp;OldVcb )) {
01881 
01882             <span class="comment">//</span>
01883             <span class="comment">//  Link the old Vcb to point to the new device object that we</span>
01884             <span class="comment">//  should be talking to, dereferencing the previous.</span>
01885             <span class="comment">//</span>
01886 
01887             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( OldVcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o4">TargetDeviceObject</a> );
01888 
01889             Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o2">Vpb</a>-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o5">RealDevice</a>-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o10">Vpb</a> = OldVcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o2">Vpb</a>;
01890 
01891             OldVcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o2">Vpb</a>-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o5">RealDevice</a> = Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o2">Vpb</a>-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o5">RealDevice</a>;
01892 
01893             OldVcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o4">TargetDeviceObject</a> = DeviceObjectWeTalkTo;
01894             OldVcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o8">VcbCondition</a> = <a class="code" href="../../d6/d8/udfstruc_8h.html#a130a119">VcbMounted</a>;
01895 
01896             OldVcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o10">MediaChangeCount</a> = Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o10">MediaChangeCount</a>;
01897 
01898             <span class="comment">//</span>
01899             <span class="comment">//  Push the state of the method 2 bit across.  In changing the device,</span>
01900             <span class="comment">//  we may now be on one with a different requirement.</span>
01901             <span class="comment">//</span>
01902 
01903             <a class="code" href="../../d5/d5/cc_8h.html#a61">ClearFlag</a>( OldVcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o7">VcbState</a>, VCB_STATE_METHOD_2_FIXUP );
01904             <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>( OldVcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o7">VcbState</a>, <a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o7">VcbState</a>, VCB_STATE_METHOD_2_FIXUP ));
01905             
01906             <span class="comment">//</span>
01907             <span class="comment">//  See if we will need to provide notification of the remount.  This is the readonly</span>
01908             <span class="comment">//  filesystem's form of dismount/mount notification - we promise that whenever a</span>
01909             <span class="comment">//  volume is "dismounted", that a mount notification will occur when it is revalidated.</span>
01910             <span class="comment">//  Note that we do not send mount on normal remounts - that would duplicate the media</span>
01911             <span class="comment">//  arrival notification of the device driver.</span>
01912             <span class="comment">//</span>
01913     
01914             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( OldVcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o7">VcbState</a>, VCB_STATE_NOTIFY_REMOUNT )) {
01915     
01916                 <a class="code" href="../../d5/d5/cc_8h.html#a61">ClearFlag</a>( OldVcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o7">VcbState</a>, VCB_STATE_NOTIFY_REMOUNT );
01917                 
01918                 FileObjectToNotify = OldVcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o21">RootIndexFcb</a>-&gt;FileObject;
01919                 <a class="code" href="../../d4/d0/ob_8h.html#a15">ObReferenceObject</a>( FileObjectToNotify );
01920             }
01921             
01922             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg, <span class="stringliteral">"UdfMountVolume, remounted old Vcb %08x\n"</span>, OldVcb ));
01923 
01924             <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( Status = STATUS_SUCCESS );
01925         }
01926 
01927         <span class="comment">//</span>
01928         <span class="comment">//  Initialize the Vcb and associated structures from our volume descriptors</span>
01929         <span class="comment">//</span>
01930 
01931         <a class="code" href="../../d3/d8/udfprocs_8h.html#a205">UdfUpdateVcbPhase1</a>( IrpContext,
01932                             Vcb,
01933                             FileSetDescriptor );
01934 
01935         <span class="comment">//</span>
01936         <span class="comment">//  Drop an extra reference on the root dir file so we'll be able to send</span>
01937         <span class="comment">//  notification.</span>
01938         <span class="comment">//</span>
01939 
01940         <span class="keywordflow">if</span> (Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o21">RootIndexFcb</a>) {
01941 
01942             FileObjectToNotify = Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o21">RootIndexFcb</a>-&gt;FileObject;
01943             <a class="code" href="../../d4/d0/ob_8h.html#a15">ObReferenceObject</a>( FileObjectToNotify );
01944         }
01945 
01946         <span class="comment">//</span>
01947         <span class="comment">//  The new mount is complete.  Remove the additional references on this</span>
01948         <span class="comment">//  Vcb since, at this point, we have added the real references this volume</span>
01949         <span class="comment">//  will have during its lifetime.  We also need to drop the additional</span>
01950         <span class="comment">//  reference on the device we mounted.</span>
01951         <span class="comment">//</span>
01952 
01953         Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o16">VcbReference</a> -= Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o18">VcbResidualReference</a>;
01954         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o16">VcbReference</a> == Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o18">VcbResidualReference</a> );
01955 
01956         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o4">TargetDeviceObject</a> );
01957 
01958         Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o8">VcbCondition</a> = <a class="code" href="../../d6/d8/udfstruc_8h.html#a130a119">VcbMounted</a>;
01959 
01960         <a class="code" href="../../d3/d8/udfprocs_8h.html#a76">UdfReleaseVcb</a>( IrpContext, Vcb );
01961         Vcb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01962 
01963         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
01964 
01965     } finally {
01966 
01967         <a class="code" href="../../d8/d3/lfsdata_8h.html#a3">DebugUnwind</a>( <span class="stringliteral">"UdfMountVolume"</span> );
01968 
01969         <span class="comment">//</span>
01970         <span class="comment">//  If we didn't complete the mount then cleanup any remaining structures.</span>
01971         <span class="comment">//</span>
01972 
01973         <span class="keywordflow">if</span> (Vpb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) { Vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o4">DeviceObject</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>; }
01974 
01975         <span class="keywordflow">if</span> (Pcb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01976 
01977             <a class="code" href="../../d3/d8/udfprocs_8h.html#a147">UdfDeletePcb</a>( Pcb );
01978         }
01979 
01980         <span class="keywordflow">if</span> (Vcb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01981 
01982             <span class="comment">//</span>
01983             <span class="comment">//  Make sure there is no Vcb in the IrpContext since it could go away</span>
01984             <span class="comment">//</span>
01985 
01986             IrpContext-&gt;Vcb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01987 
01988             Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o16">VcbReference</a> -= Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o18">VcbResidualReference</a>;
01989 
01990             <span class="keywordflow">if</span> (<a class="code" href="../../d8/d5/udfs_2verfysup_8c.html#a4">UdfDismountVcb</a>( IrpContext, Vcb )) {
01991 
01992                 <a class="code" href="../../d3/d8/udfprocs_8h.html#a76">UdfReleaseVcb</a>( IrpContext, Vcb );
01993             }
01994 
01995         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (VolDo != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01996 
01997             <a class="code" href="../../d4/d6/iosubs_8c.html#a55">IoDeleteDevice</a>( (<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>)VolDo );
01998             Vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o4">DeviceObject</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01999         }
02000 
02001         <span class="comment">//</span>
02002         <span class="comment">//  Release the global resource.</span>
02003         <span class="comment">//</span>
02004 
02005         <a class="code" href="../../d3/d8/udfprocs_8h.html#a73">UdfReleaseUdfData</a>( IrpContext );
02006 
02007         <span class="comment">//</span>
02008         <span class="comment">//  Free any structures we may have been allocated</span>
02009         <span class="comment">//</span>
02010 
02011         <a class="code" href="../../d3/d8/udfprocs_8h.html#a124">UdfFreePool</a>( &amp;AnchorVolumeDescriptor );
02012         <a class="code" href="../../d3/d8/udfprocs_8h.html#a124">UdfFreePool</a>( &amp;PrimaryVolumeDescriptor );
02013         <a class="code" href="../../d3/d8/udfprocs_8h.html#a124">UdfFreePool</a>( &amp;LogicalVolumeDescriptor );
02014         <a class="code" href="../../d3/d8/udfprocs_8h.html#a124">UdfFreePool</a>( &amp;FileSetDescriptor );
02015     }
02016 
02017     <span class="comment">//</span>
02018     <span class="comment">//  Now send mount notification.</span>
02019     <span class="comment">//</span>
02020     
02021     <span class="keywordflow">if</span> (FileObjectToNotify) {
02022 
02023         <a class="code" href="../../d1/d8/fsrtl_8h.html#a168">FsRtlNotifyVolumeEvent</a>( FileObjectToNotify, FSRTL_VOLUME_MOUNT );
02024         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( FileObjectToNotify );
02025     }
02026 
02027     <span class="comment">//</span>
02028     <span class="comment">//  Complete the request if no exception.</span>
02029     <span class="comment">//</span>
02030 
02031     <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, Irp, Status );
02032     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, Dbg, <span class="stringliteral">"UdfMountVolume -&gt; %08x\n"</span>, Status ));
02033 
02034     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
02035 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a16" doxytag="udfs/fsctrl.c::UdfOplockRequest" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS UdfOplockRequest           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>IrpContext</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d0/d2/struct__IRP.html">PIRP</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>Irp</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l00470">470</a> of file <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html">udfs/fsctrl.c</a>.
<p>
References <a class="el" href="../../d6/d4/cc_8h-source.html#l00509">ClearFlag</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d7/d7/udfstruc_8h-source.html#l00978">_FCB::FcbCleanup</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02494">_IO_STACK_LOCATION::FileObject</a>, <a class="el" href="../../d2/d7/fsrtl_8h-source.html#l00807">FsRtlAreThereCurrentFileLocks</a>, <a class="el" href="../../d6/d1/oplock_8c-source.html#l00581">FsRtlOplockFsctrl()</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l03252">IoGetCurrentIrpStackLocation</a>, <a class="el" href="../../d1/d5/iop_8h-source.html#l00130">Irp</a>, <a class="el" href="../../d7/d7/udfstruc_8h-source.html#l01236">IRP_CONTEXT_FLAG_FORCE_POST</a>, <a class="el" href="../../d7/d7/udfstruc_8h-source.html#l01235">IRP_CONTEXT_FLAG_WAIT</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02069">_IO_STACK_LOCATION::Parameters</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00505">SetFlag</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l01542">UdfAcquireFcbExclusive</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l01545">UdfAcquireFcbShared</a>, <a class="el" href="../../d1/d7/udfdata_8c-source.html#l00809">UdfCompleteRequest()</a>, <a class="el" href="../../d7/d2/filobsup_8c-source.html#l00133">UdfDecodeFileObject()</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l00385">UdfIsFastIoPossible</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l01567">UdfLockFcb</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l01548">UdfReleaseFcb</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l01577">UdfUnlockFcb</a>, <a class="el" href="../../d9/d4/udfs_2verfysup_8c-source.html#l00760">UdfVerifyFcbOperation()</a>, and <a class="el" href="../../d3/d8/udfprocs_8h.html#a263a117">UserFileOpen</a>.
<p>
Referenced by <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l00363">UdfUserFsctl()</a>.
<p>
<pre class="fragment"><div>00477                    :
00478 
00479     This <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> common routine to handle oplock requests <a class="code" href="../../d3/d0/user32_8def.html#a107">made</a> via <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
00480     <a class="code" href="../../d8/d7/io_2fsctrl_8c.html#a0">NtFsControlFile</a> call.
00481 
00482 Arguments:
00483 
00484     <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> being processed
00485 
00486 Return Value:
00487 
00488     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> - The <span class="keywordflow">return</span> status <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> operation
00489 
00490 --*/
00491 
00492 {
00493     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00494     <a class="code" href="../../d7/d9/struct__FCB.html">PFCB</a> Fcb;
00495     <a class="code" href="../../d2/d9/struct__CCB.html">PCCB</a> Ccb;
00496 
00497     ULONG OplockCount = 0;
00498     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> IrpSp = <a class="code" href="../../d0/d5/io_8h.html#a228">IoGetCurrentIrpStackLocation</a>( Irp );
00499 
00500     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00501 
00502     <span class="comment">//</span>
00503     <span class="comment">//  We only permit oplock requests on files.</span>
00504     <span class="comment">//</span>
00505 
00506     <span class="keywordflow">if</span> (<a class="code" href="../../d3/d8/udfprocs_8h.html#a174">UdfDecodeFileObject</a>( IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a>,
00507                              &amp;Fcb,
00508                              &amp;Ccb ) != <a class="code" href="../../d3/d8/udfprocs_8h.html#a263a117">UserFileOpen</a> ) {
00509 
00510         <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, Irp, STATUS_INVALID_PARAMETER );
00511         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
00512     }
00513 
00514     <span class="comment">//</span>
00515     <span class="comment">//  Make this a waitable Irpcontext so we don't fail to acquire</span>
00516     <span class="comment">//  the resources.</span>
00517     <span class="comment">//</span>
00518 
00519     <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>( IrpContext-&gt;Flags, IRP_CONTEXT_FLAG_WAIT );
00520     <a class="code" href="../../d5/d5/cc_8h.html#a61">ClearFlag</a>( IrpContext-&gt;Flags, IRP_CONTEXT_FLAG_FORCE_POST );
00521 
00522     <span class="comment">//</span>
00523     <span class="comment">//  Switch on the function control code.  We grab the Fcb exclusively</span>
00524     <span class="comment">//  for oplock requests, shared for oplock break acknowledgement.</span>
00525     <span class="comment">//</span>
00526 
00527     <span class="keywordflow">switch</span> (IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.FileSystemControl.FsControlCode) {
00528 
00529     <span class="keywordflow">case</span> FSCTL_REQUEST_OPLOCK_LEVEL_1 :
00530     <span class="keywordflow">case</span> FSCTL_REQUEST_OPLOCK_LEVEL_2 :
00531     <span class="keywordflow">case</span> FSCTL_REQUEST_BATCH_OPLOCK :
00532     <span class="keywordflow">case</span> FSCTL_REQUEST_FILTER_OPLOCK :
00533 
00534         <a class="code" href="../../d3/d8/udfprocs_8h.html#a83">UdfAcquireFcbExclusive</a>( IrpContext, Fcb, FALSE );
00535 
00536         <span class="keywordflow">if</span> (IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.FileSystemControl.FsControlCode == FSCTL_REQUEST_OPLOCK_LEVEL_2) {
00537 
00538             <span class="keywordflow">if</span> (Fcb-&gt;FileLock != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00539 
00540                 OplockCount = (ULONG) <a class="code" href="../../d1/d8/fsrtl_8h.html#a19">FsRtlAreThereCurrentFileLocks</a>( Fcb-&gt;FileLock );
00541             }
00542 
00543         } <span class="keywordflow">else</span> {
00544 
00545             OplockCount = Fcb-&gt;<a class="code" href="../../d7/d9/struct__FCB.html#o7">FcbCleanup</a>;
00546         }
00547 
00548         <span class="keywordflow">break</span>;
00549 
00550     <span class="keywordflow">case</span> FSCTL_OPLOCK_BREAK_ACKNOWLEDGE:
00551     <span class="keywordflow">case</span> FSCTL_OPBATCH_ACK_CLOSE_PENDING:
00552     <span class="keywordflow">case</span> FSCTL_OPLOCK_BREAK_NOTIFY:
00553     <span class="keywordflow">case</span> FSCTL_OPLOCK_BREAK_ACK_NO_2:
00554 
00555         <a class="code" href="../../d3/d8/udfprocs_8h.html#a84">UdfAcquireFcbShared</a>( IrpContext, Fcb, FALSE );
00556         <span class="keywordflow">break</span>;
00557 
00558     <span class="keywordflow">default</span>:
00559 
00560         <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, Irp, STATUS_INVALID_PARAMETER );
00561         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
00562     }
00563 
00564     <span class="comment">//</span>
00565     <span class="comment">//  Use a try finally to free the Fcb.</span>
00566     <span class="comment">//</span>
00567 
00568     <span class="keywordflow">try</span> {
00569 
00570         <span class="comment">//</span>
00571         <span class="comment">//  Verify the Fcb.</span>
00572         <span class="comment">//</span>
00573 
00574         <a class="code" href="../../d8/d5/udfs_2verfysup_8c.html#a6">UdfVerifyFcbOperation</a>( IrpContext, Fcb );
00575 
00576         <span class="comment">//</span>
00577         <span class="comment">//  Call the FsRtl routine to grant/acknowledge oplock.</span>
00578         <span class="comment">//</span>
00579 
00580         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d1/d8/fsrtl_8h.html#a164">FsRtlOplockFsctrl</a>( &amp;Fcb-&gt;Oplock,
00581                                     Irp,
00582                                     OplockCount );
00583 
00584         <span class="comment">//</span>
00585         <span class="comment">//  Set the flag indicating if Fast I/O is possible</span>
00586         <span class="comment">//</span>
00587 
00588         <a class="code" href="../../d3/d8/udfprocs_8h.html#a90">UdfLockFcb</a>( IrpContext, Fcb );
00589         Fcb-&gt;IsFastIoPossible = <a class="code" href="../../d3/d8/udfprocs_8h.html#a63">UdfIsFastIoPossible</a>( Fcb );
00590         <a class="code" href="../../d3/d8/udfprocs_8h.html#a91">UdfUnlockFcb</a>( IrpContext, Fcb );
00591 
00592         <span class="comment">//</span>
00593         <span class="comment">//  The oplock package will complete the Irp.</span>
00594         <span class="comment">//</span>
00595 
00596         <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00597 
00598     } finally {
00599 
00600         <span class="comment">//</span>
00601         <span class="comment">//  Release all of our resources</span>
00602         <span class="comment">//</span>
00603 
00604         <a class="code" href="../../d3/d8/udfprocs_8h.html#a85">UdfReleaseFcb</a>( IrpContext, Fcb );
00605     }
00606 
00607     <span class="comment">//</span>
00608     <span class="comment">//  Complete the request if there was no exception.</span>
00609     <span class="comment">//</span>
00610 
00611     <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, Irp, Status );
00612     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00613 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a17" doxytag="udfs/fsctrl.c::UdfRecognizeVolume" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> BOOLEAN UdfRecognizeVolume           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>IrpContext</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>DeviceObject</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>SectorSize</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN OUT PBOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>Bridge</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l03457">3457</a> of file <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html">udfs/fsctrl.c</a>.
<p>
References <a class="el" href="../../d2/d7/udfdata_8h-source.html#l00352">ASSERT_IRP_CONTEXT</a>, <a class="el" href="../../d0/d5/cdfs__rec_8c-source.html#l00032">Dbg</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02290">DebugTrace</a>, <a class="el" href="../../d9/d2/lfsdata_8h-source.html#l00187">DebugUnwind</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d2/d7/fsrtl_8h-source.html#l01101">FsRtlAllocatePoolWithTag</a>, <a class="el" href="../../d1/d6/iso13346_8h-source.html#l00200">VSD_GENERIC::Ident</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l00033">Offset</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>, <a class="el" href="../../d5/d8/udfs__rec_8h.html#a13">PVSD_GENERIC</a>, <a class="el" href="../../d6/d7/udfs__rec_8h-source.html#l00110">SectorAlignN</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l00230">SectorSize</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, <a class="el" href="../../d2/d6/udfs_2nodetype_8h-source.html#l00178">TAG_NSR_VSD</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, <a class="el" href="../../d1/d6/iso13346_8h-source.html#l00199">VSD_GENERIC::Type</a>, <a class="el" href="../../d0/d7/udfs_2strucsup_8c-source.html#l02552">UdfFindInParseTable()</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l00453">UdfFreePool()</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l02115">UdfIsRawDevice</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l00444">UdfNonPagedPool</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l00951">UdfRawBufferSizeN()</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l00961">UdfRawReadSizeN()</a>, <a class="el" href="../../d4/d6/deviosup_8c-source.html#l00685">UdfReadSectors()</a>, <a class="el" href="../../d1/d6/iso13346_8h-source.html#l00201">VSD_GENERIC::Version</a>, <a class="el" href="../../d6/d7/udfs__rec_8h-source.html#l00036">VRA_BOUNDARY_LOCATION</a>, <a class="el" href="../../d5/d8/udfs__rec_8h.html#a12">VSD_GENERIC</a>, <a class="el" href="../../d6/d7/udfs__rec_8h-source.html#l00057">VSD_LENGTH_IDENT</a>, <a class="el" href="../../d5/d8/udfs__rec_8h.html#a30a19">VsdIdentBEA01</a>, <a class="el" href="../../d5/d8/udfs__rec_8h.html#a30a27">VsdIdentBOOT2</a>, <a class="el" href="../../d5/d8/udfs__rec_8h.html#a30a22">VsdIdentCD001</a>, <a class="el" href="../../d5/d8/udfs__rec_8h.html#a30a21">VsdIdentCDROM</a>, <a class="el" href="../../d5/d8/udfs__rec_8h.html#a30a23">VsdIdentCDW01</a>, <a class="el" href="../../d5/d8/udfs__rec_8h.html#a30a24">VsdIdentCDW02</a>, <a class="el" href="../../d5/d8/udfs__rec_8h.html#a30a25">VsdIdentNSR01</a>, <a class="el" href="../../d5/d8/udfs__rec_8h.html#a30a26">VsdIdentNSR02</a>, <a class="el" href="../../d5/d7/udfs__rec_8c-source.html#l00039">VsdIdentParseTable</a>, and <a class="el" href="../../d5/d8/udfs__rec_8h.html#a30a20">VsdIdentTEA01</a>.
<p>
Referenced by <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l01444">UdfMountVolume()</a>.
<p>
<pre class="fragment"><div>03466                    :
03467 
03468     This routine walks <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Volume Recognition Sequence to determine
03469     whether <span class="keyword">this</span> volume contains an NSR02 (ISO 13346 Section 4) image.
03470 
03471 Arguments:
03472 
03473     DeviceObject - device we are checking
03474 
03475     <a class="code" href="../../d3/d8/udfprocs_8h.html#a42">SectorSize</a> - size of a physical sector on <span class="keyword">this</span> device
03476 
03477     Bridge - will <span class="keywordflow">return</span> whether there appear to be ISO 9660 structures
03478         on <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> media
03479 
03480 Return Value:
03481 
03482     <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a21">Boolean</a> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> <span class="keywordflow">if</span> we found NSR02, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> otherwise.
03483 
03484 --*/
03485 
03486 {
03487     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
03488 
03489     BOOLEAN FoundBEA = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03490     BOOLEAN FoundNSR = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03491     BOOLEAN Resolved = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03492 
03493     <a class="code" href="../../d4/d2/structVSD__GENERIC.html">PVSD_GENERIC</a> VolumeStructureDescriptor;
03494     ULONGLONG <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> = <a class="code" href="../../d5/d8/udfs__rec_8h.html#a11">SectorAlignN</a>( SectorSize, VRA_BOUNDARY_LOCATION );
03495 
03496     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
03497 
03498     <span class="comment">//</span>
03499     <span class="comment">//  Check the input parameters</span>
03500     <span class="comment">//</span>
03501 
03502     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext);
03503 
03504     VolumeStructureDescriptor = (<a class="code" href="../../d4/d2/structVSD__GENERIC.html">PVSD_GENERIC</a>) <a class="code" href="../../d1/d8/fsrtl_8h.html#a37">FsRtlAllocatePoolWithTag</a>( UdfNonPagedPool,
03505                                                                          <a class="code" href="../../d3/d8/udfprocs_8h.html#a165">UdfRawBufferSizeN</a>( SectorSize,
03506                                                                                             <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d2/structVSD__GENERIC.html">VSD_GENERIC</a>) ),
03507                                                                          TAG_NSR_VSD );
03508 
03509     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( +1, Dbg,
03510                  <span class="stringliteral">"UdfRecognizeVolume, DevObj %08x SectorSize %08x\n"</span>,
03511                  DeviceObject,
03512                  SectorSize ));
03513 
03514     <span class="comment">//</span>
03515     <span class="comment">//  Use try-finally to facilitate cleanup</span>
03516     <span class="comment">//</span>
03517 
03518     <span class="keywordflow">try</span> {
03519 
03520 <span class="preprocessor">#ifdef UDF_SUPPORT_NONSTANDARD_ADAPTEC</span>
03521 <span class="preprocessor"></span>
03522         <span class="comment">//</span>
03523         <span class="comment">//  Disable checking the recognition area.</span>
03524         <span class="comment">//</span>
03525         <span class="comment">//  Reasons:</span>
03526         <span class="comment">//</span>
03527         <span class="comment">//      ADAPTEC - early CDUDF did not bound NSR02 with BEA/TEA, instead</span>
03528         <span class="comment">//              sticking it in the middle of the ISO 9660 sequence.</span>
03529         <span class="comment">//</span>
03530 
03531         Resolved = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03532 <span class="preprocessor">#endif</span>
03533 <span class="preprocessor"></span>
03534         <span class="keywordflow">while</span> (!Resolved) {
03535 
03536             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d3/d8/udfprocs_8h.html#a160">UdfReadSectors</a>( IrpContext,
03537                                      Offset,
03538                                      <a class="code" href="../../d3/d8/udfprocs_8h.html#a166">UdfRawReadSizeN</a>( SectorSize,
03539                                                       <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d2/structVSD__GENERIC.html">VSD_GENERIC</a>) ),
03540                                      FALSE,
03541                                      VolumeStructureDescriptor,
03542                                      DeviceObject );
03543 
03544             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
03545                 <span class="keywordflow">break</span>;
03546             }
03547             
03548             <span class="comment">//</span>
03549             <span class="comment">//  Now check the type of the descriptor. All ISO 13346 VSDs are</span>
03550             <span class="comment">//  of Type 0, 9660 PVDs are Type 1, 9660 SVDs are Type 2, and 9660</span>
03551             <span class="comment">//  terminating descriptors are Type 255.</span>
03552             <span class="comment">//</span>
03553 
03554             <span class="keywordflow">if</span> (VolumeStructureDescriptor-&gt;<a class="code" href="../../d4/d2/structVSD__GENERIC.html#o0">Type</a> == 0) {
03555 
03556                 <span class="comment">//</span>
03557                 <span class="comment">//  In order to properly recognize the volume, we must know all of the</span>
03558                 <span class="comment">//  Structure identifiers in ISO 13346 so that we can terminate if a</span>
03559                 <span class="comment">//  badly formatted (or, shockingly, non 13346) volume is presented to us.</span>
03560                 <span class="comment">//</span>
03561 
03562                 <span class="keywordflow">switch</span> (<a class="code" href="../../d3/d8/udfprocs_8h.html#a218">UdfFindInParseTable</a>( VsdIdentParseTable,
03563                                              VolumeStructureDescriptor-&gt;<a class="code" href="../../d4/d2/structVSD__GENERIC.html#o1">Ident</a>,
03564                                              VSD_LENGTH_IDENT )) {
03565                     <span class="keywordflow">case</span> <a class="code" href="../../d5/d8/udfs__rec_8h.html#a30a19">VsdIdentBEA01</a>:
03566 
03567                         <span class="comment">//</span>
03568                         <span class="comment">//  Only one BEA may exist and its version must be 1 (2/9.2.3)</span>
03569                         <span class="comment">//</span>
03570 
03571                         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg, <span class="stringliteral">"UdfRecognizeVolume, got a BEA01\n"</span> ));
03572 
03573 
03574                         <span class="keywordflow">if</span> ((FoundBEA &amp;&amp;
03575                              <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg,
03576                                           <span class="stringliteral">"UdfRecognizeVolume, ... but it is a duplicate!\n"</span> ))) ||
03577 
03578                             (VolumeStructureDescriptor-&gt;<a class="code" href="../../d4/d2/structVSD__GENERIC.html#o2">Version</a> != 1 &amp;&amp;
03579                              <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg,
03580                                           <span class="stringliteral">"UdfRecognizeVolume, ... but it has a wacky version number %02x != 1!\n"</span>,
03581                                           VolumeStructureDescriptor-&gt;<a class="code" href="../../d4/d2/structVSD__GENERIC.html#o2">Version</a> )))) {
03582 
03583                             Resolved = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03584                             <span class="keywordflow">break</span>;
03585                         }
03586 
03587                         FoundBEA = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03588                         <span class="keywordflow">break</span>;
03589 
03590                     <span class="keywordflow">case</span> <a class="code" href="../../d5/d8/udfs__rec_8h.html#a30a20">VsdIdentTEA01</a>:
03591 
03592                         <span class="comment">//</span>
03593                         <span class="comment">//  If we reach the TEA it must be the case that we don't recognize</span>
03594                         <span class="comment">//</span>
03595 
03596                         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg, <span class="stringliteral">"UdfRecognizeVolume, got a TEA01\n"</span> ));
03597                         Resolved = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03598                         <span class="keywordflow">break</span>;
03599 
03600                     <span class="keywordflow">case</span> <a class="code" href="../../d5/d8/udfs__rec_8h.html#a30a26">VsdIdentNSR02</a>:
03601 
03602                         <span class="comment">//</span>
03603                         <span class="comment">//  We recognize NSR02 version 1 embedded after a BEA (3/9.1.3).  For</span>
03604                         <span class="comment">//  simplicity we will not bother being a complete nitpick and check</span>
03605                         <span class="comment">//  for a bounding TEA, although we will be optimistic in the case where</span>
03606                         <span class="comment">//  we fail to match the version.</span>
03607                         <span class="comment">//</span>
03608 
03609                         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg, <span class="stringliteral">"UdfRecognizeVolume, got an NSR02\n"</span> ));
03610 
03611                         <span class="keywordflow">if</span> ((FoundBEA ||
03612                              !<a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg, <span class="stringliteral">"UdfRecognizeVolume, ... but we haven't seen a BEA01 yet!\n"</span> ))) &amp;&amp;
03613 
03614                             (VolumeStructureDescriptor-&gt;<a class="code" href="../../d4/d2/structVSD__GENERIC.html#o2">Version</a> == 1 ||
03615                              !<a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg, <span class="stringliteral">"UdfRecognizeVolume, ... but it has a wacky version number %02x != 1\n"</span>,
03616                                            VolumeStructureDescriptor-&gt;<a class="code" href="../../d4/d2/structVSD__GENERIC.html#o2">Version</a> )))) {
03617 
03618                             
03619                             FoundNSR = Resolved = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03620                             <span class="keywordflow">break</span>;
03621                         }
03622 
03623                         <span class="keywordflow">break</span>;
03624 
03625                     <span class="keywordflow">case</span> <a class="code" href="../../d5/d8/udfs__rec_8h.html#a30a22">VsdIdentCD001</a>:
03626                     <span class="keywordflow">case</span> <a class="code" href="../../d5/d8/udfs__rec_8h.html#a30a23">VsdIdentCDW01</a>:
03627                     <span class="keywordflow">case</span> <a class="code" href="../../d5/d8/udfs__rec_8h.html#a30a25">VsdIdentNSR01</a>:
03628                     <span class="keywordflow">case</span> <a class="code" href="../../d5/d8/udfs__rec_8h.html#a30a24">VsdIdentCDW02</a>:
03629                     <span class="keywordflow">case</span> <a class="code" href="../../d5/d8/udfs__rec_8h.html#a30a27">VsdIdentBOOT2</a>:
03630 
03631                         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg, <span class="stringliteral">"UdfRecognizeVolume, got a valid but uninteresting 13346 descriptor\n"</span> ));
03632 
03633                         <span class="comment">//</span>
03634                         <span class="comment">//  Valid but uninteresting (to us) descriptors</span>
03635                         <span class="comment">//</span>
03636 
03637                         <span class="keywordflow">break</span>;
03638 
03639                     <span class="keywordflow">default</span>:
03640 
03641                         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg, <span class="stringliteral">"UdfRecognizeVolume, got an invalid 13346 descriptor\n"</span> ));
03642 
03643                         <span class="comment">//</span>
03644                         <span class="comment">//  Stumbling across something we don't know, it must be that this</span>
03645                         <span class="comment">//  is not a valid 13346 image</span>
03646                         <span class="comment">//</span>
03647 
03648                         Resolved = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03649                         <span class="keywordflow">break</span>;
03650 
03651                 }
03652 
03653             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!FoundBEA &amp;&amp; (VolumeStructureDescriptor-&gt;<a class="code" href="../../d4/d2/structVSD__GENERIC.html#o0">Type</a> &lt; 3 ||
03654                                      VolumeStructureDescriptor-&gt;<a class="code" href="../../d4/d2/structVSD__GENERIC.html#o0">Type</a> == 255)) {
03655 
03656                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg, <span class="stringliteral">"UdfRecognizeVolume, got a 9660 descriptor\n"</span> ));
03657 
03658                 <span class="comment">//</span>
03659                 <span class="comment">//  Only HSG (CDROM) and 9660 (CD001) are possible, and they are only legal</span>
03660                 <span class="comment">//  before the ISO 13346 BEA/TEA extent.  By design, an ISO 13346 VSD precisely</span>
03661                 <span class="comment">//  overlaps a 9660 PVD/SVD in the appropriate fields.</span>
03662                 <span class="comment">//</span>
03663                 <span class="comment">//  Note that we aren't being strict about the structure of the 9660 descriptors</span>
03664                 <span class="comment">//  since that really isn't very interesting.  We care more about the 13346.</span>
03665                 <span class="comment">//</span>
03666                 <span class="comment">//</span>
03667 
03668                 <span class="keywordflow">switch</span> (<a class="code" href="../../d3/d8/udfprocs_8h.html#a218">UdfFindInParseTable</a>( VsdIdentParseTable,
03669                                              VolumeStructureDescriptor-&gt;<a class="code" href="../../d4/d2/structVSD__GENERIC.html#o1">Ident</a>,
03670                                              VSD_LENGTH_IDENT )) {
03671                     <span class="keywordflow">case</span> <a class="code" href="../../d5/d8/udfs__rec_8h.html#a30a21">VsdIdentCDROM</a>:
03672                     <span class="keywordflow">case</span> <a class="code" href="../../d5/d8/udfs__rec_8h.html#a30a22">VsdIdentCD001</a>:
03673 
03674                         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg, <span class="stringliteral">"UdfRecognizeVolume, ... seems we have 9660 here\n"</span> ));
03675 
03676                         <span class="comment">//</span>
03677                         <span class="comment">//  Note to our caller that we seem to have ISO 9660 here</span>
03678                         <span class="comment">//</span>
03679 
03680                         *Bridge = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03681 
03682                         <span class="keywordflow">break</span>;
03683 
03684                     <span class="keywordflow">default</span>:
03685 
03686                         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg, <span class="stringliteral">"UdfRecognizeVolume, ... but it looks wacky\n"</span> ));
03687 
03688                         <span class="comment">//</span>
03689                         <span class="comment">//  This probably was a false alert, but in any case there is nothing</span>
03690                         <span class="comment">//  on this volume for us.</span>
03691                         <span class="comment">//</span>
03692 
03693                         Resolved = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03694                         <span class="keywordflow">break</span>;
03695                 }
03696 
03697             } <span class="keywordflow">else</span> {
03698 
03699                 <span class="comment">//</span>
03700                 <span class="comment">//  Something else must be recorded on this volume.</span>
03701                 <span class="comment">//</span>
03702 
03703                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg, <span class="stringliteral">"UdfRecognizeVolume, got an unrecognizeable descriptor, probably not 13346/9660\n"</span> ));
03704                 <span class="keywordflow">break</span>;
03705             }
03706 
03707             <span class="comment">//</span>
03708             <span class="comment">//  Align our next read with the sector following the current descriptor</span>
03709             <span class="comment">//</span>
03710 
03711             <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> += <a class="code" href="../../d5/d8/udfs__rec_8h.html#a11">SectorAlignN</a>( SectorSize, <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d2/structVSD__GENERIC.html">VSD_GENERIC</a>) );
03712         }
03713 
03714     } finally {
03715 
03716         <a class="code" href="../../d8/d3/lfsdata_8h.html#a3">DebugUnwind</a>( <span class="stringliteral">"UdfRecognizeVolume"</span> );
03717 
03718         <span class="comment">//</span>
03719         <span class="comment">//  Free up our temporary buffer</span>
03720         <span class="comment">//</span>
03721 
03722         <a class="code" href="../../d3/d8/udfprocs_8h.html#a124">UdfFreePool</a>( &amp;VolumeStructureDescriptor );
03723 
03724         <span class="keywordflow">if</span> (AbnormalTermination()) {
03725 
03726             <span class="comment">//</span>
03727             <span class="comment">//  Commute a status we raised for empty devices so that other filesystems</span>
03728             <span class="comment">//  can have a crack at this.</span>
03729             <span class="comment">//</span>
03730 
03731             <span class="keywordflow">if</span> (<a class="code" href="../../d3/d8/udfprocs_8h.html#a100">UdfIsRawDevice</a>(IrpContext, IrpContext-&gt;ExceptionStatus)) {
03732 
03733                 IrpContext-&gt;ExceptionStatus = STATUS_UNRECOGNIZED_VOLUME;
03734             }
03735         }
03736     }
03737 
03738     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, Dbg, <span class="stringliteral">"UdfRecognizeVolume -&gt; %u\n"</span>, FoundNSR ));
03739 
03740     <span class="keywordflow">return</span> FoundNSR;
03741 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a18" doxytag="udfs/fsctrl.c::UdfScanForDismountedVcb" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID UdfScanForDismountedVcb           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>IrpContext</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l03749">3749</a> of file <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html">udfs/fsctrl.c</a>.
<p>
References <a class="el" href="../../d2/d7/udfdata_8h-source.html#l00363">ASSERT_EXCLUSIVE_UDFDATA</a>, <a class="el" href="../../d2/d7/udfdata_8h-source.html#l00352">ASSERT_IRP_CONTEXT</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>, <a class="el" href="../../d9/d4/udfs_2verfysup_8c-source.html#l00236">UdfCheckForDismount()</a>, <a class="el" href="../../d1/d7/udfdata_8c-source.html#l00042">UdfData</a>, <a class="el" href="../../d7/d7/udfstruc_8h-source.html#l00559">_VCB::VcbCondition</a>, <a class="el" href="../../d6/d8/udfstruc_8h.html#a130a121">VcbDismountInProgress</a>, <a class="el" href="../../d6/d8/udfstruc_8h.html#a130a120">VcbInvalid</a>, <a class="el" href="../../d6/d8/udfstruc_8h.html#a130a117">VcbNotMounted</a>, <a class="el" href="../../d7/d7/udfstruc_8h-source.html#l00216">_UDF_DATA::VcbQueue</a>, <a class="el" href="../../d7/d7/udfstruc_8h-source.html#l00612">_VCB::VcbReference</a>, and <a class="el" href="../../d7/d7/udfstruc_8h-source.html#l00620">_VCB::VcbResidualReference</a>.
<p>
Referenced by <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l01444">UdfMountVolume()</a>.
<p>
<pre class="fragment"><div>03755                    :
03756 
03757     This routine walks through <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> list of Vcb's looking <span class="keywordflow">for</span> any which may
03758     now be deleted.  They may have been left on <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> list because there were
03759     outstanding references.
03760 
03761 Arguments:
03762 
03763 Return Value:
03764 
03765     None
03766 
03767 --*/
03768 
03769 {
03770     <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb;
03771     PLIST_ENTRY Links;
03772 
03773     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
03774 
03775     <span class="comment">//</span>
03776     <span class="comment">//  Check input.</span>
03777     <span class="comment">//</span>
03778 
03779     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
03780 
03781     <a class="code" href="../../d1/d8/udfdata_8h.html#a39">ASSERT_EXCLUSIVE_UDFDATA</a>;
03782 
03783     <span class="comment">//</span>
03784     <span class="comment">//  Walk through all of the Vcb's attached to the global data.</span>
03785     <span class="comment">//</span>
03786 
03787     Links = <a class="code" href="../../d0/d8/udfdata_8c.html#a2">UdfData</a>.<a class="code" href="../../d2/d3/struct__UDF__DATA.html#o3">VcbQueue</a>.Flink;
03788 
03789     <span class="keywordflow">while</span> (Links != &amp;<a class="code" href="../../d0/d8/udfdata_8c.html#a2">UdfData</a>.<a class="code" href="../../d2/d3/struct__UDF__DATA.html#o3">VcbQueue</a>) {
03790 
03791         Vcb = CONTAINING_RECORD( Links, <a class="code" href="../../d7/d5/struct__VCB.html">VCB</a>, VcbLinks );
03792 
03793         <span class="comment">//</span>
03794         <span class="comment">//  Move to the next link now since the current Vcb may be deleted.</span>
03795         <span class="comment">//</span>
03796 
03797         Links = Links-&gt;Flink;
03798 
03799         <span class="comment">//</span>
03800         <span class="comment">//  If dismount is already underway then check if this Vcb can</span>
03801         <span class="comment">//  go away.</span>
03802         <span class="comment">//</span>
03803 
03804         <span class="keywordflow">if</span> ((Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o8">VcbCondition</a> == <a class="code" href="../../d6/d8/udfstruc_8h.html#a130a121">VcbDismountInProgress</a>) ||
03805             (Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o8">VcbCondition</a> == <a class="code" href="../../d6/d8/udfstruc_8h.html#a130a120">VcbInvalid</a>) ||
03806             ((Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o8">VcbCondition</a> == <a class="code" href="../../d6/d8/udfstruc_8h.html#a130a117">VcbNotMounted</a>) &amp;&amp; (Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o16">VcbReference</a> &lt;= Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o18">VcbResidualReference</a>))) {
03807 
03808             <a class="code" href="../../d8/d5/udfs_2verfysup_8c.html#a3">UdfCheckForDismount</a>( IrpContext, Vcb, FALSE );
03809         }
03810     }
03811 
03812     <span class="keywordflow">return</span>;
03813 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="udfs/fsctrl.c::UdfStoreFileSetDescriptorIfPrevailing" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> INLINE VOID UdfStoreFileSetDescriptorIfPrevailing           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN OUT <a class="el" href="../../d2/d2/structNSR__FSD.html">PNSR_FSD</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>StoredFSD</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN OUT <a class="el" href="../../d2/d2/structNSR__FSD.html">PNSR_FSD</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>NewFSD</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l00048">48</a> of file <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html">udfs/fsctrl.c</a>.
<p>
References <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, and <a class="el" href="../../d0/d7/iso13346_8h.html#a232">PNSR_FSD</a>.
<p>
Referenced by <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l02558">UdfFindFileSetDescriptor()</a>.
<p>
<pre class="fragment"><div>00052 {
00053     <a class="code" href="../../d2/d2/structNSR__FSD.html">PNSR_FSD</a> TempFSD;
00054 
00055     <span class="comment">//</span>
00056     <span class="comment">//  If we haven't stored a fileset descriptor or the fileset number</span>
00057     <span class="comment">//  of the stored descriptor is less than the new descriptor, swap the</span>
00058     <span class="comment">//  pointers around.</span>
00059     <span class="comment">//</span>
00060 
00061     <span class="keywordflow">if</span> (*StoredFSD == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> || (*StoredFSD)-&gt;FileSet &lt; (*NewFSD)-&gt;FileSet) {
00062 
00063         TempFSD = *StoredFSD;
00064         *StoredFSD = *NewFSD;
00065         *NewFSD = TempFSD;
00066     }
00067 }
</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a24" doxytag="udfs/fsctrl.c::UdfStoreVolumeDescriptorIfPrevailing" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID UdfStoreVolumeDescriptorIfPrevailing           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN OUT <a class="el" href="../../d4/d3/structNSR__VD__GENERIC.html">PNSR_VD_GENERIC</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>StoredVD</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN OUT <a class="el" href="../../d4/d3/structNSR__VD__GENERIC.html">PNSR_VD_GENERIC</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>NewVD</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l00235">235</a> of file <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html">udfs/fsctrl.c</a>.
<p>
References <a class="el" href="../../d2/d7/fsrtl_8h-source.html#l01101">FsRtlAllocatePoolWithTag</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d2/d6/udfs_2nodetype_8h-source.html#l00179">TAG_NSR_VDSD</a>, and <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l00444">UdfNonPagedPool</a>.
<p>
Referenced by <a class="el" href="../../d3/d5/allocsup_8c-source.html#l00724">UdfAddToPcb()</a>, and <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l02832">UdfFindVolumeDescriptors()</a>.
<p>
<pre class="fragment"><div>00242                    :
00243 
00244     This routine updates Volume Descriptor <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <span class="keyword">new</span> descriptor
00245     <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> more prevailing than <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> one currently stored.
00246 
00247 Arguments:
00248 
00249     StoredVD - pointer to a currently stored descriptor
00250 
00251     NewVD - pointer to a candidate descriptor
00252 
00253 Return Value:
00254 
00255     None.
00256 
00257 --*/
00258 
00259 {
00260     <a class="code" href="../../d4/d3/structNSR__VD__GENERIC.html">PNSR_VD_GENERIC</a> TempVD;
00261 
00262     <span class="comment">//</span>
00263     <span class="comment">//  If we haven't stored a volume descriptor or the sequence number</span>
00264     <span class="comment">//  of the stored descriptor is less than the new descriptor, make a copy</span>
00265     <span class="comment">//  of it and store it.</span>
00266     <span class="comment">//</span>
00267 
00268     <span class="keywordflow">if</span> ((<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> == *StoredVD) || ((*StoredVD)-&gt;Sequence &lt; NewVD-&gt;Sequence)) {
00269 
00270         <span class="keywordflow">if</span> ( <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> == *StoredVD)  {
00271 
00272             *StoredVD = (<a class="code" href="../../d4/d3/structNSR__VD__GENERIC.html">PNSR_VD_GENERIC</a>) <a class="code" href="../../d1/d8/fsrtl_8h.html#a37">FsRtlAllocatePoolWithTag</a>( UdfNonPagedPool,
00273                                                                     <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d3/structNSR__VD__GENERIC.html">NSR_VD_GENERIC</a>),
00274                                                                     TAG_NSR_VDSD );
00275         }
00276 
00277         RtlCopyMemory( *StoredVD,  NewVD,  <span class="keyword">sizeof</span>( <a class="code" href="../../d4/d3/structNSR__VD__GENERIC.html">NSR_VD_GENERIC</a>));
00278     }
00279 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a19" doxytag="udfs/fsctrl.c::UdfUnlockVolume" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS UdfUnlockVolume           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>IrpContext</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d0/d2/struct__IRP.html">PIRP</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>Irp</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l00877">877</a> of file <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html">udfs/fsctrl.c</a>.
<p>
References <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02494">_IO_STACK_LOCATION::FileObject</a>, <a class="el" href="../../d2/d7/fsrtl_8h-source.html#l01425">FSRTL_VOLUME_UNLOCK</a>, <a class="el" href="../../d4/d8/fsrtl_2pnp_8c-source.html#l00041">FsRtlNotifyVolumeEvent()</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l03252">IoGetCurrentIrpStackLocation</a>, <a class="el" href="../../d1/d5/iop_8h-source.html#l00130">Irp</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l01515">UdfAcquireVcbExclusive</a>, <a class="el" href="../../d1/d7/udfdata_8c-source.html#l00809">UdfCompleteRequest()</a>, <a class="el" href="../../d7/d2/filobsup_8c-source.html#l00133">UdfDecodeFileObject()</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l01521">UdfReleaseVcb</a>, <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l00732">UdfUnlockVolumeInternal()</a>, <a class="el" href="../../d3/d8/udfprocs_8h.html#a263a115">UserVolumeOpen</a>, and <a class="el" href="../../d7/d7/udfstruc_8h-source.html#l00941">_FCB::Vcb</a>.
<p>
Referenced by <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l00363">UdfUserFsctl()</a>.
<p>
<pre class="fragment"><div>00884                    :
00885 
00886     This routine performs <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> unlock volume operation.  It <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> responsible <span class="keywordflow">for</span>
00887     either completing of enqueuing <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> input <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>.
00888 
00889 Arguments:
00890 
00891     <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> to process
00892 
00893 Return Value:
00894 
00895     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> - The <span class="keywordflow">return</span> status <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> operation
00896 
00897 --*/
00898 
00899 {
00900     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00901 
00902     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> IrpSp = <a class="code" href="../../d0/d5/io_8h.html#a228">IoGetCurrentIrpStackLocation</a>( Irp );
00903 
00904     <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb;
00905     <a class="code" href="../../d7/d9/struct__FCB.html">PFCB</a> Fcb;
00906     <a class="code" href="../../d2/d9/struct__CCB.html">PCCB</a> Ccb;
00907 
00908     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00909 
00910     <span class="comment">//</span>
00911     <span class="comment">//  Decode the file object, the only type of opens we accept are</span>
00912     <span class="comment">//  user volume opens.</span>
00913     <span class="comment">//</span>
00914 
00915     <span class="keywordflow">if</span> (<a class="code" href="../../d3/d8/udfprocs_8h.html#a174">UdfDecodeFileObject</a>( IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a>, &amp;Fcb, &amp;Ccb ) != <a class="code" href="../../d3/d8/udfprocs_8h.html#a263a115">UserVolumeOpen</a> ) {
00916 
00917         <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, Irp, STATUS_INVALID_PARAMETER );
00918         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
00919     }
00920 
00921     <span class="comment">//</span>
00922     <span class="comment">//  Acquire exclusive access to the Vcb.</span>
00923     <span class="comment">//</span>
00924 
00925     Vcb = Fcb-&gt;<a class="code" href="../../d7/d9/struct__FCB.html#o2">Vcb</a>;
00926 
00927     <a class="code" href="../../d3/d8/udfprocs_8h.html#a74">UdfAcquireVcbExclusive</a>( IrpContext, Vcb, FALSE );
00928 
00929     <span class="comment">//</span>
00930     <span class="comment">//  We won't check for a valid Vcb for this request.  An unlock will always</span>
00931     <span class="comment">//  succeed on a locked volume.</span>
00932     <span class="comment">//</span>
00933 
00934     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d3/d8/udfprocs_8h.html#a191">UdfUnlockVolumeInternal</a>( IrpContext, Vcb, IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a> );    
00935     
00936     <span class="comment">//</span>
00937     <span class="comment">//  Release all of our resources</span>
00938     <span class="comment">//</span>
00939 
00940     <a class="code" href="../../d3/d8/udfprocs_8h.html#a76">UdfReleaseVcb</a>( IrpContext, Vcb );
00941 
00942     <span class="comment">//</span>
00943     <span class="comment">//  Send notification that the volume is avaliable.</span>
00944     <span class="comment">//</span>
00945 
00946     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
00947 
00948         <a class="code" href="../../d1/d8/fsrtl_8h.html#a168">FsRtlNotifyVolumeEvent</a>( IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a>, FSRTL_VOLUME_UNLOCK );
00949     }
00950 
00951     <span class="comment">//</span>
00952     <span class="comment">//  Complete the request if there haven't been any exceptions.</span>
00953     <span class="comment">//</span>
00954 
00955     <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, Irp, Status );
00956     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00957 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a27" doxytag="udfs/fsctrl.c::UdfUnlockVolumeInternal" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS UdfUnlockVolumeInternal           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>IrpContext</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d7/d5/struct__VCB.html">PVCB</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>Vcb</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l00732">732</a> of file <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html">udfs/fsctrl.c</a>.
<p>
References <a class="el" href="../../d6/d4/cc_8h-source.html#l00509">ClearFlag</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00497">FlagOn</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, and <a class="el" href="../../d7/d7/udfstruc_8h-source.html#l00683">VCB_STATE_LOCKED</a>.
<p>
Referenced by <a class="el" href="../../d5/d8/udfs_2pnp_8c-source.html#l00632">UdfPnpCancelRemove()</a>, <a class="el" href="../../d5/d8/udfs_2pnp_8c-source.html#l00350">UdfPnpRemove()</a>, and <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l00877">UdfUnlockVolume()</a>.
<p>
<pre class="fragment"><div>00740                    :
00741 
00742     This routine performs <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> actual unlock volume operation. 
00743     
00744     The volume must be held exclusive by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller.
00745 
00746 Arguments:
00747 
00748     Vcb - The volume being locked.
00749     
00750     FileObject - <a class="code" href="../../d1/d9/icmui_8def.html#a0">File</a> corresponding to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> handle locking <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> volume.  If <span class="keyword">this</span>
00751         <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> not specified, a system lock <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> assumed.
00752 
00753 Return Value:
00754 
00755     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> - The <span class="keywordflow">return</span> status <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> operation
00756     
00757     Attempting to remove a system lock that did not exist <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> OK.
00758 
00759 --*/
00760 
00761 {
00762     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_PARAMETER;
00763     
00764     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(Vcb-&gt;VcbState, VCB_STATE_LOCKED) &amp;&amp; FileObject == Vcb-&gt;VolumeLockFileObject) {
00765 
00766         <a class="code" href="../../d5/d5/cc_8h.html#a61">ClearFlag</a>( Vcb-&gt;VcbState, VCB_STATE_LOCKED );
00767         Vcb-&gt;VolumeLockFileObject = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00768         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
00769     }
00770 
00771     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00772 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a20" doxytag="udfs/fsctrl.c::UdfUpdateVolumeLabel" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID UdfUpdateVolumeLabel           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>IrpContext</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PWCHAR&nbsp;</td>
          <td class="mdname" nowrap> <em>VolumeLabel</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN OUT <a class="el" href="../../d0/d6/jul98_2test_2icc__i386_8h.html#a22">PUSHORT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>VolumeLabelLength</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PUCHAR&nbsp;</td>
          <td class="mdname" nowrap> <em>Dstring</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN UCHAR&nbsp;</td>
          <td class="mdname" nowrap> <em>FieldLength</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l04056">4056</a> of file <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html">udfs/fsctrl.c</a>.
<p>
References <a class="el" href="../../d2/d7/udfdata_8h-source.html#l00352">ASSERT_IRP_CONTEXT</a>, <a class="el" href="../../d0/d5/cdfs__rec_8c-source.html#l00032">Dbg</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02290">DebugTrace</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01065">MAXIMUM_VOLUME_LABEL_LENGTH</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, <a class="el" href="../../d6/d4/namesup_8c-source.html#l00819">UdfCheckLegalCS0Dstring()</a>, and <a class="el" href="../../d6/d4/namesup_8c-source.html#l00689">UdfConvertCS0DstringToUnicode()</a>.
<p>
Referenced by <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l01444">UdfMountVolume()</a>, and <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l02043">UdfVerifyVolume()</a>.
<p>
<pre class="fragment"><div>04066                    :
04067 
04068     This routine will retrieve an NT volume label from a logical volume descriptor.
04069 
04070 Arguments:
04071 
04072     VolumeLabel - a volume label to fill in.
04073 
04074     VolumeLabelLength - returns <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> length of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> returned volume label.
04075 
04076     Dstring - <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> dstring field containing <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> volume <span class="keywordtype">id</span>.
04077 
04078     FieldLength - <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> length of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> dstring field.
04079 
04080 Return Value:
04081 
04082     None.
04083 
04084 --*/
04085 
04086 {
04087     BOOLEAN Result;
04088 
04089     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
04090 
04091     <span class="comment">//</span>
04092     <span class="comment">//  Check inputs.</span>
04093     <span class="comment">//</span>
04094 
04095     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
04096 
04097     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( +1, Dbg,
04098                  <span class="stringliteral">"UdfUpdateVolumeLabel, Label %08x, Dstring %08x FieldLength %02x\n"</span>,
04099                  VolumeLabel,
04100                  Dstring,
04101                  FieldLength ));
04102 
04103     <span class="comment">//</span>
04104     <span class="comment">//  Check that the dstring is usable as a volume identification.</span>
04105     <span class="comment">//</span>
04106 
04107     Result = <a class="code" href="../../d3/d8/udfprocs_8h.html#a182">UdfCheckLegalCS0Dstring</a>( IrpContext,
04108                                       Dstring,
04109                                       0,
04110                                       FieldLength,
04111                                       TRUE );
04112 
04113 
04114     <span class="comment">//</span>
04115     <span class="comment">//  Update the label directly if the dstring is good.</span>
04116     <span class="comment">//</span>
04117 
04118     <span class="keywordflow">if</span> (Result) {
04119 
04120         UNICODE_STRING TemporaryUnicodeString;
04121 
04122         TemporaryUnicodeString.Buffer = VolumeLabel;
04123         TemporaryUnicodeString.MaximumLength = <a class="code" href="../../d0/d5/io_8h.html#a121">MAXIMUM_VOLUME_LABEL_LENGTH</a>;
04124         TemporaryUnicodeString.Length = 0;
04125 
04126         <a class="code" href="../../d3/d8/udfprocs_8h.html#a181">UdfConvertCS0DstringToUnicode</a>( IrpContext,
04127                                        Dstring,
04128                                        0,
04129                                        FieldLength,
04130                                        &amp;TemporaryUnicodeString );
04131 
04132         <span class="comment">//</span>
04133         <span class="comment">//  Now retrieve the name for return to the caller.</span>
04134         <span class="comment">//</span>
04135 
04136         RtlCopyMemory( VolumeLabel, TemporaryUnicodeString.Buffer, TemporaryUnicodeString.Length );
04137         *VolumeLabelLength = TemporaryUnicodeString.Length;
04138 
04139         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg,
04140                      <span class="stringliteral">"UdfUpdateVolumeLabel, Labeled as \"%wZ\"\n"</span>,
04141                      &amp;TemporaryUnicodeString ));
04142 
04143     <span class="comment">//</span>
04144     <span class="comment">//  Treat as label.</span>
04145     <span class="comment">//</span>
04146 
04147     } <span class="keywordflow">else</span> {
04148 
04149         *VolumeLabelLength = 0;
04150 
04151         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg,
04152                      <span class="stringliteral">"UdfUpdateVolumeLabel, invalid label.\n"</span> ));
04153     }
04154 
04155     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, Dbg,
04156                  <span class="stringliteral">"UdfUpdateVolumeLabel -&gt; VOID\n"</span> ));
04157 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a21" doxytag="udfs/fsctrl.c::UdfUpdateVolumeSerialNumber" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID UdfUpdateVolumeSerialNumber           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>IrpContext</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN OUT PULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>VolumeSerialNumber</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d2/d2/structNSR__FSD.html">PNSR_FSD</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>Fsd</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l04165">4165</a> of file <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html">udfs/fsctrl.c</a>.
<p>
References <a class="el" href="../../d2/d7/udfdata_8h-source.html#l00352">ASSERT_IRP_CONTEXT</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l00348">SwapCopyUchar4</a>, and <a class="el" href="../../d1/d7/udfdata_8c-source.html#l01022">UdfSerial32()</a>.
<p>
Referenced by <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l01444">UdfMountVolume()</a>, and <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l02043">UdfVerifyVolume()</a>.
<p>
<pre class="fragment"><div>04173                    :
04174 
04175     This routine will compute <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> volume serial number <span class="keywordflow">for</span> a set of descriptors.
04176 
04177 Arguments:
04178 
04179     VolumeSerialNumber - returns <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> volume serial number corresponding to these descriptors.
04180 
04181     Fsd - <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> fileset descriptor to examine.
04182 
04183 Return Value:
04184 
04185     None.
04186 
04187 --*/
04188 
04189 {
04190     ULONG VsnLe;
04191     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
04192 
04193     <span class="comment">//</span>
04194     <span class="comment">//  Check input.</span>
04195     <span class="comment">//</span>
04196 
04197     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
04198 
04199     <span class="comment">//</span>
04200     <span class="comment">//  The serial number is just off of the FSD. This matches Win9x.</span>
04201     <span class="comment">//</span>
04202 
04203     VsnLe = <a class="code" href="../../d3/d8/udfprocs_8h.html#a132">UdfSerial32</a>( (PCHAR) Fsd, <span class="keyword">sizeof</span>( <a class="code" href="../../d2/d2/structNSR__FSD.html">NSR_FSD</a> ));
04204     <a class="code" href="../../d3/d8/udfprocs_8h.html#a60">SwapCopyUchar4</a>( VolumeSerialNumber, &amp;VsnLe );
04205 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a22" doxytag="udfs/fsctrl.c::UdfUserFsctl" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS UdfUserFsctl           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>IrpContext</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d0/d2/struct__IRP.html">PIRP</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>Irp</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l00363">363</a> of file <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html">udfs/fsctrl.c</a>.
<p>
References <a class="el" href="../../d1/d4/io_8h-source.html#l03252">IoGetCurrentIrpStackLocation</a>, <a class="el" href="../../d1/d5/iop_8h-source.html#l00130">Irp</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02069">_IO_STACK_LOCATION::Parameters</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, <a class="el" href="../../d1/d7/udfdata_8c-source.html#l00809">UdfCompleteRequest()</a>, <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l00966">UdfDismountVolume()</a>, <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l01271">UdfInvalidateVolumes()</a>, <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l01236">UdfIsPathnameValid()</a>, <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l01064">UdfIsVolumeDirty()</a>, <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l01175">UdfIsVolumeMounted()</a>, <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l00780">UdfLockVolume()</a>, <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l00470">UdfOplockRequest()</a>, and <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l00877">UdfUnlockVolume()</a>.
<p>
Referenced by <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l00283">UdfCommonFsControl()</a>.
<p>
<pre class="fragment"><div>00369                    :
00370 
00371     This <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> common routine <span class="keywordflow">for</span> implementing <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> user's requests <a class="code" href="../../d3/d0/user32_8def.html#a107">made</a>
00372     through <a class="code" href="../../d8/d7/io_2fsctrl_8c.html#a0">NtFsControlFile</a>.
00373 
00374 Arguments:
00375 
00376     <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> being processed
00377 
00378 Return Value:
00379 
00380     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> - The <span class="keywordflow">return</span> status <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> operation
00381 
00382 --*/
00383 
00384 {
00385     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00386     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> IrpSp = <a class="code" href="../../d0/d5/io_8h.html#a228">IoGetCurrentIrpStackLocation</a>( Irp );
00387 
00388     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00389 
00390     <span class="comment">//</span>
00391     <span class="comment">//  Case on the control code.</span>
00392     <span class="comment">//</span>
00393 
00394     <span class="keywordflow">switch</span> ( IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.FileSystemControl.FsControlCode ) {
00395 
00396     <span class="keywordflow">case</span> FSCTL_REQUEST_OPLOCK_LEVEL_1 :
00397     <span class="keywordflow">case</span> FSCTL_REQUEST_OPLOCK_LEVEL_2 :
00398     <span class="keywordflow">case</span> FSCTL_REQUEST_BATCH_OPLOCK :
00399     <span class="keywordflow">case</span> FSCTL_OPLOCK_BREAK_ACKNOWLEDGE :
00400     <span class="keywordflow">case</span> FSCTL_OPBATCH_ACK_CLOSE_PENDING :
00401     <span class="keywordflow">case</span> FSCTL_OPLOCK_BREAK_NOTIFY :
00402     <span class="keywordflow">case</span> FSCTL_OPLOCK_BREAK_ACK_NO_2 :
00403     <span class="keywordflow">case</span> FSCTL_REQUEST_FILTER_OPLOCK :
00404 
00405         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a16">UdfOplockRequest</a>( IrpContext, Irp );
00406         <span class="keywordflow">break</span>;
00407 
00408     <span class="keywordflow">case</span> FSCTL_LOCK_VOLUME :
00409 
00410         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a14">UdfLockVolume</a>( IrpContext, Irp );
00411         <span class="keywordflow">break</span>;
00412 
00413     <span class="keywordflow">case</span> FSCTL_UNLOCK_VOLUME :
00414 
00415         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a19">UdfUnlockVolume</a>( IrpContext, Irp );
00416         <span class="keywordflow">break</span>;
00417 
00418     <span class="keywordflow">case</span> FSCTL_DISMOUNT_VOLUME :
00419 
00420         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a5">UdfDismountVolume</a>( IrpContext, Irp );
00421         <span class="keywordflow">break</span>;
00422 
00423     <span class="keywordflow">case</span> FSCTL_IS_VOLUME_DIRTY :
00424 
00425         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a12">UdfIsVolumeDirty</a>( IrpContext, Irp );
00426         <span class="keywordflow">break</span>;
00427 
00428     <span class="keywordflow">case</span> FSCTL_IS_VOLUME_MOUNTED :
00429 
00430         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a13">UdfIsVolumeMounted</a>( IrpContext, Irp );
00431         <span class="keywordflow">break</span>;
00432 
00433     <span class="keywordflow">case</span> FSCTL_IS_PATHNAME_VALID :
00434 
00435         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a10">UdfIsPathnameValid</a>( IrpContext, Irp );
00436         <span class="keywordflow">break</span>;
00437 
00438     <span class="keywordflow">case</span> FSCTL_INVALIDATE_VOLUMES :
00439 
00440         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a9">UdfInvalidateVolumes</a>( IrpContext, Irp );
00441         <span class="keywordflow">break</span>;
00442 
00443 
00444     <span class="comment">//</span>
00445     <span class="comment">//  We don't support any of the known or unknown requests.</span>
00446     <span class="comment">//</span>
00447 
00448     <span class="keywordflow">case</span> FSCTL_MARK_VOLUME_DIRTY :
00449     <span class="keywordflow">case</span> FSCTL_QUERY_RETRIEVAL_POINTERS :
00450     <span class="keywordflow">case</span> FSCTL_GET_COMPRESSION :
00451     <span class="keywordflow">case</span> FSCTL_SET_COMPRESSION :
00452     <span class="keywordflow">case</span> FSCTL_MARK_AS_SYSTEM_HIVE :
00453     <span class="keywordflow">case</span> FSCTL_QUERY_FAT_BPB :
00454     <span class="keywordflow">default</span>:
00455 
00456         <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, Irp, STATUS_INVALID_DEVICE_REQUEST );
00457         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_DEVICE_REQUEST;
00458         <span class="keywordflow">break</span>;
00459     }
00460 
00461     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00462 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a23" doxytag="udfs/fsctrl.c::UdfVerifyVolume" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS UdfVerifyVolume           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>IrpContext</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d0/d2/struct__IRP.html">PIRP</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>Irp</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l02043">2043</a> of file <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html">udfs/fsctrl.c</a>.
<p>
References <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d2/d7/udfdata_8h-source.html#l00352">ASSERT_IRP_CONTEXT</a>, <a class="el" href="../../d2/d7/udfdata_8h-source.html#l00336">ASSERT_VCB</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00509">ClearFlag</a>, <a class="el" href="../../d0/d5/cdfs__rec_8c-source.html#l00032">Dbg</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02290">DebugTrace</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01188">_DEVICE_OBJECT::DeviceType</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01153">DO_VERIFY_VOLUME</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00497">FlagOn</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02030">_IO_STACK_LOCATION::Flags</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01184">_DEVICE_OBJECT::Flags</a>, <a class="el" href="../../d1/d6/iso13346_8h-source.html#l00545">NSR_LVOL::FSD</a>, <a class="el" href="../../d2/d7/fsrtl_8h-source.html#l01426">FSRTL_VOLUME_MOUNT</a>, <a class="el" href="../../d4/d8/fsrtl_2pnp_8c-source.html#l00041">FsRtlNotifyVolumeEvent()</a>, <a class="el" href="../../d2/d9/cmchek_8c-source.html#l00095">Index</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l03252">IoGetCurrentIrpStackLocation</a>, <a class="el" href="../../d1/d5/iop_8h-source.html#l00130">Irp</a>, <a class="el" href="../../d1/d6/iso13346_8h-source.html#l00441">NSR_ANCHOR::Main</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01065">MAXIMUM_VOLUME_LABEL_LENGTH</a>, <a class="el" href="../../d7/d7/udfstruc_8h-source.html#l00572">_VCB::MediaChangeCount</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00494">ObDereferenceObject</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00514">ObReferenceObject</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02069">_IO_STACK_LOCATION::Parameters</a>, <a class="el" href="../../d7/d7/udfstruc_8h-source.html#l00535">_VCB::Pcb</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01073">_VPB::RealDevice</a>, <a class="el" href="../../d1/d6/iso13346_8h-source.html#l00442">NSR_ANCHOR::Reserve</a>, <a class="el" href="../../d7/d7/udfstruc_8h-source.html#l00629">_VCB::RootIndexFcb</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01074">_VPB::SerialNumber</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01912">SL_ALLOW_RAW_MOUNT</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, <a class="el" href="../../d7/d7/udfstruc_8h-source.html#l00541">_VCB::TargetDeviceObject</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l00436">try_leave</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l01509">UdfAcquireUdfData</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l01515">UdfAcquireVcbExclusive</a>, <a class="el" href="../../d9/d4/udfs_2verfysup_8c-source.html#l00236">UdfCheckForDismount()</a>, <a class="el" href="../../d3/d5/allocsup_8c-source.html#l00804">UdfCompletePcb()</a>, <a class="el" href="../../d1/d7/udfdata_8c-source.html#l00809">UdfCompleteRequest()</a>, <a class="el" href="../../d3/d5/allocsup_8c-source.html#l00309">UdfDeletePcb()</a>, <a class="el" href="../../d3/d5/allocsup_8c-source.html#l00923">UdfEquivalentPcb()</a>, <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l03307">UdfFindAnchorVolumeDescriptor()</a>, <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l02558">UdfFindFileSetDescriptor()</a>, <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l02832">UdfFindVolumeDescriptors()</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l00453">UdfFreePool()</a>, <a class="el" href="../../d4/d6/deviosup_8c-source.html#l00573">UdfPerformDevIoCtrl()</a>, <a class="el" href="../../d9/d1/udfs_2cachesup_8c-source.html#l00417">UdfPurgeVolume()</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l01512">UdfReleaseUdfData</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l01521">UdfReleaseVcb</a>, <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l04056">UdfUpdateVolumeLabel()</a>, <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l04165">UdfUpdateVolumeSerialNumber()</a>, <a class="el" href="../../d5/d4/aug98_2dll32_2icc__i386_8h-source.html#l00064">USHORT</a>, <a class="el" href="../../d7/d7/udfstruc_8h-source.html#l00685">VCB_STATE_NOTIFY_REMOUNT</a>, <a class="el" href="../../d7/d7/udfstruc_8h-source.html#l00611">_VCB::VcbCleanup</a>, <a class="el" href="../../d7/d7/udfstruc_8h-source.html#l00559">_VCB::VcbCondition</a>, <a class="el" href="../../d6/d8/udfstruc_8h.html#a130a119">VcbMounted</a>, <a class="el" href="../../d6/d8/udfstruc_8h.html#a130a117">VcbNotMounted</a>, <a class="el" href="../../d7/d7/udfstruc_8h-source.html#l00558">_VCB::VcbState</a>, <a class="el" href="../../d1/d6/iso13346_8h-source.html#l00542">NSR_LVOL::VolumeID</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01076">_VPB::VolumeLabel</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01071">_VPB::VolumeLabelLength</a>, and <a class="el" href="../../d7/d7/udfstruc_8h-source.html#l00529">_VCB::Vpb</a>.
<p>
Referenced by <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l00283">UdfCommonFsControl()</a>.
<p>
<pre class="fragment"><div>02050                    :
02051 
02052     This routine performs <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> verify volume operation.  It <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> responsible <span class="keywordflow">for</span>
02053     either completing of enqueuing <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> input <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>.
02054 
02055 Arguments:
02056 
02057     <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> to process
02058 
02059 Return Value:
02060 
02061     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> - The <span class="keywordflow">return</span> status <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> operation
02062 
02063 --*/
02064 
02065 {
02066     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> IrpSp = <a class="code" href="../../d0/d5/io_8h.html#a228">IoGetCurrentIrpStackLocation</a>( Irp );
02067     <a class="code" href="../../d7/d7/struct__VPB.html">PVPB</a> Vpb = IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.VerifyVolume.Vpb;
02068     <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb = &amp;((<a class="code" href="../../d6/d7/struct__VOLUME__DEVICE__OBJECT.html">PVOLUME_DEVICE_OBJECT</a>) IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.VerifyVolume.DeviceObject)-&gt;Vcb;
02069 
02070     <a class="code" href="../../d4/d9/struct__PCB.html">PPCB</a> Pcb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02071 
02072     <a class="code" href="../../d7/d1/structNSR__ANCHOR.html">PNSR_ANCHOR</a> AnchorVolumeDescriptor = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02073     <a class="code" href="../../d0/d3/structNSR__PVD.html">PNSR_PVD</a> PrimaryVolumeDescriptor = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02074     <a class="code" href="../../d6/d2/structNSR__LVOL.html">PNSR_LVOL</a> LogicalVolumeDescriptor = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02075     <a class="code" href="../../d2/d2/structNSR__FSD.html">PNSR_FSD</a> FileSetDescriptor = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02076 
02077     ULONG MediaChangeCount = 0;
02078     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
02079 
02080     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObjectToNotify = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02081 
02082     BOOLEAN ReturnError;
02083     BOOLEAN ReleaseVcb;
02084 
02085     IO_STATUS_BLOCK Iosb;
02086 
02087     WCHAR VolumeLabel[ <a class="code" href="../../d0/d5/io_8h.html#a121">MAXIMUM_VOLUME_LABEL_LENGTH</a> / <span class="keyword">sizeof</span>( WCHAR )];
02088     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> VolumeLabelLength;
02089     ULONG VolumeSerialNumber;
02090 
02091     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
02092 
02093     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
02094 
02095     <span class="comment">//</span>
02096     <span class="comment">//  Check input.</span>
02097     <span class="comment">//</span>
02098 
02099     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
02100 
02101     <span class="comment">//</span>
02102     <span class="comment">//  Check that we are talking to a Cdrom or Disk device.  This request should</span>
02103     <span class="comment">//  always be waitable.</span>
02104     <span class="comment">//</span>
02105 
02106     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( Vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o5">RealDevice</a>-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o12">DeviceType</a> == FILE_DEVICE_CD_ROM ||
02107             Vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o5">RealDevice</a>-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o12">DeviceType</a> == FILE_DEVICE_DISK );
02108 
02109     <a class="code" href="../../d1/d8/udfdata_8h.html#a12">ASSERT_VCB</a>( Vcb );
02110 
02111     <span class="comment">//</span>
02112     <span class="comment">//  Update the real device in the IrpContext from the Vpb.  There was no available</span>
02113     <span class="comment">//  file object when the IrpContext was created.</span>
02114     <span class="comment">//</span>
02115 
02116     IrpContext-&gt;RealDevice = Vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o5">RealDevice</a>;
02117 
02118     <span class="comment">//</span>
02119     <span class="comment">//  Acquire shared global access, the termination handler for the</span>
02120     <span class="comment">//  following try statement will free the access.</span>
02121     <span class="comment">//</span>
02122 
02123     <a class="code" href="../../d3/d8/udfprocs_8h.html#a72">UdfAcquireUdfData</a>( IrpContext );
02124     <a class="code" href="../../d3/d8/udfprocs_8h.html#a74">UdfAcquireVcbExclusive</a>( IrpContext, Vcb, FALSE );
02125     ReleaseVcb = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02126 
02127     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( +1, Dbg, <span class="stringliteral">"UdfVerifyVolume, Vcb %08x\n"</span>, Vcb ));
02128 
02129     <span class="keywordflow">try</span> {
02130 
02131         <span class="comment">//</span>
02132         <span class="comment">//  Check if the real device still needs to be verified.  If it doesn't</span>
02133         <span class="comment">//  then obviously someone beat us here and already did the work</span>
02134         <span class="comment">//  so complete the verify irp with success.  Otherwise reenable</span>
02135         <span class="comment">//  the real device and get to work.</span>
02136         <span class="comment">//</span>
02137 
02138         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( Vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o5">RealDevice</a>-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o8">Flags</a>, DO_VERIFY_VOLUME )) {
02139 
02140             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg, <span class="stringliteral">"UdfVerifyVolume, verify bit was cleared out ahead of us\n"</span> ));
02141 
02142             MediaChangeCount = Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o10">MediaChangeCount</a>;
02143             <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( Status = STATUS_SUCCESS );
02144         }
02145 
02146         <span class="comment">//</span>
02147         <span class="comment">//  Verify that there is a disk here.</span>
02148         <span class="comment">//</span>
02149 
02150         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d3/d8/udfprocs_8h.html#a159">UdfPerformDevIoCtrl</a>( IrpContext,
02151                                       ( Vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o5">RealDevice</a>-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o12">DeviceType</a> == FILE_DEVICE_CD_ROM ?
02152                                         IOCTL_CDROM_CHECK_VERIFY :
02153                                         IOCTL_DISK_CHECK_VERIFY ),
02154                                       Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o4">TargetDeviceObject</a>,
02155                                       &amp;MediaChangeCount,
02156                                       <span class="keyword">sizeof</span>(ULONG),
02157                                       FALSE,
02158                                       TRUE,
02159                                       &amp;Iosb );
02160 
02161         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
02162 
02163             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg, <span class="stringliteral">"UdfVerifyVolume, CHECK_VERIFY failed\n"</span> ));
02164 
02165             <span class="comment">//</span>
02166             <span class="comment">//  If we will allow a raw mount then return WRONG_VOLUME to</span>
02167             <span class="comment">//  allow the volume to be mounted by raw.</span>
02168             <span class="comment">//</span>
02169 
02170             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o2">Flags</a>, SL_ALLOW_RAW_MOUNT )) {
02171 
02172                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg, <span class="stringliteral">"UdfVerifyVolume, ... allowing raw mount\n"</span> ));
02173 
02174                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_WRONG_VOLUME;
02175             }
02176 
02177             <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( Status );
02178         }
02179 
02180         <span class="keywordflow">if</span> (Iosb.Information != <span class="keyword">sizeof</span>(ULONG)) {
02181 
02182             <span class="comment">//</span>
02183             <span class="comment">//  Be safe about the count in case the driver didn't fill it in</span>
02184             <span class="comment">//</span>
02185 
02186             MediaChangeCount = 0;
02187         }
02188 
02189         <span class="comment">//</span>
02190         <span class="comment">//  Verify that the device actually saw a change. If the driver does not</span>
02191         <span class="comment">//  support the MCC, then we must verify the volume in any case.</span>
02192         <span class="comment">//</span>
02193 
02194         <span class="keywordflow">if</span> (MediaChangeCount == 0 || Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o10">MediaChangeCount</a> != MediaChangeCount) {
02195 
02196             <span class="comment">//</span>
02197             <span class="comment">//  Now we need to navigate the disc to find the relavent decriptors.  This is</span>
02198             <span class="comment">//  much the same as the mount process.</span>
02199             <span class="comment">//</span>
02200 
02201             <span class="comment">//</span>
02202             <span class="comment">//  Find the AVD.</span>
02203             <span class="comment">//</span>
02204 
02205             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a6">UdfFindAnchorVolumeDescriptor</a>( IrpContext,
02206                                                     Vcb,
02207                                                     &amp;AnchorVolumeDescriptor );
02208 
02209             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(Status)) {
02210                 
02211                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg, <span class="stringliteral">"UdfVerifyVolume, No AVD visible\n"</span> ));
02212                 <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( Status = STATUS_WRONG_VOLUME );
02213             }
02214             
02215             <span class="comment">//</span>
02216             <span class="comment">//  Get the prevailing descriptors out of the VDS, building a fresh Pcb.</span>
02217             <span class="comment">//</span>
02218 
02219             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a8">UdfFindVolumeDescriptors</a>( IrpContext,
02220                                                Vcb,
02221                                                &amp;AnchorVolumeDescriptor-&gt;<a class="code" href="../../d7/d1/structNSR__ANCHOR.html#o1">Main</a>,
02222                                                &amp;Pcb,
02223                                                &amp;PrimaryVolumeDescriptor,
02224                                                &amp;LogicalVolumeDescriptor );
02225 
02226             <span class="comment">//</span>
02227             <span class="comment">//  Try the reserve sequence in case of error.</span>
02228             <span class="comment">//</span>
02229 
02230             <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_DISK_CORRUPT_ERROR) {
02231 
02232                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a8">UdfFindVolumeDescriptors</a>( IrpContext,
02233                                                    Vcb,
02234                                                    &amp;AnchorVolumeDescriptor-&gt;<a class="code" href="../../d7/d1/structNSR__ANCHOR.html#o2">Reserve</a>,
02235                                                    &amp;Pcb,
02236                                                    &amp;PrimaryVolumeDescriptor,
02237                                                    &amp;LogicalVolumeDescriptor );
02238             }
02239 
02240             <span class="comment">//</span>
02241             <span class="comment">//  If we're totally unable to find a VDS, give up.</span>
02242             <span class="comment">//</span>
02243 
02244             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(Status)) {
02245 
02246                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg, <span class="stringliteral">"UdfVerifyVolume, PVD/LVD/PD pickup failed\n"</span> ));
02247 
02248                 <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( Status = STATUS_WRONG_VOLUME );
02249             }
02250 
02251             <span class="comment">//</span>
02252             <span class="comment">//  Now go complete initialization of the Pcb so we can compare it.</span>
02253             <span class="comment">//</span>
02254 
02255             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d3/d8/udfprocs_8h.html#a150">UdfCompletePcb</a>( IrpContext,
02256                                      Vcb,
02257                                      Pcb );
02258 
02259             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(Status)) {
02260 
02261                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg, <span class="stringliteral">"UdfVerifyVolume, Pcb completion failed\n"</span> ));
02262 
02263                 <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( Status = STATUS_WRONG_VOLUME );
02264             }
02265 
02266             <span class="comment">//</span>
02267             <span class="comment">//  Now let's compare this new Pcb to the previous Vcb's Pcb to see if they</span>
02268             <span class="comment">//  appear to be equivalent.</span>
02269             <span class="comment">//</span>
02270 
02271             <span class="keywordflow">if</span> (!<a class="code" href="../../d3/d8/udfprocs_8h.html#a151">UdfEquivalentPcb</a>( IrpContext,
02272                                    Pcb,
02273                                    Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o3">Pcb</a>)) {
02274 
02275                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg, <span class="stringliteral">"UdfVerifyVolume, Pcbs are not equivalent\n"</span> ));
02276 
02277                 <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( Status = STATUS_WRONG_VOLUME );
02278             }
02279 
02280             <span class="comment">//</span>
02281             <span class="comment">//  At this point we know that the Vcb's Pcb is OK for mapping to find the fileset</span>
02282             <span class="comment">//  descriptor, so we can drop the new one we built for comparison purposes.</span>
02283             <span class="comment">//</span>
02284 
02285             <a class="code" href="../../d3/d8/udfprocs_8h.html#a147">UdfDeletePcb</a>( Pcb );
02286             Pcb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02287 
02288             <span class="comment">//</span>
02289             <span class="comment">//  Go pick up the fileset descriptor.</span>
02290             <span class="comment">//</span>
02291 
02292             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a7">UdfFindFileSetDescriptor</a>( IrpContext,
02293                                                Vcb,
02294                                                &amp;LogicalVolumeDescriptor-&gt;<a class="code" href="../../d6/d2/structNSR__LVOL.html#o6">FSD</a>,
02295                                                &amp;FileSetDescriptor );
02296 
02297             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(Status)) {
02298 
02299                 <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( Status = STATUS_WRONG_VOLUME );
02300             }
02301 
02302             <span class="comment">//</span>
02303             <span class="comment">//  Now that everything is in place, build a volume label and serial number from these</span>
02304             <span class="comment">//  descriptors and perform the final check that this Vcb is (or is not) the right one</span>
02305             <span class="comment">//  for the media now in the drive.</span>
02306             <span class="comment">//</span>
02307 
02308             <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a20">UdfUpdateVolumeLabel</a>( IrpContext,
02309                                   VolumeLabel,
02310                                   &amp;VolumeLabelLength,
02311                                   LogicalVolumeDescriptor-&gt;<a class="code" href="../../d6/d2/structNSR__LVOL.html#o3">VolumeID</a>,
02312                                   <span class="keyword">sizeof</span>( LogicalVolumeDescriptor-&gt;<a class="code" href="../../d6/d2/structNSR__LVOL.html#o3">VolumeID</a> ));
02313 
02314             <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a21">UdfUpdateVolumeSerialNumber</a>( IrpContext,
02315                                          &amp;VolumeSerialNumber,
02316                                          FileSetDescriptor );
02317 
02318             <span class="keywordflow">if</span> (Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o2">Vpb</a>-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o6">SerialNumber</a> != VolumeSerialNumber ||
02319                 Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o2">Vpb</a>-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o3">VolumeLabelLength</a> != VolumeLabelLength ||
02320                 RtlCompareMemory( Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o2">Vpb</a>-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o8">VolumeLabel</a>,
02321                                   VolumeLabel,
02322                                   VolumeLabelLength )) {
02323 
02324                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg, <span class="stringliteral">"UdfVerifyVolume, volume label/sn mismatch\n"</span> ));
02325 
02326                 <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( Status = STATUS_WRONG_VOLUME );
02327             }
02328         }
02329 
02330         <span class="comment">//</span>
02331         <span class="comment">//  The volume is OK, clear the verify bit.</span>
02332         <span class="comment">//</span>
02333 
02334         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg, <span class="stringliteral">"UdfVerifyVolume, looks like the same volume\n"</span> ));
02335 
02336         Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o8">VcbCondition</a> = <a class="code" href="../../d6/d8/udfstruc_8h.html#a130a119">VcbMounted</a>;
02337 
02338         <a class="code" href="../../d5/d5/cc_8h.html#a61">ClearFlag</a>( Vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o5">RealDevice</a>-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o8">Flags</a>, DO_VERIFY_VOLUME );
02339 
02340         <span class="comment">//</span>
02341         <span class="comment">//  See if we will need to provide notification of the remount.  This is the readonly</span>
02342         <span class="comment">//  filesystem's form of dismount/mount notification.</span>
02343         <span class="comment">//</span>
02344 
02345         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o7">VcbState</a>, VCB_STATE_NOTIFY_REMOUNT )) {
02346 
02347             <a class="code" href="../../d5/d5/cc_8h.html#a61">ClearFlag</a>( Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o7">VcbState</a>, VCB_STATE_NOTIFY_REMOUNT );
02348             
02349             FileObjectToNotify = Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o21">RootIndexFcb</a>-&gt;FileObject;
02350             <a class="code" href="../../d4/d0/ob_8h.html#a15">ObReferenceObject</a>( FileObjectToNotify );
02351         }
02352         
02353     } finally {
02354 
02355         <span class="comment">//</span>
02356         <span class="comment">//  If we did not raise an exception, update the current Vcb.</span>
02357         <span class="comment">//</span>
02358 
02359         <span class="keywordflow">if</span> (!AbnormalTermination()) {
02360 
02361             <span class="comment">//</span>
02362             <span class="comment">//  Update the media change count to note that we have verified the volume</span>
02363             <span class="comment">//  at this value</span>
02364             <span class="comment">//</span>
02365 
02366             Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o10">MediaChangeCount</a> = MediaChangeCount;
02367 
02368             <span class="comment">//</span>
02369             <span class="comment">//  Mark the Vcb as not mounted.</span>
02370             <span class="comment">//</span>
02371 
02372             <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_WRONG_VOLUME) {
02373 
02374                 Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o8">VcbCondition</a> = <a class="code" href="../../d6/d8/udfstruc_8h.html#a130a117">VcbNotMounted</a>;
02375                 
02376                 <span class="comment">//</span>
02377                 <span class="comment">//  Now, if there are no user handles to the volume, try to spark</span>
02378                 <span class="comment">//  teardown by purging the volume.</span>
02379                 <span class="comment">//</span>
02380 
02381                 <span class="keywordflow">if</span> (Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o15">VcbCleanup</a> == 0) {
02382 
02383                     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d3/d8/udfprocs_8h.html#a158">UdfPurgeVolume</a>( IrpContext, Vcb, FALSE ))) {
02384 
02385                         ReleaseVcb = <a class="code" href="../../d8/d5/udfs_2verfysup_8c.html#a3">UdfCheckForDismount</a>( IrpContext, Vcb, FALSE );
02386                     }
02387                 }
02388             }
02389         }
02390 
02391         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, Dbg, <span class="stringliteral">"UdfVerifyVolume -&gt; %08x\n"</span>, Status ));
02392 
02393         <span class="keywordflow">if</span> (ReleaseVcb) {
02394             
02395             <a class="code" href="../../d3/d8/udfprocs_8h.html#a76">UdfReleaseVcb</a>( IrpContext, Vcb );
02396         }
02397 
02398         <a class="code" href="../../d3/d8/udfprocs_8h.html#a73">UdfReleaseUdfData</a>( IrpContext );
02399 
02400         <span class="comment">//</span>
02401         <span class="comment">//  Delete the Pcb if built.</span>
02402         <span class="comment">//</span>
02403 
02404         <span class="keywordflow">if</span> (Pcb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02405 
02406             <a class="code" href="../../d3/d8/udfprocs_8h.html#a147">UdfDeletePcb</a>( Pcb );
02407         }
02408 
02409         <a class="code" href="../../d3/d8/udfprocs_8h.html#a124">UdfFreePool</a>( &amp;AnchorVolumeDescriptor );
02410         <a class="code" href="../../d3/d8/udfprocs_8h.html#a124">UdfFreePool</a>( &amp;PrimaryVolumeDescriptor );
02411         <a class="code" href="../../d3/d8/udfprocs_8h.html#a124">UdfFreePool</a>( &amp;LogicalVolumeDescriptor );
02412         <a class="code" href="../../d3/d8/udfprocs_8h.html#a124">UdfFreePool</a>( &amp;FileSetDescriptor );
02413     }
02414 
02415     <span class="comment">//</span>
02416     <span class="comment">//  Now send mount notification.</span>
02417     <span class="comment">//</span>
02418     
02419     <span class="keywordflow">if</span> (FileObjectToNotify) {
02420 
02421         <a class="code" href="../../d1/d8/fsrtl_8h.html#a168">FsRtlNotifyVolumeEvent</a>( FileObjectToNotify, FSRTL_VOLUME_MOUNT );
02422         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( FileObjectToNotify );
02423     }
02424     
02425     <span class="comment">//</span>
02426     <span class="comment">//  Complete the request if no exception.</span>
02427     <span class="comment">//</span>
02428 
02429     <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, Irp, Status );
02430     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
02431 }

</div></pre>    </td>
  </tr>
</table>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="a2" doxytag="udfs/fsctrl.c::UdfDisable" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> BOOLEAN <a class="el" href="../../d9/d7/udfs_2fsctrl_8c.html#a2">UdfDisable</a> = FALSE          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l00040">40</a> of file <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html">udfs/fsctrl.c</a>.
<p>
Referenced by <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l01444">UdfMountVolume()</a>.    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:43:46 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
