<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: mtrr.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>mtrr.c</h1><a href="../../d8/d4/mtrr_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1991  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    mtrr.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module implements interfaces that support manipulation of</span>
00012 <span class="comment">    memory type range registers.</span>
00013 <span class="comment"></span>
00014 <span class="comment">    These entry points only exist on i386 machines.</span>
00015 <span class="comment"></span>
00016 <span class="comment">Author:</span>
00017 <span class="comment"></span>
00018 <span class="comment">    Ken Reneris (kenr)  11-Oct-95</span>
00019 <span class="comment"></span>
00020 <span class="comment">Environment:</span>
00021 <span class="comment"></span>
00022 <span class="comment">    Kernel mode only.</span>
00023 <span class="comment"></span>
00024 <span class="comment">Revision History:</span>
00025 <span class="comment"></span>
00026 <span class="comment">--*/</span>
00027 
00028 <span class="preprocessor">#include "<a class="code" href="../../d0/d0/ki_8h.html">ki.h</a>"</span>
00029 <span class="preprocessor">#include "<a class="code" href="../../d9/d4/mtrr_8h.html">mtrr.h</a>"</span>
00030 
<a name="l00031"></a><a class="code" href="../../d8/d4/mtrr_8c.html#a0">00031</a> <span class="preprocessor">#define STATIC</span>
00032 <span class="preprocessor"></span>
<a name="l00033"></a><a class="code" href="../../d8/d4/mtrr_8c.html#a1">00033</a> <span class="preprocessor">#define IDBG    0</span>
00034 <span class="preprocessor"></span>
00035 <span class="preprocessor">#if DBG</span>
00036 <span class="preprocessor"></span><span class="preprocessor">#define DBGMSG(a)   DbgPrint(a)</span>
00037 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00038"></a><a class="code" href="../../d8/d4/mtrr_8c.html#a2">00038</a> <span class="preprocessor"></span><span class="preprocessor">#define DBGMSG(a)</span>
00039 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00040 <span class="preprocessor"></span>
00041 <span class="comment">//</span>
00042 <span class="comment">// Internal declarations</span>
00043 <span class="comment">//</span>
00044 
00045 <span class="comment">//</span>
00046 <span class="comment">// Range in generic terms</span>
00047 <span class="comment">//</span>
00048 
<a name="l00049"></a><a class="code" href="../../d2/d7/struct__ONE__RANGE.html">00049</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d2/d7/struct__ONE__RANGE.html">_ONE_RANGE</a> {
<a name="l00050"></a><a class="code" href="../../d2/d7/struct__ONE__RANGE.html#o0">00050</a>     ULONGLONG           <a class="code" href="../../d2/d7/struct__ONE__RANGE.html#o0">Base</a>;
<a name="l00051"></a><a class="code" href="../../d2/d7/struct__ONE__RANGE.html#o1">00051</a>     ULONGLONG           <a class="code" href="../../d2/d7/struct__ONE__RANGE.html#o1">Limit</a>;
<a name="l00052"></a><a class="code" href="../../d2/d7/struct__ONE__RANGE.html#o2">00052</a>     UCHAR               <a class="code" href="../../d2/d7/struct__ONE__RANGE.html#o2">Type</a>;
00053 } <a class="code" href="../../d2/d7/struct__ONE__RANGE.html">ONE_RANGE</a>, *<a class="code" href="../../d2/d7/struct__ONE__RANGE.html">PONE_RANGE</a>;
00054 
<a name="l00055"></a><a class="code" href="../../d8/d4/mtrr_8c.html#a3">00055</a> <span class="preprocessor">#define GROW_RANGE_TABLE    4</span>
00056 <span class="preprocessor"></span>
00057 <span class="comment">//</span>
00058 <span class="comment">// Range in specific mtrr terms</span>
00059 <span class="comment">//</span>
00060 
<a name="l00061"></a><a class="code" href="../../d5/d0/struct__MTRR__RANGE.html">00061</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d5/d0/struct__MTRR__RANGE.html">_MTRR_RANGE</a> {
<a name="l00062"></a><a class="code" href="../../d5/d0/struct__MTRR__RANGE.html#o0">00062</a>     <a class="code" href="../../d6/d0/struct__MTRR__VARIABLE__BASE.html">MTRR_VARIABLE_BASE</a>  <a class="code" href="../../d5/d0/struct__MTRR__RANGE.html#o0">Base</a>;
<a name="l00063"></a><a class="code" href="../../d5/d0/struct__MTRR__RANGE.html#o1">00063</a>     <a class="code" href="../../d9/d0/struct__MTRR__VARIABLE__MASK.html">MTRR_VARIABLE_MASK</a>  <a class="code" href="../../d5/d0/struct__MTRR__RANGE.html#o1">Mask</a>;
00064 } <a class="code" href="../../d5/d0/struct__MTRR__RANGE.html">MTRR_RANGE</a>, *<a class="code" href="../../d5/d0/struct__MTRR__RANGE.html">PMTRR_RANGE</a>;
00065 
00066 <span class="comment">//</span>
00067 <span class="comment">// System static information concerning cached range types</span>
00068 <span class="comment">//</span>
00069 
<a name="l00070"></a><a class="code" href="../../d5/d2/struct__RANGE__INFO.html">00070</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d5/d2/struct__RANGE__INFO.html">_RANGE_INFO</a> {
00071 
00072     <span class="comment">//</span>
00073     <span class="comment">// Global MTRR info</span>
00074     <span class="comment">//</span>
00075 
<a name="l00076"></a><a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o0">00076</a>     <a class="code" href="../../d2/d0/struct__MTRR__DEFAULT.html">MTRR_DEFAULT</a>        <a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o0">Default</a>;            <span class="comment">// h/w mtrr default</span>
<a name="l00077"></a><a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o1">00077</a>     <a class="code" href="../../d9/d9/struct__MTRR__CAPABILITIES.html">MTRR_CAPABILITIES</a>   <a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o1">Capabilities</a>;       <span class="comment">// h/w mtrr Capabilities</span>
<a name="l00078"></a><a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o2">00078</a>     UCHAR               <a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o2">DefaultCachedType</a>;  <span class="comment">// default type for MmCached</span>
00079 
00080     <span class="comment">//</span>
00081     <span class="comment">// Variable MTRR information</span>
00082     <span class="comment">//</span>
00083 
<a name="l00084"></a><a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o3">00084</a>     BOOLEAN             <a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o3">RangesValid</a>;        <span class="comment">// Ranges initialized and valid.</span>
<a name="l00085"></a><a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o4">00085</a>     BOOLEAN             <a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o4">MtrrWorkaround</a>;     <span class="comment">// Work Around needed/not.</span>
<a name="l00086"></a><a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o5">00086</a>     UCHAR               <a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o5">NoRange</a>;            <span class="comment">// No ranges currently in Ranges</span>
<a name="l00087"></a><a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o6">00087</a>     UCHAR               <a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o6">MaxRange</a>;           <span class="comment">// Max size of Ranges</span>
<a name="l00088"></a><a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o7">00088</a>     <a class="code" href="../../d8/d4/mtrr_8c.html#a7">PONE_RANGE</a>          <a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o7">Ranges</a>;             <span class="comment">// Current ranges as set into h/w</span>
00089 
00090 } <a class="code" href="../../d5/d2/struct__RANGE__INFO.html">RANGE_INFO</a>, *<a class="code" href="../../d5/d2/struct__RANGE__INFO.html">PRANGE_INFO</a>;
00091 
00092 
00093 <span class="comment">//</span>
00094 <span class="comment">// Structure used while processing range database</span>
00095 <span class="comment">//</span>
00096 
<a name="l00097"></a><a class="code" href="../../d0/d2/struct__NEW__RANGE.html">00097</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d0/d2/struct__NEW__RANGE.html">_NEW_RANGE</a> {
00098     <span class="comment">//</span>
00099     <span class="comment">// Current Status</span>
00100     <span class="comment">//</span>
00101 
<a name="l00102"></a><a class="code" href="../../d0/d2/struct__NEW__RANGE.html#o0">00102</a>     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>            <a class="code" href="../../d0/d2/struct__NEW__RANGE.html#o0">Status</a>;
00103 
00104     <span class="comment">//</span>
00105     <span class="comment">// Generic info on new range</span>
00106     <span class="comment">//</span>
00107 
<a name="l00108"></a><a class="code" href="../../d0/d2/struct__NEW__RANGE.html#o1">00108</a>     ULONGLONG           <a class="code" href="../../d0/d2/struct__NEW__RANGE.html#o1">Base</a>;
<a name="l00109"></a><a class="code" href="../../d0/d2/struct__NEW__RANGE.html#o2">00109</a>     ULONGLONG           <a class="code" href="../../d0/d2/struct__NEW__RANGE.html#o2">Limit</a>;
<a name="l00110"></a><a class="code" href="../../d0/d2/struct__NEW__RANGE.html#o3">00110</a>     UCHAR               <a class="code" href="../../d0/d2/struct__NEW__RANGE.html#o3">Type</a>;
00111 
00112     <span class="comment">//</span>
00113     <span class="comment">// MTRR image to be set into h/w</span>
00114     <span class="comment">//</span>
00115 
<a name="l00116"></a><a class="code" href="../../d0/d2/struct__NEW__RANGE.html#o4">00116</a>     <a class="code" href="../../d8/d4/mtrr_8c.html#a9">PMTRR_RANGE</a>         <a class="code" href="../../d0/d2/struct__NEW__RANGE.html#o4">MTRR</a>;
00117 
00118     <span class="comment">//</span>
00119     <span class="comment">// RangeDatabase before edits were started</span>
00120     <span class="comment">//</span>
00121 
<a name="l00122"></a><a class="code" href="../../d0/d2/struct__NEW__RANGE.html#o5">00122</a>     UCHAR               <a class="code" href="../../d0/d2/struct__NEW__RANGE.html#o5">NoRange</a>;
<a name="l00123"></a><a class="code" href="../../d0/d2/struct__NEW__RANGE.html#o6">00123</a>     <a class="code" href="../../d8/d4/mtrr_8c.html#a7">PONE_RANGE</a>          <a class="code" href="../../d0/d2/struct__NEW__RANGE.html#o6">Ranges</a>;
00124 
00125     <span class="comment">//</span>
00126     <span class="comment">// IPI context to coordinate concurrent processor update</span>
00127     <span class="comment">//</span>
00128 
<a name="l00129"></a><a class="code" href="../../d0/d2/struct__NEW__RANGE.html#o7">00129</a>     ULONG               <a class="code" href="../../d0/d2/struct__NEW__RANGE.html#o7">NoMTRR</a>;
<a name="l00130"></a><a class="code" href="../../d0/d2/struct__NEW__RANGE.html#o8">00130</a>     ULONG               <a class="code" href="../../d0/d2/struct__NEW__RANGE.html#o8">Processor</a>;
<a name="l00131"></a><a class="code" href="../../d0/d2/struct__NEW__RANGE.html#o9">00131</a>     <span class="keyword">volatile</span> ULONG      <a class="code" href="../../d0/d2/struct__NEW__RANGE.html#o9">TargetCount</a>;
<a name="l00132"></a><a class="code" href="../../d0/d2/struct__NEW__RANGE.html#o10">00132</a>     <span class="keyword">volatile</span> ULONG      *<a class="code" href="../../d0/d2/struct__NEW__RANGE.html#o10">TargetPhase</a>;
00133 
00134 } <a class="code" href="../../d0/d2/struct__NEW__RANGE.html">NEW_RANGE</a>, *<a class="code" href="../../d0/d2/struct__NEW__RANGE.html">PNEW_RANGE</a>;
00135 
00136 <span class="comment">//</span>
00137 <span class="comment">// Prototypes</span>
00138 <span class="comment">//</span>
00139 
00140 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00141 <a class="code" href="../../d8/d4/mtrr_8c.html#a16">KiInitializeMTRR</a> (
00142     IN BOOLEAN LastProcessor
00143     );
00144 
00145 BOOLEAN
00146 <a class="code" href="../../d8/d4/mtrr_8c.html#a17">KiRemoveRange</a> (
00147     IN PNEW_RANGE   NewRange,
00148     IN ULONGLONG    Base,
00149     IN ULONGLONG    Limit,
00150     IN PBOOLEAN     RemoveThisType
00151     );
00152 
00153 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00154 <a class="code" href="../../d8/d4/mtrr_8c.html#a18">KiAddRange</a> (
00155     IN PNEW_RANGE   NewRange,
00156     IN ULONGLONG    Base,
00157     IN ULONGLONG    Limit,
00158     IN UCHAR        Type
00159     );
00160 
00161 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00162 <a class="code" href="../../d8/d4/mtrr_8c.html#a19">KiStartEffectiveRangeChange</a> (
00163     IN PNEW_RANGE   NewRange
00164     );
00165 
00166 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00167 <a class="code" href="../../d8/d4/mtrr_8c.html#a20">KiCompleteEffectiveRangeChange</a> (
00168     IN PNEW_RANGE   NewRange
00169     );
00170 
00171 <a class="code" href="../../d7/d9/assign_8c.html#a3">STATIC</a> ULONG
00172 <a class="code" href="../../d8/d4/mtrr_8c.html#a21">KiRangeWeight</a> (
00173     IN PONE_RANGE   Range
00174     );
00175 
00176 <a class="code" href="../../d7/d9/assign_8c.html#a3">STATIC</a> ULONG
00177 <a class="code" href="../../d8/d4/mtrr_8c.html#a22">KiFindFirstSetLeftBit</a> (
00178     IN ULONGLONG    Set
00179     );
00180 
00181 <a class="code" href="../../d7/d9/assign_8c.html#a3">STATIC</a> ULONG
00182 <a class="code" href="../../d8/d4/mtrr_8c.html#a23">KiFindFirstSetRightBit</a> (
00183     IN ULONGLONG    Set
00184     );
00185 
00186 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00187 <a class="code" href="../../d8/d4/mtrr_8c.html#a24">KiLoadMTRRTarget</a> (
00188     IN PKIPI_CONTEXT SignalDone,
00189     IN PVOID Context,
00190     IN PVOID Parameter2,
00191     IN PVOID Parameter3
00192     );
00193 
00194 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00195 <a class="code" href="../../d0/d5/mtrramd_8c.html#a23">KiLoadMTRR</a> (
00196     IN PNEW_RANGE Context
00197     );
00198 
00199 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00200 <a class="code" href="../../d8/d4/mtrr_8c.html#a26">KiSynchronizeMTRRLoad</a> (
00201     IN PNEW_RANGE   Context
00202     );
00203 
00204 ULONGLONG
00205 <a class="code" href="../../d8/d4/mtrr_8c.html#a27">KiMaskToLength</a> (
00206     IN ULONGLONG    Mask
00207     );
00208 
00209 ULONGLONG
00210 <a class="code" href="../../d8/d4/mtrr_8c.html#a28">KiLengthToMask</a> (
00211     IN ULONGLONG    Length
00212     );
00213 
00214 <span class="preprocessor">#if IDBG</span>
00215 <span class="preprocessor"></span><a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00216 KiDumpMTRR (
00217     PUCHAR      DebugString,
00218     PMTRR_RANGE MTRR
00219     );
00220 <span class="preprocessor">#endif</span>
00221 <span class="preprocessor"></span>
00222 <span class="comment">//</span>
00223 <span class="comment">// --- AMD - Prototypes for AMD K6 MTRR Support functions. ---</span>
00224 <span class="comment">//</span>
00225 
00226 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00227 <a class="code" href="../../d0/d5/mtrramd_8c.html#a26">KiAmdK6MtrrSetMemoryType</a> (
00228     IN ULONG BaseAddress,
00229     IN ULONG NumberOfBytes,
00230     IN MEMORY_CACHING_TYPE CacheType
00231     );
00232 
00233 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00234 <a class="code" href="../../d0/d5/mtrramd_8c.html#a32">KiAmdK6MtrrWRMSR</a> (
00235     VOID
00236     );
00237 
00238 <span class="comment">// --- AMD - End ---</span>
00239 
00240 <span class="preprocessor">#ifdef ALLOC_PRAGMA</span>
00241 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(INIT,KiInitializeMTRR)</span>
00242 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGELK,KiRemoveRange)</span>
00243 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGELK,KiAddRange)</span>
00244 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGELK,KiStartEffectiveRangeChange)</span>
00245 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGELK,KiCompleteEffectiveRangeChange)</span>
00246 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGELK,KiRangeWeight)</span>
00247 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGELK,KiFindFirstSetLeftBit)</span>
00248 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGELK,KiFindFirstSetRightBit)</span>
00249 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGELK,KiLoadMTRR)</span>
00250 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGELK,KiLoadMTRRTarget)</span>
00251 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGELK,KiSynchronizeMTRRLoad)</span>
00252 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGELK,KiLengthToMask)</span>
00253 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGELK,KiMaskToLength)</span>
00254 <span class="preprocessor"></span>
00255 <span class="preprocessor">#if IDBG</span>
00256 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGELK,KiDumpMTRR)</span>
00257 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00258 <span class="preprocessor"></span>
00259 <span class="preprocessor">#endif</span>
00260 <span class="preprocessor"></span>
00261 <span class="comment">//</span>
00262 <span class="comment">// KiRangeLock - Used to synchronize accesses to KiRangeInfo</span>
00263 <span class="comment">//</span>
00264 
<a name="l00265"></a><a class="code" href="../../d8/d4/mtrr_8c.html#a14">00265</a> KSPIN_LOCK          <a class="code" href="../../d8/d4/mtrr_8c.html#a14">KiRangeLock</a>;
00266 
00267 <span class="comment">//</span>
00268 <span class="comment">// KiRangeInfo - Range type mapping information.  Details specific h/w support</span>
00269 <span class="comment">//               and contains the current range database of how physical</span>
00270 <span class="comment">//               addresses have been set</span>
00271 
<a name="l00272"></a><a class="code" href="../../d8/d4/mtrr_8c.html#a15">00272</a> <a class="code" href="../../d5/d2/struct__RANGE__INFO.html">RANGE_INFO</a>          <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>;
00273 
00274 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00275"></a><a class="code" href="../../d6/d9/kernlini_8c.html#a50">00275</a> <a class="code" href="../../d8/d4/mtrr_8c.html#a16">KiInitializeMTRR</a> (
00276     IN BOOLEAN LastProcessor
00277     )
00278 <span class="comment">/*++</span>
00279 <span class="comment"></span>
00280 <span class="comment">Routine Description:</span>
00281 <span class="comment"></span>
00282 <span class="comment">    Called to incrementally initialize the physical range</span>
00283 <span class="comment">    database feature.   First processor's MTRR set is read into the</span>
00284 <span class="comment">    physical range database.</span>
00285 <span class="comment"></span>
00286 <span class="comment">Arguments:</span>
00287 <span class="comment"></span>
00288 <span class="comment">    LastProcessor - If set this is the last processor to execute this routine</span>
00289 <span class="comment">    such that when this processor finishes, the initialization is complete.</span>
00290 <span class="comment"></span>
00291 <span class="comment">Return Value:</span>
00292 <span class="comment"></span>
00293 <span class="comment">    None - if there was a problem the function</span>
00294 <span class="comment">    KeSetPhysicalCacheTypeRange type is disabled.</span>
00295 <span class="comment"></span>
00296 <span class="comment">--*/</span>
00297 {
00298     BOOLEAN             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00299     ULONG               <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>, <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
00300     <a class="code" href="../../d2/d0/struct__MTRR__DEFAULT.html">MTRR_DEFAULT</a>        Default;
00301     <a class="code" href="../../d9/d9/struct__MTRR__CAPABILITIES.html">MTRR_CAPABILITIES</a>   Capabilities;
00302     <a class="code" href="../../d0/d2/struct__NEW__RANGE.html">NEW_RANGE</a>           NewRange;
00303     <a class="code" href="../../d6/d0/struct__MTRR__VARIABLE__BASE.html">MTRR_VARIABLE_BASE</a>  MtrrBase;
00304     <a class="code" href="../../d9/d0/struct__MTRR__VARIABLE__MASK.html">MTRR_VARIABLE_MASK</a>  MtrrMask;
00305     ULONGLONG           Base, Mask, Length;
00306     BOOLEAN             RemoveThisType[<a class="code" href="../../d9/d4/mtrr_8h.html#a11">MTRR_TYPE_MAX</a>];
00307     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>            NtStatus;
00308     PKPRCB              Prcb;
00309 
00310     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00311     RtlZeroMemory (&amp;NewRange, <span class="keyword">sizeof</span> (NewRange));
00312     NewRange.Status = STATUS_UNSUCCESSFUL;
00313 
00314     <span class="comment">//</span>
00315     <span class="comment">// If this is the first processor, initialize some fields</span>
00316     <span class="comment">//</span>
00317 
00318     <span class="keywordflow">if</span> (<a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a1">KeGetPcr</a>()-&gt;Number == 0) {
00319         <a class="code" href="../../d4/d9/ke_8h.html#a354">KeInitializeSpinLock</a> (&amp;<a class="code" href="../../d8/d4/mtrr_8c.html#a14">KiRangeLock</a>);
00320 
00321         <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o1">Capabilities</a>.<a class="code" href="../../d9/d9/struct__MTRR__CAPABILITIES.html#o8">u</a>.QuadPart = <a class="code" href="../../d5/d3/i386_8h.html#a52">RDMSR</a>(<a class="code" href="../../d9/d4/mtrr_8h.html#a0">MTRR_MSR_CAPABILITIES</a>);
00322         <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o0">Default</a>.<a class="code" href="../../d2/d0/struct__MTRR__DEFAULT.html#o8">u</a>.QuadPart = <a class="code" href="../../d5/d3/i386_8h.html#a52">RDMSR</a>(<a class="code" href="../../d9/d4/mtrr_8h.html#a1">MTRR_MSR_DEFAULT</a>);
00323         <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o2">DefaultCachedType</a> = <a class="code" href="../../d9/d4/mtrr_8h.html#a11">MTRR_TYPE_MAX</a>;
00324 
00325         <span class="comment">//</span>
00326         <span class="comment">// If h/w mtrr support is not enabled, disable OS support</span>
00327         <span class="comment">//</span>
00328 
00329         <span class="keywordflow">if</span> (!<a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o0">Default</a>.<a class="code" href="../../d2/d0/struct__MTRR__DEFAULT.html#o8">u</a>.hw.MtrrEnabled ||
00330             <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o1">Capabilities</a>.<a class="code" href="../../d9/d9/struct__MTRR__CAPABILITIES.html#o8">u</a>.hw.VarCnt == 0 ||
00331             <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o0">Default</a>.<a class="code" href="../../d2/d0/struct__MTRR__DEFAULT.html#o8">u</a>.hw.Type != <a class="code" href="../../d9/d4/mtrr_8h.html#a6">MTRR_TYPE_UC</a>) {
00332 
00333             <a class="code" href="../../d7/d9/assign_8c.html#a19">DBGMSG</a>(<span class="stringliteral">"MTRR feature disabled.\n"</span>);
00334             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00335 
00336         } <span class="keywordflow">else</span> {
00337 
00338             <span class="comment">//</span>
00339             <span class="comment">// If USWC type is supported by hardware, but the MTRR</span>
00340             <span class="comment">// feature is not set in KeFeatureBits, it is because</span>
00341             <span class="comment">// the HAL indicated USWC should not be used on this</span>
00342             <span class="comment">// machine.  (Possibly due to shared memory clusters).</span>
00343             <span class="comment">//</span>
00344 
00345             <span class="keywordflow">if</span> (<a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o1">Capabilities</a>.<a class="code" href="../../d9/d9/struct__MTRR__CAPABILITIES.html#o8">u</a>.hw.UswcSupported &amp;&amp;
00346                 ((<a class="code" href="../../d4/d9/ke_8h.html#a137">KeFeatureBits</a> &amp; <a class="code" href="../../d5/d3/i386_8h.html#a6">KF_MTRR</a>) == 0)) {
00347 
00348                 <a class="code" href="../../d7/d9/assign_8c.html#a19">DBGMSG</a>(<span class="stringliteral">"KiInitializeMTRR: MTRR use globally disabled on this machine.\n"</span>);
00349                 <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o1">Capabilities</a>.<a class="code" href="../../d9/d9/struct__MTRR__CAPABILITIES.html#o8">u</a>.hw.UswcSupported = 0;
00350             }
00351 
00352             <span class="comment">//</span>
00353             <span class="comment">// Allocate initial range type database</span>
00354             <span class="comment">//</span>
00355 
00356             <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o5">NoRange</a> = 0;
00357             <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o6">MaxRange</a> = (UCHAR) <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o1">Capabilities</a>.<a class="code" href="../../d9/d9/struct__MTRR__CAPABILITIES.html#o8">u</a>.hw.VarCnt + <a class="code" href="../../d8/d4/mtrr_8c.html#a3">GROW_RANGE_TABLE</a>;
00358             <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o7">Ranges</a> = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a> (<a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>,
00359                                     <span class="keyword">sizeof</span>(<a class="code" href="../../d2/d7/struct__ONE__RANGE.html">ONE_RANGE</a>) * <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o6">MaxRange</a>,
00360                                     '  eK');
00361             RtlZeroMemory (<a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o7">Ranges</a>, <span class="keyword">sizeof</span>(<a class="code" href="../../d8/d4/mtrr_8c.html#a6">ONE_RANGE</a>) * <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o6">MaxRange</a>);
00362         }
00363     }
00364 
00365     <span class="comment">//</span>
00366     <span class="comment">// Workaround for cpu signatures 611, 612, 616 and 617</span>
00367     <span class="comment">// - if the request for setting a variable MTRR specifies</span>
00368     <span class="comment">// an address which is not 4M aligned or length is not</span>
00369     <span class="comment">// a multiple of 4M then possible problem for INVLPG inst.</span>
00370     <span class="comment">// Detect if workaround is required</span>
00371     <span class="comment">//</span>
00372 
00373     Prcb = <a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a2">KeGetCurrentPrcb</a>();
00374     <span class="keywordflow">if</span> (Prcb-&gt;CpuType == 6  &amp;&amp;
00375         (Prcb-&gt;CpuStep == 0x0101 || Prcb-&gt;CpuStep == 0x0102 ||
00376          Prcb-&gt;CpuStep == 0x0106 || Prcb-&gt;CpuStep == 0x0107 )) {
00377 
00378         <span class="keywordflow">if</span> (strcmp(Prcb-&gt;VendorString, <span class="stringliteral">"GenuineIntel"</span>) == 0) {
00379 
00380             <span class="comment">//</span>
00381             <span class="comment">// Only do this if it's an Intel part, other </span>
00382             <span class="comment">// manufacturers may have the same stepping </span>
00383             <span class="comment">// numbers but no bug.</span>
00384             <span class="comment">//</span>
00385 
00386             <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o4">MtrrWorkaround</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00387         }
00388     }
00389 
00390     <span class="comment">//</span>
00391     <span class="comment">// If MTRR support disabled on first processor or if</span>
00392     <span class="comment">// buffer not allocated then fall through</span>
00393     <span class="comment">//</span>
00394 
00395     <span class="keywordflow">if</span> (!<a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o7">Ranges</a>){
00396         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00397     } <span class="keywordflow">else</span> {
00398 
00399         <span class="comment">//</span>
00400         <span class="comment">// Verify MTRR support is symmetric</span>
00401         <span class="comment">//</span>
00402 
00403         Capabilities.<a class="code" href="../../d9/d9/struct__MTRR__CAPABILITIES.html#o8">u</a>.QuadPart = <a class="code" href="../../d5/d3/i386_8h.html#a52">RDMSR</a>(<a class="code" href="../../d9/d4/mtrr_8h.html#a0">MTRR_MSR_CAPABILITIES</a>);
00404 
00405         <span class="keywordflow">if</span> ((Capabilities.<a class="code" href="../../d9/d9/struct__MTRR__CAPABILITIES.html#o8">u</a>.hw.UswcSupported) &amp;&amp;
00406             ((<a class="code" href="../../d4/d9/ke_8h.html#a137">KeFeatureBits</a> &amp; <a class="code" href="../../d5/d3/i386_8h.html#a6">KF_MTRR</a>) == 0)) {
00407             <a class="code" href="../../d7/d9/assign_8c.html#a19">DBGMSG</a> (<span class="stringliteral">"KiInitializeMTRR: setting UswcSupported FALSE\n"</span>);
00408             Capabilities.<a class="code" href="../../d9/d9/struct__MTRR__CAPABILITIES.html#o8">u</a>.hw.UswcSupported = 0;
00409         }
00410 
00411         Default.<a class="code" href="../../d2/d0/struct__MTRR__DEFAULT.html#o8">u</a>.QuadPart = <a class="code" href="../../d5/d3/i386_8h.html#a52">RDMSR</a>(<a class="code" href="../../d9/d4/mtrr_8h.html#a1">MTRR_MSR_DEFAULT</a>);
00412 
00413         <span class="keywordflow">if</span> (Default.<a class="code" href="../../d2/d0/struct__MTRR__DEFAULT.html#o8">u</a>.QuadPart != <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o0">Default</a>.<a class="code" href="../../d2/d0/struct__MTRR__DEFAULT.html#o8">u</a>.QuadPart ||
00414             Capabilities.<a class="code" href="../../d9/d9/struct__MTRR__CAPABILITIES.html#o8">u</a>.QuadPart != <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o1">Capabilities</a>.<a class="code" href="../../d9/d9/struct__MTRR__CAPABILITIES.html#o8">u</a>.QuadPart) {
00415             <a class="code" href="../../d7/d9/assign_8c.html#a19">DBGMSG</a> (<span class="stringliteral">"KiInitializeMTRR: asymmetric mtrr support\n"</span>);
00416             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00417         }
00418     }
00419 
00420     NewRange.Status = STATUS_SUCCESS;
00421 
00422     <span class="comment">//</span>
00423     <span class="comment">// MTRR registers should be identically set on each processor.</span>
00424     <span class="comment">// Ranges should be added to the range database only for one</span>
00425     <span class="comment">// processor.</span>
00426     <span class="comment">//</span>
00427 
00428     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> &amp;&amp; (<a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a1">KeGetPcr</a>()-&gt;Number == 0)) {
00429 <span class="preprocessor">#if IDBG</span>
00430 <span class="preprocessor"></span>        KiDumpMTRR (<span class="stringliteral">"Processor MTRR:"</span>, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00431 <span class="preprocessor">#endif</span>
00432 <span class="preprocessor"></span>
00433         <span class="comment">//</span>
00434         <span class="comment">// Read current MTRR settings for various cached range types</span>
00435         <span class="comment">// and add them to the range database</span>
00436         <span class="comment">//</span>
00437 
00438         <span class="keywordflow">for</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>=0; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &lt; Capabilities.<a class="code" href="../../d9/d9/struct__MTRR__CAPABILITIES.html#o8">u</a>.hw.VarCnt; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>++) {
00439 
00440             MtrrBase.<a class="code" href="../../d6/d0/struct__MTRR__VARIABLE__BASE.html#o7">u</a>.QuadPart = <a class="code" href="../../d5/d3/i386_8h.html#a52">RDMSR</a>(<a class="code" href="../../d9/d4/mtrr_8h.html#a2">MTRR_MSR_VARIABLE_BASE</a>+<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>*2);
00441             MtrrMask.<a class="code" href="../../d9/d0/struct__MTRR__VARIABLE__MASK.html#o7">u</a>.QuadPart = <a class="code" href="../../d5/d3/i386_8h.html#a52">RDMSR</a>(<a class="code" href="../../d9/d4/mtrr_8h.html#a3">MTRR_MSR_VARIABLE_MASK</a>+<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>*2);
00442 
00443             Mask = MtrrMask.<a class="code" href="../../d9/d0/struct__MTRR__VARIABLE__MASK.html#o7">u</a>.QuadPart &amp; <a class="code" href="../../d9/d4/mtrr_8h.html#a13">MTRR_MASK_MASK</a>;
00444             Base = MtrrBase.<a class="code" href="../../d6/d0/struct__MTRR__VARIABLE__BASE.html#o7">u</a>.QuadPart &amp; <a class="code" href="../../d9/d4/mtrr_8h.html#a12">MTRR_MASK_BASE</a>;
00445 
00446             <span class="comment">//</span>
00447             <span class="comment">// Note - the variable MTRR Mask does NOT contain the length</span>
00448             <span class="comment">// spanned by the variable MTRR. Thus just checking the Valid</span>
00449             <span class="comment">// Bit should be sufficient for identifying a valid MTRR.</span>
00450             <span class="comment">//</span>
00451 
00452             <span class="keywordflow">if</span> (MtrrMask.<a class="code" href="../../d9/d0/struct__MTRR__VARIABLE__MASK.html#o7">u</a>.hw.Valid) {
00453 
00454                 Length = <a class="code" href="../../d8/d4/mtrr_8c.html#a27">KiMaskToLength</a>(Mask);
00455 
00456                 <span class="comment">//</span>
00457                 <span class="comment">// Check for non-contiguous MTRR mask.</span>
00458                 <span class="comment">//</span>
00459 
00460                 <span class="keywordflow">if</span> ((Mask + Length) &amp; <a class="code" href="../../d9/d4/mtrr_8h.html#a14">MASK_OVERFLOW_MASK</a>) {
00461                     <a class="code" href="../../d7/d9/assign_8c.html#a19">DBGMSG</a> (<span class="stringliteral">"KiInitializeMTRR: Found non-contiguous MTRR mask!\n"</span>);
00462                     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00463                 }
00464 
00465                 <span class="comment">//</span>
00466                 <span class="comment">// Add this MTRR to the range database</span>
00467                 <span class="comment">//</span>
00468 
00469                 Base &amp;= Mask;
00470                 <a class="code" href="../../d8/d4/mtrr_8c.html#a18">KiAddRange</a> (
00471                     &amp;NewRange,
00472                     Base,
00473                     Base + Length - 1,
00474                     (UCHAR) MtrrBase.<a class="code" href="../../d6/d0/struct__MTRR__VARIABLE__BASE.html#o7">u</a>.hw.Type
00475                     );
00476 
00477                 <span class="comment">//</span>
00478                 <span class="comment">// Check for default cache type</span>
00479                 <span class="comment">//</span>
00480 
00481                 <span class="keywordflow">if</span> (MtrrBase.<a class="code" href="../../d6/d0/struct__MTRR__VARIABLE__BASE.html#o7">u</a>.hw.Type == <a class="code" href="../../d9/d4/mtrr_8h.html#a10">MTRR_TYPE_WB</a>) {
00482                     <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o2">DefaultCachedType</a> = <a class="code" href="../../d9/d4/mtrr_8h.html#a10">MTRR_TYPE_WB</a>;
00483                 }
00484 
00485                 <span class="keywordflow">if</span> (<a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o2">DefaultCachedType</a> == <a class="code" href="../../d9/d4/mtrr_8h.html#a11">MTRR_TYPE_MAX</a>  &amp;&amp;
00486                     MtrrBase.<a class="code" href="../../d6/d0/struct__MTRR__VARIABLE__BASE.html#o7">u</a>.hw.Type == <a class="code" href="../../d9/d4/mtrr_8h.html#a8">MTRR_TYPE_WT</a>) {
00487                     <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o2">DefaultCachedType</a> = <a class="code" href="../../d9/d4/mtrr_8h.html#a8">MTRR_TYPE_WT</a>;
00488                 }
00489             }
00490         }
00491 
00492         <span class="comment">//</span>
00493         <span class="comment">// If a default type for "cached" was not found, assume write-back</span>
00494         <span class="comment">//</span>
00495 
00496         <span class="keywordflow">if</span> (<a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o2">DefaultCachedType</a> == <a class="code" href="../../d9/d4/mtrr_8h.html#a11">MTRR_TYPE_MAX</a>) {
00497             <a class="code" href="../../d7/d9/assign_8c.html#a19">DBGMSG</a> (<span class="stringliteral">"KiInitializeMTRR: assume write-back\n"</span>);
00498             <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o2">DefaultCachedType</a> = <a class="code" href="../../d9/d4/mtrr_8h.html#a10">MTRR_TYPE_WB</a>;
00499         }
00500     }
00501 
00502     <span class="comment">//</span>
00503     <span class="comment">// Done</span>
00504     <span class="comment">//</span>
00505 
00506     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(NewRange.Status)) {
00507         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00508     }
00509 
00510     <span class="keywordflow">if</span> (!<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>) {
00511         <a class="code" href="../../d7/d9/assign_8c.html#a19">DBGMSG</a> (<span class="stringliteral">"KiInitializeMTRR: OS support for MTRRs disabled\n"</span>);
00512         <span class="keywordflow">if</span> (<a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o7">Ranges</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00513             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (<a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o7">Ranges</a>);
00514             <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o7">Ranges</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00515         }
00516     } <span class="keywordflow">else</span> {
00517 
00518         <span class="comment">// if last processor indicate initialization complete</span>
00519         <span class="keywordflow">if</span> (LastProcessor) {
00520             <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o3">RangesValid</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00521         }
00522     }
00523 }
00524 
00525 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00526"></a><a class="code" href="../../d8/d4/mtrr_8c.html#a31">00526</a> <a class="code" href="../../d8/d4/mtrr_8c.html#a31">KeRestoreMtrr</a> (
00527     VOID
00528     )
00529 <span class="comment">/*++</span>
00530 <span class="comment"></span>
00531 <span class="comment">Routine Description:</span>
00532 <span class="comment"></span>
00533 <span class="comment">    This function reloads the MTRR registers to be the current</span>
00534 <span class="comment">    known values.   This is used on a system wakeup to ensure the</span>
00535 <span class="comment">    registers are sane.</span>
00536 <span class="comment"></span>
00537 <span class="comment">    N.B. The caller must have the PAGELK code locked</span>
00538 <span class="comment"></span>
00539 <span class="comment">Arguments:</span>
00540 <span class="comment"></span>
00541 <span class="comment">    none</span>
00542 <span class="comment"></span>
00543 <span class="comment">Return Value:</span>
00544 <span class="comment"></span>
00545 <span class="comment">    none</span>
00546 <span class="comment"></span>
00547 <span class="comment">--*/</span>
00548 {
00549     <a class="code" href="../../d0/d2/struct__NEW__RANGE.html">NEW_RANGE</a>           NewRange;
00550     KIRQL               OldIrql;
00551 
00552     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o3">RangesValid</a>) {
00553         RtlZeroMemory (&amp;NewRange, <span class="keyword">sizeof</span> (NewRange));
00554         <a class="code" href="../../d4/d9/ke_8h.html#a37">KeAcquireSpinLock</a> (&amp;<a class="code" href="../../d8/d4/mtrr_8c.html#a14">KiRangeLock</a>, &amp;OldIrql);
00555         <a class="code" href="../../d8/d4/mtrr_8c.html#a19">KiStartEffectiveRangeChange</a> (&amp;NewRange);
00556         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(NewRange.Status));
00557         <a class="code" href="../../d8/d4/mtrr_8c.html#a20">KiCompleteEffectiveRangeChange</a> (&amp;NewRange);
00558         <a class="code" href="../../d9/d5/verifier_8c.html#a119">KeReleaseSpinLock</a> (&amp;<a class="code" href="../../d8/d4/mtrr_8c.html#a14">KiRangeLock</a>, OldIrql);
00559         <span class="keywordflow">return</span>;
00560     }
00561 
00562         <span class="comment">//</span>
00563         <span class="comment">// If the processor is a AMD K6 with MTRR support then perform</span>
00564         <span class="comment">// processor specific implentaiton.</span>
00565         <span class="comment">//</span>
00566 
00567         <span class="keywordflow">if</span> (<a class="code" href="../../d4/d9/ke_8h.html#a137">KeFeatureBits</a> &amp; <a class="code" href="../../d5/d3/i386_8h.html#a15">KF_AMDK6MTRR</a>) {
00568         <a class="code" href="../../d4/d9/ke_8h.html#a37">KeAcquireSpinLock</a> (&amp;<a class="code" href="../../d8/d4/mtrr_8c.html#a14">KiRangeLock</a>, &amp;OldIrql);
00569                 <a class="code" href="../../d0/d5/mtrramd_8c.html#a23">KiLoadMTRR</a>(<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00570         <a class="code" href="../../d9/d5/verifier_8c.html#a119">KeReleaseSpinLock</a> (&amp;<a class="code" href="../../d8/d4/mtrr_8c.html#a14">KiRangeLock</a>, OldIrql);
00571         }
00572 }
00573 
00574 
00575 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00576"></a><a class="code" href="../../d8/d4/mtrr_8c.html#a32">00576</a> <a class="code" href="../../d8/d4/mtrr_8c.html#a32">KeSetPhysicalCacheTypeRange</a> (
00577     IN PHYSICAL_ADDRESS PhysicalAddress,
00578     IN ULONG NumberOfBytes,
00579     IN MEMORY_CACHING_TYPE CacheType
00580     )
00581 <span class="comment">/*++</span>
00582 <span class="comment"></span>
00583 <span class="comment">Routine Description:</span>
00584 <span class="comment"></span>
00585 <span class="comment">    This function sets a physical range to a particular cache type.</span>
00586 <span class="comment">    If the system does not support setting cache policies based on</span>
00587 <span class="comment">    physical ranges, no action is taken.</span>
00588 <span class="comment"></span>
00589 <span class="comment">Arguments:</span>
00590 <span class="comment"></span>
00591 <span class="comment">    PhysicalAddress - The starting address of the range being set</span>
00592 <span class="comment"></span>
00593 <span class="comment">    NumberOfBytes   - The length, in bytes, of the range being set</span>
00594 <span class="comment"></span>
00595 <span class="comment">    CacheType       - The caching type for which the physical range is</span>
00596 <span class="comment">                      to be set to.</span>
00597 <span class="comment"></span>
00598 <span class="comment">                     NonCached:</span>
00599 <span class="comment">                        Setting ranges to be NonCached is done for</span>
00600 <span class="comment">                        book keeping reasons.  A return of SUCCESS when</span>
00601 <span class="comment">                        setting a range NonCached does not mean it has</span>
00602 <span class="comment">                        been physically set to as NonCached.  The caller</span>
00603 <span class="comment">                        must use a cache-disabled virtual pointer for</span>
00604 <span class="comment">                        any NonCached range.</span>
00605 <span class="comment"></span>
00606 <span class="comment">                     Cached:</span>
00607 <span class="comment">                        A successful return indicates that the physical</span>
00608 <span class="comment">                        range has been set to cached.   This mode requires</span>
00609 <span class="comment">                        the caller to be at irql &lt; dispatch_level.</span>
00610 <span class="comment"></span>
00611 <span class="comment">                     FrameBuffer:</span>
00612 <span class="comment">                        A successful return indicates that the physical</span>
00613 <span class="comment">                        range has been set to be framebuffer cached.</span>
00614 <span class="comment">                        This mode requires the caller to be at irql &lt;</span>
00615 <span class="comment">                        dispatch_level.</span>
00616 <span class="comment"></span>
00617 <span class="comment">                     USWCCached:</span>
00618 <span class="comment">                        This type is to be satisfied only via PAT and</span>
00619 <span class="comment">                        fails for the MTRR interface.</span>
00620 <span class="comment"></span>
00621 <span class="comment">Return Value:</span>
00622 <span class="comment"></span>
00623 <span class="comment">    STATUS_SUCCESS - if success, the cache attributes of the physical range</span>
00624 <span class="comment">                     have been set.</span>
00625 <span class="comment"></span>
00626 <span class="comment">    STATUS_NOT_SUPPORTED - either feature not supported or not yet initialized,</span>
00627 <span class="comment">                           or MmWriteCombined type not supported and is</span>
00628 <span class="comment">                           requested, or input range does not match restrictions</span>
00629 <span class="comment">                           imposed by workarounds for current processor stepping</span>
00630 <span class="comment">                           or is below 1M (in the fixed MTRR range), or not yet</span>
00631 <span class="comment">                           initialized.</span>
00632 <span class="comment"></span>
00633 <span class="comment">    STATUS_UNSUCCESSFUL - Unable to satisfy request due to</span>
00634 <span class="comment">                        - Unable to map software image into limited # of</span>
00635 <span class="comment">                          hardware MTRRs.</span>
00636 <span class="comment">                        - irql was not &lt; DISPATCH_LEVEL.</span>
00637 <span class="comment">                        - Failure due to other internal error (out of memory).</span>
00638 <span class="comment"></span>
00639 <span class="comment">  STATUS_INVALID_PARAMETER - Incorrect input memory type.</span>
00640 <span class="comment"></span>
00641 <span class="comment">--*/</span>
00642 {
00643     KIRQL               OldIrql;
00644     <a class="code" href="../../d0/d2/struct__NEW__RANGE.html">NEW_RANGE</a>           NewRange;
00645     BOOLEAN             RemoveThisType[<a class="code" href="../../d9/d4/mtrr_8h.html#a11">MTRR_TYPE_MAX</a>];
00646     BOOLEAN             EffectRangeChange, AddToRangeDatabase;
00647 
00648     <span class="comment">//</span>
00649     <span class="comment">// If caller has requested the MmUSWCCached memory type then fail</span>
00650     <span class="comment">// - MmUSWCCached is supported via PAT and not otherwise</span>
00651     <span class="comment">//</span>
00652 
00653     <span class="keywordflow">if</span> (CacheType == <a class="code" href="../../d4/d9/ke_8h.html#a413a253">MmUSWCCached</a>) {
00654         <span class="keywordflow">return</span> STATUS_NOT_SUPPORTED;
00655     }
00656 
00657     <span class="comment">//</span>
00658     <span class="comment">// Addresses above 4GB, below 1MB or not page aligned and</span>
00659     <span class="comment">// page length are not supported.</span>
00660     <span class="comment">//</span>
00661 
00662     <span class="keywordflow">if</span> ((PhysicalAddress.HighPart != 0)               ||
00663         (PhysicalAddress.LowPart &lt; (1 * 1024 * 1024)) ||
00664         (PhysicalAddress.LowPart &amp; 0xfff)             ||
00665         (NumberOfBytes &amp; 0xfff)                          ) {
00666         <span class="keywordflow">return</span> STATUS_NOT_SUPPORTED;
00667     }
00668 
00669     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (NumberOfBytes != 0);
00670 
00671         <span class="comment">//</span>
00672         <span class="comment">// If the processor is a AMD K6 with MTRR support then perform</span>
00673         <span class="comment">// processor specific implentaiton.</span>
00674         <span class="comment">//</span>
00675 
00676         <span class="keywordflow">if</span> (<a class="code" href="../../d4/d9/ke_8h.html#a137">KeFeatureBits</a> &amp; <a class="code" href="../../d5/d3/i386_8h.html#a15">KF_AMDK6MTRR</a>) {
00677 
00678             <span class="keywordflow">if</span> ((CacheType != <a class="code" href="../../d4/d9/ke_8h.html#a413a250">MmWriteCombined</a>) &amp;&amp; (CacheType != <a class="code" href="../../d4/d9/ke_8h.html#a413a248">MmNonCached</a>)) {
00679             <span class="keywordflow">return</span> STATUS_NOT_SUPPORTED;
00680         }
00681 
00682                 <span class="keywordflow">return</span> <a class="code" href="../../d0/d5/mtrramd_8c.html#a26">KiAmdK6MtrrSetMemoryType</a>(PhysicalAddress.LowPart,
00683                                                     NumberOfBytes,
00684                                                     CacheType);
00685         }
00686 
00687     <span class="comment">//</span>
00688     <span class="comment">// If processor doesn't have the memory type range feature</span>
00689     <span class="comment">// return not supported.</span>
00690     <span class="comment">//</span>
00691 
00692     <span class="keywordflow">if</span> (!<a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o3">RangesValid</a>) {
00693         <span class="keywordflow">return</span> STATUS_NOT_SUPPORTED;
00694     }
00695 
00696     <span class="comment">//</span>
00697     <span class="comment">// Workaround for cpu signatures 611, 612, 616 and 617</span>
00698     <span class="comment">// - if the request for setting a variable MTRR specifies</span>
00699     <span class="comment">// an address which is not 4M aligned or length is not</span>
00700     <span class="comment">// a multiple of 4M then return status not supported</span>
00701     <span class="comment">//</span>
00702 
00703     <span class="keywordflow">if</span> ((<a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o4">MtrrWorkaround</a>) &amp;&amp;
00704         ((PhysicalAddress.LowPart &amp; 0x3fffff) ||
00705          (NumberOfBytes &amp; 0x3fffff))) {
00706 
00707             <span class="keywordflow">return</span> STATUS_NOT_SUPPORTED;
00708     }
00709 
00710     RtlZeroMemory (&amp;NewRange, <span class="keyword">sizeof</span> (NewRange));
00711     NewRange.Base  = PhysicalAddress.QuadPart;
00712     NewRange.Limit = NewRange.Base + NumberOfBytes - 1;
00713 
00714     <span class="comment">//</span>
00715     <span class="comment">// Determine what the new mtrr range type is.   If setting NonCached then</span>
00716     <span class="comment">// the database need not be updated to reflect the virtual change.  This</span>
00717     <span class="comment">// is because non-cached virtual pointers are mapped as cache disabled.</span>
00718     <span class="comment">//</span>
00719 
00720     EffectRangeChange = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00721     AddToRangeDatabase = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00722     <span class="keywordflow">switch</span> (CacheType) {
00723         <span class="keywordflow">case</span> <a class="code" href="../../d4/d9/ke_8h.html#a413a248">MmNonCached</a>:
00724             NewRange.Type = <a class="code" href="../../d9/d4/mtrr_8h.html#a6">MTRR_TYPE_UC</a>;
00725 
00726             <span class="comment">//</span>
00727             <span class="comment">// NonCached ranges do not need to be reflected into the h/w state</span>
00728             <span class="comment">// as all non-cached ranges are mapped with cache-disabled pointers.</span>
00729             <span class="comment">// This also means that cache-disabled ranges do not need to</span>
00730             <span class="comment">// be put into mtrrs, or held in the range, regardless of the default</span>
00731             <span class="comment">// range type.</span>
00732             <span class="comment">//</span>
00733 
00734             EffectRangeChange = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00735             AddToRangeDatabase = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00736             <span class="keywordflow">break</span>;
00737 
00738         <span class="keywordflow">case</span> <a class="code" href="../../d4/d9/ke_8h.html#a413a249">MmCached</a>:
00739             NewRange.Type = <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o2">DefaultCachedType</a>;
00740             <span class="keywordflow">break</span>;
00741 
00742         <span class="keywordflow">case</span> <a class="code" href="../../d4/d9/ke_8h.html#a413a250">MmWriteCombined</a>:
00743             NewRange.Type = <a class="code" href="../../d9/d4/mtrr_8h.html#a7">MTRR_TYPE_USWC</a>;
00744 
00745             <span class="comment">//</span>
00746             <span class="comment">// If USWC type isn't supported, then request can not be honored</span>
00747             <span class="comment">//</span>
00748 
00749             <span class="keywordflow">if</span> (!<a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o1">Capabilities</a>.<a class="code" href="../../d9/d9/struct__MTRR__CAPABILITIES.html#o8">u</a>.hw.UswcSupported) {
00750                 <a class="code" href="../../d7/d9/assign_8c.html#a19">DBGMSG</a> (<span class="stringliteral">"KeSetPhysicalCacheTypeRange: USWC not supported\n"</span>);
00751                 <span class="keywordflow">return</span> STATUS_NOT_SUPPORTED;
00752             }
00753             <span class="keywordflow">break</span>;
00754 
00755         <span class="keywordflow">default</span>:
00756             <a class="code" href="../../d7/d9/assign_8c.html#a19">DBGMSG</a> (<span class="stringliteral">"KeSetPhysicalCacheTypeRange: no such cache type\n"</span>);
00757             <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
00758             <span class="keywordflow">break</span>;
00759     }
00760 
00761     NewRange.Status = STATUS_SUCCESS;
00762 
00763     <span class="comment">//</span>
00764     <span class="comment">// The default type is UC thus the range is still mapped using</span>
00765     <span class="comment">// a Cache Disabled VirtualPointer and hence it need not be added.</span>
00766     <span class="comment">//</span>
00767 
00768     <span class="comment">//</span>
00769     <span class="comment">// If h/w needs updated, lock down the code required to effect the change</span>
00770     <span class="comment">//</span>
00771 
00772     <span class="keywordflow">if</span> (EffectRangeChange) {
00773         <span class="keywordflow">if</span> (KeGetCurrentIrql() &gt;= <a class="code" href="../../d6/d7/halmips_8h.html#a53">DISPATCH_LEVEL</a>) {
00774 
00775             <span class="comment">//</span>
00776             <span class="comment">// Code can not be locked down.   Supplying a new range type requires</span>
00777             <span class="comment">// that the caller calls at irql &lt; dispatch_level.</span>
00778             <span class="comment">//</span>
00779 
00780             <a class="code" href="../../d7/d9/assign_8c.html#a19">DBGMSG</a> (<span class="stringliteral">"KeSetPhysicalCacheTypeRange failed due to calling IRQL == DISPATCH_LEVEL\n"</span>);
00781             <span class="keywordflow">return</span> STATUS_UNSUCCESSFUL;
00782         }
00783 
00784         <a class="code" href="../../d5/d6/iosup_8c.html#a76">MmLockPagableSectionByHandle</a>(<a class="code" href="../../d5/d8/ex_8h.html#a166">ExPageLockHandle</a>);
00785     }
00786 
00787     <span class="comment">//</span>
00788     <span class="comment">// Serialize the range type database</span>
00789     <span class="comment">//</span>
00790 
00791     <a class="code" href="../../d4/d9/ke_8h.html#a37">KeAcquireSpinLock</a> (&amp;<a class="code" href="../../d8/d4/mtrr_8c.html#a14">KiRangeLock</a>, &amp;OldIrql);
00792 
00793     <span class="comment">//</span>
00794     <span class="comment">// If h/w is going to need updated, then start an effective range change</span>
00795     <span class="comment">//</span>
00796 
00797     <span class="keywordflow">if</span> (EffectRangeChange) {
00798         <a class="code" href="../../d8/d4/mtrr_8c.html#a19">KiStartEffectiveRangeChange</a> (&amp;NewRange);
00799     }
00800 
00801     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a> (NewRange.Status)) {
00802 
00803         <span class="comment">//</span>
00804         <span class="comment">// If the new range is NonCached, then don't remove standard memory</span>
00805         <span class="comment">// caching types</span>
00806         <span class="comment">//</span>
00807 
00808         memset (RemoveThisType, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, <a class="code" href="../../d9/d4/mtrr_8h.html#a11">MTRR_TYPE_MAX</a>);
00809         <span class="keywordflow">if</span> (NewRange.Type != <a class="code" href="../../d9/d4/mtrr_8h.html#a6">MTRR_TYPE_UC</a>) {
00810             <span class="comment">//</span>
00811             <span class="comment">// If the requested type is uncached then the physical</span>
00812             <span class="comment">// memory region is mapped using a cache disabled virtual pointer.</span>
00813             <span class="comment">// The effective memory type for that region will be the lowest</span>
00814             <span class="comment">// common denominator of the MTRR type and the cache type in the</span>
00815             <span class="comment">// PTE.  Therefore for a request of type UC, the effective type</span>
00816             <span class="comment">// will be UC irrespective of the MTRR settings in that range.</span>
00817             <span class="comment">// Hence it is not necessary to remove the existing MTRR settings</span>
00818             <span class="comment">// (if any) for that range.</span>
00819             <span class="comment">//</span>
00820 
00821             <span class="comment">//</span>
00822             <span class="comment">// Clip/remove any ranges in the target area</span>
00823             <span class="comment">//</span>
00824 
00825             <a class="code" href="../../d8/d4/mtrr_8c.html#a17">KiRemoveRange</a> (&amp;NewRange, NewRange.Base, NewRange.Limit, RemoveThisType);
00826         }
00827 
00828         <span class="comment">//</span>
00829         <span class="comment">// If needed, add new range type</span>
00830         <span class="comment">//</span>
00831 
00832         <span class="keywordflow">if</span> (AddToRangeDatabase) {
00833             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (EffectRangeChange == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
00834             <a class="code" href="../../d8/d4/mtrr_8c.html#a18">KiAddRange</a> (&amp;NewRange, NewRange.Base, NewRange.Limit, NewRange.Type);
00835         }
00836 
00837         <span class="comment">//</span>
00838         <span class="comment">// If this is an effect range change, then complete it</span>
00839         <span class="comment">//</span>
00840 
00841         <span class="keywordflow">if</span> (EffectRangeChange) {
00842             <a class="code" href="../../d8/d4/mtrr_8c.html#a20">KiCompleteEffectiveRangeChange</a> (&amp;NewRange);
00843         }
00844     }
00845 
00846     <a class="code" href="../../d9/d5/verifier_8c.html#a119">KeReleaseSpinLock</a> (&amp;<a class="code" href="../../d8/d4/mtrr_8c.html#a14">KiRangeLock</a>, OldIrql);
00847     <span class="keywordflow">if</span> (EffectRangeChange) {
00848         <a class="code" href="../../d5/d6/iosup_8c.html#a81">MmUnlockPagableImageSection</a>(<a class="code" href="../../d5/d8/ex_8h.html#a166">ExPageLockHandle</a>);
00849     }
00850 
00851     <span class="keywordflow">return</span> NewRange.Status;
00852 }
00853 
00854 BOOLEAN
<a name="l00855"></a><a class="code" href="../../d8/d4/mtrr_8c.html#a17">00855</a> <a class="code" href="../../d8/d4/mtrr_8c.html#a17">KiRemoveRange</a> (
00856     IN PNEW_RANGE   NewRange,
00857     IN ULONGLONG    Base,
00858     IN ULONGLONG    Limit,
00859     IN PBOOLEAN     RemoveThisType
00860     )
00861 <span class="comment">/*++</span>
00862 <span class="comment"></span>
00863 <span class="comment">Routine Description:</span>
00864 <span class="comment"></span>
00865 <span class="comment">    This function removes any range overlapping with the passed range, of</span>
00866 <span class="comment">    type supplied in RemoveThisType from the global range database.</span>
00867 <span class="comment"></span>
00868 <span class="comment">Arguments:</span>
00869 <span class="comment"></span>
00870 <span class="comment">    NewRange        - Context information</span>
00871 <span class="comment"></span>
00872 <span class="comment">    Base            - Base &amp; Limit signify the first &amp; last address of a range</span>
00873 <span class="comment">    Limit           - which is to be removed from the range database</span>
00874 <span class="comment"></span>
00875 <span class="comment">    RemoveThisType  - A TRUE flag for each type which can not overlap the</span>
00876 <span class="comment">                      target range</span>
00877 <span class="comment"></span>
00878 <span class="comment"></span>
00879 <span class="comment">Return Value:</span>
00880 <span class="comment"></span>
00881 <span class="comment">    TRUE  - if the range database was altered such that it may no longer</span>
00882 <span class="comment">            be sorted.</span>
00883 <span class="comment"></span>
00884 <span class="comment">--*/</span>
00885 {
00886     ULONG       i;
00887     <a class="code" href="../../d8/d4/mtrr_8c.html#a7">PONE_RANGE</a>  Range;
00888     BOOLEAN     DatabaseNeedsSorted;
00889 
00890 
00891     DatabaseNeedsSorted = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00892 
00893     <span class="comment">//</span>
00894     <span class="comment">// Check each range</span>
00895     <span class="comment">//</span>
00896 
00897     <span class="keywordflow">for</span> (i=0, Range=<a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o7">Ranges</a>; i &lt; <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o5">NoRange</a>; i++, Range++) {
00898 
00899         <span class="comment">//</span>
00900         <span class="comment">// If this range type doesn't need to be altered, skip it</span>
00901         <span class="comment">//</span>
00902 
00903         <span class="keywordflow">if</span> (!RemoveThisType[Range-&gt;Type]) {
00904             <span class="keywordflow">continue</span>;
00905         }
00906 
00907         <span class="comment">//</span>
00908         <span class="comment">// Check range to see if it overlaps with range being removed</span>
00909         <span class="comment">//</span>
00910 
00911         <span class="keywordflow">if</span> (Range-&gt;Base &lt; Base) {
00912 
00913             <span class="keywordflow">if</span> (Range-&gt;Limit &gt;= Base  &amp;&amp;  Range-&gt;Limit &lt;= Limit) {
00914 
00915                 <span class="comment">//</span>
00916                 <span class="comment">// Truncate range to not overlap with area being removed</span>
00917                 <span class="comment">//</span>
00918 
00919                 Range-&gt;Limit = Base - 1;
00920             }
00921 
00922             <span class="keywordflow">if</span> (Range-&gt;Limit &gt; Limit) {
00923 
00924                 <span class="comment">//</span>
00925                 <span class="comment">// Target area is contained totally within this area.</span>
00926                 <span class="comment">// Split into two ranges</span>
00927                 <span class="comment">//</span>
00928 
00929                 <span class="comment">//</span>
00930                 <span class="comment">// Add range at end</span>
00931                 <span class="comment">//</span>
00932 
00933                 DatabaseNeedsSorted = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00934                 <a class="code" href="../../d8/d4/mtrr_8c.html#a18">KiAddRange</a> (
00935                     NewRange,
00936                     Limit+1,
00937                     Range-&gt;Limit,
00938                     Range-&gt;Type
00939                     );
00940 
00941                 <span class="comment">//</span>
00942                 <span class="comment">// Turn current range into range at beginning</span>
00943                 <span class="comment">//</span>
00944 
00945                 Range-&gt;Limit = Base - 1;
00946             }
00947 
00948         } <span class="keywordflow">else</span> {
00949 
00950             <span class="comment">// Range-&gt;Base &gt;= Base</span>
00951 
00952             <span class="keywordflow">if</span> (Range-&gt;Base &lt;= Limit) {
00953                 <span class="keywordflow">if</span> (Range-&gt;Limit &lt;= Limit) {
00954                     <span class="comment">//</span>
00955                     <span class="comment">// This range is totally within the target area.  Remove it.</span>
00956                     <span class="comment">//</span>
00957 
00958                     DatabaseNeedsSorted = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00959                     <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o5">NoRange</a> -= 1;
00960                     Range-&gt;Base  = <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o7">Ranges</a>[<a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o5">NoRange</a>].<a class="code" href="../../d2/d7/struct__ONE__RANGE.html#o0">Base</a>;
00961                     Range-&gt;Limit = <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o7">Ranges</a>[<a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o5">NoRange</a>].<a class="code" href="../../d2/d7/struct__ONE__RANGE.html#o1">Limit</a>;
00962                     Range-&gt;Type = <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o7">Ranges</a>[<a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o5">NoRange</a>].<a class="code" href="../../d2/d7/struct__ONE__RANGE.html#o2">Type</a>;
00963 
00964                     <span class="comment">//</span>
00965                     <span class="comment">// recheck at current location</span>
00966                     <span class="comment">//</span>
00967 
00968                     i -= 1;
00969                     Range -= 1;
00970 
00971                 } <span class="keywordflow">else</span> {
00972 
00973                     <span class="comment">//</span>
00974                     <span class="comment">// Bump beginning past area being removed</span>
00975                     <span class="comment">//</span>
00976 
00977                     Range-&gt;Base = Limit + 1;
00978                 }
00979             }
00980         }
00981     }
00982 
00983     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a> (NewRange-&gt;Status)) {
00984         <a class="code" href="../../d7/d9/assign_8c.html#a19">DBGMSG</a> (<span class="stringliteral">"KiRemoveRange: failure\n"</span>);
00985     }
00986 
00987     <span class="keywordflow">return</span> DatabaseNeedsSorted;
00988 }
00989 
00990 
00991 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00992"></a><a class="code" href="../../d8/d4/mtrr_8c.html#a18">00992</a> <a class="code" href="../../d8/d4/mtrr_8c.html#a18">KiAddRange</a> (
00993     IN PNEW_RANGE   NewRange,
00994     IN ULONGLONG    Base,
00995     IN ULONGLONG    Limit,
00996     IN UCHAR        Type
00997     )
00998 <span class="comment">/*++</span>
00999 <span class="comment"></span>
01000 <span class="comment">Routine Description:</span>
01001 <span class="comment"></span>
01002 <span class="comment">    This function adds the passed range to the global range database.</span>
01003 <span class="comment"></span>
01004 <span class="comment">Arguments:</span>
01005 <span class="comment"></span>
01006 <span class="comment">    NewRange        - Context information</span>
01007 <span class="comment"></span>
01008 <span class="comment">    Base            - Base &amp; Limit signify the first &amp; last address of a range</span>
01009 <span class="comment">    Limit           - which is to be added to the range database</span>
01010 <span class="comment"></span>
01011 <span class="comment">    Type            - Type of caching required for this range</span>
01012 <span class="comment"></span>
01013 <span class="comment">Return Value:</span>
01014 <span class="comment"></span>
01015 <span class="comment">    None - Context is updated with an error if the table has overflowed</span>
01016 <span class="comment"></span>
01017 <span class="comment">--*/</span>
01018 {
01019     <a class="code" href="../../d8/d4/mtrr_8c.html#a7">PONE_RANGE</a>      Range, OldRange;
01020     ULONG           size;
01021 
01022     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o5">NoRange</a> &gt;= <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o6">MaxRange</a>) {
01023 
01024         <span class="comment">//</span>
01025         <span class="comment">// Table is out of space, get a bigger one</span>
01026         <span class="comment">//</span>
01027 
01028         OldRange = <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o7">Ranges</a>;
01029         size = <span class="keyword">sizeof</span>(<a class="code" href="../../d2/d7/struct__ONE__RANGE.html">ONE_RANGE</a>) * (<a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o6">MaxRange</a> + <a class="code" href="../../d8/d4/mtrr_8c.html#a3">GROW_RANGE_TABLE</a>);
01030         Range  = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a> (<a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, size, '  eK');
01031 
01032         <span class="keywordflow">if</span> (!Range) {
01033             NewRange-&gt;Status = STATUS_UNSUCCESSFUL;
01034             <span class="keywordflow">return</span> ;
01035         }
01036 
01037         <span class="comment">//</span>
01038         <span class="comment">// Grow table</span>
01039         <span class="comment">//</span>
01040 
01041         RtlZeroMemory (Range, size);
01042         RtlCopyMemory (Range, OldRange, <span class="keyword">sizeof</span>(<a class="code" href="../../d2/d7/struct__ONE__RANGE.html">ONE_RANGE</a>) * <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o6">MaxRange</a>);
01043         <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o7">Ranges</a> = Range;
01044         <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o6">MaxRange</a> += <a class="code" href="../../d8/d4/mtrr_8c.html#a3">GROW_RANGE_TABLE</a>;
01045         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (OldRange);
01046     }
01047 
01048     <span class="comment">//</span>
01049     <span class="comment">// Add new entry to table</span>
01050     <span class="comment">//</span>
01051 
01052     <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o7">Ranges</a>[<a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o5">NoRange</a>].<a class="code" href="../../d2/d7/struct__ONE__RANGE.html#o0">Base</a> = Base;
01053     <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o7">Ranges</a>[<a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o5">NoRange</a>].<a class="code" href="../../d2/d7/struct__ONE__RANGE.html#o1">Limit</a> = Limit;
01054     <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o7">Ranges</a>[<a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o5">NoRange</a>].<a class="code" href="../../d2/d7/struct__ONE__RANGE.html#o2">Type</a> = Type;
01055     <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o5">NoRange</a> += 1;
01056 }
01057 
01058 
01059 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01060"></a><a class="code" href="../../d8/d4/mtrr_8c.html#a19">01060</a> <a class="code" href="../../d8/d4/mtrr_8c.html#a19">KiStartEffectiveRangeChange</a> (
01061     IN PNEW_RANGE   NewRange
01062     )
01063 <span class="comment">/*++</span>
01064 <span class="comment"></span>
01065 <span class="comment">Routine Description:</span>
01066 <span class="comment"></span>
01067 <span class="comment">    This functions sets up the context information required to</span>
01068 <span class="comment">    track &amp; later effect a range change in hardware</span>
01069 <span class="comment"></span>
01070 <span class="comment">Arguments:</span>
01071 <span class="comment"></span>
01072 <span class="comment">    NewRange        - Context information</span>
01073 <span class="comment"></span>
01074 <span class="comment">Return Value:</span>
01075 <span class="comment"></span>
01076 <span class="comment">    None</span>
01077 <span class="comment"></span>
01078 <span class="comment">--*/</span>
01079 {
01080     ULONG   size;
01081 
01082     <span class="comment">//</span>
01083     <span class="comment">// Allocate working space for MTRR image</span>
01084     <span class="comment">//</span>
01085 
01086     size = <span class="keyword">sizeof</span>(<a class="code" href="../../d5/d0/struct__MTRR__RANGE.html">MTRR_RANGE</a>) * ((ULONG) <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o1">Capabilities</a>.<a class="code" href="../../d9/d9/struct__MTRR__CAPABILITIES.html#o8">u</a>.hw.VarCnt + 1);
01087     NewRange-&gt;MTRR = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a> (<a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, size, '  eK');
01088     <span class="keywordflow">if</span> (!NewRange-&gt;MTRR) {
01089         NewRange-&gt;Status = STATUS_UNSUCCESSFUL;
01090         <span class="keywordflow">return</span> ;
01091     }
01092 
01093     RtlZeroMemory (NewRange-&gt;MTRR, size);
01094 
01095     <span class="comment">//</span>
01096     <span class="comment">// Save current range information in case of an error</span>
01097     <span class="comment">//</span>
01098 
01099     size = <span class="keyword">sizeof</span>(<a class="code" href="../../d2/d7/struct__ONE__RANGE.html">ONE_RANGE</a>) * <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o5">NoRange</a>;
01100     NewRange-&gt;NoRange = <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o5">NoRange</a>;
01101     NewRange-&gt;Ranges = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a> (<a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, size, '  eK');
01102     <span class="keywordflow">if</span> (!NewRange-&gt;Ranges) {
01103         NewRange-&gt;Status = STATUS_UNSUCCESSFUL;
01104         <span class="keywordflow">return</span> ;
01105     }
01106 
01107     RtlCopyMemory (NewRange-&gt;Ranges, <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o7">Ranges</a>, size);
01108 }
01109 
01110 
01111 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01112"></a><a class="code" href="../../d8/d4/mtrr_8c.html#a20">01112</a> <a class="code" href="../../d8/d4/mtrr_8c.html#a20">KiCompleteEffectiveRangeChange</a> (
01113     IN PNEW_RANGE   NewRange
01114     )
01115 <span class="comment">/*++</span>
01116 <span class="comment"></span>
01117 <span class="comment">Routine Description:</span>
01118 <span class="comment"></span>
01119 <span class="comment">    This functions commits the range database to hardware, or backs</span>
01120 <span class="comment">    out the current changes to it.</span>
01121 <span class="comment"></span>
01122 <span class="comment">Arguments:</span>
01123 <span class="comment"></span>
01124 <span class="comment">    NewRange        - Context information</span>
01125 <span class="comment"></span>
01126 <span class="comment">Return Value:</span>
01127 <span class="comment"></span>
01128 <span class="comment">    None</span>
01129 <span class="comment"></span>
01130 <span class="comment">--*/</span>
01131 {
01132     BOOLEAN         Restart;
01133     ULONG           <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>, Index2, RemIndex2, NoMTRR;
01134     ULONGLONG       BestLength, WhichMtrr;
01135     ULONGLONG       CurrLength;
01136     ULONGLONG       l, Base, Length, MLength;
01137     <a class="code" href="../../d8/d4/mtrr_8c.html#a7">PONE_RANGE</a>      Range;
01138     <a class="code" href="../../d2/d7/struct__ONE__RANGE.html">ONE_RANGE</a>       OneRange;
01139     <a class="code" href="../../d8/d4/mtrr_8c.html#a9">PMTRR_RANGE</a>     MTRR;
01140     BOOLEAN         RoundDown;
01141     BOOLEAN         RemoveThisType[<a class="code" href="../../d9/d4/mtrr_8h.html#a11">MTRR_TYPE_MAX</a>];
01142     PKPRCB          Prcb;
01143     KIRQL           OldIrql, OldIrql2;
01144     KAFFINITY       TargetProcessors;
01145 
01146 
01147     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (KeGetCurrentIrql() == <a class="code" href="../../d6/d7/halmips_8h.html#a53">DISPATCH_LEVEL</a>);
01148     Prcb = <a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a2">KeGetCurrentPrcb</a>();
01149 
01150     <span class="comment">//</span>
01151     <span class="comment">// Round all ranges, according to type, to match what h/w can support</span>
01152     <span class="comment">//</span>
01153 
01154     <span class="keywordflow">for</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>=0; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &lt; <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o5">NoRange</a>; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>++) {
01155         Range = &amp;<a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o7">Ranges</a>[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>];
01156 
01157         <span class="comment">//</span>
01158         <span class="comment">// Determine rounding for this range type</span>
01159         <span class="comment">//</span>
01160 
01161         RoundDown = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01162         <span class="keywordflow">if</span> (Range-&gt;<a class="code" href="../../d2/d7/struct__ONE__RANGE.html#o2">Type</a> == <a class="code" href="../../d9/d4/mtrr_8h.html#a6">MTRR_TYPE_UC</a>) {
01163             RoundDown = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01164         }
01165 
01166         <span class="comment">//</span>
01167         <span class="comment">// Apply rounding</span>
01168         <span class="comment">//</span>
01169 
01170         <span class="keywordflow">if</span> (RoundDown) {
01171             Range-&gt;<a class="code" href="../../d2/d7/struct__ONE__RANGE.html#o0">Base</a>  = (Range-&gt;<a class="code" href="../../d2/d7/struct__ONE__RANGE.html#o0">Base</a>  + <a class="code" href="../../d9/d4/mtrr_8h.html#a4">MTRR_PAGE_SIZE</a> - 1) &amp; <a class="code" href="../../d9/d4/mtrr_8h.html#a5">MTRR_PAGE_MASK</a>;
01172             Range-&gt;<a class="code" href="../../d2/d7/struct__ONE__RANGE.html#o1">Limit</a> = ((Range-&gt;<a class="code" href="../../d2/d7/struct__ONE__RANGE.html#o1">Limit</a>+1) &amp; <a class="code" href="../../d9/d4/mtrr_8h.html#a5">MTRR_PAGE_MASK</a>)-1;
01173         } <span class="keywordflow">else</span> {
01174             Range-&gt;<a class="code" href="../../d2/d7/struct__ONE__RANGE.html#o0">Base</a>  = (Range-&gt;<a class="code" href="../../d2/d7/struct__ONE__RANGE.html#o0">Base</a>  &amp; <a class="code" href="../../d9/d4/mtrr_8h.html#a5">MTRR_PAGE_MASK</a>);
01175             Range-&gt;<a class="code" href="../../d2/d7/struct__ONE__RANGE.html#o1">Limit</a> = ((Range-&gt;<a class="code" href="../../d2/d7/struct__ONE__RANGE.html#o1">Limit</a> + <a class="code" href="../../d9/d4/mtrr_8h.html#a4">MTRR_PAGE_SIZE</a>) &amp; <a class="code" href="../../d9/d4/mtrr_8h.html#a5">MTRR_PAGE_MASK</a>)-1;
01176         }
01177     }
01178 
01179     <span class="keywordflow">do</span> {
01180         Restart = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01181 
01182         <span class="comment">//</span>
01183         <span class="comment">// Sort the ranges by base address</span>
01184         <span class="comment">//</span>
01185 
01186         <span class="keywordflow">for</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>=0; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &lt; <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o5">NoRange</a>; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>++) {
01187             Range = &amp;<a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o7">Ranges</a>[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>];
01188 
01189             <span class="keywordflow">for</span> (Index2=<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>+1; Index2 &lt; <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o5">NoRange</a>; Index2++) {
01190 
01191                 <span class="keywordflow">if</span> (<a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o7">Ranges</a>[Index2].<a class="code" href="../../d2/d7/struct__ONE__RANGE.html#o0">Base</a> &lt; Range-&gt;<a class="code" href="../../d2/d7/struct__ONE__RANGE.html#o0">Base</a>) {
01192 
01193                     <span class="comment">//</span>
01194                     <span class="comment">// Swap KiRangeInfo.Ranges[Index] with KiRangeInfo.Ranges[Index2]</span>
01195                     <span class="comment">//</span>
01196 
01197                     OneRange = *Range;
01198                     *Range = <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o7">Ranges</a>[Index2];
01199                     <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o7">Ranges</a>[Index2] = OneRange;
01200                 }
01201             }
01202         }
01203 
01204         <span class="comment">//</span>
01205         <span class="comment">// At this point the range database is sorted on</span>
01206         <span class="comment">// base address. Scan range database combining adjacent and</span>
01207         <span class="comment">// overlapping ranges of the same type</span>
01208         <span class="comment">//</span>
01209 
01210         <span class="keywordflow">for</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>=0; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &lt; (ULONG) <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o5">NoRange</a>-1; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>++) {
01211             Range = &amp;<a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o7">Ranges</a>[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>];
01212 
01213             <span class="comment">//</span>
01214             <span class="comment">// Scan the range database. If ranges are adjacent/overlap and are of</span>
01215             <span class="comment">// the same type, combine them.</span>
01216             <span class="comment">//</span>
01217 
01218             <span class="keywordflow">for</span> (Index2 = <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>+1; Index2 &lt; (ULONG) <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o5">NoRange</a>; Index2++) {
01219 
01220                 l = Range[0].<a class="code" href="../../d2/d7/struct__ONE__RANGE.html#o1">Limit</a> + 1;
01221                 <span class="keywordflow">if</span> (l &lt; Range[0].Limit) {
01222                     l = Range[0].Limit;
01223                 }
01224 
01225                 <span class="keywordflow">if</span> (l &gt;= <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o7">Ranges</a>[Index2].<a class="code" href="../../d2/d7/struct__ONE__RANGE.html#o0">Base</a>  &amp;&amp;
01226                     Range[0].Type == <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o7">Ranges</a>[Index2].<a class="code" href="../../d2/d7/struct__ONE__RANGE.html#o2">Type</a>) {
01227 
01228                     <span class="comment">//</span>
01229                     <span class="comment">// Increase Range[0] limit to cover Range[Index2]</span>
01230                     <span class="comment">//</span>
01231 
01232                     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o7">Ranges</a>[Index2].<a class="code" href="../../d2/d7/struct__ONE__RANGE.html#o1">Limit</a> &gt; Range[0].Limit) {
01233                         Range[0].Limit = <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o7">Ranges</a>[Index2].<a class="code" href="../../d2/d7/struct__ONE__RANGE.html#o1">Limit</a>;
01234                     }
01235 
01236                     <span class="comment">//</span>
01237                     <span class="comment">// Remove KiRangeInfo.Ranges[Index2]</span>
01238                     <span class="comment">//</span>
01239 
01240                     <span class="keywordflow">if</span> (Index2 &lt; (ULONG) <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o5">NoRange</a> - 1 ) {
01241 
01242                         <span class="comment">//</span>
01243                         <span class="comment">// Copy everything from Index2 till end</span>
01244                         <span class="comment">// of range list. # Entries to copy is</span>
01245                         <span class="comment">// (KiRangeInfo.NoRange -1) - (Index2+1) + 1</span>
01246                         <span class="comment">//</span>
01247 
01248                         RtlCopyMemory(
01249                             &amp;(<a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o7">Ranges</a>[Index2]),
01250                             &amp;(<a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o7">Ranges</a>[Index2+1]),
01251                             <span class="keyword">sizeof</span>(<a class="code" href="../../d2/d7/struct__ONE__RANGE.html">ONE_RANGE</a>) * (<a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o5">NoRange</a>-Index2-1)
01252                             );
01253                     }
01254 
01255                     <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o5">NoRange</a> -= 1;
01256 
01257                     <span class="comment">//</span>
01258                     <span class="comment">// Recheck current location</span>
01259                     <span class="comment">//</span>
01260 
01261                     Index2 -= 1;
01262                 }
01263             }
01264         }
01265 
01266         <span class="comment">//</span>
01267         <span class="comment">// At this point the range database is sorted on base</span>
01268         <span class="comment">// address and adjacent/overlapping ranges of the same</span>
01269         <span class="comment">// type are combined. Check for overlapping ranges -</span>
01270         <span class="comment">// If legal then allow else truncate the less "weighty" range</span>
01271         <span class="comment">//</span>
01272 
01273         <span class="keywordflow">for</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = 0; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &lt; (ULONG) <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o5">NoRange</a>-1  &amp;&amp;  !Restart; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>++) {
01274 
01275             Range = &amp;<a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o7">Ranges</a>[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>];
01276 
01277             l = Range[0].<a class="code" href="../../d2/d7/struct__ONE__RANGE.html#o1">Limit</a> + 1;
01278             <span class="keywordflow">if</span> (l &lt; Range[0].Limit) {
01279                 l = Range[0].Limit;
01280             }
01281 
01282             <span class="comment">//</span>
01283             <span class="comment">// If ranges overlap and are not of same type, and if the</span>
01284             <span class="comment">// overlap is not legal then carve them to the best cache type</span>
01285             <span class="comment">// available.</span>
01286             <span class="comment">//</span>
01287 
01288             <span class="keywordflow">for</span> (Index2 = <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>+1; Index2 &lt; (ULONG) <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o5">NoRange</a> &amp;&amp; !Restart; Index2++) {
01289 
01290                 <span class="keywordflow">if</span> (l &gt; <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o7">Ranges</a>[Index2].<a class="code" href="../../d2/d7/struct__ONE__RANGE.html#o0">Base</a>) {
01291 
01292                     <span class="keywordflow">if</span> (Range[0].Type == <a class="code" href="../../d9/d4/mtrr_8h.html#a6">MTRR_TYPE_UC</a> ||
01293                         <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o7">Ranges</a>[Index2].<a class="code" href="../../d2/d7/struct__ONE__RANGE.html#o2">Type</a> == <a class="code" href="../../d9/d4/mtrr_8h.html#a6">MTRR_TYPE_UC</a>) {
01294 
01295                         <span class="comment">//</span>
01296                         <span class="comment">// Overlap of a UC type with a range of any other type is</span>
01297                         <span class="comment">// legal</span>
01298                         <span class="comment">//</span>
01299 
01300                     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((Range[0].Type == <a class="code" href="../../d9/d4/mtrr_8h.html#a8">MTRR_TYPE_WT</a> &amp;&amp;
01301                                 <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o7">Ranges</a>[Index2].<a class="code" href="../../d2/d7/struct__ONE__RANGE.html#o2">Type</a> == <a class="code" href="../../d9/d4/mtrr_8h.html#a10">MTRR_TYPE_WB</a>) ||
01302                                (Range[0].Type == <a class="code" href="../../d9/d4/mtrr_8h.html#a10">MTRR_TYPE_WB</a> &amp;&amp;
01303                                 <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o7">Ranges</a>[Index2].<a class="code" href="../../d2/d7/struct__ONE__RANGE.html#o2">Type</a> == <a class="code" href="../../d9/d4/mtrr_8h.html#a8">MTRR_TYPE_WT</a>) ) {
01304                         <span class="comment">//</span>
01305                         <span class="comment">// Overlap of WT and WB range is legal. The overlap range will</span>
01306                         <span class="comment">// be WT.</span>
01307                         <span class="comment">//</span>
01308 
01309                     } <span class="keywordflow">else</span> {
01310 
01311                         <span class="comment">//</span>
01312                         <span class="comment">// This is an illegal overlap and we need to carve the ranges</span>
01313                         <span class="comment">// to remove the overlap.</span>
01314                         <span class="comment">//</span>
01315                         <span class="comment">// Pick range which has the cache type which should be used for</span>
01316                         <span class="comment">// the overlapped area</span>
01317                         <span class="comment">//</span>
01318 
01319                         <span class="keywordflow">if</span> (<a class="code" href="../../d8/d4/mtrr_8c.html#a21">KiRangeWeight</a>(&amp;Range[0]) &gt; <a class="code" href="../../d8/d4/mtrr_8c.html#a21">KiRangeWeight</a>(&amp;(<a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o7">Ranges</a>[Index2]))){
01320                             RemIndex2 = Index2;
01321                         } <span class="keywordflow">else</span> {
01322                             RemIndex2 = <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
01323                         }
01324 
01325                         <span class="comment">//</span>
01326                         <span class="comment">// Remove ranges of type which do not belong in the overlapped area</span>
01327                         <span class="comment">//</span>
01328 
01329                         RtlZeroMemory (RemoveThisType, <a class="code" href="../../d9/d4/mtrr_8h.html#a11">MTRR_TYPE_MAX</a>);
01330                         RemoveThisType[<a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o7">Ranges</a>[RemIndex2].<a class="code" href="../../d2/d7/struct__ONE__RANGE.html#o2">Type</a>] = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01331 
01332                         <span class="comment">//</span>
01333                         <span class="comment">// Remove just the overlapped portion of the range.</span>
01334                         <span class="comment">//</span>
01335 
01336                         Restart = <a class="code" href="../../d8/d4/mtrr_8c.html#a17">KiRemoveRange</a> (
01337                            NewRange,
01338                            <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o7">Ranges</a>[Index2].<a class="code" href="../../d2/d7/struct__ONE__RANGE.html#o0">Base</a>,
01339                            (Range[0].Limit &lt; <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o7">Ranges</a>[Index2].<a class="code" href="../../d2/d7/struct__ONE__RANGE.html#o1">Limit</a> ?
01340                                     Range[0].Limit : <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o7">Ranges</a>[Index2].<a class="code" href="../../d2/d7/struct__ONE__RANGE.html#o1">Limit</a>),
01341                            RemoveThisType
01342                            );
01343                     }
01344                 }
01345             }
01346         }
01347 
01348     } <span class="keywordflow">while</span> (Restart);
01349 
01350     <span class="comment">//</span>
01351     <span class="comment">// The range database is now rounded to fit in the h/w and sorted.</span>
01352     <span class="comment">// Attempt to build MTRR settings which exactly describe the ranges</span>
01353     <span class="comment">//</span>
01354 
01355     MTRR = NewRange-&gt;MTRR;
01356     NoMTRR = 0;
01357     <span class="keywordflow">for</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>=0;<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(NewRange-&gt;Status)&amp;&amp; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>&lt;<a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o5">NoRange</a>;<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>++) {
01358         Range = &amp;<a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o7">Ranges</a>[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>];
01359 
01360         <span class="comment">//</span>
01361         <span class="comment">// Build MTRRs to fit this range</span>
01362         <span class="comment">//</span>
01363 
01364         Base   = Range-&gt;<a class="code" href="../../d2/d7/struct__ONE__RANGE.html#o0">Base</a>;
01365         Length = Range-&gt;<a class="code" href="../../d2/d7/struct__ONE__RANGE.html#o1">Limit</a> - Base + 1;
01366 
01367         <span class="keywordflow">while</span> (Length) {
01368 
01369             <span class="comment">//</span>
01370             <span class="comment">// Compute MTRR length for current range base &amp; length</span>
01371             <span class="comment">//</span>
01372 
01373             <span class="keywordflow">if</span> (Base == 0) {
01374                 MLength = Length;
01375             } <span class="keywordflow">else</span> {
01376                 MLength = (ULONGLONG) 1 &lt;&lt; <a class="code" href="../../d8/d4/mtrr_8c.html#a23">KiFindFirstSetRightBit</a>(Base);
01377             }
01378             <span class="keywordflow">if</span> (MLength &gt; Length) {
01379                 MLength = Length;
01380             }
01381 
01382             l = (ULONGLONG) 1 &lt;&lt; <a class="code" href="../../d8/d4/mtrr_8c.html#a22">KiFindFirstSetLeftBit</a> (MLength);
01383             <span class="keywordflow">if</span> (MLength &gt; l) {
01384                 MLength = l;
01385             }
01386 
01387             <span class="comment">//</span>
01388             <span class="comment">// Store it in the next MTRR</span>
01389             <span class="comment">//</span>
01390 
01391             MTRR[NoMTRR].<a class="code" href="../../d5/d0/struct__MTRR__RANGE.html#o0">Base</a>.<a class="code" href="../../d6/d0/struct__MTRR__VARIABLE__BASE.html#o7">u</a>.QuadPart = Base;
01392             MTRR[NoMTRR].<a class="code" href="../../d5/d0/struct__MTRR__RANGE.html#o0">Base</a>.<a class="code" href="../../d6/d0/struct__MTRR__VARIABLE__BASE.html#o7">u</a>.hw.Type  = Range-&gt;<a class="code" href="../../d2/d7/struct__ONE__RANGE.html#o2">Type</a>;
01393             MTRR[NoMTRR].<a class="code" href="../../d5/d0/struct__MTRR__RANGE.html#o1">Mask</a>.<a class="code" href="../../d9/d0/struct__MTRR__VARIABLE__MASK.html#o7">u</a>.QuadPart = <a class="code" href="../../d8/d4/mtrr_8c.html#a28">KiLengthToMask</a>(MLength);
01394             MTRR[NoMTRR].<a class="code" href="../../d5/d0/struct__MTRR__RANGE.html#o1">Mask</a>.<a class="code" href="../../d9/d0/struct__MTRR__VARIABLE__MASK.html#o7">u</a>.hw.Valid = 1;
01395             NoMTRR += 1;
01396 
01397             <span class="comment">//</span>
01398             <span class="comment">// Adjust off amount of data covered by that last MTRR</span>
01399             <span class="comment">//</span>
01400 
01401             Base += MLength;
01402             Length -= MLength;
01403 
01404             <span class="comment">//</span>
01405             <span class="comment">// If there are too many MTRRs, and currently setting a</span>
01406             <span class="comment">// Non-USWC range try to remove a USWC MTRR.</span>
01407             <span class="comment">// (ie, convert some MmWriteCombined to MmNonCached).</span>
01408             <span class="comment">//</span>
01409 
01410             <span class="keywordflow">if</span> (NoMTRR &gt; (ULONG) <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o1">Capabilities</a>.<a class="code" href="../../d9/d9/struct__MTRR__CAPABILITIES.html#o8">u</a>.hw.VarCnt) {
01411 
01412                 <span class="keywordflow">if</span> (Range-&gt;<a class="code" href="../../d2/d7/struct__ONE__RANGE.html#o2">Type</a> != <a class="code" href="../../d9/d4/mtrr_8h.html#a7">MTRR_TYPE_USWC</a>) {
01413 
01414                     <span class="comment">//</span>
01415                     <span class="comment">// Find smallest USWC type and drop it</span>
01416                     <span class="comment">//</span>
01417                     <span class="comment">// This is okay only if the default type is UC.</span>
01418                     <span class="comment">// Default type should always be UC unless BIOS changes</span>
01419                     <span class="comment">// it. Still ASSERT!</span>
01420                     <span class="comment">//</span>
01421 
01422                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(<a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o0">Default</a>.<a class="code" href="../../d2/d0/struct__MTRR__DEFAULT.html#o8">u</a>.hw.Type == <a class="code" href="../../d9/d4/mtrr_8h.html#a6">MTRR_TYPE_UC</a>);
01423 
01424                     BestLength = (ULONGLONG) 1 &lt;&lt; (<a class="code" href="../../d9/d4/mtrr_8h.html#a16">MTRR_MAX_RANGE_SHIFT</a> + 1);
01425 
01426                     <span class="keywordflow">for</span> (Index2=0; Index2 &lt; <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o1">Capabilities</a>.<a class="code" href="../../d9/d9/struct__MTRR__CAPABILITIES.html#o8">u</a>.hw.VarCnt; Index2++) {
01427 
01428                         <span class="keywordflow">if</span> (MTRR[Index2].<a class="code" href="../../d5/d0/struct__MTRR__RANGE.html#o0">Base</a>.<a class="code" href="../../d6/d0/struct__MTRR__VARIABLE__BASE.html#o7">u</a>.hw.Type == <a class="code" href="../../d9/d4/mtrr_8h.html#a7">MTRR_TYPE_USWC</a>) {
01429 
01430                             CurrLength = <a class="code" href="../../d8/d4/mtrr_8c.html#a27">KiMaskToLength</a>(MTRR[Index2].Mask.u.QuadPart &amp;
01431                                                  <a class="code" href="../../d9/d4/mtrr_8h.html#a13">MTRR_MASK_MASK</a>);
01432 
01433                             <span class="keywordflow">if</span> (CurrLength &lt; BestLength) {
01434                                 WhichMtrr = Index2;
01435                                 BestLength = CurrLength;
01436                             }
01437                         }
01438                     }
01439 
01440                     <span class="keywordflow">if</span> (BestLength == ((ULONGLONG) 1 &lt;&lt; (<a class="code" href="../../d9/d4/mtrr_8h.html#a16">MTRR_MAX_RANGE_SHIFT</a> + 1))) {
01441                         <span class="comment">//</span>
01442                         <span class="comment">// Range was not found which could be dropped.  Abort process</span>
01443                         <span class="comment">//</span>
01444 
01445                         NewRange-&gt;Status = STATUS_UNSUCCESSFUL;
01446                         Length = 0;
01447 
01448                     } <span class="keywordflow">else</span> {
01449                         <span class="comment">//</span>
01450                         <span class="comment">// Remove WhichMtrr</span>
01451                         <span class="comment">//</span>
01452 
01453                         NoMTRR -= 1;
01454                         MTRR[WhichMtrr] = MTRR[NoMTRR];
01455                     }
01456 
01457                 } <span class="keywordflow">else</span> {
01458 
01459                     NewRange-&gt;Status = STATUS_UNSUCCESSFUL;
01460                     Length =0;
01461                 }
01462             }
01463         }
01464     }
01465 
01466     <span class="comment">//</span>
01467     <span class="comment">// Done building new MTRRs</span>
01468     <span class="comment">//</span>
01469 
01470     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(NewRange-&gt;Status)) {
01471 
01472         <span class="comment">//</span>
01473         <span class="comment">// Update the MTRRs on all processors</span>
01474         <span class="comment">//</span>
01475 
01476 <span class="preprocessor">#if IDBG</span>
01477 <span class="preprocessor"></span>        KiDumpMTRR (<span class="stringliteral">"Loading the following MTRR:"</span>, NewRange-&gt;MTRR);
01478 <span class="preprocessor">#endif</span>
01479 <span class="preprocessor"></span>
01480         NewRange-&gt;TargetCount = 0;
01481         NewRange-&gt;TargetPhase = &amp;Prcb-&gt;ReverseStall;
01482         NewRange-&gt;Processor = Prcb-&gt;Number;
01483 
01484         <span class="comment">//</span>
01485         <span class="comment">// Previously enabled MTRRs with index &gt; NoMTRR</span>
01486         <span class="comment">// which could conflict with existing setting should be disabled</span>
01487         <span class="comment">// This is taken care of by setting NewRange-&gt;NoMTRR to total</span>
01488         <span class="comment">// number of variable MTRRs.</span>
01489         <span class="comment">//</span>
01490 
01491         NewRange-&gt;NoMTRR = (ULONG) <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o1">Capabilities</a>.<a class="code" href="../../d9/d9/struct__MTRR__CAPABILITIES.html#o8">u</a>.hw.VarCnt;
01492 
01493         <span class="comment">//</span>
01494         <span class="comment">// Synchronize with other IPI functions which may stall</span>
01495         <span class="comment">//</span>
01496 
01497         <a class="code" href="../../d0/d0/ki_8h.html#a11">KiLockContextSwap</a>(&amp;OldIrql);
01498 
01499 <span class="preprocessor">#if !defined(NT_UP)</span>
01500 <span class="preprocessor"></span>        <span class="comment">//</span>
01501         <span class="comment">// Collect all the (other) processors</span>
01502         <span class="comment">//</span>
01503 
01504         TargetProcessors = <a class="code" href="../../d4/d9/ke_8h.html#a123">KeActiveProcessors</a> &amp; ~Prcb-&gt;SetMember;
01505         <span class="keywordflow">if</span> (TargetProcessors != 0) {
01506 
01507             KiIpiSendSynchronousPacket (
01508                 Prcb,
01509                 TargetProcessors,
01510                 <a class="code" href="../../d8/d4/mtrr_8c.html#a24">KiLoadMTRRTarget</a>,
01511                 (PVOID) NewRange,
01512                 <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
01513                 <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>
01514                 );
01515 
01516             <span class="comment">//</span>
01517             <span class="comment">// Wait for all processors to be collected</span>
01518             <span class="comment">//</span>
01519 
01520             <a class="code" href="../../d2/d1/xipi_8c.html#a2">KiIpiStallOnPacketTargets</a>(TargetProcessors);
01521 
01522             <span class="comment">//</span>
01523             <span class="comment">// All processors are now waiting.  Raise to high level to</span>
01524             <span class="comment">// ensure this processor doesn't enter the debugger due to</span>
01525             <span class="comment">// some interrupt service routine.</span>
01526             <span class="comment">//</span>
01527 
01528             <a class="code" href="../../d9/d5/verifier_8c.html#a116">KeRaiseIrql</a> (<a class="code" href="../../d6/d7/halmips_8h.html#a57">HIGH_LEVEL</a>, &amp;OldIrql2);
01529 
01530             <span class="comment">//</span>
01531             <span class="comment">// There's no reason for any debug events now, so signal</span>
01532             <span class="comment">// the other processors that they can all disable interrupts</span>
01533             <span class="comment">// and being the MTRR update</span>
01534             <span class="comment">//</span>
01535 
01536             Prcb-&gt;ReverseStall += 1;
01537         }
01538 <span class="preprocessor">#endif</span>
01539 <span class="preprocessor"></span>
01540         <span class="comment">//</span>
01541         <span class="comment">// Update MTRRs</span>
01542         <span class="comment">//</span>
01543 
01544         <a class="code" href="../../d0/d5/mtrramd_8c.html#a23">KiLoadMTRR</a> (NewRange);
01545 
01546         <span class="comment">//</span>
01547         <span class="comment">// Release ContextSwap lock</span>
01548         <span class="comment">//</span>
01549 
01550         <a class="code" href="../../d0/d0/ki_8h.html#a12">KiUnlockContextSwap</a>(OldIrql);
01551 
01552 
01553 <span class="preprocessor">#if IDBG</span>
01554 <span class="preprocessor"></span>        KiDumpMTRR (<span class="stringliteral">"Processor MTRR:"</span>, NewRange-&gt;MTRR);
01555 <span class="preprocessor">#endif</span>
01556 <span class="preprocessor"></span>
01557     } <span class="keywordflow">else</span> {
01558 
01559         <span class="comment">//</span>
01560         <span class="comment">// There was an error, put original range database back</span>
01561         <span class="comment">//</span>
01562 
01563         <a class="code" href="../../d7/d9/assign_8c.html#a19">DBGMSG</a> (<span class="stringliteral">"KiCompleteEffectiveRangeChange: mtrr update did not occur\n"</span>);
01564 
01565         <span class="keywordflow">if</span> (NewRange-&gt;Ranges) {
01566             <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o5">NoRange</a> = NewRange-&gt;NoRange;
01567 
01568             RtlCopyMemory (
01569                 <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o7">Ranges</a>,
01570                 NewRange-&gt;Ranges,
01571                 sizeof (<a class="code" href="../../d2/d7/struct__ONE__RANGE.html">ONE_RANGE</a>) * <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o5">NoRange</a>
01572                 );
01573         }
01574     }
01575 
01576     <span class="comment">//</span>
01577     <span class="comment">// Cleanup</span>
01578     <span class="comment">//</span>
01579 
01580     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (NewRange-&gt;Ranges);
01581     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (NewRange-&gt;MTRR);
01582 }
01583 
01584 
01585 <a class="code" href="../../d7/d9/assign_8c.html#a3">STATIC</a> ULONG
<a name="l01586"></a><a class="code" href="../../d8/d4/mtrr_8c.html#a21">01586</a> <a class="code" href="../../d8/d4/mtrr_8c.html#a21">KiRangeWeight</a> (
01587     IN PONE_RANGE   Range
01588     )
01589 <span class="comment">/*++</span>
01590 <span class="comment"></span>
01591 <span class="comment">Routine Description:</span>
01592 <span class="comment"></span>
01593 <span class="comment">    This functions returns a weighting of the passed in range's cache</span>
01594 <span class="comment">    type.   When two or more regions collide within the same h/w region</span>
01595 <span class="comment">    the types are weighted and that cache type of the higher weight</span>
01596 <span class="comment">    is used for the collision area.</span>
01597 <span class="comment"></span>
01598 <span class="comment">Arguments:</span>
01599 <span class="comment"></span>
01600 <span class="comment">    Range   - Range to obtain weighting for</span>
01601 <span class="comment"></span>
01602 <span class="comment">Return Value:</span>
01603 <span class="comment"></span>
01604 <span class="comment">    The weight of the particular cache type</span>
01605 <span class="comment"></span>
01606 <span class="comment">--*/</span>
01607 {
01608     ULONG   Weight;
01609 
01610     <span class="keywordflow">switch</span> (Range-&gt;Type) {
01611         <span class="keywordflow">case</span> <a class="code" href="../../d9/d4/mtrr_8h.html#a6">MTRR_TYPE_UC</a>:      Weight = 5;     <span class="keywordflow">break</span>;
01612         <span class="keywordflow">case</span> <a class="code" href="../../d9/d4/mtrr_8h.html#a7">MTRR_TYPE_USWC</a>:    Weight = 4;     <span class="keywordflow">break</span>;
01613         <span class="keywordflow">case</span> <a class="code" href="../../d9/d4/mtrr_8h.html#a9">MTRR_TYPE_WP</a>:      Weight = 3;     <span class="keywordflow">break</span>;
01614         <span class="keywordflow">case</span> <a class="code" href="../../d9/d4/mtrr_8h.html#a8">MTRR_TYPE_WT</a>:      Weight = 2;     <span class="keywordflow">break</span>;
01615         <span class="keywordflow">case</span> <a class="code" href="../../d9/d4/mtrr_8h.html#a10">MTRR_TYPE_WB</a>:      Weight = 1;     <span class="keywordflow">break</span>;
01616         <span class="keywordflow">default</span>:                Weight = 0;     <span class="keywordflow">break</span>;
01617     }
01618 
01619     <span class="keywordflow">return</span> Weight;
01620 }
01621 
01622 
01623 <a class="code" href="../../d7/d9/assign_8c.html#a3">STATIC</a> ULONGLONG
<a name="l01624"></a><a class="code" href="../../d8/d4/mtrr_8c.html#a27">01624</a> <a class="code" href="../../d8/d4/mtrr_8c.html#a27">KiMaskToLength</a> (
01625     IN ULONGLONG    Mask
01626     )
01627 <span class="comment">/*++</span>
01628 <span class="comment"></span>
01629 <span class="comment">Routine Description:</span>
01630 <span class="comment"></span>
01631 <span class="comment">    This function returns the length specified by a particular</span>
01632 <span class="comment">    mtrr variable register mask.</span>
01633 <span class="comment"></span>
01634 <span class="comment">--*/</span>
01635 {
01636     <span class="keywordflow">if</span> (Mask == 0) {
01637         <span class="comment">// Zero Mask signifies a length of      2**36</span>
01638         <span class="keywordflow">return</span>(((ULONGLONG) 1 &lt;&lt; <a class="code" href="../../d9/d4/mtrr_8h.html#a16">MTRR_MAX_RANGE_SHIFT</a>));
01639     } <span class="keywordflow">else</span> {
01640         <span class="keywordflow">return</span>(((ULONGLONG) 1 &lt;&lt; <a class="code" href="../../d8/d4/mtrr_8c.html#a23">KiFindFirstSetRightBit</a>(Mask)));
01641     }
01642 }
01643 
01644 <a class="code" href="../../d7/d9/assign_8c.html#a3">STATIC</a> ULONGLONG
<a name="l01645"></a><a class="code" href="../../d8/d4/mtrr_8c.html#a28">01645</a> <a class="code" href="../../d8/d4/mtrr_8c.html#a28">KiLengthToMask</a> (
01646     IN ULONGLONG    Length
01647     )
01648 <span class="comment">/*++</span>
01649 <span class="comment"></span>
01650 <span class="comment">Routine Description:</span>
01651 <span class="comment"></span>
01652 <span class="comment">    This function constructs the mask corresponding to the input length</span>
01653 <span class="comment">    to be set in a variable MTRR register. The length is assumed to be</span>
01654 <span class="comment">    a multiple of 4K.</span>
01655 <span class="comment"></span>
01656 <span class="comment">--*/</span>
01657 {
01658     ULONGLONG FullMask = 0xffffff;
01659 
01660     <span class="keywordflow">if</span> (Length == ((ULONGLONG) 1 &lt;&lt; <a class="code" href="../../d9/d4/mtrr_8h.html#a16">MTRR_MAX_RANGE_SHIFT</a>)) {
01661         <span class="keywordflow">return</span>(0);
01662     } <span class="keywordflow">else</span> {
01663         <span class="keywordflow">return</span>(((FullMask &lt;&lt; <a class="code" href="../../d8/d4/mtrr_8c.html#a23">KiFindFirstSetRightBit</a>(Length)) &amp;
01664             <a class="code" href="../../d9/d4/mtrr_8h.html#a15">MTRR_RESVBIT_MASK</a>));
01665     }
01666 }
01667 
01668 <a class="code" href="../../d7/d9/assign_8c.html#a3">STATIC</a> ULONG
<a name="l01669"></a><a class="code" href="../../d8/d4/mtrr_8c.html#a23">01669</a> <a class="code" href="../../d8/d4/mtrr_8c.html#a23">KiFindFirstSetRightBit</a> (
01670     IN ULONGLONG    Set
01671     )
01672 <span class="comment">/*++</span>
01673 <span class="comment"></span>
01674 <span class="comment">Routine Description:</span>
01675 <span class="comment"></span>
01676 <span class="comment">    This function returns a bit position of the least significant</span>
01677 <span class="comment">    bit set in the passed ULONGLONG parameter. Passed parameter</span>
01678 <span class="comment">    must be non-zero.</span>
01679 <span class="comment"></span>
01680 <span class="comment">--*/</span>
01681 {
01682     ULONG   bitno;
01683 
01684     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(Set != 0);
01685     <span class="keywordflow">for</span> (bitno=0; !(Set &amp; 0xFF); bitno += 8, Set &gt;&gt;= 8) ;
01686     <span class="keywordflow">return</span> <a class="code" href="../../d8/d0/hivecell_8c.html#a5">KiFindFirstSetRight</a>[Set &amp; 0xFF] + bitno;
01687 }
01688 
01689 <a class="code" href="../../d7/d9/assign_8c.html#a3">STATIC</a> ULONG
<a name="l01690"></a><a class="code" href="../../d8/d4/mtrr_8c.html#a22">01690</a> <a class="code" href="../../d8/d4/mtrr_8c.html#a22">KiFindFirstSetLeftBit</a> (
01691     IN ULONGLONG    Set
01692     )
01693 <span class="comment">/*++</span>
01694 <span class="comment"></span>
01695 <span class="comment">Routine Description:</span>
01696 <span class="comment"></span>
01697 <span class="comment">    This function returns a bit position of the most significant</span>
01698 <span class="comment">    bit set in the passed ULONGLONG parameter. Passed parameter</span>
01699 <span class="comment">    must be non-zero.</span>
01700 <span class="comment"></span>
01701 <span class="comment">--*/</span>
01702 {
01703     ULONG   bitno;
01704 
01705     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(Set != 0);
01706     <span class="keywordflow">for</span> (bitno=56;!(Set &amp; 0xFF00000000000000); bitno -= 8, Set &lt;&lt;= 8) ;
01707     <span class="keywordflow">return</span> <a class="code" href="../../d8/d0/hivecell_8c.html#a6">KiFindFirstSetLeft</a>[Set &gt;&gt; 56] + bitno;
01708 }
01709 
01710 <span class="preprocessor">#if IDBG</span>
01711 <span class="preprocessor"></span><a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01712 KiDumpMTRR (
01713     PUCHAR          DebugString,
01714     PMTRR_RANGE     MTRR
01715     )
01716 <span class="comment">/*++</span>
01717 <span class="comment"></span>
01718 <span class="comment">Routine Description:</span>
01719 <span class="comment"></span>
01720 <span class="comment">    This function dumps the MTRR information to the debugger</span>
01721 <span class="comment"></span>
01722 <span class="comment">--*/</span>
01723 {
01724     <span class="keyword">static</span> PUCHAR Type[] = {
01725     <span class="comment">//  0       1       2       3       4       5       6</span>
01726         <span class="stringliteral">"UC  "</span>, <span class="stringliteral">"USWC"</span>, <span class="stringliteral">"????"</span>, <span class="stringliteral">"????"</span>, <span class="stringliteral">"WT  "</span>, <span class="stringliteral">"WP  "</span>, <span class="stringliteral">"WB  "</span> };
01727     <a class="code" href="../../d6/d0/struct__MTRR__VARIABLE__BASE.html">MTRR_VARIABLE_BASE</a>  Base;
01728     <a class="code" href="../../d9/d0/struct__MTRR__VARIABLE__MASK.html">MTRR_VARIABLE_MASK</a>  Mask;
01729     ULONG       <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
01730     ULONG       i;
01731     PUCHAR      p;
01732 
01733     <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a> (<span class="stringliteral">"%s\n"</span>, DebugString);
01734     <span class="keywordflow">for</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>=0; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &lt; (ULONG) <a class="code" href="../../d8/d4/mtrr_8c.html#a15">KiRangeInfo</a>.<a class="code" href="../../d5/d2/struct__RANGE__INFO.html#o1">Capabilities</a>.<a class="code" href="../../d9/d9/struct__MTRR__CAPABILITIES.html#o8">u</a>.hw.VarCnt; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>++) {
01735         <span class="keywordflow">if</span> (MTRR) {
01736             Base = MTRR[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].<a class="code" href="../../d5/d0/struct__MTRR__RANGE.html#o0">Base</a>;
01737             Mask = MTRR[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].Mask;
01738         } <span class="keywordflow">else</span> {
01739             Base.<a class="code" href="../../d6/d0/struct__MTRR__VARIABLE__BASE.html#o7">u</a>.QuadPart = <a class="code" href="../../d5/d3/i386_8h.html#a52">RDMSR</a>(MTRR_MSR_VARIABLE_BASE+2*Index);
01740             Mask.<a class="code" href="../../d9/d0/struct__MTRR__VARIABLE__MASK.html#o7">u</a>.QuadPart = <a class="code" href="../../d5/d3/i386_8h.html#a52">RDMSR</a>(MTRR_MSR_VARIABLE_MASK+2*Index);
01741         }
01742 
01743         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a> (<span class="stringliteral">"  %d. "</span>, Index);
01744         <span class="keywordflow">if</span> (Mask.<a class="code" href="../../d9/d0/struct__MTRR__VARIABLE__MASK.html#o7">u</a>.hw.Valid) {
01745             p = <span class="stringliteral">"????"</span>;
01746             <span class="keywordflow">if</span> (Base.<a class="code" href="../../d6/d0/struct__MTRR__VARIABLE__BASE.html#o7">u</a>.hw.Type &lt; 7) {
01747                 p = Type[Base.<a class="code" href="../../d6/d0/struct__MTRR__VARIABLE__BASE.html#o7">u</a>.hw.Type];
01748             }
01749 
01750             <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a> (<span class="stringliteral">"%s  %08x:%08x  %08x:%08x"</span>,
01751                 p,
01752                 (ULONG) (Base.<a class="code" href="../../d6/d0/struct__MTRR__VARIABLE__BASE.html#o7">u</a>.QuadPart &gt;&gt; 32),
01753                 ((ULONG) (Base.<a class="code" href="../../d6/d0/struct__MTRR__VARIABLE__BASE.html#o7">u</a>.QuadPart &amp; MTRR_MASK_BASE)),
01754                 (ULONG) (Mask.<a class="code" href="../../d9/d0/struct__MTRR__VARIABLE__MASK.html#o7">u</a>.QuadPart &gt;&gt; 32),
01755                 ((ULONG) (Mask.<a class="code" href="../../d9/d0/struct__MTRR__VARIABLE__MASK.html#o7">u</a>.QuadPart &amp; MTRR_MASK_MASK))
01756                 );
01757 
01758         }
01759         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a> (<span class="stringliteral">"\n"</span>);
01760     }
01761 }
01762 <span class="preprocessor">#endif</span>
01763 <span class="preprocessor"></span>
01764 
01765 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01766"></a><a class="code" href="../../d8/d4/mtrr_8c.html#a24">01766</a> <a class="code" href="../../d8/d4/mtrr_8c.html#a24">KiLoadMTRRTarget</a> (
01767     IN PKIPI_CONTEXT SignalDone,
01768     IN PVOID NewRange,
01769     IN PVOID Parameter2,
01770     IN PVOID Parameter3
01771     )
01772 {
01773     <a class="code" href="../../d8/d4/mtrr_8c.html#a13">PNEW_RANGE</a> Context;
01774 
01775     Context = (<a class="code" href="../../d8/d4/mtrr_8c.html#a13">PNEW_RANGE</a>) NewRange;
01776 
01777     <span class="comment">//</span>
01778     <span class="comment">// Wait for all processors to be ready</span>
01779     <span class="comment">//</span>
01780 
01781     KiIpiSignalPacketDoneAndStall (SignalDone, Context-&gt;<a class="code" href="../../d0/d2/struct__NEW__RANGE.html#o10">TargetPhase</a>);
01782 
01783     <span class="comment">//</span>
01784     <span class="comment">// Update MTRRs</span>
01785     <span class="comment">//</span>
01786 
01787     <a class="code" href="../../d0/d5/mtrramd_8c.html#a23">KiLoadMTRR</a> (Context);
01788 }
01789 
01790 
01791 
<a name="l01792"></a><a class="code" href="../../d8/d4/mtrr_8c.html#a4">01792</a> <span class="preprocessor">#define MOV_EAX_CR4   _emit { 0Fh, 20h, E0h }</span>
<a name="l01793"></a><a class="code" href="../../d8/d4/mtrr_8c.html#a5">01793</a> <span class="preprocessor"></span><span class="preprocessor">#define MOV_CR4_EAX   _emit { 0Fh, 22h, E0h }</span>
01794 <span class="preprocessor"></span>
01795 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l01796"></a><a class="code" href="../../d8/d4/mtrr_8c.html#a25">01796</a> <a class="code" href="../../d0/d5/mtrramd_8c.html#a23">KiLoadMTRR</a> (
01797     IN PNEW_RANGE Context
01798     )
01799 <span class="comment">/*++</span>
01800 <span class="comment"></span>
01801 <span class="comment">Routine Description:</span>
01802 <span class="comment"></span>
01803 <span class="comment">    This function loads the memory type range registers into all processors</span>
01804 <span class="comment"></span>
01805 <span class="comment">Arguments:</span>
01806 <span class="comment"></span>
01807 <span class="comment">    Context     - Context which include the MTRRs to load</span>
01808 <span class="comment"></span>
01809 <span class="comment">Return Value:</span>
01810 <span class="comment"></span>
01811 <span class="comment">    All processors are set into the new state</span>
01812 <span class="comment"></span>
01813 <span class="comment">--*/</span>
01814 {
01815     <a class="code" href="../../d2/d0/struct__MTRR__DEFAULT.html">MTRR_DEFAULT</a>        Default;
01816     BOOLEAN             Enable;
01817     ULONG               HldCr0, HldCr4;
01818     ULONG               <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
01819 
01820     <span class="comment">//</span>
01821     <span class="comment">// Disable interrupts</span>
01822     <span class="comment">//</span>
01823 
01824     Enable = <a class="code" href="../../d0/d0/ki_8h.html#a106">KiDisableInterrupts</a>();
01825 
01826     <span class="comment">//</span>
01827     <span class="comment">// Synchronize all processors</span>
01828     <span class="comment">//</span>
01829 
01830         <span class="keywordflow">if</span> (!(<a class="code" href="../../d4/d9/ke_8h.html#a137">KeFeatureBits</a> &amp; <a class="code" href="../../d5/d3/i386_8h.html#a15">KF_AMDK6MTRR</a>)) {
01831         <a class="code" href="../../d8/d4/mtrr_8c.html#a26">KiSynchronizeMTRRLoad</a> (Context);
01832     }
01833 
01834     _asm {
01835         ;
01836         ; Get current CR0
01837         ;
01838 
01839         mov     eax, cr0
01840         mov     HldCr0, eax
01841 
01842         ;
01843         ; Disable caching &amp; line fill
01844         ;
01845 
01846         and     eax, not CR0_NW
01847         or      eax, CR0_CD
01848         mov     cr0, eax
01849 
01850         ;
01851         ; Flush caches
01852         ;
01853 
01854         ;
01855         ; wbinvd
01856         ;
01857 
01858         _emit 0Fh
01859         _emit 09h
01860 
01861         ;
01862         ; Get current cr4
01863         ;
01864 
01865         _emit  0Fh
01866         _emit  20h
01867         _emit  0E0h             ; mov eax, cr4
01868         mov     HldCr4, eax
01869 
01870         ;
01871         ; Disable global page
01872         ;
01873 
01874         and     eax, not CR4_PGE
01875         _emit  0Fh
01876         _emit  22h
01877         _emit  0E0h             ; mov cr4, eax
01878 
01879         ;
01880         ; Flush TLB
01881         ;
01882 
01883         mov     eax, cr3
01884         mov     cr3, eax
01885     }
01886 
01887         <span class="keywordflow">if</span> (<a class="code" href="../../d4/d9/ke_8h.html#a137">KeFeatureBits</a> &amp; <a class="code" href="../../d5/d3/i386_8h.html#a15">KF_AMDK6MTRR</a>) {
01888 
01889         <span class="comment">//</span>
01890         <span class="comment">// Write the MTRRs</span>
01891         <span class="comment">//</span>
01892 
01893         <a class="code" href="../../d0/d5/mtrramd_8c.html#a32">KiAmdK6MtrrWRMSR</a>();
01894 
01895         } <span class="keywordflow">else</span> {
01896 
01897         <span class="comment">//</span>
01898         <span class="comment">// Disable MTRRs</span>
01899         <span class="comment">//</span>
01900 
01901         Default.<a class="code" href="../../d2/d0/struct__MTRR__DEFAULT.html#o8">u</a>.QuadPart = <a class="code" href="../../d5/d3/i386_8h.html#a52">RDMSR</a>(<a class="code" href="../../d9/d4/mtrr_8h.html#a1">MTRR_MSR_DEFAULT</a>);
01902         Default.<a class="code" href="../../d2/d0/struct__MTRR__DEFAULT.html#o8">u</a>.hw.MtrrEnabled = 0;
01903         <a class="code" href="../../d5/d3/i386_8h.html#a53">WRMSR</a> (<a class="code" href="../../d9/d4/mtrr_8h.html#a1">MTRR_MSR_DEFAULT</a>, Default.<a class="code" href="../../d2/d0/struct__MTRR__DEFAULT.html#o8">u</a>.QuadPart);
01904 
01905         <span class="comment">//</span>
01906         <span class="comment">// Synchronize all processors</span>
01907         <span class="comment">//</span>
01908 
01909         <a class="code" href="../../d8/d4/mtrr_8c.html#a26">KiSynchronizeMTRRLoad</a> (Context);
01910 
01911         <span class="comment">//</span>
01912         <span class="comment">// Load new MTRRs</span>
01913         <span class="comment">//</span>
01914 
01915         <span class="keywordflow">for</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>=0; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &lt; Context-&gt;NoMTRR; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>++) {
01916             <a class="code" href="../../d5/d3/i386_8h.html#a53">WRMSR</a> (<a class="code" href="../../d9/d4/mtrr_8h.html#a2">MTRR_MSR_VARIABLE_BASE</a>+2*<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>, Context-&gt;MTRR[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].Base.u.QuadPart);
01917             <a class="code" href="../../d5/d3/i386_8h.html#a53">WRMSR</a> (<a class="code" href="../../d9/d4/mtrr_8h.html#a3">MTRR_MSR_VARIABLE_MASK</a>+2*<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>, Context-&gt;MTRR[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].Mask.u.QuadPart);
01918         }
01919 
01920         <span class="comment">//</span>
01921         <span class="comment">// Synchronize all processors</span>
01922         <span class="comment">//</span>
01923 
01924         <a class="code" href="../../d8/d4/mtrr_8c.html#a26">KiSynchronizeMTRRLoad</a> (Context);
01925         }
01926     _asm {
01927 
01928         ;
01929         ; Flush caches (<span class="keyword">this</span> should be a <span class="stringliteral">"nop"</span>, but <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> was in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Intel reference algorithm)
01930         ; This <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> required because of aggressive prefetch of both instr + data
01931         ;
01932 
01933         ;
01934         ; wbinvd
01935         ;
01936 
01937         _emit 0Fh
01938         _emit 09h
01939 
01940         ;
01941         ; Flush TLBs (same comment as above)
01942         ; Same explanation as above
01943         ;
01944 
01945         mov     eax, cr3
01946         mov     cr3, eax
01947     }
01948 
01949         <span class="keywordflow">if</span> (!(<a class="code" href="../../d4/d9/ke_8h.html#a137">KeFeatureBits</a> &amp; <a class="code" href="../../d5/d3/i386_8h.html#a15">KF_AMDK6MTRR</a>)) {
01950 
01951         <span class="comment">//</span>
01952         <span class="comment">// Enable MTRRs</span>
01953         <span class="comment">//</span>
01954 
01955         Default.<a class="code" href="../../d2/d0/struct__MTRR__DEFAULT.html#o8">u</a>.hw.MtrrEnabled = 1;
01956         <a class="code" href="../../d5/d3/i386_8h.html#a53">WRMSR</a> (<a class="code" href="../../d9/d4/mtrr_8h.html#a1">MTRR_MSR_DEFAULT</a>, Default.<a class="code" href="../../d2/d0/struct__MTRR__DEFAULT.html#o8">u</a>.QuadPart);
01957 
01958         <span class="comment">//</span>
01959         <span class="comment">// Synchronize all processors</span>
01960         <span class="comment">//</span>
01961 
01962         <a class="code" href="../../d8/d4/mtrr_8c.html#a26">KiSynchronizeMTRRLoad</a> (Context);
01963     }
01964 
01965     _asm {
01966         ;
01967         ; Restore CR4 (global page enable)
01968         ;
01969 
01970         mov     eax, HldCr4
01971         _emit  0Fh
01972         _emit  22h
01973         _emit  0E0h             ; mov cr4, eax
01974 
01975         ;
01976         ; Restore CR0 (cache enable)
01977         ;
01978 
01979         mov     eax, HldCr0
01980         mov     cr0, eax
01981     }
01982 
01983     <span class="comment">//</span>
01984     <span class="comment">// Restore interrupts and return</span>
01985     <span class="comment">//</span>
01986 
01987     <a class="code" href="../../d0/d0/ki_8h.html#a107">KiRestoreInterrupts</a> (Enable);
01988     <span class="keywordflow">return</span> STATUS_SUCCESS;
01989 }
01990 
01991 
01992 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01993"></a><a class="code" href="../../d8/d4/mtrr_8c.html#a26">01993</a> <a class="code" href="../../d8/d4/mtrr_8c.html#a26">KiSynchronizeMTRRLoad</a> (
01994     IN PNEW_RANGE   Context
01995     )
01996 {
01997 
01998 <span class="preprocessor">#if !defined(NT_UP)</span>
01999 <span class="preprocessor"></span>
02000     ULONG               CurrentPhase;
02001     <span class="keyword">volatile</span> ULONG      *TargetPhase;
02002     PKPRCB              Prcb;
02003 
02004     TargetPhase = Context-&gt;TargetPhase;
02005     Prcb = <a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a2">KeGetCurrentPrcb</a>();
02006 
02007     <span class="keywordflow">if</span> (Prcb-&gt;Number == (CCHAR) Context-&gt;Processor) {
02008 
02009         <span class="comment">//</span>
02010         <span class="comment">// Wait for all processors to signal</span>
02011         <span class="comment">//</span>
02012 
02013         <span class="keywordflow">while</span> (Context-&gt;TargetCount != (ULONG) <a class="code" href="../../d4/d9/ke_8h.html#a133">KeNumberProcessors</a> - 1) {
02014             KeYieldProcessor ();
02015         }
02016 
02017         <span class="comment">//</span>
02018         <span class="comment">// Reset count for next time</span>
02019         <span class="comment">//</span>
02020 
02021         Context-&gt;TargetCount = 0;
02022 
02023         <span class="comment">//</span>
02024         <span class="comment">// Let waiting processor go to next synchronization point</span>
02025         <span class="comment">//</span>
02026 
02027         InterlockedIncrement ((PULONG) TargetPhase);
02028 
02029 
02030     } <span class="keywordflow">else</span> {
02031 
02032         <span class="comment">//</span>
02033         <span class="comment">// Get current phase</span>
02034         <span class="comment">//</span>
02035 
02036         CurrentPhase = *TargetPhase;
02037 
02038         <span class="comment">//</span>
02039         <span class="comment">// Signal that we have completed the current phase</span>
02040         <span class="comment">//</span>
02041 
02042         InterlockedIncrement ((PULONG) &amp;Context-&gt;TargetCount);
02043 
02044         <span class="comment">//</span>
02045         <span class="comment">// Wait for new phase to begin</span>
02046         <span class="comment">//</span>
02047 
02048         <span class="keywordflow">while</span> (*TargetPhase == CurrentPhase) {
02049             KeYieldProcessor ();
02050         }
02051     }
02052 
02053 <span class="preprocessor">#endif</span>
02054 <span class="preprocessor"></span>
02055 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:40:53 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
