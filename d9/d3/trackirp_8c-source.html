<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: trackirp.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>trackirp.c</h1><a href="../../d8/d4/trackirp_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1998  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    trackirp.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module tracks irps and verified drivers when people do stupid things with</span>
00012 <span class="comment">    them.</span>
00013 <span class="comment"></span>
00014 <span class="comment">    Note to people hitting bugs in these code paths due to core changes:</span>
00015 <span class="comment"></span>
00016 <span class="comment">    -   "This file is NOT vital to operation of the OS, and could easily be</span>
00017 <span class="comment">         disabled while a redesign to compensate for the core change is</span>
00018 <span class="comment">         implemented." - the author</span>
00019 <span class="comment"></span>
00020 <span class="comment">Author:</span>
00021 <span class="comment"></span>
00022 <span class="comment">    Adrian J. Oney (adriao) 09-May-1998</span>
00023 <span class="comment"></span>
00024 <span class="comment">Environment:</span>
00025 <span class="comment"></span>
00026 <span class="comment">    Kernel mode</span>
00027 <span class="comment"></span>
00028 <span class="comment">Revision History:</span>
00029 <span class="comment"></span>
00030 <span class="comment">Known BUGBUGs:</span>
00031 <span class="comment"></span>
00032 <span class="comment">    ADRIAO BUGBUG   #07 05/11/98 - Add a pass-through filter at every attach.</span>
00033 <span class="comment">    ADRIAO BUGBUG   #05 05/12/98 - Find a way to check pends when not forced.</span>
00034 <span class="comment">    ADRIAO BUGBUG   #17 05/30/98 - WMI IRPs may assert second time erroneously.</span>
00035 <span class="comment">    ADRIAO BUGBUG   #28 06/10/98 - Need to find a better way to id SCSI SRBs</span>
00036 <span class="comment">    ADRIAO BUGBUG       08/16/98 - Pass on quota charging iff appropriate...</span>
00037 <span class="comment">    ADRIAO BUGBUG       08/19/98 - Don't use hardcoded number.</span>
00038 <span class="comment"></span>
00039 <span class="comment">Known HACKHACKs:</span>
00040 <span class="comment"></span>
00041 <span class="comment">    ADRIAO HACKHACK #05 05/30/98 - Create IRPs aren't surrogated as MUP chokes.</span>
00042 <span class="comment">                                   (HACKHACK_FOR_MUP)</span>
00043 <span class="comment">    ADRIAO HACKHACK #10 06/12/98 - Scsiport never skips, so I rip too much to boot.</span>
00044 <span class="comment">                                   (HACKHACK_FOR_SCSIPORT)</span>
00045 <span class="comment"></span>
00046 <span class="comment">--*/</span>
00047 
00048 <span class="preprocessor">#include "<a class="code" href="../../d0/d6/iop_8h.html">iop.h</a>"</span>
00049 
00050 <span class="preprocessor">#if (( defined(_X86_) ) &amp;&amp; ( FPO ))</span>
00051 <span class="preprocessor"></span><span class="preprocessor">#pragma optimize( "y", off )    // disable FPO for consistent stack traces</span>
00052 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00053 <span class="preprocessor"></span>
<a name="l00054"></a><a class="code" href="../../d8/d4/trackirp_8c.html#a0">00054</a> <span class="preprocessor">#define POOL_TAG_DEFERRED_CONTEXT   'dprI'</span>
00055 <span class="preprocessor"></span>
<a name="l00056"></a><a class="code" href="../../d8/d4/trackirp_8c.html#a1">00056</a> <span class="preprocessor">#define HACKHACK_FOR_MUP</span>
<a name="l00057"></a><a class="code" href="../../d8/d4/trackirp_8c.html#a2">00057</a> <span class="preprocessor"></span><span class="preprocessor">#define HACKHACK_FOR_SCSIPORT</span>
<a name="l00058"></a><a class="code" href="../../d8/d4/trackirp_8c.html#a3">00058</a> <span class="preprocessor"></span><span class="preprocessor">#define HACKHACK_FOR_ACPI</span>
<a name="l00059"></a><a class="code" href="../../d8/d4/trackirp_8c.html#a4">00059</a> <span class="preprocessor"></span><span class="preprocessor">#define HACKHACK_FOR_BOGUSIRPS</span>
00060 <span class="preprocessor"></span>
00061 <span class="comment">//</span>
00062 <span class="comment">// This entire file is only present if NO_SPECIAL_IRP isn't defined</span>
00063 <span class="comment">//</span>
00064 <span class="preprocessor">#ifndef NO_SPECIAL_IRP</span>
00065 <span class="preprocessor"></span>
00066 <span class="comment">//</span>
00067 <span class="comment">// When enabled, everything is locked down on demand...</span>
00068 <span class="comment">//</span>
00069 <span class="preprocessor">#ifdef ALLOC_PRAGMA</span>
00070 <span class="preprocessor"></span><span class="comment">//#pragma alloc_text(NONPAGE, IovpDoAssertIrps)</span>
00071 <span class="preprocessor">#pragma alloc_text(PAGE,     IovpInitIrpTracking)</span>
00072 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,     IovpReexamineAllStacks)</span>
00073 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY, IovpCallDriver1)</span>
00074 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY, IovpCallDriver2)</span>
00075 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY, IovpCompleteRequest1)</span>
00076 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY, IovpCompleteRequest2)</span>
00077 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY, IovpCompleteRequest3)</span>
00078 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY, IovpCompleteRequest4)</span>
00079 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY, IovpCompleteRequest5)</span>
00080 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY, IovpCompleteRequest)</span>
00081 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY, IovpCancelIrp)</span>
00082 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY, IovpFreeIrp)</span>
00083 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY, IovpAllocateIrp1)</span>
00084 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY, IovpAllocateIrp2)</span>
00085 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY, IovpInitializeIrp)</span>
00086 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY, IovpAttachDeviceToDeviceStack)</span>
00087 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY, IovpDetachDevice)</span>
00088 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY, IovpDeleteDevice)</span>
00089 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY, IovpInternalCompletionTrap)</span>
00090 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY, IovpSwapSurrogateIrp)</span>
00091 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY, IovpProtectedIrpAllocate)</span>
00092 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY, IovpProtectedIrpMakeTouchable)</span>
00093 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY, IovpProtectedIrpMakeUntouchable)</span>
00094 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY, IovpProtectedIrpFree)</span>
00095 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY, IovpExamineDevObjForwarding)</span>
00096 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY, IovpExamineIrpStackForwarding)</span>
00097 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY, IovpGetDeviceAttachedTo)</span>
00098 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY, IovpGetLowestDevice)</span>
00099 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY, IovpAssertNonLegacyDevice)</span>
00100 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY, IovpIsInFdoStack)</span>
00101 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY, IovpSeedStack)</span>
00102 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY, IovpSeedOnePage)</span>
00103 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY, IovpSeedTwoPages)</span>
00104 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY, IovpSeedThreePages)</span>
00105 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY, IovpInternalDeferredCompletion)</span>
00106 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY, IovpInternalCompleteAfterWait)</span>
00107 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY, IovpInternalCompleteAtDPC)</span>
00108 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY, IovpAdvanceStackDownwards)</span>
00109 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY, IovpEnumDevObjCallback)</span>
00110 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY, IovpIsInterestingStack)</span>
00111 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY, IovpIsInterestingDriver)</span>
00112 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00113 <span class="preprocessor"></span>
00114 <span class="comment">//</span>
00115 <span class="comment">// These flags control the tracking features and which hacks are enabled.</span>
00116 <span class="comment">// Both values will be set to the appropriate values if they are found</span>
00117 <span class="comment">// to be -1 at boot time. If they are changed at ^K time they will not</span>
00118 <span class="comment">// be subsequently overridden. 7FFFFFFF and 0 will do the maximum level</span>
00119 <span class="comment">// of testing...</span>
00120 <span class="comment">//</span>
<a name="l00121"></a><a class="code" href="../../d8/d4/trackirp_8c.html#a7">00121</a> ULONG <a class="code" href="../../d8/d4/trackirp_8c.html#a7">IovpTrackingFlags</a> = 0; <span class="comment">//(ULONG) -1;</span>
<a name="l00122"></a><a class="code" href="../../d8/d4/trackirp_8c.html#a8">00122</a> ULONG <a class="code" href="../../d8/d4/trackirp_8c.html#a8">IovpHackFlags</a> = (ULONG) -1;
00123 
00124 <span class="comment">//</span>
00125 <span class="comment">// This global flag is set if assertions have been enabled. It will never</span>
00126 <span class="comment">// transition from TRUE to FALSE, so it is safe to do a quick check for</span>
00127 <span class="comment">// TRUE outside a spinlock. Furthermore, a false "FALSE" is guarenteed to</span>
00128 <span class="comment">// be safe.</span>
00129 <span class="comment">//</span>
<a name="l00130"></a><a class="code" href="../../d8/d4/trackirp_8c.html#a9">00130</a> BOOLEAN <a class="code" href="../../d8/d4/trackirp_8c.html#a9">IovpIrpTrackingEnabled</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00131 
00132 <span class="comment">//</span>
00133 <span class="comment">// Flags that indicate how we were initialized.</span>
00134 <span class="comment">//</span>
<a name="l00135"></a><a class="code" href="../../d8/d4/trackirp_8c.html#a10">00135</a> ULONG <a class="code" href="../../d8/d4/trackirp_8c.html#a10">IovpInitFlags</a> = 0;
00136 
00137 <span class="comment">//</span>
00138 <span class="comment">// This counter is used in picking random IRPs to cancel</span>
00139 <span class="comment">//</span>
<a name="l00140"></a><a class="code" href="../../d8/d4/trackirp_8c.html#a11">00140</a> ULONG <a class="code" href="../../d8/d4/trackirp_8c.html#a11">IovpCancelCount</a> = 0;
00141 
00142 <span class="comment">//</span>
00143 <span class="comment">// This is the time in 100ns units to defer an IRP if so told.</span>
00144 <span class="comment">//</span>
00145 <span class="comment">// ADRIAO BUGBUG 08/19/98 - Don't use hardcoded number.</span>
00146 <span class="comment">//</span>
<a name="l00147"></a><a class="code" href="../../d8/d4/trackirp_8c.html#a12">00147</a> LONG <a class="code" href="../../d8/d4/trackirp_8c.html#a12">IovpIrpDeferralTime</a> = 10 * 300; <span class="comment">// 300us</span>
00148 
00149 <span class="comment">/*</span>
00150 <span class="comment"> * - The IRP verification code works as follows -</span>
00151 <span class="comment"> *</span>
00152 <span class="comment"> * To enforce the correct handling of an IRP, we must maintain some data about</span>
00153 <span class="comment"> * it. But the IRP is a public structure and as drivers are allowed to create</span>
00154 <span class="comment"> * IRPs without using IoAllocateIrp we cannot add any fields to it. Therefore</span>
00155 <span class="comment"> * we maintain out own side structures that are looked up via a hash table.</span>
00156 <span class="comment"> *</span>
00157 <span class="comment"> * IOV_REQUEST_PACKETs cover the lifetime of the IRP from allocation to</span>
00158 <span class="comment"> * deallocation, and from there (sans pointer) until all "references" have</span>
00159 <span class="comment"> * been dropped, which may happen long after the IRP itself was freed and</span>
00160 <span class="comment"> * recycled.</span>
00161 <span class="comment"> *</span>
00162 <span class="comment"> * When an IRP is progress down a stack, a "session" is allocated. An</span>
00163 <span class="comment"> * IovRequestPacket has a current session until such time as the IRP is</span>
00164 <span class="comment"> * completed. The session still exists until all references are dropped, but</span>
00165 <span class="comment"> * before that happens a new session may become the current session (ie the IRP</span>
00166 <span class="comment"> * was sent back down before the previous call stacks unwound). The tracking</span>
00167 <span class="comment"> * data is held around until all sessions have decayed.</span>
00168 <span class="comment"> *</span>
00169 <span class="comment"> * Each session has an array of stack locations corresponding to those in use</span>
00170 <span class="comment"> * by the IRP. These IOV_STACK_LOCATIONs are used to track "requests" within</span>
00171 <span class="comment"> * the IRP, ie the passage of a major/minor/parameter set down the stack.</span>
00172 <span class="comment"> * Of course multiple requests may exist in the same session/stack at once.</span>
00173 <span class="comment"> *</span>
00174 <span class="comment"> * Finally, surrogates. The IoVerifier may "switch" the IRP in use as it goes</span>
00175 <span class="comment"> * down the stack. In this case the new IRP is usually allocated from the</span>
00176 <span class="comment"> * special pool and freed as early as possible to catch bugs (people who touch</span>
00177 <span class="comment"> * after completes). Each surrogate gets it's own IovRequestPacket, which is</span>
00178 <span class="comment"> * linked to the previous surrogate or real irp in use prior to it.</span>
00179 <span class="comment"> *</span>
00180 <span class="comment"> *   +--------------------+                     +--------------------+</span>
00181 <span class="comment"> *   | IOV_REQUEST_PACKET |                     | IOV_REQUEST_PACKET |</span>
00182 <span class="comment"> *   |   (original irp)   |&lt;--------------------|    (surrogate)     |</span>
00183 <span class="comment"> *   |                    |                     |                    |</span>
00184 <span class="comment"> *   +--------------------+                     +--------------------+</span>
00185 <span class="comment"> *                 ||</span>
00186 <span class="comment"> *                 v</span>
00187 <span class="comment"> *    +-------------------+       +-------------------------+</span>
00188 <span class="comment"> *    | IOV_SESSION_DATA  |       | IOV_STACK_LOCATION[...] |</span>
00189 <span class="comment"> *    | (current session) |------&gt;|    (per IrpSp data)     |</span>
00190 <span class="comment"> *    |                   |       |                         |</span>
00191 <span class="comment"> *    +-------------------+       +-------------------------+</span>
00192 <span class="comment"> *</span>
00193 <span class="comment"> *</span>
00194 <span class="comment"> * The following flags change the behavior of IRPs memory allocation,</span>
00195 <span class="comment"> * and code preemption in the OS. They should not neccessarily be on by</span>
00196 <span class="comment"> * default, as they will seriously Heisenburg the system...</span>
00197 <span class="comment"> *</span>
00198 <span class="comment"> * ASSERTFLAG_TRACKIRPS         - If this is not on, all of the below (excepting</span>
00199 <span class="comment"> *                                ASSERTFLAG_MONITOR_ALLOCS) do not occur, and</span>
00200 <span class="comment"> *                                IRPs are handled as in the free build (with</span>
00201 <span class="comment"> *                                very few assertions). If on, all IRPs are</span>
00202 <span class="comment"> *                                tracked, but not asserted on.</span>
00203 <span class="comment"> *</span>
00204 <span class="comment"> * ASSERTFLAG_MONITOR_ALLOCS    - Calls to IoAllocateIrp go through the Special</span>
00205 <span class="comment"> *                                pool. For every IRP so allocated a snapshot</span>
00206 <span class="comment"> *                                of the thread stack at allocation time is</span>
00207 <span class="comment"> *                                taken.</span>
00208 <span class="comment"> *</span>
00209 <span class="comment"> * ASSERTFLAG_POLICEIRPS        - Monitors IRPs for basic/common mistakes.</span>
00210 <span class="comment"> *                                Required for below flags to be used.</span>
00211 <span class="comment"> *</span>
00212 <span class="comment"> * ASSERTFLAG_MONITORMAJORS     - Catches issues specific to various Major and</span>
00213 <span class="comment"> *                                minor specific issues.</span>
00214 <span class="comment"> *</span>
00215 <span class="comment"> * ASSERTFLAG_SURROGATE         - Tracked IRPs are automatically freed upon</span>
00216 <span class="comment"> *                                completion. This is done with a surrogate</span>
00217 <span class="comment"> *                                IRP allocated from the special pool that</span>
00218 <span class="comment"> *                                replaces the original while travelling down</span>
00219 <span class="comment"> *                                the stack.</span>
00220 <span class="comment"> *</span>
00221 <span class="comment"> * ASSERTFLAG_SMASH_SRBS        - Some SCSI IRPs can't be surrogated unless</span>
00222 <span class="comment"> *                                the SRB-&gt;OriginalRequest pointer is updated.</span>
00223 <span class="comment"> *                                This is due to a busted SRB architecture.</span>
00224 <span class="comment"> *                                Note that the technique used to identify an</span>
00225 <span class="comment"> *                                SRB IRP is "fuzzy", and could in theory touch</span>
00226 <span class="comment"> *                                an IRP it shouldn't have!</span>
00227 <span class="comment"> *</span>
00228 <span class="comment"> * ASSERTFLAG_FORCEPENDING      - Tracked IRPs are automatically pended, but</span>
00229 <span class="comment"> *                                are not held for any period of time.</span>
00230 <span class="comment"> *</span>
00231 <span class="comment"> * ASSERTFLAG_DEFERCOMPLETION   - Tracked IRPs are completed later via timer.</span>
00232 <span class="comment"> *                                ASSERTFLAG_FORCEPENDING set by inference.</span>
00233 <span class="comment"> *</span>
00234 <span class="comment"> * ASSERTFLAG_COMPLETEATDPC     - completes every IRP at DPC, regardless of</span>
00235 <span class="comment"> *                                major function.</span>
00236 <span class="comment"> *</span>
00237 <span class="comment"> * ASSERTFLAG_COMPLETEATPASSIVE - completes every IRP as Passive, regardless</span>
00238 <span class="comment"> *                                of major function. ASSERTFLAG_FORCEPENDING</span>
00239 <span class="comment"> *                                is set by inference.</span>
00240 <span class="comment"> *</span>
00241 <span class="comment"> * ASSERTFLAG_CONSUME_ALWAYS    - Stack locations are forced to be copied (ie</span>
00242 <span class="comment"> *                                any skips are undone).  Note that we do not</span>
00243 <span class="comment"> *                                consume if the IRP was just forwarded to</span>
00244 <span class="comment"> *                                another stack.</span>
00245 <span class="comment"> *</span>
00246 <span class="comment"> * ASSERTFLAG_ROTATE_STATUS     - Alternate successful status's are chosen where</span>
00247 <span class="comment"> *                                appropriate as the IRP returns up the stack.</span>
00248 <span class="comment"> *                                This catches many IRP forwarding bugs.</span>
00249 <span class="comment"> *</span>
00250 <span class="comment"> * ASSERTFLAG_SEEDSTACK         - Seeds the stack so that uninitialized</span>
00251 <span class="comment"> *                                variables are caught more easily...</span>
00252 <span class="comment"> *</span>
00253 <span class="comment"> */</span>
00254 
00255 BOOLEAN
00256 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l00257"></a><a class="code" href="../../d9/d4/trackirp_8h.html#a107">00257</a> <a class="code" href="../../d9/d4/trackirp_8h.html#a107">IovpInitIrpTracking</a>(
00258     IN ULONG   Level,
00259     IN ULONG   Flags
00260     )
00261 <span class="comment">/*++</span>
00262 <span class="comment"></span>
00263 <span class="comment">  Description:</span>
00264 <span class="comment"></span>
00265 <span class="comment">    Initialize that which needs to be initialized.</span>
00266 <span class="comment"></span>
00267 <span class="comment">  Arguments:</span>
00268 <span class="comment"></span>
00269 <span class="comment">    Level         - Level of testing to apply</span>
00270 <span class="comment">                      0 - No checks</span>
00271 <span class="comment">                      1 - Tracking with surrogate irp allocation</span>
00272 <span class="comment">                      2 - Monitors basic IRP mistakes</span>
00273 <span class="comment">                      3 - Monitors mistakes based on the irp major</span>
00274 <span class="comment">                          Surrogate IRPs used, status values rotated,</span>
00275 <span class="comment">                          and various other checks.</span>
00276 <span class="comment">                      4 - IRPs always completed at DPC.</span>
00277 <span class="comment">                      5 - All IRPs pended with completion defered via timer.</span>
00278 <span class="comment">                      6 - Any hacks turned off.</span>
00279 <span class="comment"></span>
00280 <span class="comment">  Return Value:</span>
00281 <span class="comment"></span>
00282 <span class="comment">    Returns TRUE iff settings were successfully applied.</span>
00283 <span class="comment"></span>
00284 <span class="comment">--*/</span>
00285 {
00286     PVOID sectionHeaderHandle;
00287     ULONG newTrackingFlags;
00288 
00289     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00290 
00291     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d4/trackirp_8c.html#a9">IovpIrpTrackingEnabled</a>) {
00292 
00293         <a class="code" href="../../d8/d4/trackirp_8c.html#a10">IovpInitFlags</a> = (Flags | (<a class="code" href="../../d8/d4/trackirp_8c.html#a10">IovpInitFlags</a>&amp;<a class="code" href="../../d0/d5/io_8h.html#a261">IOVERIFIERINIT_EVERYTHING_TRACKED</a>));
00294 
00295     } <span class="keywordflow">else</span> {
00296 
00297         <a class="code" href="../../d9/d8/hashirp_8h.html#a6">IovpTrackingDataInit</a>();
00298 
00299         <a class="code" href="../../d8/d4/trackirp_8c.html#a10">IovpInitFlags</a> = Flags;
00300         <a class="code" href="../../d8/d4/trackirp_8c.html#a9">IovpIrpTrackingEnabled</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00301     }
00302 
00303     newTrackingFlags = 0;
00304     <span class="keywordflow">switch</span>(Level) {
00305 
00306         <span class="keywordflow">default</span>:
00307         <span class="keywordflow">case</span> 7:
00308             <a class="code" href="../../d8/d4/trackirp_8c.html#a8">IovpHackFlags</a> = 0;
00309 
00310         <span class="keywordflow">case</span> 6:
00311             newTrackingFlags |= <a class="code" href="../../d9/d4/trackirp_8h.html#a7">ASSERTFLAG_FORCEPENDING</a> |
00312                                 <a class="code" href="../../d9/d4/trackirp_8h.html#a10">ASSERTFLAG_DEFERCOMPLETION</a>;
00313             <span class="comment">//</span>
00314             <span class="comment">// Fall through</span>
00315             <span class="comment">//</span>
00316 
00317         <span class="keywordflow">case</span> 5:
00318             newTrackingFlags |= <a class="code" href="../../d9/d4/trackirp_8h.html#a8">ASSERTFLAG_COMPLETEATDPC</a>;
00319             <span class="comment">//</span>
00320             <span class="comment">// Fall through</span>
00321             <span class="comment">//</span>
00322 
00323         <span class="keywordflow">case</span> 4:
00324             newTrackingFlags |= <a class="code" href="../../d9/d4/trackirp_8h.html#a4">ASSERTFLAG_SURROGATE</a> |
00325                                 <a class="code" href="../../d9/d4/trackirp_8h.html#a5">ASSERTFLAG_SMASH_SRBS</a> |
00326                                 <a class="code" href="../../d9/d4/trackirp_8h.html#a6">ASSERTFLAG_CONSUME_ALWAYS</a> |
00327                                 <a class="code" href="../../d9/d4/trackirp_8h.html#a11">ASSERTFLAG_ROTATE_STATUS</a> |
00328                                 <a class="code" href="../../d9/d4/trackirp_8h.html#a13">ASSERTFLAG_SEEDSTACK</a>;
00329             <span class="comment">//</span>
00330             <span class="comment">// Fall through</span>
00331             <span class="comment">//</span>
00332 
00333         <span class="keywordflow">case</span> 3:
00334             newTrackingFlags |= <a class="code" href="../../d9/d4/trackirp_8h.html#a3">ASSERTFLAG_MONITORMAJORS</a>;
00335             <span class="comment">//</span>
00336             <span class="comment">// Fall through</span>
00337             <span class="comment">//</span>
00338 
00339         <span class="keywordflow">case</span> 2:
00340             newTrackingFlags |= <a class="code" href="../../d9/d4/trackirp_8h.html#a2">ASSERTFLAG_POLICEIRPS</a>;
00341             <span class="comment">//</span>
00342             <span class="comment">// Fall through</span>
00343             <span class="comment">//</span>
00344 
00345         <span class="keywordflow">case</span> 1:
00346             newTrackingFlags |= <a class="code" href="../../d9/d4/trackirp_8h.html#a0">ASSERTFLAG_TRACKIRPS</a> |
00347                                 <a class="code" href="../../d9/d4/trackirp_8h.html#a1">ASSERTFLAG_MONITOR_ALLOCS</a>;
00348             <span class="comment">//</span>
00349             <span class="comment">// Fall through</span>
00350             <span class="comment">//</span>
00351 
00352         <span class="keywordflow">case</span> 0:
00353             <span class="keywordflow">break</span>;
00354     }
00355 
00356     <span class="keywordflow">if</span> ((Level == 0) &amp;&amp; (Flags&amp;<a class="code" href="../../d0/d5/io_8h.html#a263">IOVERIFIERINIT_NO_REINIT</a>)) {
00357 
00358         <span class="comment">//</span>
00359         <span class="comment">// Preinit flags</span>
00360         <span class="comment">//</span>
00361         newTrackingFlags = <a class="code" href="../../d8/d4/trackirp_8c.html#a7">IovpTrackingFlags</a>;
00362     }
00363 
00364     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d4/trackirp_8c.html#a8">IovpHackFlags</a> == (ULONG) -1) {
00365 
00366         <a class="code" href="../../d8/d4/trackirp_8c.html#a8">IovpHackFlags</a> =
00367 <span class="preprocessor">#ifdef HACKHACKS_ENABLED</span>
00368 <span class="preprocessor"></span><span class="preprocessor">#ifdef HACKHACK_FOR_MUP</span>
00369 <span class="preprocessor"></span>                         <a class="code" href="../../d9/d4/trackirp_8h.html#a15">HACKFLAG_FOR_MUP</a> |
00370 <span class="preprocessor">#endif</span>
00371 <span class="preprocessor"></span><span class="preprocessor">#ifdef HACKHACK_FOR_SCSIPORT</span>
00372 <span class="preprocessor"></span>                         <a class="code" href="../../d9/d4/trackirp_8h.html#a16">HACKFLAG_FOR_SCSIPORT</a> |
00373 <span class="preprocessor">#endif</span>
00374 <span class="preprocessor"></span><span class="preprocessor">#ifdef HACKHACK_FOR_ACPI</span>
00375 <span class="preprocessor"></span>                         <a class="code" href="../../d9/d4/trackirp_8h.html#a17">HACKFLAG_FOR_ACPI</a> |
00376 <span class="preprocessor">#endif</span>
00377 <span class="preprocessor"></span><span class="preprocessor">#ifdef HACKHACK_FOR_BOGUSIRPS</span>
00378 <span class="preprocessor"></span>                         <a class="code" href="../../d9/d4/trackirp_8h.html#a18">HACKFLAG_FOR_BOGUSIRPS</a> |
00379 <span class="preprocessor">#endif</span>
00380 <span class="preprocessor"></span><span class="preprocessor">#endif // HACKHACKS_ENABLED</span>
00381 <span class="preprocessor"></span>                         0;
00382     }
00383 
00384     <span class="keywordflow">if</span> (!(<a class="code" href="../../d8/d4/trackirp_8c.html#a10">IovpInitFlags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a261">IOVERIFIERINIT_EVERYTHING_TRACKED</a>)) {
00385 
00386         <span class="comment">//</span>
00387         <span class="comment">// These options aren't available unless we were marking IRPs since</span>
00388         <span class="comment">// boot.</span>
00389         <span class="comment">//</span>
00390         newTrackingFlags &amp;=~ (
00391                               <a class="code" href="../../d9/d4/trackirp_8h.html#a3">ASSERTFLAG_MONITORMAJORS</a> |
00392                               <a class="code" href="../../d9/d4/trackirp_8h.html#a4">ASSERTFLAG_SURROGATE</a> |
00393                               <a class="code" href="../../d9/d4/trackirp_8h.html#a5">ASSERTFLAG_SMASH_SRBS</a> |
00394                               <a class="code" href="../../d9/d4/trackirp_8h.html#a6">ASSERTFLAG_CONSUME_ALWAYS</a>
00395                              );
00396     }
00397 
00398     <a class="code" href="../../d8/d4/trackirp_8c.html#a7">IovpTrackingFlags</a> = newTrackingFlags;
00399     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00400 }
00401 
00402 BOOLEAN
00403 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l00404"></a><a class="code" href="../../d9/d4/trackirp_8h.html#a131">00404</a> <a class="code" href="../../d9/d4/trackirp_8h.html#a131">IovpDoAssertIrps</a>(
00405     VOID
00406     )
00407 <span class="comment">/*++</span>
00408 <span class="comment"></span>
00409 <span class="comment">  Description:</span>
00410 <span class="comment"></span>
00411 <span class="comment">    This routine is called to ensure we can do IRP assertions. When called we</span>
00412 <span class="comment">    lock the neccessary data structures and code if we haven't been initialized.</span>
00413 <span class="comment"></span>
00414 <span class="comment">  Arguments: None</span>
00415 <span class="comment"></span>
00416 <span class="comment">  Return Value:</span>
00417 <span class="comment"></span>
00418 <span class="comment">    TRUE if assertions can be done, FALSE otherwise (e.g.,</span>
00419 <span class="comment">    called at DPC time and we weren't already enabled)</span>
00420 <span class="comment"></span>
00421 <span class="comment">--*/</span>
00422 {
00423     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(<a class="code" href="../../d8/d4/trackirp_8c.html#a7">IovpTrackingFlags</a>);
00424     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(KeGetCurrentIrql() &lt;= <a class="code" href="../../d6/d7/halmips_8h.html#a53">DISPATCH_LEVEL</a>) ;
00425 
00426     <span class="comment">//</span>
00427     <span class="comment">// If we aren't enabled, call the enabling function. This is harmless to</span>
00428     <span class="comment">// call repeatedly. We are not gaurenteed to be enabled when this function</span>
00429     <span class="comment">// returns (it can't block anyway, as paging might need to occur, and we'd</span>
00430     <span class="comment">// be sitting on file system IRPs). The IOVERIFIERINIT_EVERYTHING_TRACKED is</span>
00431     <span class="comment">// used to let us know we caught all IRPs, ie none are outstanding that</span>
00432     <span class="comment">// haven't been tracked/marked in some manner. We can set this here as</span>
00433     <span class="comment">// SPECIALIRP_MARK_NON_TRACKABLE() is called in the normal IofCallDriver</span>
00434     <span class="comment">// code paths if SPECIAL_IRP's are enabled.</span>
00435     <span class="comment">//</span>
00436     <span class="keywordflow">if</span> (!<a class="code" href="../../d8/d4/trackirp_8c.html#a9">IovpIrpTrackingEnabled</a>) {
00437 
00438 <span class="preprocessor">#if 0</span>
00439 <span class="preprocessor"></span>        <a class="code" href="../../d6/d6/ioverifier_8c.html#a26">IoVerifierInit</a>(
00440             DRIVER_VERIFIER_IO_CHECKING,
00441             <a class="code" href="../../d0/d5/io_8h.html#a261">IOVERIFIERINIT_EVERYTHING_TRACKED</a> |
00442             <a class="code" href="../../d0/d5/io_8h.html#a262">IOVERIFIERINIT_ASYNCHRONOUSINIT</a> |
00443             <a class="code" href="../../d0/d5/io_8h.html#a263">IOVERIFIERINIT_NO_REINIT</a>
00444             );
00445 <span class="preprocessor">#endif</span>
00446 <span class="preprocessor"></span>    }
00447 
00448     <span class="comment">//</span>
00449     <span class="comment">// If enabled, return so.</span>
00450     <span class="comment">//</span>
00451     <span class="keywordflow">return</span> <a class="code" href="../../d8/d4/trackirp_8c.html#a9">IovpIrpTrackingEnabled</a>;
00452 }
00453 
00454 <span class="comment">/*</span>
00455 <span class="comment"> * The 13 routines listed below -</span>
00456 <span class="comment"> *   IovpCallDriver1</span>
00457 <span class="comment"> *   IovpCallDriver2</span>
00458 <span class="comment"> *   IovpCompleteRequest1</span>
00459 <span class="comment"> *   IovpCompleteRequest2</span>
00460 <span class="comment"> *   IovpCompleteRequest3</span>
00461 <span class="comment"> *   IovpCompleteRequest4</span>
00462 <span class="comment"> *   IovpCompleteRequest5</span>
00463 <span class="comment"> *   IovpCompleteRequest</span>
00464 <span class="comment"> *   IovpCancelIrp</span>
00465 <span class="comment"> *   IovpFreeIrp</span>
00466 <span class="comment"> *   IovpAllocateIrp1</span>
00467 <span class="comment"> *   IovpAllocateIrp2</span>
00468 <span class="comment"> *   IovpInitializeIrp</span>
00469 <span class="comment"> * and their helper routine</span>
00470 <span class="comment"> *   IovpSwapSurrogateIrp</span>
00471 <span class="comment"> *</span>
00472 <span class="comment"> * - all hook into various parts IofCallDriver and IofCompleteRequest to</span>
00473 <span class="comment"> * track the IRP through it's life and determine whether it has been handled</span>
00474 <span class="comment"> * correctly. Some of them may even change internal variables in the hooked</span>
00475 <span class="comment"> * function. Most dramatically, IovpCallDriver1 may build a</span>
00476 <span class="comment"> * replacement Irp which will take the place of the one passed into</span>
00477 <span class="comment"> * IoCallDriver.</span>
00478 <span class="comment"> *</span>
00479 <span class="comment"> *   All of the below functions use a tracking structure called (reasonably</span>
00480 <span class="comment"> * enough) IRP_TRACKING_DATA. This lasts the longer of the call stack</span>
00481 <span class="comment"> * unwinding or the IRP completing.</span>
00482 <span class="comment"> *</span>
00483 <span class="comment"> */</span>
00484 
<a name="l00485"></a><a class="code" href="../../d8/d4/trackirp_8c.html#a5">00485</a> <span class="preprocessor">#define FAIL_CALLER_OF_IOFCALLDRIVER(msg, irpSp) \</span>
00486 <span class="preprocessor">    WDM_FAIL_CALLER(msg, 3+2*((irpSp)-&gt;MajorFunction == IRP_MJ_POWER))</span>
00487 <span class="preprocessor"></span>
<a name="l00488"></a><a class="code" href="../../d8/d4/trackirp_8c.html#a6">00488</a> <span class="preprocessor">#define FAIL_CALLER_OF_IOFCALLDRIVER2(msg, irpSp) \</span>
00489 <span class="preprocessor">    WDM_FAIL_CALLER(msg, 4+2*((irpSp)-&gt;MajorFunction == IRP_MJ_POWER))</span>
00490 <span class="preprocessor"></span>
00491 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00492 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l00493"></a><a class="code" href="../../d9/d4/trackirp_8h.html#a108">00493</a> <a class="code" href="../../d9/d4/trackirp_8h.html#a108">IovpCallDriver1</a>(
00494     IN OUT <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>           *IrpPointer,
00495     IN     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject,
00496     IN OUT <a class="code" href="../../d3/d0/struct__IOFCALLDRIVER__STACKDATA.html">PIOFCALLDRIVER_STACKDATA</a> IofCallDriverStackData
00497     )
00498 <span class="comment">/*++</span>
00499 <span class="comment"></span>
00500 <span class="comment">  Description:</span>
00501 <span class="comment"></span>
00502 <span class="comment">    This routine is called by IofCallDriver just before adjusting</span>
00503 <span class="comment">    the IRP stack and calling the driver's dispatch routine.</span>
00504 <span class="comment"></span>
00505 <span class="comment">  Arguments:</span>
00506 <span class="comment"></span>
00507 <span class="comment">    IrpPointer             - a pointer* to the IRP passed in to</span>
00508 <span class="comment">                             IofCallDriver. This routine may</span>
00509 <span class="comment">                             change the pointer if a surrogate</span>
00510 <span class="comment">                             IRP is allocated.</span>
00511 <span class="comment"></span>
00512 <span class="comment">    DeviceObject           - Device object passed into IofCallDriver.</span>
00513 <span class="comment"></span>
00514 <span class="comment">    IofCallDriverStackData - Pointer to a local variable on</span>
00515 <span class="comment">                             IofCallDriver's stack to store data.</span>
00516 <span class="comment">                             The stored information will be picked</span>
00517 <span class="comment">                             up by IovpCallDriver2, and</span>
00518 <span class="comment">                             may be adjusted at other times.</span>
00519 <span class="comment"></span>
00520 <span class="comment"></span>
00521 <span class="comment">  Return Value:</span>
00522 <span class="comment"></span>
00523 <span class="comment">     None.</span>
00524 <span class="comment"></span>
00525 <span class="comment">--*/</span>
00526 {
00527     <a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html">PIOV_REQUEST_PACKET</a> iovPacket;
00528     <a class="code" href="../../d8/d1/struct__IOV__SESSION__DATA.html">PIOV_SESSION_DATA</a> iovSessionData;
00529     <a class="code" href="../../d9/d1/struct__IOV__STACK__LOCATION.html">PIOV_STACK_LOCATION</a> iovCurrentStackLocation;
00530     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp, replacementIrp;
00531     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpSp, irpLastSp;
00532     BOOLEAN isNewSession, isNewRequest, previouslyInUse, surrogateSpawned;
00533     ULONG isSameStack;
00534     ULONG locationsAdvanced, completeStyle;
00535     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> pdo, lowerDeviceObject;
00536     <a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html">PDRIVER_OBJECT</a> driverObject;
00537     PVOID dispatchRoutine;
00538 
00539     irp = *IrpPointer;
00540     irpSp = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>( irp );
00541 
00542     <span class="comment">//</span>
00543     <span class="comment">// Preinitialize the CallStackData.</span>
00544     <span class="comment">//</span>
00545     RtlZeroMemory(IofCallDriverStackData, <span class="keyword">sizeof</span>(<a class="code" href="../../d3/d0/struct__IOFCALLDRIVER__STACKDATA.html">IOFCALLDRIVER_STACKDATA</a>));
00546 
00547     <span class="comment">//</span>
00548     <span class="comment">// If we are going to die shortly, kindly say so.</span>
00549     <span class="comment">//</span>
00550     <span class="keywordflow">if</span> (DeviceObject == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00551 
00552         <a class="code" href="../../d8/d4/trackirp_8c.html#a5">FAIL_CALLER_OF_IOFCALLDRIVER</a>(
00553             (<a class="code" href="../../d2/d5/ioassert_8h.html#a114a43">DCERROR_NULL_DEVOBJ_FORWARDED</a>, <a class="code" href="../../d2/d5/ioassert_8h.html#a7">DCPARAM_IRP</a>, irp),
00554             irpSp
00555             );
00556     }
00557 
00558     <span class="comment">//</span>
00559     <span class="comment">// The examined flag is set on any IRP that has come through</span>
00560     <span class="comment">// IofCallDriver. We use the flag to detect whether we have seen the IRP</span>
00561     <span class="comment">// before.</span>
00562     <span class="comment">//</span>
00563     <span class="keywordflow">switch</span>(irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a>&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a19">IRPFLAG_EXAMINE_MASK</a>) {
00564 
00565         <span class="keywordflow">case</span> <a class="code" href="../../d9/d4/trackirp_8h.html#a20">IRPFLAG_EXAMINE_NOT_TRACKED</a>:
00566 
00567             <span class="comment">//</span>
00568             <span class="comment">// This packet is marked do not touch. So we ignore it.</span>
00569             <span class="comment">//</span>
00570             iovPacket = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00571             <span class="keywordflow">break</span>;
00572 
00573         <span class="keywordflow">case</span> <a class="code" href="../../d9/d4/trackirp_8h.html#a21">IRPFLAG_EXAMINE_TRACKED</a>:
00574 
00575             <span class="comment">//</span>
00576             <span class="comment">// This packet has been marked. We should find it.</span>
00577             <span class="comment">//</span>
00578             iovPacket = <a class="code" href="../../d9/d8/hashirp_8h.html#a7">IovpTrackingDataFindAndLock</a>(irp);
00579             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(iovPacket != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00580             <span class="keywordflow">break</span>;
00581 
00582         <span class="keywordflow">case</span> <a class="code" href="../../d9/d4/trackirp_8h.html#a22">IRPFLAG_EXAMINE_UNMARKED</a>:
00583 
00584             iovPacket = <a class="code" href="../../d9/d8/hashirp_8h.html#a7">IovpTrackingDataFindAndLock</a>(irp);
00585             <span class="keywordflow">if</span> (iovPacket) {
00586 
00587                 <span class="comment">//</span>
00588                 <span class="comment">// Was tracked but cache flag got wiped. Replace.</span>
00589                 <span class="comment">//</span>
00590                 irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> |= <a class="code" href="../../d9/d4/trackirp_8h.html#a21">IRPFLAG_EXAMINE_TRACKED</a>;
00591 
00592             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="../../d8/d4/trackirp_8c.html#a7">IovpTrackingFlags</a>&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a0">ASSERTFLAG_TRACKIRPS</a>) {
00593 
00594                 <span class="comment">//</span>
00595                 <span class="comment">// Create the packet</span>
00596                 <span class="comment">//</span>
00597                 iovPacket = <a class="code" href="../../d9/d8/hashirp_8h.html#a8">IovpTrackingDataCreateAndLock</a>(irp);
00598                 <span class="keywordflow">if</span> (iovPacket) {
00599 
00600                     <span class="comment">//</span>
00601                     <span class="comment">// Mark it</span>
00602                     <span class="comment">//</span>
00603                     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> |= <a class="code" href="../../d9/d4/trackirp_8h.html#a21">IRPFLAG_EXAMINE_TRACKED</a>;
00604                 } <span class="keywordflow">else</span> {
00605 
00606                     <span class="comment">//</span>
00607                     <span class="comment">// No memory, try to keep it out of the IRP assert though.</span>
00608                     <span class="comment">//</span>
00609                     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> |= <a class="code" href="../../d9/d4/trackirp_8h.html#a20">IRPFLAG_EXAMINE_NOT_TRACKED</a>;
00610                 }
00611             } <span class="keywordflow">else</span> {
00612 
00613                 <span class="comment">//</span>
00614                 <span class="comment">// Do as told, don't track through IofCallDriver.</span>
00615                 <span class="comment">//</span>
00616                 irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> |= <a class="code" href="../../d9/d4/trackirp_8h.html#a20">IRPFLAG_EXAMINE_NOT_TRACKED</a>;
00617             }
00618             <span class="keywordflow">break</span>;
00619 
00620         <span class="keywordflow">default</span>:
00621             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(0);
00622             <span class="keywordflow">break</span>;
00623     }
00624 
00625     <span class="keywordflow">if</span> (iovPacket == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00626 
00627         <span class="comment">//</span>
00628         <span class="comment">// Nothing to track, get out.</span>
00629         <span class="comment">//</span>
00630         <span class="keywordflow">return</span>;
00631     }
00632 
00633     <span class="comment">//</span>
00634     <span class="comment">// Find the current session. The session terminates when the final top-level</span>
00635     <span class="comment">// completion routine gets called.</span>
00636     <span class="comment">//</span>
00637     iovSessionData = <a class="code" href="../../d9/d8/hashirp_8h.html#a16">IovpTrackingDataGetCurrentSessionData</a>(iovPacket);
00638 
00639     <span class="keywordflow">if</span> (iovSessionData) {
00640 
00641         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o5">Flags</a>&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a25">TRACKFLAG_ACTIVE</a>);
00642         isNewSession = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00643 
00644         <a class="code" href="../../d6/d7/sessnirp_8h.html#a1">IovpSessionDataAdvance</a>(
00645             DeviceObject,
00646             iovSessionData,      <span class="comment">// This param is optional.</span>
00647             &amp;iovPacket,
00648             &amp;surrogateSpawned
00649             );
00650 
00651     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!(iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o5">Flags</a>&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a25">TRACKFLAG_ACTIVE</a>)){
00652 
00653         iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o5">Flags</a> |= <a class="code" href="../../d9/d4/trackirp_8h.html#a25">TRACKFLAG_ACTIVE</a>;
00654         isNewSession = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00655 
00656         iovSessionData = <a class="code" href="../../d6/d7/sessnirp_8h.html#a0">IovpSessionDataCreate</a>(
00657             DeviceObject,
00658             &amp;iovPacket,
00659             &amp;surrogateSpawned
00660             );
00661 
00662     } <span class="keywordflow">else</span> {
00663 
00664         <span class="comment">//</span>
00665         <span class="comment">// Might hit this path under low memory, or we are tracking allocations</span>
00666         <span class="comment">// but not the IRP sessions themselves.</span>
00667         <span class="comment">//</span>
00668     }
00669 
00670     <span class="comment">//</span>
00671     <span class="comment">// Let IovpCallDriver2 know what it's tracking...</span>
00672     <span class="comment">//</span>
00673     IofCallDriverStackData-&gt;IovSessionData = iovSessionData;
00674 
00675     <span class="keywordflow">if</span> (iovSessionData == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00676 
00677         <a class="code" href="../../d9/d8/hashirp_8h.html#a12">IovpTrackingDataReleaseLock</a>(iovPacket) ;
00678         <span class="keywordflow">return</span>;
00679     }
00680 
00681     <span class="keywordflow">if</span> (surrogateSpawned) {
00682 
00683         <span class="comment">//</span>
00684         <span class="comment">// iovPacket was changed to cover the surrogate IRP. Update our own</span>
00685         <span class="comment">// local variable and IofCallDriver's local variable appropriately.</span>
00686         <span class="comment">//</span>
00687         irp = iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o0">TrackedIrp</a>;
00688         irpSp = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>(irp);
00689         *IrpPointer = irp;
00690     }
00691 
00692     <span class="keywordflow">if</span> (isNewSession) {
00693 
00694         <a class="code" href="../../d9/d8/hashirp_8h.html#a13">IovpTrackingDataReference</a>(iovPacket, <a class="code" href="../../d9/d8/hashirp_8h.html#a21a5">IOVREFTYPE_POINTER</a>);
00695         <a class="code" href="../../d6/d7/sessnirp_8h.html#a2">IovpSessionDataReference</a>(iovSessionData);
00696     }
00697 
00698     <span class="keywordflow">if</span> (iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o11">AssertFlags</a>&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a2">ASSERTFLAG_POLICEIRPS</a>) {
00699 
00700         <span class="comment">//</span>
00701         <span class="comment">// If someone has given us an IRP with a cancel routine, beat them. Drivers</span>
00702         <span class="comment">// set cancel routines when they are going to be pending IRPs *themselves*</span>
00703         <span class="comment">// and should remove them before passing the IRP below. This is also true</span>
00704         <span class="comment">// as the driver will *not* call your cancel routine if he writes in his</span>
00705         <span class="comment">// own (which it may). Nor is the lower driver expected to put yours back</span>
00706         <span class="comment">// either...</span>
00707         <span class="comment">//</span>
00708         <span class="keywordflow">if</span> (irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o25">CancelRoutine</a>) {
00709 
00710             <a class="code" href="../../d8/d4/trackirp_8c.html#a5">FAIL_CALLER_OF_IOFCALLDRIVER</a>(
00711                 (<a class="code" href="../../d2/d5/ioassert_8h.html#a114a42">DCERROR_CANCELROUTINE_FORWARDED</a>, <a class="code" href="../../d2/d5/ioassert_8h.html#a7">DCPARAM_IRP</a>, irp),
00712                 irpSp
00713                 );
00714 
00715             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o25">CancelRoutine</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00716         }
00717     }
00718 
00719     <span class="comment">//</span>
00720     <span class="comment">// Now do any checking that requires tracking data.</span>
00721     <span class="comment">//</span>
00722     <span class="keywordflow">if</span> (iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o5">Flags</a>&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a29">TRACKFLAG_QUEUED_INTERNALLY</a>) {
00723 
00724         <span class="comment">//</span>
00725         <span class="comment">// We internally queue irps to catch bugs. When we are doing this, we</span>
00726         <span class="comment">// force the stack returned status to STATUS_PENDING, and we queue the</span>
00727         <span class="comment">// irp and release it on a timer. We also may make the IRP non-touchable.</span>
00728         <span class="comment">// This particular caller is trying to forward an IRP he doesn't own,</span>
00729         <span class="comment">// and we didn't actually end up with an untouchable irp.</span>
00730         <span class="comment">//</span>
00731         <a class="code" href="../../d8/d4/trackirp_8c.html#a5">FAIL_CALLER_OF_IOFCALLDRIVER</a>(
00732             (<a class="code" href="../../d2/d5/ioassert_8h.html#a114a44">DCERROR_QUEUED_IRP_FORWARDED</a>, <a class="code" href="../../d2/d5/ioassert_8h.html#a7">DCPARAM_IRP</a>, irp),
00733             irpSp
00734             );
00735     }
00736 
00737     <span class="comment">//</span>
00738     <span class="comment">// Figure out how many stack locations we've moved up since we've last seen</span>
00739     <span class="comment">// this IRP, and determine if the stack locations were copied appropriately.</span>
00740     <span class="comment">// We also need to see exactly how the IRP was forwarded (down the stack,</span>
00741     <span class="comment">// to another stack, straight to the PDO, etc).</span>
00742     <span class="comment">//</span>
00743     <span class="comment">// ADRIAO BUGBUG #07 05/11/98 - The only way to truely detect this is to</span>
00744     <span class="comment">//                              attach a filter at every layer in stack.</span>
00745     <span class="comment">//                              This is left as an exercise for later.</span>
00746     <span class="comment">//</span>
00747     <a class="code" href="../../d9/d4/trackirp_8h.html#a123">IovpExamineDevObjForwarding</a>(
00748         DeviceObject,
00749         iovSessionData-&gt;<a class="code" href="../../d8/d1/struct__IOV__SESSION__DATA.html#o6">DeviceLastCalled</a>,
00750         &amp;iovSessionData-&gt;<a class="code" href="../../d8/d1/struct__IOV__SESSION__DATA.html#o7">ForwardMethod</a>
00751         ) ;
00752 
00753     <a class="code" href="../../d9/d4/trackirp_8h.html#a121">IovpExamineIrpStackForwarding</a>(
00754         iovPacket,
00755         isNewSession,
00756         iovSessionData-&gt;<a class="code" href="../../d8/d1/struct__IOV__SESSION__DATA.html#o7">ForwardMethod</a>,
00757         DeviceObject,
00758         irp,
00759         &amp;irpSp,
00760         &amp;irpLastSp,
00761         &amp;locationsAdvanced
00762         );
00763 
00764     <a class="code" href="../../d9/d4/trackirp_8h.html#a88">TRACKIRP_DBGPRINT</a>((
00765         <span class="stringliteral">"  CD1: Current, Last = (%x, %x)\n"</span>,
00766         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o13">CurrentLocation</a>,
00767         iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o18">LastLocation</a>
00768         ), 3) ;
00769 
00770     <span class="comment">//</span>
00771     <span class="comment">// Figure out whether this is a new request or not, and record a</span>
00772     <span class="comment">// pointer in this slot to the requests originating slot as appropriate.</span>
00773     <span class="comment">//</span>
00774     isNewRequest = <a class="code" href="../../d8/d4/flunkirp_8h.html#a0">IovpAssertIsNewRequest</a>(irpLastSp, irpSp);
00775 
00776     <span class="comment">//</span>
00777     <span class="comment">// Record information in our private stack locations and</span>
00778     <span class="comment">// write that back into the "stack" data itself...</span>
00779     <span class="comment">//</span>
00780     previouslyInUse = <a class="code" href="../../d9/d4/trackirp_8h.html#a145">IovpAdvanceStackDownwards</a>(
00781         iovSessionData-&gt;<a class="code" href="../../d8/d1/struct__IOV__SESSION__DATA.html#o9">StackData</a>,
00782         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o13">CurrentLocation</a>,
00783         irpSp,
00784         irpLastSp,
00785         locationsAdvanced,
00786         isNewRequest,
00787         <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
00788         &amp;iovCurrentStackLocation
00789         );
00790 
00791     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(iovCurrentStackLocation);
00792 
00793     <span class="keywordflow">if</span> (previouslyInUse) {
00794 
00795         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(!isNewRequest);
00796         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(!isNewSession);
00797         <a class="code" href="../../d7/d0/ke_2miscc_8c.html#a3">KeQuerySystemTime</a>(&amp;iovCurrentStackLocation-&gt;<a class="code" href="../../d9/d1/struct__IOV__STACK__LOCATION.html#o6">PerfDispatchStart</a>) ;
00798 
00799     } <span class="keywordflow">else</span> {
00800 
00801         IofCallDriverStackData-&gt;Flags = <a class="code" href="../../d9/d4/trackirp_8h.html#a55">CALLFLAG_TOPMOST_IN_SLOT</a> ;
00802         InitializeListHead(&amp;IofCallDriverStackData-&gt;SharedLocationList) ;
00803 
00804         <a class="code" href="../../d7/d0/ke_2miscc_8c.html#a3">KeQuerySystemTime</a>(&amp;iovCurrentStackLocation-&gt;<a class="code" href="../../d9/d1/struct__IOV__STACK__LOCATION.html#o6">PerfDispatchStart</a>) ;
00805         <a class="code" href="../../d7/d0/ke_2miscc_8c.html#a3">KeQuerySystemTime</a>(&amp;iovCurrentStackLocation-&gt;<a class="code" href="../../d9/d1/struct__IOV__STACK__LOCATION.html#o7">PerfStackLocationStart</a>) ;
00806 
00807         <span class="comment">//</span>
00808         <span class="comment">// Record the first thread this IRP slot was dispatched to.</span>
00809         <span class="comment">//</span>
00810         iovCurrentStackLocation-&gt;<a class="code" href="../../d9/d1/struct__IOV__STACK__LOCATION.html#o12">ThreadDispatchedTo</a> = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
00811         <span class="keywordflow">if</span> (isNewRequest) {
00812 
00813             iovCurrentStackLocation-&gt;<a class="code" href="../../d9/d1/struct__IOV__STACK__LOCATION.html#o10">InitialStatusBlock</a> = irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>;
00814             iovCurrentStackLocation-&gt;<a class="code" href="../../d9/d1/struct__IOV__STACK__LOCATION.html#o11">LastStatusBlock</a> = irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>;
00815             <span class="keywordflow">if</span> (isNewSession) {
00816 
00817                 iovCurrentStackLocation-&gt;<a class="code" href="../../d9/d1/struct__IOV__STACK__LOCATION.html#o1">Flags</a> |= <a class="code" href="../../d9/d4/trackirp_8h.html#a50">STACKFLAG_FIRST_REQUEST</a>;
00818             }
00819         }
00820     }
00821 
00822     <span class="comment">//</span>
00823     <span class="comment">// Record whether this is the last device object for this IRP...</span>
00824     <span class="comment">// PDO's have devnodes filled out, so look for that field.</span>
00825     <span class="comment">// Actually, we can't quite do that trick as during Bus</span>
00826     <span class="comment">// enumeration a bus filter might be sending down Irps before</span>
00827     <span class="comment">// the OS has ever seen the node. So we assume a devobj is a</span>
00828     <span class="comment">// PDO if he has never attached to anyone.</span>
00829     <span class="comment">//</span>
00830     lowerDeviceObject = <a class="code" href="../../d9/d4/trackirp_8h.html#a125">IovpGetDeviceAttachedTo</a>(DeviceObject) ;
00831     <span class="keywordflow">if</span> (lowerDeviceObject) {
00832         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>(lowerDeviceObject) ;
00833     } <span class="keywordflow">else</span> {
00834         iovCurrentStackLocation-&gt;<a class="code" href="../../d9/d1/struct__IOV__STACK__LOCATION.html#o1">Flags</a> |= <a class="code" href="../../d9/d4/trackirp_8h.html#a49">STACKFLAG_REACHED_PDO</a> ;
00835     }
00836 
00837     <span class="comment">//</span>
00838     <span class="comment">// Record who is getting this IRP (we will blame any mistakes on him</span>
00839     <span class="comment">// if this request gets completed.) Note that we've already asserted</span>
00840     <span class="comment">// DeviceObject is non-NULL...</span>
00841     <span class="comment">//</span>
00842     driverObject = DeviceObject-&gt;DriverObject ;
00843     dispatchRoutine = driverObject-&gt;<a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html#o14">MajorFunction</a>[irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a>] ;
00844     iovCurrentStackLocation-&gt;<a class="code" href="../../d9/d1/struct__IOV__STACK__LOCATION.html#o5">LastDispatch</a> = dispatchRoutine ;
00845 
00846     <span class="comment">//</span>
00847     <span class="comment">// Uncomplete the request if we are heading back down with it...</span>
00848     <span class="comment">//</span>
00849     iovCurrentStackLocation-&gt;<a class="code" href="../../d9/d1/struct__IOV__STACK__LOCATION.html#o1">Flags</a> &amp;=~ STACKFLAG_REQUEST_COMPLETED ;
00850 
00851     <span class="comment">//</span>
00852     <span class="comment">// This IofCallDriver2 dude will need to be told what his status should</span>
00853     <span class="comment">// be later. Add him to the linked list of addresses to scribble away</span>
00854     <span class="comment">// stati when the appropriate level is completed.</span>
00855     <span class="comment">//</span>
00856     InsertHeadList(
00857         &amp;iovCurrentStackLocation-&gt;<a class="code" href="../../d9/d1/struct__IOV__STACK__LOCATION.html#o3">CallStackData</a>,
00858         &amp;IofCallDriverStackData-&gt;SharedLocationList
00859         ) ;
00860 
00861     <span class="comment">//</span>
00862     <span class="comment">// More IofCallDriver2 stuff, tell him the stack location.</span>
00863     <span class="comment">//</span>
00864     IofCallDriverStackData-&gt;IovStackLocation = iovCurrentStackLocation ;
00865 
00866     <span class="comment">// If it's a remove IRP, mark everyone appropriately</span>
00867     <span class="keywordflow">if</span> ((irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a> == <a class="code" href="../../d0/d5/io_8h.html#a40">IRP_MJ_PNP</a>)&amp;&amp;
00868         (irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o1">MinorFunction</a> == <a class="code" href="../../d0/d5/io_8h.html#a67">IRP_MN_REMOVE_DEVICE</a>)) {
00869 
00870         IofCallDriverStackData-&gt;<a class="code" href="../../d9/d1/struct__IOV__STACK__LOCATION.html#o1">Flags</a> |= <a class="code" href="../../d9/d4/trackirp_8h.html#a52">CALLFLAG_IS_REMOVE_IRP</a> ;
00871 
00872         pdo = <a class="code" href="../../d9/d4/trackirp_8h.html#a128">IovpGetLowestDevice</a>(DeviceObject) ;
00873         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(pdo) ;
00874         IofCallDriverStackData-&gt;RemovePdo = pdo ;
00875         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>(pdo) ;
00876         <span class="keywordflow">if</span> (<a class="code" href="../../d9/d4/trackirp_8h.html#a130">IovpIsInFdoStack</a>(DeviceObject) &amp;&amp;
00877             (!(DeviceObject-&gt;DeviceObjectExtension-&gt;ExtensionFlags&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a43">DOE_RAW_FDO</a>))) {
00878             IofCallDriverStackData-&gt;Flags |= <a class="code" href="../../d9/d4/trackirp_8h.html#a53">CALLFLAG_REMOVING_FDO_STACK_DO</a> ;
00879         }
00880     }
00881 
00882     <span class="keywordflow">if</span> ((iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o11">AssertFlags</a>&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a2">ASSERTFLAG_POLICEIRPS</a>) &amp;&amp;
00883         (iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o11">AssertFlags</a>&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a3">ASSERTFLAG_MONITORMAJORS</a>)) {
00884 
00885         <span class="comment">//</span>
00886         <span class="comment">// Do IRP-major specific assertions as appropriate</span>
00887         <span class="comment">//</span>
00888         <span class="keywordflow">if</span> (isNewSession) {
00889 
00890             <a class="code" href="../../d8/d4/flunkirp_8h.html#a1">IovpAssertNewIrps</a>(iovPacket, irpSp, iovCurrentStackLocation) ;
00891         }
00892 
00893         <span class="keywordflow">if</span> (isNewRequest) {
00894 
00895             <a class="code" href="../../d8/d4/flunkirp_8h.html#a2">IovpAssertNewRequest</a>(iovPacket, DeviceObject, irpLastSp, irpSp, iovCurrentStackLocation) ;
00896         }
00897 
00898         <a class="code" href="../../d8/d4/flunkirp_8h.html#a4">IovpAssertIrpStackDownward</a>(iovPacket, DeviceObject, irpLastSp, irpSp, iovCurrentStackLocation) ;
00899     }
00900 
00901     <span class="comment">//</span>
00902     <span class="comment">// Update our fields</span>
00903     <span class="comment">//</span>
00904     iovSessionData-&gt;<a class="code" href="../../d8/d1/struct__IOV__SESSION__DATA.html#o6">DeviceLastCalled</a> = DeviceObject ;
00905     iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o18">LastLocation</a> = irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o13">CurrentLocation</a> ;
00906     iovCurrentStackLocation-&gt;<a class="code" href="../../d9/d1/struct__IOV__STACK__LOCATION.html#o2">RequestsFirstStackLocation</a>-&gt;<a class="code" href="../../d9/d1/struct__IOV__STACK__LOCATION.html#o11">LastStatusBlock</a> = irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>;
00907 
00908     <span class="comment">//</span>
00909     <span class="comment">// Dope the next stack location so we can detect usage of</span>
00910     <span class="comment">// IoCopyCurrentIrpStackLocationToNext or IoSetCompletionRoutine.</span>
00911     <span class="comment">//</span>
00912     <span class="keywordflow">if</span> (irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o13">CurrentLocation</a>&gt;1) {
00913         <a class="code" href="../../d0/d5/io_8h.html#a238">IoSetNextIrpStackLocation</a>( irp ) ;
00914         irpSp = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>( irp );
00915         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o3">Control</a> |= <a class="code" href="../../d9/d4/trackirp_8h.html#a60">SL_NOTCOPIED</a> ;
00916         <a class="code" href="../../d0/d5/io_8h.html#a240">IoSkipCurrentIrpStackLocation</a>( irp ) ;
00917     }
00918 
00919     <span class="comment">//</span>
00920     <span class="comment">// Randomly set the cancel flag on a percentage of forwarded IRPs. Many</span>
00921     <span class="comment">// drivers queue first and after dequeue assume the cancel routine they</span>
00922     <span class="comment">// set must have been cleared if Cancel = TRUE. They don't handle the case</span>
00923     <span class="comment">// were the Irp was cancelled in flight.</span>
00924     <span class="comment">//</span>
00925     <span class="comment">// ADRIAO BUGBUG 07/16/1999 -</span>
00926     <span class="comment">//     Do better spontaneous cancel logic later.</span>
00927     <span class="comment">//</span>
00928     <span class="keywordflow">if</span> ((<a class="code" href="../../d8/d4/trackirp_8c.html#a10">IovpInitFlags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a265">IOVERIFIERINIT_RANDOMLY_CANCEL_IRPS</a>) &amp;&amp;
00929         (!(irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a174">IRP_PAGING_IO</a>))) {
00930 
00931         <span class="keywordflow">if</span> (((++<a class="code" href="../../d8/d4/trackirp_8c.html#a11">IovpCancelCount</a>) % 4000) == 0) {
00932 
00933             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o14">Cancel</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00934         }
00935     }
00936 
00937     <span class="comment">//</span>
00938     <span class="comment">// Assert LastLocation is consistent with an IRP that may be completed.</span>
00939     <span class="comment">//</span>
00940     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(iovSessionData-&gt;<a class="code" href="../../d8/d1/struct__IOV__SESSION__DATA.html#o9">StackData</a>[iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o18">LastLocation</a>-1].InUse) ;
00941 
00942     <a class="code" href="../../d6/d7/sessnirp_8h.html#a2">IovpSessionDataReference</a>(iovSessionData);
00943     <a class="code" href="../../d9/d8/hashirp_8h.html#a12">IovpTrackingDataReleaseLock</a>(iovPacket) ;
00944 }
00945 
00946 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00947 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l00948"></a><a class="code" href="../../d9/d4/trackirp_8h.html#a109">00948</a> <a class="code" href="../../d9/d4/trackirp_8h.html#a109">IovpCallDriver2</a>(
00949     IN     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>               Irp,
00950     IN     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>     DeviceObject,
00951     IN     PVOID              DispatchRoutine,
00952     IN OUT NTSTATUS           *FinalStatus,
00953     IN     <a class="code" href="../../d3/d0/struct__IOFCALLDRIVER__STACKDATA.html">PIOFCALLDRIVER_STACKDATA</a> IofCallDriverStackData
00954     )
00955 <span class="comment">/*++</span>
00956 <span class="comment"></span>
00957 <span class="comment">  Description:</span>
00958 <span class="comment"></span>
00959 <span class="comment">    This routine is called by IofCallDriver just after the driver's dispatch</span>
00960 <span class="comment">    routine has been called. The IRP may not be touchable at this time.</span>
00961 <span class="comment"></span>
00962 <span class="comment">  Arguments:</span>
00963 <span class="comment"></span>
00964 <span class="comment">    Irp                    - A pointer to the IRP passed into IofCallDriver.</span>
00965 <span class="comment">                             The IRP may not be touchable right now.</span>
00966 <span class="comment"></span>
00967 <span class="comment">    DispatchRoutine        - Dispatch routine that was called by IofCallDriver.</span>
00968 <span class="comment"></span>
00969 <span class="comment">    FinalStatus            - A pointer to the status returned by the dispatch</span>
00970 <span class="comment">                             routine. This may be changed if all IRPs are being</span>
00971 <span class="comment">                             forced "pending".</span>
00972 <span class="comment"></span>
00973 <span class="comment">    IofCallDriverStackData - Pointer to a local variable on IofCallDriver's</span>
00974 <span class="comment">                             stack to retreive data stored by</span>
00975 <span class="comment">                             IovpCallDriver1.</span>
00976 <span class="comment"></span>
00977 <span class="comment">  Return Value:</span>
00978 <span class="comment"></span>
00979 <span class="comment">     None.</span>
00980 <span class="comment"></span>
00981 <span class="comment">--*/</span>
00982 {
00983     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status, lastStatus;
00984     <a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html">PIOV_REQUEST_PACKET</a> iovPacket;
00985     <a class="code" href="../../d8/d1/struct__IOV__SESSION__DATA.html">PIOV_SESSION_DATA</a> iovSessionData;
00986     ULONG refCount;
00987     <a class="code" href="../../d9/d1/struct__IOV__STACK__LOCATION.html">PIOV_STACK_LOCATION</a> iovCurrentStackLocation;
00988     BOOLEAN mustDetachAndDelete;
00989     <a class="code" href="../../d4/d4/struct__DEVICE__NODE.html">PDEVICE_NODE</a> devNode;
00990     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> lowerDevObj;
00991 
00992     iovSessionData = IofCallDriverStackData-&gt;IovSessionData;
00993     <span class="keywordflow">if</span> (iovSessionData == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00994 
00995         <span class="keywordflow">return</span>;
00996     }
00997 
00998     iovPacket = iovSessionData-&gt;<a class="code" href="../../d8/d1/struct__IOV__SESSION__DATA.html#o0">IovRequestPacket</a>;
00999     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(iovPacket);
01000     <a class="code" href="../../d9/d8/hashirp_8h.html#a11">IovpTrackingDataAcquireLock</a>(iovPacket);
01001 
01002     <span class="comment">//</span>
01003     <span class="comment">// ADRIAO BUGBUG 08/10/1999 -</span>
01004     <span class="comment">//     This needs to be reenabled once the DNF_ flags are used in a</span>
01005     <span class="comment">// consistant manner.</span>
01006     <span class="comment">//</span>
01007 <span class="preprocessor">#if 0</span>
01008 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (iovSessionData-&gt;<a class="code" href="../../d8/d1/struct__IOV__SESSION__DATA.html#o4">AssertFlags</a>&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a2">ASSERTFLAG_POLICEIRPS</a>) {
01009 
01010         <span class="keywordflow">if</span> (IofCallDriverStackData-&gt;Flags&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a52">CALLFLAG_IS_REMOVE_IRP</a>) {
01011 
01012             <span class="keywordflow">if</span> ((*FinalStatus != STATUS_PENDING) &amp;&amp;
01013                 (iovCurrentStackLocation-&gt;<a class="code" href="../../d9/d1/struct__IOV__STACK__LOCATION.html#o12">ThreadDispatchedTo</a> == <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>())) {
01014 
01015                 lowerDevObj = <a class="code" href="../../d9/d4/trackirp_8h.html#a125">IovpGetDeviceAttachedTo</a>(DeviceObject) ;
01016 
01017                 <span class="comment">//</span>
01018                 <span class="comment">// We can look at this because the caller has committed to this being</span>
01019                 <span class="comment">// completed now, and we are on the original thread.</span>
01020                 <span class="comment">//</span>
01021                 <span class="comment">// N.B. This works because all the objects in the stack have been</span>
01022                 <span class="comment">// referenced during a remove. If we decide to only reference the</span>
01023                 <span class="comment">// top object, this logic would break...</span>
01024                 <span class="comment">//</span>
01025                 <span class="keywordflow">if</span> (IofCallDriverStackData-&gt;Flags&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a53">CALLFLAG_REMOVING_FDO_STACK_DO</a>) {
01026 
01027                     <span class="comment">//</span>
01028                     <span class="comment">// FDO, Upper, &amp; Lower filters *must* go. Note that lowerDevObj</span>
01029                     <span class="comment">// should be null as we should have detached.</span>
01030                     <span class="comment">//</span>
01031                     mustDetachAndDelete = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> ;
01032 
01033                 } <span class="keywordflow">else</span> {
01034 
01035                     devNode = IofCallDriverStackData-&gt;RemovePdo-&gt;DeviceObjectExtension-&gt;DeviceNode ;
01036                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(devNode) ;
01037 
01038                     <span class="keywordflow">if</span> (devNode-&gt;<a class="code" href="../../d4/d4/struct__DEVICE__NODE.html#o6">Flags</a> &amp; <a class="code" href="../../d9/d0/pnpiop_8h.html#a33">DNF_DEVICE_GONE</a>) {
01039 
01040                         <span class="comment">//</span>
01041                         <span class="comment">// It's been reported as missing. It *must* go!</span>
01042                         <span class="comment">//</span>
01043                         mustDetachAndDelete = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> ;
01044 
01045                     } <span class="keywordflow">else</span> {
01046 
01047                         <span class="comment">//</span>
01048                         <span class="comment">// It must stay!</span>
01049                         <span class="comment">//</span>
01050                         mustDetachAndDelete = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> ;
01051                     }
01052                 }
01053 
01054                 <span class="keywordflow">if</span> (mustDetachAndDelete) {
01055 
01056                     <span class="comment">//</span>
01057                     <span class="comment">// IoDetachDevice and IoDeleteDevice should have been called.</span>
01058                     <span class="comment">// First verify IoDetachDevice...</span>
01059                     <span class="comment">//</span>
01060                     <span class="keywordflow">if</span> (lowerDevObj) {
01061 
01062                         <a class="code" href="../../d2/d5/ioassert_8h.html#a21">WDM_FAIL_ROUTINE</a>((
01063                             <a class="code" href="../../d2/d5/ioassert_8h.html#a114a68">DCERROR_SHOULDVE_DETACHED</a>,
01064                             <a class="code" href="../../d2/d5/ioassert_8h.html#a7">DCPARAM_IRP</a> + <a class="code" href="../../d2/d5/ioassert_8h.html#a8">DCPARAM_ROUTINE</a> + <a class="code" href="../../d2/d5/ioassert_8h.html#a9">DCPARAM_DEVOBJ</a>,
01065                             iovSessionData-&gt;<a class="code" href="../../d8/d1/struct__IOV__SESSION__DATA.html#o8">BestVisibleIrp</a>,
01066                             DispatchRoutine,
01067                             DeviceObject
01068                             ));
01069                     }
01070 
01071                     <span class="comment">//</span>
01072                     <span class="comment">// Now verify IoDeleteDevice</span>
01073                     <span class="comment">//</span>
01074                     <span class="keywordflow">if</span> (!(DeviceObject-&gt;DeviceObjectExtension-&gt;ExtensionFlags&amp;<a class="code" href="../../d0/d5/io_8h.html#a139">DOE_DELETE_PENDING</a>)) {
01075 
01076                         <a class="code" href="../../d2/d5/ioassert_8h.html#a21">WDM_FAIL_ROUTINE</a>((
01077                             <a class="code" href="../../d2/d5/ioassert_8h.html#a114a69">DCERROR_SHOULDVE_DELETED</a>,
01078                             <a class="code" href="../../d2/d5/ioassert_8h.html#a7">DCPARAM_IRP</a> + <a class="code" href="../../d2/d5/ioassert_8h.html#a8">DCPARAM_ROUTINE</a> + <a class="code" href="../../d2/d5/ioassert_8h.html#a9">DCPARAM_DEVOBJ</a>,
01079                             iovSessionData-&gt;<a class="code" href="../../d8/d1/struct__IOV__SESSION__DATA.html#o8">BestVisibleIrp</a>,
01080                             DispatchRoutine,
01081                             DeviceObject
01082                             ));
01083                     }
01084 
01085                 } <span class="keywordflow">else</span> {
01086 
01087                     <span class="comment">//</span>
01088                     <span class="comment">// Did we mistakenly leave? Verify we aren't a bus filter that</span>
01089                     <span class="comment">// has been fooled. In that case, no checking can be done...</span>
01090                     <span class="comment">//</span>
01091                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(!(IofCallDriverStackData-&gt;Flags&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a53">CALLFLAG_REMOVING_FDO_STACK_DO</a>)) ;
01092 
01093                     <span class="keywordflow">if</span> (DeviceObject == IofCallDriverStackData-&gt;RemovePdo) {
01094 
01095                         <span class="comment">//</span>
01096                         <span class="comment">// Check PDO's - did we mistakenly delete ourselves?</span>
01097                         <span class="comment">//</span>
01098                         <span class="keywordflow">if</span> (DeviceObject-&gt;DeviceObjectExtension-&gt;ExtensionFlags&amp;<a class="code" href="../../d0/d5/io_8h.html#a139">DOE_DELETE_PENDING</a>) {
01099 
01100                             <a class="code" href="../../d2/d5/ioassert_8h.html#a21">WDM_FAIL_ROUTINE</a>((
01101                                 <a class="code" href="../../d2/d5/ioassert_8h.html#a114a72">DCERROR_DELETED_PRESENT_PDO</a>,
01102                                 <a class="code" href="../../d2/d5/ioassert_8h.html#a7">DCPARAM_IRP</a> + <a class="code" href="../../d2/d5/ioassert_8h.html#a8">DCPARAM_ROUTINE</a> + <a class="code" href="../../d2/d5/ioassert_8h.html#a9">DCPARAM_DEVOBJ</a>,
01103                                 iovSessionData-&gt;<a class="code" href="../../d8/d1/struct__IOV__SESSION__DATA.html#o8">BestVisibleIrp</a>,
01104                                 DispatchRoutine,
01105                                 DeviceObject
01106                                 ));
01107                         }
01108 
01109                     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!(IofCallDriverStackData-&gt;RemovePdo-&gt;DeviceObjectExtension-&gt;ExtensionFlags&amp;<a class="code" href="../../d0/d5/io_8h.html#a139">DOE_DELETE_PENDING</a>)) {
01110 
01111                         <span class="comment">//</span>
01112                         <span class="comment">// Check bus filters. Bus filters better not have detached</span>
01113                         <span class="comment">// or deleted themselves, as the PDO is still present!</span>
01114                         <span class="comment">//</span>
01115                         <span class="keywordflow">if</span> (lowerDevObj == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01116 
01117                             <span class="comment">//</span>
01118                             <span class="comment">// Oops, it detached. Baad bus filter...</span>
01119                             <span class="comment">//</span>
01120                             <a class="code" href="../../d2/d5/ioassert_8h.html#a21">WDM_FAIL_ROUTINE</a>((
01121                                 <a class="code" href="../../d2/d5/ioassert_8h.html#a114a73">DCERROR_BUS_FILTER_ERRONEOUSLY_DETACHED</a>,
01122                                 <a class="code" href="../../d2/d5/ioassert_8h.html#a7">DCPARAM_IRP</a> + <a class="code" href="../../d2/d5/ioassert_8h.html#a8">DCPARAM_ROUTINE</a> + <a class="code" href="../../d2/d5/ioassert_8h.html#a9">DCPARAM_DEVOBJ</a>,
01123                                 iovSessionData-&gt;<a class="code" href="../../d8/d1/struct__IOV__SESSION__DATA.html#o8">BestVisibleIrp</a>,
01124                                 DispatchRoutine,
01125                                 DeviceObject
01126                                 ));
01127                         }
01128 
01129                         <span class="keywordflow">if</span> (DeviceObject-&gt;DeviceObjectExtension-&gt;ExtensionFlags&amp;<a class="code" href="../../d0/d5/io_8h.html#a139">DOE_DELETE_PENDING</a>) {
01130 
01131                             <span class="comment">//</span>
01132                             <span class="comment">// It deleted itself. Also very bad...</span>
01133                             <span class="comment">//</span>
01134                             <a class="code" href="../../d2/d5/ioassert_8h.html#a21">WDM_FAIL_ROUTINE</a>((
01135                                 <a class="code" href="../../d2/d5/ioassert_8h.html#a114a74">DCERROR_BUS_FILTER_ERRONEOUSLY_DELETED</a>,
01136                                 <a class="code" href="../../d2/d5/ioassert_8h.html#a7">DCPARAM_IRP</a> + <a class="code" href="../../d2/d5/ioassert_8h.html#a8">DCPARAM_ROUTINE</a> + <a class="code" href="../../d2/d5/ioassert_8h.html#a9">DCPARAM_DEVOBJ</a>,
01137                                 iovSessionData-&gt;<a class="code" href="../../d8/d1/struct__IOV__SESSION__DATA.html#o8">BestVisibleIrp</a>,
01138                                 DispatchRoutine,
01139                                 DeviceObject
01140                                 ));
01141                         }
01142                     }
01143                 }
01144 
01145                 <span class="keywordflow">if</span> (lowerDevObj) {
01146 
01147                     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>(lowerDevObj) ;
01148                 }
01149             }
01150         }
01151     }
01152 <span class="preprocessor">#endif</span>
01153 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (IofCallDriverStackData-&gt;Flags&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a51">CALLFLAG_COMPLETED</a>) {
01154 
01155         <a class="code" href="../../d9/d4/trackirp_8h.html#a88">TRACKIRP_DBGPRINT</a>((
01156             <span class="stringliteral">"  Verifying status in CD2\n"</span>
01157             ),2) ;
01158 
01159         <span class="keywordflow">if</span> ((*FinalStatus != IofCallDriverStackData-&gt;ExpectedStatus)&amp;&amp;
01160             (*FinalStatus != STATUS_PENDING)) {
01161 
01162             <span class="keywordflow">if</span> ((iovSessionData-&gt;<a class="code" href="../../d8/d1/struct__IOV__SESSION__DATA.html#o4">AssertFlags</a>&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a2">ASSERTFLAG_POLICEIRPS</a>) &amp;&amp;
01163                 (!(iovSessionData-&gt;<a class="code" href="../../d8/d1/struct__IOV__SESSION__DATA.html#o3">SessionFlags</a>&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a57">SESSIONFLAG_UNWOUND_INCONSISTANT</a>))) {
01164 
01165 
01166                 <span class="comment">//</span>
01167                 <span class="comment">// The completion routine and the return value don't match. Hey!</span>
01168                 <span class="comment">//</span>
01169                 <a class="code" href="../../d2/d5/ioassert_8h.html#a21">WDM_FAIL_ROUTINE</a>((
01170                     <a class="code" href="../../d2/d5/ioassert_8h.html#a114a75">DCERROR_INCONSISTANT_STATUS</a>,
01171                     <a class="code" href="../../d2/d5/ioassert_8h.html#a7">DCPARAM_IRP</a> + <a class="code" href="../../d2/d5/ioassert_8h.html#a8">DCPARAM_ROUTINE</a> + <a class="code" href="../../d2/d5/ioassert_8h.html#a10">DCPARAM_STATUS</a>*2,
01172                     iovSessionData-&gt;<a class="code" href="../../d8/d1/struct__IOV__SESSION__DATA.html#o8">BestVisibleIrp</a>,
01173                     DispatchRoutine,
01174                     IofCallDriverStackData-&gt;ExpectedStatus,
01175                     *FinalStatus
01176                     ));
01177             }
01178 
01179             iovSessionData-&gt;<a class="code" href="../../d8/d1/struct__IOV__SESSION__DATA.html#o3">SessionFlags</a> |= <a class="code" href="../../d9/d4/trackirp_8h.html#a57">SESSIONFLAG_UNWOUND_INCONSISTANT</a>;
01180 
01181         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*FinalStatus == 0xFFFFFFFF) {
01182 
01183             <span class="keywordflow">if</span> (iovSessionData-&gt;<a class="code" href="../../d8/d1/struct__IOV__SESSION__DATA.html#o4">AssertFlags</a>&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a2">ASSERTFLAG_POLICEIRPS</a>) {
01184 
01185 
01186                 <span class="comment">//</span>
01187                 <span class="comment">// This status value is illegal. If we see it, we probably have</span>
01188                 <span class="comment">// an uninitialized variable...</span>
01189                 <span class="comment">//</span>
01190                 <a class="code" href="../../d2/d5/ioassert_8h.html#a21">WDM_FAIL_ROUTINE</a>((
01191                     <a class="code" href="../../d2/d5/ioassert_8h.html#a114a76">DCERROR_UNINITIALIZED_STATUS</a>,
01192                     <a class="code" href="../../d2/d5/ioassert_8h.html#a7">DCPARAM_IRP</a> + <a class="code" href="../../d2/d5/ioassert_8h.html#a8">DCPARAM_ROUTINE</a>,
01193                     iovSessionData-&gt;<a class="code" href="../../d8/d1/struct__IOV__SESSION__DATA.html#o8">BestVisibleIrp</a>,
01194                     DispatchRoutine
01195                     ));
01196             }
01197         }
01198 
01199         <span class="comment">//</span>
01200         <span class="comment">// We do not need to remove ourselves from the list because</span>
01201         <span class="comment">// we will not be completed twice (InUse is NULL makes sure).</span>
01202         <span class="comment">//</span>
01203 
01204     } <span class="keywordflow">else</span> {
01205 
01206         <span class="comment">//</span>
01207         <span class="comment">// OK, we haven't completed yet. Status better</span>
01208         <span class="comment">// be pending...</span>
01209         <span class="comment">//</span>
01210         <a class="code" href="../../d9/d4/trackirp_8h.html#a88">TRACKIRP_DBGPRINT</a>((
01211             <span class="stringliteral">"  Verifying status is STATUS_PENDING in CR2\n"</span>
01212             ), 2) ;
01213 
01214         <span class="keywordflow">if</span> (*FinalStatus != STATUS_PENDING) {
01215 
01216             <span class="keywordflow">if</span> ((iovSessionData-&gt;<a class="code" href="../../d8/d1/struct__IOV__SESSION__DATA.html#o4">AssertFlags</a>&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a2">ASSERTFLAG_POLICEIRPS</a>) &amp;&amp;
01217                 (!(iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o5">Flags</a>&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a36">TRACKFLAG_UNWOUND_BADLY</a>))) {
01218 
01219                 <span class="comment">//</span>
01220                 <span class="comment">// We got control before this slot was completed. This is</span>
01221                 <span class="comment">// legal as long as STATUS_PENDING was returned (it was not),</span>
01222                 <span class="comment">// so it's bug time. Note that the IRP may not be safe to touch.</span>
01223                 <span class="comment">//</span>
01224                 <a class="code" href="../../d2/d5/ioassert_8h.html#a21">WDM_FAIL_ROUTINE</a>((
01225                     <a class="code" href="../../d2/d5/ioassert_8h.html#a114a77">DCERROR_IRP_RETURNED_WITHOUT_COMPLETION</a>,
01226                     <a class="code" href="../../d2/d5/ioassert_8h.html#a7">DCPARAM_IRP</a> + <a class="code" href="../../d2/d5/ioassert_8h.html#a8">DCPARAM_ROUTINE</a>,
01227                     iovSessionData-&gt;<a class="code" href="../../d8/d1/struct__IOV__SESSION__DATA.html#o8">BestVisibleIrp</a>,
01228                     DispatchRoutine
01229                     ));
01230             }
01231 
01232             iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o5">Flags</a> |= <a class="code" href="../../d9/d4/trackirp_8h.html#a36">TRACKFLAG_UNWOUND_BADLY</a>;
01233         }
01234 
01235         iovCurrentStackLocation = (<a class="code" href="../../d9/d1/struct__IOV__STACK__LOCATION.html">PIOV_STACK_LOCATION</a>)(IofCallDriverStackData-&gt;IovStackLocation) ;
01236         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(iovCurrentStackLocation-&gt;<a class="code" href="../../d9/d1/struct__IOV__STACK__LOCATION.html#o0">InUse</a>) ;
01237         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(!IsListEmpty(&amp;iovCurrentStackLocation-&gt;<a class="code" href="../../d9/d1/struct__IOV__STACK__LOCATION.html#o3">CallStackData</a>)) ;
01238 
01239         <span class="comment">//</span>
01240         <span class="comment">// We now extricate ourselves from the list.</span>
01241         <span class="comment">//</span>
01242         RemoveEntryList(&amp;IofCallDriverStackData-&gt;SharedLocationList) ;
01243     }
01244 
01245     <span class="keywordflow">if</span> ((IofCallDriverStackData-&gt;Flags&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a54">CALLFLAG_OVERRIDE_STATUS</a>)&amp;&amp;
01246         (*FinalStatus != STATUS_PENDING)) {
01247 
01248         *FinalStatus = IofCallDriverStackData-&gt;NewStatus ;
01249     }
01250 
01251     <span class="keywordflow">if</span> ((iovSessionData-&gt;<a class="code" href="../../d8/d1/struct__IOV__SESSION__DATA.html#o4">AssertFlags</a>&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a7">ASSERTFLAG_FORCEPENDING</a>) &amp;&amp;
01252         (!(IofCallDriverStackData-&gt;Flags&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a52">CALLFLAG_IS_REMOVE_IRP</a>))) {
01253 
01254         <span class="comment">//</span>
01255         <span class="comment">// We also have the option of causing trouble by making every Irp</span>
01256         <span class="comment">// look as if were pending.</span>
01257         <span class="comment">//</span>
01258         *FinalStatus = STATUS_PENDING ;
01259     }
01260 
01261     <a class="code" href="../../d6/d7/sessnirp_8h.html#a3">IovpSessionDataDereference</a>(iovSessionData);
01262     <a class="code" href="../../d9/d8/hashirp_8h.html#a12">IovpTrackingDataReleaseLock</a>(iovPacket);
01263 }
01264 
01265 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01266 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l01267"></a><a class="code" href="../../d9/d4/trackirp_8h.html#a110">01267</a> <a class="code" href="../../d9/d4/trackirp_8h.html#a110">IovpCompleteRequest1</a>(
01268     IN     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>               Irp,
01269     IN     CCHAR              <a class="code" href="../../d0/d6/iop_8h.html#a36">PriorityBoost</a>,
01270     IN OUT <a class="code" href="../../d4/d0/struct__IOFCOMPLETEREQUEST__STACKDATA.html">PIOFCOMPLETEREQUEST_STACKDATA</a> CompletionPacket
01271     )
01272 <span class="comment">/*++</span>
01273 <span class="comment"></span>
01274 <span class="comment">  Description</span>
01275 <span class="comment"></span>
01276 <span class="comment">    This routine is called the moment IofCompleteRequest is invoked, and</span>
01277 <span class="comment">    before any completion routines get called and before the IRP stack</span>
01278 <span class="comment">    is adjusted in any way.</span>
01279 <span class="comment"></span>
01280 <span class="comment">  Arguments:</span>
01281 <span class="comment"></span>
01282 <span class="comment">    Irp                    - A pointer to the IRP passed into</span>
01283 <span class="comment">                             IofCompleteRequest.</span>
01284 <span class="comment"></span>
01285 <span class="comment">    PriorityBoost          - The priority boost passed into</span>
01286 <span class="comment">                             IofCompleteRequest.</span>
01287 <span class="comment"></span>
01288 <span class="comment">    CompletionPacket       - A pointer to a local variable on the stack of</span>
01289 <span class="comment">                             IofCompleteRequest. The information stored in</span>
01290 <span class="comment">                             this local variable will be picked up by</span>
01291 <span class="comment">                             IovpCompleteRequest2-5.</span>
01292 <span class="comment">  Return Value:</span>
01293 <span class="comment"></span>
01294 <span class="comment">     None.</span>
01295 <span class="comment">--*/</span>
01296 {
01297     <a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html">PIOV_REQUEST_PACKET</a> iovPacket;
01298     <a class="code" href="../../d8/d1/struct__IOV__SESSION__DATA.html">PIOV_SESSION_DATA</a> iovSessionData;
01299     BOOLEAN slotIsInUse;
01300     <a class="code" href="../../d9/d1/struct__IOV__STACK__LOCATION.html">PIOV_STACK_LOCATION</a> iovCurrentStackLocation;
01301     ULONG locationsAdvanced;
01302     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpSp;
01303     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> lowerDevobj;
01304 
01305     iovPacket = <a class="code" href="../../d9/d8/hashirp_8h.html#a7">IovpTrackingDataFindAndLock</a>(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>);
01306 
01307     CompletionPacket-&gt;RaisedCount = 0;
01308 
01309     <span class="keywordflow">if</span> (iovPacket == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01310 
01311         CompletionPacket-&gt;IovSessionData = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01312         <span class="keywordflow">return</span>;
01313     }
01314 
01315     iovSessionData = <a class="code" href="../../d9/d8/hashirp_8h.html#a16">IovpTrackingDataGetCurrentSessionData</a>(iovPacket);
01316 
01317     CompletionPacket-&gt;IovSessionData = iovSessionData;
01318     CompletionPacket-&gt;<a class="code" href="../../d8/d1/struct__IOV__SESSION__DATA.html#o0">IovRequestPacket</a> = iovPacket;
01319 
01320     <span class="keywordflow">if</span> (iovSessionData == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01321 
01322         <span class="comment">//</span>
01323         <span class="comment">// We just got a look at the allocation, not the session itself.</span>
01324         <span class="comment">// This can happen if a driver calls IofCompleteRequest on an internally</span>
01325         <span class="comment">// generated IRP before calling IofCallDriver. NPFS does this.</span>
01326         <span class="comment">//</span>
01327         <a class="code" href="../../d9/d8/hashirp_8h.html#a12">IovpTrackingDataReleaseLock</a>(iovPacket);
01328         <span class="keywordflow">return</span>;
01329     }
01330 
01331     <a class="code" href="../../d9/d4/trackirp_8h.html#a88">TRACKIRP_DBGPRINT</a>((
01332         <span class="stringliteral">"  CR1: Current, Last = (%x, %x)\n"</span>,
01333         <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o13">CurrentLocation</a>, iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o18">LastLocation</a>
01334         ), 3);
01335 
01336     irpSp = <a class="code" href="../../d0/d5/io_8h.html#a228">IoGetCurrentIrpStackLocation</a>(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>);
01337 
01338     <span class="keywordflow">if</span> (iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o5">Flags</a>&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a29">TRACKFLAG_QUEUED_INTERNALLY</a>) {
01339 
01340         <span class="comment">//</span>
01341         <span class="comment">// We are probably going to die now. Anyway, it was a good life...</span>
01342         <span class="comment">//</span>
01343         <a class="code" href="../../d2/d5/ioassert_8h.html#a17">WDM_FAIL_CALLER3</a>((<a class="code" href="../../d2/d5/ioassert_8h.html#a114a48">DCERROR_QUEUED_IRP_COMPLETED</a>, <a class="code" href="../../d2/d5/ioassert_8h.html#a7">DCPARAM_IRP</a>, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>));
01344     }
01345 
01346     <span class="comment">//</span>
01347     <span class="comment">// This would be *very* bad - someone is completing an IRP that is</span>
01348     <span class="comment">// currently in progress...</span>
01349     <span class="comment">//</span>
01350     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(!(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a>&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a23">IRP_DIAG_HAS_SURROGATE</a>));
01351 
01352     <span class="comment">//</span>
01353     <span class="comment">// Hmmm, someone is completing an IRP that IoCallDriver never called. These</span>
01354     <span class="comment">// is possible but rather gross, so we warn.</span>
01355     <span class="comment">//</span>
01356     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o13">CurrentLocation</a> == ((CCHAR) <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o12">StackCount</a> + 1)) {
01357 
01358         <a class="code" href="../../d2/d5/ioassert_8h.html#a12">WDM_CHASTISE_CALLER3</a>((<a class="code" href="../../d2/d5/ioassert_8h.html#a114a96">DCERROR_UNFORWARDED_IRP_COMPLETED</a>, <a class="code" href="../../d2/d5/ioassert_8h.html#a7">DCPARAM_IRP</a>, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>));
01359     }
01360 
01361     <span class="comment">//</span>
01362     <span class="comment">// Record priority for our own later recompletion...</span>
01363     <span class="comment">//</span>
01364     iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o17">PriorityBoost</a> = <a class="code" href="../../d0/d6/iop_8h.html#a36">PriorityBoost</a>;
01365 
01366     <span class="comment">//</span>
01367     <span class="comment">// We have the option of causing trouble by making every Irp look</span>
01368     <span class="comment">// as if were pending. It is best to do it here, as this also takes</span>
01369     <span class="comment">// care of anybody who has synchronized the IRP and thus does not need</span>
01370     <span class="comment">// to mark it pending in his completion routine.</span>
01371     <span class="comment">//</span>
01372     <span class="keywordflow">if</span> (iovSessionData-&gt;<a class="code" href="../../d8/d1/struct__IOV__SESSION__DATA.html#o4">AssertFlags</a>&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a7">ASSERTFLAG_FORCEPENDING</a>) {
01373 
01374         <a class="code" href="../../d0/d5/io_8h.html#a234">IoMarkIrpPending</a>(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>);
01375     }
01376 
01377     <span class="comment">//</span>
01378     <span class="comment">// Do this so that if the IRP comes down again, it looks like a new one</span>
01379     <span class="comment">// to the "forward them correctly" code.</span>
01380     <span class="comment">//</span>
01381     iovSessionData-&gt;<a class="code" href="../../d8/d1/struct__IOV__SESSION__DATA.html#o6">DeviceLastCalled</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01382 
01383     locationsAdvanced = iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o18">LastLocation</a> - <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o13">CurrentLocation</a>;
01384 
01385     <span class="comment">//</span>
01386     <span class="comment">// Remember this so that we can detect the case where someone is completing</span>
01387     <span class="comment">// to themselves.</span>
01388     <span class="comment">//</span>
01389     CompletionPacket-&gt;LocationsAdvanced = locationsAdvanced;
01390 
01391     <span class="comment">//</span>
01392     <span class="comment">// If this failed, somebody skipped then completed.</span>
01393     <span class="comment">//</span>
01394     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(locationsAdvanced);
01395 
01396     <span class="comment">//</span>
01397     <span class="comment">// If somebody called IoSetNextIrpStackLocation, and then completed,</span>
01398     <span class="comment">// update our internal stack locations (slots) as appropriate.</span>
01399     <span class="comment">//</span>
01400     slotIsInUse = <a class="code" href="../../d9/d4/trackirp_8h.html#a145">IovpAdvanceStackDownwards</a>(
01401          iovSessionData-&gt;<a class="code" href="../../d8/d1/struct__IOV__SESSION__DATA.html#o9">StackData</a>,
01402          <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o13">CurrentLocation</a>,
01403          irpSp,
01404          irpSp + locationsAdvanced,
01405          locationsAdvanced,
01406          <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
01407          <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
01408          &amp;iovCurrentStackLocation
01409          );
01410 
01411     <a class="code" href="../../d9/d8/hashirp_8h.html#a12">IovpTrackingDataReleaseLock</a>(iovPacket);
01412 }
01413 
01414 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01415 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l01416"></a><a class="code" href="../../d9/d4/trackirp_8h.html#a111">01416</a> <a class="code" href="../../d9/d4/trackirp_8h.html#a111">IovpCompleteRequest2</a>(
01417     IN     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>               Irp,
01418     IN OUT <a class="code" href="../../d4/d0/struct__IOFCOMPLETEREQUEST__STACKDATA.html">PIOFCOMPLETEREQUEST_STACKDATA</a> CompletionPacket
01419     )
01420 <span class="comment">/*++</span>
01421 <span class="comment"></span>
01422 <span class="comment">  Description:</span>
01423 <span class="comment"></span>
01424 <span class="comment">    This routine is called for each stack location that might have a completion</span>
01425 <span class="comment">    routine.</span>
01426 <span class="comment"></span>
01427 <span class="comment">  Arguments:</span>
01428 <span class="comment"></span>
01429 <span class="comment">    Irp                    - A pointer to the IRP passed into</span>
01430 <span class="comment">                             IofCompleteRequest.</span>
01431 <span class="comment"></span>
01432 <span class="comment">    CompletionPacket       - A pointer to a local variable on the stack of</span>
01433 <span class="comment">                             IofCompleteRequest. The information stored in</span>
01434 <span class="comment">                             this local variable will be picked up by</span>
01435 <span class="comment">                             IovpCompleteRequest4&amp;5.</span>
01436 <span class="comment"></span>
01437 <span class="comment">  Return Value:</span>
01438 <span class="comment"></span>
01439 <span class="comment">     None.</span>
01440 <span class="comment">--*/</span>
01441 {
01442     <a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html">PIOV_REQUEST_PACKET</a> iovPacket;
01443     <a class="code" href="../../d8/d1/struct__IOV__SESSION__DATA.html">PIOV_SESSION_DATA</a> iovSessionData;
01444     BOOLEAN raiseToDPC, newlyCompleted, requestFinalized ;
01445     KIRQL oldIrql ;
01446     <a class="code" href="../../d9/d1/struct__IOV__STACK__LOCATION.html">PIOV_STACK_LOCATION</a> iovCurrentStackLocation, requestsFirstStackLocation ;
01447     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status, entranceStatus ;
01448     <a class="code" href="../../d3/d0/struct__IOFCALLDRIVER__STACKDATA.html">PIOFCALLDRIVER_STACKDATA</a> IofCallDriverStackData ;
01449     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpSp ;
01450     ULONG refAction ;
01451     PLIST_ENTRY listEntry ;
01452 
01453     iovSessionData = CompletionPacket-&gt;IovSessionData;
01454     <span class="keywordflow">if</span> (iovSessionData == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01455 
01456         <span class="keywordflow">return</span>;
01457     }
01458 
01459     iovPacket = CompletionPacket-&gt;IovRequestPacket;
01460     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(iovPacket);
01461     <a class="code" href="../../d9/d8/hashirp_8h.html#a11">IovpTrackingDataAcquireLock</a>(iovPacket);
01462 
01463     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(iovSessionData == <a class="code" href="../../d9/d8/hashirp_8h.html#a16">IovpTrackingDataGetCurrentSessionData</a>(iovPacket));
01464 
01465     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(!<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o25">CancelRoutine</a>) ;
01466 
01467     status = <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status ;
01468 
01469     <a class="code" href="../../d9/d4/trackirp_8h.html#a88">TRACKIRP_DBGPRINT</a>((
01470         <span class="stringliteral">"  CR2: Current, Last = (%x, %x)\n"</span>,
01471         <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o13">CurrentLocation</a>, iovPacket-&gt;LastLocation
01472         ), 3) ;
01473 
01474     iovCurrentStackLocation = iovSessionData-&gt;<a class="code" href="../../d8/d1/struct__IOV__SESSION__DATA.html#o9">StackData</a> + <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o13">CurrentLocation</a> -1 ;
01475     <a class="code" href="../../d9/d4/trackirp_8h.html#a88">TRACKIRP_DBGPRINT</a>((
01476         <span class="stringliteral">"  Smacking %lx in CR2\n"</span>,
01477         iovCurrentStackLocation-iovSessionData-&gt;<a class="code" href="../../d8/d1/struct__IOV__SESSION__DATA.html#o9">StackData</a>
01478         ), 2) ;
01479 
01480     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o13">CurrentLocation</a> &lt;= iovPacket-&gt;TopStackLocation) {
01481 
01482         <span class="comment">//</span>
01483         <span class="comment">// Might this be false if the completion routine is to an</span>
01484         <span class="comment">// internal stack loc as set up by IoSetNextIrpStackLocation?</span>
01485         <span class="comment">//</span>
01486         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(iovCurrentStackLocation-&gt;<a class="code" href="../../d9/d1/struct__IOV__STACK__LOCATION.html#o0">InUse</a>) ;
01487 
01488         <span class="comment">//</span>
01489         <span class="comment">// Determine if a request was newly completed. Note that</span>
01490         <span class="comment">// several requests may exist within an IRP if it is being</span>
01491         <span class="comment">// "reused". For instance, in response to a IRP_MJ_READ, a</span>
01492         <span class="comment">// driver might convert it into a IRP_MJ_PNP request for the</span>
01493         <span class="comment">// rest of the stack. The two are treated as seperate requests.</span>
01494         <span class="comment">//</span>
01495         requestsFirstStackLocation = iovCurrentStackLocation-&gt;<a class="code" href="../../d9/d1/struct__IOV__STACK__LOCATION.html#o2">RequestsFirstStackLocation</a> ;
01496         <a class="code" href="../../d9/d4/trackirp_8h.html#a88">TRACKIRP_DBGPRINT</a>((
01497             <span class="stringliteral">"  CR2: original request for %lx is %lx\n"</span>,
01498             iovCurrentStackLocation-iovSessionData-&gt;<a class="code" href="../../d8/d1/struct__IOV__SESSION__DATA.html#o9">StackData</a>,
01499             requestsFirstStackLocation-iovSessionData-&gt;<a class="code" href="../../d8/d1/struct__IOV__SESSION__DATA.html#o9">StackData</a>
01500             ), 3) ;
01501 
01502         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(requestsFirstStackLocation) ;
01503         <span class="keywordflow">if</span> (requestsFirstStackLocation-&gt;<a class="code" href="../../d9/d1/struct__IOV__STACK__LOCATION.html#o1">Flags</a>&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a47">STACKFLAG_REQUEST_COMPLETED</a>) {
01504             newlyCompleted = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> ;
01505         } <span class="keywordflow">else</span> {
01506             requestsFirstStackLocation-&gt;<a class="code" href="../../d9/d1/struct__IOV__STACK__LOCATION.html#o1">Flags</a>|=<a class="code" href="../../d9/d4/trackirp_8h.html#a47">STACKFLAG_REQUEST_COMPLETED</a> ;
01507             newlyCompleted = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> ;
01508             <a class="code" href="../../d9/d4/trackirp_8h.html#a88">TRACKIRP_DBGPRINT</a>((
01509                 <span class="stringliteral">"  CR2: Request %lx newly completed by %lx\n"</span>,
01510                 requestsFirstStackLocation-iovSessionData-&gt;<a class="code" href="../../d8/d1/struct__IOV__SESSION__DATA.html#o9">StackData</a>,
01511                 iovCurrentStackLocation-iovSessionData-&gt;<a class="code" href="../../d8/d1/struct__IOV__SESSION__DATA.html#o9">StackData</a>
01512                 ), 3) ;
01513         }
01514         requestFinalized = (iovCurrentStackLocation == requestsFirstStackLocation) ;
01515         <span class="keywordflow">if</span> (requestFinalized) {
01516 
01517             <a class="code" href="../../d9/d4/trackirp_8h.html#a88">TRACKIRP_DBGPRINT</a>((
01518                 <span class="stringliteral">"  CR2: Request %lx finalized\n"</span>,
01519                 iovCurrentStackLocation-iovSessionData-&gt;<a class="code" href="../../d8/d1/struct__IOV__SESSION__DATA.html#o9">StackData</a>
01520                 ), 3) ;
01521         }
01522 
01523         <span class="comment">//</span>
01524         <span class="comment">// OK -</span>
01525         <span class="comment">//       If we haven't unwound yet, then IofCallDriverStackData will</span>
01526         <span class="comment">// start out non-NULL, in which case we will scribble away the final</span>
01527         <span class="comment">// completion routine status to everybody asking (could be multiple</span>
01528         <span class="comment">// if they IoSkip'd).</span>
01529         <span class="comment">//       On the other hand, everybody might have unwound, in which</span>
01530         <span class="comment">// case IofCallDriver(...) will start out NULL, and we will already have</span>
01531         <span class="comment">// asserted if STATUS_PENDING wasn't returned much much earlier...</span>
01532         <span class="comment">//       Finally, this slot may not have been "prepared" if an</span>
01533         <span class="comment">// internal stack location called IoSetNextIrpStackLocation, thus</span>
01534         <span class="comment">// consuming a stack location. In this case, IofCallDriverStackData</span>
01535         <span class="comment">// will come from a zero'd slot, and we will do nothing, which is</span>
01536         <span class="comment">// also fine.</span>
01537         <span class="comment">//</span>
01538         irpSp = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>) ;
01539 
01540         <span class="keywordflow">if</span> ((iovPacket-&gt;AssertFlags&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a2">ASSERTFLAG_POLICEIRPS</a>) &amp;&amp;
01541             (iovPacket-&gt;AssertFlags&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a3">ASSERTFLAG_MONITORMAJORS</a>)) {
01542 
01543             <a class="code" href="../../d8/d4/flunkirp_8h.html#a5">IovpAssertIrpStackUpward</a>(
01544                 iovPacket,
01545                 irpSp,
01546                 iovCurrentStackLocation,
01547                 newlyCompleted,
01548                 requestFinalized
01549                 );
01550         }
01551 
01552         entranceStatus = status ;
01553 
01554         <span class="keywordflow">while</span>(!IsListEmpty(&amp;iovCurrentStackLocation-&gt;CallStackData)) {
01555 
01556             <span class="comment">//</span>
01557             <span class="comment">// Pop off the list head.</span>
01558             <span class="comment">//</span>
01559             listEntry = RemoveHeadList(&amp;iovCurrentStackLocation-&gt;CallStackData) ;
01560             IofCallDriverStackData = CONTAINING_RECORD(
01561                 listEntry,
01562                 <a class="code" href="../../d3/d0/struct__IOFCALLDRIVER__STACKDATA.html">IOFCALLDRIVER_STACKDATA</a>,
01563                 SharedLocationList) ;
01564 
01565             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(!(IofCallDriverStackData-&gt;<a class="code" href="../../d3/d0/struct__IOFCALLDRIVER__STACKDATA.html#o2">Flags</a>&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a51">CALLFLAG_COMPLETED</a>)) ;
01566 
01567             IofCallDriverStackData-&gt;<a class="code" href="../../d3/d0/struct__IOFCALLDRIVER__STACKDATA.html#o2">Flags</a> |= <a class="code" href="../../d9/d4/trackirp_8h.html#a51">CALLFLAG_COMPLETED</a> ;
01568             IofCallDriverStackData-&gt;<a class="code" href="../../d3/d0/struct__IOFCALLDRIVER__STACKDATA.html#o4">ExpectedStatus</a> = status ;
01569 
01570             <span class="keywordflow">if</span> ((iovSessionData-&gt;<a class="code" href="../../d8/d1/struct__IOV__SESSION__DATA.html#o4">AssertFlags</a>&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a11">ASSERTFLAG_ROTATE_STATUS</a>)&amp;&amp;
01571                  <a class="code" href="../../d8/d4/flunkirp_8h.html#a3">IovpAssertDoAdvanceStatus</a>(irpSp, entranceStatus, &amp;status)) {
01572 
01573                 <span class="comment">//</span>
01574                 <span class="comment">// Purposely munge the returned status for everyone at this</span>
01575                 <span class="comment">// layer to flush more bugs. We are specifically trolling for</span>
01576                 <span class="comment">// this buggy sequence:</span>
01577                 <span class="comment">//    Irp-&gt;IoStatus.Status = STATUS_SUCCESS ;</span>
01578                 <span class="comment">//    IoSkipCurrentIrpStackLocation(Irp);</span>
01579                 <span class="comment">//    IoCallDriver(DeviceBelow, Irp) ;</span>
01580                 <span class="comment">//    return STATUS_SUCCESS ;</span>
01581                 <span class="comment">//</span>
01582                 IofCallDriverStackData-&gt;<a class="code" href="../../d3/d0/struct__IOFCALLDRIVER__STACKDATA.html#o2">Flags</a> |= <a class="code" href="../../d9/d4/trackirp_8h.html#a54">CALLFLAG_OVERRIDE_STATUS</a> ;
01583                 IofCallDriverStackData-&gt;<a class="code" href="../../d3/d0/struct__IOFCALLDRIVER__STACKDATA.html#o5">NewStatus</a> = status ;
01584             }
01585         }
01586         <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status = status ;
01587 
01588         <span class="comment">//</span>
01589         <span class="comment">// Set InUse = FALSE  and  CallStackData = NULL</span>
01590         <span class="comment">//</span>
01591         RtlZeroMemory(iovCurrentStackLocation, <span class="keyword">sizeof</span>(<a class="code" href="../../d9/d1/struct__IOV__STACK__LOCATION.html">IOV_STACK_LOCATION</a>)) ;
01592         InitializeListHead(&amp;iovCurrentStackLocation-&gt;CallStackData) ;
01593     } <span class="keywordflow">else</span> {
01594 
01595         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(0) ;
01596     }
01597 
01598     <span class="comment">//</span>
01599     <span class="comment">// Once we return, we may be completed again before IofCompleteRequest3</span>
01600     <span class="comment">// get's called, so we make sure we are at DPC level throughout.</span>
01601     <span class="comment">//</span>
01602     raiseToDPC = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> ;
01603 
01604     <span class="keywordflow">if</span> (iovSessionData-&gt;<a class="code" href="../../d8/d1/struct__IOV__SESSION__DATA.html#o4">AssertFlags</a>&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a8">ASSERTFLAG_COMPLETEATDPC</a>) {
01605 
01606         <span class="keywordflow">if</span> (!CompletionPacket-&gt;RaisedCount) {
01607 
01608             <span class="comment">//</span>
01609             <span class="comment">// Copy away the callers IRQL</span>
01610             <span class="comment">//</span>
01611             CompletionPacket-&gt;PreviousIrql = iovPacket-&gt;CallerIrql;
01612             raiseToDPC = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> ;
01613         }
01614         CompletionPacket-&gt;RaisedCount++ ;
01615     }
01616 
01617     iovPacket-&gt;LastLocation = <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o13">CurrentLocation</a>+1 ;
01618 
01619     <span class="keywordflow">if</span> (iovPacket-&gt;TopStackLocation == <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o13">CurrentLocation</a>) {
01620 
01621         CompletionPacket-&gt;IovSessionData = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01622 
01623         <span class="keywordflow">if</span> (iovPacket-&gt;Flags&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a26">TRACKFLAG_SURROGATE</a>) {
01624 
01625             <span class="comment">//</span>
01626             <span class="comment">// Scribble away the real completion routine and corrosponding control</span>
01627             <span class="comment">//</span>
01628             irpSp = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>) ;
01629             iovPacket-&gt;RealIrpCompletionRoutine = irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o116">CompletionRoutine</a> ;
01630             iovPacket-&gt;RealIrpControl = irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o3">Control</a> ;
01631             iovPacket-&gt;RealIrpContext = irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o117">Context</a> ;
01632 
01633             <span class="comment">//</span>
01634             <span class="comment">// We want to peek at the Irp prior to completion. This is why we</span>
01635             <span class="comment">// have expanded the initial number of stack locations with the</span>
01636             <span class="comment">// driver verifier enabled.</span>
01637             <span class="comment">//</span>
01638             <a class="code" href="../../d0/d5/io_8h.html#a237">IoSetCompletionRoutine</a>(
01639                 <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>,
01640                 <a class="code" href="../../d8/d4/trackirp_8c.html#a29">IovpSwapSurrogateIrp</a>,
01641                 <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>,
01642                 <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
01643                 <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
01644                 <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>
01645                 ) ;
01646 
01647         } <span class="keywordflow">else</span> {
01648 
01649             <span class="comment">//</span>
01650             <span class="comment">// Close this session as the IRP has entirely completed. We drop</span>
01651             <span class="comment">// the pointer count we added to the tracking data here for the</span>
01652             <span class="comment">// same reason.</span>
01653             <span class="comment">//</span>
01654             irpSp = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>) ;
01655             <span class="keywordflow">if</span> (iovPacket-&gt;AssertFlags&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a2">ASSERTFLAG_POLICEIRPS</a>) {
01656 
01657                 <a class="code" href="../../d8/d4/flunkirp_8h.html#a6">IovpAssertFinalIrpStack</a>(iovPacket, irpSp) ;
01658             }
01659 
01660             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(iovPacket-&gt;TopStackLocation == <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o13">CurrentLocation</a>);
01661             <a class="code" href="../../d6/d7/sessnirp_8h.html#a4">IovpSessionDataClose</a>(iovSessionData);
01662             <a class="code" href="../../d6/d7/sessnirp_8h.html#a3">IovpSessionDataDereference</a>(iovSessionData);
01663             <a class="code" href="../../d9/d8/hashirp_8h.html#a14">IovpTrackingDataDereference</a>(iovPacket, <a class="code" href="../../d9/d8/hashirp_8h.html#a21a5">IOVREFTYPE_POINTER</a>);
01664         }
01665 
01666     } <span class="keywordflow">else</span> {
01667 
01668         <span class="comment">//</span>
01669         <span class="comment">// We will be seeing this IRP again. Hold a session count against it.</span>
01670         <span class="comment">//</span>
01671         <a class="code" href="../../d6/d7/sessnirp_8h.html#a2">IovpSessionDataReference</a>(iovSessionData);
01672     }
01673 
01674     <span class="comment">//</span>
01675     <span class="comment">// Assert LastLocation is consistent with an IRP that may be completed.</span>
01676     <span class="comment">//</span>
01677     <span class="keywordflow">if</span> (iovPacket-&gt;LastLocation &lt; iovPacket-&gt;TopStackLocation) {
01678 
01679         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(iovSessionData-&gt;<a class="code" href="../../d8/d1/struct__IOV__SESSION__DATA.html#o9">StackData</a>[iovPacket-&gt;LastLocation-1].<a class="code" href="../../d9/d1/struct__IOV__STACK__LOCATION.html#o0">InUse</a>) ;
01680     }
01681 
01682     <a class="code" href="../../d9/d8/hashirp_8h.html#a12">IovpTrackingDataReleaseLock</a>(iovPacket);
01683 
01684     <span class="keywordflow">if</span> (raiseToDPC) {
01685         <a class="code" href="../../d9/d5/verifier_8c.html#a116">KeRaiseIrql</a>(<a class="code" href="../../d6/d7/halmips_8h.html#a53">DISPATCH_LEVEL</a>, &amp;oldIrql);
01686     }
01687 
01688     CompletionPacket-&gt;LocationsAdvanced --;
01689 }
01690 
01691 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01692 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l01693"></a><a class="code" href="../../d9/d4/trackirp_8h.html#a112">01693</a> <a class="code" href="../../d9/d4/trackirp_8h.html#a112">IovpCompleteRequest3</a>(
01694     IN     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>               Irp,
01695     IN     PVOID              Routine,
01696     IN OUT <a class="code" href="../../d4/d0/struct__IOFCOMPLETEREQUEST__STACKDATA.html">PIOFCOMPLETEREQUEST_STACKDATA</a> CompletionPacket
01697     )
01698 <span class="comment">/*++</span>
01699 <span class="comment"></span>
01700 <span class="comment">  Description:</span>
01701 <span class="comment"></span>
01702 <span class="comment">    This routine is called just before each completion routine is invoked.</span>
01703 <span class="comment"></span>
01704 <span class="comment">  Arguments:</span>
01705 <span class="comment"></span>
01706 <span class="comment">    Irp                    - A pointer to the IRP passed into</span>
01707 <span class="comment">                             IofCompleteRequest.</span>
01708 <span class="comment"></span>
01709 <span class="comment">    Routine                - The completion routine about to be called.</span>
01710 <span class="comment"></span>
01711 <span class="comment">    CompletionPacket       - A pointer to data on the callers stack. This will</span>
01712 <span class="comment">                             be picked up IovpCompleteRequest4 and</span>
01713 <span class="comment">                             IovpCompleteRequest5.</span>
01714 <span class="comment"></span>
01715 <span class="comment">  Return Value:</span>
01716 <span class="comment"></span>
01717 <span class="comment">     None.</span>
01718 <span class="comment">--*/</span>
01719 {
01720     <a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html">PIOV_REQUEST_PACKET</a> iovPacket;
01721     <a class="code" href="../../d8/d1/struct__IOV__SESSION__DATA.html">PIOV_SESSION_DATA</a> iovSessionData;
01722     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpSpCur, irpSpNext ;
01723     <a class="code" href="../../d3/d2/struct__DEFERRAL__CONTEXT.html">PDEFERRAL_CONTEXT</a> deferralContext ;
01724 
01725     iovSessionData = CompletionPacket-&gt;IovSessionData;
01726     <span class="keywordflow">if</span> (iovSessionData == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01727 
01728         <span class="keywordflow">return</span>;
01729     }
01730 
01731     iovPacket = iovSessionData-&gt;<a class="code" href="../../d8/d1/struct__IOV__SESSION__DATA.html#o0">IovRequestPacket</a>;
01732     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(iovPacket);
01733     <a class="code" href="../../d9/d8/hashirp_8h.html#a11">IovpTrackingDataAcquireLock</a>(iovPacket);
01734 
01735     <span class="comment">//</span>
01736     <span class="comment">// Verify all completion routines are in nonpaged code, exempting one</span>
01737     <span class="comment">// special case - when a driver completes the IRP to itself by calling</span>
01738     <span class="comment">// IoSetNextStackLocation before calling IoCompleteRequest.</span>
01739     <span class="comment">//</span>
01740     <span class="keywordflow">if</span> (iovSessionData-&gt;<a class="code" href="../../d8/d1/struct__IOV__SESSION__DATA.html#o4">AssertFlags</a>&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a2">ASSERTFLAG_POLICEIRPS</a>) {
01741 
01742         <span class="keywordflow">if</span> ((CompletionPacket-&gt;LocationsAdvanced &lt;= 0) &amp;&amp;
01743             (<a class="code" href="../../d2/d1/mm_8h.html#a207">MmIsSystemAddressLocked</a>(Routine) == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>)) {
01744 
01745             <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(
01746                 <span class="stringliteral">"Verifier Notes: LocationsAdvanced %d\n"</span>,
01747                 CompletionPacket-&gt;LocationsAdvanced
01748                 );
01749 
01750             <a class="code" href="../../d2/d5/ioassert_8h.html#a21">WDM_FAIL_ROUTINE</a>((
01751                 <a class="code" href="../../d2/d5/ioassert_8h.html#a114a78">DCERROR_COMPLETION_ROUTINE_PAGABLE</a>,
01752                 <a class="code" href="../../d2/d5/ioassert_8h.html#a7">DCPARAM_IRP</a> + <a class="code" href="../../d2/d5/ioassert_8h.html#a8">DCPARAM_ROUTINE</a>,
01753                 <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>,
01754                 Routine
01755                 ));
01756         }
01757     }
01758 
01759     <span class="comment">//</span>
01760     <span class="comment">// Setup fields for those assertion functions that will be called *after*</span>
01761     <span class="comment">// the completion routine has been called.</span>
01762     <span class="comment">//</span>
01763     irpSpCur = <a class="code" href="../../d0/d5/io_8h.html#a228">IoGetCurrentIrpStackLocation</a>(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>) ;
01764     CompletionPacket-&gt;IsRemoveIrp =
01765        ((<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o13">CurrentLocation</a> &lt;= (CCHAR) <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o12">StackCount</a>) &amp;&amp;
01766         (irpSpCur-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a> == <a class="code" href="../../d0/d5/io_8h.html#a40">IRP_MJ_PNP</a>) &amp;&amp;
01767         (irpSpCur-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o1">MinorFunction</a> == <a class="code" href="../../d0/d5/io_8h.html#a67">IRP_MN_REMOVE_DEVICE</a>)) ;
01768 
01769     CompletionPacket-&gt;CompletionRoutine = Routine ;
01770 
01771     <span class="comment">//</span>
01772     <span class="comment">// Is this a completion routine that should be called later? Note that this</span>
01773     <span class="comment">// is only legal if we are pending the IRPs (because to the upper driver,</span>
01774     <span class="comment">// IofCallDriver is returning before it's completion routine has been called)</span>
01775     <span class="comment">//</span>
01776     <span class="keywordflow">if</span> ((!CompletionPacket-&gt;IsRemoveIrp)&amp;&amp;
01777        ((iovSessionData-&gt;<a class="code" href="../../d8/d1/struct__IOV__SESSION__DATA.html#o4">AssertFlags</a>&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a10">ASSERTFLAG_DEFERCOMPLETION</a>)||
01778         (iovSessionData-&gt;<a class="code" href="../../d8/d1/struct__IOV__SESSION__DATA.html#o4">AssertFlags</a>&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a9">ASSERTFLAG_COMPLETEATPASSIVE</a>))) {
01779 
01780         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(iovSessionData-&gt;<a class="code" href="../../d8/d1/struct__IOV__SESSION__DATA.html#o4">AssertFlags</a>&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a7">ASSERTFLAG_FORCEPENDING</a>) ;
01781 
01782         irpSpNext = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>) ;
01783 
01784         deferralContext = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>(
01785            <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>,
01786            <span class="keyword">sizeof</span>(<a class="code" href="../../d3/d2/struct__DEFERRAL__CONTEXT.html">DEFERRAL_CONTEXT</a>),
01787            <a class="code" href="../../d8/d4/trackirp_8c.html#a0">POOL_TAG_DEFERRED_CONTEXT</a>
01788            ) ;
01789 
01790         <span class="keywordflow">if</span> (deferralContext) {
01791 
01792             <span class="comment">//</span>
01793             <span class="comment">// Swap the original completion and context for our own.</span>
01794             <span class="comment">//</span>
01795             deferralContext-&gt;<a class="code" href="../../d3/d2/struct__DEFERRAL__CONTEXT.html#o0">IovRequestPacket</a>          = iovPacket;
01796             deferralContext-&gt;<a class="code" href="../../d3/d2/struct__DEFERRAL__CONTEXT.html#o6">IrpSpNext</a>                 = irpSpNext;
01797             deferralContext-&gt;<a class="code" href="../../d3/d2/struct__DEFERRAL__CONTEXT.html#o1">OriginalCompletionRoutine</a> = irpSpNext-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o116">CompletionRoutine</a>;
01798             deferralContext-&gt;<a class="code" href="../../d3/d2/struct__DEFERRAL__CONTEXT.html#o2">OriginalContext</a>           = irpSpNext-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o117">Context</a>;
01799             deferralContext-&gt;<a class="code" href="../../d3/d2/struct__DEFERRAL__CONTEXT.html#o3">OriginalIrp</a>               = <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>;
01800             deferralContext-&gt;<a class="code" href="../../d3/d2/struct__DEFERRAL__CONTEXT.html#o4">OriginalPriorityBoost</a>     = iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o17">PriorityBoost</a>;
01801 
01802             irpSpNext-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o116">CompletionRoutine</a> = <a class="code" href="../../d8/d4/trackirp_8c.html#a28">IovpInternalDeferredCompletion</a>;
01803             irpSpNext-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o117">Context</a>           = deferralContext;
01804             <a class="code" href="../../d9/d8/hashirp_8h.html#a13">IovpTrackingDataReference</a>(iovPacket, <a class="code" href="../../d9/d8/hashirp_8h.html#a21a5">IOVREFTYPE_POINTER</a>);
01805         }
01806     }
01807 
01808     <a class="code" href="../../d9/d8/hashirp_8h.html#a12">IovpTrackingDataReleaseLock</a>(iovPacket) ;
01809 }
01810 
01811 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01812 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l01813"></a><a class="code" href="../../d9/d4/trackirp_8h.html#a113">01813</a> <a class="code" href="../../d9/d4/trackirp_8h.html#a113">IovpCompleteRequest4</a>(
01814     IN     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>               Irp,
01815     IN     NTSTATUS           ReturnedStatus,
01816     IN OUT <a class="code" href="../../d4/d0/struct__IOFCOMPLETEREQUEST__STACKDATA.html">PIOFCOMPLETEREQUEST_STACKDATA</a> CompletionPacket
01817     )
01818 <span class="comment">/*++</span>
01819 <span class="comment"></span>
01820 <span class="comment">  Description:</span>
01821 <span class="comment"></span>
01822 <span class="comment">    This assert routine is called just after each completion routine is</span>
01823 <span class="comment">    invoked (but not if STATUS_MORE_PROCESSING is returned)</span>
01824 <span class="comment"></span>
01825 <span class="comment">  Arguments:</span>
01826 <span class="comment"></span>
01827 <span class="comment">    Irp                    - A pointer to the IRP passed into</span>
01828 <span class="comment">                             IofCompleteRequest.</span>
01829 <span class="comment"></span>
01830 <span class="comment">    Routine                - The completion routine called.</span>
01831 <span class="comment"></span>
01832 <span class="comment">    ReturnedStatus         - The status value returned.</span>
01833 <span class="comment"></span>
01834 <span class="comment">    CompletionPacket       - A pointer to data on the callers stack. This was</span>
01835 <span class="comment">                             filled in by IovpCompleteRequest3.</span>
01836 <span class="comment"></span>
01837 <span class="comment">  Return Value:</span>
01838 <span class="comment"></span>
01839 <span class="comment">     None.</span>
01840 <span class="comment">--*/</span>
01841 {
01842     <a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html">PIOV_REQUEST_PACKET</a> iovPacket;
01843     <a class="code" href="../../d8/d1/struct__IOV__SESSION__DATA.html">PIOV_SESSION_DATA</a> iovSessionData;
01844     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpSp;
01845     PVOID routine;
01846 
01847     routine = CompletionPacket-&gt;CompletionRoutine;
01848     iovSessionData = CompletionPacket-&gt;IovSessionData;
01849 
01850     <span class="keywordflow">if</span> (iovSessionData == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01851 
01852         <span class="keywordflow">return</span>;
01853     }
01854 
01855     iovPacket = iovSessionData-&gt;<a class="code" href="../../d8/d1/struct__IOV__SESSION__DATA.html#o0">IovRequestPacket</a>;
01856     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(iovPacket);
01857     <a class="code" href="../../d9/d8/hashirp_8h.html#a11">IovpTrackingDataAcquireLock</a>(iovPacket);
01858 
01859     <span class="comment">//</span>
01860     <span class="comment">// ADRIAO BUGBUG 01/06/1999 -</span>
01861     <span class="comment">//     Check for leaked Cancel routines here.</span>
01862     <span class="comment">//</span>
01863     <span class="keywordflow">if</span> (iovSessionData-&gt;<a class="code" href="../../d8/d1/struct__IOV__SESSION__DATA.html#o4">AssertFlags</a>&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a7">ASSERTFLAG_FORCEPENDING</a>) {
01864 
01865         <span class="comment">//</span>
01866         <span class="comment">// ADRIAO BUGBUG #05 05/12/98 - Find a way to do this in the non-pend</span>
01867         <span class="comment">//                              everything path...</span>
01868         <span class="comment">//</span>
01869         <span class="keywordflow">if</span> ((ReturnedStatus != STATUS_MORE_PROCESSING_REQUIRED)&amp;&amp;
01870             (iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o21">pIovSessionData</a> == iovSessionData)) {
01871 
01872             <span class="comment">//</span>
01873             <span class="comment">// At this point, we know the completion routine is required to have</span>
01874             <span class="comment">// set the IRP pending bit, because we've hardwired everyone below</span>
01875             <span class="comment">// him to return pending, and we've marked the pending returned bit.</span>
01876             <span class="comment">// Verify he did his part</span>
01877             <span class="comment">//</span>
01878             irpSp = <a class="code" href="../../d0/d5/io_8h.html#a228">IoGetCurrentIrpStackLocation</a>(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>) ;
01879             <span class="keywordflow">if</span> (!(irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o3">Control</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a194">SL_PENDING_RETURNED</a> )) {
01880 
01881                  <a class="code" href="../../d2/d5/ioassert_8h.html#a21">WDM_FAIL_ROUTINE</a>((
01882                      <a class="code" href="../../d2/d5/ioassert_8h.html#a114a79">DCERROR_PENDING_BIT_NOT_MIGRATED</a>,
01883                      <a class="code" href="../../d2/d5/ioassert_8h.html#a7">DCPARAM_IRP</a> + <a class="code" href="../../d2/d5/ioassert_8h.html#a8">DCPARAM_ROUTINE</a>,
01884                      <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>,
01885                      routine
01886                      ));
01887 
01888                  <span class="comment">//</span>
01889                  <span class="comment">// This will keep the IRP above from erroneously asserting (and</span>
01890                  <span class="comment">// correctly hanging).</span>
01891                  <span class="comment">//</span>
01892                  <a class="code" href="../../d0/d5/io_8h.html#a234">IoMarkIrpPending</a>(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>);
01893             }
01894         }
01895     }
01896     <a class="code" href="../../d9/d8/hashirp_8h.html#a12">IovpTrackingDataReleaseLock</a>(iovPacket);
01897 }
01898 
01899 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01900 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l01901"></a><a class="code" href="../../d9/d4/trackirp_8h.html#a114">01901</a> <a class="code" href="../../d9/d4/trackirp_8h.html#a114">IovpCompleteRequest5</a>(
01902     IN     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>                          Irp,
01903     IN OUT <a class="code" href="../../d4/d0/struct__IOFCOMPLETEREQUEST__STACKDATA.html">PIOFCOMPLETEREQUEST_STACKDATA</a> CompletionPacket
01904     )
01905 <span class="comment">/*++</span>
01906 <span class="comment"></span>
01907 <span class="comment">  Description:</span>
01908 <span class="comment"></span>
01909 <span class="comment">    This routine is called for each stack location that could have had a</span>
01910 <span class="comment">    completion routine, after any possible completion routine has been</span>
01911 <span class="comment">    called.</span>
01912 <span class="comment"></span>
01913 <span class="comment">  Arguments:</span>
01914 <span class="comment"></span>
01915 <span class="comment">    Irp                    - A pointer to the IRP passed into</span>
01916 <span class="comment">                             IofCompleteRequest.</span>
01917 <span class="comment"></span>
01918 <span class="comment">    CompletionPacket       - A pointer to a local variable on the stack of</span>
01919 <span class="comment">                             IofCompleteRequest. This information was stored</span>
01920 <span class="comment">                             by IovpCompleteRequest2 and 3.</span>
01921 <span class="comment"></span>
01922 <span class="comment">  Return Value:</span>
01923 <span class="comment"></span>
01924 <span class="comment">     None.</span>
01925 <span class="comment">--*/</span>
01926 {
01927     <a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html">PIOV_REQUEST_PACKET</a> iovPacket;
01928     <a class="code" href="../../d8/d1/struct__IOV__SESSION__DATA.html">PIOV_SESSION_DATA</a> iovSessionData;
01929     <a class="code" href="../../d9/d1/struct__IOV__STACK__LOCATION.html">PIOV_STACK_LOCATION</a> iovCurrentStackLocation ;
01930     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status ;
01931 
01932     iovSessionData = CompletionPacket-&gt;IovSessionData;
01933 
01934     <span class="keywordflow">if</span> (iovSessionData) {
01935 
01936         iovPacket = iovSessionData-&gt;<a class="code" href="../../d8/d1/struct__IOV__SESSION__DATA.html#o0">IovRequestPacket</a>;
01937         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(iovPacket);
01938         <a class="code" href="../../d9/d8/hashirp_8h.html#a11">IovpTrackingDataAcquireLock</a>(iovPacket);
01939 
01940         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>((!CompletionPacket-&gt;RaisedCount) ||
01941                (iovSessionData-&gt;<a class="code" href="../../d8/d1/struct__IOV__SESSION__DATA.html#o4">AssertFlags</a>&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a8">ASSERTFLAG_COMPLETEATDPC</a>)) ;
01942 
01943         <a class="code" href="../../d6/d7/sessnirp_8h.html#a3">IovpSessionDataDereference</a>(iovSessionData);
01944         <a class="code" href="../../d9/d8/hashirp_8h.html#a12">IovpTrackingDataReleaseLock</a>(iovPacket);
01945     }
01946 
01947     <span class="comment">//</span>
01948     <span class="comment">// When this count is at zero, we have unnested out of every</span>
01949     <span class="comment">// completion routine, so it is OK to return back to our original IRQL</span>
01950     <span class="comment">//</span>
01951     <span class="keywordflow">if</span> (CompletionPacket-&gt;RaisedCount) {
01952 
01953         <span class="keywordflow">if</span> (!(--CompletionPacket-&gt;RaisedCount)) {
01954             <span class="comment">//</span>
01955             <span class="comment">// Undo IRQL madness (wouldn't want to return to</span>
01956             <span class="comment">// the caller at DPC, would we now?)</span>
01957             <span class="comment">//</span>
01958             <a class="code" href="../../d9/d5/verifier_8c.html#a117">KeLowerIrql</a>(CompletionPacket-&gt;PreviousIrql);
01959         }
01960     }
01961 }
01962 
01963 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01964 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l01965"></a><a class="code" href="../../d9/d4/trackirp_8h.html#a115">01965</a> <a class="code" href="../../d9/d4/trackirp_8h.html#a115">IovpCompleteRequestApc</a>(
01966     IN     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>                          Irp,
01967     IN     PVOID                         BestStackOffset
01968     )
01969 <span class="comment">/*++</span>
01970 <span class="comment"></span>
01971 <span class="comment">  Description:</span>
01972 <span class="comment"></span>
01973 <span class="comment">    This routine is after the APC for completing IRPs and fired.</span>
01974 <span class="comment"></span>
01975 <span class="comment">  Arguments:</span>
01976 <span class="comment"></span>
01977 <span class="comment">    Irp                    - A pointer to the IRP passed into retrieved from</span>
01978 <span class="comment">                             the APC in IopCompleteRequest.</span>
01979 <span class="comment"></span>
01980 <span class="comment">    BestStackOffset        - A pointer to a last parameter passed on the stack.</span>
01981 <span class="comment">                             We use this to detect the case where a driver has</span>
01982 <span class="comment">                             ignored STATUS_PENDING and left the UserIosb on</span>
01983 <span class="comment">                             it's stack.</span>
01984 <span class="comment"></span>
01985 <span class="comment">  Return Value:</span>
01986 <span class="comment"></span>
01987 <span class="comment">     None.</span>
01988 <span class="comment">--*/</span>
01989 {
01990 <span class="preprocessor">#if DBG</span>
01991 <span class="preprocessor"></span><span class="preprocessor">#if defined(_X86_)</span>
01992 <span class="preprocessor"></span>    PUCHAR addr;
01993     <a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html">PIOV_REQUEST_PACKET</a> iovPacket;
01994 
01995     addr = (PUCHAR)<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o18">UserIosb</a>;
01996     <span class="keywordflow">if</span> ((addr &gt; (PUCHAR)<a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a3">KeGetCurrentThread</a>()-&gt;StackLimit) &amp;&amp;
01997         (addr &lt;= (PUCHAR)BestStackOffset)) {
01998 
01999         iovPacket = <a class="code" href="../../d9/d8/hashirp_8h.html#a7">IovpTrackingDataFindAndLock</a>(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>) ;
02000 
02001         <a class="code" href="../../d6/d9/assert_8c.html#a1">RtlAssert</a>(<span class="stringliteral">"UserIosb below stack pointer"</span>, __FILE__, (ULONG) iovPacket,
02002                   <span class="stringliteral">"Call AdriaO"</span>);
02003 
02004         <a class="code" href="../../d9/d8/hashirp_8h.html#a12">IovpTrackingDataReleaseLock</a>(iovPacket) ;
02005     }
02006 
02007     addr = (PUCHAR)<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o19">UserEvent</a>;
02008     <span class="keywordflow">if</span> ((addr &gt; (PUCHAR)<a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a3">KeGetCurrentThread</a>()-&gt;StackLimit) &amp;&amp;
02009         (addr &lt;= (PUCHAR)BestStackOffset)) {
02010 
02011         iovPacket = <a class="code" href="../../d9/d8/hashirp_8h.html#a7">IovpTrackingDataFindAndLock</a>(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>) ;
02012 
02013         <a class="code" href="../../d6/d9/assert_8c.html#a1">RtlAssert</a>(<span class="stringliteral">"UserEvent below stack pointer"</span>, __FILE__, (ULONG) iovPacket,
02014                   <span class="stringliteral">"Call AdriaO"</span>);
02015 
02016         <a class="code" href="../../d9/d8/hashirp_8h.html#a12">IovpTrackingDataReleaseLock</a>(iovPacket) ;
02017     }
02018 <span class="preprocessor">#endif</span>
02019 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
02020 <span class="preprocessor"></span>}
02021 
02022 BOOLEAN
<a name="l02023"></a><a class="code" href="../../d9/d4/trackirp_8h.html#a145">02023</a> <a class="code" href="../../d9/d4/trackirp_8h.html#a145">IovpAdvanceStackDownwards</a>(
02024     IN  <a class="code" href="../../d9/d1/struct__IOV__STACK__LOCATION.html">PIOV_STACK_LOCATION</a>   StackDataArray,
02025     IN  CCHAR                 CurrentLocation,
02026     IN  <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a>    IrpSp,
02027     IN  <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a>    IrpLastSp OPTIONAL,
02028     IN  ULONG                 LocationsAdvanced,
02029     IN  BOOLEAN               IsNewRequest,
02030     IN  BOOLEAN               MarkAsTaken,
02031     OUT <a class="code" href="../../d9/d1/struct__IOV__STACK__LOCATION.html">PIOV_STACK_LOCATION</a>   *StackLocationInfo
02032     )
02033 {
02034     <a class="code" href="../../d9/d1/struct__IOV__STACK__LOCATION.html">PIOV_STACK_LOCATION</a>  iovCurrentStackLocation, advancedLocationData, requestOriginalSLD;
02035     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a>   irpSpTemp;
02036     PLARGE_INTEGER       dispatchTime, stackTime;
02037     BOOLEAN              isNewSession, wasInUse;
02038     PVOID                dispatchRoutine;
02039 
02040     isNewSession = (IrpLastSp == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
02041     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>((!isNewSession) || (LocationsAdvanced == 1));
02042     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(isNewSession || ((ULONG) (IrpLastSp - IrpSp) == LocationsAdvanced));
02043 
02044     <span class="comment">//</span>
02045     <span class="comment">// The CurrentLocation will be decremented when we leave. If it hit's zero</span>
02046     <span class="comment">// we will bugcheck, therefore it should be at least two, and we'd need to</span>
02047     <span class="comment">// subtract two off it to make it an index into an array of slot locations</span>
02048     <span class="comment">// (our analog for stack locations). However we reserve an extra empty slot</span>
02049     <span class="comment">// at the head of the array to make our logic easier. Therefore we subtract</span>
02050     <span class="comment">// only one.</span>
02051     <span class="comment">//</span>
02052     iovCurrentStackLocation = StackDataArray + CurrentLocation -1;
02053 
02054     <a class="code" href="../../d9/d4/trackirp_8h.html#a88">TRACKIRP_DBGPRINT</a>((
02055         <span class="stringliteral">"  Smacking %lx (%lx) to valid in SD\n"</span>,
02056         CurrentLocation -1, iovCurrentStackLocation
02057         ), 2);
02058 
02059     <span class="comment">//</span>
02060     <span class="comment">// Note that we do set the InUse field. That's for the caller to do.</span>
02061     <span class="comment">//</span>
02062     <span class="keywordflow">if</span> (iovCurrentStackLocation-&gt;<a class="code" href="../../d9/d1/struct__IOV__STACK__LOCATION.html#o0">InUse</a>) {
02063 
02064         <span class="comment">//</span>
02065         <span class="comment">// The only way the stack slot could be in use is if we skipped before</span>
02066         <span class="comment">//</span>
02067         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(!LocationsAdvanced); <span class="comment">// &amp;&amp; (!isNewSession)</span>
02068         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(IrpSp == iovCurrentStackLocation-&gt;<a class="code" href="../../d9/d1/struct__IOV__STACK__LOCATION.html#o4">IrpSp</a>);
02069 
02070     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (MarkAsTaken) {
02071 
02072         <span class="comment">//</span>
02073         <span class="comment">// ADRIAO BUGBUG 01/02/1999 -</span>
02074         <span class="comment">//     Is the below assertion is not true in the case of an internally</span>
02075         <span class="comment">// forwarded, completed, and then externally forwarded IRP?</span>
02076         <span class="comment">//</span>
02077         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(LocationsAdvanced); <span class="comment">// || isNewSession</span>
02078         RtlZeroMemory(iovCurrentStackLocation, <span class="keyword">sizeof</span>(<a class="code" href="../../d9/d1/struct__IOV__STACK__LOCATION.html">IOV_STACK_LOCATION</a>));
02079         InitializeListHead(&amp;iovCurrentStackLocation-&gt;<a class="code" href="../../d9/d1/struct__IOV__STACK__LOCATION.html#o3">CallStackData</a>);
02080         iovCurrentStackLocation-&gt;<a class="code" href="../../d9/d1/struct__IOV__STACK__LOCATION.html#o4">IrpSp</a> = IrpSp;
02081     }
02082 
02083     <span class="comment">//</span>
02084     <span class="comment">// Determine the last original request. A "Request" is block of data in a</span>
02085     <span class="comment">// stack location that is progressively copied downwards as the IRP is</span>
02086     <span class="comment">// forwarded (ie, a forwarded START IRP, a forwarded IOCTL, etc). A clever</span>
02087     <span class="comment">// driver writer could use his own stack location to send down a quick</span>
02088     <span class="comment">// query before forwarding along the original request. We correctly</span>
02089     <span class="comment">// differentiate between those two unique requests within the IRP below.</span>
02090     <span class="comment">//</span>
02091     <span class="keywordflow">if</span> (isNewSession) {
02092 
02093         <span class="comment">//</span>
02094         <span class="comment">// *We* are the original request. None of these fields below should</span>
02095         <span class="comment">// be used.</span>
02096         <span class="comment">//</span>
02097         dispatchRoutine = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02098         requestOriginalSLD = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02099         stackTime = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02100         dispatchTime = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02101 
02102     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (LocationsAdvanced) {
02103 
02104         <span class="comment">//</span>
02105         <span class="comment">// To get the original request (the pointer to the Irp slot that</span>
02106         <span class="comment">// represents where we *first* saw this request), we go backwards to get</span>
02107         <span class="comment">// the most recent previous irp slot data (set up when the device above</span>
02108         <span class="comment">// forwarded this Irp to us), and we read what it's original request was.</span>
02109         <span class="comment">// We also get the dispatch routine for that slot, which we will use to</span>
02110         <span class="comment">// backfill skipped slots if we advanced more than one Irp stack</span>
02111         <span class="comment">// location this time (ie, someone called IoSetNextIrpStackLocation).</span>
02112         <span class="comment">//</span>
02113         dispatchTime       = &amp;iovCurrentStackLocation[LocationsAdvanced].<a class="code" href="../../d9/d1/struct__IOV__STACK__LOCATION.html#o6">PerfDispatchStart</a>;
02114         stackTime          = &amp;iovCurrentStackLocation[LocationsAdvanced].PerfStackLocationStart;
02115         dispatchRoutine    = iovCurrentStackLocation[LocationsAdvanced].LastDispatch;
02116         requestOriginalSLD = iovCurrentStackLocation[LocationsAdvanced].<a class="code" href="../../d9/d1/struct__IOV__STACK__LOCATION.html#o2">RequestsFirstStackLocation</a>;
02117 
02118         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(dispatchRoutine);
02119         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(iovCurrentStackLocation[LocationsAdvanced].InUse);
02120         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(requestOriginalSLD-&gt;<a class="code" href="../../d9/d1/struct__IOV__STACK__LOCATION.html#o2">RequestsFirstStackLocation</a> == requestOriginalSLD);
02121         iovCurrentStackLocation-&gt;RequestsFirstStackLocation = requestOriginalSLD;
02122 
02123     } <span class="keywordflow">else</span> {
02124 
02125         <span class="comment">//</span>
02126         <span class="comment">// We skipped. The slot should already be filled.</span>
02127         <span class="comment">//</span>
02128         dispatchRoutine = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02129         dispatchTime = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02130         stackTime = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02131         requestOriginalSLD = iovCurrentStackLocation-&gt;<a class="code" href="../../d9/d1/struct__IOV__STACK__LOCATION.html#o2">RequestsFirstStackLocation</a>;
02132         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(requestOriginalSLD);
02133         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(requestOriginalSLD-&gt;<a class="code" href="../../d9/d1/struct__IOV__STACK__LOCATION.html#o2">RequestsFirstStackLocation</a> == requestOriginalSLD);
02134     }
02135 
02136     <span class="comment">//</span>
02137     <span class="comment">// The previous request seen is in requestOriginalSLD (NULL if none). If</span>
02138     <span class="comment">// we advanced more than one stack location (ie, someone called</span>
02139     <span class="comment">// IoSetNextIrpStackLocation), we need to update the slots we never saw get</span>
02140     <span class="comment">// consumed. Note that the dispatch routine we set in the slot is for the</span>
02141     <span class="comment">// driver that owned the last slot - we do not use the device object at</span>
02142     <span class="comment">// that IrpSp because it might be stale (or perhaps even NULL).</span>
02143     <span class="comment">//</span>
02144     advancedLocationData = iovCurrentStackLocation;
02145     irpSpTemp = IrpSp;
02146     <span class="keywordflow">while</span>(LocationsAdvanced&gt;1) {
02147         advancedLocationData++ ;
02148         LocationsAdvanced-- ;
02149         irpSpTemp++ ;
02150         <a class="code" href="../../d9/d4/trackirp_8h.html#a88">TRACKIRP_DBGPRINT</a>((
02151             <span class="stringliteral">"  Late smacking %lx to valid in CD1\n"</span>,
02152             advancedLocationData - StackDataArray
02153             ), 3) ;
02154 
02155         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(!advancedLocationData-&gt;<a class="code" href="../../d9/d1/struct__IOV__STACK__LOCATION.html#o0">InUse</a>) ;
02156         RtlZeroMemory(advancedLocationData, <span class="keyword">sizeof</span>(<a class="code" href="../../d9/d1/struct__IOV__STACK__LOCATION.html">IOV_STACK_LOCATION</a>)) ;
02157         InitializeListHead(&amp;advancedLocationData-&gt;<a class="code" href="../../d9/d1/struct__IOV__STACK__LOCATION.html#o3">CallStackData</a>) ;
02158         advancedLocationData-&gt;<a class="code" href="../../d9/d1/struct__IOV__STACK__LOCATION.html#o0">InUse</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> ;
02159         advancedLocationData-&gt;<a class="code" href="../../d9/d1/struct__IOV__STACK__LOCATION.html#o4">IrpSp</a> = irpSpTemp ;
02160 
02161         advancedLocationData-&gt;<a class="code" href="../../d9/d1/struct__IOV__STACK__LOCATION.html#o2">RequestsFirstStackLocation</a> = requestOriginalSLD ;
02162         advancedLocationData-&gt;<a class="code" href="../../d9/d1/struct__IOV__STACK__LOCATION.html#o6">PerfDispatchStart</a> = *dispatchTime;
02163         advancedLocationData-&gt;<a class="code" href="../../d9/d1/struct__IOV__STACK__LOCATION.html#o7">PerfStackLocationStart</a> = *stackTime;
02164         advancedLocationData-&gt;<a class="code" href="../../d9/d1/struct__IOV__STACK__LOCATION.html#o5">LastDispatch</a> = dispatchRoutine ;
02165     }
02166 
02167     <span class="comment">//</span>
02168     <span class="comment">// For the assertion below...</span>
02169     <span class="comment">//</span>
02170     <span class="keywordflow">if</span> (LocationsAdvanced) {
02171         irpSpTemp++ ;
02172     }
02173     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>((irpSpTemp == IrpLastSp)||(IrpLastSp == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) ;
02174 
02175     <span class="comment">//</span>
02176     <span class="comment">// Write out the slot we're using.</span>
02177     <span class="comment">//</span>
02178     *StackLocationInfo = iovCurrentStackLocation;
02179 
02180     <span class="keywordflow">if</span> (!MarkAsTaken) {
02181         <span class="keywordflow">return</span> iovCurrentStackLocation-&gt;InUse;
02182     }
02183 
02184     <span class="comment">//</span>
02185     <span class="comment">// Record a pointer in this slot to the requests originating slot as</span>
02186     <span class="comment">// appropriate.</span>
02187     <span class="comment">//</span>
02188     <span class="keywordflow">if</span> (IsNewRequest) {
02189 
02190         <a class="code" href="../../d9/d4/trackirp_8h.html#a88">TRACKIRP_DBGPRINT</a>((
02191             <span class="stringliteral">"  CD1: %lx is a new request\n"</span>,
02192             advancedLocationData-StackDataArray
02193             ), 3) ;
02194 
02195         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(LocationsAdvanced == 1) ;
02196         <span class="comment">//</span>
02197         <span class="comment">// ADRIAO BUGBUG 01/02/1999 -</span>
02198         <span class="comment">//</span>
02199         <span class="comment">//     Why the **ll did I have this there? If this were correct then the</span>
02200         <span class="comment">// backfill logic above would need fixing. I think what I have now is</span>
02201         <span class="comment">// correct, not this:</span>
02202         <span class="comment">//</span>
02203         <span class="comment">// advancedLocationData-&gt;RequestsFirstStackLocation = advancedLocationData ;</span>
02204         <span class="comment">//</span>
02205         iovCurrentStackLocation-&gt;RequestsFirstStackLocation = iovCurrentStackLocation;
02206 
02207     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (LocationsAdvanced) {
02208 
02209         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(!isNewSession) ;
02210         <span class="comment">//</span>
02211         <span class="comment">// ADRIAO BUGBUG 01/02/1999 -</span>
02212         <span class="comment">//     As per above, this should already have been handled.</span>
02213         <span class="comment">//</span>
02214         <span class="comment">//advancedLocationData-&gt;RequestsFirstStackLocation = requestOriginalSLD ;</span>
02215         <a class="code" href="../../d9/d4/trackirp_8h.html#a88">TRACKIRP_DBGPRINT</a>((
02216             <span class="stringliteral">"  CD1: %lx is a request for %lx\n"</span>,
02217             advancedLocationData-StackDataArray,
02218             requestOriginalSLD-StackDataArray
02219             ), 3) ;
02220 
02221     } <span class="keywordflow">else</span> {
02222 
02223         <span class="comment">//</span>
02224         <span class="comment">// As we skipped, the request should not have changed. If it did,</span>
02225         <span class="comment">// either guy we called trashed the stack given to him (giving none</span>
02226         <span class="comment">// to the dude under him), or we incorrectly saw a new request when</span>
02227         <span class="comment">// we shouldn't have (see previous comment).</span>
02228         <span class="comment">//</span>
02229         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(!isNewSession) ;
02230         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(advancedLocationData-&gt;<a class="code" href="../../d9/d1/struct__IOV__STACK__LOCATION.html#o2">RequestsFirstStackLocation</a> == requestOriginalSLD) ;
02231     }
02232 
02233     wasInUse = iovCurrentStackLocation-&gt;InUse;
02234     iovCurrentStackLocation-&gt;InUse = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02235     <span class="keywordflow">return</span> wasInUse;
02236 }
02237 
02238 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l02239"></a><a class="code" href="../../d9/d4/trackirp_8h.html#a121">02239</a> <a class="code" href="../../d9/d4/trackirp_8h.html#a121">IovpExamineIrpStackForwarding</a>(
02240     IN OUT  <a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html">PIOV_REQUEST_PACKET</a>  IovPacket,
02241     IN      BOOLEAN              IsNewSession,
02242     IN      ULONG                ForwardMethod,
02243     IN      <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>       DeviceObject,
02244     IN      <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>                 Irp,
02245     IN OUT  <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a>  *IoCurrentStackLocation,
02246     OUT     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a>  *IoLastStackLocation,
02247     OUT     ULONG               *StackLocationsAdvanced
02248     )
02249 {
02250     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
02251     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpSp, irpLastSp;
02252     BOOLEAN isSameStack;
02253     ULONG locationsAdvanced;
02254 
02255     irpSp = *IoCurrentStackLocation;
02256 
02257     <span class="keywordflow">if</span> (!IsNewSession) {
02258 
02259         <span class="comment">//</span>
02260         <span class="comment">// We are sitting on current next being one back (-1) from</span>
02261         <span class="comment">// CurrentStackLocation.</span>
02262         <span class="comment">//</span>
02263         locationsAdvanced = IovPacket-&gt;LastLocation-<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o13">CurrentLocation</a> ;
02264         irpLastSp = <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.CurrentStackLocation+(locationsAdvanced-1) ;
02265 
02266     } <span class="keywordflow">else</span> {
02267 
02268         <span class="comment">//</span>
02269         <span class="comment">// New IRP, so no last SP and we always advance "1"</span>
02270         <span class="comment">//</span>
02271         locationsAdvanced = 1 ;
02272         irpLastSp = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ;
02273     }
02274 
02275     <span class="keywordflow">if</span> ((!IsNewSession) &amp;&amp; (IovPacket-&gt;AssertFlags&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a2">ASSERTFLAG_POLICEIRPS</a>)) {
02276 
02277         <span class="comment">//</span>
02278         <span class="comment">// As the control field is zeroed by IoCopyCurrentStackLocation, we</span>
02279         <span class="comment">// dope each stack location with the value SL_NOTCOPIED. If it is</span>
02280         <span class="comment">// zeroed or the IRP stack location has stayed the same, the one of</span>
02281         <span class="comment">// the two API's was called. Otherwise the next stack location wasn't</span>
02282         <span class="comment">// set up properly (I have yet to find a case otherwise)...</span>
02283         <span class="comment">//</span>
02284         <span class="keywordflow">if</span> ((irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o3">Control</a>&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a60">SL_NOTCOPIED</a>)&amp;&amp;
02285             IovPacket-&gt;LastLocation != <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o13">CurrentLocation</a>) {
02286 
02287 <span class="preprocessor">#if 0</span>
02288 <span class="preprocessor"></span>            <a class="code" href="../../d8/d4/trackirp_8c.html#a6">FAIL_CALLER_OF_IOFCALLDRIVER2</a>(
02289                 (<a class="code" href="../../d2/d5/ioassert_8h.html#a114a45">DCERROR_NEXTIRPSP_DIRTY</a>, <a class="code" href="../../d2/d5/ioassert_8h.html#a7">DCPARAM_IRP</a>, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>),
02290                 irpSp
02291                 );
02292 <span class="preprocessor">#endif</span>
02293 <span class="preprocessor"></span>        }
02294 
02295         <span class="comment">//</span>
02296         <span class="comment">// Now check for people who copy the stack locations and forget to</span>
02297         <span class="comment">// wipe out previous completion routines.</span>
02298         <span class="comment">//</span>
02299         <span class="keywordflow">if</span> (locationsAdvanced) {
02300 
02301             <span class="comment">//</span>
02302             <span class="comment">// IoCopyCurrentStackLocation copies everything but Completion,</span>
02303             <span class="comment">// Context, and Control</span>
02304             <span class="comment">//</span>
02305             isSameStack = RtlEqualMemory(irpSp, irpLastSp,
02306                 FIELD_OFFSET(<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">IO_STACK_LOCATION</a>, Control)) ;
02307 
02308             isSameStack &amp;= RtlEqualMemory(&amp;irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>, &amp;irpLastSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>,
02309                 FIELD_OFFSET(<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">IO_STACK_LOCATION</a>, DeviceObject)-
02310                 FIELD_OFFSET(<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">IO_STACK_LOCATION</a>, Parameters)) ;
02311 
02312             isSameStack &amp;= (irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a> == irpLastSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a>) ;
02313 
02314             <span class="comment">//</span>
02315             <span class="comment">// We should *never* see this on the stack! If we do, something</span>
02316             <span class="comment">// quite bizarre has happened...</span>
02317             <span class="comment">//</span>
02318             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o116">CompletionRoutine</a> != <a class="code" href="../../d8/d4/trackirp_8c.html#a29">IovpSwapSurrogateIrp</a>) ;
02319 
02320             <span class="keywordflow">if</span> (isSameStack) {
02321 
02322                 <span class="comment">//</span>
02323                 <span class="comment">// We caught them doing something either very bad or quite</span>
02324                 <span class="comment">// inefficient. We can tell which based on whether there is</span>
02325                 <span class="comment">// a completion routine.</span>
02326                 <span class="comment">//</span>
02327                 <span class="keywordflow">if</span> ((irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o116">CompletionRoutine</a> == irpLastSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o116">CompletionRoutine</a>)&amp;&amp;
02328                     (irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o117">Context</a> == irpLastSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o117">Context</a>) &amp;&amp;
02329                     (irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o3">Control</a> == irpLastSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o3">Control</a>) &amp;&amp;
02330                     (irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o116">CompletionRoutine</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
02331                     (DeviceObject-&gt;DriverObject != irpLastSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o57">DeviceObject</a>-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o3">DriverObject</a>)
02332                     ) {
02333 
02334                     <span class="comment">//</span>
02335                     <span class="comment">// Duplication of both the completion and the context</span>
02336                     <span class="comment">// while not properly zeroing the control field is enough</span>
02337                     <span class="comment">// to make me believe the caller has made a vexing mistake.</span>
02338                     <span class="comment">//</span>
02339                     <a class="code" href="../../d8/d4/trackirp_8c.html#a6">FAIL_CALLER_OF_IOFCALLDRIVER2</a>(
02340                         (<a class="code" href="../../d2/d5/ioassert_8h.html#a114a46">DCERROR_IRPSP_COPIED</a>, <a class="code" href="../../d2/d5/ioassert_8h.html#a7">DCPARAM_IRP</a>, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>),
02341                         irpSp
02342                         ) ;
02343 
02344                     <span class="comment">//</span>
02345                     <span class="comment">// Repair the stack</span>
02346                     <span class="comment">//</span>
02347                     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o116">CompletionRoutine</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ;
02348                     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o3">Control</a> = 0 ;
02349 
02350                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o116">CompletionRoutine</a>) {
02351 
02352                     <span class="keywordflow">if</span> (!(irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o3">Control</a>&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a60">SL_NOTCOPIED</a>)
02353 <span class="preprocessor">#ifdef HACKHACKS_ENABLED</span>
02354 <span class="preprocessor"></span>                        &amp;&amp; (!(<a class="code" href="../../d8/d4/trackirp_8c.html#a8">IovpHackFlags</a>&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a16">HACKFLAG_FOR_SCSIPORT</a>))
02355 <span class="preprocessor">#endif</span>
02356 <span class="preprocessor"></span>                        ) {
02357 
02358                         <span class="comment">//</span>
02359                         <span class="comment">// ADRIAO HACKHACK 06/12/98 #10 - PeterWie does this for</span>
02360                         <span class="comment">// two reasons:</span>
02361                         <span class="comment">// 1) It's easier to debug</span>
02362                         <span class="comment">// 2) The space is not really recovered anyway.</span>
02363                         <span class="comment">//</span>
02364                         <span class="comment">// This will be an ongoing argument it seems, but #2 can</span>
02365                         <span class="comment">// be cleverly solved if one decrements their stack</span>
02366                         <span class="comment">// count, and #1 I've solved in Debug...</span>
02367                         <span class="comment">//</span>
02368                         <span class="keywordflow">if</span> (irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a> == <a class="code" href="../../d0/d5/io_8h.html#a35">IRP_MJ_POWER</a>) {
02369 
02370                             <span class="comment">//</span>
02371                             <span class="comment">// Unwind back past PoCallDriver...</span>
02372                             <span class="comment">//</span>
02373                             <a class="code" href="../../d2/d5/ioassert_8h.html#a13">WDM_CHASTISE_CALLER5</a>(
02374                                 (<a class="code" href="../../d2/d5/ioassert_8h.html#a114a67">DCERROR_UNNECCESSARY_COPY</a>, <a class="code" href="../../d2/d5/ioassert_8h.html#a7">DCPARAM_IRP</a>, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>)
02375                                 );
02376 
02377                         } <span class="keywordflow">else</span> {
02378 
02379                             <a class="code" href="../../d2/d5/ioassert_8h.html#a12">WDM_CHASTISE_CALLER3</a>(
02380                                 (<a class="code" href="../../d2/d5/ioassert_8h.html#a114a67">DCERROR_UNNECCESSARY_COPY</a>, <a class="code" href="../../d2/d5/ioassert_8h.html#a7">DCPARAM_IRP</a>, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>)
02381                                 );
02382                         }
02383                     }
02384 
02385                     <a class="code" href="../../d0/d5/io_8h.html#a237">IoSetCompletionRoutine</a>(
02386                         <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>,
02387                         <a class="code" href="../../d8/d4/trackirp_8c.html#a25">IovpInternalCompletionTrap</a>,
02388                         <a class="code" href="../../d0/d5/io_8h.html#a228">IoGetCurrentIrpStackLocation</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> ),
02389                         <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
02390                         <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
02391                         <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>
02392                         ) ;
02393                 }
02394             }
02395 
02396         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (IovPacket-&gt;AssertFlags&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a6">ASSERTFLAG_CONSUME_ALWAYS</a>) {
02397 
02398             <span class="keywordflow">if</span> (ForwardMethod == <a class="code" href="../../d9/d4/trackirp_8h.html#a63">FORWARDED_TO_NEXT_DO</a>) {
02399 
02400                 <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o13">CurrentLocation</a>&lt;2) {
02401 
02402                     <a class="code" href="../../d8/d4/trackirp_8c.html#a6">FAIL_CALLER_OF_IOFCALLDRIVER2</a>(
02403                         (<a class="code" href="../../d2/d5/ioassert_8h.html#a114a47">DCERROR_INSUFFICIENT_STACK_LOCATIONS</a>, <a class="code" href="../../d2/d5/ioassert_8h.html#a7">DCPARAM_IRP</a>, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>),
02404                         irpSp
02405                         ) ;
02406 
02407                 } <span class="keywordflow">else</span> {
02408 
02409                     <span class="comment">//</span>
02410                     <span class="comment">// Back up the skip, then copy. Add a completion routine with</span>
02411                     <span class="comment">// unique and assertable context to catch people who clumsily</span>
02412                     <span class="comment">// Rtl-copy stack locations (we can't catch them if the caller</span>
02413                     <span class="comment">// above used an empty stack with no completion routine)...</span>
02414                     <span class="comment">//</span>
02415                     <a class="code" href="../../d0/d5/io_8h.html#a238">IoSetNextIrpStackLocation</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> ) ;
02416 
02417                     <span class="comment">//</span>
02418                     <span class="comment">// Set the trap...</span>
02419                     <span class="comment">//</span>
02420                     <a class="code" href="../../d0/d5/io_8h.html#a239">IoCopyCurrentIrpStackLocationToNext</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> ) ;
02421                     <a class="code" href="../../d0/d5/io_8h.html#a237">IoSetCompletionRoutine</a>(
02422                         <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>,
02423                         <a class="code" href="../../d8/d4/trackirp_8c.html#a25">IovpInternalCompletionTrap</a>,
02424                         <a class="code" href="../../d0/d5/io_8h.html#a228">IoGetCurrentIrpStackLocation</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> ),
02425                         <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
02426                         <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
02427                         <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>
02428                         ) ;
02429 
02430                     <span class="comment">//</span>
02431                     <span class="comment">// This is our new reality...</span>
02432                     <span class="comment">//</span>
02433                     locationsAdvanced = 1 ;
02434                     irpSp = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
02435                 }
02436             }
02437         }
02438     }
02439 
02440     *IoCurrentStackLocation = irpSp;
02441     *IoLastStackLocation = irpLastSp;
02442     *StackLocationsAdvanced = locationsAdvanced;
02443 }
02444 
02445 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l02446"></a><a class="code" href="../../d9/d4/trackirp_8h.html#a126">02446</a> <a class="code" href="../../d9/d4/trackirp_8h.html#a126">IovpInternalCompletionTrap</a>(
02447     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject,
02448     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp,
02449     IN PVOID Context
02450     )
02451 <span class="comment">/*++</span>
02452 <span class="comment"></span>
02453 <span class="comment">  Description:</span>
02454 <span class="comment"></span>
02455 <span class="comment">    This routine does nothing but act as a trap for people</span>
02456 <span class="comment">    incorrectly copying stack locations...</span>
02457 <span class="comment"></span>
02458 <span class="comment">  Arguments:</span>
02459 <span class="comment"></span>
02460 <span class="comment">    DeviceObject           - Device object set at this level of the completion</span>
02461 <span class="comment">                             routine - ignored.</span>
02462 <span class="comment"></span>
02463 <span class="comment">    Irp                    - A pointer to the IRP.</span>
02464 <span class="comment"></span>
02465 <span class="comment">    Context                - Context should equal the Irp's stack location -</span>
02466 <span class="comment">                             this is asserted.</span>
02467 <span class="comment"></span>
02468 <span class="comment">  Return Value:</span>
02469 <span class="comment"></span>
02470 <span class="comment">     STATUS_SUCCESS</span>
02471 <span class="comment"></span>
02472 <span class="comment">--*/</span>
02473 {
02474     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpSp ;
02475 
02476     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o11">PendingReturned</a>) {
02477 
02478         <a class="code" href="../../d0/d5/io_8h.html#a234">IoMarkIrpPending</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> ) ;
02479     }
02480     irpSp = <a class="code" href="../../d0/d5/io_8h.html#a228">IoGetCurrentIrpStackLocation</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> ) ;
02481 
02482     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>((PVOID) irpSp == Context) ;
02483 
02484     <span class="keywordflow">return</span> STATUS_SUCCESS ;
02485 }
02486 
02487 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l02488"></a><a class="code" href="../../d9/d4/trackirp_8h.html#a137">02488</a> <a class="code" href="../../d9/d4/trackirp_8h.html#a137">IovpInternalCompleteAtDPC</a>(
02489     IN <a class="code" href="../../d1/d6/struct__KDPC.html">PKDPC</a> Dpc,
02490     IN PVOID DeferredContext,
02491     IN PVOID SystemArgument1,
02492     IN PVOID SystemArgument2
02493     )
02494 {
02495     <a class="code" href="../../d9/d4/trackirp_8h.html#a136">IovpInternalCompleteAfterWait</a>(DeferredContext) ;
02496 }
02497 
02498 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l02499"></a><a class="code" href="../../d9/d4/trackirp_8h.html#a136">02499</a> <a class="code" href="../../d9/d4/trackirp_8h.html#a136">IovpInternalCompleteAfterWait</a>(
02500     IN PVOID Context
02501     )
02502 {
02503     <a class="code" href="../../d3/d2/struct__DEFERRAL__CONTEXT.html">PDEFERRAL_CONTEXT</a> deferralContext = (<a class="code" href="../../d3/d2/struct__DEFERRAL__CONTEXT.html">PDEFERRAL_CONTEXT</a>) Context ;
02504     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpSpNext ;
02505     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status ;
02506 
02507     <span class="keywordflow">if</span> (deferralContext-&gt;<a class="code" href="../../d3/d2/struct__DEFERRAL__CONTEXT.html#o10">DeferAction</a> == <a class="code" href="../../d9/d4/trackirp_8h.html#a146a104">DEFERACTION_QUEUE_PASSIVE_TIMER</a>) {
02508 
02509         <span class="comment">//</span>
02510         <span class="comment">// Wait the appropriate amount of time if so ordered...</span>
02511         <span class="comment">//</span>
02512         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(KeGetCurrentIrql()==<a class="code" href="../../d1/d3/ppcdef_8h.html#a21">PASSIVE_LEVEL</a>) ;
02513         <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>(
02514             &amp;deferralContext-&gt;<a class="code" href="../../d3/d2/struct__DEFERRAL__CONTEXT.html#o9">DeferralTimer</a>,
02515             <a class="code" href="../../d6/d7/halmips_8h.html#a455">Executive</a>,
02516             <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
02517             <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
02518             <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>
02519             ) ;
02520     }
02521 
02522     <a class="code" href="../../d9/d8/hashirp_8h.html#a11">IovpTrackingDataAcquireLock</a>(deferralContext-&gt;<a class="code" href="../../d3/d2/struct__DEFERRAL__CONTEXT.html#o0">IovRequestPacket</a>) ;
02523 
02524     <a class="code" href="../../d9/d8/hashirp_8h.html#a18">IovpProtectedIrpMakeTouchable</a>(
02525         deferralContext-&gt;<a class="code" href="../../d3/d2/struct__DEFERRAL__CONTEXT.html#o3">OriginalIrp</a>,
02526         &amp;deferralContext-&gt;<a class="code" href="../../d3/d2/struct__DEFERRAL__CONTEXT.html#o0">IovRequestPacket</a>-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o20">RestoreHandle</a>
02527         );
02528 
02529     irpSpNext = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>( deferralContext-&gt;<a class="code" href="../../d3/d2/struct__DEFERRAL__CONTEXT.html#o3">OriginalIrp</a> ) ;
02530 
02531     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(irpSpNext == deferralContext-&gt;<a class="code" href="../../d3/d2/struct__DEFERRAL__CONTEXT.html#o6">IrpSpNext</a>) ;
02532     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(irpSpNext-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o116">CompletionRoutine</a> == deferralContext-&gt;<a class="code" href="../../d3/d2/struct__DEFERRAL__CONTEXT.html#o1">OriginalCompletionRoutine</a>) ;
02533     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(irpSpNext-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o117">Context</a> == deferralContext-&gt;<a class="code" href="../../d3/d2/struct__DEFERRAL__CONTEXT.html#o2">OriginalContext</a>) ;
02534 
02535     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(deferralContext-&gt;<a class="code" href="../../d3/d2/struct__DEFERRAL__CONTEXT.html#o0">IovRequestPacket</a>-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o5">Flags</a> &amp; <a class="code" href="../../d9/d4/trackirp_8h.html#a29">TRACKFLAG_QUEUED_INTERNALLY</a>) ;
02536     deferralContext-&gt;<a class="code" href="../../d3/d2/struct__DEFERRAL__CONTEXT.html#o0">IovRequestPacket</a>-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o5">Flags</a> &amp;=~ TRACKFLAG_QUEUED_INTERNALLY ;
02537 
02538     <a class="code" href="../../d9/d8/hashirp_8h.html#a14">IovpTrackingDataDereference</a>(deferralContext-&gt;<a class="code" href="../../d3/d2/struct__DEFERRAL__CONTEXT.html#o0">IovRequestPacket</a>, <a class="code" href="../../d9/d8/hashirp_8h.html#a21a5">IOVREFTYPE_POINTER</a>) ;
02539     <a class="code" href="../../d9/d8/hashirp_8h.html#a12">IovpTrackingDataReleaseLock</a>(deferralContext-&gt;<a class="code" href="../../d3/d2/struct__DEFERRAL__CONTEXT.html#o0">IovRequestPacket</a>) ;
02540 
02541     status = irpSpNext-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o116">CompletionRoutine</a>(
02542         deferralContext-&gt;<a class="code" href="../../d3/d2/struct__DEFERRAL__CONTEXT.html#o5">DeviceObject</a>,
02543         deferralContext-&gt;<a class="code" href="../../d3/d2/struct__DEFERRAL__CONTEXT.html#o3">OriginalIrp</a>,
02544         irpSpNext-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o117">Context</a>
02545         ) ;
02546 
02547     <span class="keywordflow">if</span> (status!=STATUS_MORE_PROCESSING_REQUIRED) {
02548 
02549         <a class="code" href="../../d0/d5/io_8h.html#a224">IoCompleteRequest</a>(deferralContext-&gt;<a class="code" href="../../d3/d2/struct__DEFERRAL__CONTEXT.html#o3">OriginalIrp</a>, deferralContext-&gt;<a class="code" href="../../d3/d2/struct__DEFERRAL__CONTEXT.html#o4">OriginalPriorityBoost</a>) ;
02550     }
02551     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(deferralContext) ;
02552 }
02553 
02554 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l02555"></a><a class="code" href="../../d9/d4/trackirp_8h.html#a127">02555</a> <a class="code" href="../../d9/d4/trackirp_8h.html#a127">IovpInternalDeferredCompletion</a>(
02556     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject,
02557     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp,
02558     IN PVOID Context
02559     )
02560 <span class="comment">/*++</span>
02561 <span class="comment"></span>
02562 <span class="comment">  Description:</span>
02563 <span class="comment"></span>
02564 <span class="comment">    This function is slipped in as a completion routine when we are</span>
02565 <span class="comment">    "deferring" completion via work item, etc.</span>
02566 <span class="comment"></span>
02567 <span class="comment">  Arguments:</span>
02568 <span class="comment"></span>
02569 <span class="comment">    DeviceObject           - Device object set at this level of the completion</span>
02570 <span class="comment">                             routine - passed on.</span>
02571 <span class="comment"></span>
02572 <span class="comment">    Irp                    - A pointer to the IRP.</span>
02573 <span class="comment"></span>
02574 <span class="comment">    Context                - Context block that includes original completion</span>
02575 <span class="comment">                             routine.</span>
02576 <span class="comment"></span>
02577 <span class="comment">  Return Value:</span>
02578 <span class="comment"></span>
02579 <span class="comment">     NTSTATUS</span>
02580 <span class="comment"></span>
02581 <span class="comment">--*/</span>
02582 {
02583     <a class="code" href="../../d3/d2/struct__DEFERRAL__CONTEXT.html">PDEFERRAL_CONTEXT</a> deferralContext = (<a class="code" href="../../d3/d2/struct__DEFERRAL__CONTEXT.html">PDEFERRAL_CONTEXT</a>) Context;
02584     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpSpNext;
02585     BOOLEAN passiveCompletionOK;
02586     <a class="code" href="../../d9/d4/trackirp_8h.html#a146">DEFER_ACTION</a> deferAction;
02587     ULONG refAction;
02588     ULONG trackingFlags;
02589     LARGE_INTEGER deltaTime;
02590 
02591     <span class="comment">//</span>
02592     <span class="comment">// Do delta time conversion.</span>
02593     <span class="comment">//</span>
02594     deltaTime.QuadPart = - <a class="code" href="../../d8/d4/trackirp_8c.html#a12">IovpIrpDeferralTime</a> ;
02595 
02596     <span class="comment">//</span>
02597     <span class="comment">// The *next* stack location holds our completion and context. The current</span>
02598     <span class="comment">// stack location has already been wiped.</span>
02599     <span class="comment">//</span>
02600     irpSpNext = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> ) ;
02601 
02602     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>((PVOID) irpSpNext-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o116">CompletionRoutine</a> == <a class="code" href="../../d8/d4/trackirp_8c.html#a28">IovpInternalDeferredCompletion</a>) ;
02603 
02604     <span class="comment">//</span>
02605     <span class="comment">// Put everything back in case someone is looking...</span>
02606     <span class="comment">//</span>
02607     irpSpNext-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o116">CompletionRoutine</a> = deferralContext-&gt;<a class="code" href="../../d3/d2/struct__DEFERRAL__CONTEXT.html#o1">OriginalCompletionRoutine</a> ;
02608     irpSpNext-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o117">Context</a> = deferralContext-&gt;<a class="code" href="../../d3/d2/struct__DEFERRAL__CONTEXT.html#o2">OriginalContext</a> ;
02609 
02610     <span class="comment">//</span>
02611     <span class="comment">// Some IRP dispatch routines cannot be called at passive. Two examples are</span>
02612     <span class="comment">// paging IRPs (cause we could switch) and Power IRPs. As we don't check yet,</span>
02613     <span class="comment">// if we "were" completed passive, continue to do so, but elsewhere...</span>
02614     <span class="comment">//</span>
02615     passiveCompletionOK = (KeGetCurrentIrql()==<a class="code" href="../../d1/d3/ppcdef_8h.html#a21">PASSIVE_LEVEL</a>) ;
02616 
02617     <a class="code" href="../../d9/d8/hashirp_8h.html#a11">IovpTrackingDataAcquireLock</a>(deferralContext-&gt;<a class="code" href="../../d3/d2/struct__DEFERRAL__CONTEXT.html#o0">IovRequestPacket</a>) ;
02618 
02619     <span class="comment">//</span>
02620     <span class="comment">// Verify all completion routines are in nonpaged code.</span>
02621     <span class="comment">//</span>
02622     <span class="keywordflow">if</span> (deferralContext-&gt;<a class="code" href="../../d3/d2/struct__DEFERRAL__CONTEXT.html#o0">IovRequestPacket</a>-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o11">AssertFlags</a>&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a2">ASSERTFLAG_POLICEIRPS</a>) {
02623 
02624         <span class="keywordflow">if</span> (<a class="code" href="../../d2/d1/mm_8h.html#a207">MmIsSystemAddressLocked</a>(irpSpNext-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o116">CompletionRoutine</a>) == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
02625 
02626             <a class="code" href="../../d2/d5/ioassert_8h.html#a21">WDM_FAIL_ROUTINE</a>((
02627                 <a class="code" href="../../d2/d5/ioassert_8h.html#a114a78">DCERROR_COMPLETION_ROUTINE_PAGABLE</a>,
02628                 <a class="code" href="../../d2/d5/ioassert_8h.html#a7">DCPARAM_IRP</a> + <a class="code" href="../../d2/d5/ioassert_8h.html#a8">DCPARAM_ROUTINE</a>,
02629                 <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>,
02630                 irpSpNext-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o116">CompletionRoutine</a>
02631                 )) ;
02632         }
02633     }
02634 
02635     trackingFlags = deferralContext-&gt;<a class="code" href="../../d3/d2/struct__DEFERRAL__CONTEXT.html#o0">IovRequestPacket</a>-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o11">AssertFlags</a>;
02636 
02637     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(trackingFlags&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a7">ASSERTFLAG_FORCEPENDING</a>) ;
02638 
02639     <span class="keywordflow">switch</span>(trackingFlags&amp;(<a class="code" href="../../d9/d4/trackirp_8h.html#a10">ASSERTFLAG_DEFERCOMPLETION</a>|
02640                           <a class="code" href="../../d9/d4/trackirp_8h.html#a9">ASSERTFLAG_COMPLETEATPASSIVE</a>|
02641                           <a class="code" href="../../d9/d4/trackirp_8h.html#a8">ASSERTFLAG_COMPLETEATDPC</a>)) {
02642 
02643         <span class="keywordflow">case</span> <a class="code" href="../../d9/d4/trackirp_8h.html#a9">ASSERTFLAG_COMPLETEATPASSIVE</a>:
02644             deferAction = passiveCompletionOK ? <a class="code" href="../../d9/d4/trackirp_8h.html#a146a103">DEFERACTION_QUEUE_WORKITEM</a> :
02645                                                 <a class="code" href="../../d9/d4/trackirp_8h.html#a146a106">DEFERACTION_NORMAL</a> ;
02646             <span class="keywordflow">break</span>;
02647 
02648         <span class="keywordflow">case</span> <a class="code" href="../../d9/d4/trackirp_8h.html#a10">ASSERTFLAG_DEFERCOMPLETION</a> | <a class="code" href="../../d9/d4/trackirp_8h.html#a9">ASSERTFLAG_COMPLETEATPASSIVE</a>:
02649             deferAction = passiveCompletionOK ? <a class="code" href="../../d9/d4/trackirp_8h.html#a146a104">DEFERACTION_QUEUE_PASSIVE_TIMER</a> :
02650                                                 <a class="code" href="../../d9/d4/trackirp_8h.html#a146a106">DEFERACTION_NORMAL</a> ;
02651             <span class="keywordflow">break</span>;
02652 
02653         <span class="keywordflow">case</span> <a class="code" href="../../d9/d4/trackirp_8h.html#a10">ASSERTFLAG_DEFERCOMPLETION</a> | <a class="code" href="../../d9/d4/trackirp_8h.html#a8">ASSERTFLAG_COMPLETEATDPC</a>:
02654             deferAction = <a class="code" href="../../d9/d4/trackirp_8h.html#a146a105">DEFERACTION_QUEUE_DISPATCH_TIMER</a> ;
02655             <span class="keywordflow">break</span>;
02656 
02657         <span class="keywordflow">case</span> <a class="code" href="../../d9/d4/trackirp_8h.html#a10">ASSERTFLAG_DEFERCOMPLETION</a>:
02658             deferAction = (KeGetCurrentIrql()==<a class="code" href="../../d6/d7/halmips_8h.html#a53">DISPATCH_LEVEL</a>) ?
02659                 <a class="code" href="../../d9/d4/trackirp_8h.html#a146a105">DEFERACTION_QUEUE_DISPATCH_TIMER</a> :
02660                 <a class="code" href="../../d9/d4/trackirp_8h.html#a146a104">DEFERACTION_QUEUE_PASSIVE_TIMER</a> ;
02661             <span class="keywordflow">break</span>;
02662 
02663         <span class="keywordflow">default</span>:
02664             deferAction = <a class="code" href="../../d9/d4/trackirp_8h.html#a146a106">DEFERACTION_NORMAL</a> ;
02665             <a class="code" href="../../d2/d5/ioassert_8h.html#a23">KDASSERT</a>(0) ;
02666     }
02667 
02668     <span class="keywordflow">if</span> (deferAction != <a class="code" href="../../d9/d4/trackirp_8h.html#a146a106">DEFERACTION_NORMAL</a>) {
02669 
02670         <span class="comment">//</span>
02671         <span class="comment">// Set this flag. If anybody uses this IRP while this flag is on, complain</span>
02672         <span class="comment">// immediately!</span>
02673         <span class="comment">//</span>
02674         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(!(trackingFlags&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a29">TRACKFLAG_QUEUED_INTERNALLY</a>)) ;
02675         deferralContext-&gt;<a class="code" href="../../d3/d2/struct__DEFERRAL__CONTEXT.html#o0">IovRequestPacket</a>-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o5">Flags</a> |= <a class="code" href="../../d9/d4/trackirp_8h.html#a29">TRACKFLAG_QUEUED_INTERNALLY</a> ;
02676         deferralContext-&gt;<a class="code" href="../../d3/d2/struct__DEFERRAL__CONTEXT.html#o5">DeviceObject</a> = DeviceObject ;
02677 
02678         deferralContext-&gt;<a class="code" href="../../d3/d2/struct__DEFERRAL__CONTEXT.html#o0">IovRequestPacket</a>-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o20">RestoreHandle</a> =
02679             <a class="code" href="../../d9/d8/hashirp_8h.html#a17">IovpProtectedIrpMakeUntouchable</a>(
02680                 <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>,
02681                 <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>
02682                 ) ;
02683     } <span class="keywordflow">else</span> {
02684 
02685         <a class="code" href="../../d9/d8/hashirp_8h.html#a14">IovpTrackingDataDereference</a>(deferralContext-&gt;<a class="code" href="../../d3/d2/struct__DEFERRAL__CONTEXT.html#o0">IovRequestPacket</a>, <a class="code" href="../../d9/d8/hashirp_8h.html#a21a5">IOVREFTYPE_POINTER</a>);
02686     }
02687 
02688     <a class="code" href="../../d9/d8/hashirp_8h.html#a12">IovpTrackingDataReleaseLock</a>(deferralContext-&gt;<a class="code" href="../../d3/d2/struct__DEFERRAL__CONTEXT.html#o0">IovRequestPacket</a>) ;
02689 
02690     deferralContext-&gt;<a class="code" href="../../d3/d2/struct__DEFERRAL__CONTEXT.html#o10">DeferAction</a> = deferAction ;
02691 
02692     <span class="keywordflow">switch</span>(deferAction) {
02693 
02694         <span class="keywordflow">case</span> <a class="code" href="../../d9/d4/trackirp_8h.html#a146a104">DEFERACTION_QUEUE_PASSIVE_TIMER</a>:
02695             <a class="code" href="../../d3/d2/timerobj_8c.html#a2">KeInitializeTimerEx</a>(&amp;deferralContext-&gt;<a class="code" href="../../d3/d2/struct__DEFERRAL__CONTEXT.html#o9">DeferralTimer</a>, SynchronizationTimer) ;
02696             <a class="code" href="../../d3/d2/timerobj_8c.html#a7">KeSetTimerEx</a>(
02697                 &amp;deferralContext-&gt;<a class="code" href="../../d3/d2/struct__DEFERRAL__CONTEXT.html#o9">DeferralTimer</a>,
02698                 deltaTime,
02699                 0,
02700                 <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>
02701                 ) ;
02702 
02703             <span class="comment">//</span>
02704             <span class="comment">// Fall through...</span>
02705             <span class="comment">//</span>
02706 
02707         <span class="keywordflow">case</span> <a class="code" href="../../d9/d4/trackirp_8h.html#a146a103">DEFERACTION_QUEUE_WORKITEM</a>:
02708 
02709             <span class="comment">//</span>
02710             <span class="comment">// Queue this up so we can complete this passively.</span>
02711             <span class="comment">//</span>
02712             <a class="code" href="../../d5/d8/ex_8h.html#a55">ExInitializeWorkItem</a>(
02713                 (<a class="code" href="../../d7/d9/struct__WORK__QUEUE__ITEM.html">PWORK_QUEUE_ITEM</a>)&amp;deferralContext-&gt;<a class="code" href="../../d3/d2/struct__DEFERRAL__CONTEXT.html#o7">WorkQueueItem</a>,
02714                 <a class="code" href="../../d8/d4/trackirp_8c.html#a27">IovpInternalCompleteAfterWait</a>,
02715                 deferralContext
02716                 );
02717 
02718             <a class="code" href="../../d5/d8/ex_8h.html#a261">ExQueueWorkItem</a>(
02719                 (<a class="code" href="../../d7/d9/struct__WORK__QUEUE__ITEM.html">PWORK_QUEUE_ITEM</a>)&amp;deferralContext-&gt;<a class="code" href="../../d3/d2/struct__DEFERRAL__CONTEXT.html#o7">WorkQueueItem</a>,
02720                 <a class="code" href="../../d5/d8/ex_8h.html#a332a206">DelayedWorkQueue</a>
02721                 );
02722 
02723             <span class="keywordflow">return</span> STATUS_MORE_PROCESSING_REQUIRED ;
02724 
02725         <span class="keywordflow">case</span> <a class="code" href="../../d9/d4/trackirp_8h.html#a146a105">DEFERACTION_QUEUE_DISPATCH_TIMER</a>:
02726 
02727             <a class="code" href="../../d4/d1/dpcobj_8c.html#a1">KeInitializeDpc</a>(
02728                 &amp;deferralContext-&gt;<a class="code" href="../../d3/d2/struct__DEFERRAL__CONTEXT.html#o8">DpcItem</a>,
02729                 <a class="code" href="../../d8/d4/trackirp_8c.html#a26">IovpInternalCompleteAtDPC</a>,
02730                 deferralContext
02731                 );
02732 
02733             <a class="code" href="../../d3/d2/timerobj_8c.html#a2">KeInitializeTimerEx</a>(&amp;deferralContext-&gt;<a class="code" href="../../d3/d2/struct__DEFERRAL__CONTEXT.html#o9">DeferralTimer</a>, SynchronizationTimer) ;
02734             <a class="code" href="../../d3/d2/timerobj_8c.html#a7">KeSetTimerEx</a>(
02735                 &amp;deferralContext-&gt;<a class="code" href="../../d3/d2/struct__DEFERRAL__CONTEXT.html#o9">DeferralTimer</a>,
02736                 deltaTime,
02737                 0,
02738                 &amp;deferralContext-&gt;<a class="code" href="../../d3/d2/struct__DEFERRAL__CONTEXT.html#o8">DpcItem</a>
02739                 ) ;
02740             <span class="keywordflow">return</span> STATUS_MORE_PROCESSING_REQUIRED ;
02741 
02742         <span class="keywordflow">case</span> <a class="code" href="../../d9/d4/trackirp_8h.html#a146a106">DEFERACTION_NORMAL</a>:
02743         <span class="keywordflow">default</span>:
02744 
02745             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(deferralContext) ;
02746             <span class="keywordflow">return</span> irpSpNext-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o116">CompletionRoutine</a>(DeviceObject, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, irpSpNext-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o117">Context</a>) ;
02747     }
02748 }
02749 
02750 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l02751"></a><a class="code" href="../../d9/d4/trackirp_8h.html#a122">02751</a> <a class="code" href="../../d9/d4/trackirp_8h.html#a122">IovpSwapSurrogateIrp</a>(
02752     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject,
02753     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp,
02754     IN PVOID Context
02755     )
02756 <span class="comment">/*++</span>
02757 <span class="comment"></span>
02758 <span class="comment">  Description:</span>
02759 <span class="comment"></span>
02760 <span class="comment">    This completion routine will copy back the surrogate IRP</span>
02761 <span class="comment">    to the original and complete the original IRP.</span>
02762 <span class="comment"></span>
02763 <span class="comment">  Arguments:</span>
02764 <span class="comment"></span>
02765 <span class="comment">    DeviceObject           - Device object set at this level</span>
02766 <span class="comment">                             of the completion routine - ignored.</span>
02767 <span class="comment"></span>
02768 <span class="comment">    Irp                    - A pointer to the IRP.</span>
02769 <span class="comment"></span>
02770 <span class="comment">    Context                - Context should equal the IRP - this is</span>
02771 <span class="comment">                             asserted.</span>
02772 <span class="comment"></span>
02773 <span class="comment">  Return Value:</span>
02774 <span class="comment"></span>
02775 <span class="comment">     STATUS_MORE_PROCESSING_REQUIRED...</span>
02776 <span class="comment"></span>
02777 <span class="comment">--*/</span>
02778 {
02779     <a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html">PIOV_REQUEST_PACKET</a> iovPacket, iovPrevPacket;
02780     <a class="code" href="../../d8/d1/struct__IOV__SESSION__DATA.html">PIOV_SESSION_DATA</a> iovSessionData;
02781     ULONG irpSize ;
02782     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> realIrp ;
02783     BOOLEAN freeTrackingData ;
02784     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status, lockedStatus ;
02785     CCHAR priorityBoost ;
02786     PVOID completionRoutine ;
02787     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpSp ;
02788     BOOLEAN locked ;
02789 
02790     <span class="comment">//</span>
02791     <span class="comment">// If this one fails, somebody has probably copied the stack</span>
02792     <span class="comment">// inclusive with our completion routine. We should already</span>
02793     <span class="comment">// have caught this...</span>
02794     <span class="comment">//</span>
02795     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> == Context) ;
02796 
02797     iovPacket = <a class="code" href="../../d9/d8/hashirp_8h.html#a7">IovpTrackingDataFindAndLock</a>(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>) ;
02798     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(iovPacket) ;
02799 
02800     <span class="keywordflow">if</span> (iovPacket == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02801 
02802         <span class="keywordflow">return</span> STATUS_SUCCESS ;
02803     }
02804 
02805     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o16">TopStackLocation</a> == <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o13">CurrentLocation</a>) ;
02806 
02807     iovSessionData = <a class="code" href="../../d9/d8/hashirp_8h.html#a16">IovpTrackingDataGetCurrentSessionData</a>(iovPacket);
02808     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(iovSessionData);
02809 
02810     <span class="comment">//</span>
02811     <span class="comment">// Put everything back</span>
02812     <span class="comment">//</span>
02813     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o9">HeadPacket</a> != iovPacket);
02814 
02815     iovPrevPacket = CONTAINING_RECORD(
02816         iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o7">SurrogateLink</a>.Blink,
02817         <a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html">IOV_REQUEST_PACKET</a>,
02818         SurrogateLink
02819         );
02820 
02821     realIrp = iovPrevPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o0">TrackedIrp</a> ;
02822     irpSize = <a class="code" href="../../d0/d5/io_8h.html#a245">IoSizeOfIrp</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o12">StackCount</a> ) ;
02823 
02824     <span class="comment">//</span>
02825     <span class="comment">// Back the IRP stack up so that the original completion routine</span>
02826     <span class="comment">// is called if appropriate</span>
02827     <span class="comment">//</span>
02828     <a class="code" href="../../d0/d5/io_8h.html#a238">IoSetNextIrpStackLocation</a>(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>);
02829     <a class="code" href="../../d0/d5/io_8h.html#a238">IoSetNextIrpStackLocation</a>(realIrp);
02830 
02831     irpSp = <a class="code" href="../../d0/d5/io_8h.html#a228">IoGetCurrentIrpStackLocation</a>(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>) ;
02832     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o116">CompletionRoutine</a> = iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o12">RealIrpCompletionRoutine</a> ;
02833     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o3">Control</a>           = iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o13">RealIrpControl</a> ;
02834     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o117">Context</a>           = iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o14">RealIrpContext</a> ;
02835 
02836     <span class="comment">//</span>
02837     <span class="comment">// Record final data and make any accesses to the surrogate IRP</span>
02838     <span class="comment">// crash.</span>
02839     <span class="comment">//</span>
02840     irpSp = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>) ;
02841     <span class="keywordflow">if</span> (iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o11">AssertFlags</a>&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a2">ASSERTFLAG_POLICEIRPS</a>) {
02842 
02843         <a class="code" href="../../d8/d4/flunkirp_8h.html#a6">IovpAssertFinalIrpStack</a>(iovPacket, irpSp) ;
02844     }
02845 
02846     priorityBoost = iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o17">PriorityBoost</a> ;
02847     <a class="code" href="../../d9/d8/hashirp_8h.html#a14">IovpTrackingDataDereference</a>(iovPacket, <a class="code" href="../../d9/d8/hashirp_8h.html#a21a5">IOVREFTYPE_POINTER</a>);
02848     <a class="code" href="../../d6/d7/sessnirp_8h.html#a7">IovpSessionDataFinalizeSurrogate</a>(iovSessionData, iovPacket, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>);
02849     <a class="code" href="../../d6/d7/sessnirp_8h.html#a4">IovpSessionDataClose</a>(iovSessionData);
02850     <a class="code" href="../../d6/d7/sessnirp_8h.html#a3">IovpSessionDataDereference</a>(iovSessionData);
02851 
02852     <a class="code" href="../../d9/d4/trackirp_8h.html#a88">TRACKIRP_DBGPRINT</a>((
02853         <span class="stringliteral">"  Swapping surrogate IRP %lx back to %lx (Tracking data %lx)\n"</span>,
02854         <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>,
02855         realIrp,
02856         iovPacket
02857         ), 1) ;
02858 
02859     iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o5">Flags</a> |= <a class="code" href="../../d9/d4/trackirp_8h.html#a33">TRACKFLAG_SWAPPED_BACK</a> ;
02860     <a class="code" href="../../d9/d8/hashirp_8h.html#a12">IovpTrackingDataReleaseLock</a>(iovPacket) ;
02861 
02862     <span class="comment">//</span>
02863     <span class="comment">// Send the IRP onwards and upwards.</span>
02864     <span class="comment">//</span>
02865     <a class="code" href="../../d0/d5/io_8h.html#a224">IoCompleteRequest</a>(realIrp, priorityBoost) ;
02866 
02867     <span class="keywordflow">return</span> STATUS_MORE_PROCESSING_REQUIRED ;
02868 }
02869 
02870 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
02871 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l02872"></a><a class="code" href="../../d8/d4/trackirp_8c.html#a30">02872</a> <a class="code" href="../../d9/d4/trackirp_8h.html#a116">IovpCancelIrp</a>(
02873     IN     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>               Irp,
02874     OUT    PBOOLEAN           CancelHandled,
02875     OUT    PBOOLEAN           ReturnValue
02876     )
02877 <span class="comment">/*++</span>
02878 <span class="comment"></span>
02879 <span class="comment">  Description:</span>
02880 <span class="comment"></span>
02881 <span class="comment">    This routine is called by IoCancelIrp and returns TRUE iff</span>
02882 <span class="comment">    the cancelation was handled internally here (in which case</span>
02883 <span class="comment">    IoCancelIrp should do nothing).</span>
02884 <span class="comment"></span>
02885 <span class="comment">    We need to handle the call internally when we are currently</span>
02886 <span class="comment">    dealing with a surrogate. In this case, we make sure the</span>
02887 <span class="comment">    surrogate is cancelled instead.</span>
02888 <span class="comment"></span>
02889 <span class="comment">  Arguments:</span>
02890 <span class="comment"></span>
02891 <span class="comment">    Irp                    - A pointer to the IRP passed into</span>
02892 <span class="comment">                             IoCancelIrp.</span>
02893 <span class="comment"></span>
02894 <span class="comment">    CancelHandled          - Indicates whether the IRP cancellation</span>
02895 <span class="comment">                             was handled entirely by this routine.</span>
02896 <span class="comment"></span>
02897 <span class="comment">    ReturnValue            - Set to the value IoCancelIrp</span>
02898 <span class="comment">                             should return if the IRP cancelation</span>
02899 <span class="comment">                             was handled entirely by this routine.</span>
02900 <span class="comment"></span>
02901 <span class="comment">  Return Value:</span>
02902 <span class="comment"></span>
02903 <span class="comment">     None.</span>
02904 <span class="comment"></span>
02905 <span class="comment">--*/</span>
02906 {
02907     <a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html">PIOV_REQUEST_PACKET</a> iovPacket, iovNextPacket;
02908     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irpToCancel;
02909     KIRQL irql ;
02910 
02911     *CancelHandled = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> ;
02912 
02913     iovPacket = <a class="code" href="../../d9/d8/hashirp_8h.html#a7">IovpTrackingDataFindAndLock</a>(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>) ;
02914     <span class="keywordflow">if</span> (!iovPacket) {
02915 
02916         <span class="keywordflow">return</span> ;
02917     }
02918 
02919     <span class="comment">//</span>
02920     <span class="comment">// If the IRP is queued internally, touching it is not very safe as we may</span>
02921     <span class="comment">// have temporarily removed the page's backing. Restore the backing while</span>
02922     <span class="comment">// under the IRPs track lock.</span>
02923     <span class="comment">//</span>
02924 
02925     <span class="keywordflow">if</span> (iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o5">Flags</a>&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a29">TRACKFLAG_QUEUED_INTERNALLY</a>) {
02926 
02927         <a class="code" href="../../d9/d8/hashirp_8h.html#a18">IovpProtectedIrpMakeTouchable</a>(
02928             <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>,
02929             &amp;iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o20">RestoreHandle</a>
02930             );
02931 
02932         iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o20">RestoreHandle</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ;
02933     }
02934 
02935     <span class="keywordflow">if</span> (!(iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o5">Flags</a>&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a25">TRACKFLAG_ACTIVE</a>)) {
02936 
02937         <span class="comment">//</span>
02938         <span class="comment">// We've already completed the IRP, and the only reason it's</span>
02939         <span class="comment">// still being tracked is because of it's allocation.</span>
02940         <span class="comment">// So it is not ours to cancel.</span>
02941         <span class="comment">//</span>
02942         <a class="code" href="../../d9/d8/hashirp_8h.html#a12">IovpTrackingDataReleaseLock</a>(iovPacket);
02943         <span class="keywordflow">return</span>;
02944     }
02945 
02946     <span class="keywordflow">if</span> (!(iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o5">Flags</a>&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a27">TRACKFLAG_HAS_SURROGATE</a>)) {
02947 
02948         <span class="comment">//</span>
02949         <span class="comment">// Cancel of an IRP that doesn't have an active surrogate. Let it</span>
02950         <span class="comment">// proceed normally.</span>
02951         <span class="comment">//</span>
02952         <a class="code" href="../../d9/d8/hashirp_8h.html#a12">IovpTrackingDataReleaseLock</a>(iovPacket);
02953         <span class="keywordflow">return</span>;
02954     }
02955 
02956     <span class="keywordflow">if</span> (iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o11">AssertFlags</a>&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a2">ASSERTFLAG_POLICEIRPS</a>) {
02957 
02958         <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o25">CancelRoutine</a>) {
02959 
02960             <a class="code" href="../../d2/d5/ioassert_8h.html#a21">WDM_FAIL_ROUTINE</a>((
02961                 <a class="code" href="../../d2/d5/ioassert_8h.html#a114a80">DCERROR_CANCELROUTINE_ON_FORWARDED_IRP</a>,
02962                 <a class="code" href="../../d2/d5/ioassert_8h.html#a7">DCPARAM_IRP</a> + <a class="code" href="../../d2/d5/ioassert_8h.html#a8">DCPARAM_ROUTINE</a>,
02963                 <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>,
02964                 <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o25">CancelRoutine</a>
02965                 ));
02966 
02967             <span class="comment">//</span>
02968             <span class="comment">// We will ignore this routine. As we should...</span>
02969             <span class="comment">//</span>
02970         }
02971     }
02972 
02973     iovNextPacket = CONTAINING_RECORD(
02974         iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o7">SurrogateLink</a>.Flink,
02975         <a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html">IOV_REQUEST_PACKET</a>,
02976         SurrogateLink
02977         );
02978 
02979     <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o14">Cancel</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02980     *CancelHandled = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> ;
02981     irpToCancel = iovNextPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o0">TrackedIrp</a> ;
02982     <a class="code" href="../../d9/d8/hashirp_8h.html#a12">IovpTrackingDataReleaseLock</a>(iovPacket) ;
02983     *ReturnValue = <a class="code" href="../../d4/d6/iosubs_8c.html#a30">IoCancelIrp</a>(irpToCancel) ;
02984 
02985     <span class="keywordflow">return</span> ;
02986 }
02987 
02988 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
02989 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l02990"></a><a class="code" href="../../d9/d4/trackirp_8h.html#a117">02990</a> <a class="code" href="../../d9/d4/trackirp_8h.html#a117">IovpFreeIrp</a>(
02991     IN     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>               Irp,
02992     IN OUT PBOOLEAN           FreeHandled
02993     )
02994 <span class="comment">/*++</span>
02995 <span class="comment"></span>
02996 <span class="comment">  Description:</span>
02997 <span class="comment"></span>
02998 <span class="comment">    This routine is called by IoFreeIrp and returns TRUE iff</span>
02999 <span class="comment">    the free was handled internally here (in which case IoFreeIrp</span>
03000 <span class="comment">    should do nothing).</span>
03001 <span class="comment"></span>
03002 <span class="comment">    We need to handle the call internally because we may turn off lookaside</span>
03003 <span class="comment">    list cacheing to catch people reusing IRPs after they are freed.</span>
03004 <span class="comment"></span>
03005 <span class="comment">  Arguments:</span>
03006 <span class="comment"></span>
03007 <span class="comment">    Irp                    - A pointer to the IRP passed into</span>
03008 <span class="comment">                             IoCancelIrp.</span>
03009 <span class="comment"></span>
03010 <span class="comment">    FreeHandled            - Indicates whether the free operation was</span>
03011 <span class="comment">                             handled entirely by this routine.</span>
03012 <span class="comment"></span>
03013 <span class="comment">  Return Value:</span>
03014 <span class="comment"></span>
03015 <span class="comment">     None.</span>
03016 <span class="comment"></span>
03017 <span class="comment">--*/</span>
03018 {
03019     <a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html">PIOV_REQUEST_PACKET</a> iovPacket;
03020     PVOID restoreHandle ;
03021 
03022     iovPacket = <a class="code" href="../../d9/d8/hashirp_8h.html#a7">IovpTrackingDataFindAndLock</a>(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>);
03023 
03024     <span class="keywordflow">if</span> (iovPacket == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03025 
03026         <span class="comment">//</span>
03027         <span class="comment">// ADRIAO BUGBUG 01/06/1999 -</span>
03028         <span class="comment">//     Below assertion might fire if an IRP allocated then freed twice.</span>
03029         <span class="comment">//</span>
03030         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(!(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o17">AllocationFlags</a>&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a61">IRP_ALLOCATION_MONITORED</a>));
03031         *FreeHandled = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> ;
03032         <span class="keywordflow">return</span>;
03033     }
03034 
03035     <span class="keywordflow">if</span> (!IsListEmpty(&amp;<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o8">ThreadListEntry</a>)) {
03036 
03037         <span class="keywordflow">if</span> (iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o11">AssertFlags</a>&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a2">ASSERTFLAG_POLICEIRPS</a>) {
03038 
03039             <a class="code" href="../../d2/d5/ioassert_8h.html#a16">WDM_FAIL_CALLER2</a>(
03040                 (<a class="code" href="../../d2/d5/ioassert_8h.html#a114a51">DCERROR_FREE_OF_THREADED_IRP</a>, <a class="code" href="../../d2/d5/ioassert_8h.html#a7">DCPARAM_IRP</a>, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>)
03041                 );
03042         }
03043 
03044         <span class="comment">//</span>
03045         <span class="comment">// &lt;Grumble&gt; keep us alive by not actually freeing the IRP if someone did</span>
03046         <span class="comment">// this to us. We leak for life...</span>
03047         <span class="comment">//</span>
03048         *FreeHandled = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> ;
03049         <span class="keywordflow">return</span> ;
03050     }
03051 
03052     <span class="keywordflow">if</span> (<a class="code" href="../../d9/d8/hashirp_8h.html#a16">IovpTrackingDataGetCurrentSessionData</a>(iovPacket)) {
03053 
03054         <span class="comment">//</span>
03055         <span class="comment">// If there's a current session, that means someone is freeing an IRP</span>
03056         <span class="comment">// that they don't own. Of course, if the stack unwound badly because</span>
03057         <span class="comment">// someone forgot to return PENDING or complete the IRP, then we don't</span>
03058         <span class="comment">// assert here (we'd probably end up blaiming kernel).</span>
03059         <span class="comment">//</span>
03060         <span class="keywordflow">if</span> ((iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o11">AssertFlags</a>&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a2">ASSERTFLAG_POLICEIRPS</a>) &amp;&amp;
03061             (!(iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o5">Flags</a>&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a36">TRACKFLAG_UNWOUND_BADLY</a>))) {
03062 
03063             <a class="code" href="../../d2/d5/ioassert_8h.html#a16">WDM_FAIL_CALLER2</a>(
03064                 (<a class="code" href="../../d2/d5/ioassert_8h.html#a114a50">DCERROR_FREE_OF_INUSE_IRP</a>, <a class="code" href="../../d2/d5/ioassert_8h.html#a7">DCPARAM_IRP</a>, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>)
03065                 );
03066         }
03067 
03068         <span class="comment">//</span>
03069         <span class="comment">// &lt;Grumble&gt; keep us alive by not actually freeing the IRP if someone did</span>
03070         <span class="comment">// this to us. We leak for life...</span>
03071         <span class="comment">//</span>
03072         <a class="code" href="../../d9/d8/hashirp_8h.html#a12">IovpTrackingDataReleaseLock</a>(iovPacket) ;
03073         *FreeHandled = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> ;
03074         <span class="keywordflow">return</span> ;
03075     }
03076 
03077     <span class="keywordflow">if</span> (!(iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o5">Flags</a>&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a35">TRACKFLAG_IO_ALLOCATED</a>)) {
03078 
03079         <span class="comment">//</span>
03080         <span class="comment">// We weren't tracking this at allocation time. We shouldn't got our</span>
03081         <span class="comment">// packet unless the IRP had a pointer count still, meaning it's has</span>
03082         <span class="comment">// a session. And that should've been caught above.</span>
03083         <span class="comment">//</span>
03084         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(0);
03085         <a class="code" href="../../d9/d8/hashirp_8h.html#a12">IovpTrackingDataReleaseLock</a>(iovPacket) ;
03086         *FreeHandled = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> ;
03087         <span class="keywordflow">return</span>;
03088     }
03089 
03090     <span class="comment">//</span>
03091     <span class="comment">// The IRP may have been reinitialized, possibly losing it's allocation</span>
03092     <span class="comment">// flags. We catch this bug in the IoInitializeIrp hook.</span>
03093     <span class="comment">//</span>
03094     <span class="comment">//ASSERT(Irp-&gt;AllocationFlags&amp;IRP_ALLOCATION_MONITORED) ;</span>
03095     <span class="comment">//</span>
03096 
03097     <span class="keywordflow">if</span> (!(iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o5">Flags</a>&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a28">TRACKFLAG_PROTECTEDIRP</a>)) {
03098 
03099         <span class="comment">//</span>
03100         <span class="comment">// We're just tagging along this IRP. Drop our pointer count but bail.</span>
03101         <span class="comment">//</span>
03102         <a class="code" href="../../d9/d8/hashirp_8h.html#a14">IovpTrackingDataDereference</a>(iovPacket, <a class="code" href="../../d9/d8/hashirp_8h.html#a21a5">IOVREFTYPE_POINTER</a>);
03103         <a class="code" href="../../d9/d8/hashirp_8h.html#a12">IovpTrackingDataReleaseLock</a>(iovPacket);
03104         *FreeHandled = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03105         <span class="keywordflow">return</span>;
03106     }
03107 
03108     <span class="comment">//</span>
03109     <span class="comment">// Set up a nice bugcheck for those who free their IRPs twice. This is done</span>
03110     <span class="comment">// because the special pool may have been exhausted, in which case the IRP</span>
03111     <span class="comment">// can be touched after it has been freed.</span>
03112     <span class="comment">//</span>
03113     <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o0">Type</a> = 0;
03114 
03115     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(iovPacket) ;
03116     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o11">AssertFlags</a>&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a2">ASSERTFLAG_POLICEIRPS</a>);
03117     <a class="code" href="../../d9/d8/hashirp_8h.html#a14">IovpTrackingDataDereference</a>(iovPacket, <a class="code" href="../../d9/d8/hashirp_8h.html#a21a5">IOVREFTYPE_POINTER</a>);
03118     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o4">PointerCount</a> == 0);
03119     <a class="code" href="../../d9/d8/hashirp_8h.html#a12">IovpTrackingDataReleaseLock</a>(iovPacket) ;
03120     restoreHandle = <a class="code" href="../../d9/d8/hashirp_8h.html#a17">IovpProtectedIrpMakeUntouchable</a>(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) ;
03121     <a class="code" href="../../d9/d8/hashirp_8h.html#a19">IovpProtectedIrpFree</a>(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, &amp;restoreHandle) ;
03122 
03123     <span class="comment">//</span>
03124     <span class="comment">// We handled allocation and initialization. There is nothing much more to</span>
03125     <span class="comment">// do.</span>
03126     <span class="comment">//</span>
03127     *FreeHandled = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> ;
03128 }
03129 
03130 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
03131 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l03132"></a><a class="code" href="../../d9/d4/trackirp_8h.html#a118">03132</a> <a class="code" href="../../d9/d4/trackirp_8h.html#a118">IovpAllocateIrp1</a>(
03133     IN     CCHAR             StackSize,
03134     IN     BOOLEAN           ChargeQuota,
03135     IN OUT <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>              *IrpPointer
03136     )
03137 <span class="comment">/*++</span>
03138 <span class="comment"></span>
03139 <span class="comment">  Description:</span>
03140 <span class="comment"></span>
03141 <span class="comment">    This routine is called by IoAllocateIrp and returns an IRP iff</span>
03142 <span class="comment">    we are handled the allocations ourselves.</span>
03143 <span class="comment"></span>
03144 <span class="comment">    We may need to do this internally so we can turn off IRP lookaside lists</span>
03145 <span class="comment">    and use the special pool to catch people reusing free'd IRPs.</span>
03146 <span class="comment"></span>
03147 <span class="comment">  Arguments:</span>
03148 <span class="comment"></span>
03149 <span class="comment">    StackSize              - Count of stack locations to allocate for this IRP.</span>
03150 <span class="comment"></span>
03151 <span class="comment">    ChargeQuote            - TRUE if quote should be charged against the current</span>
03152 <span class="comment">                             thread.</span>
03153 <span class="comment"></span>
03154 <span class="comment">    IrpPointer             - Pointer to IRP if one was allocated. This will</span>
03155 <span class="comment">                             point to NULL after the call iff IoAllocateIrp</span>
03156 <span class="comment">                             should use it's normal lookaside list code.</span>
03157 <span class="comment"></span>
03158 <span class="comment">  Return Value:</span>
03159 <span class="comment"></span>
03160 <span class="comment">    None.</span>
03161 <span class="comment"></span>
03162 <span class="comment">--*/</span>
03163 {
03164     <a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html">PIOV_REQUEST_PACKET</a> iovPacket;
03165     PVOID returnAddress[1];
03166     ULONG stackHash;
03167     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
03168 
03169     *IrpPointer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ;
03170     <span class="keywordflow">if</span> (!(<a class="code" href="../../d8/d4/trackirp_8c.html#a7">IovpTrackingFlags</a>&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a1">ASSERTFLAG_MONITOR_ALLOCS</a>)) {
03171 
03172         <span class="keywordflow">return</span> ;
03173     }
03174 
03175     <span class="keywordflow">if</span> (!(<a class="code" href="../../d8/d4/trackirp_8c.html#a7">IovpTrackingFlags</a>&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a2">ASSERTFLAG_POLICEIRPS</a>)) {
03176 
03177         <span class="keywordflow">return</span> ;
03178     }
03179 
03180     irp = <a class="code" href="../../d9/d8/hashirp_8h.html#a20">IovpProtectedIrpAllocate</a>(
03181         StackSize,
03182         ChargeQuota,
03183         <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>()
03184         ) ;
03185 
03186     <span class="keywordflow">if</span> (irp == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03187 
03188         <span class="keywordflow">return</span>;
03189     }
03190 
03191     <a class="code" href="../../d0/d6/iop_8h.html#a20">IopInitializeIrp</a>(irp, <a class="code" href="../../d0/d5/io_8h.html#a245">IoSizeOfIrp</a>(StackSize), StackSize);
03192     *IrpPointer = irp;
03193 
03194     iovPacket = <a class="code" href="../../d9/d8/hashirp_8h.html#a8">IovpTrackingDataCreateAndLock</a>(irp);
03195 
03196     <span class="keywordflow">if</span> (iovPacket == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03197 
03198         <span class="keywordflow">return</span>;
03199     }
03200 
03201     <a class="code" href="../../d9/d8/hashirp_8h.html#a13">IovpTrackingDataReference</a>(iovPacket, <a class="code" href="../../d9/d8/hashirp_8h.html#a21a5">IOVREFTYPE_POINTER</a>);
03202     iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o5">Flags</a> |= <a class="code" href="../../d9/d4/trackirp_8h.html#a28">TRACKFLAG_PROTECTEDIRP</a> | <a class="code" href="../../d9/d4/trackirp_8h.html#a35">TRACKFLAG_IO_ALLOCATED</a>;
03203     irp-&gt;AllocationFlags |= <a class="code" href="../../d9/d4/trackirp_8h.html#a61">IRP_ALLOCATION_MONITORED</a> ;
03204     irp-&gt;Flags |= <a class="code" href="../../d9/d4/trackirp_8h.html#a21">IRPFLAG_EXAMINE_TRACKED</a>;
03205 
03206     <span class="comment">//</span>
03207     <span class="comment">// Record he who allocated this IRP (if we can get it)</span>
03208     <span class="comment">//</span>
03209     <a class="code" href="../../d5/d2/ppc_2getcalr_8c.html#a1">RtlCaptureStackBackTrace</a>(3, <a class="code" href="../../d9/d4/trackirp_8h.html#a68">IRP_ALLOC_COUNT</a>, iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o15">AllocatorStack</a>, &amp;stackHash) ;
03210 
03211     <a class="code" href="../../d9/d8/hashirp_8h.html#a12">IovpTrackingDataReleaseLock</a>(iovPacket) ;
03212 }
03213 
03214 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
03215 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l03216"></a><a class="code" href="../../d9/d4/trackirp_8h.html#a119">03216</a> <a class="code" href="../../d9/d4/trackirp_8h.html#a119">IovpAllocateIrp2</a>(
03217     IN     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>               Irp
03218     )
03219 <span class="comment">/*++</span>
03220 <span class="comment"></span>
03221 <span class="comment">  Description:</span>
03222 <span class="comment"></span>
03223 <span class="comment">    This routine is called by IoAllocateIrp and captures information if</span>
03224 <span class="comment">    the IRP was allocated by the OS.</span>
03225 <span class="comment"></span>
03226 <span class="comment">  Arguments:</span>
03227 <span class="comment"></span>
03228 <span class="comment">    Irp                    - Pointer to IRP</span>
03229 <span class="comment"></span>
03230 <span class="comment">  Return Value:</span>
03231 <span class="comment"></span>
03232 <span class="comment">    None.</span>
03233 <span class="comment"></span>
03234 <span class="comment">--*/</span>
03235 {
03236     <a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html">PIOV_REQUEST_PACKET</a> iovPacket;
03237     PVOID returnAddress[1];
03238     ULONG stackHash;
03239 
03240     <span class="keywordflow">if</span> (!(<a class="code" href="../../d8/d4/trackirp_8c.html#a7">IovpTrackingFlags</a>&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a1">ASSERTFLAG_MONITOR_ALLOCS</a>)) {
03241 
03242         <span class="keywordflow">return</span>;
03243     }
03244 
03245 <span class="comment">//    ASSERT(!(IovpTrackingFlags&amp;ASSERTFLAG_POLICEIRPS));</span>
03246 
03247     iovPacket = <a class="code" href="../../d9/d8/hashirp_8h.html#a8">IovpTrackingDataCreateAndLock</a>(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>);
03248     <span class="keywordflow">if</span> (iovPacket == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03249 
03250         <span class="keywordflow">return</span>;
03251     }
03252 
03253     <a class="code" href="../../d9/d8/hashirp_8h.html#a13">IovpTrackingDataReference</a>(iovPacket, <a class="code" href="../../d9/d8/hashirp_8h.html#a21a5">IOVREFTYPE_POINTER</a>);
03254     iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o5">Flags</a> |= <a class="code" href="../../d9/d4/trackirp_8h.html#a35">TRACKFLAG_IO_ALLOCATED</a>;
03255     <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o17">AllocationFlags</a> |= <a class="code" href="../../d9/d4/trackirp_8h.html#a61">IRP_ALLOCATION_MONITORED</a>;
03256     <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> |= <a class="code" href="../../d9/d4/trackirp_8h.html#a21">IRPFLAG_EXAMINE_TRACKED</a>;
03257 
03258     <span class="comment">//</span>
03259     <span class="comment">// Record he who allocated this IRP (if we can get it)</span>
03260     <span class="comment">//</span>
03261     <a class="code" href="../../d5/d2/ppc_2getcalr_8c.html#a1">RtlCaptureStackBackTrace</a>(2, <a class="code" href="../../d9/d4/trackirp_8h.html#a68">IRP_ALLOC_COUNT</a>, iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o15">AllocatorStack</a>, &amp;stackHash) ;
03262 
03263     <a class="code" href="../../d9/d8/hashirp_8h.html#a12">IovpTrackingDataReleaseLock</a>(iovPacket) ;
03264 }
03265 
03266 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
03267 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l03268"></a><a class="code" href="../../d9/d4/trackirp_8h.html#a120">03268</a> <a class="code" href="../../d9/d4/trackirp_8h.html#a120">IovpInitializeIrp</a>(
03269     IN OUT <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>               Irp,
03270     IN     USHORT             PacketSize,
03271     IN     CCHAR              StackSize,
03272     IN OUT PBOOLEAN           InitializeHandled
03273     )
03274 <span class="comment">/*++</span>
03275 <span class="comment"></span>
03276 <span class="comment">  Description:</span>
03277 <span class="comment"></span>
03278 <span class="comment">    This routine is called by IoInitializeIrp and sets InitializeHandled to</span>
03279 <span class="comment">    TRUE if the entire initialization was handled internally.</span>
03280 <span class="comment"></span>
03281 <span class="comment">    While here we verify the caller is not Initializing an IRP allocated</span>
03282 <span class="comment">    through IoAllocateIrp, as doing so means we may leak quota/etc.</span>
03283 <span class="comment"></span>
03284 <span class="comment">  Arguments:</span>
03285 <span class="comment"></span>
03286 <span class="comment">    Irp                    - Irp to initialize</span>
03287 <span class="comment"></span>
03288 <span class="comment">    PacketSize             - Size of the IRP in bytes.</span>
03289 <span class="comment"></span>
03290 <span class="comment">    StackSize              - Count of stack locations for this IRP.</span>
03291 <span class="comment"></span>
03292 <span class="comment">    InitializeHandled      - Pointer to a BOOLEAN that will be set to true iff</span>
03293 <span class="comment">                             the initialization of the IRP was handled entirely</span>
03294 <span class="comment">                             within this routine. If FALSE, IoInitializeIrp</span>
03295 <span class="comment">                             should initialize the IRP as normal.</span>
03296 <span class="comment"></span>
03297 <span class="comment">  Return Value:</span>
03298 <span class="comment"></span>
03299 <span class="comment">     None.</span>
03300 <span class="comment"></span>
03301 <span class="comment">--*/</span>
03302 {
03303     <a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html">PIOV_REQUEST_PACKET</a> iovPacket ;
03304 
03305     iovPacket = <a class="code" href="../../d9/d8/hashirp_8h.html#a7">IovpTrackingDataFindAndLock</a>(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>);
03306     <span class="keywordflow">if</span> (iovPacket == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03307 
03308         *InitializeHandled = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> ;
03309         <span class="keywordflow">return</span>;
03310     }
03311 
03312     <span class="keywordflow">if</span> ((iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o11">AssertFlags</a>&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a2">ASSERTFLAG_POLICEIRPS</a>) &amp;&amp;
03313        (iovPacket-&gt;<a class="code" href="../../d7/d1/struct__IOV__REQUEST__PACKET.html#o5">Flags</a>&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a35">TRACKFLAG_IO_ALLOCATED</a>)) {
03314 
03315         <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o17">AllocationFlags</a>&amp;<a class="code" href="../../d0/d5/io_8h.html#a190">IRP_QUOTA_CHARGED</a>) {
03316 
03317             <span class="comment">//</span>
03318             <span class="comment">// Don't let us leak quota now!</span>
03319             <span class="comment">//</span>
03320             <a class="code" href="../../d2/d5/ioassert_8h.html#a16">WDM_FAIL_CALLER2</a>(
03321                 (<a class="code" href="../../d2/d5/ioassert_8h.html#a114a52">DCERROR_REINIT_OF_ALLOCATED_IRP_WITH_QUOTA</a>, <a class="code" href="../../d2/d5/ioassert_8h.html#a7">DCPARAM_IRP</a>, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>)
03322                 );
03323 
03324         } <span class="keywordflow">else</span> {
03325 
03326             <span class="comment">//</span>
03327             <span class="comment">// In this case we are draining our lookaside lists erroneously.</span>
03328             <span class="comment">//</span>
03329             <span class="comment">// WDM_CHASTISE_CALLER2(</span>
03330             <span class="comment">//    (DCERROR_REINIT_OF_ALLOCATED_IRP_WITHOUT_QUOTA, DCPARAM_IRP, Irp)</span>
03331             <span class="comment">//    );</span>
03332         }
03333     }
03334 
03335     *InitializeHandled = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> ;
03336     <a class="code" href="../../d9/d8/hashirp_8h.html#a12">IovpTrackingDataReleaseLock</a>(iovPacket) ;
03337 }
03338 
03339 <span class="comment">/*</span>
03340 <span class="comment"> * Device Object functions</span>
03341 <span class="comment"> *   IovpExamineDevObjForwarded</span>
03342 <span class="comment"> *</span>
03343 <span class="comment"> */</span>
03344 
03345 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l03346"></a><a class="code" href="../../d9/d4/trackirp_8h.html#a138">03346</a> <a class="code" href="../../d9/d4/trackirp_8h.html#a138">IovpAttachDeviceToDeviceStack</a>(
03347     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> NewDevice,
03348     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> ExistingDevice
03349     )
03350 {
03351 }
03352 
03353 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l03354"></a><a class="code" href="../../d9/d4/trackirp_8h.html#a139">03354</a> <a class="code" href="../../d9/d4/trackirp_8h.html#a139">IovpDetachDevice</a>(
03355     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> LowerDevice
03356     )
03357 {
03358     <a class="code" href="../../d3/d5/struct__DEVOBJ__EXTENSION.html">PDEVOBJ_EXTENSION</a> deviceExtension;
03359 
03360     <span class="keywordflow">if</span> (LowerDevice-&gt;AttachedDevice == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03361 
03362         <a class="code" href="../../d2/d5/ioassert_8h.html#a16">WDM_FAIL_CALLER2</a>((<a class="code" href="../../d2/d5/ioassert_8h.html#a114a41">DCERROR_DETACH_NOT_ATTACHED</a>, <a class="code" href="../../d2/d5/ioassert_8h.html#a9">DCPARAM_DEVOBJ</a>, LowerDevice));
03363     } <span class="keywordflow">else</span> {
03364 
03365         <span class="comment">//</span>
03366         <span class="comment">// ADRIAO BUGBUG 01/07/1999 -</span>
03367         <span class="comment">//     As the stack can be torn apart simulatenously from above and</span>
03368         <span class="comment">// below during a remove IRP, we cannot assert the below, and moreover</span>
03369         <span class="comment">// changes to the ExtensionFlags will have to involve walking the tree.</span>
03370         <span class="comment">//</span>
03371         <span class="comment">// ASSERT(LowerDevice-&gt;AttachedDevice-&gt;AttachedDevice == NULL);</span>
03372         <span class="comment">//</span>
03373         deviceExtension = LowerDevice-&gt;AttachedDevice-&gt;DeviceObjectExtension;
03374         deviceExtension-&gt;<a class="code" href="../../d3/d5/struct__DEVOBJ__EXTENSION.html#o5">ExtensionFlags</a> &amp;=~ (<a class="code" href="../../d9/d4/trackirp_8h.html#a44">DOE_EXAMINED</a> | <a class="code" href="../../d9/d4/trackirp_8h.html#a45">DOE_TRACKED</a>);
03375     }
03376 }
03377 
03378 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l03379"></a><a class="code" href="../../d9/d4/trackirp_8h.html#a140">03379</a> <a class="code" href="../../d9/d4/trackirp_8h.html#a140">IovpDeleteDevice</a>(
03380     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject
03381     )
03382 {
03383     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> deviceBelow;
03384 
03385     <span class="comment">//</span>
03386     <span class="comment">// ADRIAO BUGBUG 03/03/1999 -</span>
03387     <span class="comment">//     Complain if the dude already deleted himself.</span>
03388     <span class="comment">//</span>
03389 
03390     deviceBelow = <a class="code" href="../../d9/d4/trackirp_8h.html#a125">IovpGetDeviceAttachedTo</a>(DeviceObject);
03391     <span class="keywordflow">if</span> (deviceBelow) {
03392 
03393         <a class="code" href="../../d2/d5/ioassert_8h.html#a15">WDM_FAIL_CALLER1</a>((<a class="code" href="../../d2/d5/ioassert_8h.html#a114a40">DCERROR_DELETE_WHILE_ATTACHED</a>, 0));
03394         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>(deviceBelow);
03395     }
03396 }
03397 
03398 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l03399"></a><a class="code" href="../../d9/d4/trackirp_8h.html#a143">03399</a> <a class="code" href="../../d9/d4/trackirp_8h.html#a143">IovpReexamineAllStacks</a>(
03400     VOID
03401     )
03402 {
03403     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
03404 
03405     <a class="code" href="../../d0/d2/obtype_8c.html#a3">ObEnumerateObjectsByType</a>(
03406         <a class="code" href="../../d3/d5/iodata_8c.html#a35">IoDeviceObjectType</a>,
03407         <a class="code" href="../../d8/d4/trackirp_8c.html#a39">IovpEnumDevObjCallback</a>,
03408         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>
03409         );
03410 }
03411 
03412 BOOLEAN
<a name="l03413"></a><a class="code" href="../../d9/d4/trackirp_8h.html#a144">03413</a> <a class="code" href="../../d9/d4/trackirp_8h.html#a144">IovpEnumDevObjCallback</a>(
03414     IN PVOID Object,
03415     IN PUNICODE_STRING ObjectName,
03416     IN ULONG HandleCount,
03417     IN ULONG PointerCount,
03418     IN PVOID Context
03419     )
03420 {
03421     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>      deviceObject;
03422     <a class="code" href="../../d3/d5/struct__DEVOBJ__EXTENSION.html">PDEVOBJ_EXTENSION</a>   deviceExtension;
03423 
03424     deviceObject = (<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>) Object;
03425     deviceExtension = deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o25">DeviceObjectExtension</a>;
03426 
03427     <span class="keywordflow">if</span> (PointerCount || HandleCount) {
03428 
03429         deviceExtension-&gt;<a class="code" href="../../d3/d5/struct__DEVOBJ__EXTENSION.html#o5">ExtensionFlags</a> &amp;=~ (<a class="code" href="../../d9/d4/trackirp_8h.html#a44">DOE_EXAMINED</a> | <a class="code" href="../../d9/d4/trackirp_8h.html#a45">DOE_TRACKED</a>);
03430     }
03431 
03432     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03433 }
03434 
03435 BOOLEAN
<a name="l03436"></a><a class="code" href="../../d9/d4/trackirp_8h.html#a141">03436</a> <a class="code" href="../../d9/d4/trackirp_8h.html#a141">IovpIsInterestingStack</a>(
03437     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject
03438     )
03439 {
03440     <a class="code" href="../../d3/d5/struct__DEVOBJ__EXTENSION.html">PDEVOBJ_EXTENSION</a>   deviceExtension;
03441     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>      currentDevObj, deviceAttachedTo;
03442     BOOLEAN             stackIsInteresting;
03443     KIRQL               irql;
03444 
03445     <span class="comment">//</span>
03446     <span class="comment">// Walk downward until we find the PDO or an examined device object.</span>
03447     <span class="comment">//</span>
03448     ExAcquireFastLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a>, &amp;irql );
03449 
03450     <span class="comment">//</span>
03451     <span class="comment">// Quickly check the top of the stack...</span>
03452     <span class="comment">//</span>
03453     <span class="keywordflow">if</span> (DeviceObject-&gt;DeviceObjectExtension-&gt;ExtensionFlags &amp; <a class="code" href="../../d9/d4/trackirp_8h.html#a44">DOE_EXAMINED</a>) {
03454 
03455         stackIsInteresting =
03456            ((DeviceObject-&gt;DeviceObjectExtension-&gt;ExtensionFlags &amp; <a class="code" href="../../d9/d4/trackirp_8h.html#a45">DOE_TRACKED</a>) != 0);
03457 
03458         ExReleaseFastLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a>, irql );
03459         <span class="keywordflow">return</span> stackIsInteresting;
03460     }
03461 
03462     <span class="comment">//</span>
03463     <span class="comment">// OK, if the top hasn't been examined, odds are devices below it haven't</span>
03464     <span class="comment">// either. Walk downwards until we can determine whether the stack as a</span>
03465     <span class="comment">// whole should be tracked.</span>
03466     <span class="comment">//</span>
03467     stackIsInteresting = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03468     deviceAttachedTo = DeviceObject;
03469     <span class="keywordflow">do</span> {
03470         currentDevObj = deviceAttachedTo;
03471         deviceExtension = currentDevObj-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o25">DeviceObjectExtension</a>;
03472         deviceAttachedTo = deviceExtension-&gt;<a class="code" href="../../d3/d5/struct__DEVOBJ__EXTENSION.html#o7">AttachedTo</a>;
03473 
03474         <span class="comment">//</span>
03475         <span class="comment">// Remember this...</span>
03476         <span class="comment">//</span>
03477         <span class="keywordflow">if</span> (<a class="code" href="../../d9/d4/trackirp_8h.html#a142">IovpIsInterestingDriver</a>(currentDevObj-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o3">DriverObject</a>)) {
03478 
03479             stackIsInteresting = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03480         }
03481 
03482     } <span class="keywordflow">while</span> (deviceAttachedTo &amp;&amp;
03483              (deviceAttachedTo-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o25">DeviceObjectExtension</a>-&gt;<a class="code" href="../../d3/d5/struct__DEVOBJ__EXTENSION.html#o5">ExtensionFlags</a> &amp; <a class="code" href="../../d9/d4/trackirp_8h.html#a44">DOE_EXAMINED</a>)
03484             );
03485 
03486     <span class="keywordflow">if</span> (deviceAttachedTo &amp;&amp;
03487         (deviceAttachedTo-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o25">DeviceObjectExtension</a>-&gt;<a class="code" href="../../d3/d5/struct__DEVOBJ__EXTENSION.html#o5">ExtensionFlags</a> &amp; <a class="code" href="../../d9/d4/trackirp_8h.html#a45">DOE_TRACKED</a>)) {
03488 
03489         <span class="comment">//</span>
03490         <span class="comment">// Propogate upwards the "interesting-ness" of the last examined device</span>
03491         <span class="comment">// in the stack...</span>
03492         <span class="comment">//</span>
03493         stackIsInteresting = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03494     }
03495 
03496     <span class="comment">//</span>
03497     <span class="comment">// Walk upwards, marking everything examined and appropriately tracked.</span>
03498     <span class="comment">//</span>
03499     <span class="keywordflow">do</span> {
03500         deviceExtension = currentDevObj-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o25">DeviceObjectExtension</a>;
03501 
03502         <span class="keywordflow">if</span> (stackIsInteresting) {
03503 
03504             deviceExtension-&gt;<a class="code" href="../../d3/d5/struct__DEVOBJ__EXTENSION.html#o5">ExtensionFlags</a> |= <a class="code" href="../../d9/d4/trackirp_8h.html#a45">DOE_TRACKED</a>;
03505         } <span class="keywordflow">else</span> {
03506 
03507             deviceExtension-&gt;<a class="code" href="../../d3/d5/struct__DEVOBJ__EXTENSION.html#o5">ExtensionFlags</a> &amp;=~ DOE_TRACKED;
03508         }
03509 
03510         deviceExtension-&gt;<a class="code" href="../../d3/d5/struct__DEVOBJ__EXTENSION.html#o5">ExtensionFlags</a> |= <a class="code" href="../../d9/d4/trackirp_8h.html#a44">DOE_EXAMINED</a>;
03511 
03512         currentDevObj = currentDevObj-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o5">AttachedDevice</a>;
03513 
03514     } <span class="keywordflow">while</span> (currentDevObj);
03515 
03516     ExReleaseFastLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a>, irql );
03517     <span class="keywordflow">return</span> stackIsInteresting;
03518 }
03519 
03520 BOOLEAN
<a name="l03521"></a><a class="code" href="../../d9/d4/trackirp_8h.html#a142">03521</a> <a class="code" href="../../d9/d4/trackirp_8h.html#a142">IovpIsInterestingDriver</a>(
03522     IN <a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html">PDRIVER_OBJECT</a> DriverObject
03523     )
03524 {
03525     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d4/trackirp_8c.html#a10">IovpInitFlags</a>&amp;<a class="code" href="../../d0/d5/io_8h.html#a264">IOVERIFIERINIT_VERIFIER_DRIVER_LIST</a>) {
03526 
03527         <span class="keywordflow">return</span> (BOOLEAN) <a class="code" href="../../d9/d5/verifier_8c.html#a112">MmIsDriverVerifying</a>(DriverObject);
03528 
03529     } <span class="keywordflow">else</span> {
03530 
03531         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03532     }
03533 }
03534 
03535 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
03536 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l03537"></a><a class="code" href="../../d9/d4/trackirp_8h.html#a123">03537</a> <a class="code" href="../../d9/d4/trackirp_8h.html#a123">IovpExamineDevObjForwarding</a>(
03538     IN     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceBeingCalled,
03539     IN     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceLastCalled,
03540     OUT    PULONG         ForwardTechnique
03541     )
03542 <span class="comment">/*++</span>
03543 <span class="comment"></span>
03544 <span class="comment">    Returns:</span>
03545 <span class="comment"></span>
03546 <span class="comment">        STARTED_TOP_OF_STACK</span>
03547 <span class="comment">        FORWARDED_TO_NEXT_DO</span>
03548 <span class="comment">        SKIPPED_A_DO</span>
03549 <span class="comment">        STARTED_INSIDE_STACK</span>
03550 <span class="comment">        CHANGED_STACKS_AT_BOTTOM</span>
03551 <span class="comment">        CHANGED_STACKS_MID_STACK</span>
03552 <span class="comment"></span>
03553 <span class="comment">--*/</span>
03554 
03555 {
03556     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> upperDevobj, lowerObject ;
03557     ULONG result ;
03558     KIRQL irql;
03559 
03560     lowerObject = <a class="code" href="../../d9/d4/trackirp_8h.html#a125">IovpGetDeviceAttachedTo</a>(DeviceLastCalled) ;
03561 
03562     ExAcquireFastLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a>, &amp;irql );
03563 
03564     <span class="comment">//</span>
03565     <span class="comment">// Nice and simple. Walk the device being called</span>
03566     <span class="comment">// upwards and find either NULL or the last device</span>
03567     <span class="comment">// we called.</span>
03568     <span class="comment">//</span>
03569     upperDevobj = DeviceBeingCalled-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o5">AttachedDevice</a> ;
03570     <span class="keywordflow">while</span>(upperDevobj &amp;&amp; (upperDevobj != DeviceLastCalled)) {
03571 
03572         upperDevobj = upperDevobj-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o5">AttachedDevice</a> ;
03573     }
03574 
03575     <span class="keywordflow">if</span> (DeviceLastCalled == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03576 
03577         <span class="comment">//</span>
03578         <span class="comment">// This is a newly started IRP, was it targetted</span>
03579         <span class="comment">// at the top of a stack or at the middle/bottom?</span>
03580         <span class="comment">//</span>
03581         result = (DeviceBeingCalled-&gt;AttachedDevice) ? <a class="code" href="../../d9/d4/trackirp_8h.html#a65">STARTED_INSIDE_STACK</a> :
03582                                                        <a class="code" href="../../d9/d4/trackirp_8h.html#a62">STARTED_TOP_OF_STACK</a> ;
03583 
03584     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (upperDevobj == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03585 
03586         <span class="comment">//</span>
03587         <span class="comment">// We were forwarded the Irp beyond our own stack</span>
03588         <span class="comment">//</span>
03589         result = (lowerObject) ? <a class="code" href="../../d9/d4/trackirp_8h.html#a67">CHANGED_STACKS_MID_STACK</a> :
03590                                  <a class="code" href="../../d9/d4/trackirp_8h.html#a66">CHANGED_STACKS_AT_BOTTOM</a> ;
03591 
03592     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (DeviceBeingCalled-&gt;AttachedDevice == upperDevobj) {
03593 
03594         result = <a class="code" href="../../d9/d4/trackirp_8h.html#a63">FORWARDED_TO_NEXT_DO</a> ;
03595 
03596         <span class="comment">//</span>
03597         <span class="comment">// Quick assertion, if LastDevice was non-NULL, the</span>
03598         <span class="comment">// device under him should be the one we are calling...</span>
03599         <span class="comment">//</span>
03600         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(lowerObject == DeviceBeingCalled) ;
03601 
03602     } <span class="keywordflow">else</span> {
03603 
03604         <span class="comment">//</span>
03605         <span class="comment">// DeviceLastCalled was found higher in the stack, but wasn't</span>
03606         <span class="comment">// directly above DeviceBeingCalled</span>
03607         <span class="comment">//</span>
03608         result = <a class="code" href="../../d9/d4/trackirp_8h.html#a64">SKIPPED_A_DO</a> ;
03609     }
03610 
03611     ExReleaseFastLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a>, irql );
03612     <span class="keywordflow">if</span> (lowerObject) {
03613         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>(lowerObject) ;
03614     }
03615     *ForwardTechnique = result ;
03616 }
03617 
03618 <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>
03619 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l03620"></a><a class="code" href="../../d9/d4/trackirp_8h.html#a125">03620</a> <a class="code" href="../../d9/d4/trackirp_8h.html#a125">IovpGetDeviceAttachedTo</a>(
03621     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject
03622     )
03623 {
03624     <a class="code" href="../../d3/d5/struct__DEVOBJ__EXTENSION.html">PDEVOBJ_EXTENSION</a> deviceExtension;
03625     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> deviceAttachedTo ;
03626     KIRQL irql ;
03627 
03628     <span class="keywordflow">if</span> (DeviceObject == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03629 
03630         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ;
03631     }
03632 
03633     ExAcquireFastLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a>, &amp;irql );
03634 
03635     deviceExtension = DeviceObject-&gt;DeviceObjectExtension;
03636     deviceAttachedTo = deviceExtension-&gt;<a class="code" href="../../d3/d5/struct__DEVOBJ__EXTENSION.html#o7">AttachedTo</a> ;
03637 
03638     <span class="keywordflow">if</span> (deviceAttachedTo) {
03639         <a class="code" href="../../d4/d0/ob_8h.html#a15">ObReferenceObject</a>(deviceAttachedTo) ;
03640     }
03641 
03642     ExReleaseFastLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a>, irql );
03643     <span class="keywordflow">return</span> deviceAttachedTo ;
03644 }
03645 
03646 <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>
03647 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l03648"></a><a class="code" href="../../d9/d4/trackirp_8h.html#a128">03648</a> <a class="code" href="../../d9/d4/trackirp_8h.html#a128">IovpGetLowestDevice</a>(
03649     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject
03650     )
03651 <span class="comment">/*++</span>
03652 <span class="comment"></span>
03653 <span class="comment">    Opposite of IoGetAttachedDeviceReference</span>
03654 <span class="comment"></span>
03655 <span class="comment">--*/</span>
03656 {
03657     <a class="code" href="../../d3/d5/struct__DEVOBJ__EXTENSION.html">PDEVOBJ_EXTENSION</a> deviceExtension;
03658     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> lowerDevobj, deviceAttachedTo ;
03659     KIRQL irql ;
03660 
03661     deviceAttachedTo = DeviceObject ;
03662 
03663     ExAcquireFastLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a>, &amp;irql );
03664 
03665     <span class="keywordflow">do</span> {
03666         lowerDevobj = deviceAttachedTo ;
03667         deviceExtension = lowerDevobj-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o25">DeviceObjectExtension</a>;
03668         deviceAttachedTo = deviceExtension-&gt;<a class="code" href="../../d3/d5/struct__DEVOBJ__EXTENSION.html#o7">AttachedTo</a> ;
03669 
03670     } <span class="keywordflow">while</span> ( deviceAttachedTo );
03671 
03672     <a class="code" href="../../d4/d0/ob_8h.html#a15">ObReferenceObject</a>(lowerDevobj) ;
03673 
03674     ExReleaseFastLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a>, irql );
03675     <span class="keywordflow">return</span> lowerDevobj ;
03676 }
03677 
03678 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
03679 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l03680"></a><a class="code" href="../../d9/d4/trackirp_8h.html#a129">03680</a> <a class="code" href="../../d9/d4/trackirp_8h.html#a129">IovpAssertNonLegacyDevice</a>(
03681     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject,
03682     IN ULONG StackFramesToSkip,
03683     IN PUCHAR FailureTxt
03684     )
03685 <span class="comment">/*++</span>
03686 <span class="comment"></span>
03687 <span class="comment">--*/</span>
03688 {
03689     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> pdoDeviceObject ;
03690     <a class="code" href="../../d4/d4/struct__DEVICE__NODE.html">PDEVICE_NODE</a> pDevNode ;
03691 
03692     pdoDeviceObject = <a class="code" href="../../d9/d4/trackirp_8h.html#a128">IovpGetLowestDevice</a>(DeviceObject) ;
03693 
03694     <span class="keywordflow">if</span> (pdoDeviceObject) {
03695 
03696         pDevNode = pdoDeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o25">DeviceObjectExtension</a>-&gt;<a class="code" href="../../d3/d5/struct__DEVOBJ__EXTENSION.html#o6">DeviceNode</a> ;
03697         <span class="keywordflow">if</span> (pDevNode&amp;&amp;(!(pDevNode-&gt;<a class="code" href="../../d4/d4/struct__DEVICE__NODE.html#o6">Flags</a>&amp;<a class="code" href="../../d9/d0/pnpiop_8h.html#a24">DNF_LEGACY_DRIVER</a>))) {
03698 
03699             <span class="comment">//</span>
03700             <span class="comment">// ADRIAO BUGBUG 12/30/98 - More stuff to fix...</span>
03701             <span class="comment">//</span>
03702             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(0);
03703 <span class="comment">/*</span>
03704 <span class="comment">            WDM_FAIL_CALLER(</span>
03705 <span class="comment">                (FailureTxt),</span>
03706 <span class="comment">                StackFramesToSkip+1,</span>
03707 <span class="comment">                NULL</span>
03708 <span class="comment">                );</span>
03709 <span class="comment">*/</span>
03710         }
03711         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>(pdoDeviceObject) ;
03712     }
03713 }
03714 
03715 BOOLEAN
03716 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l03717"></a><a class="code" href="../../d9/d4/trackirp_8h.html#a130">03717</a> <a class="code" href="../../d9/d4/trackirp_8h.html#a130">IovpIsInFdoStack</a>(
03718     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject
03719     )
03720 {
03721     <a class="code" href="../../d3/d5/struct__DEVOBJ__EXTENSION.html">PDEVOBJ_EXTENSION</a> deviceExtension;
03722     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> deviceAttachedTo, lowerDevobj ;
03723     KIRQL irql ;
03724 
03725     deviceAttachedTo = DeviceObject ;
03726 
03727     ExAcquireFastLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a>, &amp;irql );
03728 
03729     <span class="keywordflow">do</span> {
03730         <span class="keywordflow">if</span> (deviceAttachedTo-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o25">DeviceObjectExtension</a>-&gt;<a class="code" href="../../d3/d5/struct__DEVOBJ__EXTENSION.html#o5">ExtensionFlags</a>&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a42">DOE_BOTTOM_OF_FDO_STACK</a>) {
03731             <span class="keywordflow">break</span>;
03732         }
03733         deviceAttachedTo = deviceAttachedTo-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o25">DeviceObjectExtension</a>-&gt;<a class="code" href="../../d3/d5/struct__DEVOBJ__EXTENSION.html#o7">AttachedTo</a> ;
03734 
03735     } <span class="keywordflow">while</span> ( deviceAttachedTo );
03736 
03737     ExReleaseFastLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a>, irql );
03738     <span class="keywordflow">return</span> (deviceAttachedTo != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) ;
03739 }
03740 
03741 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
03742 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l03743"></a><a class="code" href="../../d9/d4/trackirp_8h.html#a133">03743</a> <a class="code" href="../../d9/d4/trackirp_8h.html#a133">IovpSeedOnePage</a>(
03744     VOID
03745     )
03746 {
03747     ULONG StackSeed[(<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>/<span class="keyword">sizeof</span>(ULONG))] ;
03748     ULONG <span class="keyword">register</span> i ;
03749 
03750     <span class="comment">//</span>
03751     <span class="comment">// We use the return value 0xFFFFFFFF, as it is an illegal return value. We</span>
03752     <span class="comment">// are trying to catch people who don't initialize NTSTATUS, and it's also</span>
03753     <span class="comment">// a good pointer trap too.</span>
03754     <span class="comment">//</span>
03755     <span class="keywordflow">for</span>(i=0; i&lt;(<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>/<span class="keyword">sizeof</span>(ULONG)); i++) StackSeed[i]=0xFFFFFFFF ;
03756 }
03757 
03758 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
03759 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l03760"></a><a class="code" href="../../d9/d4/trackirp_8h.html#a134">03760</a> <a class="code" href="../../d9/d4/trackirp_8h.html#a134">IovpSeedTwoPages</a>(
03761     VOID
03762     )
03763 {
03764     ULONG StackSeed[(<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>*2/<span class="keyword">sizeof</span>(ULONG))] ;
03765     ULONG <span class="keyword">register</span> i ;
03766 
03767     <span class="keywordflow">for</span>(i=0; i&lt;(<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>*2/<span class="keyword">sizeof</span>(ULONG)); i++) StackSeed[i]=0xFFFFFFFF ;
03768 }
03769 
03770 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
03771 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l03772"></a><a class="code" href="../../d9/d4/trackirp_8h.html#a135">03772</a> <a class="code" href="../../d9/d4/trackirp_8h.html#a135">IovpSeedThreePages</a>(
03773     VOID
03774     )
03775 {
03776     ULONG <span class="keyword">register</span> i ;
03777     ULONG StackSeed[(<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>*3/<span class="keyword">sizeof</span>(ULONG))] ;
03778 
03779     <span class="keywordflow">for</span>(i=0; i&lt;(<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>*3/<span class="keyword">sizeof</span>(ULONG)); i++) StackSeed[i]=0xFFFFFFFF ;
03780 }
03781 
03782 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
03783 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l03784"></a><a class="code" href="../../d9/d4/trackirp_8h.html#a132">03784</a> <a class="code" href="../../d9/d4/trackirp_8h.html#a132">IovpSeedStack</a>(
03785     VOID
03786     )
03787 <span class="comment">/*++</span>
03788 <span class="comment"></span>
03789 <span class="comment">  Description:</span>
03790 <span class="comment"></span>
03791 <span class="comment">    This routine "seeds" the stack so that uninitialized variables are</span>
03792 <span class="comment">    more easily ferreted out.</span>
03793 <span class="comment"></span>
03794 <span class="comment">    ADRIAO BUGBUG 08/17/98 - This is a really neat idea that runs into a</span>
03795 <span class="comment">                             memory manager optimization. While I do find</span>
03796 <span class="comment">                             the appropriate guard page, the memory manager</span>
03797 <span class="comment">                             throws out the above touched pages on a thread</span>
03798 <span class="comment">                             switch and bring in new (and probably zero'd)</span>
03799 <span class="comment">                             ones.</span>
03800 <span class="comment"></span>
03801 <span class="comment">  Arguments: None</span>
03802 <span class="comment"></span>
03803 <span class="comment">  Return Value: None</span>
03804 <span class="comment"></span>
03805 <span class="comment">--*/</span>
03806 {
03807     <span class="keywordtype">int</span> i, interruptReservedOverhead ;
03808 
03809     <span class="keywordflow">if</span> (!(<a class="code" href="../../d8/d4/trackirp_8c.html#a7">IovpTrackingFlags</a>&amp;<a class="code" href="../../d9/d4/trackirp_8h.html#a13">ASSERTFLAG_SEEDSTACK</a>)) {
03810         <span class="keywordflow">return</span> ;
03811     }
03812 
03813     <span class="comment">//</span>
03814     <span class="comment">// Is there room to try this before we run out of stack? We will reserve</span>
03815     <span class="comment">// half a page for interrupt overhead...</span>
03816     <span class="comment">//</span>
03817     interruptReservedOverhead = <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>/2 ;
03818 
03819     <span class="comment">//</span>
03820     <span class="comment">// There must be a guard page somewhere. Find it...</span>
03821     <span class="comment">//</span>
03822     <span class="keywordflow">for</span>(i=0; i&lt;4; i++) {
03823         <span class="keywordflow">if</span> (!<a class="code" href="../../d8/d2/pagfault_8c.html#a26">MmIsAddressValid</a>(((PUCHAR)&amp;i)-i*<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>-interruptReservedOverhead)) {
03824             <span class="keywordflow">break</span>;
03825         }
03826     }
03827 
03828     <span class="keywordflow">switch</span>(i) {
03829         <span class="keywordflow">case</span> 4: <a class="code" href="../../d9/d4/trackirp_8h.html#a135">IovpSeedThreePages</a>() ; <span class="keywordflow">break</span> ;
03830         <span class="keywordflow">case</span> 3: <a class="code" href="../../d9/d4/trackirp_8h.html#a134">IovpSeedTwoPages</a>() ; <span class="keywordflow">break</span> ;
03831         <span class="keywordflow">case</span> 2: <a class="code" href="../../d9/d4/trackirp_8h.html#a133">IovpSeedOnePage</a>() ; <span class="keywordflow">break</span> ;
03832         <span class="keywordflow">case</span> 1: <span class="keywordflow">break</span> ; <span class="comment">// Minimum is overhead</span>
03833         <span class="keywordflow">case</span> 0: <span class="keywordflow">break</span> ; <span class="comment">// Umm, we don't even have overhead!</span>
03834         <span class="keywordflow">default</span>: <span class="keywordflow">break</span> ;
03835     }
03836 }
03837 
03838 <span class="preprocessor">#endif // NO_SPECIAL_IRP</span>
03839 <span class="preprocessor"></span>
03840 
03841 
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:42:02 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
