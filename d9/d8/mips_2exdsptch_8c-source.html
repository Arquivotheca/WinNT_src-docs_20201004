<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: exdsptch.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>exdsptch.c</h1><a href="../../d8/d9/mips_2exdsptch_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1990  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    exdsptch.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module implements the dispatching of exception and the unwinding of</span>
00012 <span class="comment">    procedure call frames.</span>
00013 <span class="comment"></span>
00014 <span class="comment">Author:</span>
00015 <span class="comment"></span>
00016 <span class="comment">    David N. Cutler (davec) 11-Sep-1990</span>
00017 <span class="comment"></span>
00018 <span class="comment">Environment:</span>
00019 <span class="comment"></span>
00020 <span class="comment">    Any mode.</span>
00021 <span class="comment"></span>
00022 <span class="comment">Revision History:</span>
00023 <span class="comment"></span>
00024 <span class="comment">--*/</span>
00025 
00026 <span class="preprocessor">#include "<a class="code" href="../../d5/d9/ntrtlp_8h.html">ntrtlp.h</a>"</span>
00027 
00028 <span class="comment">//</span>
00029 <span class="comment">// Define local macros.</span>
00030 <span class="comment">//</span>
00031 <span class="comment">// Raise noncontinuable exception with associated exception record.</span>
00032 <span class="comment">//</span>
00033 
<a name="l00034"></a><a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a0">00034</a> <span class="preprocessor">#define RAISE_EXCEPTION(Status, ExceptionRecordt) { \</span>
00035 <span class="preprocessor">    EXCEPTION_RECORD ExceptionRecordn; \</span>
00036 <span class="preprocessor">                                            \</span>
00037 <span class="preprocessor">    ExceptionRecordn.ExceptionCode = Status; \</span>
00038 <span class="preprocessor">    ExceptionRecordn.ExceptionFlags = EXCEPTION_NONCONTINUABLE; \</span>
00039 <span class="preprocessor">    ExceptionRecordn.ExceptionRecord = ExceptionRecordt; \</span>
00040 <span class="preprocessor">    ExceptionRecordn.NumberParameters = 0; \</span>
00041 <span class="preprocessor">    RtlRaiseException(&amp;ExceptionRecordn); \</span>
00042 <span class="preprocessor">    }</span>
00043 <span class="preprocessor"></span>
00044 <span class="comment">//</span>
00045 <span class="comment">// Define stack register and zero register numbers.</span>
00046 <span class="comment">//</span>
00047 
<a name="l00048"></a><a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a1">00048</a> <span class="preprocessor">#define RA 0x1f                         // integer register 31</span>
<a name="l00049"></a><a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">00049</a> <span class="preprocessor"></span><span class="preprocessor">#define SP 0x1d                         // integer register 29</span>
<a name="l00050"></a><a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a3">00050</a> <span class="preprocessor"></span><span class="preprocessor">#define ZERO 0x0                        // integer register 0</span>
00051 <span class="preprocessor"></span>
00052 <span class="comment">//</span>
00053 <span class="comment">// Define saved register masks.</span>
00054 <span class="comment">//</span>
00055 
<a name="l00056"></a><a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a4">00056</a> <span class="preprocessor">#define SAVED_FLOATING_MASK 0xfff00000  // saved floating registers</span>
<a name="l00057"></a><a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a5">00057</a> <span class="preprocessor"></span><span class="preprocessor">#define SAVED_INTEGER_MASK 0xf3ffff02   // saved integer registers</span>
00058 <span class="preprocessor"></span>
00059 <span class="comment">//</span>
00060 <span class="comment">// Define private function prototypes.</span>
00061 <span class="comment">//</span>
00062 
00063 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00064 <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a3">RtlpRestoreContext</a> (
00065     IN PCONTEXT Context,
00066     IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL
00067     );
00068 
00069 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00070 <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a4">RtlpRaiseException</a> (
00071     IN PEXCEPTION_RECORD ExceptionRecord
00072     );
00073 
00074 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00075 <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a5">RtlpRaiseStatus</a> (
00076     IN NTSTATUS Status
00077     );
00078 
00079 ULONG
00080 <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a6">RtlpVirtualUnwind</a> (
00081     IN ULONG ControlPc,
00082     IN PRUNTIME_FUNCTION FunctionEntry,
00083     IN PCONTEXT ContextRecord,
00084     OUT PBOOLEAN InFunction,
00085     OUT PULONG EstablisherFrame,
00086     IN OUT PKNONVOLATILE_CONTEXT_POINTERS ContextPointers OPTIONAL
00087     );
00088 
00089 ULONG
00090 <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a10">RtlpVirtualUnwind32</a> (
00091     IN ULONG ControlPc,
00092     IN PRUNTIME_FUNCTION FunctionEntry,
00093     IN OUT PCONTEXT ContextRecord,
00094     OUT PBOOLEAN InFunction,
00095     OUT PULONG EstablisherFrame,
00096     IN OUT PKNONVOLATILE_CONTEXT_POINTERS ContextPointers OPTIONAL
00097     );
00098 
00099 
00100 BOOLEAN
<a name="l00101"></a><a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a11">00101</a> <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a7">RtlDispatchException</a> (
00102     IN PEXCEPTION_RECORD ExceptionRecord,
00103     IN PCONTEXT ContextRecord
00104     )
00105 
00106 <span class="comment">/*++</span>
00107 <span class="comment"></span>
00108 <span class="comment">Routine Description:</span>
00109 <span class="comment"></span>
00110 <span class="comment">    This function attempts to dispatch an exception to a frame based</span>
00111 <span class="comment">    handler by searching backwards through the stack based call frames.</span>
00112 <span class="comment">    The search begins with the frame specified in the context record and</span>
00113 <span class="comment">    continues backward until either a handler is found that handles the</span>
00114 <span class="comment">    exception, the stack is found to be invalid (i.e., out of limits or</span>
00115 <span class="comment">    unaligned), or the end of the call hierarchy is reached.</span>
00116 <span class="comment"></span>
00117 <span class="comment">    As each frame is encounter, the PC where control left the corresponding</span>
00118 <span class="comment">    function is determined and used to lookup exception handler information</span>
00119 <span class="comment">    in the runtime function table built by the linker. If the respective</span>
00120 <span class="comment">    routine has an exception handler, then the handler is called. If the</span>
00121 <span class="comment">    handler does not handle the exception, then the prologue of the routine</span>
00122 <span class="comment">    is executed backwards to "unwind" the effect of the prologue and then</span>
00123 <span class="comment">    the next frame is examined.</span>
00124 <span class="comment"></span>
00125 <span class="comment">Arguments:</span>
00126 <span class="comment"></span>
00127 <span class="comment">    ExceptionRecord - Supplies a pointer to an exception record.</span>
00128 <span class="comment"></span>
00129 <span class="comment">    ContextRecord - Supplies a pointer to a context record.</span>
00130 <span class="comment"></span>
00131 <span class="comment">Return Value:</span>
00132 <span class="comment"></span>
00133 <span class="comment">    If the exception is handled by one of the frame based handlers, then</span>
00134 <span class="comment">    a value of TRUE is returned. Otherwise a value of FALSE is returned.</span>
00135 <span class="comment"></span>
00136 <span class="comment">--*/</span>
00137 
00138 {
00139 
00140     CONTEXT ContextRecord1;
00141     ULONG ControlPc;
00142     <a class="code" href="../../d0/d6/struct__DISPATCHER__CONTEXT.html">DISPATCHER_CONTEXT</a> DispatcherContext;
00143     EXCEPTION_DISPOSITION Disposition;
00144     ULONG EstablisherFrame;
00145     ULONG ExceptionFlags;
00146     PRUNTIME_FUNCTION FunctionEntry;
00147     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
00148     BOOLEAN InFunction;
00149     ULONG HighLimit;
00150     ULONG LowLimit;
00151     ULONG NestedFrame;
00152     ULONG NextPc;
00153 
00154     <span class="comment">//</span>
00155     <span class="comment">// Get current stack limits, copy the context record, get the initial</span>
00156     <span class="comment">// PC value, capture the exception flags, and set the nested exception</span>
00157     <span class="comment">// frame pointer.</span>
00158     <span class="comment">//</span>
00159 
00160     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a30">RtlpGetStackLimits</a>(&amp;LowLimit, &amp;HighLimit);
00161     RtlMoveMemory(&amp;ContextRecord1, ContextRecord, <span class="keyword">sizeof</span>(CONTEXT));
00162     ControlPc = ContextRecord1.Fir;
00163     ExceptionFlags = ExceptionRecord-&gt;ExceptionFlags &amp; <a class="code" href="../../d6/d7/halmips_8h.html#a25">EXCEPTION_NONCONTINUABLE</a>;
00164     NestedFrame = 0;
00165 
00166     <span class="comment">//</span>
00167     <span class="comment">// Start with the frame specified by the context record and search</span>
00168     <span class="comment">// backwards through the call frame hierarchy attempting to find an</span>
00169     <span class="comment">// exception handler that will handle the exception.</span>
00170     <span class="comment">//</span>
00171 
00172     <span class="keywordflow">do</span> {
00173 
00174         <span class="comment">//</span>
00175         <span class="comment">// Lookup the function table entry using the point at which control</span>
00176         <span class="comment">// left the procedure.</span>
00177         <span class="comment">//</span>
00178 
00179         FunctionEntry = <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a8">RtlLookupFunctionEntry</a>(ControlPc);
00180 
00181         <span class="comment">//</span>
00182         <span class="comment">// If there is a function table entry for the routine, then virtually</span>
00183         <span class="comment">// unwind to the caller of the current routine to obtain the virtual</span>
00184         <span class="comment">// frame pointer of the establisher and check if there is an exception</span>
00185         <span class="comment">// handler for the frame.</span>
00186         <span class="comment">//</span>
00187 
00188         <span class="keywordflow">if</span> (FunctionEntry != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00189             NextPc = <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a38">RtlVirtualUnwind</a>(ControlPc | 1,
00190                                       FunctionEntry,
00191                                       &amp;ContextRecord1,
00192                                       &amp;InFunction,
00193                                       &amp;EstablisherFrame,
00194                                       <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00195 
00196             <span class="comment">//</span>
00197             <span class="comment">// If the virtual frame pointer is not within the specified stack</span>
00198             <span class="comment">// limits or the virtual frame pointer is unaligned, then set the</span>
00199             <span class="comment">// stack invalid flag in the exception record and return exception</span>
00200             <span class="comment">// not handled. Otherwise, check if the current routine has an</span>
00201             <span class="comment">// exception handler.</span>
00202             <span class="comment">//</span>
00203 
00204             <span class="keywordflow">if</span> ((EstablisherFrame &lt; LowLimit) || (EstablisherFrame &gt; HighLimit) ||
00205                ((EstablisherFrame &amp; 0x7) != 0)) {
00206                 ExceptionFlags |= <a class="code" href="../../d6/d7/halmips_8h.html#a28">EXCEPTION_STACK_INVALID</a>;
00207                 <span class="keywordflow">break</span>;
00208 
00209             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((FunctionEntry-&gt;ExceptionHandler != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp; InFunction) {
00210 
00211                 <span class="comment">//</span>
00212                 <span class="comment">// The frame has an exception handler. The handler must be</span>
00213                 <span class="comment">// executed by calling another routine that is written in</span>
00214                 <span class="comment">// assembler. This is required because up level addressing</span>
00215                 <span class="comment">// of the handler information is required when a nested</span>
00216                 <span class="comment">// exception is encountered.</span>
00217                 <span class="comment">//</span>
00218 
00219                 DispatcherContext.ControlPc = ControlPc;
00220                 DispatcherContext.FunctionEntry = FunctionEntry;
00221                 DispatcherContext.EstablisherFrame = EstablisherFrame;
00222                 DispatcherContext.ContextRecord = ContextRecord;
00223                 ExceptionRecord-&gt;ExceptionFlags = ExceptionFlags;
00224 
00225                 <span class="comment">//</span>
00226                 <span class="comment">// If requested log exception.</span>
00227                 <span class="comment">//</span>
00228 
00229                 <span class="keywordflow">if</span> (<a class="code" href="../../d9/d2/ldrp_8h.html#a33">NtGlobalFlag</a> &amp; FLG_ENABLE_EXCEPTION_LOGGING) {
00230                     <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = <a class="code" href="../../d5/d9/ntrtlp_8h.html#a48">RtlpLogExceptionHandler</a>(ExceptionRecord,
00231                                                     ContextRecord,
00232                                                     ControlPc,
00233                                                     FunctionEntry,
00234                                                     <span class="keyword">sizeof</span>(RUNTIME_FUNCTION));
00235                 }
00236 
00237                 Disposition =
00238                     <a class="code" href="../../d6/d9/ntrtlppc_8h.html#a0">RtlpExecuteHandlerForException</a>(ExceptionRecord,
00239                                                    EstablisherFrame,
00240                                                    ContextRecord,
00241                                                    &amp;DispatcherContext,
00242                                                    FunctionEntry-&gt;ExceptionHandler);
00243 
00244                 <span class="keywordflow">if</span> (<a class="code" href="../../d9/d2/ldrp_8h.html#a33">NtGlobalFlag</a> &amp; FLG_ENABLE_EXCEPTION_LOGGING) {
00245                     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a49">RtlpLogLastExceptionDisposition</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>, Disposition);
00246                 }
00247 
00248                 ExceptionFlags |=
00249                     (ExceptionRecord-&gt;ExceptionFlags &amp; <a class="code" href="../../d6/d7/halmips_8h.html#a25">EXCEPTION_NONCONTINUABLE</a>);
00250 
00251                 <span class="comment">//</span>
00252                 <span class="comment">// If the current scan is within a nested context and the frame</span>
00253                 <span class="comment">// just examined is the end of the nested region, then clear</span>
00254                 <span class="comment">// the nested context frame and the nested exception flag in</span>
00255                 <span class="comment">// the exception flags.</span>
00256                 <span class="comment">//</span>
00257 
00258                 <span class="keywordflow">if</span> (NestedFrame == EstablisherFrame) {
00259                     ExceptionFlags &amp;= (~<a class="code" href="../../d6/d7/halmips_8h.html#a29">EXCEPTION_NESTED_CALL</a>);
00260                     NestedFrame = 0;
00261                 }
00262 
00263                 <span class="comment">//</span>
00264                 <span class="comment">// Case on the handler disposition.</span>
00265                 <span class="comment">//</span>
00266 
00267                 <span class="keywordflow">switch</span> (Disposition) {
00268 
00269                     <span class="comment">//</span>
00270                     <span class="comment">// The disposition is to continue execution.</span>
00271                     <span class="comment">//</span>
00272                     <span class="comment">// If the exception is not continuable, then raise the</span>
00273                     <span class="comment">// exception STATUS_NONCONTINUABLE_EXCEPTION. Otherwise</span>
00274                     <span class="comment">// return exception handled.</span>
00275                     <span class="comment">//</span>
00276 
00277                 <span class="keywordflow">case</span> <a class="code" href="../../d6/d7/halmips_8h.html#a36">ExceptionContinueExecution</a> :
00278                     <span class="keywordflow">if</span> ((ExceptionFlags &amp; <a class="code" href="../../d6/d7/halmips_8h.html#a25">EXCEPTION_NONCONTINUABLE</a>) != 0) {
00279                         <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a0">RAISE_EXCEPTION</a>(STATUS_NONCONTINUABLE_EXCEPTION, ExceptionRecord);
00280 
00281                     } <span class="keywordflow">else</span> {
00282                         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00283                     }
00284 
00285                     <span class="comment">//</span>
00286                     <span class="comment">// The disposition is to continue the search.</span>
00287                     <span class="comment">//</span>
00288                     <span class="comment">// Get next frame address and continue the search.</span>
00289                     <span class="comment">//</span>
00290 
00291                 <span class="keywordflow">case</span> <a class="code" href="../../d6/d7/halmips_8h.html#a37">ExceptionContinueSearch</a> :
00292                     <span class="keywordflow">break</span>;
00293 
00294                     <span class="comment">//</span>
00295                     <span class="comment">// The disposition is nested exception.</span>
00296                     <span class="comment">//</span>
00297                     <span class="comment">// Set the nested context frame to the establisher frame</span>
00298                     <span class="comment">// address and set the nested exception flag in the</span>
00299                     <span class="comment">// exception flags.</span>
00300                     <span class="comment">//</span>
00301 
00302                 <span class="keywordflow">case</span> <a class="code" href="../../d6/d7/halmips_8h.html#a38">ExceptionNestedException</a> :
00303                     ExceptionFlags |= <a class="code" href="../../d6/d7/halmips_8h.html#a29">EXCEPTION_NESTED_CALL</a>;
00304                     <span class="keywordflow">if</span> (DispatcherContext.EstablisherFrame &gt; NestedFrame) {
00305                         NestedFrame = DispatcherContext.EstablisherFrame;
00306                     }
00307 
00308                     <span class="keywordflow">break</span>;
00309 
00310                     <span class="comment">//</span>
00311                     <span class="comment">// All other disposition values are invalid.</span>
00312                     <span class="comment">//</span>
00313                     <span class="comment">// Raise invalid disposition exception.</span>
00314                     <span class="comment">//</span>
00315 
00316                 <span class="keywordflow">default</span> :
00317                     <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a0">RAISE_EXCEPTION</a>(STATUS_INVALID_DISPOSITION, ExceptionRecord);
00318                 }
00319             }
00320 
00321         } <span class="keywordflow">else</span> {
00322 
00323             <span class="comment">//</span>
00324             <span class="comment">// Set point at which control left the previous routine.</span>
00325             <span class="comment">//</span>
00326 
00327             NextPc = (ULONG)(ContextRecord1.XIntRa - 4);
00328 
00329             <span class="comment">//</span>
00330             <span class="comment">// If the next control PC is the same as the old control PC, then</span>
00331             <span class="comment">// the function table is not correctly formed.</span>
00332             <span class="comment">//</span>
00333 
00334             <span class="keywordflow">if</span> (NextPc == ControlPc) {
00335                 <span class="keywordflow">break</span>;
00336             }
00337         }
00338 
00339         <span class="comment">//</span>
00340         <span class="comment">// Set point at which control left the previous routine.</span>
00341         <span class="comment">//</span>
00342 
00343         ControlPc = NextPc;
00344     } <span class="keywordflow">while</span> ((ULONG)ContextRecord1.XIntSp &lt; HighLimit);
00345 
00346     <span class="comment">//</span>
00347     <span class="comment">// Set final exception flags and return exception not handled.</span>
00348     <span class="comment">//</span>
00349 
00350     ExceptionRecord-&gt;ExceptionFlags = ExceptionFlags;
00351     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00352 }
00353 
00354 PRUNTIME_FUNCTION
<a name="l00355"></a><a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a12">00355</a> <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a8">RtlLookupFunctionEntry</a> (
00356     IN ULONG ControlPc
00357     )
00358 
00359 <span class="comment">/*++</span>
00360 <span class="comment"></span>
00361 <span class="comment">Routine Description:</span>
00362 <span class="comment"></span>
00363 <span class="comment">    This function searches the currently active function tables for an entry</span>
00364 <span class="comment">    that corresponds to the specified PC value.</span>
00365 <span class="comment"></span>
00366 <span class="comment">Arguments:</span>
00367 <span class="comment"></span>
00368 <span class="comment">    ControlPc - Supplies the address of an instruction within the specified</span>
00369 <span class="comment">        function.</span>
00370 <span class="comment"></span>
00371 <span class="comment">Return Value:</span>
00372 <span class="comment"></span>
00373 <span class="comment">    If there is no entry in the function table for the specified PC, then</span>
00374 <span class="comment">    NULL is returned. Otherwise, the address of the function table entry</span>
00375 <span class="comment">    that corresponds to the specified PC is returned.</span>
00376 <span class="comment"></span>
00377 <span class="comment">--*/</span>
00378 
00379 {
00380 
00381     PRUNTIME_FUNCTION FunctionEntry;
00382     PRUNTIME_FUNCTION FunctionTable;
00383     ULONG SizeOfExceptionTable;
00384     LONG High;
00385     PVOID ImageBase;
00386     LONG Low;
00387     LONG Middle;
00388     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> i;
00389 
00390     <span class="comment">//</span>
00391     <span class="comment">// Search for the image that includes the specified PC value.</span>
00392     <span class="comment">//</span>
00393 
00394     ImageBase = <a class="code" href="../../d6/d4/pctohdr_8c.html#a1">RtlPcToFileHeader</a>((PVOID)ControlPc, &amp;ImageBase);
00395 
00396     <span class="comment">//</span>
00397     <span class="comment">// If an image is found that includes the specified PC, then locate the</span>
00398     <span class="comment">// function table for the image.</span>
00399     <span class="comment">//</span>
00400 
00401     <span class="keywordflow">if</span> (ImageBase != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00402         FunctionTable = (PRUNTIME_FUNCTION)<a class="code" href="../../d8/d9/imagedir_8c.html#a5">RtlImageDirectoryEntryToData</a>(
00403                          ImageBase, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, IMAGE_DIRECTORY_ENTRY_EXCEPTION,
00404                          &amp;SizeOfExceptionTable);
00405 
00406         <span class="comment">//</span>
00407         <span class="comment">// If a function table is located, then search the function table</span>
00408         <span class="comment">// for a function table entry for the specified PC.</span>
00409         <span class="comment">//</span>
00410 
00411         <span class="keywordflow">if</span> (FunctionTable != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00412 
00413             <span class="comment">//</span>
00414             <span class="comment">// Initialize search indicies.</span>
00415             <span class="comment">//</span>
00416 
00417             Low = 0;
00418             High = (SizeOfExceptionTable / <span class="keyword">sizeof</span>(RUNTIME_FUNCTION)) - 1;
00419 
00420             <span class="comment">//</span>
00421             <span class="comment">// Perform binary search on the function table for a function table</span>
00422             <span class="comment">// entry that subsumes the specified PC.</span>
00423             <span class="comment">//</span>
00424 
00425             <span class="keywordflow">while</span> (High &gt;= Low) {
00426 
00427                 <span class="comment">//</span>
00428                 <span class="comment">// Compute next probe index and test entry. If the specified PC</span>
00429                 <span class="comment">// is greater than of equal to the beginning address and less</span>
00430                 <span class="comment">// than the ending address of the function table entry, then</span>
00431                 <span class="comment">// return the address of the function table entry. Otherwise,</span>
00432                 <span class="comment">// continue the search.</span>
00433                 <span class="comment">//</span>
00434 
00435                 Middle = (Low + High) &gt;&gt; 1;
00436                 FunctionEntry = &amp;FunctionTable[Middle];
00437                 <span class="keywordflow">if</span> (ControlPc &lt; FunctionEntry-&gt;BeginAddress) {
00438                     High = Middle - 1;
00439 
00440                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ControlPc &gt;= FunctionEntry-&gt;EndAddress) {
00441                     Low = Middle + 1;
00442 
00443                 } <span class="keywordflow">else</span> {
00444 
00445                     <span class="comment">//</span>
00446                     <span class="comment">// The capability exists for more than one function entry</span>
00447                     <span class="comment">// to map to the same function. This permits a function to</span>
00448                     <span class="comment">// have discontiguous code segments described by separate</span>
00449                     <span class="comment">// function table entries. If the ending prologue address</span>
00450                     <span class="comment">// is not within the limits of the begining and ending</span>
00451                     <span class="comment">// address of the function able entry, then the prologue</span>
00452                     <span class="comment">// ending address is the address of a function table entry</span>
00453                     <span class="comment">// that accurately describes the ending prologue address.</span>
00454                     <span class="comment">//</span>
00455 
00456                     <span class="keywordflow">if</span> ((FunctionEntry-&gt;PrologEndAddress &lt; FunctionEntry-&gt;BeginAddress) ||
00457                         (FunctionEntry-&gt;PrologEndAddress &gt; FunctionEntry-&gt;EndAddress)) {
00458                         FunctionEntry = (PRUNTIME_FUNCTION)FunctionEntry-&gt;PrologEndAddress;
00459                     }
00460 
00461                     <span class="keywordflow">return</span> FunctionEntry;
00462                 }
00463             }
00464         }
00465     }
00466 
00467     <span class="comment">//</span>
00468     <span class="comment">// A function table entry for the specified PC was not found.</span>
00469     <span class="comment">//</span>
00470 
00471     <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00472 }
00473 
00474 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00475"></a><a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a13">00475</a> <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a9">RtlRaiseException</a> (
00476     IN PEXCEPTION_RECORD ExceptionRecord
00477     )
00478 
00479 <span class="comment">/*++</span>
00480 <span class="comment"></span>
00481 <span class="comment">Routine Description:</span>
00482 <span class="comment"></span>
00483 <span class="comment">    This function raises a software exception by building a context record</span>
00484 <span class="comment">    and calling the raise exception system service.</span>
00485 <span class="comment"></span>
00486 <span class="comment">    N.B. This routine is a shell routine that simply calls another routine</span>
00487 <span class="comment">         to do the real work. The reason this is done is to avoid a problem</span>
00488 <span class="comment">         in try/finally scopes where the last statement in the scope is a</span>
00489 <span class="comment">         call to raise an exception.</span>
00490 <span class="comment"></span>
00491 <span class="comment">Arguments:</span>
00492 <span class="comment"></span>
00493 <span class="comment">    ExceptionRecord - Supplies a pointer to an exception record.</span>
00494 <span class="comment"></span>
00495 <span class="comment">Return Value:</span>
00496 <span class="comment"></span>
00497 <span class="comment">    None.</span>
00498 <span class="comment"></span>
00499 <span class="comment">--*/</span>
00500 
00501 {
00502 
00503     <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a4">RtlpRaiseException</a>(ExceptionRecord);
00504     <span class="keywordflow">return</span>;
00505 }
00506 
00507 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00508 <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a4">RtlpRaiseException</a> (
00509     IN PEXCEPTION_RECORD ExceptionRecord
00510     )
00511 
00512 <span class="comment">/*++</span>
00513 <span class="comment"></span>
00514 <span class="comment">Routine Description:</span>
00515 <span class="comment"></span>
00516 <span class="comment">    This function raises a software exception by building a context record</span>
00517 <span class="comment">    and calling the raise exception system service.</span>
00518 <span class="comment"></span>
00519 <span class="comment">Arguments:</span>
00520 <span class="comment"></span>
00521 <span class="comment">    ExceptionRecord - Supplies a pointer to an exception record.</span>
00522 <span class="comment"></span>
00523 <span class="comment">Return Value:</span>
00524 <span class="comment"></span>
00525 <span class="comment">    None.</span>
00526 <span class="comment"></span>
00527 <span class="comment">--*/</span>
00528 
00529 {
00530 
00531     ULONG ControlPc;
00532     CONTEXT ContextRecord;
00533     ULONG EstablisherFrame;
00534     PRUNTIME_FUNCTION FunctionEntry;
00535     BOOLEAN InFunction;
00536     ULONG NextPc;
00537     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00538 
00539     <span class="comment">//</span>
00540     <span class="comment">// Capture the current context, virtually unwind to the caller of this</span>
00541     <span class="comment">// routine, set the fault instruction address to that of the caller, and</span>
00542     <span class="comment">// call the raise exception system service.</span>
00543     <span class="comment">//</span>
00544 
00545     RtlCaptureContext(&amp;ContextRecord);
00546     ControlPc = (ULONG)(ContextRecord.XIntRa - 4);
00547     FunctionEntry = <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a8">RtlLookupFunctionEntry</a>(ControlPc);
00548     NextPc = <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a38">RtlVirtualUnwind</a>(ControlPc | 1,
00549                               FunctionEntry,
00550                               &amp;ContextRecord,
00551                               &amp;InFunction,
00552                               &amp;EstablisherFrame,
00553                               NULL);
00554 
00555     ContextRecord.Fir = NextPc + 4;
00556     ExceptionRecord-&gt;ExceptionAddress = (PVOID)ContextRecord.Fir;
00557     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwRaiseException(ExceptionRecord, &amp;ContextRecord, TRUE);
00558 
00559     <span class="comment">//</span>
00560     <span class="comment">// There should never be a return from this system service unless</span>
00561     <span class="comment">// there is a problem with the argument list itself. Raise another</span>
00562     <span class="comment">// exception specifying the status value returned.</span>
00563     <span class="comment">//</span>
00564 
00565     <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a10">RtlRaiseStatus</a>(Status);
00566     <span class="keywordflow">return</span>;
00567 }
00568 
00569 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00570"></a><a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a14">00570</a> <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a10">RtlRaiseStatus</a> (
00571     IN NTSTATUS Status
00572     )
00573 
00574 <span class="comment">/*++</span>
00575 <span class="comment"></span>
00576 <span class="comment">Routine Description:</span>
00577 <span class="comment"></span>
00578 <span class="comment">    This function raises an exception with the specified status value. The</span>
00579 <span class="comment">    exception is marked as noncontinuable with no parameters.</span>
00580 <span class="comment"></span>
00581 <span class="comment">    N.B. This routine is a shell routine that simply calls another routine</span>
00582 <span class="comment">         to do the real work. The reason this is done is to avoid a problem</span>
00583 <span class="comment">         in try/finally scopes where the last statement in the scope is a</span>
00584 <span class="comment">         call to raise an exception.</span>
00585 <span class="comment"></span>
00586 <span class="comment">Arguments:</span>
00587 <span class="comment"></span>
00588 <span class="comment">    Status - Supplies the status value to be used as the exception code</span>
00589 <span class="comment">        for the exception that is to be raised.</span>
00590 <span class="comment"></span>
00591 <span class="comment">Return Value:</span>
00592 <span class="comment"></span>
00593 <span class="comment">    None.</span>
00594 <span class="comment"></span>
00595 <span class="comment">--*/</span>
00596 
00597 {
00598 
00599     <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a5">RtlpRaiseStatus</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>);
00600     <span class="keywordflow">return</span>;
00601 }
00602 
00603 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00604 <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a5">RtlpRaiseStatus</a> (
00605     IN NTSTATUS Status
00606     )
00607 
00608 <span class="comment">/*++</span>
00609 <span class="comment"></span>
00610 <span class="comment">Routine Description:</span>
00611 <span class="comment"></span>
00612 <span class="comment">    This function raises an exception with the specified status value. The</span>
00613 <span class="comment">    exception is marked as noncontinuable with no parameters.</span>
00614 <span class="comment"></span>
00615 <span class="comment">Arguments:</span>
00616 <span class="comment"></span>
00617 <span class="comment">    Status - Supplies the status value to be used as the exception code</span>
00618 <span class="comment">        for the exception that is to be raised.</span>
00619 <span class="comment"></span>
00620 <span class="comment">Return Value:</span>
00621 <span class="comment"></span>
00622 <span class="comment">    None.</span>
00623 <span class="comment"></span>
00624 <span class="comment">--*/</span>
00625 
00626 {
00627 
00628     ULONG ControlPc;
00629     CONTEXT ContextRecord;
00630     ULONG EstablisherFrame;
00631     EXCEPTION_RECORD ExceptionRecord;
00632     PRUNTIME_FUNCTION FunctionEntry;
00633     BOOLEAN InFunction;
00634     ULONG NextPc;
00635 
00636     <span class="comment">//</span>
00637     <span class="comment">// Construct an exception record.</span>
00638     <span class="comment">//</span>
00639 
00640     ExceptionRecord.ExceptionCode = <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00641     ExceptionRecord.ExceptionRecord = (PEXCEPTION_RECORD)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00642     ExceptionRecord.NumberParameters = 0;
00643     ExceptionRecord.ExceptionFlags = <a class="code" href="../../d6/d7/halmips_8h.html#a25">EXCEPTION_NONCONTINUABLE</a>;
00644 
00645     <span class="comment">//</span>
00646     <span class="comment">// Capture the current context, virtually unwind to the caller of this</span>
00647     <span class="comment">// routine, set the fault instruction address to that of the caller, and</span>
00648     <span class="comment">// call the raise exception system service.</span>
00649     <span class="comment">//</span>
00650 
00651     RtlCaptureContext(&amp;ContextRecord);
00652     ControlPc = (ULONG)(ContextRecord.XIntRa - 4);
00653     FunctionEntry = <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a8">RtlLookupFunctionEntry</a>(ControlPc);
00654     NextPc = <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a38">RtlVirtualUnwind</a>(ControlPc | 1,
00655                               FunctionEntry,
00656                               &amp;ContextRecord,
00657                               &amp;InFunction,
00658                               &amp;EstablisherFrame,
00659                               NULL);
00660 
00661     ContextRecord.Fir = NextPc + 4;
00662     ExceptionRecord.ExceptionAddress = (PVOID)ContextRecord.Fir;
00663     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwRaiseException(&amp;ExceptionRecord, &amp;ContextRecord, TRUE);
00664 
00665     <span class="comment">//</span>
00666     <span class="comment">// There should never be a return from this system service unless</span>
00667     <span class="comment">// there is a problem with the argument list itself. Raise another</span>
00668     <span class="comment">// exception specifying the status value returned.</span>
00669     <span class="comment">//</span>
00670 
00671     <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a10">RtlRaiseStatus</a>(Status);
00672     <span class="keywordflow">return</span>;
00673 }
00674 
00675 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00676"></a><a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a15">00676</a> <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a11">RtlUnwind</a> (
00677     IN PVOID TargetFrame OPTIONAL,
00678     IN PVOID TargetIp OPTIONAL,
00679     IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL,
00680     IN PVOID ReturnValue
00681     )
00682 
00683 <span class="comment">/*++</span>
00684 <span class="comment"></span>
00685 <span class="comment">Routine Description:</span>
00686 <span class="comment"></span>
00687 <span class="comment">    This function initiates an unwind of procedure call frames. The machine</span>
00688 <span class="comment">    state at the time of the call to unwind is captured in a context record</span>
00689 <span class="comment">    and the unwinding flag is set in the exception flags of the exception</span>
00690 <span class="comment">    record. If the TargetFrame parameter is not specified, then the exit unwind</span>
00691 <span class="comment">    flag is also set in the exception flags of the exception record. A backward</span>
00692 <span class="comment">    scan through the procedure call frames is then performed to find the target</span>
00693 <span class="comment">    of the unwind operation.</span>
00694 <span class="comment"></span>
00695 <span class="comment">    As each frame is encounter, the PC where control left the corresponding</span>
00696 <span class="comment">    function is determined and used to lookup exception handler information</span>
00697 <span class="comment">    in the runtime function table built by the linker. If the respective</span>
00698 <span class="comment">    routine has an exception handler, then the handler is called.</span>
00699 <span class="comment"></span>
00700 <span class="comment">    N.B. This routine is provided for backward compatibility with release 1.</span>
00701 <span class="comment"></span>
00702 <span class="comment">Arguments:</span>
00703 <span class="comment"></span>
00704 <span class="comment">    TargetFrame - Supplies an optional pointer to the call frame that is the</span>
00705 <span class="comment">        target of the unwind. If this parameter is not specified, then an exit</span>
00706 <span class="comment">        unwind is performed.</span>
00707 <span class="comment"></span>
00708 <span class="comment">    TargetIp - Supplies an optional instruction address that specifies the</span>
00709 <span class="comment">        continuation address of the unwind. This address is ignored if the</span>
00710 <span class="comment">        target frame parameter is not specified.</span>
00711 <span class="comment"></span>
00712 <span class="comment">    ExceptionRecord - Supplies an optional pointer to an exception record.</span>
00713 <span class="comment"></span>
00714 <span class="comment">    ReturnValue - Supplies a value that is to be placed in the integer</span>
00715 <span class="comment">        function return register just before continuing execution.</span>
00716 <span class="comment"></span>
00717 <span class="comment">Return Value:</span>
00718 <span class="comment"></span>
00719 <span class="comment">    None.</span>
00720 <span class="comment"></span>
00721 <span class="comment">--*/</span>
00722 
00723 {
00724 
00725     CONTEXT ContextRecord;
00726 
00727     <span class="comment">//</span>
00728     <span class="comment">// Call real unwind routine specifying a context record as an</span>
00729     <span class="comment">// extra argument.</span>
00730     <span class="comment">//</span>
00731 
00732     <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a12">RtlUnwind2</a>(TargetFrame,
00733                TargetIp,
00734                ExceptionRecord,
00735                ReturnValue,
00736                &amp;ContextRecord);
00737 
00738     <span class="keywordflow">return</span>;
00739 }
00740 
00741 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00742"></a><a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a16">00742</a> <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a12">RtlUnwind2</a> (
00743     IN PVOID TargetFrame OPTIONAL,
00744     IN PVOID TargetIp OPTIONAL,
00745     IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL,
00746     IN PVOID ReturnValue,
00747     IN PCONTEXT ContextRecord
00748     )
00749 
00750 <span class="comment">/*++</span>
00751 <span class="comment"></span>
00752 <span class="comment">Routine Description:</span>
00753 <span class="comment"></span>
00754 <span class="comment">    This function initiates an unwind of procedure call frames. The machine</span>
00755 <span class="comment">    state at the time of the call to unwind is captured in a context record</span>
00756 <span class="comment">    and the unwinding flag is set in the exception flags of the exception</span>
00757 <span class="comment">    record. If the TargetFrame parameter is not specified, then the exit unwind</span>
00758 <span class="comment">    flag is also set in the exception flags of the exception record. A backward</span>
00759 <span class="comment">    scan through the procedure call frames is then performed to find the target</span>
00760 <span class="comment">    of the unwind operation.</span>
00761 <span class="comment"></span>
00762 <span class="comment">    As each frame is encounter, the PC where control left the corresponding</span>
00763 <span class="comment">    function is determined and used to lookup exception handler information</span>
00764 <span class="comment">    in the runtime function table built by the linker. If the respective</span>
00765 <span class="comment">    routine has an exception handler, then the handler is called.</span>
00766 <span class="comment"></span>
00767 <span class="comment">Arguments:</span>
00768 <span class="comment"></span>
00769 <span class="comment">    TargetFrame - Supplies an optional pointer to the call frame that is the</span>
00770 <span class="comment">        target of the unwind. If this parameter is not specified, then an exit</span>
00771 <span class="comment">        unwind is performed.</span>
00772 <span class="comment"></span>
00773 <span class="comment">    TargetIp - Supplies an optional instruction address that specifies the</span>
00774 <span class="comment">        continuation address of the unwind. This address is ignored if the</span>
00775 <span class="comment">        target frame parameter is not specified.</span>
00776 <span class="comment"></span>
00777 <span class="comment">    ExceptionRecord - Supplies an optional pointer to an exception record.</span>
00778 <span class="comment"></span>
00779 <span class="comment">    ReturnValue - Supplies a value that is to be placed in the integer</span>
00780 <span class="comment">        function return register just before continuing execution.</span>
00781 <span class="comment"></span>
00782 <span class="comment">    ContextRecord - Supplies a pointer to a context record that can be used</span>
00783 <span class="comment">        to store context druing the unwind operation.</span>
00784 <span class="comment"></span>
00785 <span class="comment">Return Value:</span>
00786 <span class="comment"></span>
00787 <span class="comment">    None.</span>
00788 <span class="comment"></span>
00789 <span class="comment">--*/</span>
00790 
00791 {
00792 
00793     ULONG ControlPc;
00794     <a class="code" href="../../d0/d6/struct__DISPATCHER__CONTEXT.html">DISPATCHER_CONTEXT</a> DispatcherContext;
00795     EXCEPTION_DISPOSITION Disposition;
00796     ULONG EstablisherFrame;
00797     ULONG ExceptionFlags;
00798     EXCEPTION_RECORD ExceptionRecord1;
00799     PRUNTIME_FUNCTION FunctionEntry;
00800     BOOLEAN InFunction;
00801     ULONG HighLimit;
00802     ULONG LowLimit;
00803     ULONG NextPc;
00804 
00805     <span class="comment">//</span>
00806     <span class="comment">// Get current stack limits, capture the current context, virtually</span>
00807     <span class="comment">// unwind to the caller of this routine, get the initial PC value, and</span>
00808     <span class="comment">// set the unwind target address.</span>
00809     <span class="comment">//</span>
00810 
00811     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a30">RtlpGetStackLimits</a>(&amp;LowLimit, &amp;HighLimit);
00812     RtlCaptureContext(ContextRecord);
00813     ControlPc = (ULONG)(ContextRecord-&gt;XIntRa - 4);
00814     FunctionEntry = <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a8">RtlLookupFunctionEntry</a>(ControlPc);
00815     NextPc = <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a38">RtlVirtualUnwind</a>(ControlPc | 1,
00816                               FunctionEntry,
00817                               ContextRecord,
00818                               &amp;InFunction,
00819                               &amp;EstablisherFrame,
00820                               <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00821 
00822     ControlPc = NextPc;
00823     ContextRecord-&gt;Fir = (ULONG)TargetIp;
00824 
00825     <span class="comment">//</span>
00826     <span class="comment">// If an exception record is not specified, then build a local exception</span>
00827     <span class="comment">// record for use in calling exception handlers during the unwind operation.</span>
00828     <span class="comment">//</span>
00829 
00830     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(ExceptionRecord) == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
00831         ExceptionRecord = &amp;ExceptionRecord1;
00832         ExceptionRecord1.ExceptionCode = STATUS_UNWIND;
00833         ExceptionRecord1.ExceptionRecord = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00834         ExceptionRecord1.ExceptionAddress = (PVOID)ControlPc;
00835         ExceptionRecord1.NumberParameters = 0;
00836     }
00837 
00838     <span class="comment">//</span>
00839     <span class="comment">// If the target frame of the unwind is specified, then a normal unwind</span>
00840     <span class="comment">// is being performed. Otherwise, an exit unwind is being performed.</span>
00841     <span class="comment">//</span>
00842 
00843     ExceptionFlags = <a class="code" href="../../d6/d7/halmips_8h.html#a26">EXCEPTION_UNWINDING</a>;
00844     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(TargetFrame) == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
00845         ExceptionRecord-&gt;ExceptionFlags |= <a class="code" href="../../d6/d7/halmips_8h.html#a27">EXCEPTION_EXIT_UNWIND</a>;
00846     }
00847 
00848     <span class="comment">//</span>
00849     <span class="comment">// Scan backward through the call frame hierarchy and call exception</span>
00850     <span class="comment">// handlers until the target frame of the unwind is reached.</span>
00851     <span class="comment">//</span>
00852 
00853     <span class="keywordflow">do</span> {
00854 
00855         <span class="comment">//</span>
00856         <span class="comment">// Lookup the function table entry using the point at which control</span>
00857         <span class="comment">// left the procedure.</span>
00858         <span class="comment">//</span>
00859 
00860         FunctionEntry = <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a8">RtlLookupFunctionEntry</a>(ControlPc);
00861 
00862         <span class="comment">//</span>
00863         <span class="comment">// If there is a function table entry for the routine, then virtually</span>
00864         <span class="comment">// unwind to the caller of the routine to obtain the virtual frame</span>
00865         <span class="comment">// pointer of the establisher, but don't update the context record.</span>
00866         <span class="comment">//</span>
00867 
00868         <span class="keywordflow">if</span> (FunctionEntry != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00869             NextPc = <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a6">RtlpVirtualUnwind</a>(ControlPc,
00870                                        FunctionEntry,
00871                                        ContextRecord,
00872                                        &amp;InFunction,
00873                                        &amp;EstablisherFrame,
00874                                        <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00875 
00876             <span class="comment">//</span>
00877             <span class="comment">// If the virtual frame pointer is not within the specified stack</span>
00878             <span class="comment">// limits, the virtual frame pointer is unaligned, or the target</span>
00879             <span class="comment">// frame is below the virtual frame and an exit unwind is not being</span>
00880             <span class="comment">// performed, then raise the exception STATUS_BAD_STACK. Otherwise,</span>
00881             <span class="comment">// check to determine if the current routine has an exception</span>
00882             <span class="comment">// handler.</span>
00883             <span class="comment">//</span>
00884 
00885             <span class="keywordflow">if</span> ((EstablisherFrame &lt; LowLimit) || (EstablisherFrame &gt; HighLimit) ||
00886                ((ARGUMENT_PRESENT(TargetFrame) != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
00887                ((ULONG)TargetFrame &lt; EstablisherFrame)) ||
00888                ((EstablisherFrame &amp; 0x7) != 0)) {
00889                 <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a0">RAISE_EXCEPTION</a>(STATUS_BAD_STACK, ExceptionRecord);
00890 
00891             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((FunctionEntry-&gt;ExceptionHandler != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp; InFunction) {
00892 
00893                 <span class="comment">//</span>
00894                 <span class="comment">// The frame has an exception handler.</span>
00895                 <span class="comment">//</span>
00896                 <span class="comment">// The control PC, establisher frame pointer, the address</span>
00897                 <span class="comment">// of the function table entry, and the address of the</span>
00898                 <span class="comment">// context record are all stored in the dispatcher context.</span>
00899                 <span class="comment">// This information is used by the unwind linkage routine</span>
00900                 <span class="comment">// and can be used by the exception handler itself.</span>
00901                 <span class="comment">//</span>
00902                 <span class="comment">// A linkage routine written in assembler is used to actually</span>
00903                 <span class="comment">// call the actual exception handler. This is required by the</span>
00904                 <span class="comment">// exception handler that is associated with the linkage</span>
00905                 <span class="comment">// routine so it can have access to two sets of dispatcher</span>
00906                 <span class="comment">// context when it is called.</span>
00907                 <span class="comment">//</span>
00908 
00909                 DispatcherContext.ControlPc = ControlPc;
00910                 DispatcherContext.FunctionEntry = FunctionEntry;
00911                 DispatcherContext.EstablisherFrame = EstablisherFrame;
00912                 DispatcherContext.ContextRecord = ContextRecord;
00913 
00914                 <span class="comment">//</span>
00915                 <span class="comment">// Call the exception handler.</span>
00916                 <span class="comment">//</span>
00917 
00918                 <span class="keywordflow">do</span> {
00919 
00920                     <span class="comment">//</span>
00921                     <span class="comment">// If the establisher frame is the target of the unwind</span>
00922                     <span class="comment">// operation, then set the target unwind flag.</span>
00923                     <span class="comment">//</span>
00924 
00925                     <span class="keywordflow">if</span> ((ULONG)TargetFrame == EstablisherFrame) {
00926                         ExceptionFlags |= <a class="code" href="../../d6/d7/halmips_8h.html#a30">EXCEPTION_TARGET_UNWIND</a>;
00927                     }
00928 
00929                     ExceptionRecord-&gt;ExceptionFlags = ExceptionFlags;
00930 
00931                     <span class="comment">//</span>
00932                     <span class="comment">// Set the specified return value in case the exception</span>
00933                     <span class="comment">// handler directly continues execution.</span>
00934                     <span class="comment">//</span>
00935 
00936                     ContextRecord-&gt;XIntV0 = (LONG)ReturnValue;
00937                     Disposition =
00938                         <a class="code" href="../../d6/d9/ntrtlppc_8h.html#a1">RtlpExecuteHandlerForUnwind</a>(ExceptionRecord,
00939                                                     EstablisherFrame,
00940                                                     ContextRecord,
00941                                                     &amp;DispatcherContext,
00942                                                     FunctionEntry-&gt;ExceptionHandler);
00943 
00944                     <span class="comment">//</span>
00945                     <span class="comment">// Clear target unwind and collided unwind flags.</span>
00946                     <span class="comment">//</span>
00947 
00948                     ExceptionFlags &amp;= ~(<a class="code" href="../../d6/d7/halmips_8h.html#a31">EXCEPTION_COLLIDED_UNWIND</a> |
00949                                                         <a class="code" href="../../d6/d7/halmips_8h.html#a30">EXCEPTION_TARGET_UNWIND</a>);
00950 
00951                     <span class="comment">//</span>
00952                     <span class="comment">// Case on the handler disposition.</span>
00953                     <span class="comment">//</span>
00954 
00955                     <span class="keywordflow">switch</span> (Disposition) {
00956 
00957                         <span class="comment">//</span>
00958                         <span class="comment">// The disposition is to continue the search.</span>
00959                         <span class="comment">//</span>
00960                         <span class="comment">// If the target frame has not been reached, then</span>
00961                         <span class="comment">// virtually unwind to the caller of the current</span>
00962                         <span class="comment">// routine, update the context record, and continue</span>
00963                         <span class="comment">// the search for a handler.</span>
00964                         <span class="comment">//</span>
00965 
00966                     <span class="keywordflow">case</span> <a class="code" href="../../d6/d7/halmips_8h.html#a37">ExceptionContinueSearch</a> :
00967                         <span class="keywordflow">if</span> (EstablisherFrame != (ULONG)TargetFrame) {
00968                             NextPc = <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a38">RtlVirtualUnwind</a>(ControlPc | 1,
00969                                                       FunctionEntry,
00970                                                       ContextRecord,
00971                                                       &amp;InFunction,
00972                                                       &amp;EstablisherFrame,
00973                                                       <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00974                         }
00975 
00976                         <span class="keywordflow">break</span>;
00977 
00978                         <span class="comment">//</span>
00979                         <span class="comment">// The disposition is collided unwind.</span>
00980                         <span class="comment">//</span>
00981                         <span class="comment">// Set the target of the current unwind to the context</span>
00982                         <span class="comment">// record of the previous unwind, and reexecute the</span>
00983                         <span class="comment">// exception handler from the collided frame with the</span>
00984                         <span class="comment">// collided unwind flag set in the exception record.</span>
00985                         <span class="comment">//</span>
00986 
00987                     <span class="keywordflow">case</span> <a class="code" href="../../d6/d7/halmips_8h.html#a39">ExceptionCollidedUnwind</a> :
00988                         ControlPc = DispatcherContext.ControlPc;
00989                         FunctionEntry = DispatcherContext.FunctionEntry;
00990                         ContextRecord = DispatcherContext.ContextRecord;
00991                         ContextRecord-&gt;Fir = (ULONG)TargetIp;
00992                         ExceptionFlags |= <a class="code" href="../../d6/d7/halmips_8h.html#a31">EXCEPTION_COLLIDED_UNWIND</a>;
00993                         EstablisherFrame = DispatcherContext.EstablisherFrame;
00994                         <span class="keywordflow">break</span>;
00995 
00996                         <span class="comment">//</span>
00997                         <span class="comment">// All other disposition values are invalid.</span>
00998                         <span class="comment">//</span>
00999                         <span class="comment">// Raise invalid disposition exception.</span>
01000                         <span class="comment">//</span>
01001 
01002                     <span class="keywordflow">default</span> :
01003                         <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a0">RAISE_EXCEPTION</a>(STATUS_INVALID_DISPOSITION, ExceptionRecord);
01004                     }
01005 
01006                 } <span class="keywordflow">while</span> ((ExceptionFlags &amp; <a class="code" href="../../d6/d7/halmips_8h.html#a31">EXCEPTION_COLLIDED_UNWIND</a>) != 0);
01007 
01008             } <span class="keywordflow">else</span> {
01009 
01010                 <span class="comment">//</span>
01011                 <span class="comment">// If the target frame has not been reached, then virtually unwind to the</span>
01012                 <span class="comment">// caller of the current routine and update the context record.</span>
01013                 <span class="comment">//</span>
01014 
01015                 <span class="keywordflow">if</span> (EstablisherFrame != (ULONG)TargetFrame) {
01016                     NextPc = <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a38">RtlVirtualUnwind</a>(ControlPc | 1,
01017                                               FunctionEntry,
01018                                               ContextRecord,
01019                                               &amp;InFunction,
01020                                               &amp;EstablisherFrame,
01021                                               <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
01022                 }
01023             }
01024 
01025         } <span class="keywordflow">else</span> {
01026 
01027             <span class="comment">//</span>
01028             <span class="comment">// Set point at which control left the previous routine.</span>
01029             <span class="comment">//</span>
01030 
01031             NextPc = (ULONG)(ContextRecord-&gt;XIntRa - 4);
01032 
01033             <span class="comment">//</span>
01034             <span class="comment">// If the next control PC is the same as the old control PC, then</span>
01035             <span class="comment">// the function table is not correctly formed.</span>
01036             <span class="comment">//</span>
01037 
01038             <span class="keywordflow">if</span> (NextPc == ControlPc) {
01039                 <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a10">RtlRaiseStatus</a>(STATUS_BAD_FUNCTION_TABLE);
01040             }
01041         }
01042 
01043         <span class="comment">//</span>
01044         <span class="comment">// Set point at which control left the previous routine.</span>
01045         <span class="comment">//</span>
01046         <span class="comment">// N.B. Make sure the address is in the delay slot of the jal</span>
01047         <span class="comment">//      to prevent the boundary condition of the return address</span>
01048         <span class="comment">//      being at the front of a try body.</span>
01049         <span class="comment">//</span>
01050 
01051         ControlPc = NextPc;
01052 
01053     } <span class="keywordflow">while</span> ((EstablisherFrame &lt; HighLimit) &amp;&amp;
01054             (EstablisherFrame != (ULONG)TargetFrame));
01055 
01056     <span class="comment">//</span>
01057     <span class="comment">// If the establisher stack pointer is equal to the target frame</span>
01058     <span class="comment">// pointer, then continue execution. Otherwise, an exit unwind was</span>
01059     <span class="comment">// performed or the target of the unwind did not exist and the</span>
01060     <span class="comment">// debugger and subsystem are given a second chance to handle the</span>
01061     <span class="comment">// unwind.</span>
01062     <span class="comment">//</span>
01063 
01064     <span class="keywordflow">if</span> (EstablisherFrame == (ULONG)TargetFrame) {
01065         ContextRecord-&gt;XIntV0 = (LONG)ReturnValue;
01066         <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a3">RtlpRestoreContext</a>(ContextRecord, ExceptionRecord);
01067 
01068     } <span class="keywordflow">else</span> {
01069         ZwRaiseException(ExceptionRecord, ContextRecord, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
01070     }
01071 }
01072 
01073 ULONG
<a name="l01074"></a><a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a17">01074</a> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a38">RtlVirtualUnwind</a> (
01075     IN ULONG ControlPc,
01076     IN PRUNTIME_FUNCTION FunctionEntry,
01077     IN OUT PCONTEXT ContextRecord,
01078     OUT PBOOLEAN InFunction,
01079     OUT PULONG EstablisherFrame,
01080     IN OUT PKNONVOLATILE_CONTEXT_POINTERS ContextPointers OPTIONAL
01081     )
01082 
01083 <span class="comment">/*++</span>
01084 <span class="comment"></span>
01085 <span class="comment">Routine Description:</span>
01086 <span class="comment"></span>
01087 <span class="comment">    This function virtually unwinds the specfified function by executing its</span>
01088 <span class="comment">    prologue code backwards.</span>
01089 <span class="comment"></span>
01090 <span class="comment">    If the function is a leaf function, then the address where control left</span>
01091 <span class="comment">    the previous frame is obtained from the context record. If the function</span>
01092 <span class="comment">    is a nested function, but not an exception or interrupt frame, then the</span>
01093 <span class="comment">    prologue code is executed backwards and the address where control left</span>
01094 <span class="comment">    the previous frame is obtained from the updated context record.</span>
01095 <span class="comment"></span>
01096 <span class="comment">    Otherwise, an exception or interrupt entry to the system is being unwound</span>
01097 <span class="comment">    and a specially coded prologue restores the return address twice. Once</span>
01098 <span class="comment">    from the fault instruction address and once from the saved return address</span>
01099 <span class="comment">    register. The first restore is returned as the function value and the</span>
01100 <span class="comment">    second restore is place in the updated context record.</span>
01101 <span class="comment"></span>
01102 <span class="comment">    If a context pointers record is specified, then the address where each</span>
01103 <span class="comment">    nonvolatile registers is restored from is recorded in the appropriate</span>
01104 <span class="comment">    element of the context pointers record.</span>
01105 <span class="comment"></span>
01106 <span class="comment">    N.B. This routine handles 64-bit context records.</span>
01107 <span class="comment"></span>
01108 <span class="comment">Arguments:</span>
01109 <span class="comment"></span>
01110 <span class="comment">    ControlPc - Supplies the address where control left the specified</span>
01111 <span class="comment">        function.</span>
01112 <span class="comment"></span>
01113 <span class="comment">        N.B. The low order bit of this argument is used to denote the</span>
01114 <span class="comment">             context record type. If the low order bit is clear, then</span>
01115 <span class="comment">             the context record contains 32-bit information. Otherwise,</span>
01116 <span class="comment">             it contains 64-bit information.</span>
01117 <span class="comment"></span>
01118 <span class="comment">    FunctionEntry - Supplies the address of the function table entry for the</span>
01119 <span class="comment">        specified function.</span>
01120 <span class="comment"></span>
01121 <span class="comment">    ContextRecord - Supplies the address of a context record.</span>
01122 <span class="comment"></span>
01123 <span class="comment">    InFunction - Supplies a pointer to a variable that receives whether the</span>
01124 <span class="comment">        control PC is within the current function.</span>
01125 <span class="comment"></span>
01126 <span class="comment">    EstablisherFrame - Supplies a pointer to a variable that receives the</span>
01127 <span class="comment">        the establisher frame pointer value.</span>
01128 <span class="comment"></span>
01129 <span class="comment">    ContextPointers - Supplies an optional pointer to a context pointers</span>
01130 <span class="comment">        record.</span>
01131 <span class="comment"></span>
01132 <span class="comment">Return Value:</span>
01133 <span class="comment"></span>
01134 <span class="comment">    The address where control left the previous frame is returned as the</span>
01135 <span class="comment">    function value.</span>
01136 <span class="comment"></span>
01137 <span class="comment">--*/</span>
01138 
01139 {
01140 
01141     ULONG Address;
01142     ULONG DecrementOffset;
01143     ULONG DecrementRegister;
01144     PULONG FloatingRegister;
01145     ULONG Function;
01146     MIPS_INSTRUCTION Instruction;
01147     PULONGLONG IntegerRegister;
01148     ULONG NextPc;
01149     LONG <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>;
01150     ULONG Opcode;
01151     ULONG Rd;
01152     BOOLEAN RestoredRa;
01153     BOOLEAN RestoredSp;
01154     ULONG Rs;
01155     ULONG Rt;
01156 
01157     <span class="comment">//</span>
01158     <span class="comment">// If the low order bit of the control PC is clear, then the context</span>
01159     <span class="comment">// record format is 32-bit. Otherwise, the context record format is</span>
01160     <span class="comment">// 64-bits.</span>
01161     <span class="comment">//</span>
01162 
01163     <span class="keywordflow">if</span> ((ControlPc &amp; 1) == 0) {
01164         <span class="keywordflow">return</span> <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a10">RtlpVirtualUnwind32</a>(ControlPc,
01165                                    FunctionEntry,
01166                                    ContextRecord,
01167                                    InFunction,
01168                                    EstablisherFrame,
01169                                    ContextPointers);
01170 
01171     } <span class="keywordflow">else</span> {
01172 
01173         <span class="comment">//</span>
01174         <span class="comment">// Set the base address of the integer and floating register arrays.</span>
01175         <span class="comment">//</span>
01176 
01177         FloatingRegister = &amp;ContextRecord-&gt;FltF0;
01178         IntegerRegister = &amp;ContextRecord-&gt;XIntZero;
01179 
01180         <span class="comment">//</span>
01181         <span class="comment">// If the instruction at the point where control left the specified</span>
01182         <span class="comment">// function is a return, then any saved registers have been restored</span>
01183         <span class="comment">// with the possible exception of the stack pointer and the control</span>
01184         <span class="comment">// PC is not considered to be in the function (i.e., an epilogue).</span>
01185         <span class="comment">//</span>
01186 
01187         ControlPc &amp;= ~1;
01188         <span class="keywordflow">if</span> (*((PULONG)ControlPc) == JUMP_RA) {
01189             *InFunction = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01190             Instruction.Long = *((PULONG)ControlPc + 1);
01191             Opcode = Instruction.i_format.Opcode;
01192             <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> = Instruction.i_format.Simmediate;
01193             Rd = Instruction.r_format.Rd;
01194             Rs = Instruction.i_format.Rs;
01195             Rt = Instruction.i_format.Rt;
01196             Function = Instruction.r_format.Function;
01197 
01198             <span class="comment">//</span>
01199             <span class="comment">// If the opcode is an add immediate unsigned op and both the</span>
01200             <span class="comment">// source and destination registers are SP, then add the signed</span>
01201             <span class="comment">// offset value to SP. Otherwise, if the opcode is a special op,</span>
01202             <span class="comment">// the operation is an add unsigned, and the source and destination</span>
01203             <span class="comment">// registers are both SP, then add the register specified by Rd to</span>
01204             <span class="comment">// SP.</span>
01205             <span class="comment">//</span>
01206 
01207             <span class="keywordflow">if</span> ((Opcode == ADDIU_OP) &amp;&amp; (Rt == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>) &amp;&amp; (Rs == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>)) {
01208                 IntegerRegister[<a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>] += <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>;
01209 
01210             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((Opcode == SPEC_OP) &amp;&amp; (Function == ADDU_OP) &amp;&amp;
01211                        (Rd == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>) &amp;&amp; (Rs == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>)) {
01212                 IntegerRegister[<a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>] += IntegerRegister[Rt];
01213             }
01214 
01215             *EstablisherFrame = (ULONG)ContextRecord-&gt;XIntSp;
01216             <span class="keywordflow">return</span> (ULONG)ContextRecord-&gt;XIntRa;
01217         }
01218 
01219         <span class="comment">//</span>
01220         <span class="comment">// If the address where control left the specified function is outside</span>
01221         <span class="comment">// the limits of the prologue, then the control PC is considered to be</span>
01222         <span class="comment">// within the function and the control address is set to the end of</span>
01223         <span class="comment">// the prologue. Otherwise, the control PC is not considered to be</span>
01224         <span class="comment">// within the function (i.e., it is within the prologue).</span>
01225         <span class="comment">//</span>
01226 
01227         <span class="keywordflow">if</span> ((ControlPc &lt; FunctionEntry-&gt;BeginAddress) ||
01228             (ControlPc &gt;= FunctionEntry-&gt;PrologEndAddress)) {
01229             *InFunction = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01230             ControlPc = FunctionEntry-&gt;PrologEndAddress;
01231 
01232         } <span class="keywordflow">else</span> {
01233             *InFunction = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01234         }
01235 
01236         <span class="comment">//</span>
01237         <span class="comment">// Scan backward through the prologue and reload callee registers that</span>
01238         <span class="comment">// were stored.</span>
01239         <span class="comment">//</span>
01240 
01241         DecrementRegister = 0;
01242         *EstablisherFrame = (ULONG)ContextRecord-&gt;XIntSp;
01243         NextPc = (ULONG)(ContextRecord-&gt;XIntRa - 4);
01244         RestoredRa = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01245         RestoredSp = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01246         <span class="keywordflow">while</span> (ControlPc &gt; FunctionEntry-&gt;BeginAddress) {
01247 
01248             <span class="comment">//</span>
01249             <span class="comment">// Get instruction value, decode fields, case of opcode value, and</span>
01250             <span class="comment">// reverse store operations.</span>
01251             <span class="comment">//</span>
01252 
01253             ControlPc -= 4;
01254             Instruction.Long = *((PULONG)ControlPc);
01255             Opcode = Instruction.i_format.Opcode;
01256             <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> = Instruction.i_format.Simmediate;
01257             Rd = Instruction.r_format.Rd;
01258             Rs = Instruction.i_format.Rs;
01259             Rt = Instruction.i_format.Rt;
01260             Address = (ULONG)(<a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> + IntegerRegister[Rs]);
01261             <span class="keywordflow">if</span> (Opcode == SW_OP) {
01262 
01263                 <span class="comment">//</span>
01264                 <span class="comment">// Store word.</span>
01265                 <span class="comment">//</span>
01266                 <span class="comment">// If the base register is SP and the source register is an</span>
01267                 <span class="comment">// integer register, then reload the register value.</span>
01268                 <span class="comment">//</span>
01269 
01270                 <span class="keywordflow">if</span> (Rs == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>) {
01271                     IntegerRegister[Rt] = *((PLONG)Address);
01272 
01273                     <span class="comment">//</span>
01274                     <span class="comment">// If the destination register is RA and this is the first</span>
01275                     <span class="comment">// time that RA is being restored, then set the address of</span>
01276                     <span class="comment">// where control left the previous frame. Otherwise, this</span>
01277                     <span class="comment">// is an interrupt or exception and the return PC should be</span>
01278                     <span class="comment">// biased by 4. Otherwise, if the destination register is</span>
01279                     <span class="comment">// SP and this is the first time that SP is being restored,</span>
01280                     <span class="comment">// then set the establisher frame pointer.</span>
01281                     <span class="comment">//</span>
01282 
01283                     <span class="keywordflow">if</span> (Rt == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a1">RA</a>) {
01284                         <span class="keywordflow">if</span> (RestoredRa == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01285                             NextPc = (ULONG)(ContextRecord-&gt;XIntRa - 4);
01286                             RestoredRa = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01287 
01288                         } <span class="keywordflow">else</span> {
01289                             NextPc += 4;
01290                         }
01291 
01292                     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Rt == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>) {
01293                         <span class="keywordflow">if</span> (RestoredSp == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01294                             *EstablisherFrame = (ULONG)ContextRecord-&gt;XIntSp;
01295                             RestoredSp = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01296                         }
01297                     }
01298 
01299                     <span class="comment">//</span>
01300                     <span class="comment">// If a context pointer record is specified, then record</span>
01301                     <span class="comment">// the address where the destination register contents</span>
01302                     <span class="comment">// are stored.</span>
01303                     <span class="comment">//</span>
01304 
01305                     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(ContextPointers)) {
01306                         ContextPointers-&gt;XIntegerContext[Rt] = (PULONGLONG)Address;
01307                     }
01308                 }
01309 
01310             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Opcode == SD_OP) {
01311 
01312                 <span class="comment">//</span>
01313                 <span class="comment">// Store double.</span>
01314                 <span class="comment">//</span>
01315                 <span class="comment">// If the base register is SP and the source register is an</span>
01316                 <span class="comment">// integer register, then reload the register value.</span>
01317                 <span class="comment">//</span>
01318 
01319                 <span class="keywordflow">if</span> (Rs == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>) {
01320                     IntegerRegister[Rt] = *((PULONGLONG)Address);
01321 
01322                     <span class="comment">//</span>
01323                     <span class="comment">// If the destination register is RA and this is the first</span>
01324                     <span class="comment">// time that RA is being restored, then set the address of</span>
01325                     <span class="comment">// where control left the previous frame. Otherwise, this</span>
01326                     <span class="comment">// is an interrupt or exception and the return PC should be</span>
01327                     <span class="comment">// biased by 4. Otherwise, if the destination register is</span>
01328                     <span class="comment">// SP and this is the first time that SP is being restored,</span>
01329                     <span class="comment">// then set the establisher frame pointer.</span>
01330                     <span class="comment">//</span>
01331 
01332                     <span class="keywordflow">if</span> (Rt == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a1">RA</a>) {
01333                         <span class="keywordflow">if</span> (RestoredRa == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01334                             NextPc = (ULONG)(ContextRecord-&gt;XIntRa - 4);
01335                             RestoredRa = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01336 
01337                         } <span class="keywordflow">else</span> {
01338                             NextPc += 4;
01339                         }
01340 
01341                     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Rt == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>) {
01342                         <span class="keywordflow">if</span> (RestoredSp == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01343                             *EstablisherFrame = (ULONG)ContextRecord-&gt;XIntSp;
01344                             RestoredSp = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01345                         }
01346                     }
01347 
01348                     <span class="comment">//</span>
01349                     <span class="comment">// If a context pointer record is specified, then record</span>
01350                     <span class="comment">// the address where the destination register contents</span>
01351                     <span class="comment">// are stored.</span>
01352                     <span class="comment">//</span>
01353                     <span class="comment">// N.B. The low order bit of the address is set to indicate</span>
01354                     <span class="comment">//      a store double operation.</span>
01355                     <span class="comment">//</span>
01356 
01357                     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(ContextPointers)) {
01358                         ContextPointers-&gt;XIntegerContext[Rt] = (PLONGLONG)((ULONG)Address | 1);
01359                     }
01360                 }
01361 
01362             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Opcode == SWC1_OP) {
01363 
01364                 <span class="comment">//</span>
01365                 <span class="comment">// Store word coprocessor 1.</span>
01366                 <span class="comment">//</span>
01367                 <span class="comment">// If the base register is SP and the source register is a</span>
01368                 <span class="comment">// floating register, then reload the register value.</span>
01369                 <span class="comment">//</span>
01370 
01371                 <span class="keywordflow">if</span> (Rs == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>) {
01372                     FloatingRegister[Rt] = *((PULONG)Address);
01373 
01374                     <span class="comment">//</span>
01375                     <span class="comment">// If a context pointer record is specified, then record</span>
01376                     <span class="comment">// the address where the destination register contents</span>
01377                     <span class="comment">// are stored.</span>
01378                     <span class="comment">//</span>
01379 
01380                     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(ContextPointers)) {
01381                         ContextPointers-&gt;FloatingContext[Rt] = (PULONG)Address;
01382                     }
01383                 }
01384 
01385             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Opcode == SDC1_OP) {
01386 
01387                 <span class="comment">//</span>
01388                 <span class="comment">// Store double coprocessor 1.</span>
01389                 <span class="comment">//</span>
01390                 <span class="comment">// If the base register is SP and the source register is a</span>
01391                 <span class="comment">// floating register, then reload the register and the next</span>
01392                 <span class="comment">// register values.</span>
01393                 <span class="comment">//</span>
01394 
01395                 <span class="keywordflow">if</span> (Rs == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>) {
01396                     FloatingRegister[Rt] = *((PULONG)Address);
01397                     FloatingRegister[Rt + 1] = *((PULONG)(Address + 4));
01398 
01399                     <span class="comment">//</span>
01400                     <span class="comment">// If a context pointer record is specified, then record</span>
01401                     <span class="comment">// the address where the destination registers contents</span>
01402                     <span class="comment">// are stored.</span>
01403                     <span class="comment">//</span>
01404 
01405                     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(ContextPointers)) {
01406                         ContextPointers-&gt;FloatingContext[Rt] = (PULONG)Address;
01407                         ContextPointers-&gt;FloatingContext[Rt + 1] = (PULONG)(Address + 4);
01408                     }
01409                 }
01410 
01411             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Opcode == ADDIU_OP) {
01412 
01413                 <span class="comment">//</span>
01414                 <span class="comment">// Add immediate unsigned.</span>
01415                 <span class="comment">//</span>
01416                 <span class="comment">// If both the source and destination registers are SP, then</span>
01417                 <span class="comment">// a standard stack allocation was performed and the signed</span>
01418                 <span class="comment">// displacement value should be subtracted from SP. Otherwise,</span>
01419                 <span class="comment">// if the destination register is the decrement register and</span>
01420                 <span class="comment">// the source register is zero, then add the decrement value</span>
01421                 <span class="comment">// to SP.</span>
01422                 <span class="comment">//</span>
01423 
01424                 <span class="keywordflow">if</span> ((Rs == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>) &amp;&amp; (Rt == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>)) {
01425                     IntegerRegister[<a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>] -= <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>;
01426                     <span class="keywordflow">if</span> (RestoredSp == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01427                         *EstablisherFrame = (ULONG)ContextRecord-&gt;XIntSp;
01428                         RestoredSp = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01429                     }
01430 
01431                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((Rt == DecrementRegister) &amp;&amp; (Rs == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a3">ZERO</a>)) {
01432                     IntegerRegister[<a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>] += <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>;
01433                     <span class="keywordflow">if</span> (RestoredSp == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01434                         *EstablisherFrame = (ULONG)ContextRecord-&gt;XIntSp;
01435                         RestoredSp = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01436                     }
01437                 }
01438 
01439             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Opcode == ORI_OP) {
01440 
01441                 <span class="comment">//</span>
01442                 <span class="comment">// Or immediate.</span>
01443                 <span class="comment">//</span>
01444                 <span class="comment">// If both the destination and source registers are the decrement</span>
01445                 <span class="comment">// register, then save the decrement value. Otherwise, if the</span>
01446                 <span class="comment">// destination register is the decrement register and the source</span>
01447                 <span class="comment">// register is zero, then add the decrement value to SP.</span>
01448                 <span class="comment">//</span>
01449 
01450                 <span class="keywordflow">if</span> ((Rs == DecrementRegister) &amp;&amp; (Rt == DecrementRegister)) {
01451                     DecrementOffset = (<a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> &amp; 0xffff);
01452 
01453                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((Rt == DecrementRegister) &amp;&amp; (Rs == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a3">ZERO</a>)) {
01454                     IntegerRegister[<a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>] += (<a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> &amp; 0xffff);
01455                     <span class="keywordflow">if</span> (RestoredSp == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01456                         *EstablisherFrame = (ULONG)ContextRecord-&gt;XIntSp;
01457                         RestoredSp = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01458                     }
01459                 }
01460 
01461             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Opcode == SPEC_OP) {
01462 
01463                 <span class="comment">//</span>
01464                 <span class="comment">// Special operation.</span>
01465                 <span class="comment">//</span>
01466                 <span class="comment">// The real opcode is in the function field of special opcode</span>
01467                 <span class="comment">// instructions.</span>
01468                 <span class="comment">//</span>
01469 
01470                 Function = Instruction.r_format.Function;
01471                 <span class="keywordflow">if</span> ((Function == ADDU_OP) || (Function == OR_OP)) {
01472 
01473                     <span class="comment">//</span>
01474                     <span class="comment">// Add unsigned or an or operation.</span>
01475                     <span class="comment">//</span>
01476                     <span class="comment">// If one of the source registers is ZERO, then the</span>
01477                     <span class="comment">// operation is a move operation and the destination</span>
01478                     <span class="comment">// register should be moved to the appropriate source</span>
01479                     <span class="comment">// register.</span>
01480                     <span class="comment">//</span>
01481 
01482                     <span class="keywordflow">if</span> (Rt == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a3">ZERO</a>) {
01483                         IntegerRegister[Rs] = IntegerRegister[Rd];
01484 
01485                         <span class="comment">//</span>
01486                         <span class="comment">// If the destination register is RA and this is the</span>
01487                         <span class="comment">// first time that RA is being restored, then set the</span>
01488                         <span class="comment">// address of where control left the previous frame.</span>
01489                         <span class="comment">// Otherwise, this an interrupt or exception and the</span>
01490                         <span class="comment">// return PC should be biased by 4.</span>
01491                         <span class="comment">//</span>
01492 
01493                         <span class="keywordflow">if</span> (Rs == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a1">RA</a>) {
01494                             <span class="keywordflow">if</span> (RestoredRa == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01495                                 NextPc = (ULONG)(ContextRecord-&gt;XIntRa - 4);
01496                                 RestoredRa = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01497 
01498                             } <span class="keywordflow">else</span> {
01499                                 NextPc += 4;
01500                             }
01501                         }
01502 
01503                     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Rs == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a3">ZERO</a>) {
01504                         IntegerRegister[Rt] = IntegerRegister[Rd];
01505 
01506                         <span class="comment">//</span>
01507                         <span class="comment">// If the destination register is RA and this is the</span>
01508                         <span class="comment">// first time that RA is being restored, then set the</span>
01509                         <span class="comment">// address of where control left the previous frame.</span>
01510                         <span class="comment">// Otherwise, this an interrupt or exception and the</span>
01511                         <span class="comment">// return PC should be biased by 4.</span>
01512                         <span class="comment">//</span>
01513 
01514                         <span class="keywordflow">if</span> (Rt == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a1">RA</a>) {
01515                             <span class="keywordflow">if</span> (RestoredRa == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01516                                 NextPc = (ULONG)(ContextRecord-&gt;XIntRa - 4);
01517                                 RestoredRa = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01518 
01519                             } <span class="keywordflow">else</span> {
01520                                 NextPc += 4;
01521                             }
01522                         }
01523                     }
01524 
01525                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Function == SUBU_OP) {
01526 
01527                     <span class="comment">//</span>
01528                     <span class="comment">// Subtract unsigned.</span>
01529                     <span class="comment">//</span>
01530                     <span class="comment">// If the destination register is SP and the source register</span>
01531                     <span class="comment">// is SP, then a stack allocation greater than 32kb has been</span>
01532                     <span class="comment">// performed and source register number of the decrement must</span>
01533                     <span class="comment">// be saved for later use.</span>
01534                     <span class="comment">//</span>
01535 
01536                     <span class="keywordflow">if</span> ((Rd == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>) &amp;&amp; (Rs == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>)) {
01537                         DecrementRegister = Rt;
01538                     }
01539                 }
01540 
01541             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Opcode == LUI_OP) {
01542 
01543                 <span class="comment">//</span>
01544                 <span class="comment">// Load upper immediate.</span>
01545                 <span class="comment">//</span>
01546                 <span class="comment">// If the destination register is the decrement register, then</span>
01547                 <span class="comment">// compute the decrement value, add it from SP, and clear the</span>
01548                 <span class="comment">// decrement register number.</span>
01549                 <span class="comment">//</span>
01550 
01551                 <span class="keywordflow">if</span> (Rt == DecrementRegister) {
01552                     DecrementRegister = 0;
01553                     IntegerRegister[<a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>] += (LONG)(DecrementOffset + (<a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> &lt;&lt; 16));
01554                     <span class="keywordflow">if</span> (RestoredSp == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01555                         *EstablisherFrame = (ULONG)(ContextRecord-&gt;XIntSp);
01556                         RestoredSp = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01557                     }
01558                 }
01559             }
01560         }
01561 
01562         <span class="comment">//</span>
01563         <span class="comment">// Make sure that integer register zero is really zero.</span>
01564         <span class="comment">//</span>
01565 
01566         ContextRecord-&gt;XIntZero = 0;
01567         <span class="keywordflow">return</span> NextPc;
01568     }
01569 }
01570 
01571 ULONG
<a name="l01572"></a><a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a10">01572</a> <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a10">RtlpVirtualUnwind32</a> (
01573     IN ULONG ControlPc,
01574     IN PRUNTIME_FUNCTION FunctionEntry,
01575     IN OUT PCONTEXT ContextRecord,
01576     OUT PBOOLEAN InFunction,
01577     OUT PULONG EstablisherFrame,
01578     IN OUT PKNONVOLATILE_CONTEXT_POINTERS ContextPointers OPTIONAL
01579     )
01580 
01581 <span class="comment">/*++</span>
01582 <span class="comment"></span>
01583 <span class="comment">Routine Description:</span>
01584 <span class="comment"></span>
01585 <span class="comment">    This function virtually unwinds the specfified function by executing its</span>
01586 <span class="comment">    prologue code backwards.</span>
01587 <span class="comment"></span>
01588 <span class="comment">    If the function is a leaf function, then the address where control left</span>
01589 <span class="comment">    the previous frame is obtained from the context record. If the function</span>
01590 <span class="comment">    is a nested function, but not an exception or interrupt frame, then the</span>
01591 <span class="comment">    prologue code is executed backwards and the address where control left</span>
01592 <span class="comment">    the previous frame is obtained from the updated context record.</span>
01593 <span class="comment"></span>
01594 <span class="comment">    Otherwise, an exception or interrupt entry to the system is being unwound</span>
01595 <span class="comment">    and a specially coded prologue restores the return address twice. Once</span>
01596 <span class="comment">    from the fault instruction address and once from the saved return address</span>
01597 <span class="comment">    register. The first restore is returned as the function value and the</span>
01598 <span class="comment">    second restore is place in the updated context record.</span>
01599 <span class="comment"></span>
01600 <span class="comment">    If a context pointers record is specified, then the address where each</span>
01601 <span class="comment">    nonvolatile registers is restored from is recorded in the appropriate</span>
01602 <span class="comment">    element of the context pointers record.</span>
01603 <span class="comment"></span>
01604 <span class="comment">    N.B. This routine handles 32-bit context records.</span>
01605 <span class="comment"></span>
01606 <span class="comment">Arguments:</span>
01607 <span class="comment"></span>
01608 <span class="comment">    ControlPc - Supplies the address where control left the specified</span>
01609 <span class="comment">        function.</span>
01610 <span class="comment"></span>
01611 <span class="comment">    FunctionEntry - Supplies the address of the function table entry for the</span>
01612 <span class="comment">        specified function.</span>
01613 <span class="comment"></span>
01614 <span class="comment">    ContextRecord - Supplies the address of a context record.</span>
01615 <span class="comment"></span>
01616 <span class="comment">    InFunction - Supplies a pointer to a variable that receives whether the</span>
01617 <span class="comment">        control PC is within the current function.</span>
01618 <span class="comment"></span>
01619 <span class="comment">    EstablisherFrame - Supplies a pointer to a variable that receives the</span>
01620 <span class="comment">        the establisher frame pointer value.</span>
01621 <span class="comment"></span>
01622 <span class="comment">    ContextPointers - Supplies an optional pointer to a context pointers</span>
01623 <span class="comment">        record.</span>
01624 <span class="comment"></span>
01625 <span class="comment">Return Value:</span>
01626 <span class="comment"></span>
01627 <span class="comment">    The address where control left the previous frame is returned as the</span>
01628 <span class="comment">    function value.</span>
01629 <span class="comment"></span>
01630 <span class="comment">--*/</span>
01631 
01632 {
01633 
01634     ULONG Address;
01635     ULONG DecrementOffset;
01636     ULONG DecrementRegister;
01637     PULONG FloatingRegister;
01638     ULONG Function;
01639     MIPS_INSTRUCTION Instruction;
01640     PULONG IntegerRegister;
01641     ULONG NextPc;
01642     LONG <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>;
01643     ULONG Opcode;
01644     ULONG Rd;
01645     BOOLEAN RestoredRa;
01646     BOOLEAN RestoredSp;
01647     ULONG Rs;
01648     ULONG Rt;
01649 
01650     <span class="comment">//</span>
01651     <span class="comment">// Set the base address of the integer and floating register arrays.</span>
01652     <span class="comment">//</span>
01653 
01654     FloatingRegister = &amp;ContextRecord-&gt;FltF0;
01655     IntegerRegister = &amp;ContextRecord-&gt;IntZero;
01656 
01657     <span class="comment">//</span>
01658     <span class="comment">// If the instruction at the point where control left the specified</span>
01659     <span class="comment">// function is a return, then any saved registers have been restored</span>
01660     <span class="comment">// with the possible exception of the stack pointer and the control</span>
01661     <span class="comment">// PC is not considered to be in the function (i.e., an epilogue).</span>
01662     <span class="comment">//</span>
01663 
01664     <span class="keywordflow">if</span> (*((PULONG)ControlPc) == JUMP_RA) {
01665         *InFunction = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01666         Instruction.Long = *((PULONG)ControlPc + 1);
01667         Opcode = Instruction.i_format.Opcode;
01668         <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> = Instruction.i_format.Simmediate;
01669         Rd = Instruction.r_format.Rd;
01670         Rs = Instruction.i_format.Rs;
01671         Rt = Instruction.i_format.Rt;
01672         Function = Instruction.r_format.Function;
01673 
01674         <span class="comment">//</span>
01675         <span class="comment">// If the opcode is an add immediate unsigned op and both the source</span>
01676         <span class="comment">// and destination registers are SP, then add the signed offset value</span>
01677         <span class="comment">// to SP. Otherwise, if the opcode is a special op, the operation is</span>
01678         <span class="comment">// an add unsigned, and the source and destination registers are both</span>
01679         <span class="comment">// SP, then add the register specified by Rd to SP.</span>
01680         <span class="comment">//</span>
01681 
01682         <span class="keywordflow">if</span> ((Opcode == ADDIU_OP) &amp;&amp; (Rt == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>) &amp;&amp; (Rs == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>)) {
01683             IntegerRegister[<a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>] += <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>;
01684 
01685         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((Opcode == SPEC_OP) &amp;&amp; (Function == ADDU_OP) &amp;&amp;
01686                    (Rd == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>) &amp;&amp; (Rs == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>)) {
01687             IntegerRegister[<a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>] += IntegerRegister[Rt];
01688         }
01689 
01690         *EstablisherFrame = ContextRecord-&gt;IntSp;
01691         <span class="keywordflow">return</span> ContextRecord-&gt;IntRa;
01692     }
01693 
01694     <span class="comment">//</span>
01695     <span class="comment">// If the address where control left the specified function is outside</span>
01696     <span class="comment">// the limits of the prologue, then the control PC is considered to be</span>
01697     <span class="comment">// within the function and the control address is set to the end of</span>
01698     <span class="comment">// the prologue. Otherwise, the control PC is not considered to be</span>
01699     <span class="comment">// within the function (i.e., it is within the prologue).</span>
01700     <span class="comment">//</span>
01701 
01702     <span class="keywordflow">if</span> ((ControlPc &lt; FunctionEntry-&gt;BeginAddress) ||
01703         (ControlPc &gt;= FunctionEntry-&gt;PrologEndAddress)) {
01704         *InFunction = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01705         ControlPc = FunctionEntry-&gt;PrologEndAddress;
01706 
01707     } <span class="keywordflow">else</span> {
01708         *InFunction = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01709     }
01710 
01711     <span class="comment">//</span>
01712     <span class="comment">// Scan backward through the prologue and reload callee registers that</span>
01713     <span class="comment">// were stored.</span>
01714     <span class="comment">//</span>
01715 
01716     DecrementRegister = 0;
01717     *EstablisherFrame = ContextRecord-&gt;IntSp;
01718     NextPc = ContextRecord-&gt;IntRa - 4;
01719     RestoredRa = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01720     RestoredSp = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01721     <span class="keywordflow">while</span> (ControlPc &gt; FunctionEntry-&gt;BeginAddress) {
01722 
01723         <span class="comment">//</span>
01724         <span class="comment">// Get instruction value, decode fields, case of opcode value, and</span>
01725         <span class="comment">// reverse store operations.</span>
01726         <span class="comment">//</span>
01727 
01728         ControlPc -= 4;
01729         Instruction.Long = *((PULONG)ControlPc);
01730         Opcode = Instruction.i_format.Opcode;
01731         <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> = Instruction.i_format.Simmediate;
01732         Rd = Instruction.r_format.Rd;
01733         Rs = Instruction.i_format.Rs;
01734         Rt = Instruction.i_format.Rt;
01735         Address = <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> + IntegerRegister[Rs];
01736         <span class="keywordflow">if</span> (Opcode == SW_OP) {
01737 
01738             <span class="comment">//</span>
01739             <span class="comment">// Store word.</span>
01740             <span class="comment">//</span>
01741             <span class="comment">// If the base register is SP and the source register is an</span>
01742             <span class="comment">// integer register, then reload the register value.</span>
01743             <span class="comment">//</span>
01744 
01745             <span class="keywordflow">if</span> (Rs == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>) {
01746                 IntegerRegister[Rt] = *((PULONG)Address);
01747 
01748                 <span class="comment">//</span>
01749                 <span class="comment">// If the destination register is RA and this is the first</span>
01750                 <span class="comment">// time that RA is being restored, then set the address of</span>
01751                 <span class="comment">// where control left the previous frame. Otherwise, this</span>
01752                 <span class="comment">// is an interrupt or exception and the return PC should be</span>
01753                 <span class="comment">// biased by 4. Otherwise, if the destination register is</span>
01754                 <span class="comment">// SP and this is the first time that SP is being restored,</span>
01755                 <span class="comment">// then set the establisher frame pointer.</span>
01756                 <span class="comment">//</span>
01757 
01758                 <span class="keywordflow">if</span> (Rt == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a1">RA</a>) {
01759                     <span class="keywordflow">if</span> (RestoredRa == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01760                         NextPc = ContextRecord-&gt;IntRa - 4;
01761                         RestoredRa = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01762 
01763                     } <span class="keywordflow">else</span> {
01764                         NextPc += 4;
01765                     }
01766 
01767                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Rt == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>) {
01768                     <span class="keywordflow">if</span> (RestoredSp == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01769                         *EstablisherFrame = ContextRecord-&gt;IntSp;
01770                         RestoredSp = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01771                     }
01772                 }
01773 
01774                 <span class="comment">//</span>
01775                 <span class="comment">// If a context pointer record is specified, then record</span>
01776                 <span class="comment">// the address where the destination register contents</span>
01777                 <span class="comment">// are stored.</span>
01778                 <span class="comment">//</span>
01779 
01780                 <span class="keywordflow">if</span> (ARGUMENT_PRESENT(ContextPointers)) {
01781                     ContextPointers-&gt;XIntegerContext[Rt] = (PULONGLONG)Address;
01782                 }
01783             }
01784 
01785         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Opcode == SWC1_OP) {
01786 
01787             <span class="comment">//</span>
01788             <span class="comment">// Store word coprocessor 1.</span>
01789             <span class="comment">//</span>
01790             <span class="comment">// If the base register is SP and the source register is a</span>
01791             <span class="comment">// floating register, then reload the register value.</span>
01792             <span class="comment">//</span>
01793 
01794             <span class="keywordflow">if</span> (Rs == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>) {
01795                 FloatingRegister[Rt] = *((PULONG)Address);
01796 
01797                 <span class="comment">//</span>
01798                 <span class="comment">// If a context pointer record is specified, then record</span>
01799                 <span class="comment">// the address where the destination register contents</span>
01800                 <span class="comment">// are stored.</span>
01801                 <span class="comment">//</span>
01802 
01803                 <span class="keywordflow">if</span> (ARGUMENT_PRESENT(ContextPointers)) {
01804                     ContextPointers-&gt;FloatingContext[Rt] = (PULONG)Address;
01805                 }
01806             }
01807 
01808         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Opcode == SDC1_OP) {
01809 
01810             <span class="comment">//</span>
01811             <span class="comment">// Store double coprocessor 1.</span>
01812             <span class="comment">//</span>
01813             <span class="comment">// If the base register is SP and the source register is a</span>
01814             <span class="comment">// floating register, then reload the register and the next</span>
01815             <span class="comment">// register values.</span>
01816             <span class="comment">//</span>
01817 
01818             <span class="keywordflow">if</span> (Rs == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>) {
01819                 FloatingRegister[Rt] = *((PULONG)Address);
01820                 FloatingRegister[Rt + 1] = *((PULONG)(Address + 4));
01821 
01822                 <span class="comment">//</span>
01823                 <span class="comment">// If a context pointer record is specified, then record</span>
01824                 <span class="comment">// the address where the destination registers contents</span>
01825                 <span class="comment">// are stored.</span>
01826                 <span class="comment">//</span>
01827 
01828                 <span class="keywordflow">if</span> (ARGUMENT_PRESENT(ContextPointers)) {
01829                     ContextPointers-&gt;FloatingContext[Rt] = (PULONG)Address;
01830                     ContextPointers-&gt;FloatingContext[Rt + 1] = (PULONG)(Address + 4);
01831                 }
01832             }
01833 
01834         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Opcode == ADDIU_OP) {
01835 
01836             <span class="comment">//</span>
01837             <span class="comment">// Add immediate unsigned.</span>
01838             <span class="comment">//</span>
01839             <span class="comment">// If both the source and destination registers are SP, then</span>
01840             <span class="comment">// a standard stack allocation was performed and the signed</span>
01841             <span class="comment">// displacement value should be subtracted from SP. Otherwise,</span>
01842             <span class="comment">// if the destination register is the decrement register and</span>
01843             <span class="comment">// the source register is zero, then add the decrement value</span>
01844             <span class="comment">// to SP.</span>
01845             <span class="comment">//</span>
01846 
01847             <span class="keywordflow">if</span> ((Rs == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>) &amp;&amp; (Rt == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>)) {
01848                 IntegerRegister[<a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>] -= <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>;
01849                 <span class="keywordflow">if</span> (RestoredSp == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01850                     *EstablisherFrame = ContextRecord-&gt;IntSp;
01851                     RestoredSp = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01852                 }
01853 
01854             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((Rt == DecrementRegister) &amp;&amp; (Rs == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a3">ZERO</a>)) {
01855                 IntegerRegister[<a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>] += <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>;
01856                 <span class="keywordflow">if</span> (RestoredSp == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01857                     *EstablisherFrame = ContextRecord-&gt;IntSp;
01858                     RestoredSp = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01859                 }
01860             }
01861 
01862         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Opcode == ORI_OP) {
01863 
01864             <span class="comment">//</span>
01865             <span class="comment">// Or immediate.</span>
01866             <span class="comment">//</span>
01867             <span class="comment">// If both the destination and source registers are the decrement</span>
01868             <span class="comment">// register, then save the decrement value. Otherwise, if the</span>
01869             <span class="comment">// destination register is the decrement register and the source</span>
01870             <span class="comment">// register is zero, then add the decrement value to SP.</span>
01871             <span class="comment">//</span>
01872 
01873             <span class="keywordflow">if</span> ((Rs == DecrementRegister) &amp;&amp; (Rt == DecrementRegister)) {
01874                 DecrementOffset = (<a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> &amp; 0xffff);
01875 
01876             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((Rt == DecrementRegister) &amp;&amp; (Rs == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a3">ZERO</a>)) {
01877                 IntegerRegister[<a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>] += (<a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> &amp; 0xffff);
01878                 <span class="keywordflow">if</span> (RestoredSp == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01879                     *EstablisherFrame = ContextRecord-&gt;IntSp;
01880                     RestoredSp = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01881                 }
01882             }
01883 
01884         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Opcode == SPEC_OP) {
01885 
01886             <span class="comment">//</span>
01887             <span class="comment">// Special operation.</span>
01888             <span class="comment">//</span>
01889             <span class="comment">// The real opcode is in the function field of special opcode</span>
01890             <span class="comment">// instructions.</span>
01891             <span class="comment">//</span>
01892 
01893             Function = Instruction.r_format.Function;
01894             <span class="keywordflow">if</span> ((Function == ADDU_OP) || (Function == OR_OP)) {
01895 
01896                 <span class="comment">//</span>
01897                 <span class="comment">// Add unsigned or an or operation.</span>
01898                 <span class="comment">//</span>
01899                 <span class="comment">// If one of the source registers is ZERO, then the</span>
01900                 <span class="comment">// operation is a move operation and the destination</span>
01901                 <span class="comment">// register should be moved to the appropriate source</span>
01902                 <span class="comment">// register.</span>
01903                 <span class="comment">//</span>
01904 
01905                 <span class="keywordflow">if</span> (Rt == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a3">ZERO</a>) {
01906                     IntegerRegister[Rs] = IntegerRegister[Rd];
01907 
01908                     <span class="comment">//</span>
01909                     <span class="comment">// If the destination register is RA and this is the</span>
01910                     <span class="comment">// first time that RA is being restored, then set the</span>
01911                     <span class="comment">// address of where control left the previous frame.</span>
01912                     <span class="comment">// Otherwise, this an interrupt or exception and the</span>
01913                     <span class="comment">// return PC should be biased by 4.</span>
01914                     <span class="comment">//</span>
01915 
01916                     <span class="keywordflow">if</span> (Rs == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a1">RA</a>) {
01917                         <span class="keywordflow">if</span> (RestoredRa == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01918                             NextPc = ContextRecord-&gt;IntRa - 4;
01919                             RestoredRa = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01920 
01921                         } <span class="keywordflow">else</span> {
01922                             NextPc += 4;
01923                         }
01924                     }
01925 
01926                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Rs == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a3">ZERO</a>) {
01927                     IntegerRegister[Rt] = IntegerRegister[Rd];
01928 
01929                     <span class="comment">//</span>
01930                     <span class="comment">// If the destination register is RA and this is the</span>
01931                     <span class="comment">// first time that RA is being restored, then set the</span>
01932                     <span class="comment">// address of where control left the previous frame.</span>
01933                     <span class="comment">// Otherwise, this an interrupt or exception and the</span>
01934                     <span class="comment">// return PC should be biased by 4.</span>
01935                     <span class="comment">//</span>
01936 
01937                     <span class="keywordflow">if</span> (Rt == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a1">RA</a>) {
01938                         <span class="keywordflow">if</span> (RestoredRa == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01939                             NextPc = ContextRecord-&gt;IntRa - 4;
01940                             RestoredRa = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01941 
01942                         } <span class="keywordflow">else</span> {
01943                             NextPc += 4;
01944                         }
01945                     }
01946                 }
01947 
01948             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Function == SUBU_OP) {
01949 
01950                 <span class="comment">//</span>
01951                 <span class="comment">// Subtract unsigned.</span>
01952                 <span class="comment">//</span>
01953                 <span class="comment">// If the destination register is SP and the source register</span>
01954                 <span class="comment">// is SP, then a stack allocation greater than 32kb has been</span>
01955                 <span class="comment">// performed and source register number of the decrement must</span>
01956                 <span class="comment">// be saved for later use.</span>
01957                 <span class="comment">//</span>
01958 
01959                 <span class="keywordflow">if</span> ((Rd == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>) &amp;&amp; (Rs == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>)) {
01960                     DecrementRegister = Rt;
01961                 }
01962             }
01963 
01964         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Opcode == LUI_OP) {
01965 
01966             <span class="comment">//</span>
01967             <span class="comment">// Load upper immediate.</span>
01968             <span class="comment">//</span>
01969             <span class="comment">// If the destination register is the decrement register, then</span>
01970             <span class="comment">// compute the decrement value, add it from SP, and clear the</span>
01971             <span class="comment">// decrement register number.</span>
01972             <span class="comment">//</span>
01973 
01974             <span class="keywordflow">if</span> (Rt == DecrementRegister) {
01975                 DecrementRegister = 0;
01976                 IntegerRegister[<a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>] += (DecrementOffset + (<a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> &lt;&lt; 16));
01977                 <span class="keywordflow">if</span> (RestoredSp == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01978                     *EstablisherFrame = ContextRecord-&gt;IntSp;
01979                     RestoredSp = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01980                 }
01981             }
01982         }
01983     }
01984 
01985     <span class="comment">//</span>
01986     <span class="comment">// Make sure that integer register zero is really zero.</span>
01987     <span class="comment">//</span>
01988 
01989     ContextRecord-&gt;IntZero = 0;
01990     <span class="keywordflow">return</span> NextPc;
01991 }
01992 
01993 ULONG
<a name="l01994"></a><a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a9">01994</a> <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a6">RtlpVirtualUnwind</a> (
01995     IN ULONG ControlPc,
01996     IN PRUNTIME_FUNCTION FunctionEntry,
01997     IN PCONTEXT ContextRecord,
01998     OUT PBOOLEAN InFunction,
01999     OUT PULONG EstablisherFrame,
02000     IN OUT PKNONVOLATILE_CONTEXT_POINTERS ContextPointers OPTIONAL
02001     )
02002 
02003 <span class="comment">/*++</span>
02004 <span class="comment"></span>
02005 <span class="comment">Routine Description:</span>
02006 <span class="comment"></span>
02007 <span class="comment">    This function virtually unwinds the specfified function by executing its</span>
02008 <span class="comment">    prologue code backwards.</span>
02009 <span class="comment"></span>
02010 <span class="comment">    If the function is a leaf function, then the address where control left</span>
02011 <span class="comment">    the previous frame is obtained from the context record. If the function</span>
02012 <span class="comment">    is a nested function, but not an exception or interrupt frame, then the</span>
02013 <span class="comment">    prologue code is executed backwards and the address where control left</span>
02014 <span class="comment">    the previous frame is obtained from the updated context record.</span>
02015 <span class="comment"></span>
02016 <span class="comment">    Otherwise, an exception or interrupt entry to the system is being unwound</span>
02017 <span class="comment">    and a specially coded prologue restores the return address twice. Once</span>
02018 <span class="comment">    from the fault instruction address and once from the saved return address</span>
02019 <span class="comment">    register. The first restore is returned as the function value and the</span>
02020 <span class="comment">    second restore is place in the updated context record.</span>
02021 <span class="comment"></span>
02022 <span class="comment">    If a context pointers record is specified, then the address where each</span>
02023 <span class="comment">    nonvolatile registers is restored from is recorded in the appropriate</span>
02024 <span class="comment">    element of the context pointers record.</span>
02025 <span class="comment"></span>
02026 <span class="comment">    N.B. This function copies the specified context record and only computes</span>
02027 <span class="comment">         the establisher frame and whether control is actually in a function.</span>
02028 <span class="comment"></span>
02029 <span class="comment">Arguments:</span>
02030 <span class="comment"></span>
02031 <span class="comment">    ControlPc - Supplies the address where control left the specified</span>
02032 <span class="comment">        function.</span>
02033 <span class="comment"></span>
02034 <span class="comment">    FunctionEntry - Supplies the address of the function table entry for the</span>
02035 <span class="comment">        specified function.</span>
02036 <span class="comment"></span>
02037 <span class="comment">    ContextRecord - Supplies the address of a context record.</span>
02038 <span class="comment"></span>
02039 <span class="comment">    InFunction - Supplies a pointer to a variable that receives whether the</span>
02040 <span class="comment">        control PC is within the current function.</span>
02041 <span class="comment"></span>
02042 <span class="comment">    EstablisherFrame - Supplies a pointer to a variable that receives the</span>
02043 <span class="comment">        the establisher frame pointer value.</span>
02044 <span class="comment"></span>
02045 <span class="comment">    ContextPointers - Supplies an optional pointer to a context pointers</span>
02046 <span class="comment">        record.</span>
02047 <span class="comment"></span>
02048 <span class="comment">Return Value:</span>
02049 <span class="comment"></span>
02050 <span class="comment">    The address where control left the previous frame is returned as the</span>
02051 <span class="comment">    function value.</span>
02052 <span class="comment"></span>
02053 <span class="comment">--*/</span>
02054 
02055 {
02056 
02057     CONTEXT LocalContext;
02058 
02059     <span class="comment">//</span>
02060     <span class="comment">// Copy the context record so updates will not be reflected in the</span>
02061     <span class="comment">// original copy and then virtually unwind to the caller of the</span>
02062     <span class="comment">// specified control point.</span>
02063     <span class="comment">//</span>
02064 
02065     RtlMoveMemory((PVOID)&amp;LocalContext, ContextRecord, <span class="keyword">sizeof</span>(CONTEXT));
02066     <span class="keywordflow">return</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a38">RtlVirtualUnwind</a>(ControlPc | 1,
02067                             FunctionEntry,
02068                             &amp;LocalContext,
02069                             InFunction,
02070                             EstablisherFrame,
02071                             ContextPointers);
02072 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:39:57 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
