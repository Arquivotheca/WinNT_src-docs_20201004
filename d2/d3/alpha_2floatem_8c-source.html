<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: floatem.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>floatem.c</h1><a href="../../d1/d4/alpha_2floatem_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1991  Microsoft Corporation</span>
00004 <span class="comment">Copyright (c) 1993  Digital Equipment Corporation</span>
00005 <span class="comment"></span>
00006 <span class="comment">Module Name:</span>
00007 <span class="comment"></span>
00008 <span class="comment">    floatem.c</span>
00009 <span class="comment"></span>
00010 <span class="comment">Abstract:</span>
00011 <span class="comment"></span>
00012 <span class="comment">    This module implements a software emulation of the IEEE single and</span>
00013 <span class="comment">    double floating operations. It is required on Alpha processors since</span>
00014 <span class="comment">    the hardware does not fully support all of the operations required</span>
00015 <span class="comment">    by the IEEE standard. In particular, infinities and NaNs are not</span>
00016 <span class="comment">    handled by the hardware, but rather cause an exception. On receipt</span>
00017 <span class="comment">    of the exception, a software emulation of the floating operation</span>
00018 <span class="comment">    is performed to determine the real result of the operation and if</span>
00019 <span class="comment">    an exception will actually be raised.</span>
00020 <span class="comment"></span>
00021 <span class="comment">    This code is also used to perform all floating operations on EV4</span>
00022 <span class="comment">    processors when plus or minus infinity rounding is used.</span>
00023 <span class="comment"></span>
00024 <span class="comment">    Since floating exceptions are rather rare events, this routine is</span>
00025 <span class="comment">    written in C. Should a higher performance implementation be required,</span>
00026 <span class="comment">    then the algorithms contained herein, can be used to guide a higher</span>
00027 <span class="comment">    performance assembly language implementation.</span>
00028 <span class="comment"></span>
00029 <span class="comment">    N.B. This routine does not emulate floating loads, floating stores,</span>
00030 <span class="comment">         control to/from floating, or move to/from floating instructions.</span>
00031 <span class="comment">         These instructions never require emulation.</span>
00032 <span class="comment"></span>
00033 <span class="comment">    Floating point operations are carried out by unpacking the operands,</span>
00034 <span class="comment">    normalizing denormalized numbers, checking for NaNs, interpreting</span>
00035 <span class="comment">    infinities, and computing results.</span>
00036 <span class="comment"></span>
00037 <span class="comment">    Floating operands are converted to a format that has a value with the</span>
00038 <span class="comment">    appropriate number of leading zeros, an overflow bit, the mantissa, a</span>
00039 <span class="comment">    guard bit, a round bit, and a set of sticky bits. The unpacked mantissa</span>
00040 <span class="comment">    includes the hidden bit.</span>
00041 <span class="comment"></span>
00042 <span class="comment">    The overflow bit is needed for addition and is also used for multiply.</span>
00043 <span class="comment">    The mantissa is 24-bits for single operations and 53-bits for double</span>
00044 <span class="comment">    operations. The guard bit and round bit are used to hold precise values</span>
00045 <span class="comment">    for normalization and rounding.</span>
00046 <span class="comment"></span>
00047 <span class="comment">    If the result of an operation is normalized, then the guard bit becomes</span>
00048 <span class="comment">    the round bit and the round bit is accumulated with the sticky bits. If</span>
00049 <span class="comment">    the result of an operation needs to be shifted left one bit for purposes</span>
00050 <span class="comment">    of normalization, then the guard bit becomes part of the mantissa and the</span>
00051 <span class="comment">    round bit is used for rounding.</span>
00052 <span class="comment"></span>
00053 <span class="comment">    The round bit plus the sticky bits are used to determine how rounding is</span>
00054 <span class="comment">    performed.</span>
00055 <span class="comment"></span>
00056 <span class="comment">Author:</span>
00057 <span class="comment"></span>
00058 <span class="comment">    David N. Cutler (davec) 16-Jun-1991</span>
00059 <span class="comment"></span>
00060 <span class="comment">Environment:</span>
00061 <span class="comment"></span>
00062 <span class="comment">    Kernel mode only.</span>
00063 <span class="comment"></span>
00064 <span class="comment">Revision History:</span>
00065 <span class="comment"></span>
00066 <span class="comment">    Thomas Van Baak (tvb) 12-Sep-1992</span>
00067 <span class="comment"></span>
00068 <span class="comment">        Adapted for Alpha AXP.</span>
00069 <span class="comment"></span>
00070 <span class="comment">    Nigel Haslock (haslock) 20-Apr-1995</span>
00071 <span class="comment"></span>
00072 <span class="comment">        Adjustments for additional EV4.5 and EV5 functionality</span>
00073 <span class="comment"></span>
00074 <span class="comment">    Kim Peterson (peterson) 4-Feb-1998</span>
00075 <span class="comment"></span>
00076 <span class="comment">        Corrections for denormal and double precision denormal processing.</span>
00077 <span class="comment">        Rounds denormal after shifting it into denormal format.</span>
00078 <span class="comment">        Preserves first operand NAN if second operand is not a NAN</span>
00079 <span class="comment">        (single precision was already correct).</span>
00080 <span class="comment"></span>
00081 <span class="comment">--*/</span>
00082 
00083 <span class="preprocessor">#include "<a class="code" href="../../d0/d0/ki_8h.html">ki.h</a>"</span>
00084 <span class="preprocessor">#pragma hdrstop</span>
00085 <span class="preprocessor"></span><span class="preprocessor">#include "alphaops.h"</span>
00086 
00087 <span class="preprocessor">#if DBG</span>
00088 <span class="preprocessor"></span>
00089 <span class="keyword">extern</span> ULONG RtlDebugFlags;
00090 <span class="preprocessor">#define DBGPRINT  ((RtlDebugFlags &amp; 0x4) != 0) &amp;&amp; DbgPrint</span>
00091 <span class="preprocessor"></span><span class="preprocessor">#define DBGPRINT2 ((RtlDebugFlags &amp; 0x8) != 0) &amp;&amp; DbgPrint</span>
00092 <span class="preprocessor"></span>
00093 <span class="preprocessor">#else</span>
00094 <span class="preprocessor"></span>
<a name="l00095"></a><a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a0">00095</a> <span class="preprocessor">#define DBGPRINT  0 &amp;&amp; DbgPrint</span>
<a name="l00096"></a><a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a1">00096</a> <span class="preprocessor"></span><span class="preprocessor">#define DBGPRINT2 0 &amp;&amp; DbgPrint</span>
00097 <span class="preprocessor"></span>
00098 <span class="preprocessor">#endif</span>
00099 <span class="preprocessor"></span>
<a name="l00100"></a><a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a2">00100</a> <span class="preprocessor">#define LOW_PART(Quad) ((ULONG)(Quad))</span>
<a name="l00101"></a><a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a3">00101</a> <span class="preprocessor"></span><span class="preprocessor">#define HIGH_PART(Quad) ((ULONG)(Quad &gt;&gt; 32))</span>
<a name="l00102"></a><a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a4">00102</a> <span class="preprocessor"></span><span class="preprocessor">#define MAKE_QUAD(Low, High) (((ULONGLONG)(High)) &lt;&lt; 32 | ((ULONGLONG)(Low)))</span>
00103 <span class="preprocessor"></span>
00104 <span class="comment">//</span>
00105 <span class="comment">// The hardware recognizes the new CVTST instruction by the kludged</span>
00106 <span class="comment">// opcode function 16.2ac instead of the proper 16.00e (per ECO #46).</span>
00107 <span class="comment">//</span>
00108 
<a name="l00109"></a><a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a5">00109</a> <span class="preprocessor">#define CVTST_FUNC_PROPER 0x00E</span>
00110 <span class="preprocessor"></span>
00111 <span class="comment">//</span>
00112 <span class="comment">// Define unpacked format NaN mask values and boolean macros.</span>
00113 <span class="comment">//</span>
00114 <span class="comment">// N.B. The NaN bit is set for a quiet NaN and reset for a signaling NaN.</span>
00115 <span class="comment">//      This is the same as Intel, Sun, IBM and opposite of Mips, HP.</span>
00116 <span class="comment">//</span>
00117 
<a name="l00118"></a><a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a6">00118</a> <span class="preprocessor">#define DOUBLE_NAN_BIT_HIGH (1 &lt;&lt; (53 - 32))</span>
<a name="l00119"></a><a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a7">00119</a> <span class="preprocessor"></span><span class="preprocessor">#define SINGLE_NAN_BIT (1 &lt;&lt; 24)</span>
00120 <span class="preprocessor"></span>
<a name="l00121"></a><a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a8">00121</a> <span class="preprocessor">#define DoubleSignalNan(DoubleOperand) \</span>
00122 <span class="preprocessor">    (((DoubleOperand)-&gt;Nan != FALSE) &amp;&amp; \</span>
00123 <span class="preprocessor">     (((DoubleOperand)-&gt;MantissaHigh &amp; DOUBLE_NAN_BIT_HIGH) == 0))</span>
00124 <span class="preprocessor"></span>
<a name="l00125"></a><a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a9">00125</a> <span class="preprocessor">#define DoubleQuietNan(DoubleOperand) \</span>
00126 <span class="preprocessor">    (((DoubleOperand)-&gt;Nan != FALSE) &amp;&amp; \</span>
00127 <span class="preprocessor">     (((DoubleOperand)-&gt;MantissaHigh &amp; DOUBLE_NAN_BIT_HIGH) != 0))</span>
00128 <span class="preprocessor"></span>
<a name="l00129"></a><a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a10">00129</a> <span class="preprocessor">#define SingleSignalNan(SingleOperand) \</span>
00130 <span class="preprocessor">    (((SingleOperand)-&gt;Nan != FALSE) &amp;&amp; \</span>
00131 <span class="preprocessor">     (((SingleOperand)-&gt;Mantissa &amp; SINGLE_NAN_BIT) == 0))</span>
00132 <span class="preprocessor"></span>
<a name="l00133"></a><a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a11">00133</a> <span class="preprocessor">#define SingleQuietNan(SingleOperand) \</span>
00134 <span class="preprocessor">    (((SingleOperand)-&gt;Nan != FALSE) &amp;&amp; \</span>
00135 <span class="preprocessor">     (((SingleOperand)-&gt;Mantissa &amp; SINGLE_NAN_BIT) != 0))</span>
00136 <span class="preprocessor"></span>
00137 <span class="comment">//</span>
00138 <span class="comment">// Define context block structure.</span>
00139 <span class="comment">//</span>
00140 
<a name="l00141"></a><a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html">00141</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html">_FP_CONTEXT_BLOCK</a> {
<a name="l00142"></a><a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o0">00142</a>     ULONG <a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o0">Fc</a>;
00143     PEXCEPTION_RECORD <a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o1">ExceptionRecord</a>;
00144     PKEXCEPTION_FRAME <a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o2">ExceptionFrame</a>;
00145     PKTRAP_FRAME <a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o3">TrapFrame</a>;
<a name="l00146"></a><a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o4">00146</a>     PSW_FPCR <a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o4">SoftwareFpcr</a>;
00147     ULONG <a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o5">Round</a>;
<a name="l00148"></a><a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o6">00148</a>     BOOLEAN <a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o6">IeeeMode</a>;
<a name="l00149"></a><a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o7">00149</a>     BOOLEAN <a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o7">UnderflowEnable</a>;
00150 } <a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html">FP_CONTEXT_BLOCK</a>, *<a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html">PFP_CONTEXT_BLOCK</a>;
00151 
00152 <span class="comment">//</span>
00153 <span class="comment">// Define single and double operand value structures.</span>
00154 <span class="comment">//</span>
00155 
<a name="l00156"></a><a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html">00156</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html">_FP_DOUBLE_OPERAND</a> {
00157     LONG <a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a>;
00158     ULONG <a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a>;
00159     LONGLONG <a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o2">Mantissa</a>;                  <span class="comment">// ## Not fully used yet</span>
00160     LONG <a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a>;
00161     LONG <a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a>;
00162     BOOLEAN <a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o5">Infinity</a>;
00163     BOOLEAN <a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o6">Nan</a>;
<a name="l00164"></a><a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o7">00164</a>     BOOLEAN <a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o7">Normal</a>;
00165 } <a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html">FP_DOUBLE_OPERAND</a>, *<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html">PFP_DOUBLE_OPERAND</a>;
00166 
<a name="l00167"></a><a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html">00167</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html">_FP_SINGLE_OPERAND</a> {
00168     LONG <a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a>;
00169     LONG <a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">Exponent</a>;
00170     LONG <a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a>;
00171     BOOLEAN <a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o3">Infinity</a>;
00172     BOOLEAN <a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o4">Nan</a>;
<a name="l00173"></a><a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o5">00173</a>     BOOLEAN <a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o5">Normal</a>;
00174 } <a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html">FP_SINGLE_OPERAND</a>, *<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html">PFP_SINGLE_OPERAND</a>;
00175 
00176 <span class="comment">//</span>
00177 <span class="comment">// Define single and double IEEE floating point memory formats.</span>
00178 <span class="comment">//</span>
00179 
<a name="l00180"></a><a class="code" href="../../d5/d8/struct__DOUBLE__FORMAT.html">00180</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d5/d8/struct__DOUBLE__FORMAT.html">_DOUBLE_FORMAT</a> {
<a name="l00181"></a><a class="code" href="../../d5/d8/struct__DOUBLE__FORMAT.html#o0">00181</a>     ULONGLONG <a class="code" href="../../d5/d8/struct__DOUBLE__FORMAT.html#o0">Mantissa</a> : 52;
<a name="l00182"></a><a class="code" href="../../d5/d8/struct__DOUBLE__FORMAT.html#o1">00182</a>     ULONGLONG <a class="code" href="../../d5/d8/struct__DOUBLE__FORMAT.html#o1">Exponent</a> : 11;
<a name="l00183"></a><a class="code" href="../../d5/d8/struct__DOUBLE__FORMAT.html#o2">00183</a>     ULONGLONG <a class="code" href="../../d5/d8/struct__DOUBLE__FORMAT.html#o2">Sign</a> : 1;
00184 } <a class="code" href="../../d5/d8/struct__DOUBLE__FORMAT.html">DOUBLE_FORMAT</a>, *<a class="code" href="../../d5/d8/struct__DOUBLE__FORMAT.html">PDOUBLE_FORMAT</a>;
00185 
<a name="l00186"></a><a class="code" href="../../d4/d3/struct__SINGLE__FORMAT.html">00186</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d4/d3/struct__SINGLE__FORMAT.html">_SINGLE_FORMAT</a> {
<a name="l00187"></a><a class="code" href="../../d4/d3/struct__SINGLE__FORMAT.html#o0">00187</a>     ULONG <a class="code" href="../../d4/d3/struct__SINGLE__FORMAT.html#o0">Mantissa</a> : 23;
<a name="l00188"></a><a class="code" href="../../d4/d3/struct__SINGLE__FORMAT.html#o1">00188</a>     ULONG <a class="code" href="../../d4/d3/struct__SINGLE__FORMAT.html#o1">Exponent</a> : 8;
<a name="l00189"></a><a class="code" href="../../d4/d3/struct__SINGLE__FORMAT.html#o2">00189</a>     ULONG <a class="code" href="../../d4/d3/struct__SINGLE__FORMAT.html#o2">Sign</a> : 1;
00190 } <a class="code" href="../../d4/d3/struct__SINGLE__FORMAT.html">SINGLE_FORMAT</a>, *<a class="code" href="../../d4/d3/struct__SINGLE__FORMAT.html">PSINGLE_FORMAT</a>;
00191 
00192 <span class="comment">//</span>
00193 <span class="comment">// Define forward referenced function prototypes.</span>
00194 <span class="comment">//</span>
00195 
00196 ULONGLONG
00197 <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a22">KiConvertSingleOperandToRegister</a> (
00198     IN ULONG SingleValue
00199     );
00200 
00201 ULONG
00202 <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a23">KiConvertRegisterToSingleOperand</a> (
00203     IN ULONGLONG DoubleValue
00204     );
00205 
00206 BOOLEAN
00207 <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a24">KiConvertQuadwordToLongword</a> (
00208     IN PFP_CONTEXT_BLOCK ContextBlock,
00209     IN LONGLONG Quadword
00210     );
00211 
00212 BOOLEAN
00213 <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a16">KiDivideByZeroDouble</a> (
00214     IN PFP_CONTEXT_BLOCK ContextBlock,
00215     IN PFP_DOUBLE_OPERAND DoubleOperand1,
00216     IN PFP_DOUBLE_OPERAND DoubleOperand2
00217     );
00218 
00219 BOOLEAN
00220 <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a17">KiDivideByZeroSingle</a> (
00221     IN PFP_CONTEXT_BLOCK ContextBlock,
00222     IN PFP_SINGLE_OPERAND SingleOperand1,
00223     IN PFP_SINGLE_OPERAND SingleOperand2
00224     );
00225 
00226 PFP_IEEE_VALUE
00227 <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a27">KiInitializeIeeeValue</a> (
00228     IN PEXCEPTION_RECORD ExceptionRecord
00229     );
00230 
00231 BOOLEAN
00232 <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a18">KiInvalidCompareDouble</a> (
00233     IN PFP_CONTEXT_BLOCK ContextBlock,
00234     IN BOOLEAN CheckForSignalNan,
00235     IN PFP_DOUBLE_OPERAND DoubleOperand1,
00236     IN PFP_DOUBLE_OPERAND DoubleOperand2
00237     );
00238 
00239 BOOLEAN
00240 <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a20">KiInvalidOperationDouble</a> (
00241     IN PFP_CONTEXT_BLOCK ContextBlock,
00242     IN BOOLEAN CheckForSignalNan,
00243     IN PFP_DOUBLE_OPERAND DoubleOperand1,
00244     IN PFP_DOUBLE_OPERAND DoubleOperand2
00245     );
00246 
00247 BOOLEAN
00248 <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a22">KiInvalidOperationQuadword</a> (
00249     IN PFP_CONTEXT_BLOCK ContextBlock,
00250     IN ULONGLONG ResultValue
00251     );
00252 
00253 BOOLEAN
00254 <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a23">KiInvalidOperationSingle</a> (
00255     IN PFP_CONTEXT_BLOCK ContextBlock,
00256     IN BOOLEAN CheckForSignalNan,
00257     IN PFP_SINGLE_OPERAND SingleOperand1,
00258     IN PFP_SINGLE_OPERAND SingleOperand2
00259     );
00260 
00261 BOOLEAN
00262 <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a24">KiNormalizeDouble</a> (
00263     IN PFP_CONTEXT_BLOCK ContextBlock,
00264     IN PFP_DOUBLE_OPERAND ResultOperand,
00265     IN ULONGLONG StickyBits
00266     );
00267 
00268 BOOLEAN
00269 <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a26">KiNormalizeQuadword</a> (
00270     IN PFP_CONTEXT_BLOCK ContextBlock,
00271     IN PFP_DOUBLE_OPERAND ResultOperand
00272     );
00273 
00274 BOOLEAN
00275 <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a27">KiNormalizeSingle</a> (
00276     IN PFP_CONTEXT_BLOCK ContextBlock,
00277     IN PFP_SINGLE_OPERAND ResultOperand,
00278     IN ULONG StickyBits
00279     );
00280 
00281 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00282 <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a30">KiUnpackDouble</a> (
00283     IN ULONG Source,
00284     IN PFP_CONTEXT_BLOCK ContextBlock,
00285     OUT PFP_DOUBLE_OPERAND DoubleOperand
00286     );
00287 
00288 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00289 <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a31">KiUnpackSingle</a> (
00290     IN ULONG Source,
00291     IN PFP_CONTEXT_BLOCK ContextBlock,
00292     OUT PFP_SINGLE_OPERAND SingleOperand
00293     );
00294 
00295 BOOLEAN
<a name="l00296"></a><a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a37">00296</a> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a32">KiEmulateFloating</a> (
00297     IN OUT PEXCEPTION_RECORD ExceptionRecord,
00298     IN OUT PKEXCEPTION_FRAME ExceptionFrame,
00299     IN OUT PKTRAP_FRAME TrapFrame,
00300     IN OUT PSW_FPCR SoftwareFpcr
00301     )
00302 
00303 <span class="comment">/*++</span>
00304 <span class="comment"></span>
00305 <span class="comment">Routine Description:</span>
00306 <span class="comment"></span>
00307 <span class="comment">    This function is called to emulate a floating operation and convert the</span>
00308 <span class="comment">    exception status to the proper value. If the exception is an unimplemented</span>
00309 <span class="comment">    operation, then the operation is emulated. Otherwise, the status code is</span>
00310 <span class="comment">    just converted to its proper value.</span>
00311 <span class="comment"></span>
00312 <span class="comment">Arguments:</span>
00313 <span class="comment"></span>
00314 <span class="comment">    ExceptionRecord - Supplies a pointer to an exception record.</span>
00315 <span class="comment"></span>
00316 <span class="comment">    ExceptionFrame - Supplies a pointer to an exception frame.</span>
00317 <span class="comment"></span>
00318 <span class="comment">    TrapFrame - Supplies a pointer to a trap frame.</span>
00319 <span class="comment"></span>
00320 <span class="comment">    SoftwareFpcr - Supplies a pointer to a variable that contains a copy of</span>
00321 <span class="comment">        the software FPCR.</span>
00322 <span class="comment"></span>
00323 <span class="comment">Return Value:</span>
00324 <span class="comment"></span>
00325 <span class="comment">    A value of TRUE is returned if the floating exception is successfully</span>
00326 <span class="comment">    emulated. Otherwise, a value of FALSE is returned.</span>
00327 <span class="comment"></span>
00328 <span class="comment">--*/</span>
00329 
00330 {
00331 
00332     ULARGE_INTEGER AhighBhigh;
00333     ULARGE_INTEGER AhighBlow;
00334     ULARGE_INTEGER AlowBhigh;
00335     ULARGE_INTEGER AlowBlow;
00336     ULONG Carry1;
00337     ULONG Carry2;
00338     BOOLEAN CompareEqual;
00339     BOOLEAN CompareLess;
00340     BOOLEAN CompareResult;
00341     <a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html">FP_CONTEXT_BLOCK</a> ContextBlock;
00342     LARGE_INTEGER DoubleDividend;
00343     LARGE_INTEGER DoubleDivisor;
00344     ULONG DoubleMantissaLow;
00345     LONG DoubleMantissaHigh;
00346     <a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html">FP_DOUBLE_OPERAND</a> DoubleOperand1;
00347     <a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html">FP_DOUBLE_OPERAND</a> DoubleOperand2;
00348     <a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html">FP_DOUBLE_OPERAND</a> DoubleOperand3;
00349     LARGE_INTEGER DoubleQuotient;
00350     PVOID ExceptionAddress;
00351     ULONG ExponentDifference;
00352     ULONG Fa;
00353     ULONG Fb;
00354     ULONG Function;
00355     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
00356     ALPHA_INSTRUCTION Instruction;
00357     ULARGE_INTEGER LargeResult;
00358     LONG Negation;
00359     LONGLONG Quadword;
00360     LONG SingleMantissa;
00361     <a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html">FP_SINGLE_OPERAND</a> SingleOperand1;
00362     <a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html">FP_SINGLE_OPERAND</a> SingleOperand2;
00363     <a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html">FP_SINGLE_OPERAND</a> SingleOperand3;
00364     ULONG StickyBits;
00365     BOOLEAN ValidOperation;
00366 
00367     <span class="comment">//</span>
00368     <span class="comment">// Save the original exception address in case another exception</span>
00369     <span class="comment">// occurs.</span>
00370     <span class="comment">//</span>
00371 
00372     ExceptionAddress = ExceptionRecord-&gt;ExceptionAddress;
00373 
00374     <span class="comment">//</span>
00375     <span class="comment">// Any exception that occurs during the attempted emulation of the</span>
00376     <span class="comment">// floating operation causes the emulation to be aborted. The new</span>
00377     <span class="comment">// exception code and information is copied to the original exception</span>
00378     <span class="comment">// record and a value of FALSE is returned.</span>
00379     <span class="comment">//</span>
00380 
00381     <span class="keywordflow">try</span> {
00382 
00383         <span class="comment">//</span>
00384         <span class="comment">// Fetch the faulting or trapping instruction. Check the opcode and</span>
00385         <span class="comment">// function code (including the trap enable bits) for IEEE floating</span>
00386         <span class="comment">// point operations that are expected to be emulated.</span>
00387         <span class="comment">//</span>
00388         <span class="comment">// N.B. Only a subset of the 2048 possible combinations of 11 bits</span>
00389         <span class="comment">//      in the function field are valid. A total of 88 functions</span>
00390         <span class="comment">//      are affected by missing plus and minus infinity rounding</span>
00391         <span class="comment">//      mode support in the EV4 chip.</span>
00392         <span class="comment">//</span>
00393 
00394         Instruction = *((PALPHA_INSTRUCTION)ExceptionRecord-&gt;ExceptionAddress);
00395         <a class="code" href="../../d6/d5/ioep_8h.html#a21">DBGPRINT</a>(<span class="stringliteral">"KiEmulateFloating: Instruction = %.8lx, Fpcr = %.16Lx\n"</span>,
00396                  Instruction.Long, TrapFrame-&gt;Fpcr);
00397         Function = Instruction.FpOp.Function;
00398 
00399         ValidOperation = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00400         <span class="keywordflow">if</span> (Instruction.FpOp.Opcode == IEEEFP_OP) {
00401 
00402             <span class="comment">//</span>
00403             <span class="comment">// Adjust the function code if the instruction is CVTST.</span>
00404             <span class="comment">//</span>
00405 
00406             <span class="keywordflow">if</span> (Function == CVTST_FUNC) {
00407                 Function = <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a5">CVTST_FUNC_PROPER</a>;
00408 
00409             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Function == CVTST_S_FUNC) {
00410                 Function = <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a5">CVTST_FUNC_PROPER</a> | FP_TRAP_ENABLE_S;
00411             }
00412 
00413             <span class="keywordflow">switch</span> (Function &amp; FP_FUNCTION_MASK) {
00414             <span class="keywordflow">case</span> ADDS_FUNC :
00415             <span class="keywordflow">case</span> SUBS_FUNC :
00416             <span class="keywordflow">case</span> MULS_FUNC :
00417             <span class="keywordflow">case</span> DIVS_FUNC :
00418             <span class="keywordflow">case</span> ADDT_FUNC :
00419             <span class="keywordflow">case</span> SUBT_FUNC :
00420             <span class="keywordflow">case</span> MULT_FUNC :
00421             <span class="keywordflow">case</span> DIVT_FUNC :
00422             <span class="keywordflow">case</span> CVTTQ_FUNC :
00423             <span class="keywordflow">case</span> CVTTS_FUNC :
00424 
00425                 <span class="keywordflow">switch</span> (Function &amp; FP_TRAP_ENABLE_MASK) {
00426                 <span class="keywordflow">case</span> FP_TRAP_ENABLE_NONE :
00427                 <span class="keywordflow">case</span> FP_TRAP_ENABLE_U :
00428                 <span class="keywordflow">case</span> FP_TRAP_ENABLE_SU :
00429                 <span class="keywordflow">case</span> FP_TRAP_ENABLE_SUI :
00430 
00431                     ValidOperation = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00432                     <span class="keywordflow">break</span>;
00433                 }
00434                 <span class="keywordflow">break</span>;
00435 
00436             <span class="keywordflow">case</span> CVTQS_FUNC :
00437             <span class="keywordflow">case</span> CVTQT_FUNC :
00438 
00439                 <span class="keywordflow">switch</span> (Function &amp; FP_TRAP_ENABLE_MASK) {
00440                 <span class="keywordflow">case</span> FP_TRAP_ENABLE_NONE :
00441                 <span class="keywordflow">case</span> FP_TRAP_ENABLE_SUI :
00442 
00443                     ValidOperation = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00444                     <span class="keywordflow">break</span>;
00445                 }
00446                 <span class="keywordflow">break</span>;
00447 
00448             <span class="keywordflow">case</span> <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a5">CVTST_FUNC_PROPER</a> :
00449 
00450                 <span class="keywordflow">switch</span> (Function &amp; FP_TRAP_ENABLE_MASK) {
00451                 <span class="keywordflow">case</span> FP_TRAP_ENABLE_NONE :
00452                 <span class="keywordflow">case</span> FP_TRAP_ENABLE_S :
00453 
00454                     ValidOperation = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00455                     <span class="keywordflow">break</span>;
00456                 }
00457                 <span class="keywordflow">break</span>;
00458 
00459             <span class="keywordflow">case</span> CMPTEQ_FUNC :
00460             <span class="keywordflow">case</span> CMPTLE_FUNC :
00461             <span class="keywordflow">case</span> CMPTLT_FUNC :
00462             <span class="keywordflow">case</span> CMPTUN_FUNC :
00463 
00464                 ValidOperation = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00465                 <span class="keywordflow">break</span>;
00466             }
00467 
00468         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Instruction.FpOp.Opcode == FPOP_OP) {
00469             <span class="keywordflow">switch</span> (Function) {
00470             <span class="keywordflow">case</span> CVTLQ_FUNC :
00471             <span class="keywordflow">case</span> CVTQL_FUNC :
00472             <span class="keywordflow">case</span> CVTQLV_FUNC :
00473             <span class="keywordflow">case</span> CVTQLSV_FUNC :
00474 
00475                 ValidOperation = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00476                 <span class="keywordflow">break</span>;
00477             }
00478         }
00479 
00480         <span class="keywordflow">if</span> (ValidOperation == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
00481 
00482             <span class="comment">//</span>
00483             <span class="comment">// An illegal instruction, function code, format value, or trap</span>
00484             <span class="comment">// enable value was encountered. Generate an illegal instruction</span>
00485             <span class="comment">// exception.</span>
00486             <span class="comment">//</span>
00487 
00488             ExceptionRecord-&gt;ExceptionCode = STATUS_ILLEGAL_INSTRUCTION;
00489             <a class="code" href="../../d6/d5/ioep_8h.html#a21">DBGPRINT</a>(<span class="stringliteral">"KiEmulateFloating: Invalid Function or Format\n"</span>);
00490             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00491         }
00492 
00493         <span class="comment">//</span>
00494         <span class="comment">// Increment the floating emulation count.</span>
00495         <span class="comment">//</span>
00496 
00497         <a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a2">KeGetCurrentPrcb</a>()-&gt;KeFloatingEmulationCount += 1;
00498 
00499         <span class="comment">//</span>
00500         <span class="comment">// Initialize the address of the exception record, exception frame,</span>
00501         <span class="comment">// and trap frame in the context block used during the emulation of</span>
00502         <span class="comment">// the floating point operation.</span>
00503         <span class="comment">//</span>
00504         <span class="comment">// N.B. The SoftwareFpcr and IEEE exception records are only used</span>
00505         <span class="comment">//      with IEEE mode instructions.</span>
00506         <span class="comment">//</span>
00507 
00508         ContextBlock.<a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o1">ExceptionRecord</a> = ExceptionRecord;
00509         ContextBlock.<a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o2">ExceptionFrame</a> = ExceptionFrame;
00510         ContextBlock.<a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o3">TrapFrame</a> = TrapFrame;
00511         ContextBlock.<a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o4">SoftwareFpcr</a> = SoftwareFpcr;
00512 
00513         <span class="comment">//</span>
00514         <span class="comment">// Check if the /S bit is set in the instruction. This bit is always</span>
00515         <span class="comment">// set in the case of a trigger instruction of an asynchronous trap</span>
00516         <span class="comment">// (assuming valid trap shadow) but not necessarily always set in the</span>
00517         <span class="comment">// case of an unimplemented floating instruction fault.</span>
00518         <span class="comment">//</span>
00519 
00520         <span class="keywordflow">if</span> ((Function &amp; FP_TRAP_ENABLE_S) != 0) {
00521             ContextBlock.<a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o6">IeeeMode</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00522 
00523         } <span class="keywordflow">else</span> {
00524             ContextBlock.<a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o6">IeeeMode</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00525         }
00526 
00527         <span class="keywordflow">if</span> ((Function &amp; FP_TRAP_ENABLE_U) != 0) {
00528             ContextBlock.<a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o7">UnderflowEnable</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00529 
00530         } <span class="keywordflow">else</span> {
00531             ContextBlock.<a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o7">UnderflowEnable</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00532         }
00533 
00534         <span class="comment">//</span>
00535         <span class="comment">// Set the current rounding mode from the rounding mode specified in</span>
00536         <span class="comment">// the instruction, or if dynamic rounding is specified, from the</span>
00537         <span class="comment">// rounding mode specified in the FPCR.</span>
00538         <span class="comment">// Set the emulation flag and emulate the floating point operation.</span>
00539         <span class="comment">// The return value is dependent on the results of the emulation.</span>
00540         <span class="comment">//</span>
00541 
00542         ContextBlock.<a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o0">Fc</a> = Instruction.FpOp.Fc;
00543         Fa = Instruction.FpOp.Fa;
00544         Fb = Instruction.FpOp.Fb;
00545 
00546         <span class="keywordflow">if</span> ((Function &amp; FP_ROUND_MASK) == FP_ROUND_D) {
00547             ContextBlock.<a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o5">Round</a> = ((PFPCR)&amp;TrapFrame-&gt;Fpcr)-&gt;DynamicRoundingMode;
00548 
00549         } <span class="keywordflow">else</span> {
00550             ContextBlock.<a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o5">Round</a> = (Function &amp; FP_ROUND_MASK) &gt;&gt; FP_ROUND_SHIFT;
00551         }
00552 
00553         SoftwareFpcr-&gt;EmulationOccurred = 1;
00554 
00555         <span class="comment">//</span>
00556         <span class="comment">// Unpack operands and dispense with NaNs.</span>
00557         <span class="comment">//</span>
00558 
00559         <span class="keywordflow">switch</span> (Function &amp; FP_FUNCTION_MASK) {
00560         <span class="keywordflow">case</span> ADDS_FUNC :
00561         <span class="keywordflow">case</span> SUBS_FUNC :
00562         <span class="keywordflow">case</span> MULS_FUNC :
00563         <span class="keywordflow">case</span> DIVS_FUNC :
00564 
00565             <span class="comment">//</span>
00566             <span class="comment">// The function has two single operand values.</span>
00567             <span class="comment">//</span>
00568 
00569             <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a31">KiUnpackSingle</a>(Fa, &amp;ContextBlock, &amp;SingleOperand1);
00570             <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a31">KiUnpackSingle</a>(Fb, &amp;ContextBlock, &amp;SingleOperand2);
00571 
00572             <span class="comment">//</span>
00573             <span class="comment">// Non-IEEE mode operate instructions trap on NaN, infinity, or</span>
00574             <span class="comment">// denormal operands.</span>
00575             <span class="comment">//</span>
00576 
00577             <span class="keywordflow">if</span> ((ContextBlock.<a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o6">IeeeMode</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
00578                 ((SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o5">Normal</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) ||
00579                  (SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o5">Normal</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>))) {
00580                 ExceptionRecord-&gt;ExceptionCode = STATUS_FLOAT_INVALID_OPERATION;
00581                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00582             }
00583 
00584             <span class="keywordflow">if</span> ((SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o4">Nan</a> != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) || (SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o4">Nan</a> != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>)) {
00585 
00586                 <span class="comment">//</span>
00587                 <span class="comment">// Store a quiet NaN if the invalid operation trap</span>
00588                 <span class="comment">// is disabled, or raise an exception if the invalid</span>
00589                 <span class="comment">// operation trap is enabled and either of the NaNs</span>
00590                 <span class="comment">// is a signaling NaN.</span>
00591                 <span class="comment">//</span>
00592 
00593                 <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a23">KiInvalidOperationSingle</a>(&amp;ContextBlock,
00594                                                 <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
00595                                                 &amp;SingleOperand1,
00596                                                 &amp;SingleOperand2);
00597             }
00598             <span class="keywordflow">break</span>;
00599 
00600         <span class="keywordflow">case</span> ADDT_FUNC :
00601         <span class="keywordflow">case</span> SUBT_FUNC :
00602         <span class="keywordflow">case</span> MULT_FUNC :
00603         <span class="keywordflow">case</span> DIVT_FUNC :
00604 
00605             <span class="comment">//</span>
00606             <span class="comment">// The function has two double operand values.</span>
00607             <span class="comment">//</span>
00608 
00609             <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a30">KiUnpackDouble</a>(Fa, &amp;ContextBlock, &amp;DoubleOperand1);
00610             <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a30">KiUnpackDouble</a>(Fb, &amp;ContextBlock, &amp;DoubleOperand2);
00611 
00612             <span class="comment">//</span>
00613             <span class="comment">// Non-IEEE mode operate instructions trap on NaN, infinity, or</span>
00614             <span class="comment">// denormal operands.</span>
00615             <span class="comment">//</span>
00616 
00617             <span class="keywordflow">if</span> ((ContextBlock.<a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o6">IeeeMode</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
00618                 ((DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o7">Normal</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) ||
00619                  (DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o7">Normal</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>))) {
00620                 ExceptionRecord-&gt;ExceptionCode = STATUS_FLOAT_INVALID_OPERATION;
00621                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00622             }
00623             <span class="keywordflow">if</span> ((DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o6">Nan</a> != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) || (DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o6">Nan</a> != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>)) {
00624 
00625                 <span class="comment">//</span>
00626                 <span class="comment">// Store a quiet NaN if the invalid operation trap</span>
00627                 <span class="comment">// is disabled, or raise an exception if the invalid</span>
00628                 <span class="comment">// operation trap is enabled and either of the NaNs</span>
00629                 <span class="comment">// is a signaling NaN.</span>
00630                 <span class="comment">//</span>
00631 
00632                 <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a20">KiInvalidOperationDouble</a>(&amp;ContextBlock,
00633                                                 <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
00634                                                 &amp;DoubleOperand1,
00635                                                 &amp;DoubleOperand2);
00636             }
00637             <span class="keywordflow">break</span>;
00638 
00639         <span class="keywordflow">case</span> CMPTEQ_FUNC :
00640         <span class="keywordflow">case</span> CMPTLE_FUNC :
00641         <span class="keywordflow">case</span> CMPTLT_FUNC :
00642         <span class="keywordflow">case</span> CMPTUN_FUNC :
00643 
00644             <span class="comment">//</span>
00645             <span class="comment">// The function has two double operand values.</span>
00646             <span class="comment">//</span>
00647 
00648             <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a30">KiUnpackDouble</a>(Fa, &amp;ContextBlock, &amp;DoubleOperand1);
00649             <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a30">KiUnpackDouble</a>(Fb, &amp;ContextBlock, &amp;DoubleOperand2);
00650 
00651             <span class="comment">//</span>
00652             <span class="comment">// Non-IEEE mode compare instructions trap on NaN or denormal</span>
00653             <span class="comment">// operands.</span>
00654             <span class="comment">//</span>
00655 
00656             <span class="keywordflow">if</span> ((ContextBlock.<a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o6">IeeeMode</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
00657                 (((DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o7">Normal</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
00658                   (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o5">Infinity</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>)) ||
00659                  ((DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o7">Normal</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
00660                   (DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o5">Infinity</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>)))) {
00661                 ExceptionRecord-&gt;ExceptionCode = STATUS_FLOAT_INVALID_OPERATION;
00662                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00663             }
00664 
00665             <span class="comment">//</span>
00666             <span class="comment">// Compare operation.</span>
00667             <span class="comment">//</span>
00668             <span class="comment">// If either operand is a NaN, then check the type of compare</span>
00669             <span class="comment">// operation to determine the result value and if an exception</span>
00670             <span class="comment">// should be raised. Otherwise, if the operation is a compare</span>
00671             <span class="comment">// unordered operation, store a false result.</span>
00672             <span class="comment">//</span>
00673 
00674             <span class="keywordflow">if</span> ((DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o6">Nan</a> != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) || (DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o6">Nan</a> != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>)) {
00675 
00676                 <span class="comment">//</span>
00677                 <span class="comment">// If the compare is an unordered compare, then store a true</span>
00678                 <span class="comment">// result (a NaN compares unordered with everything, including</span>
00679                 <span class="comment">// itself). Raise an exception if the invalid operation trap</span>
00680                 <span class="comment">// is enabled and either of the NaNs is a signaling NaN.</span>
00681                 <span class="comment">//</span>
00682                 <span class="comment">// Otherwise, if the operation is compare equal, then store a</span>
00683                 <span class="comment">// false result. Raise an exception if the invalid operation</span>
00684                 <span class="comment">// trap is enabled and either of the NaNs is a signaling NaN.</span>
00685                 <span class="comment">//</span>
00686                 <span class="comment">// Otherwise store a false result and raise an exception if</span>
00687                 <span class="comment">// the invalid operation trap is enabled.</span>
00688                 <span class="comment">//</span>
00689 
00690                 <span class="keywordflow">if</span> ((Function &amp; FP_FUNCTION_MASK) == CMPTUN_FUNC) {
00691                     <a class="code" href="../../d8/d5/ppc_2getsetrg_8c.html#a1">KiSetRegisterValue</a>(ContextBlock.<a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o0">Fc</a> + 32,
00692                                        FP_COMPARE_TRUE,
00693                                        ExceptionFrame,
00694                                        TrapFrame);
00695 
00696                     <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a18">KiInvalidCompareDouble</a>(&amp;ContextBlock,
00697                                                   <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
00698                                                   &amp;DoubleOperand1,
00699                                                   &amp;DoubleOperand2);
00700 
00701                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((Function &amp; FP_FUNCTION_MASK) == CMPTEQ_FUNC) {
00702                     <a class="code" href="../../d8/d5/ppc_2getsetrg_8c.html#a1">KiSetRegisterValue</a>(ContextBlock.<a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o0">Fc</a> + 32,
00703                                        FP_COMPARE_FALSE,
00704                                        ExceptionFrame,
00705                                        TrapFrame);
00706 
00707                     <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a18">KiInvalidCompareDouble</a>(&amp;ContextBlock,
00708                                                   <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
00709                                                   &amp;DoubleOperand1,
00710                                                   &amp;DoubleOperand2);
00711 
00712                 } <span class="keywordflow">else</span> {
00713                     <a class="code" href="../../d8/d5/ppc_2getsetrg_8c.html#a1">KiSetRegisterValue</a>(ContextBlock.<a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o0">Fc</a> + 32,
00714                                        FP_COMPARE_FALSE,
00715                                        ExceptionFrame,
00716                                        TrapFrame);
00717 
00718                     <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a18">KiInvalidCompareDouble</a>(&amp;ContextBlock,
00719                                                   <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00720                                                   &amp;DoubleOperand1,
00721                                                   &amp;DoubleOperand2);
00722                 }
00723 
00724             } <span class="keywordflow">else</span> {
00725                 <span class="keywordflow">if</span> ((Function &amp; FP_FUNCTION_MASK) == CMPTUN_FUNC) {
00726                     <a class="code" href="../../d8/d5/ppc_2getsetrg_8c.html#a1">KiSetRegisterValue</a>(ContextBlock.<a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o0">Fc</a> + 32,
00727                                        FP_COMPARE_FALSE,
00728                                        ExceptionFrame,
00729                                        TrapFrame);
00730 
00731                     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00732                 }
00733             }
00734             <span class="keywordflow">break</span>;
00735 
00736         <span class="keywordflow">case</span> <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a5">CVTST_FUNC_PROPER</a> :
00737 
00738             <span class="comment">//</span>
00739             <span class="comment">// The function has one single operand value which is found in</span>
00740             <span class="comment">// the second operand.</span>
00741             <span class="comment">//</span>
00742 
00743             <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a31">KiUnpackSingle</a>(Fb, &amp;ContextBlock, &amp;SingleOperand1);
00744 
00745             <span class="comment">//</span>
00746             <span class="comment">// Non-IEEE mode convert instructions trap on NaN, infinity, or</span>
00747             <span class="comment">// denormal operands.</span>
00748             <span class="comment">//</span>
00749 
00750             <span class="keywordflow">if</span> ((ContextBlock.<a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o6">IeeeMode</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
00751                 (SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o5">Normal</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>)) {
00752                 ExceptionRecord-&gt;ExceptionCode = STATUS_FLOAT_INVALID_OPERATION;
00753                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00754             }
00755             <span class="keywordflow">break</span>;
00756 
00757         <span class="keywordflow">case</span> CVTTQ_FUNC :
00758         <span class="keywordflow">case</span> CVTTS_FUNC :
00759 
00760             <span class="comment">//</span>
00761             <span class="comment">// The function has one double operand value which is found in</span>
00762             <span class="comment">// the second operand.</span>
00763             <span class="comment">//</span>
00764 
00765             <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a30">KiUnpackDouble</a>(Fb, &amp;ContextBlock, &amp;DoubleOperand1);
00766 
00767             <span class="comment">//</span>
00768             <span class="comment">// Non-IEEE mode convert instructions trap on NaN, infinity, or</span>
00769             <span class="comment">// denormal operands.</span>
00770             <span class="comment">//</span>
00771 
00772             <span class="keywordflow">if</span> ((ContextBlock.<a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o6">IeeeMode</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
00773                 (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o7">Normal</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>)) {
00774                 ExceptionRecord-&gt;ExceptionCode = STATUS_FLOAT_INVALID_OPERATION;
00775                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00776             }
00777             <span class="keywordflow">break</span>;
00778 
00779         <span class="keywordflow">case</span> CVTLQ_FUNC :
00780         <span class="keywordflow">case</span> CVTQL_FUNC :
00781         <span class="keywordflow">case</span> CVTQS_FUNC :
00782         <span class="keywordflow">case</span> CVTQT_FUNC :
00783 
00784             <span class="comment">//</span>
00785             <span class="comment">// The function has one quadword operand value which is found in</span>
00786             <span class="comment">// the second operand.</span>
00787             <span class="comment">//</span>
00788 
00789             Quadword = <a class="code" href="../../d8/d5/ppc_2getsetrg_8c.html#a0">KiGetRegisterValue</a>(Fb + 32,
00790                                           ContextBlock.<a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o2">ExceptionFrame</a>,
00791                                           ContextBlock.<a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o3">TrapFrame</a>);
00792             <span class="keywordflow">break</span>;
00793         }
00794 
00795         <span class="comment">//</span>
00796         <span class="comment">// Case to the proper function routine to emulate the operation.</span>
00797         <span class="comment">//</span>
00798 
00799         Negation = 0;
00800         <span class="keywordflow">switch</span> (Function &amp; FP_FUNCTION_MASK) {
00801 
00802         <span class="comment">//</span>
00803         <span class="comment">// Floating subtract operation.</span>
00804         <span class="comment">//</span>
00805         <span class="comment">// Floating subtract is accomplished by complementing the sign</span>
00806         <span class="comment">// of the second operand and then performing an add operation.</span>
00807         <span class="comment">//</span>
00808 
00809         <span class="keywordflow">case</span> SUBS_FUNC :
00810             <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a1">DBGPRINT2</a>(<span class="stringliteral">"subs\n"</span>);
00811             Negation = 0x1;
00812 
00813         <span class="comment">//</span>
00814         <span class="comment">// Floating add operation.</span>
00815         <span class="comment">//</span>
00816         <span class="comment">// Floating add is accomplished using signed magnitude addition.</span>
00817         <span class="comment">//</span>
00818         <span class="comment">// The exponent difference is calculated and the smaller number</span>
00819         <span class="comment">// is right shifted by the specified amount, but no more than</span>
00820         <span class="comment">// the width of the operand values (i.e., 26 for single and 55</span>
00821         <span class="comment">// for double). The shifted out value is saved for rounding.</span>
00822         <span class="comment">//</span>
00823         <span class="comment">// If the signs of the two operands are the same, then they</span>
00824         <span class="comment">// are added together after having performed the alignment</span>
00825         <span class="comment">// shift.</span>
00826         <span class="comment">//</span>
00827         <span class="comment">// If the signs of the two operands are different, then the</span>
00828         <span class="comment">// sign of the result is the sign of the larger operand and</span>
00829         <span class="comment">// the smaller operand is subtracted from the larger operand.</span>
00830         <span class="comment">// In order to avoid making a double level test (i.e., one on</span>
00831         <span class="comment">// the exponents, and one on the mantissas if the exponents</span>
00832         <span class="comment">// are equal), it is possible that the result of the subtract</span>
00833         <span class="comment">// could be negative (if the exponents are equal). If this</span>
00834         <span class="comment">// occurs, then the result sign and mantissa are complemented</span>
00835         <span class="comment">// to obtain the correct result.</span>
00836         <span class="comment">//</span>
00837 
00838         <span class="keywordflow">case</span> ADDS_FUNC :
00839             <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a1">DBGPRINT2</a>(<span class="stringliteral">"adds\n"</span>);
00840 
00841             <span class="comment">//</span>
00842             <span class="comment">// Complement the sign of the second operand if the operation</span>
00843             <span class="comment">// is subtraction.</span>
00844             <span class="comment">//</span>
00845 
00846             SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a> ^= Negation;
00847 
00848             <span class="comment">//</span>
00849             <span class="comment">// Reorder the operands according to their exponent value</span>
00850             <span class="comment">// so that Operand1 exponent will be &gt;= Operand2 exponent.</span>
00851             <span class="comment">//</span>
00852 
00853             <span class="keywordflow">if</span> (SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">Exponent</a> &gt; SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">Exponent</a>) {
00854                 SingleOperand3 = SingleOperand2;
00855                 SingleOperand2 = SingleOperand1;
00856                 SingleOperand1 = SingleOperand3;
00857             }
00858 
00859             <span class="comment">//</span>
00860             <span class="comment">// Compute the exponent difference and shift the smaller</span>
00861             <span class="comment">// mantissa right by the difference value or 26 which ever</span>
00862             <span class="comment">// is smaller. The bits shifted out are termed the sticky</span>
00863             <span class="comment">// bits and are used later in the rounding operation.</span>
00864             <span class="comment">//</span>
00865 
00866             ExponentDifference =
00867                 SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">Exponent</a> - SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">Exponent</a>;
00868 
00869             <span class="keywordflow">if</span> (ExponentDifference &gt; 26) {
00870                 ExponentDifference = 26;
00871             }
00872 
00873             StickyBits =
00874                     SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> &amp; ((1 &lt;&lt; ExponentDifference) - 1);
00875             SingleMantissa = SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> &gt;&gt; ExponentDifference;
00876 
00877             <span class="comment">//</span>
00878             <span class="comment">// If the operands both have the same sign, then perform the</span>
00879             <span class="comment">// operation by adding the values together. Otherwise, if the</span>
00880             <span class="comment">// operands are not infinity, perform the operation by</span>
00881             <span class="comment">// subtracting the second operand from the first operand.</span>
00882             <span class="comment">//</span>
00883 
00884             <span class="keywordflow">if</span> ((SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a> ^ SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a>) == 0) {
00885                 SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> += SingleMantissa;
00886 
00887             } <span class="keywordflow">else</span> {
00888                 <span class="keywordflow">if</span> ((SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o3">Infinity</a> != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
00889                     (SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o3">Infinity</a> != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>)) {
00890                     <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a23">KiInvalidOperationSingle</a>(&amp;ContextBlock,
00891                                                     <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00892                                                     &amp;SingleOperand1,
00893                                                     &amp;SingleOperand2);
00894 
00895                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o3">Infinity</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
00896                     <span class="keywordflow">if</span> (StickyBits != 0) {
00897                         SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> -= 1;
00898                     }
00899 
00900                     SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> -= SingleMantissa;
00901                     <span class="keywordflow">if</span> (SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> &lt; 0) {
00902                         SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> = -SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a>;
00903                         SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a> ^= 0x1;
00904                     }
00905 
00906                     <span class="comment">//</span>
00907                     <span class="comment">// If the result is exactly zero and the signs of the</span>
00908                     <span class="comment">// operands differ, then the result is plus zero except</span>
00909                     <span class="comment">// when the rounding mode is minus infinity.</span>
00910                     <span class="comment">//</span>
00911 
00912                     <span class="keywordflow">if</span> ((SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> == 0) &amp;&amp; (StickyBits == 0)) {
00913                         <span class="keywordflow">if</span> (ContextBlock.<a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o5">Round</a> == ROUND_TO_MINUS_INFINITY) {
00914                             SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a> = 0x1;
00915 
00916                         } <span class="keywordflow">else</span> {
00917                             SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a> = 0x0;
00918                         }
00919                     }
00920                 }
00921             }
00922 
00923             <span class="comment">//</span>
00924             <span class="comment">// Normalize and store the result value.</span>
00925             <span class="comment">//</span>
00926 
00927             <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a27">KiNormalizeSingle</a>(&amp;ContextBlock,
00928                                      &amp;SingleOperand1,
00929                                      StickyBits);
00930 
00931         <span class="keywordflow">case</span> SUBT_FUNC :
00932             <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a1">DBGPRINT2</a>(<span class="stringliteral">"subt\n"</span>);
00933             Negation = 0x1;
00934 
00935         <span class="keywordflow">case</span> ADDT_FUNC :
00936             <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a1">DBGPRINT2</a>(<span class="stringliteral">"addt\n"</span>);
00937 
00938             <span class="comment">//</span>
00939             <span class="comment">// Complement the sign of the second operand if the operation</span>
00940             <span class="comment">// is subtraction.</span>
00941             <span class="comment">//</span>
00942 
00943             DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a> ^= Negation;
00944 
00945             <span class="comment">//</span>
00946             <span class="comment">// Reorder the operands according to their exponent value</span>
00947             <span class="comment">// so that Operand1 exponent will be &gt;= Operand2 exponent.</span>
00948             <span class="comment">//</span>
00949 
00950             <span class="keywordflow">if</span> (DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a> &gt; DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a>) {
00951                 DoubleOperand3 = DoubleOperand2;
00952                 DoubleOperand2 = DoubleOperand1;
00953                 DoubleOperand1 = DoubleOperand3;
00954             }
00955 
00956             <span class="comment">//</span>
00957             <span class="comment">// Compute the exponent difference and shift the smaller</span>
00958             <span class="comment">// mantissa right by the difference value or 55 which ever</span>
00959             <span class="comment">// is smaller. The bits shifted out are termed the sticky</span>
00960             <span class="comment">// bits and are used later in the rounding operation.</span>
00961             <span class="comment">//</span>
00962 
00963             ExponentDifference =
00964                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a> - DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a>;
00965 
00966             <span class="keywordflow">if</span> (ExponentDifference &gt; 55) {
00967                 ExponentDifference = 55;
00968             }
00969 
00970             <span class="keywordflow">if</span> (ExponentDifference &gt;= 32) {
00971                 ExponentDifference -= 32;
00972                 StickyBits = (DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a>) |
00973                     (DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> &amp; ((1 &lt;&lt; ExponentDifference) - 1));
00974 
00975                 DoubleMantissaLow =
00976                     DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> &gt;&gt; ExponentDifference;
00977 
00978                 DoubleMantissaHigh = 0;
00979 
00980             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ExponentDifference &gt; 0) {
00981                 StickyBits =
00982                     DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> &amp; ((1 &lt;&lt; ExponentDifference) - 1);
00983 
00984                 DoubleMantissaLow =
00985                     (DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> &gt;&gt; ExponentDifference) |
00986                     (DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> &lt;&lt; (32 - ExponentDifference));
00987 
00988                 DoubleMantissaHigh =
00989                     DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> &gt;&gt; ExponentDifference;
00990 
00991             } <span class="keywordflow">else</span> {
00992                 StickyBits = 0;
00993                 DoubleMantissaLow = DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a>;
00994                 DoubleMantissaHigh = DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a>;
00995             }
00996 
00997             <span class="comment">//</span>
00998             <span class="comment">// If the operands both have the same sign, then perform the</span>
00999             <span class="comment">// operation by adding the values together. Otherwise, if the</span>
01000             <span class="comment">// operands are not infinity, perform the operation by</span>
01001             <span class="comment">// subtracting the second operand from the first operand.</span>
01002             <span class="comment">//</span>
01003 
01004             <span class="keywordflow">if</span> ((DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a> ^ DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a>) == 0) {
01005                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> += DoubleMantissaLow;
01006                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> += DoubleMantissaHigh;
01007                 <span class="keywordflow">if</span> (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> &lt; DoubleMantissaLow) {
01008                     DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> += 1;
01009                 }
01010 
01011             } <span class="keywordflow">else</span> {
01012                 <span class="keywordflow">if</span> ((DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o5">Infinity</a> != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
01013                     (DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o5">Infinity</a> != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>)) {
01014                     <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a20">KiInvalidOperationDouble</a>(&amp;ContextBlock,
01015                                                     <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
01016                                                     &amp;DoubleOperand1,
01017                                                     &amp;DoubleOperand2);
01018 
01019                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o5">Infinity</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01020                     <span class="keywordflow">if</span> (StickyBits != 0) {
01021                         <span class="keywordflow">if</span> (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> &lt; 1) {
01022                             DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> -= 1;
01023                         }
01024 
01025                         DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> -= 1;
01026                     }
01027 
01028                     <span class="keywordflow">if</span> (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> &lt; DoubleMantissaLow) {
01029                         DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> -= 1;
01030                     }
01031 
01032                     DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> -= DoubleMantissaLow;
01033                     DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> -= DoubleMantissaHigh;
01034                     <span class="keywordflow">if</span> (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> &lt; 0) {
01035                         DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> = -(LONG)DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a>;
01036                         DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> = -DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a>;
01037                         <span class="keywordflow">if</span> (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> != 0) {
01038                             DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> -= 1;
01039                         }
01040                         DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a> ^= 0x1;
01041                     }
01042 
01043                     <span class="comment">//</span>
01044                     <span class="comment">// If the result is exactly zero and the signs of the</span>
01045                     <span class="comment">// operands differ, then the result is plus zero except</span>
01046                     <span class="comment">// when the rounding mode is minus infinity.</span>
01047                     <span class="comment">//</span>
01048 
01049                     <span class="keywordflow">if</span> ((DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> == 0) &amp;&amp;
01050                         (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> == 0) &amp;&amp;
01051                         (StickyBits == 0)) {
01052                         <span class="keywordflow">if</span> (ContextBlock.<a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o5">Round</a> == ROUND_TO_MINUS_INFINITY) {
01053                             DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a> = 0x1;
01054 
01055                         } <span class="keywordflow">else</span> {
01056                             DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a> = 0x0;
01057                         }
01058                     }
01059                 }
01060             }
01061 
01062             <span class="comment">//</span>
01063             <span class="comment">// Normalize and store the result value.</span>
01064             <span class="comment">//</span>
01065 
01066             <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a24">KiNormalizeDouble</a>(&amp;ContextBlock,
01067                                      &amp;DoubleOperand1,
01068                                      StickyBits);
01069 
01070         <span class="comment">//</span>
01071         <span class="comment">// Floating multiply operation.</span>
01072         <span class="comment">//</span>
01073         <span class="comment">// Floating multiply is accomplished using unsigned multiplies</span>
01074         <span class="comment">// of the mantissa values, and adding the partial results together</span>
01075         <span class="comment">// to form the total product.</span>
01076         <span class="comment">//</span>
01077         <span class="comment">// The two mantissa values are preshifted such that the final</span>
01078         <span class="comment">// result is properly aligned.</span>
01079         <span class="comment">//</span>
01080 
01081         <span class="keywordflow">case</span> MULS_FUNC :
01082             <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a1">DBGPRINT2</a>(<span class="stringliteral">"muls\n"</span>);
01083 
01084             <span class="comment">//</span>
01085             <span class="comment">// Reorder the operands according to their exponent value</span>
01086             <span class="comment">// so that Operand1 exponent will be &gt;= Operand2 exponent.</span>
01087             <span class="comment">//</span>
01088 
01089             <span class="keywordflow">if</span> (SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">Exponent</a> &gt; SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">Exponent</a>) {
01090                 SingleOperand3 = SingleOperand2;
01091                 SingleOperand2 = SingleOperand1;
01092                 SingleOperand1 = SingleOperand3;
01093             }
01094 
01095             <span class="comment">//</span>
01096             <span class="comment">// If the first operand is infinite and the second operand is</span>
01097             <span class="comment">// zero, then an invalid operation is specified.</span>
01098             <span class="comment">//</span>
01099 
01100             <span class="keywordflow">if</span> ((SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o3">Infinity</a> != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
01101                 (SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o3">Infinity</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
01102                 (SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> == 0)) {
01103                 <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a23">KiInvalidOperationSingle</a>(&amp;ContextBlock,
01104                                                 <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
01105                                                 &amp;SingleOperand1,
01106                                                 &amp;SingleOperand2);
01107             }
01108 
01109             <span class="comment">//</span>
01110             <span class="comment">// Preshift the operand mantissas so the result will be a</span>
01111             <span class="comment">// properly aligned 64-bit value and then unsigned multiply</span>
01112             <span class="comment">// the two mantissa values. The single result is the high part</span>
01113             <span class="comment">// of the 64-bit product and the sticky bits are the low part</span>
01114             <span class="comment">// of the 64-bit product.</span>
01115             <span class="comment">//</span>
01116             <span class="comment">// The size of the product will be (1+23+2)+(1+23+2) = 52 bits</span>
01117             <span class="comment">// of which the high (1+1+23+2) = 27 bits are result and the</span>
01118             <span class="comment">// remaining 25 bits are sticky. By preshifting the operands</span>
01119             <span class="comment">// left 7 bits, the number of sticky bits is 32. This alignment</span>
01120             <span class="comment">// is convenient.</span>
01121             <span class="comment">//</span>
01122             <span class="comment">// The 7 bit preshift amount must be applied in part to both</span>
01123             <span class="comment">// operands because 26 of 32 bits of the mantissa are used and</span>
01124             <span class="comment">// so neither operand can be safely shifted left by more than 6</span>
01125             <span class="comment">// bits. Thus one operand is shifted the maximum of 6 bits and</span>
01126             <span class="comment">// the other the remaining 1 bit.</span>
01127             <span class="comment">//</span>
01128 
01129             LargeResult.QuadPart = ((ULONGLONG)((ULONG)(SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> &lt;&lt; (32 - 26)))) *
01130                                    ((ULONGLONG)((ULONG)(SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> &lt;&lt; 1)));
01131 
01132             SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> = LargeResult.HighPart;
01133             StickyBits = LargeResult.LowPart;
01134 
01135             <span class="comment">//</span>
01136             <span class="comment">// Compute the sign and exponent of the result.</span>
01137             <span class="comment">//</span>
01138 
01139             SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a> ^= SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a>;
01140             SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">Exponent</a> +=
01141                         SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">Exponent</a> - SINGLE_EXPONENT_BIAS;
01142 
01143             <span class="comment">//</span>
01144             <span class="comment">// Normalize and store the result value.</span>
01145             <span class="comment">//</span>
01146 
01147             <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a27">KiNormalizeSingle</a>(&amp;ContextBlock,
01148                                      &amp;SingleOperand1,
01149                                      StickyBits);
01150 
01151         <span class="keywordflow">case</span> MULT_FUNC :
01152             <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a1">DBGPRINT2</a>(<span class="stringliteral">"mult\n"</span>);
01153 
01154             <span class="comment">//</span>
01155             <span class="comment">// Reorder the operands according to their exponent value</span>
01156             <span class="comment">// so that Operand1 exponent will be &gt;= Operand2 exponent.</span>
01157             <span class="comment">//</span>
01158 
01159             <span class="keywordflow">if</span> (DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a> &gt; DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a>) {
01160                 DoubleOperand3 = DoubleOperand2;
01161                 DoubleOperand2 = DoubleOperand1;
01162                 DoubleOperand1 = DoubleOperand3;
01163             }
01164 
01165             <span class="comment">//</span>
01166             <span class="comment">// If the first operand is infinite and the second operand is</span>
01167             <span class="comment">// zero, then an invalid operation is specified.</span>
01168             <span class="comment">//</span>
01169 
01170             <span class="keywordflow">if</span> ((DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o5">Infinity</a> != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
01171                 (DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o5">Infinity</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
01172                 (DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> == 0)) {
01173                 <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a20">KiInvalidOperationDouble</a>(&amp;ContextBlock,
01174                                                 <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
01175                                                 &amp;DoubleOperand1,
01176                                                 &amp;DoubleOperand2);
01177             }
01178 
01179             <span class="comment">//</span>
01180             <span class="comment">// Preshift the operand mantissas so the result will be a</span>
01181             <span class="comment">// properly aligned 128-bit value and then unsigned multiply</span>
01182             <span class="comment">// the two mantissa values. The double result is the high part</span>
01183             <span class="comment">// of the 128-bit product and the sticky bits are the low part</span>
01184             <span class="comment">// of the 128-bit product.</span>
01185             <span class="comment">//</span>
01186             <span class="comment">// The size of the product will be (1+52+2)+(1+52+2) = 110 bits</span>
01187             <span class="comment">// of which the high (1+1+52+2) = 56 bits are result and the</span>
01188             <span class="comment">// remaining 54 bits are sticky. By preshifting the operands</span>
01189             <span class="comment">// left 10 bits, the number of sticky bits is 64. This alignment</span>
01190             <span class="comment">// is convenient.</span>
01191             <span class="comment">//</span>
01192             <span class="comment">// The 10 bit preshift amount must be applied in part to both</span>
01193             <span class="comment">// operands because 55 of 64 bits of the mantissa are used and</span>
01194             <span class="comment">// so neither operand can be safely shifted left by more than 9</span>
01195             <span class="comment">// bits. Thus one operand is shifted the maximum of 9 bits and</span>
01196             <span class="comment">// the other the remaining 1 bit.</span>
01197             <span class="comment">//</span>
01198 
01199             DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> =
01200                     (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> &lt;&lt; 1) |
01201                             (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> &gt;&gt; 31);
01202 
01203             DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> &lt;&lt;= 1;
01204             DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> =
01205                     (DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> &lt;&lt; (64 - 55)) |
01206                             (DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> &gt;&gt; (32 - (64 - 55)));
01207 
01208             DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> &lt;&lt;= (64 - 55);
01209 
01210             <span class="comment">//</span>
01211             <span class="comment">// The 128-bit product is formed by multiplying and adding</span>
01212             <span class="comment">// all the cross product values.</span>
01213             <span class="comment">//</span>
01214             <span class="comment">// Consider the operands (A and B) as being composed of two</span>
01215             <span class="comment">// parts Ahigh, Alow, Bhigh, and Blow. The cross product sum</span>
01216             <span class="comment">// is then:</span>
01217             <span class="comment">//</span>
01218             <span class="comment">//       Ahigh * Bhigh * 2^64 +</span>
01219             <span class="comment">//              Ahigh * Blow * 2^32 +</span>
01220             <span class="comment">//              Alow * Bhigh * 2^32 +</span>
01221             <span class="comment">//                              Alow * Blow</span>
01222             <span class="comment">//</span>
01223 
01224             AhighBhigh.QuadPart = (ULONGLONG)(ULONG)DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> *
01225                                   (ULONGLONG)(ULONG)DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a>;
01226 
01227             AhighBlow.QuadPart = (ULONGLONG)(ULONG)DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> *
01228                                  (ULONGLONG)DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a>;
01229 
01230             AlowBhigh.QuadPart = (ULONGLONG)DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> *
01231                                  (ULONGLONG)(ULONG)DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a>;
01232 
01233             AlowBlow.QuadPart = (ULONGLONG)DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> *
01234                                 (ULONGLONG)DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a>;
01235 
01236             AlowBlow.HighPart += AhighBlow.LowPart;
01237             <span class="keywordflow">if</span> (AlowBlow.HighPart &lt; AhighBlow.LowPart) {
01238                 Carry1 = 1;
01239 
01240             } <span class="keywordflow">else</span> {
01241                 Carry1 = 0;
01242             }
01243 
01244             AlowBlow.HighPart += AlowBhigh.LowPart;
01245             <span class="keywordflow">if</span> (AlowBlow.HighPart &lt; AlowBhigh.LowPart) {
01246                 Carry1 += 1;
01247             }
01248 
01249             DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> = AhighBlow.HighPart + Carry1;
01250             <span class="keywordflow">if</span> (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> &lt; Carry1) {
01251                 Carry2 = 1;
01252 
01253             } <span class="keywordflow">else</span> {
01254                 Carry2 = 0;
01255             }
01256 
01257             DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> += AlowBhigh.HighPart;
01258             <span class="keywordflow">if</span> (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> &lt; AlowBhigh.HighPart) {
01259                 Carry2 += 1;
01260             }
01261 
01262             DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> += AhighBhigh.LowPart;
01263             <span class="keywordflow">if</span> (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> &lt; AhighBhigh.LowPart) {
01264                 Carry2 += 1;
01265             }
01266 
01267             DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> = AhighBhigh.HighPart + Carry2;
01268             StickyBits = AlowBlow.HighPart | AlowBlow.LowPart;
01269 
01270             <span class="comment">//</span>
01271             <span class="comment">// Compute the sign and exponent of the result.</span>
01272             <span class="comment">//</span>
01273 
01274             DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a> ^= DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a>;
01275             DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a> +=
01276                         DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a> - DOUBLE_EXPONENT_BIAS;
01277 
01278             <span class="comment">//</span>
01279             <span class="comment">// Normalize and store the result value.</span>
01280             <span class="comment">//</span>
01281 
01282             <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a24">KiNormalizeDouble</a>(&amp;ContextBlock,
01283                                      &amp;DoubleOperand1,
01284                                      StickyBits);
01285 
01286         <span class="comment">//</span>
01287         <span class="comment">// Floating divide operation.</span>
01288         <span class="comment">//</span>
01289         <span class="comment">// Floating division is accomplished by repeated subtract using</span>
01290         <span class="comment">// a single one-bit-at-a-time algorithm. The number of division</span>
01291         <span class="comment">// steps performed is equal to the mantissa size plus one guard</span>
01292         <span class="comment">// bit.</span>
01293         <span class="comment">//</span>
01294         <span class="comment">// The sticky bits are the remainder after the specified number</span>
01295         <span class="comment">// of division steps.</span>
01296         <span class="comment">//</span>
01297 
01298         <span class="keywordflow">case</span> DIVS_FUNC :
01299             <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a1">DBGPRINT2</a>(<span class="stringliteral">"divs\n"</span>);
01300 
01301             <span class="comment">//</span>
01302             <span class="comment">// If the first operand is infinite and the second operand</span>
01303             <span class="comment">// is infinite, or both operands are zero, then an invalid</span>
01304             <span class="comment">// operation is specified.</span>
01305             <span class="comment">//</span>
01306 
01307             <span class="keywordflow">if</span> (((SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o3">Infinity</a> != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
01308                  (SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o3">Infinity</a> != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>)) ||
01309                 ((SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o3">Infinity</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
01310                  (SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> == 0) &amp;&amp;
01311                  (SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o3">Infinity</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
01312                  (SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> == 0))) {
01313                 <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a23">KiInvalidOperationSingle</a>(&amp;ContextBlock,
01314                                                 <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
01315                                                 &amp;SingleOperand1,
01316                                                 &amp;SingleOperand2);
01317             }
01318 
01319             <span class="comment">//</span>
01320             <span class="comment">// If the second operand is zero, then a divide by zero</span>
01321             <span class="comment">// operation is specified.</span>
01322             <span class="comment">//</span>
01323 
01324             <span class="keywordflow">if</span> ((SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o3">Infinity</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
01325                 (SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> == 0)) {
01326                 <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a17">KiDivideByZeroSingle</a>(&amp;ContextBlock,
01327                                             &amp;SingleOperand1,
01328                                             &amp;SingleOperand2);
01329             }
01330 
01331             <span class="comment">//</span>
01332             <span class="comment">// If the first operand is infinite, then the result is</span>
01333             <span class="comment">// infinite. Otherwise, if the second operand is infinite,</span>
01334             <span class="comment">// then the result is zero (note that both operands cannot</span>
01335             <span class="comment">// be infinite).</span>
01336             <span class="comment">//</span>
01337 
01338             <span class="keywordflow">if</span> (SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o3">Infinity</a> != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01339                 SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a> ^= SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a>;
01340                 <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a27">KiNormalizeSingle</a>(&amp;ContextBlock,
01341                                          &amp;SingleOperand1,
01342                                          0);
01343 
01344             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o3">Infinity</a> != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01345                 SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a> ^= SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a>;
01346                 SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">Exponent</a> = 0;
01347                 SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> = 0;
01348                 <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a27">KiNormalizeSingle</a>(&amp;ContextBlock,
01349                                          &amp;SingleOperand1,
01350                                          0);
01351             }
01352 
01353             <span class="comment">//</span>
01354             <span class="comment">// Perform divide operation by repeating a single bit</span>
01355             <span class="comment">// divide step 26 iterations.</span>
01356             <span class="comment">//</span>
01357 
01358             SingleOperand3.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> = 0;
01359             <span class="keywordflow">for</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = 0; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &lt; 26; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> += 1) {
01360                 SingleOperand3.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> &lt;&lt;= 1;
01361                 <span class="keywordflow">if</span> (SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> &gt;= SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a>) {
01362                     SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> -= SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a>;
01363                     SingleOperand3.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> |= 1;
01364                 }
01365 
01366                 SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> &lt;&lt;= 1;
01367             }
01368 
01369             <span class="comment">//</span>
01370             <span class="comment">// Compute the sign and exponent of the result.</span>
01371             <span class="comment">//</span>
01372 
01373             SingleOperand3.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a> = SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a> ^ SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a>;
01374             SingleOperand3.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">Exponent</a> = SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">Exponent</a> -
01375                             SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">Exponent</a> + SINGLE_EXPONENT_BIAS;
01376 
01377             <span class="comment">//</span>
01378             <span class="comment">// Normalize and store the result value.</span>
01379             <span class="comment">//</span>
01380 
01381             SingleOperand3.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o3">Infinity</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01382             SingleOperand3.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o4">Nan</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01383             <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a27">KiNormalizeSingle</a>(&amp;ContextBlock,
01384                                      &amp;SingleOperand3,
01385                                      SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a>);
01386 
01387         <span class="keywordflow">case</span> DIVT_FUNC :
01388             <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a1">DBGPRINT2</a>(<span class="stringliteral">"divt\n"</span>);
01389 
01390             <span class="comment">//</span>
01391             <span class="comment">// If the first operand is infinite and the second operand</span>
01392             <span class="comment">// is infinite, or both operands are zero, then an invalid</span>
01393             <span class="comment">// operation is specified.</span>
01394             <span class="comment">//</span>
01395 
01396             <span class="keywordflow">if</span> (((DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o5">Infinity</a> != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
01397                  (DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o5">Infinity</a> != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>)) ||
01398                 ((DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o5">Infinity</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
01399                  (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> == 0) &amp;&amp;
01400                  (DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o5">Infinity</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
01401                  (DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> == 0))) {
01402                 <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a20">KiInvalidOperationDouble</a>(&amp;ContextBlock,
01403                                                 <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
01404                                                 &amp;DoubleOperand1,
01405                                                 &amp;DoubleOperand2);
01406             }
01407 
01408             <span class="comment">//</span>
01409             <span class="comment">// If the second operand is zero, then a divide by zero</span>
01410             <span class="comment">// operation is specified.</span>
01411             <span class="comment">//</span>
01412 
01413             <span class="keywordflow">if</span> ((DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o5">Infinity</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
01414                 (DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> == 0)) {
01415                 <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a16">KiDivideByZeroDouble</a>(&amp;ContextBlock,
01416                                             &amp;DoubleOperand1,
01417                                             &amp;DoubleOperand2);
01418             }
01419 
01420             <span class="comment">//</span>
01421             <span class="comment">// If the first operand is infinite, then the result is</span>
01422             <span class="comment">// infinite. Otherwise, if the second operand is infinite,</span>
01423             <span class="comment">// then the result is zero (note that both operands cannot</span>
01424             <span class="comment">// be infinite).</span>
01425             <span class="comment">//</span>
01426 
01427             <span class="keywordflow">if</span> (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o5">Infinity</a> != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01428                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a> ^= DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a>;
01429                 <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a24">KiNormalizeDouble</a>(&amp;ContextBlock,
01430                                          &amp;DoubleOperand1,
01431                                          0);
01432 
01433             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o5">Infinity</a> != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01434                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a> ^= DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a>;
01435                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a> = 0;
01436                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> = 0;
01437                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> = 0;
01438                 <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a24">KiNormalizeDouble</a>(&amp;ContextBlock,
01439                                          &amp;DoubleOperand1,
01440                                          0);
01441             }
01442 
01443             <span class="comment">//</span>
01444             <span class="comment">// Perform divide operation by repeating a single bit</span>
01445             <span class="comment">// divide step 55 iterations.</span>
01446             <span class="comment">//</span>
01447 
01448             DoubleDividend.LowPart = DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a>;
01449             DoubleDividend.HighPart = DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a>;
01450             DoubleDivisor.LowPart = DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a>;
01451             DoubleDivisor.HighPart = DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a>;
01452             DoubleQuotient.LowPart = 0;
01453             DoubleQuotient.HighPart = 0;
01454             <span class="keywordflow">for</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = 0; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &lt; 55; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> += 1) {
01455                 DoubleQuotient.HighPart =
01456                             (DoubleQuotient.HighPart &lt;&lt; 1) |
01457                                             DoubleQuotient.LowPart &gt;&gt; 31;
01458 
01459                 DoubleQuotient.LowPart &lt;&lt;= 1;
01460                 <span class="keywordflow">if</span> (DoubleDividend.QuadPart &gt;= DoubleDivisor.QuadPart) {
01461                     DoubleDividend.QuadPart = DoubleDividend.QuadPart - DoubleDivisor.QuadPart;
01462                     DoubleQuotient.LowPart |= 1;
01463                 }
01464 
01465                 DoubleDividend.HighPart =
01466                             (DoubleDividend.HighPart &lt;&lt; 1) |
01467                                             DoubleDividend.LowPart &gt;&gt; 31;
01468 
01469                 DoubleDividend.LowPart &lt;&lt;= 1;
01470             }
01471 
01472             DoubleOperand3.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> = DoubleQuotient.LowPart;
01473             DoubleOperand3.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> = DoubleQuotient.HighPart;
01474 
01475             <span class="comment">//</span>
01476             <span class="comment">// Compute the sign and exponent of the result.</span>
01477             <span class="comment">//</span>
01478 
01479             DoubleOperand3.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a> = DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a> ^ DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a>;
01480             DoubleOperand3.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a> = DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a> -
01481                             DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a> + DOUBLE_EXPONENT_BIAS;
01482 
01483             <span class="comment">//</span>
01484             <span class="comment">// Normalize and store the result value.</span>
01485             <span class="comment">//</span>
01486 
01487             DoubleOperand3.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o5">Infinity</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01488             DoubleOperand3.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o6">Nan</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01489             <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a24">KiNormalizeDouble</a>(&amp;ContextBlock,
01490                                      &amp;DoubleOperand3,
01491                                      DoubleDividend.LowPart | DoubleDividend.HighPart);
01492 
01493             <span class="comment">//</span>
01494             <span class="comment">// Floating compare double.</span>
01495             <span class="comment">//</span>
01496             <span class="comment">// This operation is performed after having separated out NaNs,</span>
01497             <span class="comment">// and therefore the only comparison predicates left are equal</span>
01498             <span class="comment">// and less.</span>
01499             <span class="comment">//</span>
01500             <span class="comment">// Floating compare double is accomplished by comparing signs,</span>
01501             <span class="comment">// then exponents, and finally the mantissa if necessary.</span>
01502             <span class="comment">//</span>
01503             <span class="comment">// N.B. The sign of zero is ignored.</span>
01504             <span class="comment">//</span>
01505 
01506         <span class="keywordflow">case</span> CMPTEQ_FUNC :
01507         <span class="keywordflow">case</span> CMPTLE_FUNC :
01508         <span class="keywordflow">case</span> CMPTLT_FUNC :
01509 
01510             <span class="comment">//</span>
01511             <span class="comment">// If either operand is zero, then set the sign of the operand</span>
01512             <span class="comment">// positive and the exponent to a value less than the minimum</span>
01513             <span class="comment">// denormal number.</span>
01514             <span class="comment">//</span>
01515 
01516             <span class="keywordflow">if</span> ((DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o5">Infinity</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
01517                 (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> == 0)) {
01518                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a> = 0;
01519                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a> = -52;
01520             }
01521 
01522             <span class="keywordflow">if</span> ((DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o5">Infinity</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
01523                 (DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> == 0)) {
01524                 DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a> = 0;
01525                 DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a> = -52;
01526             }
01527 
01528             <span class="comment">//</span>
01529             <span class="comment">// Compare signs first.</span>
01530             <span class="comment">//</span>
01531 
01532             <span class="keywordflow">if</span> (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a> &lt; DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a>) {
01533 
01534                 <span class="comment">//</span>
01535                 <span class="comment">// The first operand is greater than the second operand.</span>
01536                 <span class="comment">//</span>
01537 
01538                 CompareEqual = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01539                 CompareLess = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01540 
01541             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a> &gt; DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a>) {
01542 
01543                 <span class="comment">//</span>
01544                 <span class="comment">// The first operand is less than the second operand.</span>
01545                 <span class="comment">//</span>
01546 
01547                 CompareEqual = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01548                 CompareLess = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01549 
01550             } <span class="keywordflow">else</span> {
01551 
01552                 <span class="comment">//</span>
01553                 <span class="comment">// The operand signs are equal.</span>
01554                 <span class="comment">//</span>
01555                 <span class="comment">// If the sign of the operand is negative, then the sense of</span>
01556                 <span class="comment">// the comparison is reversed.</span>
01557                 <span class="comment">//</span>
01558 
01559                 <span class="keywordflow">if</span> (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a> == 0) {
01560 
01561                     <span class="comment">//</span>
01562                     <span class="comment">// Compare positive operand with positive operand.</span>
01563                     <span class="comment">//</span>
01564 
01565                     <span class="keywordflow">if</span> (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a> &gt; DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a>) {
01566                         CompareEqual = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01567                         CompareLess = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01568 
01569                     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a> &lt; DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a>) {
01570                         CompareEqual = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01571                         CompareLess = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01572 
01573                     } <span class="keywordflow">else</span> {
01574                         <span class="keywordflow">if</span> (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> &gt;
01575                             DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a>) {
01576                             CompareEqual = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01577                             CompareLess = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01578 
01579                         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> &lt;
01580                                    DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a>) {
01581                             CompareEqual = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01582                             CompareLess = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01583 
01584                         } <span class="keywordflow">else</span> {
01585                             <span class="keywordflow">if</span> (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> &gt;
01586                                 DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a>) {
01587                                 CompareEqual = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01588                                 CompareLess = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01589 
01590                             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> &lt;
01591                                        DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a>) {
01592                                 CompareEqual = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01593                                 CompareLess = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01594 
01595                             } <span class="keywordflow">else</span> {
01596                                 CompareEqual = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01597                                 CompareLess = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01598                             }
01599                         }
01600                     }
01601 
01602                 } <span class="keywordflow">else</span> {
01603 
01604                     <span class="comment">//</span>
01605                     <span class="comment">// Compare negative operand with negative operand.</span>
01606                     <span class="comment">//</span>
01607 
01608                     <span class="keywordflow">if</span> (DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a> &gt; DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a>) {
01609                         CompareEqual = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01610                         CompareLess = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01611 
01612                     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a> &lt; DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a>) {
01613                         CompareEqual = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01614                         CompareLess = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01615 
01616                     } <span class="keywordflow">else</span> {
01617                         <span class="keywordflow">if</span> (DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> &gt;
01618                             DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a>) {
01619                             CompareEqual = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01620                             CompareLess = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01621 
01622                         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> &lt;
01623                                    DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a>) {
01624                             CompareEqual = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01625                             CompareLess = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01626 
01627                         } <span class="keywordflow">else</span> {
01628                             <span class="keywordflow">if</span> (DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> &gt;
01629                                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a>) {
01630                                 CompareEqual = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01631                                 CompareLess = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01632 
01633                             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> &lt;
01634                                        DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a>) {
01635                                 CompareEqual = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01636                                 CompareLess = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01637 
01638                             } <span class="keywordflow">else</span> {
01639                                 CompareEqual = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01640                                 CompareLess = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01641                             }
01642                         }
01643                     }
01644                 }
01645             }
01646 
01647             <span class="comment">//</span>
01648             <span class="comment">// Form the condition code result value using the comparison</span>
01649             <span class="comment">// information and the compare function codes.</span>
01650             <span class="comment">//</span>
01651 
01652             <span class="keywordflow">switch</span> (Function &amp; FP_FUNCTION_MASK) {
01653             <span class="keywordflow">case</span> CMPTEQ_FUNC :
01654                 CompareResult = CompareEqual;
01655                 <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a1">DBGPRINT2</a>(<span class="stringliteral">"cmpteq\n"</span>);
01656                 <span class="keywordflow">break</span>;
01657 
01658             <span class="keywordflow">case</span> CMPTLE_FUNC :
01659                 CompareResult = (CompareLess | CompareEqual);
01660                 <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a1">DBGPRINT2</a>(<span class="stringliteral">"cmptle\n"</span>);
01661                 <span class="keywordflow">break</span>;
01662 
01663             <span class="keywordflow">case</span> CMPTLT_FUNC :
01664                 CompareResult = CompareLess;
01665                 <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a1">DBGPRINT2</a>(<span class="stringliteral">"cmptlt\n"</span>);
01666                 <span class="keywordflow">break</span>;
01667             }
01668 
01669             <span class="comment">//</span>
01670             <span class="comment">// Set the result operand to 2.0 if the comparison is true,</span>
01671             <span class="comment">// otherwise store 0.0.</span>
01672             <span class="comment">//</span>
01673 
01674             <span class="keywordflow">if</span> (CompareResult != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01675                 <a class="code" href="../../d8/d5/ppc_2getsetrg_8c.html#a1">KiSetRegisterValue</a>(ContextBlock.<a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o0">Fc</a> + 32,
01676                                    FP_COMPARE_TRUE,
01677                                    ExceptionFrame,
01678                                    TrapFrame);
01679 
01680             } <span class="keywordflow">else</span> {
01681                 <a class="code" href="../../d8/d5/ppc_2getsetrg_8c.html#a1">KiSetRegisterValue</a>(ContextBlock.<a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o0">Fc</a> + 32,
01682                                    FP_COMPARE_FALSE,
01683                                    ExceptionFrame,
01684                                    TrapFrame);
01685             }
01686             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01687 
01688         <span class="comment">//</span>
01689         <span class="comment">// Floating convert single to double.</span>
01690         <span class="comment">//</span>
01691         <span class="comment">// Floating conversion to double is accomplished by forming a</span>
01692         <span class="comment">// double floating operand and then normalizing and storing</span>
01693         <span class="comment">// the result value.</span>
01694         <span class="comment">//</span>
01695 
01696         <span class="keywordflow">case</span> <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a5">CVTST_FUNC_PROPER</a> :
01697             <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a1">DBGPRINT2</a>(<span class="stringliteral">"cvtst\n"</span>);
01698 
01699             <span class="comment">//</span>
01700             <span class="comment">// If the operand is a NaN, then store a quiet NaN if the</span>
01701             <span class="comment">// invalid operation trap is disabled, or raise an exception</span>
01702             <span class="comment">// if the invalid operation trap is enabled and the operand</span>
01703             <span class="comment">// is a signaling NaN.</span>
01704             <span class="comment">//</span>
01705 
01706             <span class="keywordflow">if</span> (SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o4">Nan</a> != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01707                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> =
01708                         SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> &gt;&gt; (26 - (55 - 32));
01709                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> =
01710                         SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> &lt;&lt; (32 - (26 - (55 - 32)));
01711                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a> = DOUBLE_MAXIMUM_EXPONENT;
01712                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a> = SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a>;
01713                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o5">Infinity</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01714                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o6">Nan</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01715                 <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a20">KiInvalidOperationDouble</a>(&amp;ContextBlock,
01716                                                 <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
01717                                                 &amp;DoubleOperand1,
01718                                                 &amp;DoubleOperand1);
01719             }
01720 
01721             <span class="comment">//</span>
01722             <span class="comment">// Transform the single operand to double format.</span>
01723             <span class="comment">//</span>
01724 
01725             DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> =
01726                         SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> &gt;&gt; (26 - (55 - 32));
01727             DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> =
01728                         SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> &lt;&lt; (32 - (26 - (55 - 32)));
01729             DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a> = SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">Exponent</a> +
01730                                 DOUBLE_EXPONENT_BIAS - SINGLE_EXPONENT_BIAS;
01731             DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a> = SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a>;
01732             DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o5">Infinity</a> = SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o3">Infinity</a>;
01733             DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o6">Nan</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01734 
01735             <span class="comment">//</span>
01736             <span class="comment">// Normalize and store the result value.</span>
01737             <span class="comment">//</span>
01738 
01739             <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a24">KiNormalizeDouble</a>(&amp;ContextBlock,
01740                                      &amp;DoubleOperand1,
01741                                      0);
01742 
01743         <span class="comment">//</span>
01744         <span class="comment">// Floating convert double to single.</span>
01745         <span class="comment">//</span>
01746         <span class="comment">// Floating conversion to single is accomplished by forming a</span>
01747         <span class="comment">// single floating operand and then normalizing and storing the</span>
01748         <span class="comment">// result value.</span>
01749         <span class="comment">//</span>
01750 
01751         <span class="keywordflow">case</span> CVTTS_FUNC :
01752             <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a1">DBGPRINT2</a>(<span class="stringliteral">"cvtts\n"</span>);
01753 
01754             <span class="comment">//</span>
01755             <span class="comment">// If the operand is a NaN, then store a quiet NaN if the</span>
01756             <span class="comment">// invalid operation trap is disabled, or raise an exception</span>
01757             <span class="comment">// if the invalid operation trap is enabled and the operand</span>
01758             <span class="comment">// is a signaling NaN.</span>
01759             <span class="comment">//</span>
01760 
01761             <span class="keywordflow">if</span> (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o6">Nan</a> != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01762                 SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> =
01763                     (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> &lt;&lt; (26 - (55 - 32))) |
01764                     (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> &gt;&gt; (32 - (26 - (55 - 32))));
01765                 SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">Exponent</a> = SINGLE_MAXIMUM_EXPONENT;
01766                 SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a> = DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a>;
01767                 SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o3">Infinity</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01768                 SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o4">Nan</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01769                 <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a23">KiInvalidOperationSingle</a>(&amp;ContextBlock,
01770                                                 <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
01771                                                 &amp;SingleOperand1,
01772                                                 &amp;SingleOperand1);
01773             }
01774 
01775             <span class="comment">//</span>
01776             <span class="comment">// Transform the double operand to single format.</span>
01777             <span class="comment">//</span>
01778 
01779             SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> =
01780                 (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> &lt;&lt; (26 - (55 - 32))) |
01781                 (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> &gt;&gt; (32 - (26 - (55 - 32))));
01782             StickyBits = DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> &lt;&lt; (26 - (55 - 32));
01783             SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">Exponent</a> = DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a> +
01784                                 SINGLE_EXPONENT_BIAS - DOUBLE_EXPONENT_BIAS;
01785             SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a> = DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a>;
01786             SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o3">Infinity</a> = DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o5">Infinity</a>;
01787             SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o4">Nan</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01788 
01789             <span class="comment">//</span>
01790             <span class="comment">// Normalize and store the result value.</span>
01791             <span class="comment">//</span>
01792 
01793             <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a27">KiNormalizeSingle</a>(&amp;ContextBlock,
01794                                      &amp;SingleOperand1,
01795                                      StickyBits);
01796 
01797         <span class="comment">//</span>
01798         <span class="comment">// Floating convert longword to quadword.</span>
01799         <span class="comment">//</span>
01800         <span class="comment">// Floating conversion from longword to quadword is accomplished by</span>
01801         <span class="comment">// a repositioning of 32 bits of the operand, with sign extension.</span>
01802         <span class="comment">//</span>
01803 
01804         <span class="keywordflow">case</span> CVTLQ_FUNC :
01805             <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a1">DBGPRINT2</a>(<span class="stringliteral">"cvtlq\n"</span>);
01806 
01807             <span class="comment">//</span>
01808             <span class="comment">// Pack floating register longword format into upper 32-bits</span>
01809             <span class="comment">// by keeping bits 63..62 and 58..29, eliminating unused bits</span>
01810             <span class="comment">// 61..59. Then right justify and sign extend the 32 bits into</span>
01811             <span class="comment">// 64 bits.</span>
01812             <span class="comment">//</span>
01813 
01814             Quadword = ((Quadword &gt;&gt; 62) &lt;&lt; 62) | ((ULONGLONG)(Quadword &lt;&lt; 5) &gt;&gt; 2);
01815             <a class="code" href="../../d8/d5/ppc_2getsetrg_8c.html#a1">KiSetRegisterValue</a>(ContextBlock.<a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o0">Fc</a> + 32,
01816                                Quadword &gt;&gt; 32,
01817                                ExceptionFrame,
01818                                TrapFrame);
01819 
01820             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01821 
01822         <span class="comment">//</span>
01823         <span class="comment">// Floating convert quadword to longword.</span>
01824         <span class="comment">//</span>
01825         <span class="comment">// Floating conversion from quadword to longword is accomplished by</span>
01826         <span class="comment">// truncating the high order 32 bits of the quadword after checking</span>
01827         <span class="comment">// for overflow.</span>
01828         <span class="comment">//</span>
01829 
01830         <span class="keywordflow">case</span> CVTQL_FUNC :
01831             <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a1">DBGPRINT2</a>(<span class="stringliteral">"cvtql\n"</span>);
01832 
01833             <span class="keywordflow">return</span> <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a24">KiConvertQuadwordToLongword</a>(&amp;ContextBlock, Quadword);
01834 
01835         <span class="comment">//</span>
01836         <span class="comment">// Floating convert quadword to single.</span>
01837         <span class="comment">//</span>
01838         <span class="comment">// Floating conversion to single is accomplished by forming a</span>
01839         <span class="comment">// single floating operand and then normalizing and storing the</span>
01840         <span class="comment">// result value.</span>
01841         <span class="comment">//</span>
01842 
01843         <span class="keywordflow">case</span> CVTQS_FUNC :
01844             <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a1">DBGPRINT2</a>(<span class="stringliteral">"cvtqs\n"</span>);
01845 
01846             <span class="comment">//</span>
01847             <span class="comment">// Compute the sign of the result.</span>
01848             <span class="comment">//</span>
01849 
01850             <span class="keywordflow">if</span> (Quadword &lt; 0) {
01851                 SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a> = 0x1;
01852                 Quadword = -Quadword;
01853 
01854             } <span class="keywordflow">else</span> {
01855                 SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a> = 0;
01856             }
01857 
01858             <span class="comment">//</span>
01859             <span class="comment">// Initialize the infinity and NaN values.</span>
01860             <span class="comment">//</span>
01861 
01862             SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o3">Infinity</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01863             SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o4">Nan</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01864 
01865             <span class="comment">//</span>
01866             <span class="comment">// Compute the exponent value and normalize the quadword</span>
01867             <span class="comment">// value.</span>
01868             <span class="comment">//</span>
01869 
01870             <span class="keywordflow">if</span> (Quadword != 0) {
01871                 SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">Exponent</a> = SINGLE_EXPONENT_BIAS + 63;
01872                 <span class="keywordflow">while</span> (Quadword &gt; 0) {
01873                     Quadword &lt;&lt;= 1;
01874                     SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">Exponent</a> -= 1;
01875                 }
01876 
01877                 SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> = (LONG)((ULONGLONG)Quadword &gt;&gt; (64 - 26));
01878                 <span class="keywordflow">if</span> (Quadword &amp; (((ULONGLONG)1 &lt;&lt; (64 - 26)) - 1)) {
01879                     StickyBits = 1;
01880 
01881                 } <span class="keywordflow">else</span> {
01882                     StickyBits = 0;
01883                 }
01884 
01885             } <span class="keywordflow">else</span> {
01886                 SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">Exponent</a> = 0;
01887                 SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> = 0;
01888                 StickyBits = 0;
01889             }
01890 
01891             <span class="comment">//</span>
01892             <span class="comment">// Normalize and store the result value.</span>
01893             <span class="comment">//</span>
01894 
01895             <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a27">KiNormalizeSingle</a>(&amp;ContextBlock,
01896                                      &amp;SingleOperand1,
01897                                      StickyBits);
01898 
01899         <span class="comment">//</span>
01900         <span class="comment">// Floating convert quadword to double.</span>
01901         <span class="comment">//</span>
01902         <span class="comment">// Floating conversion to double is accomplished by forming a</span>
01903         <span class="comment">// double floating operand and then normalizing and storing the</span>
01904         <span class="comment">// result value.</span>
01905         <span class="comment">//</span>
01906 
01907         <span class="keywordflow">case</span> CVTQT_FUNC :
01908             <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a1">DBGPRINT2</a>(<span class="stringliteral">"cvtqt\n"</span>);
01909 
01910             <span class="comment">//</span>
01911             <span class="comment">// Compute the sign of the result.</span>
01912             <span class="comment">//</span>
01913 
01914             <span class="keywordflow">if</span> (Quadword &lt; 0) {
01915                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a> = 0x1;
01916                 Quadword = -Quadword;
01917 
01918             } <span class="keywordflow">else</span> {
01919                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a> = 0;
01920             }
01921 
01922             <span class="comment">//</span>
01923             <span class="comment">// Initialize the infinity and NaN values.</span>
01924             <span class="comment">//</span>
01925 
01926             DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o5">Infinity</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01927             DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o6">Nan</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01928 
01929             <span class="comment">//</span>
01930             <span class="comment">// Compute the exponent value and normalize the quadword</span>
01931             <span class="comment">// value.</span>
01932             <span class="comment">//</span>
01933 
01934             <span class="keywordflow">if</span> (Quadword != 0) {
01935                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a> = DOUBLE_EXPONENT_BIAS + 63;
01936                 <span class="keywordflow">while</span> (Quadword &gt; 0) {
01937                     Quadword &lt;&lt;= 1;
01938                     DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a> -= 1;
01939                 }
01940 
01941                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> = (LONG)((ULONGLONG)Quadword &gt;&gt; ((64 - 55) + 32));
01942                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> = (LONG)((ULONGLONG)Quadword &gt;&gt; (64 - 55));
01943                 <span class="keywordflow">if</span> (Quadword &amp; (((ULONGLONG)1 &lt;&lt; (64 - 55)) - 1)) {
01944                     StickyBits = 1;
01945 
01946                 } <span class="keywordflow">else</span> {
01947                     StickyBits = 0;
01948                 }
01949 
01950             } <span class="keywordflow">else</span> {
01951                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> = 0;
01952                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> = 0;
01953                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a> = 0;
01954                 StickyBits = 0;
01955             }
01956 
01957             <span class="comment">//</span>
01958             <span class="comment">// Normalize and store the result value.</span>
01959             <span class="comment">//</span>
01960 
01961             <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a24">KiNormalizeDouble</a>(&amp;ContextBlock,
01962                                      &amp;DoubleOperand1,
01963                                      StickyBits);
01964 
01965         <span class="comment">//</span>
01966         <span class="comment">// Floating convert double to quadword.</span>
01967         <span class="comment">//</span>
01968         <span class="comment">// Floating conversion to quadword is accomplished by forming</span>
01969         <span class="comment">// a quadword value from a double floating value.</span>
01970         <span class="comment">//</span>
01971 
01972         <span class="keywordflow">case</span> CVTTQ_FUNC :
01973             <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a1">DBGPRINT2</a>(<span class="stringliteral">"cvttq\n"</span>);
01974 
01975             <span class="comment">//</span>
01976             <span class="comment">// If the operand is infinite or is a NaN, then store a</span>
01977             <span class="comment">// quiet NaN or an appropriate infinity if the invalid</span>
01978             <span class="comment">// operation trap is disabled, or raise an exception if</span>
01979             <span class="comment">// the invalid trap is enabled.</span>
01980             <span class="comment">//</span>
01981 
01982             <span class="keywordflow">if</span> ((DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o5">Infinity</a> != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) ||
01983                 (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o6">Nan</a> != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>)) {
01984                 <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a22">KiInvalidOperationQuadword</a>(&amp;ContextBlock, 0);
01985             }
01986 
01987             <span class="comment">//</span>
01988             <span class="comment">// Convert double to quadword and store the result value.</span>
01989             <span class="comment">//</span>
01990 
01991             <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a26">KiNormalizeQuadword</a>(&amp;ContextBlock, &amp;DoubleOperand1);
01992         }
01993 
01994     <span class="comment">//</span>
01995     <span class="comment">// If an exception occurs, then copy the new exception information to the</span>
01996     <span class="comment">// original exception record and handle the exception.</span>
01997     <span class="comment">//</span>
01998 
01999     } except (<a class="code" href="../../d2/d9/ppc_2exceptn_8c.html#a12">KiCopyInformation</a>(ExceptionRecord,
02000                                 (GetExceptionInformation())-&gt;ExceptionRecord)) {
02001 
02002         <span class="comment">//</span>
02003         <span class="comment">// Preserve the original exception address.</span>
02004         <span class="comment">//</span>
02005 
02006         ExceptionRecord-&gt;ExceptionAddress = ExceptionAddress;
02007         <a class="code" href="../../d6/d5/ioep_8h.html#a21">DBGPRINT</a>(<span class="stringliteral">"KiEmulateFloating: Exception\n"</span>);
02008         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02009     }
02010 
02011     <a class="code" href="../../d6/d5/ioep_8h.html#a21">DBGPRINT</a>(<span class="stringliteral">"KiEmulateFloating: Invalid Instruction\n"</span>);
02012     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02013 }
02014 
02015 ULONGLONG
<a name="l02016"></a><a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a22">02016</a> <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a22">KiConvertSingleOperandToRegister</a> (
02017     IN ULONG SingleValue
02018     )
02019 
02020 <span class="comment">/*++</span>
02021 <span class="comment"></span>
02022 <span class="comment">Routine Description:</span>
02023 <span class="comment"></span>
02024 <span class="comment">    This function converts a 32-bit single format floating point value to</span>
02025 <span class="comment">    the 64-bit, double format used within floating point registers. Alpha</span>
02026 <span class="comment">    floating point registers are 64-bits wide and single format values are</span>
02027 <span class="comment">    transformed to 64-bits when stored or loaded from memory.</span>
02028 <span class="comment"></span>
02029 <span class="comment">Arguments:</span>
02030 <span class="comment"></span>
02031 <span class="comment">    SingleValue - Supplies the 32-bit single operand value as an integer.</span>
02032 <span class="comment"></span>
02033 <span class="comment">Return Value:</span>
02034 <span class="comment"></span>
02035 <span class="comment">    The 64-bit register format operand value is returned as the function</span>
02036 <span class="comment">    value.</span>
02037 <span class="comment"></span>
02038 <span class="comment">--*/</span>
02039 
02040 {
02041     <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a19">PDOUBLE_FORMAT</a> DoubleFormat;
02042     ULONGLONG Result;
02043     <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a21">PSINGLE_FORMAT</a> SingleFormat;
02044 
02045     SingleFormat = (<a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a21">PSINGLE_FORMAT</a>)&amp;SingleValue;
02046     DoubleFormat = (<a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a19">PDOUBLE_FORMAT</a>)&amp;Result;
02047 
02048     DoubleFormat-&gt;<a class="code" href="../../d5/d8/struct__DOUBLE__FORMAT.html#o2">Sign</a> = SingleFormat-&gt;<a class="code" href="../../d4/d3/struct__SINGLE__FORMAT.html#o2">Sign</a>;
02049     DoubleFormat-&gt;<a class="code" href="../../d5/d8/struct__DOUBLE__FORMAT.html#o0">Mantissa</a> = ((ULONGLONG)SingleFormat-&gt;<a class="code" href="../../d4/d3/struct__SINGLE__FORMAT.html#o0">Mantissa</a>) &lt;&lt; (52 - 23);
02050     <span class="keywordflow">if</span> (SingleFormat-&gt;<a class="code" href="../../d4/d3/struct__SINGLE__FORMAT.html#o1">Exponent</a> == SINGLE_MAXIMUM_EXPONENT) {
02051         DoubleFormat-&gt;<a class="code" href="../../d5/d8/struct__DOUBLE__FORMAT.html#o1">Exponent</a> = DOUBLE_MAXIMUM_EXPONENT;
02052 
02053     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (SingleFormat-&gt;<a class="code" href="../../d4/d3/struct__SINGLE__FORMAT.html#o1">Exponent</a> == SINGLE_MINIMUM_EXPONENT) {
02054         DoubleFormat-&gt;<a class="code" href="../../d5/d8/struct__DOUBLE__FORMAT.html#o1">Exponent</a> = DOUBLE_MINIMUM_EXPONENT;
02055 
02056     } <span class="keywordflow">else</span> {
02057         DoubleFormat-&gt;<a class="code" href="../../d5/d8/struct__DOUBLE__FORMAT.html#o1">Exponent</a> = SingleFormat-&gt;<a class="code" href="../../d4/d3/struct__SINGLE__FORMAT.html#o1">Exponent</a> - SINGLE_EXPONENT_BIAS +
02058                                  DOUBLE_EXPONENT_BIAS;
02059     }
02060     <span class="keywordflow">return</span> Result;
02061 }
02062 
02063 ULONG
<a name="l02064"></a><a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a23">02064</a> <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a23">KiConvertRegisterToSingleOperand</a> (
02065     IN ULONGLONG DoubleValue
02066     )
02067 
02068 <span class="comment">/*++</span>
02069 <span class="comment"></span>
02070 <span class="comment">Routine Description:</span>
02071 <span class="comment"></span>
02072 <span class="comment">    This function converts the 64-bit, double format floating point value</span>
02073 <span class="comment">    used within the floating point registers to a 32-bit, single format</span>
02074 <span class="comment">    floating point value.</span>
02075 <span class="comment"></span>
02076 <span class="comment">Arguments:</span>
02077 <span class="comment"></span>
02078 <span class="comment">    DoubleValue - Supplies the 64-bit double operand value as an integer.</span>
02079 <span class="comment"></span>
02080 <span class="comment">Return Value:</span>
02081 <span class="comment"></span>
02082 <span class="comment">    The 32-bit register format operand value is returned as the function</span>
02083 <span class="comment">    value.</span>
02084 <span class="comment"></span>
02085 <span class="comment">--*/</span>
02086 
02087 {
02088     <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a19">PDOUBLE_FORMAT</a> DoubleFormat;
02089     ULONG Result;
02090     <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a21">PSINGLE_FORMAT</a> SingleFormat;
02091 
02092     SingleFormat = (<a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a21">PSINGLE_FORMAT</a>)&amp;Result;
02093     DoubleFormat = (<a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a19">PDOUBLE_FORMAT</a>)&amp;DoubleValue;
02094 
02095     SingleFormat-&gt;<a class="code" href="../../d4/d3/struct__SINGLE__FORMAT.html#o2">Sign</a> = (ULONG)DoubleFormat-&gt;<a class="code" href="../../d5/d8/struct__DOUBLE__FORMAT.html#o2">Sign</a>;
02096     SingleFormat-&gt;<a class="code" href="../../d4/d3/struct__SINGLE__FORMAT.html#o0">Mantissa</a> = (ULONG)(DoubleFormat-&gt;<a class="code" href="../../d5/d8/struct__DOUBLE__FORMAT.html#o0">Mantissa</a> &gt;&gt; (52 - 23));
02097     <span class="keywordflow">if</span> (DoubleFormat-&gt;<a class="code" href="../../d5/d8/struct__DOUBLE__FORMAT.html#o1">Exponent</a> == DOUBLE_MAXIMUM_EXPONENT) {
02098         SingleFormat-&gt;<a class="code" href="../../d4/d3/struct__SINGLE__FORMAT.html#o1">Exponent</a> = SINGLE_MAXIMUM_EXPONENT;
02099 
02100     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (DoubleFormat-&gt;<a class="code" href="../../d5/d8/struct__DOUBLE__FORMAT.html#o1">Exponent</a> == DOUBLE_MINIMUM_EXPONENT) {
02101         SingleFormat-&gt;<a class="code" href="../../d4/d3/struct__SINGLE__FORMAT.html#o1">Exponent</a> = SINGLE_MINIMUM_EXPONENT;
02102 
02103     } <span class="keywordflow">else</span> {
02104         SingleFormat-&gt;<a class="code" href="../../d4/d3/struct__SINGLE__FORMAT.html#o1">Exponent</a> = (ULONG)(DoubleFormat-&gt;<a class="code" href="../../d5/d8/struct__DOUBLE__FORMAT.html#o1">Exponent</a> - DOUBLE_EXPONENT_BIAS +
02105                                          SINGLE_EXPONENT_BIAS);
02106     }
02107     <span class="keywordflow">return</span> Result;
02108 }
02109 
02110 BOOLEAN
<a name="l02111"></a><a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a24">02111</a> <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a24">KiConvertQuadwordToLongword</a> (
02112     IN PFP_CONTEXT_BLOCK ContextBlock,
02113     IN LONGLONG Quadword
02114     )
02115 
02116 <span class="comment">/*++</span>
02117 <span class="comment"></span>
02118 <span class="comment">Routine Description:</span>
02119 <span class="comment"></span>
02120 <span class="comment">    This function is called to convert a quadword operand to a longword</span>
02121 <span class="comment">    result.</span>
02122 <span class="comment"></span>
02123 <span class="comment">Arguments:</span>
02124 <span class="comment"></span>
02125 <span class="comment">    ContextBlock - Supplies a pointer to the emulation context block.</span>
02126 <span class="comment"></span>
02127 <span class="comment">    Operand - Supplies the quadword operand value.</span>
02128 <span class="comment"></span>
02129 <span class="comment">Return Value:</span>
02130 <span class="comment"></span>
02131 <span class="comment">    If the quadword value would overflow the longword result and the invalid</span>
02132 <span class="comment">    trap is enabled then a value of FALSE is returned. Otherwise, the quadword</span>
02133 <span class="comment">    is truncated to a longword and a value of TRUE is returned.</span>
02134 <span class="comment"></span>
02135 <span class="comment">--*/</span>
02136 
02137 {
02138     PEXCEPTION_RECORD ExceptionRecord;
02139     PFPCR Fpcr;
02140     PFP_IEEE_VALUE IeeeValue;
02141     ULONGLONG ResultValue;
02142     PSW_FPCR SoftwareFpcr;
02143 
02144     <span class="comment">//</span>
02145     <span class="comment">// Truncate the quadword to a longword and convert the longword integer</span>
02146     <span class="comment">// to floating register longword integer format.</span>
02147     <span class="comment">//</span>
02148 
02149     ResultValue = ((Quadword &amp; (ULONGLONG)0xc0000000) &lt;&lt; 32) |
02150                   ((Quadword &amp; (ULONGLONG)0x3fffffff) &lt;&lt; 29);
02151 
02152     <span class="comment">//</span>
02153     <span class="comment">// Check to determine if an exception should be delivered or the result</span>
02154     <span class="comment">// should be written to the destination register.</span>
02155     <span class="comment">//</span>
02156 
02157     <span class="keywordflow">if</span> ((Quadword &lt; (LONG)0x80000000) || (Quadword &gt; (LONG)0x7fffffff)) {
02158         Fpcr = (PFPCR)&amp;ContextBlock-&gt;TrapFrame-&gt;Fpcr;
02159         Fpcr-&gt;InvalidOperation = 1;
02160         Fpcr-&gt;SummaryBit = 1;
02161         <span class="keywordflow">if</span> (ContextBlock-&gt;IeeeMode == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
02162             ExceptionRecord = ContextBlock-&gt;ExceptionRecord;
02163             ExceptionRecord-&gt;ExceptionCode = STATUS_FLOAT_INVALID_OPERATION;
02164             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02165         }
02166         SoftwareFpcr = ContextBlock-&gt;SoftwareFpcr;
02167         SoftwareFpcr-&gt;StatusInvalid = 1;
02168         <span class="keywordflow">if</span> (SoftwareFpcr-&gt;EnableInvalid != 0) {
02169             ExceptionRecord = ContextBlock-&gt;ExceptionRecord;
02170             ExceptionRecord-&gt;ExceptionCode = STATUS_FLOAT_INVALID_OPERATION;
02171             IeeeValue = <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a27">KiInitializeIeeeValue</a>(ExceptionRecord);
02172             IeeeValue-&gt;Value.U64Value.LowPart = <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a2">LOW_PART</a>(ResultValue);
02173             IeeeValue-&gt;Value.U64Value.HighPart = <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a3">HIGH_PART</a>(ResultValue);
02174             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02175         }
02176 
02177         Fpcr-&gt;DisableInvalid = 1;
02178     }
02179 
02180     <span class="comment">//</span>
02181     <span class="comment">// Set the destination register value and return a value of TRUE.</span>
02182     <span class="comment">//</span>
02183 
02184     <a class="code" href="../../d8/d5/ppc_2getsetrg_8c.html#a1">KiSetRegisterValue</a>(ContextBlock-&gt;Fc + 32,
02185                        ResultValue,
02186                        ContextBlock-&gt;ExceptionFrame,
02187                        ContextBlock-&gt;TrapFrame);
02188     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02189 }
02190 
02191 BOOLEAN
<a name="l02192"></a><a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a25">02192</a> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a16">KiDivideByZeroDouble</a> (
02193     IN PFP_CONTEXT_BLOCK ContextBlock,
02194     IN PFP_DOUBLE_OPERAND DoubleOperand1,
02195     IN PFP_DOUBLE_OPERAND DoubleOperand2
02196     )
02197 
02198 <span class="comment">/*++</span>
02199 <span class="comment"></span>
02200 <span class="comment">Routine Description:</span>
02201 <span class="comment"></span>
02202 <span class="comment">    This function is called to either raise an exception or store a</span>
02203 <span class="comment">    quiet NaN or properly signed infinity for a divide by zero double</span>
02204 <span class="comment">    floating operation.</span>
02205 <span class="comment"></span>
02206 <span class="comment">Arguments:</span>
02207 <span class="comment"></span>
02208 <span class="comment">    ContextBlock - Supplies a pointer to the emulation context block.</span>
02209 <span class="comment"></span>
02210 <span class="comment">    DoubleOperand1 - Supplies a pointer to the first operand value.</span>
02211 <span class="comment"></span>
02212 <span class="comment">    DoubleOperand2 - Supplies a pointer ot the second operand value.</span>
02213 <span class="comment"></span>
02214 <span class="comment">Return Value:</span>
02215 <span class="comment"></span>
02216 <span class="comment">    If the divide by zero trap is enabled and the dividend is not infinite,</span>
02217 <span class="comment">    then a value of FALSE is returned. Otherwise, a quiet NaN or a properly</span>
02218 <span class="comment">    signed infinity is stored as the destination result and a value of TRUE</span>
02219 <span class="comment">    is returned.</span>
02220 <span class="comment"></span>
02221 <span class="comment">--*/</span>
02222 
02223 {
02224 
02225     PEXCEPTION_RECORD ExceptionRecord;
02226     PFPCR Fpcr;
02227     PFP_IEEE_VALUE IeeeValue;
02228     ULONG ResultSign;
02229     ULONG ResultValueHigh;
02230     ULONG ResultValueLow;
02231     PSW_FPCR SoftwareFpcr;
02232 
02233     <span class="comment">//</span>
02234     <span class="comment">// The result value is a properly signed infinity.</span>
02235     <span class="comment">//</span>
02236 
02237     ResultSign = DoubleOperand1-&gt;Sign ^ DoubleOperand2-&gt;Sign;
02238     ResultValueHigh = DOUBLE_INFINITY_VALUE_HIGH | (ResultSign &lt;&lt; 31);
02239     ResultValueLow = DOUBLE_INFINITY_VALUE_LOW;
02240 
02241     <span class="comment">//</span>
02242     <span class="comment">// If the first operand is not infinite and the divide by zero trap is</span>
02243     <span class="comment">// enabled, then store the proper exception code and exception flags</span>
02244     <span class="comment">// and return a value of FALSE. Otherwise, store the appropriately signed</span>
02245     <span class="comment">// infinity and return a value of TRUE.</span>
02246     <span class="comment">//</span>
02247 
02248     <span class="keywordflow">if</span> (DoubleOperand1-&gt;Infinity == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
02249 
02250         Fpcr = (PFPCR)&amp;ContextBlock-&gt;TrapFrame-&gt;Fpcr;
02251         Fpcr-&gt;DivisionByZero = 1;
02252         Fpcr-&gt;SummaryBit = 1;
02253         <span class="keywordflow">if</span> (ContextBlock-&gt;IeeeMode == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
02254             ExceptionRecord = ContextBlock-&gt;ExceptionRecord;
02255             ExceptionRecord-&gt;ExceptionCode = STATUS_FLOAT_DIVIDE_BY_ZERO;
02256             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02257         }
02258         SoftwareFpcr = ContextBlock-&gt;SoftwareFpcr;
02259         SoftwareFpcr-&gt;StatusDivisionByZero = 1;
02260         <span class="keywordflow">if</span> (SoftwareFpcr-&gt;EnableDivisionByZero != 0) {
02261             ExceptionRecord = ContextBlock-&gt;ExceptionRecord;
02262             ExceptionRecord-&gt;ExceptionCode = STATUS_FLOAT_DIVIDE_BY_ZERO;
02263             IeeeValue = <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a27">KiInitializeIeeeValue</a>(ExceptionRecord);
02264             IeeeValue-&gt;Value.Fp64Value.W[0] = ResultValueLow;
02265             IeeeValue-&gt;Value.Fp64Value.W[1] = ResultValueHigh;
02266             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02267         }
02268 
02269         Fpcr-&gt;DisableDivisionByZero = 1;
02270     }
02271 
02272     <a class="code" href="../../d8/d5/ppc_2getsetrg_8c.html#a1">KiSetRegisterValue</a>(ContextBlock-&gt;Fc + 32,
02273                        <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a4">MAKE_QUAD</a>(ResultValueLow, ResultValueHigh),
02274                        ContextBlock-&gt;ExceptionFrame,
02275                        ContextBlock-&gt;TrapFrame);
02276 
02277     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02278 }
02279 
02280 BOOLEAN
<a name="l02281"></a><a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a26">02281</a> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a17">KiDivideByZeroSingle</a> (
02282     IN PFP_CONTEXT_BLOCK ContextBlock,
02283     IN PFP_SINGLE_OPERAND SingleOperand1,
02284     IN PFP_SINGLE_OPERAND SingleOperand2
02285     )
02286 
02287 <span class="comment">/*++</span>
02288 <span class="comment"></span>
02289 <span class="comment">Routine Description:</span>
02290 <span class="comment"></span>
02291 <span class="comment">    This function is called to either raise an exception or store a</span>
02292 <span class="comment">    quiet NaN or properly signed infinity for a divide by zero single</span>
02293 <span class="comment">    floating operation.</span>
02294 <span class="comment"></span>
02295 <span class="comment">Arguments:</span>
02296 <span class="comment"></span>
02297 <span class="comment">    ContextBlock - Supplies a pointer to the emulation context block.</span>
02298 <span class="comment"></span>
02299 <span class="comment">    SingleOperand1 - Supplies a pointer to the first operand value.</span>
02300 <span class="comment"></span>
02301 <span class="comment">    SingleOperand2 - Supplies a pointer ot the second operand value.</span>
02302 <span class="comment"></span>
02303 <span class="comment">Return Value:</span>
02304 <span class="comment"></span>
02305 <span class="comment">    If the divide by zero trap is enabled and the dividend is not infinite,</span>
02306 <span class="comment">    then a value of FALSE is returned. Otherwise, a quiet NaN or a properly</span>
02307 <span class="comment">    signed infinity is stored as the destination result and a value of TRUE</span>
02308 <span class="comment">    is returned.</span>
02309 <span class="comment"></span>
02310 <span class="comment">--*/</span>
02311 
02312 {
02313 
02314     PEXCEPTION_RECORD ExceptionRecord;
02315     PFPCR Fpcr;
02316     PFP_IEEE_VALUE IeeeValue;
02317     ULONG ResultSign;
02318     ULONG ResultValue;
02319     PSW_FPCR SoftwareFpcr;
02320 
02321     <span class="comment">//</span>
02322     <span class="comment">// The result value is a properly signed infinity.</span>
02323     <span class="comment">//</span>
02324 
02325     ResultSign = SingleOperand1-&gt;Sign ^ SingleOperand2-&gt;Sign;
02326     ResultValue = SINGLE_INFINITY_VALUE | (ResultSign &lt;&lt; 31);
02327 
02328     <span class="comment">//</span>
02329     <span class="comment">// If the first operand is not infinite and the divide by zero trap is</span>
02330     <span class="comment">// enabled, then store the proper exception code and exception flags</span>
02331     <span class="comment">// and return a value of FALSE. Otherwise, store the appropriately signed</span>
02332     <span class="comment">// infinity and return a value of TRUE.</span>
02333     <span class="comment">//</span>
02334 
02335     <span class="keywordflow">if</span> (SingleOperand1-&gt;Infinity == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
02336 
02337         Fpcr = (PFPCR)&amp;ContextBlock-&gt;TrapFrame-&gt;Fpcr;
02338         Fpcr-&gt;DivisionByZero = 1;
02339         Fpcr-&gt;SummaryBit = 1;
02340         <span class="keywordflow">if</span> (ContextBlock-&gt;IeeeMode == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
02341             ExceptionRecord = ContextBlock-&gt;ExceptionRecord;
02342             ExceptionRecord-&gt;ExceptionCode = STATUS_FLOAT_DIVIDE_BY_ZERO;
02343             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02344         }
02345         SoftwareFpcr = ContextBlock-&gt;SoftwareFpcr;
02346         SoftwareFpcr-&gt;StatusDivisionByZero = 1;
02347         <span class="keywordflow">if</span> (SoftwareFpcr-&gt;EnableDivisionByZero != 0) {
02348             ExceptionRecord = ContextBlock-&gt;ExceptionRecord;
02349             ExceptionRecord-&gt;ExceptionCode = STATUS_FLOAT_DIVIDE_BY_ZERO;
02350             IeeeValue = <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a27">KiInitializeIeeeValue</a>(ExceptionRecord);
02351             IeeeValue-&gt;Value.Fp32Value.W[0] = ResultValue;
02352             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02353         }
02354 
02355         Fpcr-&gt;DisableDivisionByZero = 1;
02356     }
02357 
02358     <a class="code" href="../../d8/d5/ppc_2getsetrg_8c.html#a1">KiSetRegisterValue</a>(ContextBlock-&gt;Fc + 32,
02359                        <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a22">KiConvertSingleOperandToRegister</a>(ResultValue),
02360                        ContextBlock-&gt;ExceptionFrame,
02361                        ContextBlock-&gt;TrapFrame);
02362 
02363     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02364 }
02365 
02366 PFP_IEEE_VALUE
<a name="l02367"></a><a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a27">02367</a> <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a27">KiInitializeIeeeValue</a> (
02368     IN PEXCEPTION_RECORD ExceptionRecord
02369     )
02370 
02371 <span class="comment">/*++</span>
02372 <span class="comment"></span>
02373 <span class="comment">Routine Description:</span>
02374 <span class="comment"></span>
02375 <span class="comment">    This function is called to initialize an IEEE exception record.</span>
02376 <span class="comment"></span>
02377 <span class="comment">    N.B. The original hardware exception record should be overwritten with an</span>
02378 <span class="comment">         IEEE exception record only when it is known for certain that an IEEE</span>
02379 <span class="comment">         exception must be generated.</span>
02380 <span class="comment"></span>
02381 <span class="comment">Arguments:</span>
02382 <span class="comment"></span>
02383 <span class="comment">    ExceptionRecord - Supplies a pointer to the exception record.</span>
02384 <span class="comment"></span>
02385 <span class="comment">Return Value:</span>
02386 <span class="comment"></span>
02387 <span class="comment">    The address of the IEEE value portion of the exception record is returned</span>
02388 <span class="comment">    as the function value.</span>
02389 <span class="comment"></span>
02390 <span class="comment">--*/</span>
02391 
02392 {
02393 
02394     <span class="comment">//</span>
02395     <span class="comment">// Initialize the number of exception information parameters, zero</span>
02396     <span class="comment">// the first parameter to indicate a hardware initiated exception,</span>
02397     <span class="comment">// set the continuation address, and clear the IEEE exception value.</span>
02398     <span class="comment">//</span>
02399 
02400     ExceptionRecord-&gt;NumberParameters = 6;
02401     ExceptionRecord-&gt;ExceptionInformation[0] = 0;
02402     ExceptionRecord-&gt;ExceptionInformation[1] =
02403         ((ULONG_PTR)(ExceptionRecord)-&gt;ExceptionAddress) + 4;
02404     ExceptionRecord-&gt;ExceptionInformation[2] = 0;
02405     ExceptionRecord-&gt;ExceptionInformation[3] = 0;
02406     ExceptionRecord-&gt;ExceptionInformation[4] = 0;
02407     ExceptionRecord-&gt;ExceptionInformation[5] = 0;
02408 
02409     <span class="comment">//</span>
02410     <span class="comment">// Return address of IEEE exception value.</span>
02411     <span class="comment">//</span>
02412 
02413     <span class="keywordflow">return</span> (PFP_IEEE_VALUE)&amp;ExceptionRecord-&gt;ExceptionInformation[2];
02414 }
02415 
02416 BOOLEAN
<a name="l02417"></a><a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a28">02417</a> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a18">KiInvalidCompareDouble</a> (
02418     IN PFP_CONTEXT_BLOCK ContextBlock,
02419     IN BOOLEAN CheckForSignalNan,
02420     IN PFP_DOUBLE_OPERAND DoubleOperand1,
02421     IN PFP_DOUBLE_OPERAND DoubleOperand2
02422     )
02423 
02424 <span class="comment">/*++</span>
02425 <span class="comment"></span>
02426 <span class="comment">Routine Description:</span>
02427 <span class="comment"></span>
02428 <span class="comment">    This function is called to determine whether an invalid operation</span>
02429 <span class="comment">    exception should be raised for a double compare operation.</span>
02430 <span class="comment"></span>
02431 <span class="comment">Arguments:</span>
02432 <span class="comment"></span>
02433 <span class="comment">    ContextBlock - Supplies a pointer to the emulation context block.</span>
02434 <span class="comment"></span>
02435 <span class="comment">    CheckForSignalNan - Supplies a boolean value that determines whether the</span>
02436 <span class="comment">        operand values should be checked for a signaling NaN.</span>
02437 <span class="comment"></span>
02438 <span class="comment">    DoubleOperand1 - Supplies a pointer to the first operand value.</span>
02439 <span class="comment"></span>
02440 <span class="comment">    DoubleOperand2 - Supplies a pointer ot the second operand value.</span>
02441 <span class="comment"></span>
02442 <span class="comment">Return Value:</span>
02443 <span class="comment"></span>
02444 <span class="comment">    If the invalid operation trap is enabled and either the operation is</span>
02445 <span class="comment">    invalid or one of the operands in a signaling NaN, then a value of</span>
02446 <span class="comment">    FALSE is returned. Otherwise, no operation is performed and a value</span>
02447 <span class="comment">    of TRUE is returned.</span>
02448 <span class="comment"></span>
02449 <span class="comment">--*/</span>
02450 
02451 {
02452 
02453     PEXCEPTION_RECORD ExceptionRecord;
02454     PFPCR Fpcr;
02455     PFP_IEEE_VALUE IeeeValue;
02456     PSW_FPCR SoftwareFpcr;
02457 
02458     <span class="comment">//</span>
02459     <span class="comment">// If an invalid operation is specified or one of the operands is a</span>
02460     <span class="comment">// signaling NaN and the invalid operation trap is enabled, then</span>
02461     <span class="comment">// store the proper exception code and exception flags and return</span>
02462     <span class="comment">// a value of FALSE. Otherwise, perform no operation and return a</span>
02463     <span class="comment">// value of TRUE.</span>
02464     <span class="comment">//</span>
02465 
02466     <span class="keywordflow">if</span> ((CheckForSignalNan == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) ||
02467         (<a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a8">DoubleSignalNan</a>(DoubleOperand1) != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) ||
02468         (<a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a8">DoubleSignalNan</a>(DoubleOperand2) != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>)) {
02469 
02470         Fpcr = (PFPCR)&amp;ContextBlock-&gt;TrapFrame-&gt;Fpcr;
02471         Fpcr-&gt;InvalidOperation = 1;
02472         Fpcr-&gt;SummaryBit = 1;
02473         <span class="keywordflow">if</span> (ContextBlock-&gt;IeeeMode == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
02474             ExceptionRecord = ContextBlock-&gt;ExceptionRecord;
02475             ExceptionRecord-&gt;ExceptionCode = STATUS_FLOAT_INVALID_OPERATION;
02476             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02477         }
02478         SoftwareFpcr = ContextBlock-&gt;SoftwareFpcr;
02479         SoftwareFpcr-&gt;StatusInvalid = 1;
02480         <span class="keywordflow">if</span> (SoftwareFpcr-&gt;EnableInvalid != 0) {
02481             ExceptionRecord = ContextBlock-&gt;ExceptionRecord;
02482             ExceptionRecord-&gt;ExceptionCode = STATUS_FLOAT_INVALID_OPERATION;
02483             IeeeValue = <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a27">KiInitializeIeeeValue</a>(ExceptionRecord);
02484             IeeeValue-&gt;Value.CompareValue = FpCompareUnordered;
02485             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02486         }
02487 
02488         Fpcr-&gt;DisableInvalid = 1;
02489     }
02490 
02491     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02492 }
02493 
02494 BOOLEAN
<a name="l02495"></a><a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a29">02495</a> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a20">KiInvalidOperationDouble</a> (
02496     IN PFP_CONTEXT_BLOCK ContextBlock,
02497     IN BOOLEAN CheckForSignalNan,
02498     IN PFP_DOUBLE_OPERAND DoubleOperand1,
02499     IN PFP_DOUBLE_OPERAND DoubleOperand2
02500     )
02501 
02502 <span class="comment">/*++</span>
02503 <span class="comment"></span>
02504 <span class="comment">Routine Description:</span>
02505 <span class="comment"></span>
02506 <span class="comment">    This function is called to either raise an exception or store a</span>
02507 <span class="comment">    quiet NaN for an invalid double floating operation.</span>
02508 <span class="comment"></span>
02509 <span class="comment">Arguments:</span>
02510 <span class="comment"></span>
02511 <span class="comment">    ContextBlock - Supplies a pointer to the emulation context block.</span>
02512 <span class="comment"></span>
02513 <span class="comment">    CheckForSignalNan - Supplies a boolean value that determines whether the</span>
02514 <span class="comment">        operand values should be checked for a signaling NaN.</span>
02515 <span class="comment"></span>
02516 <span class="comment">    DoubleOperand1 - Supplies a pointer to the first operand value.</span>
02517 <span class="comment"></span>
02518 <span class="comment">    DoubleOperand2 - Supplies a pointer ot the second operand value.</span>
02519 <span class="comment"></span>
02520 <span class="comment">Return Value:</span>
02521 <span class="comment"></span>
02522 <span class="comment">    If the invalid operation trap is enabled and either the operation is</span>
02523 <span class="comment">    invalid or one of the operands in a signaling NaN, then a value of</span>
02524 <span class="comment">    FALSE is returned. Otherwise, a quiet NaN is stored as the destination</span>
02525 <span class="comment">    result and a value of TRUE is returned.</span>
02526 <span class="comment"></span>
02527 <span class="comment">--*/</span>
02528 
02529 {
02530 
02531     PEXCEPTION_RECORD ExceptionRecord;
02532     PFPCR Fpcr;
02533     PFP_IEEE_VALUE IeeeValue;
02534     ULONG ResultValueHigh;
02535     ULONG ResultValueLow;
02536     PSW_FPCR SoftwareFpcr;
02537 
02538     <span class="comment">//</span>
02539     <span class="comment">// If the second operand is a NaN, then compute a quiet NaN from its</span>
02540     <span class="comment">// value. Otherwise, if the first operand is a NaN, then compute a</span>
02541     <span class="comment">// quiet NaN from its value. Otherwise, the result value is a quiet</span>
02542     <span class="comment">// (real indefinite) NaN.</span>
02543     <span class="comment">//</span>
02544 
02545     <a class="code" href="../../d6/d5/ioep_8h.html#a21">DBGPRINT</a>(<span class="stringliteral">"Operand1: Inf=%d NaN=%d Sign=%d Exponent=%d Mantissa=%.8x%.8x\n"</span>,
02546              DoubleOperand1-&gt;Infinity, DoubleOperand1-&gt;Nan,
02547              DoubleOperand1-&gt;Sign,
02548              DoubleOperand1-&gt;Exponent,
02549              DoubleOperand1-&gt;MantissaHigh, DoubleOperand1-&gt;MantissaLow);
02550     <a class="code" href="../../d6/d5/ioep_8h.html#a21">DBGPRINT</a>(<span class="stringliteral">"Operand2: Inf=%d NaN=%d Sign=%d Exponent=%d Mantissa=%.8x%.8x\n"</span>,
02551              DoubleOperand2-&gt;Infinity, DoubleOperand2-&gt;Nan,
02552              DoubleOperand2-&gt;Sign,
02553              DoubleOperand2-&gt;Exponent,
02554              DoubleOperand2-&gt;MantissaHigh, DoubleOperand2-&gt;MantissaLow);
02555 
02556     <span class="keywordflow">if</span> (DoubleOperand2-&gt;Nan != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
02557         ResultValueLow = DoubleOperand2-&gt;MantissaLow &gt;&gt; 2;
02558         ResultValueLow |= DoubleOperand2-&gt;MantissaHigh &lt;&lt; 30;
02559         ResultValueHigh = DoubleOperand2-&gt;MantissaHigh &gt;&gt; 2;
02560         ResultValueHigh |= DOUBLE_QUIET_NAN_PREFIX_HIGH;
02561         ResultValueHigh |= DoubleOperand2-&gt;Sign &lt;&lt; 31;
02562 
02563     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (DoubleOperand1-&gt;Nan != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
02564         ResultValueLow = DoubleOperand1-&gt;MantissaLow &gt;&gt; 2;
02565         ResultValueLow |= DoubleOperand1-&gt;MantissaHigh &lt;&lt; 30;
02566         ResultValueHigh = DoubleOperand1-&gt;MantissaHigh &gt;&gt; 2;
02567         ResultValueHigh |= DOUBLE_QUIET_NAN_PREFIX_HIGH;
02568         ResultValueHigh |= DoubleOperand1-&gt;Sign &lt;&lt; 31;
02569 
02570     } <span class="keywordflow">else</span> {
02571         ResultValueLow = DOUBLE_QUIET_NAN_VALUE_LOW;
02572         ResultValueHigh = DOUBLE_QUIET_NAN_VALUE_HIGH;
02573     }
02574 
02575     <span class="comment">//</span>
02576     <span class="comment">// If an invalid operation is specified or one of the operands is a</span>
02577     <span class="comment">// signaling NaN and the invalid operation trap is enabled, then</span>
02578     <span class="comment">// store the proper exception code and exception flags and return</span>
02579     <span class="comment">// a value of FALSE. Otherwise, store a quiet NaN as the destination</span>
02580     <span class="comment">// result and return a value of TRUE.</span>
02581     <span class="comment">//</span>
02582 
02583     <span class="keywordflow">if</span> ((CheckForSignalNan == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) ||
02584         (<a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a8">DoubleSignalNan</a>(DoubleOperand1) != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) ||
02585         (<a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a8">DoubleSignalNan</a>(DoubleOperand2) != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>)) {
02586 
02587         Fpcr = (PFPCR)&amp;ContextBlock-&gt;TrapFrame-&gt;Fpcr;
02588         Fpcr-&gt;InvalidOperation = 1;
02589         Fpcr-&gt;SummaryBit = 1;
02590         <span class="keywordflow">if</span> (ContextBlock-&gt;IeeeMode == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
02591             ExceptionRecord = ContextBlock-&gt;ExceptionRecord;
02592             ExceptionRecord-&gt;ExceptionCode = STATUS_FLOAT_INVALID_OPERATION;
02593             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02594         }
02595         SoftwareFpcr = ContextBlock-&gt;SoftwareFpcr;
02596         SoftwareFpcr-&gt;StatusInvalid = 1;
02597         <span class="keywordflow">if</span> (SoftwareFpcr-&gt;EnableInvalid != 0) {
02598             ExceptionRecord = ContextBlock-&gt;ExceptionRecord;
02599             ExceptionRecord-&gt;ExceptionCode = STATUS_FLOAT_INVALID_OPERATION;
02600             IeeeValue = <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a27">KiInitializeIeeeValue</a>(ExceptionRecord);
02601             IeeeValue-&gt;Value.Fp64Value.W[0] = ResultValueLow;
02602             IeeeValue-&gt;Value.Fp64Value.W[1] = ResultValueHigh;
02603             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02604         }
02605 
02606         Fpcr-&gt;DisableInvalid = 1;
02607     }
02608 
02609     <a class="code" href="../../d8/d5/ppc_2getsetrg_8c.html#a1">KiSetRegisterValue</a>(ContextBlock-&gt;Fc + 32,
02610                        <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a4">MAKE_QUAD</a>(ResultValueLow, ResultValueHigh),
02611                        ContextBlock-&gt;ExceptionFrame,
02612                        ContextBlock-&gt;TrapFrame);
02613 
02614     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02615 }
02616 
02617 BOOLEAN
<a name="l02618"></a><a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a30">02618</a> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a22">KiInvalidOperationQuadword</a> (
02619     IN PFP_CONTEXT_BLOCK ContextBlock,
02620     IN ULONGLONG ResultValue
02621     )
02622 
02623 <span class="comment">/*++</span>
02624 <span class="comment"></span>
02625 <span class="comment">Routine Description:</span>
02626 <span class="comment"></span>
02627 <span class="comment">    This function is called to either raise an exception or store a</span>
02628 <span class="comment">    quiet NaN for an invalid conversion to quadword.</span>
02629 <span class="comment"></span>
02630 <span class="comment">Arguments:</span>
02631 <span class="comment"></span>
02632 <span class="comment">    ContextBlock - Supplies a pointer to the emulation context block.</span>
02633 <span class="comment"></span>
02634 <span class="comment">    ResultValue - Suplies a quadword result value to be stored.</span>
02635 <span class="comment"></span>
02636 <span class="comment">Return Value:</span>
02637 <span class="comment"></span>
02638 <span class="comment">    If the invalid operation trap is enabled, then a value of FALSE is</span>
02639 <span class="comment">    returned. Otherwise, an appropriate quadword value is stored as the</span>
02640 <span class="comment">    destination result and a value of TRUE is returned.</span>
02641 <span class="comment"></span>
02642 <span class="comment">--*/</span>
02643 
02644 {
02645 
02646     PEXCEPTION_RECORD ExceptionRecord;
02647     PFPCR Fpcr;
02648     PFP_IEEE_VALUE IeeeValue;
02649     PSW_FPCR SoftwareFpcr;
02650 
02651     <span class="comment">//</span>
02652     <span class="comment">// If the invalid operation trap is enabled then store the proper</span>
02653     <span class="comment">// exception code and exception flags and return a value of FALSE.</span>
02654     <span class="comment">// Otherwise, store a quiet NaN as the destination result and return</span>
02655     <span class="comment">// a value of TRUE.</span>
02656     <span class="comment">//</span>
02657 
02658     Fpcr = (PFPCR)&amp;ContextBlock-&gt;TrapFrame-&gt;Fpcr;
02659     Fpcr-&gt;InvalidOperation = 1;
02660     Fpcr-&gt;SummaryBit = 1;
02661     <span class="keywordflow">if</span> (ContextBlock-&gt;IeeeMode == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
02662         ExceptionRecord = ContextBlock-&gt;ExceptionRecord;
02663         ExceptionRecord-&gt;ExceptionCode = STATUS_FLOAT_INVALID_OPERATION;
02664         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02665     }
02666     SoftwareFpcr = ContextBlock-&gt;SoftwareFpcr;
02667     SoftwareFpcr-&gt;StatusInvalid = 1;
02668     <span class="keywordflow">if</span> (SoftwareFpcr-&gt;EnableInvalid != 0) {
02669         ExceptionRecord = ContextBlock-&gt;ExceptionRecord;
02670         ExceptionRecord-&gt;ExceptionCode = STATUS_FLOAT_INVALID_OPERATION;
02671         IeeeValue = <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a27">KiInitializeIeeeValue</a>(ExceptionRecord);
02672         IeeeValue-&gt;Value.U64Value.LowPart = <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a2">LOW_PART</a>(ResultValue);
02673         IeeeValue-&gt;Value.U64Value.HighPart = <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a3">HIGH_PART</a>(ResultValue);
02674         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02675     }
02676 
02677     Fpcr-&gt;DisableInvalid = 1;
02678 
02679     <a class="code" href="../../d8/d5/ppc_2getsetrg_8c.html#a1">KiSetRegisterValue</a>(ContextBlock-&gt;Fc + 32,
02680                        ResultValue,
02681                        ContextBlock-&gt;ExceptionFrame,
02682                        ContextBlock-&gt;TrapFrame);
02683 
02684     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02685 }
02686 
02687 BOOLEAN
<a name="l02688"></a><a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a31">02688</a> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a23">KiInvalidOperationSingle</a> (
02689     IN PFP_CONTEXT_BLOCK ContextBlock,
02690     IN BOOLEAN CheckForSignalNan,
02691     IN PFP_SINGLE_OPERAND SingleOperand1,
02692     IN PFP_SINGLE_OPERAND SingleOperand2
02693     )
02694 
02695 <span class="comment">/*++</span>
02696 <span class="comment"></span>
02697 <span class="comment">Routine Description:</span>
02698 <span class="comment"></span>
02699 <span class="comment">    This function is called to either raise an exception or store a</span>
02700 <span class="comment">    quiet NaN for an invalid single floating operation.</span>
02701 <span class="comment"></span>
02702 <span class="comment">Arguments:</span>
02703 <span class="comment"></span>
02704 <span class="comment">    ContextBlock - Supplies a pointer to the emulation context block.</span>
02705 <span class="comment"></span>
02706 <span class="comment">    CheckForSignalNan - Supplies a boolean value that determines whether the</span>
02707 <span class="comment">        operand values should be checked for a signaling NaN.</span>
02708 <span class="comment"></span>
02709 <span class="comment">    SingleOperand1 - Supplies a pointer to the first operand value.</span>
02710 <span class="comment"></span>
02711 <span class="comment">    SingleOperand2 - Supplies a pointer ot the second operand value.</span>
02712 <span class="comment"></span>
02713 <span class="comment">Return Value:</span>
02714 <span class="comment"></span>
02715 <span class="comment">    If the invalid operation trap is enabled and either the operation is</span>
02716 <span class="comment">    invalid or one of the operands in a signaling NaN, then a value of</span>
02717 <span class="comment">    FALSE is returned. Otherwise, a quiet NaN is stored as the destination</span>
02718 <span class="comment">    result and a value of TRUE is returned.</span>
02719 <span class="comment"></span>
02720 <span class="comment">--*/</span>
02721 
02722 {
02723 
02724     PEXCEPTION_RECORD ExceptionRecord;
02725     PFPCR Fpcr;
02726     PFP_IEEE_VALUE IeeeValue;
02727     ULONG ResultValue;
02728     PSW_FPCR SoftwareFpcr;
02729 
02730     <span class="comment">//</span>
02731     <span class="comment">// If the second operand is a NaN, then compute a quiet NaN from its</span>
02732     <span class="comment">// value. Otherwise, if the first operand is a NaN, then compute a</span>
02733     <span class="comment">// quiet NaN from its value. Otherwise, the result value is a quiet</span>
02734     <span class="comment">// (real indefinite) NaN.</span>
02735     <span class="comment">//</span>
02736 
02737     <span class="keywordflow">if</span> (SingleOperand2-&gt;Nan != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
02738         ResultValue = SingleOperand2-&gt;Mantissa &gt;&gt; 2;
02739         ResultValue |= <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a5">SINGLE_QUIET_NAN_PREFIX</a>;
02740         ResultValue |= SingleOperand2-&gt;Sign &lt;&lt; 31;
02741 
02742     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (SingleOperand1-&gt;Nan != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
02743         ResultValue = SingleOperand1-&gt;Mantissa &gt;&gt; 2;
02744         ResultValue |= <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a5">SINGLE_QUIET_NAN_PREFIX</a>;
02745         ResultValue |= SingleOperand1-&gt;Sign &lt;&lt; 31;
02746 
02747     } <span class="keywordflow">else</span> {
02748         ResultValue = SINGLE_QUIET_NAN_VALUE;
02749     }
02750 
02751     <span class="comment">//</span>
02752     <span class="comment">// If an invalid operation is specified or one of the operands is a</span>
02753     <span class="comment">// signaling NaN and the invalid operation trap is enabled, then</span>
02754     <span class="comment">// store the proper exception code and exception flags and return</span>
02755     <span class="comment">// a value of FALSE. Otherwise, store a quiet NaN as the destination</span>
02756     <span class="comment">// result and return a value of TRUE.</span>
02757     <span class="comment">//</span>
02758 
02759     <span class="keywordflow">if</span> ((CheckForSignalNan == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) ||
02760         (<a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a10">SingleSignalNan</a>(SingleOperand1) != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) ||
02761         (<a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a10">SingleSignalNan</a>(SingleOperand2) != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>)) {
02762 
02763         Fpcr = (PFPCR)&amp;ContextBlock-&gt;TrapFrame-&gt;Fpcr;
02764         Fpcr-&gt;InvalidOperation = 1;
02765         Fpcr-&gt;SummaryBit = 1;
02766         <span class="keywordflow">if</span> (ContextBlock-&gt;IeeeMode == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
02767             ExceptionRecord = ContextBlock-&gt;ExceptionRecord;
02768             ExceptionRecord-&gt;ExceptionCode = STATUS_FLOAT_INVALID_OPERATION;
02769             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02770         }
02771         SoftwareFpcr = ContextBlock-&gt;SoftwareFpcr;
02772         SoftwareFpcr-&gt;StatusInvalid = 1;
02773         <span class="keywordflow">if</span> (SoftwareFpcr-&gt;EnableInvalid != 0) {
02774             ExceptionRecord = ContextBlock-&gt;ExceptionRecord;
02775             ExceptionRecord-&gt;ExceptionCode = STATUS_FLOAT_INVALID_OPERATION;
02776             IeeeValue = <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a27">KiInitializeIeeeValue</a>(ExceptionRecord);
02777             IeeeValue-&gt;Value.Fp32Value.W[0] = ResultValue;
02778             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02779         }
02780 
02781         Fpcr-&gt;DisableInvalid = 1;
02782     }
02783 
02784     <a class="code" href="../../d8/d5/ppc_2getsetrg_8c.html#a1">KiSetRegisterValue</a>(ContextBlock-&gt;Fc + 32,
02785                        <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a22">KiConvertSingleOperandToRegister</a>(ResultValue),
02786                        ContextBlock-&gt;ExceptionFrame,
02787                        ContextBlock-&gt;TrapFrame);
02788 
02789     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02790 }
02791 
02792 BOOLEAN
<a name="l02793"></a><a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a32">02793</a> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a24">KiNormalizeDouble</a> (
02794     IN PFP_CONTEXT_BLOCK ContextBlock,
02795     IN PFP_DOUBLE_OPERAND ResultOperand,
02796     IN ULONGLONG StickyBits
02797     )
02798 
02799 <span class="comment">/*++</span>
02800 <span class="comment"></span>
02801 <span class="comment">Routine Description:</span>
02802 <span class="comment"></span>
02803 <span class="comment">    This function is called to normalize a double floating result.</span>
02804 <span class="comment"></span>
02805 <span class="comment">    N.B. The result value is specified with a guard bit on the right,</span>
02806 <span class="comment">        the hidden bit (if appropriate), and a possible overflow bit.</span>
02807 <span class="comment">        The result format is:</span>
02808 <span class="comment"></span>
02809 <span class="comment">        &lt;63:56&gt; - zero</span>
02810 <span class="comment">        &lt;55&gt; - overflow bit</span>
02811 <span class="comment">        &lt;54&gt; - hidden bit</span>
02812 <span class="comment">        &lt;53:2&gt; - mantissa</span>
02813 <span class="comment">        &lt;1&gt; - guard bit</span>
02814 <span class="comment">        &lt;0&gt; - round bit</span>
02815 <span class="comment"></span>
02816 <span class="comment">        The sticky bits specify bits that were lost during the computation.</span>
02817 <span class="comment"></span>
02818 <span class="comment">Arguments:</span>
02819 <span class="comment"></span>
02820 <span class="comment">    ContextBlock - Supplies a pointer to the emulation context block.</span>
02821 <span class="comment"></span>
02822 <span class="comment">    ResultOperand - Supplies a pointer to the result operand value.</span>
02823 <span class="comment"></span>
02824 <span class="comment">    StickyBits - Supplies the value of the sticky bits.</span>
02825 <span class="comment"></span>
02826 <span class="comment">Return Value:</span>
02827 <span class="comment"></span>
02828 <span class="comment">    If there is not an exception, or the exception is handled, then a proper</span>
02829 <span class="comment">    result is stored in the destination result, the continuation address is</span>
02830 <span class="comment">    set, and a value of TRUE is returned. Otherwise, a proper value is stored and</span>
02831 <span class="comment">    a value of FALSE is returned.</span>
02832 <span class="comment"></span>
02833 <span class="comment">--*/</span>
02834 
02835 {
02836 
02837     ULONGLONG DenormalizeShift;
02838     PEXCEPTION_RECORD ExceptionRecord;
02839     ULONGLONG ExceptionResult;
02840     PFPCR Fpcr;
02841     PFP_IEEE_VALUE IeeeValue;
02842     BOOLEAN Inexact;
02843     ULONGLONG Mantissa;
02844     BOOLEAN Overflow;
02845     ULONGLONG ResultValue;
02846     ULONG RoundBit;
02847     PSW_FPCR SoftwareFpcr;
02848     BOOLEAN Underflow;
02849     ULONGLONG ResultStickyBits;
02850     ULONGLONG ResultMantissa;
02851     ULONG ResultRoundBit;
02852     LONG ResultExponent;
02853     BOOLEAN ReturnValue = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02854 
02855     <span class="comment">//</span>
02856     <span class="comment">// If the result is infinite, then store a properly signed infinity</span>
02857     <span class="comment">// in the destination register and return a value of TRUE. Otherwise,</span>
02858     <span class="comment">// round and normalize the result and check for overflow and underflow.</span>
02859     <span class="comment">//</span>
02860 
02861     <a class="code" href="../../d6/d5/ioep_8h.html#a21">DBGPRINT</a>(<span class="stringliteral">"KiNormalizeDouble: Inf=%d NaN=%d Sign=%d Exponent=%d Mantissa=%.8x%.8x\n"</span>,
02862              ResultOperand-&gt;Infinity, ResultOperand-&gt;Nan, ResultOperand-&gt;Sign,
02863              ResultOperand-&gt;Exponent,
02864              ResultOperand-&gt;MantissaHigh, ResultOperand-&gt;MantissaLow);
02865     <a class="code" href="../../d6/d5/ioep_8h.html#a21">DBGPRINT</a>(<span class="stringliteral">"KiNormalizeDouble: StickyBits=%.16Lx\n"</span>, StickyBits);
02866 
02867     <span class="keywordflow">if</span> (ResultOperand-&gt;Infinity != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
02868         <a class="code" href="../../d8/d5/ppc_2getsetrg_8c.html#a1">KiSetRegisterValue</a>(ContextBlock-&gt;Fc + 32,
02869                            <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a4">MAKE_QUAD</a>(DOUBLE_INFINITY_VALUE_LOW,
02870                                      DOUBLE_INFINITY_VALUE_HIGH |
02871                                          (ResultOperand-&gt;Sign &lt;&lt; 31)),
02872                            ContextBlock-&gt;ExceptionFrame,
02873                            ContextBlock-&gt;TrapFrame);
02874 
02875         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02876     }
02877 
02878     Mantissa = <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a4">MAKE_QUAD</a>(ResultOperand-&gt;MantissaLow,
02879                          ResultOperand-&gt;MantissaHigh);
02880     Fpcr = (PFPCR)&amp;ContextBlock-&gt;TrapFrame-&gt;Fpcr;
02881     SoftwareFpcr = ContextBlock-&gt;SoftwareFpcr;
02882 
02883     <span class="comment">//</span>
02884     <span class="comment">// If the overflow bit is set, then right shift the mantissa one bit,</span>
02885     <span class="comment">// accumulate the lost bit with the sticky bits, and adjust the exponent</span>
02886     <span class="comment">// value.</span>
02887     <span class="comment">//</span>
02888 
02889     <span class="keywordflow">if</span> ((Mantissa &amp; ((ULONGLONG)1 &lt;&lt; 55)) != 0) {
02890         StickyBits |= (Mantissa &amp; 0x1);
02891         Mantissa &gt;&gt;= 1;
02892         ResultOperand-&gt;Exponent += 1;
02893     }
02894 
02895     <span class="comment">//</span>
02896     <span class="comment">// If the mantissa is nonzero, then normalize the mantissa by left</span>
02897     <span class="comment">// shifting one bit at a time until there is a one bit in bit 54.</span>
02898     <span class="comment">//</span>
02899 
02900     <span class="keywordflow">if</span> (Mantissa != 0) {
02901         <span class="keywordflow">while</span> ((Mantissa &amp; ((ULONGLONG)1 &lt;&lt; 54)) == 0) {
02902             Mantissa &lt;&lt;= 1;
02903             ResultOperand-&gt;Exponent -= 1;
02904         }
02905     }
02906 
02907     <span class="comment">//</span>
02908     <span class="comment">// Right shift the mantissa two bits, set the round bit, and accumulate</span>
02909     <span class="comment">// the other lost bit with the sticky bits.</span>
02910     <span class="comment">//</span>
02911 
02912     StickyBits |= (Mantissa &amp; 0x1);
02913     RoundBit = (ULONG)(Mantissa &amp; 0x2);
02914     Mantissa &gt;&gt;= 2;
02915 
02916     <span class="comment">//</span>
02917     <span class="comment">// Convert to denormal format before rounding to allow underflow to</span>
02918     <span class="comment">// be detected on rounded result.  Save context to calculate IEEE</span>
02919     <span class="comment">// exception record, if needed.</span>
02920     <span class="comment">//</span>
02921 
02922     <span class="keywordflow">if</span> (ResultOperand-&gt;Exponent &lt;= DOUBLE_MINIMUM_EXPONENT &amp;&amp; Mantissa != 0) {
02923 
02924         <span class="comment">//</span>
02925         <span class="comment">// Save everything needed for calculating IEEE exception record value</span>
02926         <span class="comment">//</span>
02927 
02928         ResultMantissa = Mantissa;
02929         ResultExponent = ResultOperand-&gt;Exponent;
02930         ResultStickyBits = StickyBits;
02931         ResultRoundBit = RoundBit;
02932 
02933         <span class="comment">//</span>
02934         <span class="comment">// Right shift the mantissa to set the minimum exponent plus an extra</span>
02935         <span class="comment">// bit for the denormal format</span>
02936         <span class="comment">//</span>
02937 
02938         DenormalizeShift = 1 - ResultOperand-&gt;Exponent;
02939 
02940         <span class="comment">//</span>
02941         <span class="comment">// The maximum denormal shift is 52 bits for the mantissa plus 1 bit for the round</span>
02942         <span class="comment">// A denormal shift of 54 guarantees 0 mantissa and 0 round bit and preserves all sticky bits</span>
02943         <span class="comment">//</span>
02944 
02945         <span class="keywordflow">if</span> (DenormalizeShift &gt; 54) {
02946             DenormalizeShift = 54;
02947         }
02948 
02949         <span class="comment">//</span>
02950         <span class="comment">// The denormalized result will be rounded after it is</span>
02951         <span class="comment">// shifted.  Preserve existing Round and Sticky Bits.</span>
02952         <span class="comment">//</span>
02953 
02954         StickyBits |= RoundBit; 
02955         StickyBits |= (Mantissa &lt;&lt; 1) &lt;&lt; (64 - DenormalizeShift); 
02956         RoundBit = (ULONG)(Mantissa &gt;&gt; (DenormalizeShift - 1)) &amp; 1;
02957         Mantissa = Mantissa &gt;&gt; DenormalizeShift;
02958         ResultOperand-&gt;Exponent = DOUBLE_MINIMUM_EXPONENT;
02959     }
02960 
02961     <span class="comment">//</span>
02962     <span class="comment">// Round the result value using the mantissa, the round bit, and the sticky bits.</span>
02963     <span class="comment">//</span>
02964 
02965     <span class="keywordflow">switch</span> (ContextBlock-&gt;Round) {
02966 
02967         <span class="comment">//</span>
02968         <span class="comment">// Round to nearest representable number.</span>
02969         <span class="comment">//</span>
02970 
02971     <span class="keywordflow">case</span> ROUND_TO_NEAREST:
02972         <span class="keywordflow">if</span> (RoundBit != 0) {
02973             <span class="keywordflow">if</span> ((StickyBits != 0) || ((Mantissa &amp; 0x1) != 0)) {
02974                 Mantissa += 1;
02975             }
02976         }
02977         <span class="keywordflow">break</span>;
02978 
02979         <span class="comment">//</span>
02980         <span class="comment">// Round toward zero.</span>
02981         <span class="comment">//</span>
02982 
02983     <span class="keywordflow">case</span> ROUND_TO_ZERO:
02984         <span class="keywordflow">break</span>;
02985 
02986         <span class="comment">//</span>
02987         <span class="comment">// Round toward plus infinity.</span>
02988         <span class="comment">//</span>
02989 
02990     <span class="keywordflow">case</span> ROUND_TO_PLUS_INFINITY:
02991         <span class="keywordflow">if</span> ((ResultOperand-&gt;Sign == 0) &amp;&amp;
02992             ((StickyBits != 0) || (RoundBit != 0))) {
02993             Mantissa += 1;
02994         }
02995         <span class="keywordflow">break</span>;
02996 
02997         <span class="comment">//</span>
02998         <span class="comment">// Round toward minus infinity.</span>
02999         <span class="comment">//</span>
03000 
03001     <span class="keywordflow">case</span> ROUND_TO_MINUS_INFINITY:
03002         <span class="keywordflow">if</span> ((ResultOperand-&gt;Sign != 0) &amp;&amp;
03003             ((StickyBits != 0) || (RoundBit != 0))) {
03004             Mantissa += 1;
03005         }
03006         <span class="keywordflow">break</span>;
03007     }
03008 
03009     <span class="comment">//</span>
03010     <span class="comment">// If rounding resulted in a carry into bit 53, then right shift the</span>
03011     <span class="comment">// mantissa one bit and adjust the exponent.</span>
03012     <span class="comment">//</span>
03013 
03014     <span class="keywordflow">if</span> ((Mantissa &amp; ((ULONGLONG)1 &lt;&lt; 53)) != 0) {
03015         Mantissa &gt;&gt;= 1;
03016         ResultOperand-&gt;Exponent += 1;
03017     }
03018 
03019     <span class="comment">//</span>
03020     <span class="comment">// If rounding resulted in a carry into bit 52 in denormal format, then</span>
03021     <span class="comment">// adjust the exponent.</span>
03022     <span class="comment">//</span>
03023 
03024     <span class="keywordflow">if</span> ((ResultOperand-&gt;Exponent == DOUBLE_MINIMUM_EXPONENT) &amp;&amp; 
03025         (Mantissa &amp; ((ULONGLONG)1 &lt;&lt; 52)) != 0) {
03026         ResultOperand-&gt;Exponent += 1;
03027     }
03028 
03029     <span class="comment">//</span>
03030     <span class="comment">// If the exponent value is greater than or equal to the maximum</span>
03031     <span class="comment">// exponent value, then overflow has occurred. This results in both</span>
03032     <span class="comment">// the inexact and overflow sticky bits being set in the FPCR.</span>
03033     <span class="comment">//</span>
03034     <span class="comment">// If the exponent value is less than or equal to the minimum exponent</span>
03035     <span class="comment">// value, the mantissa is nonzero, and the denormalized result is inexact,</span>
03036     <span class="comment">// then underflow has occurred.  This results in both the inexact and</span>
03037     <span class="comment">// underflow sticky bits being set in the FPCR. </span>
03038     <span class="comment">//</span>
03039     <span class="comment">// Or if underflow exceptions are enabled, underflow occurs for all denormal</span>
03040     <span class="comment">// numbers.  This results in the underflow sticky bit always being set in the</span>
03041     <span class="comment">// FPCR and the inexact sticky bit is set when the denormalized result is</span>
03042     <span class="comment">// also inexact.</span>
03043     <span class="comment">//</span>
03044     <span class="comment">// Otherwise, a normal result can be delivered, but it may be inexact.</span>
03045     <span class="comment">// If the result is inexact, then the inexact sticky bit is set in the</span>
03046     <span class="comment">// FPCR.</span>
03047     <span class="comment">//</span>
03048 
03049     <span class="keywordflow">if</span> (ResultOperand-&gt;Exponent &gt;= DOUBLE_MAXIMUM_EXPONENT) {
03050         Inexact = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03051         Overflow = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03052         Underflow = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03053 
03054         <span class="comment">//</span>
03055         <span class="comment">// The overflow value is dependent on the rounding mode.</span>
03056         <span class="comment">//</span>
03057 
03058         <span class="keywordflow">switch</span> (ContextBlock-&gt;Round) {
03059 
03060             <span class="comment">//</span>
03061             <span class="comment">// Round to nearest representable number.</span>
03062             <span class="comment">//</span>
03063             <span class="comment">// The result value is infinity with the sign of the result.</span>
03064             <span class="comment">//</span>
03065 
03066         <span class="keywordflow">case</span> ROUND_TO_NEAREST:
03067             ResultValue = <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a4">MAKE_QUAD</a>(DOUBLE_INFINITY_VALUE_LOW,
03068                                     DOUBLE_INFINITY_VALUE_HIGH |
03069                                         (ResultOperand-&gt;Sign &lt;&lt; 31));
03070             <span class="keywordflow">break</span>;
03071 
03072             <span class="comment">//</span>
03073             <span class="comment">// Round toward zero.</span>
03074             <span class="comment">//</span>
03075             <span class="comment">// The result is the maximum number with the sign of the result.</span>
03076             <span class="comment">//</span>
03077 
03078         <span class="keywordflow">case</span> ROUND_TO_ZERO:
03079             ResultValue = <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a4">MAKE_QUAD</a>(DOUBLE_MAXIMUM_VALUE_LOW,
03080                                     DOUBLE_MAXIMUM_VALUE_HIGH |
03081                                         (ResultOperand-&gt;Sign &lt;&lt; 31));
03082             <span class="keywordflow">break</span>;
03083 
03084             <span class="comment">//</span>
03085             <span class="comment">// Round toward plus infinity.</span>
03086             <span class="comment">//</span>
03087             <span class="comment">// If the sign of the result is positive, then the result is</span>
03088             <span class="comment">// plus infinity. Otherwise, the result is the maximum negative</span>
03089             <span class="comment">// number.</span>
03090             <span class="comment">//</span>
03091 
03092         <span class="keywordflow">case</span> ROUND_TO_PLUS_INFINITY:
03093             <span class="keywordflow">if</span> (ResultOperand-&gt;Sign == 0) {
03094                 ResultValue = <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a4">MAKE_QUAD</a>(DOUBLE_INFINITY_VALUE_LOW,
03095                                         DOUBLE_INFINITY_VALUE_HIGH);
03096 
03097             } <span class="keywordflow">else</span> {
03098                 ResultValue = <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a4">MAKE_QUAD</a>(DOUBLE_MAXIMUM_VALUE_LOW,
03099                                         DOUBLE_MAXIMUM_VALUE_HIGH |
03100                                             (1 &lt;&lt; 31));
03101             }
03102             <span class="keywordflow">break</span>;
03103 
03104             <span class="comment">//</span>
03105             <span class="comment">// Round toward minus infinity.</span>
03106             <span class="comment">//</span>
03107             <span class="comment">// If the sign of the result is negative, then the result is</span>
03108             <span class="comment">// negative infinity. Otherwise, the result is the maximum</span>
03109             <span class="comment">// positive number.</span>
03110             <span class="comment">//</span>
03111 
03112 
03113         <span class="keywordflow">case</span> ROUND_TO_MINUS_INFINITY:
03114             <span class="keywordflow">if</span> (ResultOperand-&gt;Sign != 0) {
03115                 ResultValue = <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a4">MAKE_QUAD</a>(DOUBLE_INFINITY_VALUE_LOW,
03116                                         DOUBLE_INFINITY_VALUE_HIGH |
03117                                             (1 &lt;&lt; 31));
03118 
03119             } <span class="keywordflow">else</span> {
03120                 ResultValue = <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a4">MAKE_QUAD</a>(DOUBLE_MAXIMUM_VALUE_LOW,
03121                                         DOUBLE_MAXIMUM_VALUE_HIGH);
03122             }
03123             <span class="keywordflow">break</span>;
03124         }
03125 
03126         <span class="comment">//</span>
03127         <span class="comment">// Compute the overflow exception result value by subtracting 1536</span>
03128         <span class="comment">// from the exponent.</span>
03129         <span class="comment">//</span>
03130 
03131         ExceptionResult = Mantissa &amp; (((ULONGLONG)1 &lt;&lt; 52) - 1);
03132         ExceptionResult |= (((ULONGLONG)ResultOperand-&gt;Exponent - 1536) &lt;&lt; 52);
03133         ExceptionResult |= ((ULONGLONG)ResultOperand-&gt;Sign &lt;&lt; 63);
03134 
03135     } <span class="keywordflow">else</span> {
03136 
03137         <span class="comment">//</span>
03138         <span class="comment">// After rounding if the exponent value is equal to</span>
03139         <span class="comment">// the minimum exponent value and the result was nonzero, then</span>
03140         <span class="comment">// underflow has occurred.</span>
03141         <span class="comment">//</span>
03142 
03143         <span class="keywordflow">if</span> ((ResultOperand-&gt;Exponent == DOUBLE_MINIMUM_EXPONENT) &amp;&amp;
03144             (Mantissa != 0 || RoundBit != 00 || StickyBits != 0)) {
03145 
03146             <span class="comment">//</span>
03147             <span class="comment">// If the FPCR underflow to zero (denormal enable) control bit</span>
03148             <span class="comment">// is set, then flush the denormalized result to zero and do</span>
03149             <span class="comment">// not set an underflow status or generate an exception.</span>
03150             <span class="comment">//</span>
03151 
03152             <span class="keywordflow">if</span> ((ContextBlock-&gt;IeeeMode == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) ||
03153                 (SoftwareFpcr-&gt;DenormalResultEnable == 0)) {
03154                 <a class="code" href="../../d6/d5/ioep_8h.html#a21">DBGPRINT</a>(<span class="stringliteral">"SoftwareFpcr-&gt;DenormalResultEnable == 0\n"</span>);
03155                 ResultValue = 0;
03156                 Inexact = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03157                 Overflow = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03158                 Underflow = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03159 
03160             } <span class="keywordflow">else</span> {
03161 
03162                 ResultValue = Mantissa;
03163                 ResultValue |= (ULONGLONG)ResultOperand-&gt;Sign &lt;&lt; 63;
03164 
03165                 <span class="comment">//</span>
03166                 <span class="comment">//</span>
03167                 <span class="comment">// Compute the underflow exception result value by recalculating the</span>
03168                 <span class="comment">// full precision answer and adding 1536 to the exponent.</span>
03169                 <span class="comment">//</span>
03170 
03171                 <span class="comment">//</span>
03172                 <span class="comment">// Round the result value using the mantissa, the round bit, and the sticky bits.</span>
03173                 <span class="comment">//</span>
03174 
03175                 <span class="keywordflow">switch</span> (ContextBlock-&gt;Round) {
03176 
03177                     <span class="comment">//</span>
03178                     <span class="comment">// Round to nearest representable number.</span>
03179                     <span class="comment">//</span>
03180 
03181                 <span class="keywordflow">case</span> ROUND_TO_NEAREST:
03182                     <span class="keywordflow">if</span> (ResultRoundBit != 0) {
03183                         <span class="keywordflow">if</span> ((ResultStickyBits != 0) || ((ResultMantissa &amp; 0x1) != 0)) {
03184                             ResultMantissa += 1;
03185                         }
03186                     }
03187                     <span class="keywordflow">break</span>;
03188 
03189                     <span class="comment">//</span>
03190                     <span class="comment">// Round toward zero.</span>
03191                     <span class="comment">//</span>
03192 
03193                 <span class="keywordflow">case</span> ROUND_TO_ZERO:
03194                     <span class="keywordflow">break</span>;
03195 
03196                     <span class="comment">//</span>
03197                     <span class="comment">// Round toward plus infinity.</span>
03198                     <span class="comment">//</span>
03199 
03200                 <span class="keywordflow">case</span> ROUND_TO_PLUS_INFINITY:
03201                     <span class="keywordflow">if</span> ((ResultOperand-&gt;Sign == 0) &amp;&amp;
03202                         ((ResultStickyBits != 0) || (ResultRoundBit != 0))) {
03203                         ResultMantissa += 1;
03204                     }
03205                     <span class="keywordflow">break</span>;
03206 
03207                     <span class="comment">//</span>
03208                     <span class="comment">// Round toward minus infinity.</span>
03209                     <span class="comment">//</span>
03210 
03211                 <span class="keywordflow">case</span> ROUND_TO_MINUS_INFINITY:
03212                     <span class="keywordflow">if</span> ((ResultOperand-&gt;Sign != 0) &amp;&amp;
03213                         ((ResultStickyBits != 0) || (ResultRoundBit != 0))) {
03214                         ResultMantissa += 1;
03215                     }
03216                     <span class="keywordflow">break</span>;
03217                 }
03218 
03219                 <span class="comment">//</span>
03220                 <span class="comment">// If rounding resulted in a carry into bit 53, then right shift the</span>
03221                 <span class="comment">// mantissa one bit and adjust the exponent.</span>
03222                 <span class="comment">//</span>
03223 
03224                 <span class="keywordflow">if</span> ((ResultMantissa &amp; ((ULONGLONG)1 &lt;&lt; 53)) != 0) {
03225                     ResultMantissa &gt;&gt;= 1;
03226                     ResultExponent += 1;
03227                 }
03228 
03229                 <span class="comment">// Compute the underflow exception result value by adding</span>
03230                 <span class="comment">// 1536 to the exponent.</span>
03231                 <span class="comment">//</span>
03232 
03233                 ExceptionResult = ResultMantissa &amp; (((ULONGLONG)1 &lt;&lt; 52) - 1);
03234                 ExceptionResult |= (((ULONGLONG)ResultExponent + 1536) &lt;&lt; 52);
03235                 ExceptionResult |= ((ULONGLONG)ResultOperand-&gt;Sign &lt;&lt; 63);
03236 
03237                 <span class="comment">//</span>
03238                 <span class="comment">// If the denormalized result is inexact, then set underflow.</span>
03239                 <span class="comment">// Otherwise, for exact denormals do not set the underflow</span>
03240                 <span class="comment">// sticky bit unless underflow exception is enabled.</span>
03241                 <span class="comment">//</span>
03242 
03243                 Overflow = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03244                 Underflow = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03245                 <span class="keywordflow">if</span> ((StickyBits != 0) || (RoundBit != 0)) {
03246                     Inexact = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03247 
03248                 } <span class="keywordflow">else</span> {
03249                     Inexact = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03250                 }
03251             }
03252 
03253         } <span class="keywordflow">else</span> {
03254 
03255             <span class="comment">//</span>
03256             <span class="comment">// If the result is zero, then set the proper sign for zero.</span>
03257             <span class="comment">//</span>
03258 
03259             <span class="keywordflow">if</span> (Mantissa == 0) {
03260                 ResultOperand-&gt;Exponent = 0;
03261             }
03262 
03263             ResultValue = Mantissa &amp; (((ULONGLONG)1 &lt;&lt; 52) - 1);
03264             ResultValue |= (ULONGLONG)ResultOperand-&gt;Exponent &lt;&lt; 52;
03265             ResultValue |= (ULONGLONG)ResultOperand-&gt;Sign &lt;&lt; 63;
03266             <span class="keywordflow">if</span> ((StickyBits != 0) || (RoundBit != 0)) {
03267                 Inexact = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03268 
03269             } <span class="keywordflow">else</span> {
03270                 Inexact = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03271             }
03272             Overflow = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03273             Underflow = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03274         }
03275     }
03276 
03277     <span class="comment">//</span>
03278     <span class="comment">// Check to determine if an exception should be delivered.</span>
03279     <span class="comment">//</span>
03280 
03281     ExceptionRecord = ContextBlock-&gt;ExceptionRecord;
03282 
03283     <span class="keywordflow">if</span> (Overflow != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
03284         Fpcr-&gt;Overflow = 1;
03285         Fpcr-&gt;InexactResult = 1;
03286         Fpcr-&gt;SummaryBit = 1;
03287         <span class="keywordflow">if</span> (ContextBlock-&gt;IeeeMode == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
03288             ExceptionRecord-&gt;ExceptionCode = STATUS_FLOAT_OVERFLOW;
03289             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03290         }
03291         IeeeValue = <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a27">KiInitializeIeeeValue</a>(ExceptionRecord);
03292         SoftwareFpcr-&gt;StatusOverflow = 1;
03293         SoftwareFpcr-&gt;StatusInexact = 1;
03294         <span class="keywordflow">if</span> (SoftwareFpcr-&gt;EnableOverflow != 0) {
03295             ExceptionRecord-&gt;ExceptionCode = STATUS_FLOAT_OVERFLOW;
03296             IeeeValue-&gt;Value.Fp64Value.W[0] = <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a2">LOW_PART</a>(ExceptionResult);
03297             IeeeValue-&gt;Value.Fp64Value.W[1] = <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a3">HIGH_PART</a>(ExceptionResult);
03298             ReturnValue = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03299         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (SoftwareFpcr-&gt;EnableInexact != 0) {
03300             ExceptionRecord-&gt;ExceptionCode = STATUS_FLOAT_INEXACT_RESULT;
03301             IeeeValue-&gt;Value.Fp64Value.W[0] = <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a2">LOW_PART</a>(ExceptionResult);
03302             IeeeValue-&gt;Value.Fp64Value.W[1] = <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a3">HIGH_PART</a>(ExceptionResult);
03303             ReturnValue = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03304         } <span class="keywordflow">else</span> {
03305             Fpcr-&gt;DisableOverflow = 1;
03306             Fpcr-&gt;DisableInexact = 1;
03307         }
03308 
03309     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Underflow != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
03310 
03311         <span class="comment">//</span>
03312         <span class="comment">// Non-IEEE instruction always forces underflow to zero</span>
03313         <span class="comment">//</span>
03314 
03315         <span class="keywordflow">if</span> (ContextBlock-&gt;IeeeMode == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
03316             Fpcr-&gt;Underflow = 1;
03317             Fpcr-&gt;SummaryBit = 1;
03318             Fpcr-&gt;InexactResult = 1;
03319             <span class="keywordflow">if</span> (ContextBlock-&gt;UnderflowEnable != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
03320                 ExceptionRecord-&gt;ExceptionCode = STATUS_FLOAT_UNDERFLOW;
03321                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03322             }
03323 
03324         <span class="comment">//</span>
03325         <span class="comment">// IEEE instructions don't report underflow unless the results are</span>
03326         <span class="comment">// inexact or underflow exceptions are enabled</span>
03327         <span class="comment">//</span>
03328 
03329         } <span class="keywordflow">else</span> {
03330             IeeeValue = <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a27">KiInitializeIeeeValue</a>(ExceptionRecord);
03331             <span class="keywordflow">if</span> (Inexact != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
03332                 Fpcr-&gt;Underflow = 1;
03333                 Fpcr-&gt;SummaryBit = 1;
03334                 Fpcr-&gt;InexactResult = 1;
03335                 SoftwareFpcr-&gt;StatusUnderflow = 1;
03336                 SoftwareFpcr-&gt;StatusInexact = 1;
03337             } 
03338             <span class="keywordflow">if</span> (SoftwareFpcr-&gt;EnableUnderflow != 0) {
03339                 Fpcr-&gt;Underflow = 1;
03340                 Fpcr-&gt;SummaryBit = 1;
03341                 SoftwareFpcr-&gt;StatusUnderflow = 1;
03342                 ExceptionRecord-&gt;ExceptionCode = STATUS_FLOAT_UNDERFLOW;
03343                 IeeeValue-&gt;Value.Fp64Value.W[0] = <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a2">LOW_PART</a>(ExceptionResult);
03344                 IeeeValue-&gt;Value.Fp64Value.W[1] = <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a3">HIGH_PART</a>(ExceptionResult);
03345                 ReturnValue = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03346             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Inexact != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> &amp;&amp; SoftwareFpcr-&gt;EnableInexact != 0) {
03347                 ExceptionRecord-&gt;ExceptionCode = STATUS_FLOAT_INEXACT_RESULT;
03348                 IeeeValue-&gt;Value.Fp64Value.W[0] = <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a2">LOW_PART</a>(ExceptionResult);
03349                 IeeeValue-&gt;Value.Fp64Value.W[1] = <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a3">HIGH_PART</a>(ExceptionResult);
03350                 ReturnValue = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03351             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Inexact != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
03352                 Fpcr-&gt;DisableUnderflow = 1;
03353                 Fpcr-&gt;DisableInexact = 1;
03354             }
03355         }
03356 
03357     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Inexact != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
03358         Fpcr-&gt;InexactResult = 1;
03359         Fpcr-&gt;SummaryBit = 1;
03360         <span class="keywordflow">if</span> (ContextBlock-&gt;IeeeMode != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
03361             IeeeValue = <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a27">KiInitializeIeeeValue</a>(ExceptionRecord);
03362             SoftwareFpcr-&gt;StatusInexact = 1;
03363             <span class="keywordflow">if</span> (SoftwareFpcr-&gt;EnableInexact != 0) {
03364                 ExceptionRecord-&gt;ExceptionCode = STATUS_FLOAT_INEXACT_RESULT;
03365                 IeeeValue-&gt;Value.Fp64Value.W[0] = <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a2">LOW_PART</a>(ResultValue);
03366                 IeeeValue-&gt;Value.Fp64Value.W[1] = <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a3">HIGH_PART</a>(ResultValue);
03367                 ReturnValue = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03368             } <span class="keywordflow">else</span> {
03369                 Fpcr-&gt;DisableInexact = 1;
03370             }
03371         }
03372     }
03373 
03374     <span class="comment">//</span>
03375     <span class="comment">// Always write the destination register.  If an exception is delivered, and</span>
03376     <span class="comment">// then dismissed, the correct value must be in the register.</span>
03377     <span class="comment">//</span>
03378 
03379     <a class="code" href="../../d8/d5/ppc_2getsetrg_8c.html#a1">KiSetRegisterValue</a>(ContextBlock-&gt;Fc + 32,
03380                        ResultValue,
03381                        ContextBlock-&gt;ExceptionFrame,
03382                        ContextBlock-&gt;TrapFrame);
03383 
03384     <span class="comment">//</span>
03385     <span class="comment">// Return a value of TRUE.unless an exception should be generated</span>
03386     <span class="comment">//</span>
03387 
03388     <span class="keywordflow">return</span> ReturnValue;
03389 }
03390 
03391 BOOLEAN
<a name="l03392"></a><a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a33">03392</a> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a26">KiNormalizeQuadword</a> (
03393     IN PFP_CONTEXT_BLOCK ContextBlock,
03394     IN PFP_DOUBLE_OPERAND ResultOperand
03395     )
03396 
03397 <span class="comment">/*++</span>
03398 <span class="comment"></span>
03399 <span class="comment">Routine Description:</span>
03400 <span class="comment"></span>
03401 <span class="comment">    This function is called to convert a result value to a quadword result.</span>
03402 <span class="comment"></span>
03403 <span class="comment">    N.B. The result value is specified with a guard bit on the right,</span>
03404 <span class="comment">        the hidden bit (if appropriate), and an overflow bit of zero.</span>
03405 <span class="comment">        As called above, the guard bit and the round bit are also zero.</span>
03406 <span class="comment">        The result format is:</span>
03407 <span class="comment"></span>
03408 <span class="comment">        &lt;63:55&gt; - zero</span>
03409 <span class="comment">        &lt;54 - hidden bit</span>
03410 <span class="comment">        &lt;53:2&gt; - mantissa</span>
03411 <span class="comment">        &lt;1&gt; - guard bit</span>
03412 <span class="comment">        &lt;0&gt; - round bit</span>
03413 <span class="comment"></span>
03414 <span class="comment">        There are no sticky bits.</span>
03415 <span class="comment"></span>
03416 <span class="comment">Arguments:</span>
03417 <span class="comment"></span>
03418 <span class="comment">    ContextBlock - Supplies a pointer to the emulation context block.</span>
03419 <span class="comment"></span>
03420 <span class="comment">    ResultOperand - Supplies a pointer to the result operand value.</span>
03421 <span class="comment"></span>
03422 <span class="comment">Return Value:</span>
03423 <span class="comment"></span>
03424 <span class="comment">    If there is not an exception, or the exception is handled, then a proper</span>
03425 <span class="comment">    result is stored in the destination result, the continuation address is</span>
03426 <span class="comment">    set, and a value of TRUE is returned. Otherwise, no value is stored and</span>
03427 <span class="comment">    a value of FALSE is returned.</span>
03428 <span class="comment"></span>
03429 <span class="comment">--*/</span>
03430 
03431 {
03432 
03433     PEXCEPTION_RECORD ExceptionRecord;
03434     LONGLONG ExponentShift;
03435     PFPCR Fpcr;
03436     PFP_IEEE_VALUE IeeeValue;
03437     ULONGLONG Mantissa;
03438     BOOLEAN Overflow;
03439     ULONGLONG ResultValue;
03440     ULONG RoundBit;
03441     ULONGLONG StickyBits;
03442     PSW_FPCR SoftwareFpcr;
03443 
03444     <span class="comment">//</span>
03445     <span class="comment">// Subtract out the exponent bias and divide the cases into right</span>
03446     <span class="comment">// and left shifts.</span>
03447     <span class="comment">//</span>
03448 
03449     ExponentShift = ResultOperand-&gt;Exponent - DOUBLE_EXPONENT_BIAS;
03450     <a class="code" href="../../d6/d5/ioep_8h.html#a21">DBGPRINT</a>(<span class="stringliteral">"KiNormalizeQuadword: Inf=%d NaN=%d Sign=%d Exponent=%d Mantissa=%.8x%.8x\n"</span>,
03451              ResultOperand-&gt;Infinity, ResultOperand-&gt;Nan, ResultOperand-&gt;Sign,
03452              ResultOperand-&gt;Exponent,
03453              ResultOperand-&gt;MantissaHigh, ResultOperand-&gt;MantissaLow);
03454     <a class="code" href="../../d6/d5/ioep_8h.html#a21">DBGPRINT</a>(<span class="stringliteral">".. ExponentShift = %d\n"</span>, ExponentShift);
03455     Mantissa = <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a4">MAKE_QUAD</a>(ResultOperand-&gt;MantissaLow,
03456                          ResultOperand-&gt;MantissaHigh);
03457 
03458     <span class="keywordflow">if</span> (ExponentShift &lt; 54) {
03459 
03460         <span class="comment">//</span>
03461         <span class="comment">// The integer result value is less than 2**54 and so a right shift</span>
03462         <span class="comment">// must be performed.</span>
03463         <span class="comment">//</span>
03464 
03465         ExponentShift = 54 - ExponentShift;
03466         <span class="keywordflow">if</span> (ExponentShift &lt; 64) {
03467             StickyBits = Mantissa &lt;&lt; (64 - ExponentShift);
03468             ResultValue = Mantissa &gt;&gt; ExponentShift;
03469 
03470         } <span class="keywordflow">else</span> {
03471             StickyBits = Mantissa;
03472             ResultValue = 0;
03473         }
03474         Overflow = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03475 
03476     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ExponentShift &gt; 54) {
03477         ExponentShift -= 54;
03478 
03479         <span class="comment">//</span>
03480         <span class="comment">// The integer result value is 2**54 or greater and so a left shift</span>
03481         <span class="comment">// must be performed. If the unsigned integer result value is 2**64</span>
03482         <span class="comment">// or greater, then overflow has occurred and store the low order 64</span>
03483         <span class="comment">// bits of the true result.</span>
03484         <span class="comment">//</span>
03485 
03486         <span class="keywordflow">if</span> (ExponentShift &lt; (64 - 54)) {
03487             StickyBits = Mantissa &gt;&gt; (64 - ExponentShift);
03488             ResultValue = Mantissa &lt;&lt; ExponentShift;
03489             Overflow = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03490 
03491         } <span class="keywordflow">else</span> {
03492             StickyBits = 0;
03493             <span class="keywordflow">if</span> (ExponentShift &lt; 64) {
03494                 ResultValue = Mantissa &lt;&lt; ExponentShift;
03495 
03496             } <span class="keywordflow">else</span> {
03497                 ResultValue = 0;
03498             }
03499             Overflow = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03500         }
03501 
03502     } <span class="keywordflow">else</span> {
03503         StickyBits = 0;
03504         ResultValue = Mantissa;
03505         Overflow = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03506     }
03507     <a class="code" href="../../d6/d5/ioep_8h.html#a21">DBGPRINT</a>(<span class="stringliteral">".. ResultValue = %.16Lx, StickyBits = %.16Lx\n"</span>,
03508              ResultValue, StickyBits);
03509 
03510     <span class="comment">//</span>
03511     <span class="comment">// Round the result value using the mantissa, the round bit, and the</span>
03512     <span class="comment">// sticky bits.</span>
03513     <span class="comment">//</span>
03514 
03515     RoundBit = (ULONG)(StickyBits &gt;&gt; 63);
03516     StickyBits &lt;&lt;= 1;
03517     <a class="code" href="../../d6/d5/ioep_8h.html#a21">DBGPRINT</a>(<span class="stringliteral">".. ResultValue = %.16Lx, StickyBits = %.16Lx, RoundBit = %lx\n"</span>,
03518              ResultValue, StickyBits, RoundBit);
03519     <span class="keywordflow">switch</span> (ContextBlock-&gt;Round) {
03520 
03521         <span class="comment">//</span>
03522         <span class="comment">// Round to nearest representable number.</span>
03523         <span class="comment">//</span>
03524 
03525     <span class="keywordflow">case</span> ROUND_TO_NEAREST:
03526         <span class="keywordflow">if</span> (RoundBit != 0) {
03527             <span class="keywordflow">if</span> ((StickyBits != 0) || ((ResultValue &amp; 0x1) != 0)) {
03528                 ResultValue += 1;
03529                 <span class="keywordflow">if</span> (ResultValue == 0) {
03530                     Overflow = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03531                 }
03532             }
03533         }
03534         <span class="keywordflow">break</span>;
03535 
03536         <span class="comment">//</span>
03537         <span class="comment">// Round toward zero.</span>
03538         <span class="comment">//</span>
03539 
03540     <span class="keywordflow">case</span> ROUND_TO_ZERO:
03541         <span class="keywordflow">break</span>;
03542 
03543         <span class="comment">//</span>
03544         <span class="comment">// Round toward plus infinity.</span>
03545         <span class="comment">//</span>
03546 
03547     <span class="keywordflow">case</span> ROUND_TO_PLUS_INFINITY:
03548         <span class="keywordflow">if</span> ((ResultOperand-&gt;Sign == 0) &amp;&amp;
03549             ((StickyBits != 0) || (RoundBit != 0))) {
03550             ResultValue += 1;
03551             <span class="keywordflow">if</span> (ResultValue == 0) {
03552                 Overflow = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03553             }
03554         }
03555         <span class="keywordflow">break</span>;
03556 
03557         <span class="comment">//</span>
03558         <span class="comment">// Round toward minus infinity.</span>
03559         <span class="comment">//</span>
03560 
03561     <span class="keywordflow">case</span> ROUND_TO_MINUS_INFINITY:
03562         <span class="keywordflow">if</span> ((ResultOperand-&gt;Sign != 0) &amp;&amp;
03563             ((StickyBits != 0) || (RoundBit != 0))) {
03564             ResultValue += 1;
03565             <span class="keywordflow">if</span> (ResultValue == 0) {
03566                 Overflow = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03567             }
03568         }
03569         <span class="keywordflow">break</span>;
03570     }
03571 
03572     <span class="comment">//</span>
03573     <span class="comment">// If the result value is positive and the result is negative, then</span>
03574     <span class="comment">// overflow has occurred. Otherwise, negate the result value and</span>
03575     <span class="comment">// check if the result is negative. If the result is positive, then</span>
03576     <span class="comment">// overflow has occurred.</span>
03577     <span class="comment">//</span>
03578 
03579     <span class="keywordflow">if</span> (ResultOperand-&gt;Sign == 0) {
03580         <span class="keywordflow">if</span> ((LONGLONG)ResultValue &lt; 0) {
03581             Overflow = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03582         }
03583 
03584     } <span class="keywordflow">else</span> {
03585         ResultValue = -(LONGLONG)ResultValue;
03586         <span class="keywordflow">if</span> ((LONGLONG)ResultValue &gt; 0) {
03587             Overflow = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03588         }
03589     }
03590     <a class="code" href="../../d6/d5/ioep_8h.html#a21">DBGPRINT</a>(<span class="stringliteral">".. ResultValue = %.16Lx, StickyBits = %.16Lx\n"</span>,
03591              ResultValue, StickyBits);
03592 
03593     <span class="comment">//</span>
03594     <span class="comment">// Check to determine if an exception should be delivered or the result</span>
03595     <span class="comment">// should be written to the destination register.</span>
03596     <span class="comment">//</span>
03597 
03598     <span class="keywordflow">if</span> (Overflow != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
03599         <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a22">KiInvalidOperationQuadword</a>(ContextBlock, ResultValue);
03600 
03601     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((StickyBits | RoundBit) != 0) {
03602         Fpcr = (PFPCR)&amp;ContextBlock-&gt;TrapFrame-&gt;Fpcr;
03603         Fpcr-&gt;InexactResult = 1;
03604         Fpcr-&gt;SummaryBit = 1;
03605         <span class="keywordflow">if</span> (ContextBlock-&gt;IeeeMode != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
03606             SoftwareFpcr = ContextBlock-&gt;SoftwareFpcr;
03607             SoftwareFpcr-&gt;StatusInexact = 1;
03608             <span class="keywordflow">if</span> (SoftwareFpcr-&gt;EnableInexact != 0) {
03609                 ExceptionRecord = ContextBlock-&gt;ExceptionRecord;
03610                 ExceptionRecord-&gt;ExceptionCode = STATUS_FLOAT_INEXACT_RESULT;
03611                 IeeeValue = <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a27">KiInitializeIeeeValue</a>(ExceptionRecord);
03612                 IeeeValue-&gt;Value.U64Value.LowPart = <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a2">LOW_PART</a>(ResultValue);
03613                 IeeeValue-&gt;Value.U64Value.HighPart = <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a3">HIGH_PART</a>(ResultValue);
03614                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03615             }
03616 
03617             Fpcr-&gt;DisableInexact = 1;
03618         }
03619     }
03620 
03621     <span class="comment">//</span>
03622     <span class="comment">// Set the destination register value and return a value of TRUE.</span>
03623     <span class="comment">//</span>
03624 
03625     <a class="code" href="../../d8/d5/ppc_2getsetrg_8c.html#a1">KiSetRegisterValue</a>(ContextBlock-&gt;Fc + 32,
03626                        ResultValue,
03627                        ContextBlock-&gt;ExceptionFrame,
03628                        ContextBlock-&gt;TrapFrame);
03629 
03630     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03631 }
03632 
03633 BOOLEAN
<a name="l03634"></a><a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a34">03634</a> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a27">KiNormalizeSingle</a> (
03635     IN PFP_CONTEXT_BLOCK ContextBlock,
03636     IN PFP_SINGLE_OPERAND ResultOperand,
03637     IN ULONG StickyBits
03638     )
03639 
03640 <span class="comment">/*++</span>
03641 <span class="comment"></span>
03642 <span class="comment">Routine Description:</span>
03643 <span class="comment"></span>
03644 <span class="comment">    This function is called to normalize a single floating result.</span>
03645 <span class="comment"></span>
03646 <span class="comment">    N.B. The result value is specified with a guard bit on the right,</span>
03647 <span class="comment">        the hidden bit (if appropriate), and a possible overflow bit.</span>
03648 <span class="comment">        The result format is:</span>
03649 <span class="comment"></span>
03650 <span class="comment">        &lt;31:27&gt; - zero</span>
03651 <span class="comment">        &lt;26&gt; - overflow bit</span>
03652 <span class="comment">        &lt;25&gt; - hidden bit</span>
03653 <span class="comment">        &lt;24:2&gt; - mantissa</span>
03654 <span class="comment">        &lt;1&gt; - guard bit</span>
03655 <span class="comment">        &lt;0&gt; - round bit</span>
03656 <span class="comment"></span>
03657 <span class="comment">        The sticky bits specify bits that were lost during the computation.</span>
03658 <span class="comment"></span>
03659 <span class="comment">Arguments:</span>
03660 <span class="comment"></span>
03661 <span class="comment">    ContextBlock - Supplies a pointer to the emulation context block.</span>
03662 <span class="comment"></span>
03663 <span class="comment">    ResultOperand - Supplies a pointer to the result operand value.</span>
03664 <span class="comment"></span>
03665 <span class="comment">    StickyBits - Supplies the value of the sticky bits.</span>
03666 <span class="comment"></span>
03667 <span class="comment">Return Value:</span>
03668 <span class="comment"></span>
03669 <span class="comment">    If there is not an exception, or the exception is handled, then a proper</span>
03670 <span class="comment">    result is stored in the destination result, the continuation address is</span>
03671 <span class="comment">    set, and a value of TRUE is returned. Otherwise, a proper value is stored and</span>
03672 <span class="comment">    a value of FALSE is returned.</span>
03673 <span class="comment"></span>
03674 <span class="comment">--*/</span>
03675 
03676 {
03677 
03678     ULONG DenormalizeShift;
03679     PEXCEPTION_RECORD ExceptionRecord;
03680     ULONG ExceptionResult;
03681     PFPCR Fpcr;
03682     PFP_IEEE_VALUE IeeeValue;
03683     BOOLEAN Inexact;
03684     ULONG Mantissa;
03685     BOOLEAN Overflow;
03686     ULONG ResultValue;
03687     ULONG RoundBit;
03688     PSW_FPCR SoftwareFpcr;
03689     BOOLEAN Underflow;
03690     ULONG ResultStickyBits;
03691     ULONG ResultMantissa;
03692     ULONG ResultRoundBit;
03693     LONG ResultExponent;
03694     BOOLEAN ReturnValue = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03695 
03696     <span class="comment">//</span>
03697     <span class="comment">// If the result is infinite, then store a properly signed infinity</span>
03698     <span class="comment">// in the destination register and return a value of TRUE. Otherwise,</span>
03699     <span class="comment">// round and normalize the result and check for overflow and underflow.</span>
03700     <span class="comment">//</span>
03701 
03702     <a class="code" href="../../d6/d5/ioep_8h.html#a21">DBGPRINT</a>(<span class="stringliteral">"KiNormalizeSingle: Inf=%d NaN=%d Sign=%d Exponent=%d Mantissa=%.8x\n"</span>,
03703              ResultOperand-&gt;Infinity, ResultOperand-&gt;Nan, ResultOperand-&gt;Sign,
03704              ResultOperand-&gt;Exponent, ResultOperand-&gt;Mantissa);
03705     <a class="code" href="../../d6/d5/ioep_8h.html#a21">DBGPRINT</a>(<span class="stringliteral">"KiNormalizeSingle: StickyBits=%.8lx\n"</span>, StickyBits);
03706 
03707     <span class="keywordflow">if</span> (ResultOperand-&gt;Infinity != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
03708         ResultValue = SINGLE_INFINITY_VALUE | (ResultOperand-&gt;Sign &lt;&lt; 31);
03709         <a class="code" href="../../d8/d5/ppc_2getsetrg_8c.html#a1">KiSetRegisterValue</a>(ContextBlock-&gt;Fc + 32,
03710                            <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a22">KiConvertSingleOperandToRegister</a>(ResultValue),
03711                            ContextBlock-&gt;ExceptionFrame,
03712                            ContextBlock-&gt;TrapFrame);
03713 
03714         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03715     }
03716 
03717     Mantissa = ResultOperand-&gt;Mantissa;
03718     Fpcr = (PFPCR)&amp;ContextBlock-&gt;TrapFrame-&gt;Fpcr;
03719     SoftwareFpcr = ContextBlock-&gt;SoftwareFpcr;
03720 
03721     <span class="comment">//</span>
03722     <span class="comment">// If the overflow bit is set, then right shift the mantissa one bit,</span>
03723     <span class="comment">// accumulate the lost bit with the sticky bits, and adjust the exponent</span>
03724     <span class="comment">// value.</span>
03725     <span class="comment">//</span>
03726 
03727     <span class="keywordflow">if</span> ((Mantissa &amp; (1 &lt;&lt; 26)) != 0) {
03728         StickyBits |= (Mantissa &amp; 0x1);
03729         Mantissa &gt;&gt;= 1;
03730         ResultOperand-&gt;Exponent += 1;
03731     }
03732 
03733     <span class="comment">//</span>
03734     <span class="comment">// If the mantissa is nonzero, then normalize the mantissa by left</span>
03735     <span class="comment">// shifting one bit at a time until there is a one bit in bit 25.</span>
03736     <span class="comment">//</span>
03737 
03738     <span class="keywordflow">if</span> (Mantissa != 0) {
03739         <span class="keywordflow">while</span> ((Mantissa &amp; (1 &lt;&lt; 25)) == 0) {
03740             Mantissa &lt;&lt;= 1;
03741             ResultOperand-&gt;Exponent -= 1;
03742         }
03743     }
03744 
03745     <span class="comment">//</span>
03746     <span class="comment">// Right shift the mantissa two bits, set the round bit, and accumulate</span>
03747     <span class="comment">// the other lost bit with the sticky bits.</span>
03748     <span class="comment">//</span>
03749 
03750     StickyBits |= (Mantissa &amp; 0x1);
03751     RoundBit = (Mantissa &amp; 0x2);
03752     Mantissa &gt;&gt;= 2;
03753 
03754     <span class="comment">//</span>
03755     <span class="comment">// Convert to denormal format before rounding to allow underflow to</span>
03756     <span class="comment">// be detected on rounded result.  Save context to calculate IEEE</span>
03757     <span class="comment">// exception record, if needed.</span>
03758     <span class="comment">//</span>
03759 
03760     <span class="keywordflow">if</span> (ResultOperand-&gt;Exponent &lt;= SINGLE_MINIMUM_EXPONENT &amp;&amp; Mantissa != 0) {
03761 
03762         <span class="comment">//</span>
03763         <span class="comment">// Save everything needed for calculating IEEE exception record value</span>
03764         <span class="comment">//</span>
03765 
03766         ResultMantissa = Mantissa;
03767         ResultExponent = ResultOperand-&gt;Exponent;
03768         ResultStickyBits = StickyBits;
03769         ResultRoundBit = RoundBit;
03770 
03771         <span class="comment">//</span>
03772         <span class="comment">// Right shift the mantissa to set the minimum exponent plus an extra</span>
03773         <span class="comment">// bit for the denormal format</span>
03774         <span class="comment">//</span>
03775 
03776         DenormalizeShift = 1 - ResultOperand-&gt;Exponent;
03777 
03778         <span class="comment">//</span>
03779         <span class="comment">// The maximum denormal shift is 23 bits for the mantissa plus 1 bit for the round</span>
03780         <span class="comment">// A denormal shift of 25 guarantees 0 mantissa and 0 round bit and preserves all sticky bits</span>
03781         <span class="comment">//</span>
03782 
03783         <span class="keywordflow">if</span> (DenormalizeShift &gt; 25) {
03784             DenormalizeShift = 25;
03785         }
03786 
03787         <span class="comment">//</span>
03788         <span class="comment">// The denormalized result will be rounded after it is</span>
03789         <span class="comment">// shifted.  Preserve existing Round and Sticky Bits.</span>
03790         <span class="comment">//</span>
03791 
03792         StickyBits |= RoundBit; 
03793         StickyBits |= (Mantissa &lt;&lt; 1) &lt;&lt; (32 - DenormalizeShift); 
03794         RoundBit = (Mantissa &gt;&gt; (DenormalizeShift - 1)) &amp; 1;
03795         Mantissa = Mantissa &gt;&gt; DenormalizeShift;
03796         ResultOperand-&gt;Exponent = SINGLE_MINIMUM_EXPONENT;
03797     }
03798 
03799     <span class="comment">//</span>
03800     <span class="comment">// Round the result value using the mantissa, the round bit, and the sticky bits.</span>
03801     <span class="comment">//</span>
03802 
03803     <span class="keywordflow">switch</span> (ContextBlock-&gt;Round) {
03804 
03805         <span class="comment">//</span>
03806         <span class="comment">// Round to nearest representable number.</span>
03807         <span class="comment">//</span>
03808 
03809     <span class="keywordflow">case</span> ROUND_TO_NEAREST:
03810         <span class="keywordflow">if</span> (RoundBit != 0) {
03811             <span class="keywordflow">if</span> ((StickyBits != 0) || ((Mantissa &amp; 0x1) != 0)) {
03812                 Mantissa += 1;
03813             }
03814         }
03815         <span class="keywordflow">break</span>;
03816 
03817         <span class="comment">//</span>
03818         <span class="comment">// Round toward zero.</span>
03819         <span class="comment">//</span>
03820 
03821     <span class="keywordflow">case</span> ROUND_TO_ZERO:
03822         <span class="keywordflow">break</span>;
03823 
03824         <span class="comment">//</span>
03825         <span class="comment">// Round toward plus infinity.</span>
03826         <span class="comment">//</span>
03827 
03828     <span class="keywordflow">case</span> ROUND_TO_PLUS_INFINITY:
03829         <span class="keywordflow">if</span> ((ResultOperand-&gt;Sign == 0) &amp;&amp;
03830             ((StickyBits != 0) || (RoundBit != 0))) {
03831             Mantissa += 1;
03832         }
03833         <span class="keywordflow">break</span>;
03834 
03835         <span class="comment">//</span>
03836         <span class="comment">// Round toward minus infinity.</span>
03837         <span class="comment">//</span>
03838 
03839     <span class="keywordflow">case</span> ROUND_TO_MINUS_INFINITY:
03840         <span class="keywordflow">if</span> ((ResultOperand-&gt;Sign != 0) &amp;&amp;
03841             ((StickyBits != 0) || (RoundBit != 0))) {
03842             Mantissa += 1;
03843         }
03844         <span class="keywordflow">break</span>;
03845     }
03846 
03847     <span class="comment">//</span>
03848     <span class="comment">// If rounding resulted in a carry into bit 24, then right shift the</span>
03849     <span class="comment">// mantissa one bit and adjust the exponent.</span>
03850     <span class="comment">//</span>
03851 
03852     <span class="keywordflow">if</span> ((Mantissa &amp; (1 &lt;&lt; 24)) != 0) {
03853         Mantissa &gt;&gt;= 1;
03854         ResultOperand-&gt;Exponent += 1;
03855     }
03856 
03857     <span class="comment">//</span>
03858     <span class="comment">// If rounding resulted in a carry into bit 23 in denormal format, then</span>
03859     <span class="comment">// adjust the exponent.</span>
03860     <span class="comment">//</span>
03861 
03862     <span class="keywordflow">if</span> ((ResultOperand-&gt;Exponent == SINGLE_MINIMUM_EXPONENT) &amp;&amp; 
03863         (Mantissa &amp; (1 &lt;&lt; 23)) != 0) {
03864         ResultOperand-&gt;Exponent += 1;
03865     }
03866 
03867     <span class="comment">//</span>
03868     <span class="comment">// If the exponent value is greater than or equal to the maximum</span>
03869     <span class="comment">// exponent value, then overflow has occurred. This results in both</span>
03870     <span class="comment">// the inexact and overflow sticky bits being set in the FPCR.</span>
03871     <span class="comment">//</span>
03872     <span class="comment">// If the exponent value is less than or equal to the minimum exponent</span>
03873     <span class="comment">// value, the mantissa is nonzero, and the denormalized result is inexact,</span>
03874     <span class="comment">// then underflow has occurred.  This results in both the inexact and</span>
03875     <span class="comment">// underflow sticky bits being set in the FPCR. </span>
03876     <span class="comment">//</span>
03877     <span class="comment">// Or if underflow exceptions are enabled, underflow occurs for all denormal</span>
03878     <span class="comment">// numbers.  This results in the underflow sticky bit always being set in the</span>
03879     <span class="comment">// FPCR and the inexact sticky bit is set when the denormalized result is</span>
03880     <span class="comment">// also inexact.</span>
03881     <span class="comment">//</span>
03882     <span class="comment">// Otherwise, a normal result can be delivered, but it may be inexact.</span>
03883     <span class="comment">// If the result is inexact, then the inexact sticky bit is set in the</span>
03884     <span class="comment">// FPCR.</span>
03885     <span class="comment">//</span>
03886 
03887     <span class="keywordflow">if</span> (ResultOperand-&gt;Exponent &gt;= SINGLE_MAXIMUM_EXPONENT) {
03888         Inexact = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03889         Overflow = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03890         Underflow = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03891 
03892         <span class="comment">//</span>
03893         <span class="comment">// The overflow value is dependent on the rounding mode.</span>
03894         <span class="comment">//</span>
03895 
03896         <span class="keywordflow">switch</span> (ContextBlock-&gt;Round) {
03897 
03898             <span class="comment">//</span>
03899             <span class="comment">// Round to nearest representable number.</span>
03900             <span class="comment">//</span>
03901             <span class="comment">// The result value is infinity with the sign of the result.</span>
03902             <span class="comment">//</span>
03903 
03904         <span class="keywordflow">case</span> ROUND_TO_NEAREST:
03905             ResultValue = SINGLE_INFINITY_VALUE | (ResultOperand-&gt;Sign &lt;&lt; 31);
03906             <span class="keywordflow">break</span>;
03907 
03908             <span class="comment">//</span>
03909             <span class="comment">// Round toward zero.</span>
03910             <span class="comment">//</span>
03911             <span class="comment">// The result is the maximum number with the sign of the result.</span>
03912             <span class="comment">//</span>
03913 
03914         <span class="keywordflow">case</span> ROUND_TO_ZERO:
03915             ResultValue = SINGLE_MAXIMUM_VALUE | (ResultOperand-&gt;Sign &lt;&lt; 31);
03916             <span class="keywordflow">break</span>;
03917 
03918             <span class="comment">//</span>
03919             <span class="comment">// Round toward plus infinity.</span>
03920             <span class="comment">//</span>
03921             <span class="comment">// If the sign of the result is positive, then the result is</span>
03922             <span class="comment">// plus infinity. Otherwise, the result is the maximum negative</span>
03923             <span class="comment">// number.</span>
03924             <span class="comment">//</span>
03925 
03926         <span class="keywordflow">case</span> ROUND_TO_PLUS_INFINITY:
03927             <span class="keywordflow">if</span> (ResultOperand-&gt;Sign == 0) {
03928                 ResultValue = SINGLE_INFINITY_VALUE;
03929 
03930             } <span class="keywordflow">else</span> {
03931                 ResultValue = (ULONG)(SINGLE_MAXIMUM_VALUE | (1 &lt;&lt; 31));
03932             }
03933             <span class="keywordflow">break</span>;
03934 
03935             <span class="comment">//</span>
03936             <span class="comment">// Round toward minus infinity.</span>
03937             <span class="comment">//</span>
03938             <span class="comment">// If the sign of the result is negative, then the result is</span>
03939             <span class="comment">// negative infinity. Otherwise, the result is the maximum</span>
03940             <span class="comment">// positive number.</span>
03941             <span class="comment">//</span>
03942 
03943         <span class="keywordflow">case</span> ROUND_TO_MINUS_INFINITY:
03944             <span class="keywordflow">if</span> (ResultOperand-&gt;Sign != 0) {
03945                 ResultValue = (ULONG)(SINGLE_INFINITY_VALUE | (1 &lt;&lt; 31));
03946 
03947             } <span class="keywordflow">else</span> {
03948                 ResultValue = SINGLE_MAXIMUM_VALUE;
03949             }
03950             <span class="keywordflow">break</span>;
03951         }
03952 
03953         <span class="comment">//</span>
03954         <span class="comment">// Compute the overflow exception result value by subtracting 192</span>
03955         <span class="comment">// from the exponent.</span>
03956         <span class="comment">//</span>
03957 
03958         ExceptionResult = Mantissa &amp; ((1 &lt;&lt; 23) - 1);
03959         ExceptionResult |= ((ResultOperand-&gt;Exponent - 192) &lt;&lt; 23);
03960         ExceptionResult |= (ResultOperand-&gt;Sign &lt;&lt; 31);
03961 
03962     } <span class="keywordflow">else</span> {
03963 
03964         <span class="comment">//</span>
03965         <span class="comment">// After rounding if the exponent value is equal to</span>
03966         <span class="comment">// the minimum exponent value and the result was nonzero, then</span>
03967         <span class="comment">// underflow has occurred.</span>
03968         <span class="comment">//</span>
03969 
03970         <span class="keywordflow">if</span> ((ResultOperand-&gt;Exponent == SINGLE_MINIMUM_EXPONENT) &amp;&amp;
03971             (Mantissa != 0 || RoundBit != 00 || StickyBits != 0)) {
03972 
03973             <span class="comment">//</span>
03974             <span class="comment">// If the FPCR underflow to zero (denormal enable) control bit</span>
03975             <span class="comment">// is set, then flush the denormalized result to zero and do</span>
03976             <span class="comment">// not set an underflow status or generate an exception.</span>
03977             <span class="comment">//</span>
03978 
03979             <span class="keywordflow">if</span> ((ContextBlock-&gt;IeeeMode == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) ||
03980                 (SoftwareFpcr-&gt;DenormalResultEnable == 0)) {
03981                 <a class="code" href="../../d6/d5/ioep_8h.html#a21">DBGPRINT</a>(<span class="stringliteral">"SoftwareFpcr-&gt;DenormalResultEnable == 0\n"</span>);
03982                 ResultValue = 0;
03983                 Inexact = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03984                 Overflow = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03985                 Underflow = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03986 
03987             } <span class="keywordflow">else</span> {
03988 
03989                 ResultValue = Mantissa;
03990                 ResultValue |= ResultOperand-&gt;Sign &lt;&lt; 31;
03991 
03992                 <span class="comment">//</span>
03993                 <span class="comment">//</span>
03994                 <span class="comment">// Compute the underflow exception result value by first recalculating the</span>
03995                 <span class="comment">// full precision answer.</span>
03996                 <span class="comment">//</span>
03997 
03998                 <span class="comment">//</span>
03999                 <span class="comment">// Round the result value using the mantissa, the round bit, and the sticky bits.</span>
04000                 <span class="comment">//</span>
04001 
04002                 <span class="keywordflow">switch</span> (ContextBlock-&gt;Round) {
04003 
04004                     <span class="comment">//</span>
04005                     <span class="comment">// Round to nearest representable number.</span>
04006                     <span class="comment">//</span>
04007 
04008                 <span class="keywordflow">case</span> ROUND_TO_NEAREST:
04009                     <span class="keywordflow">if</span> (ResultRoundBit != 0) {
04010                         <span class="keywordflow">if</span> ((ResultStickyBits != 0) || ((ResultMantissa &amp; 0x1) != 0)) {
04011                             ResultMantissa += 1;
04012                         }
04013                     }
04014                     <span class="keywordflow">break</span>;
04015 
04016                     <span class="comment">//</span>
04017                     <span class="comment">// Round toward zero.</span>
04018                     <span class="comment">//</span>
04019 
04020                 <span class="keywordflow">case</span> ROUND_TO_ZERO:
04021                     <span class="keywordflow">break</span>;
04022 
04023                     <span class="comment">//</span>
04024                     <span class="comment">// Round toward plus infinity.</span>
04025                     <span class="comment">//</span>
04026 
04027                 <span class="keywordflow">case</span> ROUND_TO_PLUS_INFINITY:
04028                     <span class="keywordflow">if</span> ((ResultOperand-&gt;Sign == 0) &amp;&amp;
04029                         ((ResultStickyBits != 0) || (ResultRoundBit != 0))) {
04030                         ResultMantissa += 1;
04031                     }
04032                     <span class="keywordflow">break</span>;
04033 
04034                     <span class="comment">//</span>
04035                     <span class="comment">// Round toward minus infinity.</span>
04036                     <span class="comment">//</span>
04037 
04038                 <span class="keywordflow">case</span> ROUND_TO_MINUS_INFINITY:
04039                     <span class="keywordflow">if</span> ((ResultOperand-&gt;Sign != 0) &amp;&amp;
04040                         ((ResultStickyBits != 0) || (ResultRoundBit != 0))) {
04041                         ResultMantissa += 1;
04042                     }
04043                     <span class="keywordflow">break</span>;
04044                 }
04045 
04046                 <span class="comment">//</span>
04047                 <span class="comment">// If rounding resulted in a carry into bit 24, then right shift the</span>
04048                 <span class="comment">// mantissa one bit and adjust the exponent.</span>
04049                 <span class="comment">//</span>
04050 
04051                 <span class="keywordflow">if</span> ((ResultMantissa &amp; (1 &lt;&lt; 24)) != 0) {
04052                     ResultMantissa &gt;&gt;= 1;
04053                     ResultExponent += 1;
04054                 }
04055 
04056                 <span class="comment">//</span>
04057                 <span class="comment">// Compute the underflow exception result value by adding</span>
04058                 <span class="comment">// 192 to the exponent.</span>
04059                 <span class="comment">//</span>
04060 
04061                 ExceptionResult = ResultMantissa &amp; ((1 &lt;&lt; 23) - 1);
04062                 ExceptionResult |= ((ResultExponent + 192) &lt;&lt; 23);
04063                 ExceptionResult |= (ResultOperand-&gt;Sign &lt;&lt; 31);
04064 
04065                 <span class="comment">//</span>
04066                 <span class="comment">// If the denormalized result is inexact, then set underflow.</span>
04067                 <span class="comment">// Otherwise, for exact denormals do not set the underflow</span>
04068                 <span class="comment">// sticky bit unless underflow exception is enabled.</span>
04069                 <span class="comment">//</span>
04070 
04071                 Overflow = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04072                 Underflow = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04073                 <span class="keywordflow">if</span> ((StickyBits != 0) || (RoundBit != 0)) {
04074                     Inexact = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04075 
04076                 } <span class="keywordflow">else</span> {
04077                     Inexact = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04078                 }
04079             }
04080 
04081         } <span class="keywordflow">else</span> {
04082 
04083             <span class="comment">//</span>
04084             <span class="comment">// If the result is zero, then set the proper sign for zero.</span>
04085             <span class="comment">//</span>
04086 
04087             <span class="keywordflow">if</span> (Mantissa == 0) {
04088                 ResultOperand-&gt;Exponent = 0;
04089             }
04090 
04091             ResultValue = Mantissa &amp; ((1 &lt;&lt; 23) - 1);
04092             ResultValue |= (ResultOperand-&gt;Exponent &lt;&lt; 23);
04093             ResultValue |= (ResultOperand-&gt;Sign &lt;&lt; 31);
04094             <span class="keywordflow">if</span> ((StickyBits != 0) || (RoundBit != 0)) {
04095                 Inexact = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04096 
04097             } <span class="keywordflow">else</span> {
04098                 Inexact = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04099             }
04100             Overflow = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04101             Underflow = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04102         }
04103     }
04104 
04105     <span class="comment">//</span>
04106     <span class="comment">// Check to determine if an exception should be delivered.</span>
04107     <span class="comment">//</span>
04108 
04109     ExceptionRecord = ContextBlock-&gt;ExceptionRecord;
04110 
04111     <span class="keywordflow">if</span> (Overflow != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
04112         Fpcr-&gt;Overflow = 1;
04113         Fpcr-&gt;InexactResult = 1;
04114         Fpcr-&gt;SummaryBit = 1;
04115         <span class="keywordflow">if</span> (ContextBlock-&gt;IeeeMode == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
04116             ExceptionRecord-&gt;ExceptionCode = STATUS_FLOAT_OVERFLOW;
04117             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04118         }
04119         IeeeValue = <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a27">KiInitializeIeeeValue</a>(ExceptionRecord);
04120         SoftwareFpcr-&gt;StatusOverflow = 1;
04121         SoftwareFpcr-&gt;StatusInexact = 1;
04122         <span class="keywordflow">if</span> (SoftwareFpcr-&gt;EnableOverflow != 0) {
04123             ExceptionRecord-&gt;ExceptionCode = STATUS_FLOAT_OVERFLOW;
04124             IeeeValue-&gt;Value.Fp32Value.W[0] = ExceptionResult;
04125             ReturnValue = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04126         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (SoftwareFpcr-&gt;EnableInexact != 0) {
04127             ExceptionRecord-&gt;ExceptionCode = STATUS_FLOAT_INEXACT_RESULT;
04128             IeeeValue-&gt;Value.Fp32Value.W[0] = ExceptionResult;
04129             ReturnValue = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04130         } <span class="keywordflow">else</span> {
04131             Fpcr-&gt;DisableOverflow = 1;
04132             Fpcr-&gt;DisableInexact = 1;
04133         }
04134 
04135     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Underflow != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
04136 
04137         <span class="comment">//</span>
04138         <span class="comment">// Non-IEEE instruction always forces underflow to zero</span>
04139         <span class="comment">//</span>
04140 
04141         <span class="keywordflow">if</span> (ContextBlock-&gt;IeeeMode == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
04142             Fpcr-&gt;Underflow = 1;
04143             Fpcr-&gt;SummaryBit = 1;
04144             Fpcr-&gt;InexactResult = 1;
04145             <span class="keywordflow">if</span> (ContextBlock-&gt;UnderflowEnable != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
04146                 ExceptionRecord-&gt;ExceptionCode = STATUS_FLOAT_UNDERFLOW;
04147                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04148             }
04149 
04150         <span class="comment">//</span>
04151         <span class="comment">// IEEE instructions don't report underflow unless the results are</span>
04152         <span class="comment">// inexact or underflow exceptions are enabled</span>
04153         <span class="comment">//</span>
04154 
04155         } <span class="keywordflow">else</span> {
04156             IeeeValue = <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a27">KiInitializeIeeeValue</a>(ExceptionRecord);
04157             <span class="keywordflow">if</span> (Inexact != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
04158                 Fpcr-&gt;Underflow = 1;
04159                 Fpcr-&gt;InexactResult = 1;
04160                 Fpcr-&gt;SummaryBit = 1;
04161                 SoftwareFpcr-&gt;StatusUnderflow = 1;
04162                 SoftwareFpcr-&gt;StatusInexact = 1;
04163             }
04164             <span class="keywordflow">if</span> (SoftwareFpcr-&gt;EnableUnderflow != 0) {
04165                 Fpcr-&gt;Underflow = 1;
04166                 Fpcr-&gt;SummaryBit = 1;
04167                 SoftwareFpcr-&gt;StatusUnderflow = 1;
04168                 ExceptionRecord-&gt;ExceptionCode = STATUS_FLOAT_UNDERFLOW;
04169                 IeeeValue-&gt;Value.Fp32Value.W[0] = ExceptionResult;
04170                 ReturnValue = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04171             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Inexact != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> &amp;&amp; SoftwareFpcr-&gt;EnableInexact != 0) {
04172                 ExceptionRecord-&gt;ExceptionCode = STATUS_FLOAT_INEXACT_RESULT;
04173                 IeeeValue-&gt;Value.Fp32Value.W[0] = ExceptionResult;
04174                 ReturnValue = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04175             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Inexact != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
04176                 Fpcr-&gt;DisableUnderflow = 1;
04177                 Fpcr-&gt;DisableInexact = 1;
04178             }
04179         }
04180 
04181     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Inexact != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
04182         Fpcr-&gt;InexactResult = 1;
04183         Fpcr-&gt;SummaryBit = 1;
04184         <span class="keywordflow">if</span> (ContextBlock-&gt;IeeeMode != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
04185             IeeeValue = <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a27">KiInitializeIeeeValue</a>(ExceptionRecord);
04186             SoftwareFpcr-&gt;StatusInexact = 1;
04187             <span class="keywordflow">if</span> (SoftwareFpcr-&gt;EnableInexact != 0) {
04188                 ExceptionRecord-&gt;ExceptionCode = STATUS_FLOAT_INEXACT_RESULT;
04189                 IeeeValue-&gt;Value.Fp32Value.W[0] = ResultValue;
04190                 ReturnValue = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04191             } <span class="keywordflow">else</span> {
04192                 Fpcr-&gt;DisableInexact = 1;
04193             }
04194         }
04195     }
04196 
04197     <span class="comment">//</span>
04198     <span class="comment">// Always write the destination register.  If an exception is delivered, and</span>
04199     <span class="comment">// then dismissed, the correct value must be in the register.</span>
04200     <span class="comment">//</span>
04201 
04202     <a class="code" href="../../d8/d5/ppc_2getsetrg_8c.html#a1">KiSetRegisterValue</a>(ContextBlock-&gt;Fc + 32,
04203                        <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a22">KiConvertSingleOperandToRegister</a>(ResultValue),
04204                        ContextBlock-&gt;ExceptionFrame,
04205                        ContextBlock-&gt;TrapFrame);
04206 
04207     <span class="comment">//</span>
04208     <span class="comment">// Return a value of TRUE.unless an exception should be generated</span>
04209     <span class="comment">//</span>
04210 
04211     <span class="keywordflow">return</span> ReturnValue;
04212 }
04213 
04214 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l04215"></a><a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a35">04215</a> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a30">KiUnpackDouble</a> (
04216     IN ULONG Source,
04217     IN PFP_CONTEXT_BLOCK ContextBlock,
04218     OUT PFP_DOUBLE_OPERAND DoubleOperand
04219     )
04220 
04221 <span class="comment">/*++</span>
04222 <span class="comment"></span>
04223 <span class="comment">Routine Description:</span>
04224 <span class="comment"></span>
04225 <span class="comment">    This function is called to unpack a double floating value from the</span>
04226 <span class="comment">    specified source register.</span>
04227 <span class="comment"></span>
04228 <span class="comment">    N.B. The unpacked mantissa value is returned with a guard bit and a</span>
04229 <span class="comment">        round bit on the right and the hidden bit inserted if appropriate.</span>
04230 <span class="comment">        The format of the returned value is:</span>
04231 <span class="comment"></span>
04232 <span class="comment">        &lt;63:55&gt; - zero</span>
04233 <span class="comment">        &lt;54&gt; - hidden bit</span>
04234 <span class="comment">        &lt;53:2&gt; - mantissa</span>
04235 <span class="comment">        &lt;1&gt; - guard bit</span>
04236 <span class="comment">        &lt;0&gt; - round bit</span>
04237 <span class="comment"></span>
04238 <span class="comment">Arguments:</span>
04239 <span class="comment"></span>
04240 <span class="comment">    Source - Supplies the number of the register that contains the operand.</span>
04241 <span class="comment"></span>
04242 <span class="comment">    ContextBlock - Supplies a pointer to the emulation context block.</span>
04243 <span class="comment"></span>
04244 <span class="comment">    DoubleOperand - Supplies a pointer to a structure that is to receive the</span>
04245 <span class="comment">        operand value.</span>
04246 <span class="comment"></span>
04247 <span class="comment">Return Value:</span>
04248 <span class="comment"></span>
04249 <span class="comment">    None.</span>
04250 <span class="comment"></span>
04251 <span class="comment">--*/</span>
04252 
04253 {
04254 
04255     ULONGLONG Value;
04256     ULONG Value1;
04257     ULONG Value2;
04258 
04259     <span class="comment">//</span>
04260     <span class="comment">// Get the source register value and unpack the sign, exponent, and</span>
04261     <span class="comment">// mantissa value.</span>
04262     <span class="comment">//</span>
04263 
04264     Value = <a class="code" href="../../d8/d5/ppc_2getsetrg_8c.html#a0">KiGetRegisterValue</a>(Source + 32,
04265                                ContextBlock-&gt;ExceptionFrame,
04266                                ContextBlock-&gt;TrapFrame);
04267     Value1 = (ULONG)Value;
04268     Value2 = (ULONG)(Value &gt;&gt; 32);
04269 
04270     DoubleOperand-&gt;Sign = Value2 &gt;&gt; 31;
04271     DoubleOperand-&gt;Exponent = (Value2 &gt;&gt; (52 - 32)) &amp; 0x7ff;
04272     DoubleOperand-&gt;MantissaHigh = Value2 &amp; 0xfffff;
04273     DoubleOperand-&gt;MantissaLow = Value1;
04274 
04275     <span class="comment">//</span>
04276     <span class="comment">// If the exponent is the largest possible value, then the number is</span>
04277     <span class="comment">// either a NaN or an infinity. Otherwise if the exponent is the smallest</span>
04278     <span class="comment">// possible value and the mantissa is nonzero, then the number is</span>
04279     <span class="comment">// denormalized. Otherwise the number is finite and normal.</span>
04280     <span class="comment">//</span>
04281 
04282     <span class="keywordflow">if</span> (DoubleOperand-&gt;Exponent == DOUBLE_MAXIMUM_EXPONENT) {
04283         DoubleOperand-&gt;Normal = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04284         <span class="keywordflow">if</span> ((DoubleOperand-&gt;MantissaLow | DoubleOperand-&gt;MantissaHigh) != 0) {
04285             DoubleOperand-&gt;Infinity = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04286             DoubleOperand-&gt;Nan = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04287 
04288         } <span class="keywordflow">else</span> {
04289             DoubleOperand-&gt;Infinity = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04290             DoubleOperand-&gt;Nan = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04291         }
04292 
04293     } <span class="keywordflow">else</span> {
04294         DoubleOperand-&gt;Infinity = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04295         DoubleOperand-&gt;Nan = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04296         DoubleOperand-&gt;Normal = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04297         <span class="keywordflow">if</span> (DoubleOperand-&gt;Exponent == DOUBLE_MINIMUM_EXPONENT) {
04298             <span class="keywordflow">if</span> ((DoubleOperand-&gt;MantissaHigh | DoubleOperand-&gt;MantissaLow) != 0) {
04299                 <span class="keywordflow">if</span> (ContextBlock-&gt;SoftwareFpcr-&gt;DenormalOperandsEnable == 0) {
04300                     <a class="code" href="../../d6/d5/ioep_8h.html#a21">DBGPRINT</a>(<span class="stringliteral">"SoftwareFpcr-&gt;DenormalOperandsEnable == 0\n"</span>);
04301                     DoubleOperand-&gt;MantissaHigh = 0;
04302                     DoubleOperand-&gt;MantissaLow = 0;
04303                     DoubleOperand-&gt;Exponent = 0;
04304                 } <span class="keywordflow">else</span> {
04305                     DoubleOperand-&gt;Normal = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04306                     DoubleOperand-&gt;Exponent += 1;
04307                     <span class="keywordflow">while</span> ((DoubleOperand-&gt;MantissaHigh &amp; (1 &lt;&lt; 20)) == 0) {
04308                         DoubleOperand-&gt;MantissaHigh =
04309                                 (DoubleOperand-&gt;MantissaHigh &lt;&lt; 1) |
04310                                                 (DoubleOperand-&gt;MantissaLow &gt;&gt; 31);
04311                         DoubleOperand-&gt;MantissaLow &lt;&lt;= 1;
04312                         DoubleOperand-&gt;Exponent -= 1;
04313                     }
04314                 }
04315             }
04316 
04317         } <span class="keywordflow">else</span> {
04318             DoubleOperand-&gt;MantissaHigh |= (1 &lt;&lt; 20);
04319         }
04320     }
04321 
04322     <span class="comment">//</span>
04323     <span class="comment">// Left shift the mantissa 2-bits to provide for a guard bit and a round</span>
04324     <span class="comment">// bit.</span>
04325     <span class="comment">//</span>
04326 
04327     DoubleOperand-&gt;MantissaHigh =
04328         (DoubleOperand-&gt;MantissaHigh &lt;&lt; 2) | (DoubleOperand-&gt;MantissaLow &gt;&gt; 30);
04329     DoubleOperand-&gt;MantissaLow &lt;&lt;= 2;
04330     <a class="code" href="../../d6/d5/ioep_8h.html#a21">DBGPRINT</a>(<span class="stringliteral">"KiUnpackDouble: Inf=%d NaN=%d Sign=%d Exponent=%d Mantissa=%.8x%.8x\n"</span>,
04331              DoubleOperand-&gt;Infinity, DoubleOperand-&gt;Nan, DoubleOperand-&gt;Sign,
04332              DoubleOperand-&gt;Exponent,
04333              DoubleOperand-&gt;MantissaHigh, DoubleOperand-&gt;MantissaLow);
04334 
04335     <span class="keywordflow">return</span>;
04336 }
04337 
04338 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l04339"></a><a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a36">04339</a> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a31">KiUnpackSingle</a> (
04340     IN ULONG Source,
04341     IN PFP_CONTEXT_BLOCK ContextBlock,
04342     OUT PFP_SINGLE_OPERAND SingleOperand
04343     )
04344 
04345 <span class="comment">/*++</span>
04346 <span class="comment"></span>
04347 <span class="comment">Routine Description:</span>
04348 <span class="comment"></span>
04349 <span class="comment">    This function is called to unpack a single floating value from the</span>
04350 <span class="comment">    specified source register.</span>
04351 <span class="comment"></span>
04352 <span class="comment">    N.B. The unpacked mantissa value is returned with a guard bit and a</span>
04353 <span class="comment">        round bit on the right and the hidden bit inserted if appropriate.</span>
04354 <span class="comment">        The format of the returned value is:</span>
04355 <span class="comment"></span>
04356 <span class="comment">        &lt;31:26&gt; - zero</span>
04357 <span class="comment">        &lt;25&gt; - hidden bit</span>
04358 <span class="comment">        &lt;24:2&gt; - mantissa</span>
04359 <span class="comment">        &lt;1&gt; - guard bit</span>
04360 <span class="comment">        &lt;0&gt; - round bit</span>
04361 <span class="comment"></span>
04362 <span class="comment">Arguments:</span>
04363 <span class="comment"></span>
04364 <span class="comment">    Source - Supplies the number of the register that contains the operand.</span>
04365 <span class="comment"></span>
04366 <span class="comment">    ContextBlock - Supplies a pointer to the emulation context block.</span>
04367 <span class="comment"></span>
04368 <span class="comment">    SingleOperand - Supplies a pointer to a structure that is to receive the</span>
04369 <span class="comment">        operand value.</span>
04370 <span class="comment"></span>
04371 <span class="comment">Return Value:</span>
04372 <span class="comment"></span>
04373 <span class="comment">    None.</span>
04374 <span class="comment"></span>
04375 <span class="comment">--*/</span>
04376 
04377 {
04378 
04379     ULONG Value;
04380 
04381     <span class="comment">//</span>
04382     <span class="comment">// Get the source register value and unpack the sign, exponent, and</span>
04383     <span class="comment">// mantissa value.</span>
04384     <span class="comment">//</span>
04385 
04386     Value = <a class="code" href="../../d1/d4/alpha_2floatem_8c.html#a23">KiConvertRegisterToSingleOperand</a>(
04387                 <a class="code" href="../../d8/d5/ppc_2getsetrg_8c.html#a0">KiGetRegisterValue</a>(Source + 32,
04388                                   ContextBlock-&gt;ExceptionFrame,
04389                                   ContextBlock-&gt;TrapFrame));
04390 
04391     SingleOperand-&gt;Sign = Value &gt;&gt; 31;
04392     SingleOperand-&gt;Exponent = (Value &gt;&gt; 23) &amp; 0xff;
04393     SingleOperand-&gt;Mantissa = Value &amp; 0x7fffff;
04394 
04395     <span class="comment">//</span>
04396     <span class="comment">// If the exponent is the largest possible value, then the number is</span>
04397     <span class="comment">// either a NaN or an infinity. Otherwise if the exponent is the smallest</span>
04398     <span class="comment">// possible value and the mantissa is nonzero, then the number is</span>
04399     <span class="comment">// denormalized. Otherwise the number is finite and normal.</span>
04400     <span class="comment">//</span>
04401 
04402     <span class="keywordflow">if</span> (SingleOperand-&gt;Exponent == SINGLE_MAXIMUM_EXPONENT) {
04403         SingleOperand-&gt;Normal = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04404         <span class="keywordflow">if</span> (SingleOperand-&gt;Mantissa != 0) {
04405             SingleOperand-&gt;Infinity = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04406             SingleOperand-&gt;Nan = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04407 
04408         } <span class="keywordflow">else</span> {
04409             SingleOperand-&gt;Infinity = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04410             SingleOperand-&gt;Nan = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04411         }
04412 
04413     } <span class="keywordflow">else</span> {
04414         SingleOperand-&gt;Infinity = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04415         SingleOperand-&gt;Nan = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04416         SingleOperand-&gt;Normal = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04417         <span class="keywordflow">if</span> (SingleOperand-&gt;Exponent == SINGLE_MINIMUM_EXPONENT) {
04418             <span class="keywordflow">if</span> (SingleOperand-&gt;Mantissa != 0) {
04419                 <span class="keywordflow">if</span> (ContextBlock-&gt;SoftwareFpcr-&gt;DenormalOperandsEnable == 0) {
04420                     <a class="code" href="../../d6/d5/ioep_8h.html#a21">DBGPRINT</a>(<span class="stringliteral">"SoftwareFpcr-&gt;DenormalOperandsEnable == 0\n"</span>);
04421                     SingleOperand-&gt;Mantissa = 0;
04422                     SingleOperand-&gt;Exponent = 0;
04423                 } <span class="keywordflow">else</span> {
04424                     SingleOperand-&gt;Normal = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04425                     SingleOperand-&gt;Exponent += 1;
04426                     <span class="keywordflow">while</span> ((SingleOperand-&gt;Mantissa &amp; (1 &lt;&lt; 23)) == 0) {
04427                         SingleOperand-&gt;Mantissa &lt;&lt;= 1;
04428                         SingleOperand-&gt;Exponent -= 1;
04429                     }
04430                 }
04431             }
04432 
04433         } <span class="keywordflow">else</span> {
04434             SingleOperand-&gt;Mantissa |= (1 &lt;&lt; 23);
04435         }
04436     }
04437 
04438     <span class="comment">//</span>
04439     <span class="comment">// Left shift the mantissa 2-bits to provide for a guard bit and a round</span>
04440     <span class="comment">// bit.</span>
04441     <span class="comment">//</span>
04442 
04443     SingleOperand-&gt;Mantissa &lt;&lt;= 2;
04444     <a class="code" href="../../d6/d5/ioep_8h.html#a21">DBGPRINT</a>(<span class="stringliteral">"KiUnpackSingle: Inf=%d NaN=%d Sign=%d Exponent=%d Mantissa=%.8x\n"</span>,
04445              SingleOperand-&gt;Infinity, SingleOperand-&gt;Nan, SingleOperand-&gt;Sign,
04446              SingleOperand-&gt;Exponent, SingleOperand-&gt;Mantissa);
04447     <span class="keywordflow">return</span>;
04448 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:40:01 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
