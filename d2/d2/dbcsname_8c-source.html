<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: dbcsname.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>dbcsname.c</h1><a href="../../d1/d3/dbcsname_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1989  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    DbcsName.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    The name support package is for manipulating DBCS strings.  The routines</span>
00012 <span class="comment">    allow the caller to dissect and compare strings.</span>
00013 <span class="comment"></span>
00014 <span class="comment">    The following routines are provided by this package:</span>
00015 <span class="comment"></span>
00016 <span class="comment">      o  FsRtlIsFatDbcsLegal - This routine takes an input dbcs</span>
00017 <span class="comment">         string and determines if it describes a legal name or path.</span>
00018 <span class="comment"></span>
00019 <span class="comment">      o  FsRtlIsHpfsDbcsLegal - This routine takes an input dbcs</span>
00020 <span class="comment">         string and determines if it describes a legal name or path.</span>
00021 <span class="comment"></span>
00022 <span class="comment">      o  FsRtlDissectDbcs - This routine takes a path name string and</span>
00023 <span class="comment">         breaks into two parts.  The first name in the string and the</span>
00024 <span class="comment">         remainder.</span>
00025 <span class="comment"></span>
00026 <span class="comment">      o  FsRtlDoesDbcsContainWildCards - This routines tells the caller if</span>
00027 <span class="comment">         a string contains any wildcard characters.</span>
00028 <span class="comment"></span>
00029 <span class="comment">      o  FsRtlIsDbcsInExpression - This routine is used to compare a string</span>
00030 <span class="comment">         against a template (possibly containing wildcards) to sees if the</span>
00031 <span class="comment">         string is in the language denoted by the template.</span>
00032 <span class="comment"></span>
00033 <span class="comment">Author:</span>
00034 <span class="comment"></span>
00035 <span class="comment">    Gary Kimura     [GaryKi]    5-Feb-1990</span>
00036 <span class="comment"></span>
00037 <span class="comment">Revision History:</span>
00038 <span class="comment"></span>
00039 <span class="comment">--*/</span>
00040 
00041 <span class="preprocessor">#include "FsRtlP.h"</span>
00042 
00043 <span class="comment">//</span>
00044 <span class="comment">//  Trace level for the module</span>
00045 <span class="comment">//</span>
00046 
<a name="l00047"></a><a class="code" href="../../d1/d3/dbcsname_8c.html#a0">00047</a> <span class="preprocessor">#define Dbg                              (0x10000000)</span>
00048 <span class="preprocessor"></span>
00049 <span class="comment">//</span>
00050 <span class="comment">//  Some special debugging code</span>
00051 <span class="comment">//</span>
00052 
00053 <span class="preprocessor">#if DBG</span>
00054 <span class="preprocessor"></span>
00055 ULONG DaveDebug = 0;
00056 <span class="preprocessor">#define DavePrint if (DaveDebug) DbgPrint</span>
00057 <span class="preprocessor"></span>
00058 <span class="preprocessor">#else</span>
00059 <span class="preprocessor"></span>
<a name="l00060"></a><a class="code" href="../../d1/d3/dbcsname_8c.html#a1">00060</a> <span class="preprocessor">#define DavePrint NOTHING</span>
00061 <span class="preprocessor"></span>
00062 <span class="preprocessor">#endif</span>
00063 <span class="preprocessor"></span>
00064 <span class="comment">//</span>
00065 <span class="comment">//  Define a tag for general pool allocations from this module</span>
00066 <span class="comment">//</span>
00067 
00068 <span class="preprocessor">#undef MODULE_POOL_TAG</span>
<a name="l00069"></a><a class="code" href="../../d1/d3/dbcsname_8c.html#a2">00069</a> <span class="preprocessor"></span><span class="preprocessor">#define MODULE_POOL_TAG                  ('drSF')</span>
00070 <span class="preprocessor"></span>
00071 <span class="preprocessor">#ifdef ALLOC_PRAGMA</span>
00072 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, FsRtlDissectDbcs)</span>
00073 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, FsRtlDoesDbcsContainWildCards)</span>
00074 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, FsRtlIsDbcsInExpression)</span>
00075 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, FsRtlIsFatDbcsLegal)</span>
00076 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, FsRtlIsHpfsDbcsLegal)</span>
00077 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00078 <span class="preprocessor"></span>
00079 
00080 BOOLEAN
<a name="l00081"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a134">00081</a> <a class="code" href="../../d1/d8/fsrtl_8h.html#a134">FsRtlIsFatDbcsLegal</a> (
00082     IN ANSI_STRING DbcsName,
00083     IN BOOLEAN WildCardsPermissible,
00084     IN BOOLEAN PathNamePermissible,
00085     IN BOOLEAN LeadingBackslashPermissible
00086     )
00087 
00088 <span class="comment">/*++</span>
00089 <span class="comment"></span>
00090 <span class="comment">Routine Description:</span>
00091 <span class="comment"></span>
00092 <span class="comment">    This routine simple returns whether the specified file names conforms</span>
00093 <span class="comment">    to the file system specific rules for legal file names.  This routine</span>
00094 <span class="comment">    will check the single name, or if PathNamePermissible is specified as</span>
00095 <span class="comment">    TRUE, whether the whole path is a legal name.</span>
00096 <span class="comment"></span>
00097 <span class="comment">    For FAT, the following rules apply:</span>
00098 <span class="comment"></span>
00099 <span class="comment">    A. A Fat file name may not contain any of the following characters:</span>
00100 <span class="comment"></span>
00101 <span class="comment">       0x00-0x1F " / : | + , ; = [ ]</span>
00102 <span class="comment"></span>
00103 <span class="comment">    B. A Fat file name is either of the form N.E or just N, where N is a</span>
00104 <span class="comment">       string of 1-8 bytes and E is a string of 1-3 bytes conformant to</span>
00105 <span class="comment">       rule A above. In addition, neither N nor E may contain a period</span>
00106 <span class="comment">       character or end with a space character.</span>
00107 <span class="comment"></span>
00108 <span class="comment">       Incidently, N corresponds to name and E to extension.</span>
00109 <span class="comment"></span>
00110 <span class="comment">    Case: Lower case characters are taken as valid, but are up-shifted upon</span>
00111 <span class="comment">          receipt, ie. Fat only deals with upper case file names.</span>
00112 <span class="comment"></span>
00113 <span class="comment">    For example, the files ".foo", "foo.", and "foo .b" are illegal, while</span>
00114 <span class="comment">    "foo. b" and " bar" are legal.</span>
00115 <span class="comment"></span>
00116 <span class="comment">Arguments:</span>
00117 <span class="comment"></span>
00118 <span class="comment">    DbcsName - Supllies the name/path to check.</span>
00119 <span class="comment"></span>
00120 <span class="comment">    WildCardsPermissible - Specifies if Nt wild card characters are to be</span>
00121 <span class="comment">        considered considered legal.</span>
00122 <span class="comment"></span>
00123 <span class="comment">    PathNamePermissible - Spcifes if Name may be a path name separated by</span>
00124 <span class="comment">        backslash characters, or just a simple file name.</span>
00125 <span class="comment"></span>
00126 <span class="comment">    LeadingBackSlashPermissible - Specifies if a single leading backslash</span>
00127 <span class="comment">        is permissible in the file/path name.</span>
00128 <span class="comment"></span>
00129 <span class="comment">Return Value:</span>
00130 <span class="comment"></span>
00131 <span class="comment">    BOOLEAN - TRUE if the name is legal, FALSE otherwise.</span>
00132 <span class="comment"></span>
00133 <span class="comment">--*/</span>
00134 {
00135     BOOLEAN ExtensionPresent = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00136 
00137     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
00138 
00139     UCHAR Char;
00140 
00141     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00142 
00143     <span class="comment">//</span>
00144     <span class="comment">//  Empty names are not valid.</span>
00145     <span class="comment">//</span>
00146 
00147     <span class="keywordflow">if</span> ( DbcsName.Length == 0 ) { <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>; }
00148 
00149     <span class="comment">//</span>
00150     <span class="comment">//  If Wild Cards are OK, then for directory enumeration to work</span>
00151     <span class="comment">//  correctly we have to accept . and ..</span>
00152     <span class="comment">//</span>
00153 
00154     <span class="keywordflow">if</span> ( WildCardsPermissible &amp;&amp;
00155          ( ( (DbcsName.Length == 1) &amp;&amp;
00156              ((DbcsName.Buffer[0] == <span class="charliteral">'.'</span>) ||
00157               (DbcsName.Buffer[0] == ANSI_DOS_DOT)) )
00158            ||
00159            ( (DbcsName.Length == 2) &amp;&amp;
00160              ( ((DbcsName.Buffer[0] == <span class="charliteral">'.'</span>) &amp;&amp;
00161                 (DbcsName.Buffer[1] == <span class="charliteral">'.'</span>)) ||
00162                ((DbcsName.Buffer[0] == ANSI_DOS_DOT) &amp;&amp;
00163                 (DbcsName.Buffer[1] == ANSI_DOS_DOT)) ) ) ) ) {
00164 
00165         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00166     }
00167 
00168     <span class="comment">//</span>
00169     <span class="comment">//  If a leading \ is OK, skip over it (if there's more)</span>
00170     <span class="comment">//</span>
00171 
00172     <span class="keywordflow">if</span> ( DbcsName.Buffer[0] == <span class="charliteral">'\\'</span> ) {
00173 
00174         <span class="keywordflow">if</span> ( LeadingBackslashPermissible ) {
00175 
00176             <span class="keywordflow">if</span> ( (DbcsName.Length &gt; 1) ) {
00177 
00178                 DbcsName.Buffer += 1;
00179                 DbcsName.Length -= 1;
00180 
00181             } <span class="keywordflow">else</span> { <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>; }
00182 
00183         } <span class="keywordflow">else</span> { <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>; }
00184     }
00185 
00186     <span class="comment">//</span>
00187     <span class="comment">//  If we got a path name, check each componant.</span>
00188     <span class="comment">//</span>
00189 
00190     <span class="keywordflow">if</span> ( PathNamePermissible ) {
00191 
00192         ANSI_STRING FirstName;
00193         ANSI_STRING RemainingName;
00194 
00195         RemainingName = DbcsName;
00196 
00197         <span class="keywordflow">while</span> ( RemainingName.Length != 0 ) {
00198 
00199             <span class="comment">//</span>
00200             <span class="comment">//  This will catch the case of an illegal double backslash.</span>
00201             <span class="comment">//</span>
00202 
00203             <span class="keywordflow">if</span> ( RemainingName.Buffer[0] == <span class="charliteral">'\\'</span> ) { <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>; }
00204 
00205             <a class="code" href="../../d1/d8/fsrtl_8h.html#a131">FsRtlDissectDbcs</a>(RemainingName, &amp;FirstName, &amp;RemainingName);
00206 
00207             <span class="keywordflow">if</span> ( !<a class="code" href="../../d1/d8/fsrtl_8h.html#a134">FsRtlIsFatDbcsLegal</a>( FirstName,
00208                                        WildCardsPermissible,
00209                                        <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00210                                        <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) ) {
00211 
00212                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00213             }
00214         }
00215 
00216         <span class="comment">//</span>
00217         <span class="comment">//  All the componants were OK, so the path is OK.</span>
00218         <span class="comment">//</span>
00219 
00220         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00221     }
00222 
00223     <span class="comment">//</span>
00224     <span class="comment">//  If this name contains wild cards, just check for invalid characters.</span>
00225     <span class="comment">//</span>
00226 
00227     <span class="keywordflow">if</span> ( WildCardsPermissible &amp;&amp; <a class="code" href="../../d1/d8/fsrtl_8h.html#a132">FsRtlDoesDbcsContainWildCards</a>(&amp;DbcsName) ) {
00228 
00229         <span class="keywordflow">for</span> ( <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = 0; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &lt; DbcsName.Length; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> += 1 ) {
00230 
00231             Char = DbcsName.Buffer[ <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> ];
00232 
00233             <span class="comment">//</span>
00234             <span class="comment">//  Skip over any Dbcs chacters</span>
00235             <span class="comment">//</span>
00236 
00237             <span class="keywordflow">if</span> ( <a class="code" href="../../d1/d8/fsrtl_8h.html#a36">FsRtlIsLeadDbcsCharacter</a>( Char ) ) {
00238 
00239                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> != (ULONG)(DbcsName.Length - 1) );
00240                 <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> += 1;
00241                 <span class="keywordflow">continue</span>;
00242             }
00243 
00244             <span class="comment">//</span>
00245             <span class="comment">//  Make sure this character is legal, and if a wild card, that</span>
00246             <span class="comment">//  wild cards are permissible.</span>
00247             <span class="comment">//</span>
00248 
00249             <span class="keywordflow">if</span> ( !<a class="code" href="../../d1/d8/fsrtl_8h.html#a30">FsRtlIsAnsiCharacterLegalFat</a>(Char, WildCardsPermissible) ) {
00250                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00251             }
00252         }
00253 
00254         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00255     }
00256 
00257 
00258     <span class="comment">//</span>
00259     <span class="comment">//  At this point we should only have a single name, which can't have</span>
00260     <span class="comment">//  more than 12 characters (including a single period)</span>
00261     <span class="comment">//</span>
00262 
00263     <span class="keywordflow">if</span> ( DbcsName.Length &gt; 12 ) { <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>; }
00264 
00265     <span class="keywordflow">for</span> ( <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = 0; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &lt; DbcsName.Length; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> += 1 ) {
00266 
00267         Char = DbcsName.Buffer[ <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> ];
00268 
00269         <span class="comment">//</span>
00270         <span class="comment">//  Skip over and Dbcs chacters</span>
00271         <span class="comment">//</span>
00272 
00273         <span class="keywordflow">if</span> ( <a class="code" href="../../d1/d8/fsrtl_8h.html#a36">FsRtlIsLeadDbcsCharacter</a>( Char ) ) {
00274 
00275             <span class="comment">//</span>
00276             <span class="comment">//  FsRtlIsFatDbcsLegal(): fat name part and extension part dbcs check</span>
00277             <span class="comment">//</span>
00278             <span class="comment">//  1) if we're looking at base part ( !ExtensionPresent ) and the 8th byte</span>
00279             <span class="comment">//     is in the dbcs leading byte range, it's error ( Index == 7 ). If the</span>
00280             <span class="comment">//     length of base part is more than 8 ( Index &gt; 7 ), it's definitely error.</span>
00281             <span class="comment">//</span>
00282             <span class="comment">//  2) if the last byte ( Index == DbcsName.Length - 1 ) is in the dbcs leading</span>
00283             <span class="comment">//     byte range, it's error</span>
00284             <span class="comment">//</span>
00285 
00286             <span class="keywordflow">if</span> ( (!ExtensionPresent &amp;&amp; (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &gt;= 7)) ||
00287                  ( <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> == (ULONG)(DbcsName.Length - 1) ) ) {
00288                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00289             }
00290 
00291             <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> += 1;
00292 
00293             <span class="keywordflow">continue</span>;
00294         }
00295 
00296         <span class="comment">//</span>
00297         <span class="comment">//  Make sure this character is legal, and if a wild card, that</span>
00298         <span class="comment">//  wild cards are permissible.</span>
00299         <span class="comment">//</span>
00300 
00301         <span class="keywordflow">if</span> ( !<a class="code" href="../../d1/d8/fsrtl_8h.html#a30">FsRtlIsAnsiCharacterLegalFat</a>(Char, WildCardsPermissible) ) {
00302 
00303             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00304         }
00305 
00306         <span class="keywordflow">if</span> ( (Char == <span class="charliteral">'.'</span>) || (Char == ANSI_DOS_DOT) ) {
00307 
00308             <span class="comment">//</span>
00309             <span class="comment">//  We stepped onto a period.  We require the following things:</span>
00310             <span class="comment">//</span>
00311             <span class="comment">//      - It can't be the first character</span>
00312             <span class="comment">//      - There can only be one</span>
00313             <span class="comment">//      - There can't be more than three characters following</span>
00314             <span class="comment">//      - The previous character can't be a space.</span>
00315             <span class="comment">//</span>
00316 
00317             <span class="keywordflow">if</span> ( (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> == 0) ||
00318                  ExtensionPresent ||
00319                  (DbcsName.Length - (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> + 1) &gt; 3) ||
00320                  (DbcsName.Buffer[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> - 1] == <span class="charliteral">' '</span>) ) {
00321 
00322                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00323             }
00324 
00325             ExtensionPresent = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00326         }
00327 
00328         <span class="comment">//</span>
00329         <span class="comment">//  The base part of the name can't be more than 8 characters long.</span>
00330         <span class="comment">//</span>
00331 
00332         <span class="keywordflow">if</span> ( (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &gt;= 8) &amp;&amp; !ExtensionPresent ) { <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>; }
00333     }
00334 
00335     <span class="comment">//</span>
00336     <span class="comment">//  The name cannot end in a space or a period.</span>
00337     <span class="comment">//</span>
00338 
00339     <span class="keywordflow">if</span> ( (Char == <span class="charliteral">' '</span>) || (Char == <span class="charliteral">'.'</span>) || (Char == ANSI_DOS_DOT)) { <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>; }
00340 
00341     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00342 }
00343 
00344 BOOLEAN
<a name="l00345"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a135">00345</a> <a class="code" href="../../d1/d8/fsrtl_8h.html#a135">FsRtlIsHpfsDbcsLegal</a> (
00346     IN ANSI_STRING DbcsName,
00347     IN BOOLEAN WildCardsPermissible,
00348     IN BOOLEAN PathNamePermissible,
00349     IN BOOLEAN LeadingBackslashPermissible
00350     )
00351 
00352 <span class="comment">/*++</span>
00353 <span class="comment"></span>
00354 <span class="comment">Routine Description:</span>
00355 <span class="comment"></span>
00356 <span class="comment">    This routine simple returns whether the specified file names conforms</span>
00357 <span class="comment">    to the file system specific rules for legal file names.  This routine</span>
00358 <span class="comment">    will check the single name, or if PathNamePermissible is specified as</span>
00359 <span class="comment">    TRUE, whether the whole path is a legal name.</span>
00360 <span class="comment"></span>
00361 <span class="comment">    For HPFS, the following rules apply:</span>
00362 <span class="comment"></span>
00363 <span class="comment">    A. An HPFS file name may not contain any of the following characters:</span>
00364 <span class="comment"></span>
00365 <span class="comment">       0x0000 - 0x001F  " / : &lt; &gt; ? | *</span>
00366 <span class="comment"></span>
00367 <span class="comment">    B. An HPFS file name may not end in a period or a space.</span>
00368 <span class="comment"></span>
00369 <span class="comment">    C. An HPFS file name must contain no more than 255 bytes.</span>
00370 <span class="comment"></span>
00371 <span class="comment">    Case: HPFS is case preserving, but not case sensitive.  Case is</span>
00372 <span class="comment">          preserved on creates, but not checked for on file name compares.</span>
00373 <span class="comment"></span>
00374 <span class="comment">    For example, the files "foo " and "foo." are illegal, while ".foo",</span>
00375 <span class="comment">    " foo" and "foo.bar.foo" are legal.</span>
00376 <span class="comment"></span>
00377 <span class="comment">Arguments:</span>
00378 <span class="comment"></span>
00379 <span class="comment">    DbcsName - Supllies the name/path to check.</span>
00380 <span class="comment"></span>
00381 <span class="comment">    WildCardsPermissible - Specifies if Nt wild card characters are to be</span>
00382 <span class="comment">        considered considered legal.</span>
00383 <span class="comment"></span>
00384 <span class="comment">    PathNamePermissible - Spcifes if Name may be a path name separated by</span>
00385 <span class="comment">        backslash characters, or just a simple file name.</span>
00386 <span class="comment"></span>
00387 <span class="comment">    LeadingBackSlashPermissible - Specifies if a single leading backslash</span>
00388 <span class="comment">        is permissible in the file/path name.</span>
00389 <span class="comment"></span>
00390 <span class="comment">Return Value:</span>
00391 <span class="comment"></span>
00392 <span class="comment">    BOOLEAN - TRUE if the name is legal, FALSE otherwise.</span>
00393 <span class="comment"></span>
00394 <span class="comment">--*/</span>
00395 {
00396     BOOLEAN ExtensionPresent = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00397 
00398     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
00399 
00400     UCHAR Char;
00401 
00402     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00403 
00404     <span class="comment">//</span>
00405     <span class="comment">//  Empty names are not valid.</span>
00406     <span class="comment">//</span>
00407 
00408     <span class="keywordflow">if</span> ( DbcsName.Length == 0 ) { <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>; }
00409 
00410     <span class="comment">//</span>
00411     <span class="comment">//  If Wild Cards are OK, then for directory enumeration to work</span>
00412     <span class="comment">//  correctly we have to accept . and ..</span>
00413     <span class="comment">//</span>
00414 
00415     <span class="keywordflow">if</span> ( WildCardsPermissible &amp;&amp;
00416          ( ( (DbcsName.Length == 1) &amp;&amp;
00417              ((DbcsName.Buffer[0] == <span class="charliteral">'.'</span>) ||
00418               (DbcsName.Buffer[0] == ANSI_DOS_DOT)) )
00419            ||
00420            ( (DbcsName.Length == 2) &amp;&amp;
00421              ( ((DbcsName.Buffer[0] == <span class="charliteral">'.'</span>) &amp;&amp;
00422                 (DbcsName.Buffer[1] == <span class="charliteral">'.'</span>)) ||
00423                ((DbcsName.Buffer[0] == ANSI_DOS_DOT) &amp;&amp;
00424                 (DbcsName.Buffer[1] == ANSI_DOS_DOT)) ) ) ) ) {
00425 
00426         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00427     }
00428 
00429     <span class="comment">//</span>
00430     <span class="comment">//  If a leading \ is OK, skip over it (if there's more)</span>
00431     <span class="comment">//</span>
00432 
00433     <span class="keywordflow">if</span> ( DbcsName.Buffer[0] == <span class="charliteral">'\\'</span> ) {
00434 
00435         <span class="keywordflow">if</span> ( LeadingBackslashPermissible ) {
00436 
00437             <span class="keywordflow">if</span> ( (DbcsName.Length &gt; 1) ) {
00438 
00439                 DbcsName.Buffer += 1;
00440                 DbcsName.Length -= 1;
00441 
00442             } <span class="keywordflow">else</span> { <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>; }
00443 
00444         } <span class="keywordflow">else</span> { <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>; }
00445     }
00446 
00447     <span class="comment">//</span>
00448     <span class="comment">//  If we got a path name, check each componant.</span>
00449     <span class="comment">//</span>
00450 
00451     <span class="keywordflow">if</span> ( PathNamePermissible ) {
00452 
00453         ANSI_STRING FirstName;
00454         ANSI_STRING RemainingName;
00455 
00456         RemainingName = DbcsName;
00457 
00458         <span class="keywordflow">while</span> ( RemainingName.Length != 0 ) {
00459 
00460             <span class="comment">//</span>
00461             <span class="comment">//  This will catch the case of an illegal double backslash.</span>
00462             <span class="comment">//</span>
00463 
00464             <span class="keywordflow">if</span> ( RemainingName.Buffer[0] == <span class="charliteral">'\\'</span> ) { <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>; }
00465 
00466             <a class="code" href="../../d1/d8/fsrtl_8h.html#a131">FsRtlDissectDbcs</a>(RemainingName, &amp;FirstName, &amp;RemainingName);
00467 
00468             <span class="keywordflow">if</span> ( !<a class="code" href="../../d1/d8/fsrtl_8h.html#a135">FsRtlIsHpfsDbcsLegal</a>( FirstName,
00469                                        WildCardsPermissible,
00470                                        <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00471                                        <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) ) {
00472 
00473                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00474             }
00475         }
00476 
00477         <span class="comment">//</span>
00478         <span class="comment">//  All the componants were OK, so the path is OK.</span>
00479         <span class="comment">//</span>
00480 
00481         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00482     }
00483 
00484     <span class="comment">//</span>
00485     <span class="comment">//  At this point we should only have a single name, which can't have</span>
00486     <span class="comment">//  more than 255 characters</span>
00487     <span class="comment">//</span>
00488 
00489     <span class="keywordflow">if</span> ( DbcsName.Length &gt; 255 ) { <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>; }
00490 
00491     <span class="keywordflow">for</span> ( <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = 0; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &lt; DbcsName.Length; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> += 1 ) {
00492 
00493         Char = DbcsName.Buffer[ <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> ];
00494 
00495         <span class="comment">//</span>
00496         <span class="comment">//  Skip over and Dbcs chacters</span>
00497         <span class="comment">//</span>
00498 
00499         <span class="keywordflow">if</span> ( <a class="code" href="../../d1/d8/fsrtl_8h.html#a36">FsRtlIsLeadDbcsCharacter</a>( Char ) ) {
00500 
00501             <span class="comment">//</span>
00502             <span class="comment">//  FsRtlIsHpfsDbcsLegal () hpfs dbcs check</span>
00503             <span class="comment">//</span>
00504             <span class="comment">//  If the last byte ( Index == DbcsName.Length - 1 ) is in the</span>
00505             <span class="comment">//  dbcs leading byte range, it's error.</span>
00506             <span class="comment">//</span>
00507 
00508             <span class="keywordflow">if</span> ( <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> == (ULONG)(DbcsName.Length - 1) ) {
00509 
00510                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00511             }
00512 
00513             <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> += 1;
00514             <span class="keywordflow">continue</span>;
00515         }
00516 
00517         <span class="comment">//</span>
00518         <span class="comment">//  Make sure this character is legal, and if a wild card, that</span>
00519         <span class="comment">//  wild cards are permissible.</span>
00520         <span class="comment">//</span>
00521 
00522         <span class="keywordflow">if</span> ( !<a class="code" href="../../d1/d8/fsrtl_8h.html#a31">FsRtlIsAnsiCharacterLegalHpfs</a>(Char, WildCardsPermissible) ) {
00523 
00524             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00525         }
00526     }
00527 
00528     <span class="comment">//</span>
00529     <span class="comment">//  The name cannot end in a space or a period.</span>
00530     <span class="comment">//</span>
00531 
00532     <span class="keywordflow">if</span> ( (Char == <span class="charliteral">' '</span>) || (Char == <span class="charliteral">'.'</span>) || (Char == ANSI_DOS_DOT) ) {
00533 
00534         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00535     }
00536 
00537     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00538 }
00539 
00540 
00541 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00542"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a131">00542</a> <a class="code" href="../../d1/d8/fsrtl_8h.html#a131">FsRtlDissectDbcs</a> (
00543     IN ANSI_STRING Path,
00544     OUT PANSI_STRING FirstName,
00545     OUT PANSI_STRING RemainingName
00546     )
00547 
00548 <span class="comment">/*++</span>
00549 <span class="comment"></span>
00550 <span class="comment">Routine Description:</span>
00551 <span class="comment"></span>
00552 <span class="comment">    This routine takes an input Dbcs string and dissects it into two</span>
00553 <span class="comment">    substrings.  The first output string contains the name that appears at</span>
00554 <span class="comment">    the beginning of the input string, the second output string contains the</span>
00555 <span class="comment">    remainder of the input string.</span>
00556 <span class="comment"></span>
00557 <span class="comment">    In the input string backslashes are used to separate names.  The input</span>
00558 <span class="comment">    string must not start with a backslash.  Both output strings will not</span>
00559 <span class="comment">    begin with a backslash.</span>
00560 <span class="comment"></span>
00561 <span class="comment">    If the input string does not contain any names then both output strings</span>
00562 <span class="comment">    are empty.  If the input string contains only one name then the first</span>
00563 <span class="comment">    output string contains the name and the second string is empty.</span>
00564 <span class="comment"></span>
00565 <span class="comment">    Note that both output strings use the same string buffer memory of the</span>
00566 <span class="comment">    input string.</span>
00567 <span class="comment"></span>
00568 <span class="comment">    Example of its results are:</span>
00569 <span class="comment"></span>
00570 <span class="comment">//. .     InputString    FirstPart    RemainingPart</span>
00571 <span class="comment">//</span>
00572 <span class="comment">//. .     empty          empty        empty</span>
00573 <span class="comment">//</span>
00574 <span class="comment">//. .     A              A            empty</span>
00575 <span class="comment">//</span>
00576 <span class="comment">//. .     A\B\C\D\E      A            B\C\D\E</span>
00577 <span class="comment">//</span>
00578 <span class="comment">//. .     *A?            *A?          empty</span>
00579 <span class="comment">//</span>
00580 <span class="comment">//. .     \A             A            empty</span>
00581 <span class="comment">//</span>
00582 <span class="comment">//. .     A[,]           A[,]         empty</span>
00583 <span class="comment">//</span>
00584 <span class="comment">//. .     A\\B+;\C       A            \B+;\C</span>
00585 <span class="comment"></span>
00586 <span class="comment">Arguments:</span>
00587 <span class="comment"></span>
00588 <span class="comment">    InputName - Supplies the input string being dissected</span>
00589 <span class="comment"></span>
00590 <span class="comment">    Is8dot3 - Indicates if the first part of the input name must be 8.3</span>
00591 <span class="comment">        or can be long file name.</span>
00592 <span class="comment"></span>
00593 <span class="comment">    FirstPart - Receives the first name in the input string</span>
00594 <span class="comment"></span>
00595 <span class="comment">    RemainingPart - Receives the remaining part of the input string</span>
00596 <span class="comment"></span>
00597 <span class="comment">Return Value:</span>
00598 <span class="comment"></span>
00599 <span class="comment">    NONE</span>
00600 <span class="comment"></span>
00601 <span class="comment">--*/</span>
00602 
00603 {
00604     ULONG i = 0;
00605     ULONG PathLength;
00606     ULONG FirstNameStart;
00607 
00608     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00609 
00610     <span class="comment">//</span>
00611     <span class="comment">//  Make both output strings empty for now</span>
00612     <span class="comment">//</span>
00613 
00614     FirstName-&gt;Length = 0;
00615     FirstName-&gt;MaximumLength = 0;
00616     FirstName-&gt;Buffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00617 
00618     RemainingName-&gt;Length = 0;
00619     RemainingName-&gt;MaximumLength = 0;
00620     RemainingName-&gt;Buffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00621 
00622     PathLength = Path.Length;
00623 
00624     <span class="comment">//</span>
00625     <span class="comment">//  Check for an empty input string</span>
00626     <span class="comment">//</span>
00627 
00628     <span class="keywordflow">if</span> (PathLength == 0) {
00629 
00630         <span class="keywordflow">return</span>;
00631     }
00632 
00633     <span class="comment">//</span>
00634     <span class="comment">//  Skip over a starting backslash, and make sure there is more.</span>
00635     <span class="comment">//</span>
00636 
00637     <span class="keywordflow">if</span> ( Path.Buffer[0] == <span class="charliteral">'\\'</span> ) {
00638 
00639         i = 1;
00640     }
00641 
00642     <span class="comment">//</span>
00643     <span class="comment">//  Now run down the input string until we hit a backslash or the end</span>
00644     <span class="comment">//  of the string, remembering where we started;</span>
00645     <span class="comment">//</span>
00646 
00647     <span class="keywordflow">for</span> ( FirstNameStart = i;
00648           (i &lt; PathLength) &amp;&amp; (Path.Buffer[i] != <span class="charliteral">'\\'</span>);
00649           i += 1 ) {
00650 
00651         <span class="comment">//</span>
00652         <span class="comment">//  If this is the first byte of a Dbcs character, skip over the</span>
00653         <span class="comment">//  next byte as well.</span>
00654         <span class="comment">//</span>
00655 
00656         <span class="keywordflow">if</span> ( <a class="code" href="../../d1/d8/fsrtl_8h.html#a36">FsRtlIsLeadDbcsCharacter</a>( Path.Buffer[i] ) ) {
00657 
00658             i += 1;
00659         }
00660     }
00661 
00662     <span class="comment">//</span>
00663     <span class="comment">//  At this point all characters up to (but not including) i are</span>
00664     <span class="comment">//  in the first part.   So setup the first name</span>
00665     <span class="comment">//</span>
00666 
00667     FirstName-&gt;Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(i - FirstNameStart);
00668     FirstName-&gt;MaximumLength = FirstName-&gt;Length;
00669     FirstName-&gt;Buffer = &amp;Path.Buffer[FirstNameStart];
00670 
00671     <span class="comment">//</span>
00672     <span class="comment">//  Now the remaining part needs a string only if the first part didn't</span>
00673     <span class="comment">//  exhaust the entire input string.  We know that if anything is left</span>
00674     <span class="comment">//  that is must start with a backslash.  Note that if there is only</span>
00675     <span class="comment">//  a trailing backslash, the length will get correctly set to zero.</span>
00676     <span class="comment">//</span>
00677 
00678     <span class="keywordflow">if</span> (i &lt; PathLength) {
00679 
00680         RemainingName-&gt;Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(PathLength - (i + 1));
00681         RemainingName-&gt;MaximumLength = RemainingName-&gt;Length;
00682         RemainingName-&gt;Buffer = &amp;Path.Buffer[i + 1];
00683     }
00684 
00685     <span class="comment">//</span>
00686     <span class="comment">//  And return to our caller</span>
00687     <span class="comment">//</span>
00688 
00689     <span class="keywordflow">return</span>;
00690 }
00691 
00692 
00693 BOOLEAN
<a name="l00694"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a132">00694</a> <a class="code" href="../../d1/d8/fsrtl_8h.html#a132">FsRtlDoesDbcsContainWildCards</a> (
00695     IN PANSI_STRING Name
00696     )
00697 
00698 <span class="comment">/*++</span>
00699 <span class="comment"></span>
00700 <span class="comment">Routine Description:</span>
00701 <span class="comment"></span>
00702 <span class="comment">    This routine checks if the input Dbcs name contains any wild card</span>
00703 <span class="comment">    characters (i.e., *, ?, ANSI_DOS_STAR, or ANSI_DOS_QM).</span>
00704 <span class="comment"></span>
00705 <span class="comment">Arguments:</span>
00706 <span class="comment"></span>
00707 <span class="comment">    Name - Supplies the name to examine</span>
00708 <span class="comment"></span>
00709 <span class="comment">Return Value:</span>
00710 <span class="comment"></span>
00711 <span class="comment">    BOOLEAN - TRUE if the input name contains any wildcard characters and</span>
00712 <span class="comment">        FALSE otherwise.</span>
00713 <span class="comment"></span>
00714 <span class="comment">--*/</span>
00715 
00716 {
00717     CLONG i;
00718 
00719     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00720 
00721     <span class="comment">//</span>
00722     <span class="comment">//  Check each character in the name to see if it's a wildcard</span>
00723     <span class="comment">//  character</span>
00724     <span class="comment">//</span>
00725 
00726     <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length; i += 1) {
00727 
00728         <span class="comment">//</span>
00729         <span class="comment">//  check for dbcs character because we'll just skip over those</span>
00730         <span class="comment">//</span>
00731 
00732         <span class="keywordflow">if</span> (<a class="code" href="../../d1/d8/fsrtl_8h.html#a36">FsRtlIsLeadDbcsCharacter</a>( <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Buffer[i] )) {
00733 
00734             i += 1;
00735 
00736         <span class="comment">//</span>
00737         <span class="comment">//  else check for a wild card character</span>
00738         <span class="comment">//</span>
00739 
00740         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="../../d1/d8/fsrtl_8h.html#a29">FsRtlIsAnsiCharacterWild</a>( <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Buffer[i] )) {
00741 
00742             <span class="comment">//</span>
00743             <span class="comment">//  Tell caller that this name contains wild cards</span>
00744             <span class="comment">//</span>
00745 
00746             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00747         }
00748     }
00749 
00750     <span class="comment">//</span>
00751     <span class="comment">//  No wildcard characters were found, so return to our caller</span>
00752     <span class="comment">//</span>
00753 
00754     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00755 }
00756 
<a name="l00757"></a><a class="code" href="../../d1/d3/dbcsname_8c.html#a3">00757</a> <span class="preprocessor">#define GetDbcs(BUF,OFFSET,DBCS_CHAR,LENGTH) {               \</span>
00758 <span class="preprocessor">    if (FsRtlIsLeadDbcsCharacter( (BUF)[(OFFSET)] )) {       \</span>
00759 <span class="preprocessor">        *(DBCS_CHAR) = (WCHAR)((BUF)[(OFFSET)] +             \</span>
00760 <span class="preprocessor">                               0x100 * (BUF)[(OFFSET) + 1]); \</span>
00761 <span class="preprocessor">        *(LENGTH) = 2;                                       \</span>
00762 <span class="preprocessor">    } else {                                                 \</span>
00763 <span class="preprocessor">        *(DBCS_CHAR) = (WCHAR)(BUF)[(OFFSET)];               \</span>
00764 <span class="preprocessor">        *(LENGTH) = 1;                                       \</span>
00765 <span class="preprocessor">    }                                                        \</span>
00766 <span class="preprocessor">}</span>
00767 <span class="preprocessor"></span>
<a name="l00768"></a><a class="code" href="../../d1/d3/dbcsname_8c.html#a4">00768</a> <span class="preprocessor">#define MATCHES_ARRAY_SIZE 16</span>
00769 <span class="preprocessor"></span>
00770 BOOLEAN
<a name="l00771"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a133">00771</a> <a class="code" href="../../d1/d8/fsrtl_8h.html#a133">FsRtlIsDbcsInExpression</a> (
00772     IN PANSI_STRING Expression,
00773     IN PANSI_STRING Name
00774     )
00775 
00776 <span class="comment">/*++</span>
00777 <span class="comment"></span>
00778 <span class="comment">Routine Description:</span>
00779 <span class="comment"></span>
00780 <span class="comment">    This routine compares a Dbcs name and an expression and tells the caller</span>
00781 <span class="comment">    if the name is in the language defined by the expression.  The input name</span>
00782 <span class="comment">    cannot contain wildcards, while the expression may contain wildcards.</span>
00783 <span class="comment"></span>
00784 <span class="comment">    Expression wild cards are evaluated as shown in the nondeterministic</span>
00785 <span class="comment">    finite automatons below.  Note that ~* and ~? are DOS_STAR and DOS_QM.</span>
00786 <span class="comment"></span>
00787 <span class="comment"></span>
00788 <span class="comment">             ~* is DOS_STAR, ~? is DOS_QM, and ~. is DOS_DOT</span>
00789 <span class="comment"></span>
00790 <span class="comment"></span>
00791 <span class="comment">                                       S</span>
00792 <span class="comment">                                    &lt;-----&lt;</span>
00793 <span class="comment">                                 X  |     |  e       Y</span>
00794 <span class="comment">             X * Y ==       (0)-----&gt;-(1)-&gt;-----(2)-----(3)</span>
00795 <span class="comment"></span>
00796 <span class="comment"></span>
00797 <span class="comment">                                      S-.</span>
00798 <span class="comment">                                    &lt;-----&lt;</span>
00799 <span class="comment">                                 X  |     |  e       Y</span>
00800 <span class="comment">             X ~* Y ==      (0)-----&gt;-(1)-&gt;-----(2)-----(3)</span>
00801 <span class="comment"></span>
00802 <span class="comment"></span>
00803 <span class="comment"></span>
00804 <span class="comment">                                X     S     S     Y</span>
00805 <span class="comment">             X ?? Y ==      (0)---(1)---(2)---(3)---(4)</span>
00806 <span class="comment"></span>
00807 <span class="comment"></span>
00808 <span class="comment"></span>
00809 <span class="comment">                                X     .        .      Y</span>
00810 <span class="comment">             X ~.~. Y ==    (0)---(1)----(2)------(3)---(4)</span>
00811 <span class="comment">                                   |      |________|</span>
00812 <span class="comment">                                   |           ^   |</span>
00813 <span class="comment">                                   |_______________|</span>
00814 <span class="comment">                                      ^EOF or .^</span>
00815 <span class="comment"></span>
00816 <span class="comment"></span>
00817 <span class="comment">                                X     S-.     S-.     Y</span>
00818 <span class="comment">             X ~?~? Y ==    (0)---(1)-----(2)-----(3)---(4)</span>
00819 <span class="comment">                                   |      |________|</span>
00820 <span class="comment">                                   |           ^   |</span>
00821 <span class="comment">                                   |_______________|</span>
00822 <span class="comment">                                      ^EOF or .^</span>
00823 <span class="comment"></span>
00824 <span class="comment"></span>
00825 <span class="comment"></span>
00826 <span class="comment">         where S is any single character</span>
00827 <span class="comment"></span>
00828 <span class="comment">               S-. is any single character except the final .</span>
00829 <span class="comment"></span>
00830 <span class="comment">               e is a null character transition</span>
00831 <span class="comment"></span>
00832 <span class="comment">               EOF is the end of the name string</span>
00833 <span class="comment"></span>
00834 <span class="comment">    In words:</span>
00835 <span class="comment"></span>
00836 <span class="comment">        * matches 0 or more characters.</span>
00837 <span class="comment"></span>
00838 <span class="comment">        ? matches exactly 1 character.</span>
00839 <span class="comment"></span>
00840 <span class="comment">        DOS_STAR matches 0 or more characters until encountering and matching</span>
00841 <span class="comment">            the final . in the name.</span>
00842 <span class="comment"></span>
00843 <span class="comment">        DOS_QM matches any single character, or upon encountering a period or</span>
00844 <span class="comment">            end of name string, advances the expression to the end of the</span>
00845 <span class="comment">            set of contiguous DOS_QMs.</span>
00846 <span class="comment"></span>
00847 <span class="comment">        DOS_DOT matches either a . or zero characters beyond name string.</span>
00848 <span class="comment"></span>
00849 <span class="comment">Arguments:</span>
00850 <span class="comment"></span>
00851 <span class="comment">    Expression - Supplies the input expression to check against</span>
00852 <span class="comment"></span>
00853 <span class="comment">    Name - Supplies the input name to check for.</span>
00854 <span class="comment"></span>
00855 <span class="comment">Return Value:</span>
00856 <span class="comment"></span>
00857 <span class="comment">    BOOLEAN - TRUE if Name is an element in the set of strings denoted</span>
00858 <span class="comment">        by the input Expression and FALSE otherwise.</span>
00859 <span class="comment"></span>
00860 <span class="comment">--*/</span>
00861 
00862 {
00863     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> NameOffset;
00864     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> ExprOffset;
00865     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> Length;
00866 
00867     ULONG SrcCount;
00868     ULONG DestCount;
00869     ULONG PreviousDestCount;
00870     ULONG MatchesCount;
00871 
00872     WCHAR NameChar, ExprChar;
00873 
00874     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> LocalBuffer[<a class="code" href="../../d1/d3/dbcsname_8c.html#a4">MATCHES_ARRAY_SIZE</a> * 2];
00875 
00876     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> *AuxBuffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00877     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> *PreviousMatches;
00878     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> *CurrentMatches;
00879 
00880     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> MaxState;
00881     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> CurrentState;
00882 
00883     BOOLEAN NameFinished = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00884 
00885     <span class="comment">//</span>
00886     <span class="comment">//  The idea behind the algorithm is pretty simple.  We keep track of</span>
00887     <span class="comment">//  all possible locations in the regular expression that are matching</span>
00888     <span class="comment">//  the name.  If when the name has been exhausted one of the locations</span>
00889     <span class="comment">//  in the expression is also just exhausted, the name is in the language</span>
00890     <span class="comment">//  defined by the regular expression.</span>
00891     <span class="comment">//</span>
00892 
00893     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00894 
00895     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlIsDbcsInExpression\n"</span>, 0);
00896     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">" Expression      = %Z\n"</span>, Expression );
00897     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">" Name            = %Z\n"</span>, <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a> );
00898 
00899     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length != 0 );
00900     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( Expression-&gt;Length != 0 );
00901 
00902     <span class="comment">//</span>
00903     <span class="comment">//  If one string is empty return FALSE.  If both are empty return TRUE.</span>
00904     <span class="comment">//</span>
00905 
00906     <span class="keywordflow">if</span> ( (<a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length == 0) || (Expression-&gt;Length == 0) ) {
00907 
00908         <span class="keywordflow">return</span> (BOOLEAN)(!(<a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length + Expression-&gt;Length));
00909     }
00910 
00911     <span class="comment">//</span>
00912     <span class="comment">//  Special case by far the most common wild card search of *</span>
00913     <span class="comment">//</span>
00914 
00915     <span class="keywordflow">if</span> ((Expression-&gt;Length == 1) &amp;&amp; (Expression-&gt;Buffer[0] == <span class="charliteral">'*'</span>)) {
00916 
00917         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00918     }
00919 
00920     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d1/d8/fsrtl_8h.html#a132">FsRtlDoesDbcsContainWildCards</a>( Expression ) );
00921 
00922     <span class="comment">//</span>
00923     <span class="comment">//  Also special case expressions of the form *X.  With this and the prior</span>
00924     <span class="comment">//  case we have covered virtually all normal queries.</span>
00925     <span class="comment">//</span>
00926 
00927     <span class="keywordflow">if</span> (Expression-&gt;Buffer[0] == <span class="charliteral">'*'</span>) {
00928 
00929         ANSI_STRING LocalExpression;
00930 
00931         LocalExpression = *Expression;
00932 
00933         LocalExpression.Buffer += 1;
00934         LocalExpression.Length -= 1;
00935 
00936         <span class="comment">//</span>
00937         <span class="comment">//  Only special case an expression with a single *</span>
00938         <span class="comment">//</span>
00939 
00940         <span class="keywordflow">if</span> ( !<a class="code" href="../../d1/d8/fsrtl_8h.html#a132">FsRtlDoesDbcsContainWildCards</a>( &amp;LocalExpression ) ) {
00941 
00942             ULONG StartingNameOffset;
00943 
00944             <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length &lt; (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(Expression-&gt;Length - 1)) {
00945 
00946                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00947             }
00948 
00949             StartingNameOffset = <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length - LocalExpression.Length;
00950 
00951             <span class="comment">//</span>
00952             <span class="comment">//  FsRtlIsDbcsInExpression(): bug fix "expression[0] == *" case</span>
00953             <span class="comment">//</span>
00954             <span class="comment">//  StatingNameOffset must not bisect DBCS characters.</span>
00955             <span class="comment">//</span>
00956 
00957             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d9/gen8dot3_8c.html#a5">NlsMbOemCodePageTag</a>) {
00958 
00959                 ULONG i = 0;
00960 
00961                 <span class="keywordflow">while</span> ( i &lt; StartingNameOffset ) {
00962 
00963                     i += <a class="code" href="../../d1/d8/fsrtl_8h.html#a36">FsRtlIsLeadDbcsCharacter</a>( <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Buffer[i] ) ? 2 : 1;
00964                 }
00965 
00966                 <span class="keywordflow">if</span> ( i &gt; StartingNameOffset ) {
00967 
00968                     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00969                 }
00970             }
00971 
00972             <span class="comment">//</span>
00973             <span class="comment">//  Do a simple memory compare if case sensitive, otherwise</span>
00974             <span class="comment">//  we have got to check this one character at a time.</span>
00975             <span class="comment">//</span>
00976 
00977             <span class="keywordflow">return</span> (BOOLEAN) RtlEqualMemory( LocalExpression.Buffer,
00978                                              <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Buffer + StartingNameOffset,
00979                                              LocalExpression.Length );
00980         }
00981     }
00982 
00983     <span class="comment">//</span>
00984     <span class="comment">//  Walk through the name string, picking off characters.  We go one</span>
00985     <span class="comment">//  character beyond the end because some wild cards are able to match</span>
00986     <span class="comment">//  zero characters beyond the end of the string.</span>
00987     <span class="comment">//</span>
00988     <span class="comment">//  With each new name character we determine a new set of states that</span>
00989     <span class="comment">//  match the name so far.  We use two arrays that we swap back and forth</span>
00990     <span class="comment">//  for this purpose.  One array lists the possible expression states for</span>
00991     <span class="comment">//  all name characters up to but not including the current one, and other</span>
00992     <span class="comment">//  array is used to build up the list of states considering the current</span>
00993     <span class="comment">//  name character as well.  The arrays are then switched and the process</span>
00994     <span class="comment">//  repeated.</span>
00995     <span class="comment">//</span>
00996     <span class="comment">//  There is not a one-to-one correspondence between state number and</span>
00997     <span class="comment">//  offset into the expression.  This is evident from the NFAs in the</span>
00998     <span class="comment">//  initial comment to this function.  State numbering is not continuous.</span>
00999     <span class="comment">//  This allows a simple conversion between state number and expression</span>
01000     <span class="comment">//  offset.  Each character in the expression can represent one or two</span>
01001     <span class="comment">//  states.  * and DOS_STAR generate two states: ExprOffset*2 and</span>
01002     <span class="comment">//  ExprOffset*2 + 1.  All other expreesion characters can produce only</span>
01003     <span class="comment">//  a single state.  Thus ExprOffset = State/2.</span>
01004     <span class="comment">//</span>
01005     <span class="comment">//</span>
01006     <span class="comment">//  Here is a short description of the variables involved:</span>
01007     <span class="comment">//</span>
01008     <span class="comment">//  NameOffset  - The offset of the current name char being processed.</span>
01009     <span class="comment">//</span>
01010     <span class="comment">//  ExprOffset  - The offset of the current expression char being processed.</span>
01011     <span class="comment">//</span>
01012     <span class="comment">//  SrcCount    - Prior match being investigated with current name char</span>
01013     <span class="comment">//</span>
01014     <span class="comment">//  DestCount   - Next location to put a matching assuming current name char</span>
01015     <span class="comment">//</span>
01016     <span class="comment">//  NameFinished - Allows one more itteration through the Matches array</span>
01017     <span class="comment">//                 after the name is exhusted (to come *s for example)</span>
01018     <span class="comment">//</span>
01019     <span class="comment">//  PreviousDestCount - This is used to prevent entry duplication, see coment</span>
01020     <span class="comment">//</span>
01021     <span class="comment">//  PreviousMatches   - Holds the previous set of matches (the Src array)</span>
01022     <span class="comment">//</span>
01023     <span class="comment">//  CurrentMatches    - Holds the current set of matches (the Dest array)</span>
01024     <span class="comment">//</span>
01025     <span class="comment">//  AuxBuffer, LocalBuffer - the storage for the Matches arrays</span>
01026     <span class="comment">//</span>
01027 
01028     <span class="comment">//</span>
01029     <span class="comment">//  Set up the initial variables</span>
01030     <span class="comment">//</span>
01031 
01032     PreviousMatches = &amp;LocalBuffer[0];
01033     CurrentMatches = &amp;LocalBuffer[<a class="code" href="../../d1/d3/dbcsname_8c.html#a4">MATCHES_ARRAY_SIZE</a>];
01034 
01035     PreviousMatches[0] = 0;
01036     MatchesCount = 1;
01037 
01038     NameOffset = 0;
01039 
01040     MaxState = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(Expression-&gt;Length * 2);
01041 
01042     <span class="keywordflow">while</span> ( !NameFinished ) {
01043 
01044         <span class="keywordflow">if</span> ( NameOffset &lt; <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length ) {
01045 
01046             <a class="code" href="../../d1/d3/dbcsname_8c.html#a3">GetDbcs</a>( <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Buffer, NameOffset, &amp;NameChar, &amp;Length );
01047             NameOffset += Length;
01048 
01049         } <span class="keywordflow">else</span> {
01050 
01051             NameFinished = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01052 
01053             <span class="comment">//</span>
01054             <span class="comment">//  if we have already exhasted the expression, cool.  Don't</span>
01055             <span class="comment">//  continue.</span>
01056             <span class="comment">//</span>
01057 
01058             <span class="keywordflow">if</span> ( PreviousMatches[MatchesCount-1] == MaxState ) {
01059 
01060                 <span class="keywordflow">break</span>;
01061             }
01062         }
01063 
01064 
01065         <span class="comment">//</span>
01066         <span class="comment">//  Now, for each of the previous stored expression matches, see what</span>
01067         <span class="comment">//  we can do with this name character.</span>
01068         <span class="comment">//</span>
01069 
01070         SrcCount = 0;
01071         DestCount = 0;
01072         PreviousDestCount = 0;
01073 
01074         <span class="keywordflow">while</span> ( SrcCount &lt; MatchesCount ) {
01075 
01076             <span class="comment">//</span>
01077             <span class="comment">//  We have to carry on our expression analysis as far as possible</span>
01078             <span class="comment">//  for each character of name, so we loop here until the</span>
01079             <span class="comment">//  expression stops matching.  A clue here is that expression</span>
01080             <span class="comment">//  cases that can match zero or more characters end with a</span>
01081             <span class="comment">//  continue, while those that can accept only a single character</span>
01082             <span class="comment">//  end with a break.</span>
01083             <span class="comment">//</span>
01084 
01085             ExprOffset = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)((PreviousMatches[SrcCount++] + 1) / 2);
01086 
01087             Length = 0;
01088 
01089 
01090             <span class="keywordflow">while</span> ( <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> ) {
01091 
01092                 <span class="keywordflow">if</span> ( ExprOffset == Expression-&gt;Length ) {
01093 
01094                     <span class="keywordflow">break</span>;
01095                 }
01096 
01097                 <span class="comment">//</span>
01098                 <span class="comment">//  The first time through the loop we don't want</span>
01099                 <span class="comment">//  to increment ExprOffset.</span>
01100                 <span class="comment">//</span>
01101 
01102                 ExprOffset += Length;
01103 
01104                 CurrentState = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(ExprOffset * 2);
01105 
01106                 <span class="keywordflow">if</span> ( ExprOffset == Expression-&gt;Length ) {
01107 
01108                     CurrentMatches[DestCount++] = MaxState;
01109                     <span class="keywordflow">break</span>;
01110                 }
01111 
01112                 <a class="code" href="../../d1/d3/dbcsname_8c.html#a3">GetDbcs</a>(Expression-&gt;Buffer, ExprOffset, &amp;ExprChar, &amp;Length);
01113 
01114                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( !((ExprChar &gt;= <span class="charliteral">'a'</span>) &amp;&amp; (ExprChar &lt;= <span class="charliteral">'z'</span>)) );
01115 
01116                 <span class="comment">//</span>
01117                 <span class="comment">//  Before we get started, we have to check for something</span>
01118                 <span class="comment">//  really gross.  We may be about to exhaust the local</span>
01119                 <span class="comment">//  space for ExpressionMatches[][], so we have to allocate</span>
01120                 <span class="comment">//  some pool if this is the case.  Yuk!</span>
01121                 <span class="comment">//</span>
01122 
01123                 <span class="keywordflow">if</span> ( (DestCount &gt;= <a class="code" href="../../d1/d3/dbcsname_8c.html#a4">MATCHES_ARRAY_SIZE</a> - 2) &amp;&amp;
01124                      (AuxBuffer == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) ) {
01125 
01126                     AuxBuffer = <a class="code" href="../../d3/d8/fsrtlp_8h.html#a2">FsRtlpAllocatePool</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>,
01127                                                     (Expression-&gt;Length+1) *
01128                                                     <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)*2*2 );
01129 
01130                     RtlCopyMemory( AuxBuffer,
01131                                    CurrentMatches,
01132                                    <a class="code" href="../../d1/d3/dbcsname_8c.html#a4">MATCHES_ARRAY_SIZE</a> * <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>) );
01133 
01134                     CurrentMatches = AuxBuffer;
01135 
01136                     RtlCopyMemory( AuxBuffer + (Expression-&gt;Length+1)*2,
01137                                    PreviousMatches,
01138                                    <a class="code" href="../../d1/d3/dbcsname_8c.html#a4">MATCHES_ARRAY_SIZE</a> * <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>) );
01139 
01140                     PreviousMatches = AuxBuffer + (Expression-&gt;Length+1)*2;
01141 
01142                 }
01143 
01144                 <span class="comment">//</span>
01145                 <span class="comment">//  * matches any character zero or more times.</span>
01146                 <span class="comment">//</span>
01147 
01148                 <span class="keywordflow">if</span> (ExprChar == <span class="charliteral">'*'</span>) {
01149 
01150                     CurrentMatches[DestCount++] = CurrentState;
01151                     CurrentMatches[DestCount++] = CurrentState + 1;
01152                     <span class="keywordflow">continue</span>;
01153                 }
01154 
01155                 <span class="comment">//</span>
01156                 <span class="comment">//  DOS_STAR matches any character except . zero or more times.</span>
01157                 <span class="comment">//</span>
01158 
01159                 <span class="keywordflow">if</span> (ExprChar == ANSI_DOS_STAR) {
01160 
01161                     BOOLEAN ICanEatADot = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01162 
01163                     <span class="comment">//</span>
01164                     <span class="comment">//  If we are at a period, determine if we are allowed to</span>
01165                     <span class="comment">//  consume it, ie. make sure it is not the last one.</span>
01166                     <span class="comment">//</span>
01167 
01168                     <span class="keywordflow">if</span> ( !NameFinished &amp;&amp; (NameChar == <span class="charliteral">'.'</span>) ) {
01169 
01170                         WCHAR NameChar;
01171                         <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>;
01172                         <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> Length;
01173 
01174                         <span class="keywordflow">for</span> ( <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> = NameOffset;
01175                               <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> &lt; <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length;
01176                               <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> += Length ) {
01177 
01178                             <a class="code" href="../../d1/d3/dbcsname_8c.html#a3">GetDbcs</a>( <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Buffer, <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>, &amp;NameChar, &amp;Length );
01179 
01180                             <span class="keywordflow">if</span> (NameChar == <span class="charliteral">'.'</span>) {
01181 
01182                                 ICanEatADot = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01183                                 <span class="keywordflow">break</span>;
01184                             }
01185                         }
01186                     }
01187 
01188                     <span class="keywordflow">if</span> (NameFinished || (NameChar != <span class="charliteral">'.'</span>) || ICanEatADot) {
01189 
01190                         CurrentMatches[DestCount++] = CurrentState;
01191                         CurrentMatches[DestCount++] = CurrentState + 1;
01192                         <span class="keywordflow">continue</span>;
01193 
01194                     } <span class="keywordflow">else</span> {
01195 
01196                         <span class="comment">//</span>
01197                         <span class="comment">//  We are at a period.  We can only match zero</span>
01198                         <span class="comment">//  characters (ie. the epsilon transition).</span>
01199                         <span class="comment">//</span>
01200 
01201                         CurrentMatches[DestCount++] = CurrentState + 1;
01202                         <span class="keywordflow">continue</span>;
01203                     }
01204                 }
01205 
01206                 <span class="comment">//</span>
01207                 <span class="comment">//  The following expreesion characters all match by consuming</span>
01208                 <span class="comment">//  a character, thus force the expression, and thus state</span>
01209                 <span class="comment">//  forward.</span>
01210                 <span class="comment">//</span>
01211 
01212                 CurrentState += (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(Length * 2);
01213 
01214                 <span class="comment">//</span>
01215                 <span class="comment">//  DOS_QM is the most complicated.  If the name is finished,</span>
01216                 <span class="comment">//  we can match zero characters.  If this name is a '.', we</span>
01217                 <span class="comment">//  don't match, but look at the next expression.  Otherwise</span>
01218                 <span class="comment">//  we match a single character.</span>
01219                 <span class="comment">//</span>
01220 
01221                 <span class="keywordflow">if</span> ( ExprChar == ANSI_DOS_QM ) {
01222 
01223                     <span class="keywordflow">if</span> ( NameFinished || (NameChar == <span class="charliteral">'.'</span>) ) {
01224 
01225                         <span class="keywordflow">continue</span>;
01226                     }
01227 
01228                     CurrentMatches[DestCount++] = CurrentState;
01229                     <span class="keywordflow">break</span>;
01230                 }
01231 
01232                 <span class="comment">//</span>
01233                 <span class="comment">//  A DOS_DOT can match either a period, or zero characters</span>
01234                 <span class="comment">//  beyond the end of name.</span>
01235                 <span class="comment">//</span>
01236 
01237                 <span class="keywordflow">if</span> (ExprChar == DOS_DOT) {
01238 
01239                     <span class="keywordflow">if</span> ( NameFinished ) {
01240 
01241                         <span class="keywordflow">continue</span>;
01242                     }
01243 
01244                     <span class="keywordflow">if</span> (NameChar == <span class="charliteral">'.'</span>) {
01245 
01246                         CurrentMatches[DestCount++] = CurrentState;
01247                         <span class="keywordflow">break</span>;
01248                     }
01249                 }
01250 
01251                 <span class="comment">//</span>
01252                 <span class="comment">//  From this point on a name character is required to even</span>
01253                 <span class="comment">//  continue, let alone make a match.</span>
01254                 <span class="comment">//</span>
01255 
01256                 <span class="keywordflow">if</span> ( NameFinished ) {
01257 
01258                     <span class="keywordflow">break</span>;
01259                 }
01260 
01261                 <span class="comment">//</span>
01262                 <span class="comment">//  If this expression was a '?' we can match it once.</span>
01263                 <span class="comment">//</span>
01264 
01265                 <span class="keywordflow">if</span> (ExprChar == <span class="charliteral">'?'</span>) {
01266 
01267                     CurrentMatches[DestCount++] = CurrentState;
01268                     <span class="keywordflow">break</span>;
01269                 }
01270 
01271                 <span class="comment">//</span>
01272                 <span class="comment">//  Finally, check if the expression char matches the name char</span>
01273                 <span class="comment">//</span>
01274 
01275                 <span class="keywordflow">if</span> (ExprChar == NameChar) {
01276 
01277                     CurrentMatches[DestCount++] = CurrentState;
01278                     <span class="keywordflow">break</span>;
01279                 }
01280 
01281                 <span class="comment">//</span>
01282                 <span class="comment">//  The expression didn't match so go look at the next</span>
01283                 <span class="comment">//  previous match.</span>
01284                 <span class="comment">//</span>
01285 
01286                 <span class="keywordflow">break</span>;
01287             }
01288 
01289 
01290             <span class="comment">//</span>
01291             <span class="comment">//  Prevent duplication in the destination array.</span>
01292             <span class="comment">//</span>
01293             <span class="comment">//  Each of the arrays is montonically increasing and non-</span>
01294             <span class="comment">//  duplicating, thus we skip over any source element in the src</span>
01295             <span class="comment">//  array if we just added the same element to the destination</span>
01296             <span class="comment">//  array.  This guarentees non-duplication in the dest. array.</span>
01297             <span class="comment">//</span>
01298 
01299             <span class="keywordflow">if</span> ((SrcCount &lt; MatchesCount) &amp;&amp;
01300                 (PreviousDestCount &lt; DestCount) ) {
01301 
01302                 <span class="keywordflow">while</span> (PreviousDestCount &lt; DestCount) {
01303 
01304                     <span class="keywordflow">while</span> ( PreviousMatches[SrcCount] &lt;
01305                          CurrentMatches[PreviousDestCount] ) {
01306 
01307 
01308                         SrcCount += 1;
01309                     }
01310 
01311                     PreviousDestCount += 1;
01312                 }
01313             }
01314         }
01315 
01316         <span class="comment">//</span>
01317         <span class="comment">//  If we found no matches in the just finished itteration, it's time</span>
01318         <span class="comment">//  to bail.</span>
01319         <span class="comment">//</span>
01320 
01321         <span class="keywordflow">if</span> ( DestCount == 0 ) {
01322 
01323 
01324             <span class="keywordflow">if</span> (AuxBuffer != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) { <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( AuxBuffer ); }
01325 
01326             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01327         }
01328 
01329         <span class="comment">//</span>
01330         <span class="comment">//  Swap the meaning the two arrays</span>
01331         <span class="comment">//</span>
01332 
01333         {
01334             <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> *Tmp;
01335 
01336             Tmp = PreviousMatches;
01337 
01338             PreviousMatches = CurrentMatches;
01339 
01340             CurrentMatches = Tmp;
01341         }
01342 
01343         MatchesCount = DestCount;
01344     }
01345 
01346 
01347     CurrentState = PreviousMatches[MatchesCount-1];
01348 
01349     <span class="keywordflow">if</span> (AuxBuffer != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) { <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( AuxBuffer ); }
01350 
01351 
01352     <span class="keywordflow">return</span> (BOOLEAN)(CurrentState == MaxState);
01353 }
01354 
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:39:38 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
