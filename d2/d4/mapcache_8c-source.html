<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: mapcache.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>mapcache.c</h1><a href="../../d1/d5/mapcache_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1990  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    mapcache.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module contains the routines which implement mapping views</span>
00012 <span class="comment">    of sections into the system-wide cache.</span>
00013 <span class="comment"></span>
00014 <span class="comment">Author:</span>
00015 <span class="comment"></span>
00016 <span class="comment">    Lou Perazzoli (loup) 22-May-1990</span>
00017 <span class="comment">    Landy Wang (landyw) 02-Jun-1997</span>
00018 <span class="comment"></span>
00019 <span class="comment">Revision History:</span>
00020 <span class="comment"></span>
00021 <span class="comment">--*/</span>
00022 
00023 
00024 <span class="preprocessor">#include "<a class="code" href="../../d4/d8/mi_8h.html">mi.h</a>"</span>
00025 
00026 <span class="preprocessor">#ifdef ALLOC_PRAGMA</span>
00027 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(INIT,MiInitializeSystemCache )</span>
00028 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00029 <span class="preprocessor"></span>
<a name="l00030"></a><a class="code" href="../../d1/d5/mapcache_8c.html#a1">00030</a> <span class="keyword">extern</span> ULONG <a class="code" href="../../d1/d5/mapcache_8c.html#a1">MmFrontOfList</a>;
00031 
00032 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00033 <a class="code" href="../../d8/d2/pagfault_8c.html#a30">MiFreeInPageSupportBlock</a> (
00034     IN <a class="code" href="../../d4/d2/struct__MMINPAGE__SUPPORT.html">PMMINPAGE_SUPPORT</a> Support
00035     );
00036 
00037 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00038 <a class="code" href="../../d3/d5/mapview_8c.html#a12">MiRemoveMappedPtes</a> (
00039     IN PVOID BaseAddress,
00040     IN ULONG NumberOfPtes,
00041     IN <a class="code" href="../../d8/d7/struct__CONTROL__AREA.html">PCONTROL_AREA</a> ControlArea,
00042     IN <a class="code" href="../../d3/d6/struct__MMSUPPORT.html">PMMSUPPORT</a> WorkingSetInfo
00043     );
00044 
<a name="l00045"></a><a class="code" href="../../d1/d5/mapcache_8c.html#a0">00045</a> <span class="preprocessor">#define X256K 0x40000</span>
00046 <span class="preprocessor"></span>
<a name="l00047"></a><a class="code" href="../../d1/d5/mapcache_8c.html#a2">00047</a> <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> <a class="code" href="../../d1/d5/mapcache_8c.html#a2">MmFirstFreeSystemCache</a>;
00048 
<a name="l00049"></a><a class="code" href="../../d1/d5/mapcache_8c.html#a3">00049</a> <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> <a class="code" href="../../d1/d5/mapcache_8c.html#a3">MmLastFreeSystemCache</a>;
00050 
<a name="l00051"></a><a class="code" href="../../d1/d5/mapcache_8c.html#a4">00051</a> <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> <a class="code" href="../../d1/d5/mapcache_8c.html#a4">MmFlushSystemCache</a>;
00052 
<a name="l00053"></a><a class="code" href="../../d1/d5/mapcache_8c.html#a5">00053</a> <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> <a class="code" href="../../d1/d5/mapcache_8c.html#a5">MmSystemCachePteBase</a>;
00054 
00055 
00056 LONG
00057 <a class="code" href="../../d8/d8/sysload_8c.html#a40">MiMapCacheExceptionFilter</a> (
00058     IN PNTSTATUS Status,
00059     IN PEXCEPTION_POINTERS ExceptionPointer
00060     );
00061 
00062 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00063"></a><a class="code" href="../../d1/d5/mapcache_8c.html#a9">00063</a> <a class="code" href="../../d1/d5/mapcache_8c.html#a9">MmMapViewInSystemCache</a> (
00064     IN PVOID SectionToMap,
00065     OUT PVOID *CapturedBase,
00066     IN OUT PLARGE_INTEGER SectionOffset,
00067     IN OUT PULONG CapturedViewSize
00068     )
00069 
00070 <span class="comment">/*++</span>
00071 <span class="comment"></span>
00072 <span class="comment">Routine Description:</span>
00073 <span class="comment"></span>
00074 <span class="comment">    This function maps a view in the specified subject process to</span>
00075 <span class="comment">    the section object.  The page protection is identical to that</span>
00076 <span class="comment">    of the prototype PTE.</span>
00077 <span class="comment"></span>
00078 <span class="comment">    This function is a kernel mode interface to allow LPC to map</span>
00079 <span class="comment">    a section given the section pointer to map.</span>
00080 <span class="comment"></span>
00081 <span class="comment">    This routine assumes all arguments have been probed and captured.</span>
00082 <span class="comment"></span>
00083 <span class="comment">Arguments:</span>
00084 <span class="comment"></span>
00085 <span class="comment">    SectionToMap - Supplies a pointer to the section object.</span>
00086 <span class="comment"></span>
00087 <span class="comment">    BaseAddress - Supplies a pointer to a variable that will receive</span>
00088 <span class="comment">         the base address of the view. If the initial value</span>
00089 <span class="comment">         of this argument is not null, then the view will</span>
00090 <span class="comment">         be allocated starting at the specified virtual</span>
00091 <span class="comment">         address rounded down to the next 64kb address</span>
00092 <span class="comment">         boundary. If the initial value of this argument is</span>
00093 <span class="comment">         null, then the operating system will determine</span>
00094 <span class="comment">         where to allocate the view using the information</span>
00095 <span class="comment">         specified by the ZeroBits argument value and the</span>
00096 <span class="comment">         section allocation attributes (i.e. based and</span>
00097 <span class="comment">         tiled).</span>
00098 <span class="comment"></span>
00099 <span class="comment">    SectionOffset - Supplies the offset from the beginning of the</span>
00100 <span class="comment">         section to the view in bytes. This value must be a multiple</span>
00101 <span class="comment">         of 256k.</span>
00102 <span class="comment"></span>
00103 <span class="comment">    ViewSize - Supplies a pointer to a variable that will receive</span>
00104 <span class="comment">         the actual size in bytes of the view.</span>
00105 <span class="comment">         The initial values of this argument specifies the</span>
00106 <span class="comment">         size of the view in bytes and is rounded up to the</span>
00107 <span class="comment">         next host page size boundary and must be less than or equal</span>
00108 <span class="comment">         to 256k.</span>
00109 <span class="comment"></span>
00110 <span class="comment">Return Value:</span>
00111 <span class="comment"></span>
00112 <span class="comment">    Returns the status</span>
00113 <span class="comment"></span>
00114 <span class="comment">    TBS</span>
00115 <span class="comment"></span>
00116 <span class="comment">Environment:</span>
00117 <span class="comment"></span>
00118 <span class="comment">    Kernel mode.</span>
00119 <span class="comment"></span>
00120 <span class="comment">--*/</span>
00121 
00122 {
00123     <a class="code" href="../../d5/d3/parseini_8c.html#a2">PSECTION</a> Section;
00124     ULONG PteOffset;
00125     KIRQL OldIrql;
00126     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
00127     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> LastPte;
00128     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> ProtoPte;
00129     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> LastProto;
00130     <a class="code" href="../../d1/d7/struct__SUBSECTION.html">PSUBSECTION</a> Subsection;
00131     PVOID EndingVa;
00132     <a class="code" href="../../d8/d7/struct__CONTROL__AREA.html">PCONTROL_AREA</a> ControlArea;
00133 
00134     Section = SectionToMap;
00135 
00136     <span class="comment">//</span>
00137     <span class="comment">// Assert the view size is less 256kb and the section offset</span>
00138     <span class="comment">// is aligned on a 256k boundary.</span>
00139     <span class="comment">//</span>
00140 
00141     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (*CapturedViewSize &lt;= 256<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>*1024<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>);
00142     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ((SectionOffset-&gt;LowPart &amp; (256<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>*1024<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a> - 1)) == 0);
00143 
00144     <span class="comment">//</span>
00145     <span class="comment">// Make sure the section is not an image section or a page file</span>
00146     <span class="comment">// backed section.</span>
00147     <span class="comment">//</span>
00148 
00149     <span class="keywordflow">if</span> (Section-&gt;u.Flags.Image) {
00150         <span class="keywordflow">return</span> STATUS_NOT_MAPPED_DATA;
00151     }
00152 
00153     ControlArea = Section-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o0">Segment</a>-&gt;<a class="code" href="../../d1/d1/struct__SEGMENT.html#o0">ControlArea</a>;
00154 
00155     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (*CapturedViewSize != 0);
00156 
00157     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (ControlArea-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o10">u</a>.Flags.GlobalOnlyPerSession == 0);
00158 
00159     Subsection = (<a class="code" href="../../d1/d7/struct__SUBSECTION.html">PSUBSECTION</a>)(ControlArea + 1);
00160 
00161     <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
00162 
00163     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (ControlArea-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o10">u</a>.Flags.BeingCreated == 0);
00164     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (ControlArea-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o10">u</a>.Flags.BeingDeleted == 0);
00165     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (ControlArea-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o10">u</a>.Flags.BeingPurged == 0);
00166 
00167     <span class="comment">//</span>
00168     <span class="comment">// Find a free 256k base in the cache.</span>
00169     <span class="comment">//</span>
00170 
00171     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d5/mapcache_8c.html#a2">MmFirstFreeSystemCache</a> == (<a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a>)<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a0">MM_EMPTY_LIST</a>) {
00172         <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
00173         <span class="keywordflow">return</span> STATUS_NO_MEMORY;
00174     }
00175 
00176     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d5/mapcache_8c.html#a2">MmFirstFreeSystemCache</a> == <a class="code" href="../../d1/d5/mapcache_8c.html#a4">MmFlushSystemCache</a>) {
00177 
00178         <span class="comment">//</span>
00179         <span class="comment">// All system cache PTEs have been used, flush the entire</span>
00180         <span class="comment">// TB to remove any stale TB entries.</span>
00181         <span class="comment">//</span>
00182 
00183         <a class="code" href="../../d0/d6/ppc_2flushtb_8c.html#a0">KeFlushEntireTb</a> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
00184         <a class="code" href="../../d1/d5/mapcache_8c.html#a4">MmFlushSystemCache</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00185     }
00186 
00187     PointerPte = <a class="code" href="../../d1/d5/mapcache_8c.html#a2">MmFirstFreeSystemCache</a>;
00188 
00189     <span class="comment">//</span>
00190     <span class="comment">// Update next free entry.</span>
00191     <span class="comment">//</span>
00192 
00193     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 0);
00194 
00195     <span class="keywordflow">if</span> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.List.NextEntry == <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a1">MM_EMPTY_PTE_LIST</a>) {
00196         <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a> (MEMORY_MANAGEMENT,
00197                       0x778,
00198                       (ULONG_PTR)PointerPte,
00199                       0,
00200                       0);
00201         <a class="code" href="../../d1/d5/mapcache_8c.html#a2">MmFirstFreeSystemCache</a> = (<a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a>)<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a0">MM_EMPTY_LIST</a>;
00202     }
00203     <span class="keywordflow">else</span> {
00204         <a class="code" href="../../d1/d5/mapcache_8c.html#a2">MmFirstFreeSystemCache</a> = <a class="code" href="../../d1/d5/mapcache_8c.html#a5">MmSystemCachePteBase</a> + PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.List.NextEntry;
00205         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (<a class="code" href="../../d1/d5/mapcache_8c.html#a2">MmFirstFreeSystemCache</a> &lt;= <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (<a class="code" href="../../d8/d5/kddata_8c.html#a12">MmSystemCacheEnd</a>));
00206     }
00207 
00208     <span class="comment">//</span>
00209     <span class="comment">// Increment the count of the number of views for the</span>
00210     <span class="comment">// section object.  This requires the PFN lock to be held.</span>
00211     <span class="comment">//</span>
00212 
00213     ControlArea-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o4">NumberOfMappedViews</a> += 1;
00214     ControlArea-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o14">NumberOfSystemCacheViews</a> += 1;
00215     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (ControlArea-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o2">NumberOfSectionReferences</a> != 0);
00216 
00217     <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
00218 
00219     *CapturedBase = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a> (PointerPte);
00220 
00221     EndingVa = (PVOID)(((ULONG_PTR)*CapturedBase +
00222                                 *CapturedViewSize - 1<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>) | (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>));
00223 
00224     <span class="comment">//</span>
00225     <span class="comment">// An unoccupied address range has been found, put the PTEs in</span>
00226     <span class="comment">// the range into prototype PTEs.</span>
00227     <span class="comment">//</span>
00228 
00229 <span class="preprocessor">#if DBG</span>
00230 <span class="preprocessor"></span>
00231     <span class="comment">//</span>
00232     <span class="comment">//  Zero out the next pointer field.</span>
00233     <span class="comment">//</span>
00234 
00235     PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.List.NextEntry = 0;
00236 <span class="preprocessor">#endif //DBG</span>
00237 <span class="preprocessor"></span>
00238     LastPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (EndingVa);
00239 
00240     <span class="comment">//</span>
00241     <span class="comment">// Calculate the first prototype PTE address.</span>
00242     <span class="comment">//</span>
00243 
00244     PteOffset = (ULONG)(SectionOffset-&gt;QuadPart &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
00245 
00246     <span class="comment">//</span>
00247     <span class="comment">// Make sure the PTEs are not in the extended part of the</span>
00248     <span class="comment">// segment.</span>
00249     <span class="comment">//</span>
00250 
00251     <span class="keywordflow">while</span> (PteOffset &gt;= Subsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o8">PtesInSubsection</a>) {
00252         PteOffset -= Subsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o8">PtesInSubsection</a>;
00253         Subsection = Subsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o9">NextSubsection</a>;
00254     }
00255 
00256     ProtoPte = &amp;Subsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o6">SubsectionBase</a>[PteOffset];
00257 
00258     LastProto = &amp;Subsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o6">SubsectionBase</a>[Subsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o8">PtesInSubsection</a>];
00259 
00260     <span class="keywordflow">while</span> (PointerPte &lt;= LastPte) {
00261 
00262         <span class="keywordflow">if</span> (ProtoPte &gt;= LastProto) {
00263 
00264             <span class="comment">//</span>
00265             <span class="comment">// Handle extended subsections.</span>
00266             <span class="comment">//</span>
00267 
00268             Subsection = Subsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o9">NextSubsection</a>;
00269             ProtoPte = Subsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o6">SubsectionBase</a>;
00270             LastProto = &amp;Subsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o6">SubsectionBase</a>[
00271                                         Subsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o8">PtesInSubsection</a>];
00272         }
00273         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long == <a class="code" href="../../d4/d2/datalpha_8c.html#a1">ZeroKernelPte</a>.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long);
00274         PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a146">MiProtoAddressForKernelPte</a> (ProtoPte);
00275 
00276         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (((ULONG_PTR)PointerPte &amp; (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a57">MM_COLOR_MASK</a> &lt;&lt; <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a52">PTE_SHIFT</a>)) ==
00277                  (((ULONG_PTR)ProtoPte  &amp; (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a57">MM_COLOR_MASK</a> &lt;&lt; <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a52">PTE_SHIFT</a>))));
00278 
00279         PointerPte += 1;
00280         ProtoPte += 1;
00281     }
00282 
00283     <span class="keywordflow">return</span> STATUS_SUCCESS;
00284 }
00285 
00286 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00287"></a><a class="code" href="../../d4/d8/mi_8h.html#a816">00287</a> <a class="code" href="../../d4/d8/mi_8h.html#a816">MiAddMappedPtes</a> (
00288     IN <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> FirstPte,
00289     IN ULONG NumberOfPtes,
00290     IN <a class="code" href="../../d8/d7/struct__CONTROL__AREA.html">PCONTROL_AREA</a> ControlArea
00291     )
00292 
00293 <span class="comment">/*++</span>
00294 <span class="comment"></span>
00295 <span class="comment">Routine Description:</span>
00296 <span class="comment"></span>
00297 <span class="comment">    This function maps a view in the current address space to the</span>
00298 <span class="comment">    specified control area.  The page protection is identical to that</span>
00299 <span class="comment">    of the prototype PTE.</span>
00300 <span class="comment"></span>
00301 <span class="comment">    This routine assumes the caller has called MiCheckPurgeAndUpMapCount,</span>
00302 <span class="comment">    hence the PFN lock is not needed here.</span>
00303 <span class="comment"></span>
00304 <span class="comment">Arguments:</span>
00305 <span class="comment"></span>
00306 <span class="comment">    FirstPte - Supplies a pointer to the first PTE of the current address</span>
00307 <span class="comment">               space to initialize.</span>
00308 <span class="comment"></span>
00309 <span class="comment">    NumberOfPtes - Supplies the number of PTEs to initialize.</span>
00310 <span class="comment"></span>
00311 <span class="comment">    ControlArea - Supplies the control area to point the PTEs at.</span>
00312 <span class="comment"></span>
00313 <span class="comment">Return Value:</span>
00314 <span class="comment"></span>
00315 <span class="comment">    None.</span>
00316 <span class="comment"></span>
00317 <span class="comment">Environment:</span>
00318 <span class="comment"></span>
00319 <span class="comment">    Kernel mode.</span>
00320 <span class="comment"></span>
00321 <span class="comment">--*/</span>
00322 
00323 {
00324     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
00325     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> ProtoPte;
00326     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> LastProto;
00327     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> LastPte;
00328     <a class="code" href="../../d1/d7/struct__SUBSECTION.html">PSUBSECTION</a> Subsection;
00329 
00330     <span class="keywordflow">if</span> (ControlArea-&gt;u.Flags.GlobalOnlyPerSession == 0) {
00331         Subsection = (<a class="code" href="../../d1/d7/struct__SUBSECTION.html">PSUBSECTION</a>)(ControlArea + 1);
00332     }
00333     <span class="keywordflow">else</span> {
00334         Subsection = (<a class="code" href="../../d1/d7/struct__SUBSECTION.html">PSUBSECTION</a>)((<a class="code" href="../../d6/d8/struct__LARGE__CONTROL__AREA.html">PLARGE_CONTROL_AREA</a>)ControlArea + 1);
00335     }
00336 
00337     PointerPte = FirstPte;
00338     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (NumberOfPtes != 0);
00339     LastPte = FirstPte + NumberOfPtes;
00340 
00341     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (ControlArea-&gt;NumberOfMappedViews &gt;= 1);
00342     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (ControlArea-&gt;NumberOfUserReferences &gt;= 1);
00343     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (ControlArea-&gt;u.Flags.HadUserReference == 1);
00344     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (ControlArea-&gt;NumberOfSectionReferences != 0);
00345 
00346     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (ControlArea-&gt;u.Flags.BeingCreated == 0);
00347     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (ControlArea-&gt;u.Flags.BeingDeleted == 0);
00348     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (ControlArea-&gt;u.Flags.BeingPurged == 0);
00349 
00350     ProtoPte = Subsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o6">SubsectionBase</a>;
00351 
00352     LastProto = &amp;Subsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o6">SubsectionBase</a>[Subsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o8">PtesInSubsection</a>];
00353 
00354     <span class="keywordflow">while</span> (PointerPte &lt; LastPte) {
00355 
00356         <span class="keywordflow">if</span> (ProtoPte &gt;= LastProto) {
00357 
00358             <span class="comment">//</span>
00359             <span class="comment">// Handle extended subsections.</span>
00360             <span class="comment">//</span>
00361 
00362             Subsection = Subsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o9">NextSubsection</a>;
00363             ProtoPte = Subsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o6">SubsectionBase</a>;
00364             LastProto = &amp;Subsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o6">SubsectionBase</a>[
00365                                         Subsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o8">PtesInSubsection</a>];
00366         }
00367         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long == <a class="code" href="../../d4/d2/datalpha_8c.html#a1">ZeroKernelPte</a>.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long);
00368         PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a146">MiProtoAddressForKernelPte</a> (ProtoPte);
00369 
00370         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (((ULONG_PTR)PointerPte &amp; (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a57">MM_COLOR_MASK</a> &lt;&lt; <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a52">PTE_SHIFT</a>)) ==
00371                  (((ULONG_PTR)ProtoPte  &amp; (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a57">MM_COLOR_MASK</a> &lt;&lt; <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a52">PTE_SHIFT</a>))));
00372 
00373         PointerPte += 1;
00374         ProtoPte += 1;
00375     }
00376 
00377     <span class="keywordflow">return</span>;
00378 }
00379 
00380 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00381"></a><a class="code" href="../../d1/d5/mapcache_8c.html#a11">00381</a> <a class="code" href="../../d1/d5/mapcache_8c.html#a11">MmUnmapViewInSystemCache</a> (
00382     IN PVOID BaseAddress,
00383     IN PVOID SectionToUnmap,
00384     IN ULONG AddToFront
00385     )
00386 
00387 <span class="comment">/*++</span>
00388 <span class="comment"></span>
00389 <span class="comment">Routine Description:</span>
00390 <span class="comment"></span>
00391 <span class="comment">    This function unmaps a view from the system cache.</span>
00392 <span class="comment"></span>
00393 <span class="comment">    NOTE: When this function is called, no pages may be locked in</span>
00394 <span class="comment">    the cache for the specified view.</span>
00395 <span class="comment"></span>
00396 <span class="comment">Arguments:</span>
00397 <span class="comment"></span>
00398 <span class="comment">    BaseAddress - Supplies the base address of the section in the</span>
00399 <span class="comment">                  system cache.</span>
00400 <span class="comment"></span>
00401 <span class="comment">    SectionToUnmap - Supplies a pointer to the section which the</span>
00402 <span class="comment">                     base address maps.</span>
00403 <span class="comment"></span>
00404 <span class="comment">    AddToFront - Supplies TRUE if the unmapped pages should be</span>
00405 <span class="comment">                 added to the front of the standby list (i.e., their</span>
00406 <span class="comment">                 value in the cache is low).  FALSE otherwise</span>
00407 <span class="comment"></span>
00408 <span class="comment">Return Value:</span>
00409 <span class="comment"></span>
00410 <span class="comment">    none.</span>
00411 <span class="comment"></span>
00412 <span class="comment">Environment:</span>
00413 <span class="comment"></span>
00414 <span class="comment">    Kernel mode.</span>
00415 <span class="comment"></span>
00416 <span class="comment">--*/</span>
00417 
00418 {
00419     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
00420     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn1;
00421     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> FirstPte;
00422     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> PteContents;
00423     KIRQL OldIrql;
00424     KIRQL OldIrqlWs;
00425     PFN_NUMBER i;
00426     <a class="code" href="../../d4/d8/mi_8h.html#a435">WSLE_NUMBER</a> WorkingSetIndex;
00427     <a class="code" href="../../d8/d7/struct__CONTROL__AREA.html">PCONTROL_AREA</a> ControlArea;
00428     ULONG WsHeld;
00429     PFN_NUMBER PdeFrameNumber;
00430 
00431     WsHeld = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00432 
00433     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (KeGetCurrentIrql() &lt;= <a class="code" href="../../d6/d7/halmips_8h.html#a52">APC_LEVEL</a>);
00434 
00435     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (BaseAddress);
00436     FirstPte = PointerPte;
00437     ControlArea = ((<a class="code" href="../../d5/d3/parseini_8c.html#a2">PSECTION</a>)SectionToUnmap)-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o0">Segment</a>-&gt;<a class="code" href="../../d1/d1/struct__SEGMENT.html#o0">ControlArea</a>;
00438     PdeFrameNumber = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a182">MI_GET_PAGE_FRAME_FROM_PTE</a> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (PointerPte));
00439 
00440     <span class="comment">//</span>
00441     <span class="comment">// Get the control area for the segment which is mapped here.</span>
00442     <span class="comment">//</span>
00443 
00444     i = 0;
00445 
00446     <span class="keywordflow">do</span> {
00447 
00448         <span class="comment">//</span>
00449         <span class="comment">// The cache is organized in chunks of 256k bytes, clear</span>
00450         <span class="comment">// the first chunk then check to see if this is the last</span>
00451         <span class="comment">// chunk.</span>
00452         <span class="comment">//</span>
00453 
00454         <span class="comment">//</span>
00455         <span class="comment">// The page table page is always resident for the system cache.</span>
00456         <span class="comment">// Check each PTE, it is in one of two states, either valid or</span>
00457         <span class="comment">// prototype PTE format.</span>
00458         <span class="comment">//</span>
00459 
00460         PteContents = *(<span class="keyword">volatile</span> <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> *)PointerPte;
00461         <span class="keywordflow">if</span> (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1) {
00462 
00463             <span class="keywordflow">if</span> (!WsHeld) {
00464                 WsHeld = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00465                 <a class="code" href="../../d4/d8/mi_8h.html#a144">LOCK_SYSTEM_WS</a> (OldIrqlWs);
00466                 <span class="keywordflow">continue</span>;
00467             }
00468 
00469             Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber);
00470 
00471             WorkingSetIndex = <a class="code" href="../../d7/d0/wstree_8c.html#a7">MiLocateWsle</a> (BaseAddress,
00472                                             <a class="code" href="../../d4/d8/mi_8h.html#a657">MmSystemCacheWorkingSetList</a>,
00473                                             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o5">u1</a>.WsIndex );
00474             <a class="code" href="../../d7/d0/wstree_8c.html#a8">MiRemoveWsle</a> (WorkingSetIndex,
00475                           <a class="code" href="../../d4/d8/mi_8h.html#a657">MmSystemCacheWorkingSetList</a> );
00476             <a class="code" href="../../d4/d0/wslist_8c.html#a24">MiReleaseWsle</a> (WorkingSetIndex, &amp;<a class="code" href="../../d6/d8/sysinfo_8c.html#a21">MmSystemCacheWs</a>);
00477 
00478             <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a109">MI_SET_PTE_IN_WORKING_SET</a> (PointerPte, 0);
00479 
00480             <span class="comment">//</span>
00481             <span class="comment">// The PTE is valid.</span>
00482             <span class="comment">//</span>
00483 
00484             <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
00485 
00486             <span class="comment">//</span>
00487             <span class="comment">// Capture the state of the modified bit for this PTE.</span>
00488             <span class="comment">//</span>
00489 
00490             <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a177">MI_CAPTURE_DIRTY_BIT_TO_PFN</a> (PointerPte, Pfn1);
00491 
00492             <span class="comment">//</span>
00493             <span class="comment">// Decrement the share and valid counts of the page table</span>
00494             <span class="comment">// page which maps this PTE.</span>
00495             <span class="comment">//</span>
00496 
00497             <a class="code" href="../../d4/d8/mi_8h.html#a242">MiDecrementShareAndValidCount</a> (PdeFrameNumber);
00498 
00499             <span class="comment">//</span>
00500             <span class="comment">// Decrement the share count for the physical page.</span>
00501             <span class="comment">//</span>
00502 
00503 <span class="preprocessor">#if DBG</span>
00504 <span class="preprocessor"></span>            <span class="keywordflow">if</span> (ControlArea-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o4">NumberOfMappedViews</a> == 1) {
00505                 <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn;
00506                 Pfn = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber);
00507                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount == 1);
00508             }
00509 <span class="preprocessor">#endif //DBG</span>
00510 <span class="preprocessor"></span>
00511 
00512             <a class="code" href="../../d1/d5/mapcache_8c.html#a1">MmFrontOfList</a> = AddToFront;
00513             <a class="code" href="../../d6/d5/pfndec_8c.html#a1">MiDecrementShareCount</a> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a182">MI_GET_PAGE_FRAME_FROM_PTE</a> (&amp;PteContents));
00514             <a class="code" href="../../d1/d5/mapcache_8c.html#a1">MmFrontOfList</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00515             <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
00516         } <span class="keywordflow">else</span> {
00517             <span class="keywordflow">if</span> (WsHeld) {
00518                 <a class="code" href="../../d4/d8/mi_8h.html#a145">UNLOCK_SYSTEM_WS</a> (OldIrqlWs);
00519                 WsHeld = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00520             }
00521 
00522             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ((PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long == <a class="code" href="../../d4/d2/datalpha_8c.html#a1">ZeroKernelPte</a>.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long) ||
00523                     (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Prototype == 1));
00524             NOTHING;
00525         }
00526         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a187">MI_WRITE_INVALID_PTE</a> (PointerPte, <a class="code" href="../../d4/d2/datalpha_8c.html#a1">ZeroKernelPte</a>);
00527 
00528         PointerPte += 1;
00529         BaseAddress = (PVOID)((PCHAR)BaseAddress + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
00530         i += 1;
00531     } <span class="keywordflow">while</span> (i &lt; (<a class="code" href="../../d1/d5/mapcache_8c.html#a0">X256K</a> / <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>));
00532 
00533     <span class="keywordflow">if</span> (WsHeld) {
00534         <a class="code" href="../../d4/d8/mi_8h.html#a145">UNLOCK_SYSTEM_WS</a> (OldIrqlWs);
00535     }
00536 
00537     FirstPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.List.NextEntry = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a1">MM_EMPTY_PTE_LIST</a>;
00538 
00539     <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
00540 
00541     <span class="comment">//</span>
00542     <span class="comment">// Free this entry to the end of the list.</span>
00543     <span class="comment">//</span>
00544 
00545     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d5/mapcache_8c.html#a4">MmFlushSystemCache</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00546 
00547         <span class="comment">//</span>
00548         <span class="comment">// If there is no entry marked to initiate a TB flush when</span>
00549         <span class="comment">// reused, mark this entry as the one.  This way the TB</span>
00550         <span class="comment">// only needs to be flushed when the list wraps.</span>
00551         <span class="comment">//</span>
00552 
00553         <a class="code" href="../../d1/d5/mapcache_8c.html#a4">MmFlushSystemCache</a> = FirstPte;
00554     }
00555 
00556     <a class="code" href="../../d1/d5/mapcache_8c.html#a3">MmLastFreeSystemCache</a>-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.List.NextEntry = FirstPte - <a class="code" href="../../d1/d5/mapcache_8c.html#a5">MmSystemCachePteBase</a>;
00557     <a class="code" href="../../d1/d5/mapcache_8c.html#a3">MmLastFreeSystemCache</a> = FirstPte;
00558 
00559     <span class="comment">//</span>
00560     <span class="comment">// Decrement the number of mapped views for the segment</span>
00561     <span class="comment">// and check to see if the segment should be deleted.</span>
00562     <span class="comment">//</span>
00563 
00564     ControlArea-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o4">NumberOfMappedViews</a> -= 1;
00565     ControlArea-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o14">NumberOfSystemCacheViews</a> -= 1;
00566 
00567     <span class="comment">//</span>
00568     <span class="comment">// Check to see if the control area (segment) should be deleted.</span>
00569     <span class="comment">// This routine releases the PFN lock.</span>
00570     <span class="comment">//</span>
00571 
00572     <a class="code" href="../../d5/d5/sectsup_8c.html#a24">MiCheckControlArea</a> (ControlArea, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, OldIrql);
00573 
00574     <span class="keywordflow">return</span>;
00575 }
00576 
00577 
00578 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00579"></a><a class="code" href="../../d1/d5/mapcache_8c.html#a7">00579</a> <a class="code" href="../../d3/d5/mapview_8c.html#a12">MiRemoveMappedPtes</a> (
00580     IN PVOID BaseAddress,
00581     IN ULONG NumberOfPtes,
00582     IN <a class="code" href="../../d8/d7/struct__CONTROL__AREA.html">PCONTROL_AREA</a> ControlArea,
00583     IN <a class="code" href="../../d3/d6/struct__MMSUPPORT.html">PMMSUPPORT</a> WorkingSetInfo
00584     )
00585 
00586 <span class="comment">/*++</span>
00587 <span class="comment"></span>
00588 <span class="comment">Routine Description:</span>
00589 <span class="comment"></span>
00590 <span class="comment">    This function unmaps a view from the system cache or a session space.</span>
00591 <span class="comment"></span>
00592 <span class="comment">    NOTE: When this function is called, no pages may be locked in</span>
00593 <span class="comment">    the cache (or session space) for the specified view.</span>
00594 <span class="comment"></span>
00595 <span class="comment">Arguments:</span>
00596 <span class="comment"></span>
00597 <span class="comment">    BaseAddress - Supplies the base address of the section in the</span>
00598 <span class="comment">                  system cache or session space.</span>
00599 <span class="comment"></span>
00600 <span class="comment">    NumberOfPtes - Supplies the number of PTEs to unmap.</span>
00601 <span class="comment"></span>
00602 <span class="comment">    ControlArea - Supplies the control area mapping the view.</span>
00603 <span class="comment"></span>
00604 <span class="comment">    WorkingSetInfo - Supplies the charged working set structures.</span>
00605 <span class="comment"></span>
00606 <span class="comment">Return Value:</span>
00607 <span class="comment"></span>
00608 <span class="comment">    None.</span>
00609 <span class="comment"></span>
00610 <span class="comment">Environment:</span>
00611 <span class="comment"></span>
00612 <span class="comment">    Kernel mode.</span>
00613 <span class="comment"></span>
00614 <span class="comment">--*/</span>
00615 
00616 {
00617     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
00618     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPde;
00619     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn1;
00620     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> FirstPte;
00621     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> PteContents;
00622     KIRQL OldIrql;
00623     KIRQL OldIrqlWs;
00624     ULONG WorkingSetIndex;
00625     ULONG DereferenceSegment;
00626     <a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html">MMPTE_FLUSH_LIST</a> PteFlushList;
00627     ULONG WsHeld;
00628 
00629     DereferenceSegment = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00630     WsHeld = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00631 
00632     PteFlushList.<a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html#o0">Count</a> = 0;
00633     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (BaseAddress);
00634     FirstPte = PointerPte;
00635 
00636     <span class="comment">//</span>
00637     <span class="comment">// Get the control area for the segment which is mapped here.</span>
00638     <span class="comment">//</span>
00639 
00640     <span class="keywordflow">while</span> (NumberOfPtes) {
00641 
00642         <span class="comment">//</span>
00643         <span class="comment">// The cache is organized in chunks of 256k bytes, clear</span>
00644         <span class="comment">// the first chunk, then check to see if this is the last</span>
00645         <span class="comment">// chunk.</span>
00646         <span class="comment">//</span>
00647 
00648         <span class="comment">//</span>
00649         <span class="comment">// The page table page is always resident for the system cache (and</span>
00650         <span class="comment">// for a session space map).</span>
00651         <span class="comment">//</span>
00652         <span class="comment">// Check each PTE, it is in one of two states, either valid or</span>
00653         <span class="comment">// prototype PTE format.</span>
00654         <span class="comment">//</span>
00655 
00656         PteContents = *PointerPte;
00657         <span class="keywordflow">if</span> (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1) {
00658 
00659             <span class="comment">//</span>
00660             <span class="comment">// The system cache is locked by us, all others are locked by</span>
00661             <span class="comment">// the caller.</span>
00662             <span class="comment">//</span>
00663 
00664             <span class="keywordflow">if</span> (WorkingSetInfo == &amp;<a class="code" href="../../d6/d8/sysinfo_8c.html#a21">MmSystemCacheWs</a>) {
00665                 <span class="keywordflow">if</span> (!WsHeld) {
00666                     WsHeld = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00667                     <a class="code" href="../../d4/d8/mi_8h.html#a144">LOCK_SYSTEM_WS</a> (OldIrqlWs);
00668                     <span class="keywordflow">continue</span>;
00669                 }
00670             }
00671 
00672             Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber);
00673 
00674             WorkingSetIndex = <a class="code" href="../../d7/d0/wstree_8c.html#a7">MiLocateWsle</a> (BaseAddress,
00675                                             WorkingSetInfo-&gt;VmWorkingSetList,
00676                                             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o5">u1</a>.WsIndex );
00677             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (WorkingSetIndex != <a class="code" href="../../d4/d8/mi_8h.html#a10">WSLE_NULL_INDEX</a>);
00678 
00679             <a class="code" href="../../d7/d0/wstree_8c.html#a8">MiRemoveWsle</a> (WorkingSetIndex,
00680                           WorkingSetInfo-&gt;VmWorkingSetList );
00681             <a class="code" href="../../d4/d0/wslist_8c.html#a24">MiReleaseWsle</a> (WorkingSetIndex, WorkingSetInfo);
00682 
00683             <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a109">MI_SET_PTE_IN_WORKING_SET</a> (PointerPte, 0);
00684 
00685             <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
00686 
00687             <span class="comment">//</span>
00688             <span class="comment">// The PTE is valid.</span>
00689             <span class="comment">//</span>
00690 
00691             <span class="comment">//</span>
00692             <span class="comment">// Capture the state of the modified bit for this PTE.</span>
00693             <span class="comment">//</span>
00694 
00695             <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a177">MI_CAPTURE_DIRTY_BIT_TO_PFN</a> (PointerPte, Pfn1);
00696 
00697             <span class="comment">//</span>
00698             <span class="comment">// Flush the TB for this page.</span>
00699             <span class="comment">//</span>
00700 
00701             <span class="keywordflow">if</span> (PteFlushList.<a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html#o0">Count</a> != <a class="code" href="../../d4/d8/mi_8h.html#a34">MM_MAXIMUM_FLUSH_COUNT</a>) {
00702                 PteFlushList.<a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html#o1">FlushPte</a>[PteFlushList.<a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html#o0">Count</a>] = PointerPte;
00703                 PteFlushList.<a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html#o2">FlushVa</a>[PteFlushList.<a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html#o0">Count</a>] = BaseAddress;
00704                 PteFlushList.<a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html#o0">Count</a> += 1;
00705             }
00706 
00707             PointerPde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (PointerPte);
00708 
00709 <span class="preprocessor">#if !defined (_WIN64)</span>
00710 <span class="preprocessor"></span>
00711             <span class="comment">//</span>
00712             <span class="comment">// The PDE must be carefully checked against the master table</span>
00713             <span class="comment">// because the PDEs are all zeroed in process creation.  If this</span>
00714             <span class="comment">// process has never faulted on any address in this range (all</span>
00715             <span class="comment">// references prior and above were filled directly by the TB as</span>
00716             <span class="comment">// the PTEs are global on non-Hydra), then the PDE reference</span>
00717             <span class="comment">// below to determine the page table frame will be zero.</span>
00718             <span class="comment">//</span>
00719             <span class="comment">// Note this cannot happen on NT64 as no master table is used.</span>
00720             <span class="comment">//</span>
00721 
00722             <span class="keywordflow">if</span> (PointerPde-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long == 0) {
00723 
00724                 <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> MasterPde;
00725 
00726                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (<a class="code" href="../../d4/d8/mi_8h.html#a581">MiHydra</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
00727 
00728 <span class="preprocessor">#if !defined (_X86PAE_)</span>
00729 <span class="preprocessor"></span>                MasterPde = &amp;<a class="code" href="../../d4/d8/mi_8h.html#a636">MmSystemPagePtes</a> [((ULONG_PTR)PointerPde &amp;
00730                              ((<span class="keyword">sizeof</span>(<a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a>) * <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a102">PDE_PER_PAGE</a>) - 1)) / <span class="keyword">sizeof</span>(<a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a>)];
00731 <span class="preprocessor">#else</span>
00732 <span class="preprocessor"></span>                MasterPde = &amp;<a class="code" href="../../d4/d8/mi_8h.html#a636">MmSystemPagePtes</a> [((ULONG_PTR)PointerPde &amp;
00733                              (PD_PER_SYSTEM * (<span class="keyword">sizeof</span>(<a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a>) * <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a102">PDE_PER_PAGE</a>) - 1)) / <span class="keyword">sizeof</span>(<a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a>)];
00734 <span class="preprocessor">#endif</span>
00735 <span class="preprocessor"></span>                <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (MasterPde-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1);
00736                 <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a186">MI_WRITE_VALID_PTE</a> (PointerPde, *MasterPde);
00737             }
00738 <span class="preprocessor">#endif</span>
00739 <span class="preprocessor"></span>
00740             <span class="comment">//</span>
00741             <span class="comment">// Decrement the share and valid counts of the page table</span>
00742             <span class="comment">// page which maps this PTE.</span>
00743             <span class="comment">//</span>
00744 
00745             <a class="code" href="../../d4/d8/mi_8h.html#a242">MiDecrementShareAndValidCount</a> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a182">MI_GET_PAGE_FRAME_FROM_PTE</a> (PointerPde));
00746 
00747             <span class="comment">//</span>
00748             <span class="comment">// Decrement the share count for the physical page.</span>
00749             <span class="comment">//</span>
00750 
00751             <a class="code" href="../../d6/d5/pfndec_8c.html#a1">MiDecrementShareCount</a> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a182">MI_GET_PAGE_FRAME_FROM_PTE</a> (&amp;PteContents));
00752             <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
00753 
00754         } <span class="keywordflow">else</span> {
00755             <span class="keywordflow">if</span> (WorkingSetInfo == &amp;<a class="code" href="../../d6/d8/sysinfo_8c.html#a21">MmSystemCacheWs</a>) {
00756                 <span class="keywordflow">if</span> (WsHeld) {
00757                     <a class="code" href="../../d4/d8/mi_8h.html#a145">UNLOCK_SYSTEM_WS</a> (OldIrqlWs);
00758                     WsHeld = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00759                 }
00760             }
00761 
00762             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ((PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long == <a class="code" href="../../d4/d2/datalpha_8c.html#a1">ZeroKernelPte</a>.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long) ||
00763                     (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Prototype == 1));
00764             NOTHING;
00765         }
00766         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a187">MI_WRITE_INVALID_PTE</a> (PointerPte, <a class="code" href="../../d4/d2/datalpha_8c.html#a1">ZeroKernelPte</a>);
00767 
00768         PointerPte += 1;
00769         BaseAddress = (PVOID)((PCHAR)BaseAddress + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
00770         NumberOfPtes -= 1;
00771     }
00772 
00773     <span class="keywordflow">if</span> (WorkingSetInfo == &amp;<a class="code" href="../../d6/d8/sysinfo_8c.html#a21">MmSystemCacheWs</a>) {
00774         <span class="keywordflow">if</span> (WsHeld) {
00775             <a class="code" href="../../d4/d8/mi_8h.html#a145">UNLOCK_SYSTEM_WS</a> (OldIrqlWs);
00776         }
00777     }
00778     <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
00779 
00780     <a class="code" href="../../d4/d8/mi_8h.html#a888">MiFlushPteList</a> (&amp;PteFlushList, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, <a class="code" href="../../d4/d2/datalpha_8c.html#a1">ZeroKernelPte</a>);
00781 
00782     <span class="keywordflow">if</span> (WorkingSetInfo != &amp;<a class="code" href="../../d6/d8/sysinfo_8c.html#a21">MmSystemCacheWs</a>) {
00783 
00784         <span class="comment">//</span>
00785         <span class="comment">// Session space has no ASN - flush the entire TB.</span>
00786         <span class="comment">//</span>
00787     
00788         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a200">MI_FLUSH_ENTIRE_SESSION_TB</a> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
00789     }
00790 
00791     <span class="comment">//</span>
00792     <span class="comment">// Decrement the number of user references as the caller upped them</span>
00793     <span class="comment">// via MiCheckPurgeAndUpMapCount when this was originally mapped.</span>
00794     <span class="comment">//</span>
00795 
00796     ControlArea-&gt;NumberOfUserReferences -= 1;
00797 
00798     <span class="comment">//</span>
00799     <span class="comment">// Decrement the number of mapped views for the segment</span>
00800     <span class="comment">// and check to see if the segment should be deleted.</span>
00801     <span class="comment">//</span>
00802 
00803     ControlArea-&gt;NumberOfMappedViews -= 1;
00804 
00805     <span class="comment">//</span>
00806     <span class="comment">// Check to see if the control area (segment) should be deleted.</span>
00807     <span class="comment">// This routine releases the PFN lock.</span>
00808     <span class="comment">//</span>
00809 
00810     <a class="code" href="../../d5/d5/sectsup_8c.html#a24">MiCheckControlArea</a> (ControlArea, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, OldIrql);
00811 }
00812 
00813 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00814"></a><a class="code" href="../../d4/d8/mi_8h.html#a910">00814</a> <a class="code" href="../../d4/d8/mi_8h.html#a910">MiInitializeSystemCache</a> (
00815     IN ULONG MinimumWorkingSet,
00816     IN ULONG MaximumWorkingSet
00817     )
00818 
00819 <span class="comment">/*++</span>
00820 <span class="comment"></span>
00821 <span class="comment">Routine Description:</span>
00822 <span class="comment"></span>
00823 <span class="comment">    This routine initializes the system cache working set and</span>
00824 <span class="comment">    data management structures.</span>
00825 <span class="comment"></span>
00826 <span class="comment">Arguments:</span>
00827 <span class="comment"></span>
00828 <span class="comment">    MinimumWorkingSet - Supplies the minimum working set for the system</span>
00829 <span class="comment">                        cache.</span>
00830 <span class="comment"></span>
00831 <span class="comment">    MaximumWorkingSet - Supplies the maximum working set size for the</span>
00832 <span class="comment">                        system cache.</span>
00833 <span class="comment"></span>
00834 <span class="comment">Return Value:</span>
00835 <span class="comment"></span>
00836 <span class="comment">    None.</span>
00837 <span class="comment"></span>
00838 <span class="comment">Environment:</span>
00839 <span class="comment"></span>
00840 <span class="comment">    Kernel mode, called only at phase 0 initialization.</span>
00841 <span class="comment"></span>
00842 <span class="comment">--*/</span>
00843 
00844 {
00845     ULONG SizeOfSystemCacheInPages;
00846     ULONG HunksOf256KInCache;
00847     <a class="code" href="../../d1/d8/struct__MMWSLE.html">PMMWSLE</a> WslEntry;
00848     ULONG NumberOfEntriesMapped;
00849     PFN_NUMBER i;
00850     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> PteContents;
00851     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
00852     KIRQL OldIrql;
00853 
00854     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (<a class="code" href="../../d4/d8/mi_8h.html#a657">MmSystemCacheWorkingSetList</a>);
00855 
00856     PteContents = <a class="code" href="../../d4/d2/datalpha_8c.html#a2">ValidKernelPte</a>;
00857 
00858     <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
00859 
00860     i = <a class="code" href="../../d7/d5/pfnlist_8c.html#a14">MiRemoveZeroPage</a>(<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a124">MI_GET_PAGE_COLOR_FROM_PTE</a> (PointerPte));
00861 
00862     PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber = i;
00863 
00864     <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a186">MI_WRITE_VALID_PTE</a> (PointerPte, PteContents);
00865 
00866     <a class="code" href="../../d8/d2/pagfault_8c.html#a22">MiInitializePfn</a> (i, PointerPte, 1<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>);
00867 
00868     <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
00869 
00870 <span class="preprocessor">#if defined (_WIN64)</span>
00871 <span class="preprocessor"></span>    <a class="code" href="../../d4/d8/mi_8h.html#a658">MmSystemCacheWsle</a> = (<a class="code" href="../../d1/d8/struct__MMWSLE.html">PMMWSLE</a>)(<a class="code" href="../../d4/d8/mi_8h.html#a657">MmSystemCacheWorkingSetList</a> + 1);
00872 <span class="preprocessor">#else</span>
00873 <span class="preprocessor"></span>    <a class="code" href="../../d4/d8/mi_8h.html#a658">MmSystemCacheWsle</a> =
00874             (<a class="code" href="../../d1/d8/struct__MMWSLE.html">PMMWSLE</a>)(&amp;<a class="code" href="../../d4/d8/mi_8h.html#a657">MmSystemCacheWorkingSetList</a>-&gt;<a class="code" href="../../d0/d8/struct__MMWSL.html#o16">UsedPageTableEntries</a>[0]);
00875 <span class="preprocessor">#endif</span>
00876 <span class="preprocessor"></span>
00877     <a class="code" href="../../d6/d8/sysinfo_8c.html#a21">MmSystemCacheWs</a>.<a class="code" href="../../d3/d6/struct__MMSUPPORT.html#o7">VmWorkingSetList</a> = <a class="code" href="../../d4/d8/mi_8h.html#a657">MmSystemCacheWorkingSetList</a>;
00878     <a class="code" href="../../d6/d8/sysinfo_8c.html#a21">MmSystemCacheWs</a>.<a class="code" href="../../d3/d6/struct__MMSUPPORT.html#o4">WorkingSetSize</a> = 0;
00879     <a class="code" href="../../d6/d8/sysinfo_8c.html#a21">MmSystemCacheWs</a>.<a class="code" href="../../d3/d6/struct__MMSUPPORT.html#o5">MinimumWorkingSetSize</a> = MinimumWorkingSet;
00880     <a class="code" href="../../d6/d8/sysinfo_8c.html#a21">MmSystemCacheWs</a>.<a class="code" href="../../d3/d6/struct__MMSUPPORT.html#o6">MaximumWorkingSetSize</a> = MaximumWorkingSet;
00881     InsertTailList (&amp;<a class="code" href="../../d4/d8/mi_8h.html#a710">MmWorkingSetExpansionHead</a>.<a class="code" href="../../d7/d7/struct__MMWORKING__SET__EXPANSION__HEAD.html#o0">ListHead</a>,
00882                     &amp;<a class="code" href="../../d6/d8/sysinfo_8c.html#a21">MmSystemCacheWs</a>.<a class="code" href="../../d3/d6/struct__MMSUPPORT.html#o8">WorkingSetExpansionLinks</a>);
00883 
00884     <a class="code" href="../../d6/d8/sysinfo_8c.html#a21">MmSystemCacheWs</a>.<a class="code" href="../../d3/d6/struct__MMSUPPORT.html#o9">AllowWorkingSetAdjustment</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00885 
00886     <span class="comment">//</span>
00887     <span class="comment">// Don't use entry 0 as an index of zero in the PFN database</span>
00888     <span class="comment">// means that the page can be assigned to a slot.  This is not</span>
00889     <span class="comment">// a problem for process working sets as page 0 is private.</span>
00890     <span class="comment">//</span>
00891 
00892     <a class="code" href="../../d4/d8/mi_8h.html#a657">MmSystemCacheWorkingSetList</a>-&gt;<a class="code" href="../../d0/d8/struct__MMWSL.html#o1">FirstFree</a> = 1;
00893     <a class="code" href="../../d4/d8/mi_8h.html#a657">MmSystemCacheWorkingSetList</a>-&gt;<a class="code" href="../../d0/d8/struct__MMWSL.html#o2">FirstDynamic</a> = 1;
00894     <a class="code" href="../../d4/d8/mi_8h.html#a657">MmSystemCacheWorkingSetList</a>-&gt;<a class="code" href="../../d0/d8/struct__MMWSL.html#o4">NextSlot</a> = 1;
00895     <a class="code" href="../../d4/d8/mi_8h.html#a657">MmSystemCacheWorkingSetList</a>-&gt;<a class="code" href="../../d0/d8/struct__MMWSL.html#o3">LastEntry</a> = (ULONG)<a class="code" href="../../d4/d8/mi_8h.html#a663">MmSystemCacheWsMinimum</a>;
00896     <a class="code" href="../../d4/d8/mi_8h.html#a657">MmSystemCacheWorkingSetList</a>-&gt;<a class="code" href="../../d0/d8/struct__MMWSL.html#o0">Quota</a> = <a class="code" href="../../d4/d8/mi_8h.html#a657">MmSystemCacheWorkingSetList</a>-&gt;<a class="code" href="../../d0/d8/struct__MMWSL.html#o3">LastEntry</a>;
00897     <a class="code" href="../../d4/d8/mi_8h.html#a657">MmSystemCacheWorkingSetList</a>-&gt;<a class="code" href="../../d0/d8/struct__MMWSL.html#o9">HashTable</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00898     <a class="code" href="../../d4/d8/mi_8h.html#a657">MmSystemCacheWorkingSetList</a>-&gt;<a class="code" href="../../d0/d8/struct__MMWSL.html#o10">HashTableSize</a> = 0;
00899     <a class="code" href="../../d4/d8/mi_8h.html#a657">MmSystemCacheWorkingSetList</a>-&gt;<a class="code" href="../../d0/d8/struct__MMWSL.html#o5">Wsle</a> = <a class="code" href="../../d4/d8/mi_8h.html#a658">MmSystemCacheWsle</a>;
00900 
00901     <a class="code" href="../../d4/d8/mi_8h.html#a657">MmSystemCacheWorkingSetList</a>-&gt;<a class="code" href="../../d0/d8/struct__MMWSL.html#o12">HashTableStart</a> = 
00902        (PVOID)((PCHAR)<a class="code" href="../../d2/d1/mm_8h.html#a7">PAGE_ALIGN</a> (&amp;<a class="code" href="../../d4/d8/mi_8h.html#a657">MmSystemCacheWorkingSetList</a>-&gt;<a class="code" href="../../d0/d8/struct__MMWSL.html#o5">Wsle</a>[<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a70">MM_MAXIMUM_WORKING_SET</a>]) + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
00903 
00904     <a class="code" href="../../d4/d8/mi_8h.html#a657">MmSystemCacheWorkingSetList</a>-&gt;<a class="code" href="../../d0/d8/struct__MMWSL.html#o13">HighestPermittedHashAddress</a> = (PVOID)(<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a12">MM_SYSTEM_CACHE_START</a>);
00905 
00906     NumberOfEntriesMapped = (ULONG)(((<a class="code" href="../../d1/d8/struct__MMWSLE.html">PMMWSLE</a>)((PCHAR)<a class="code" href="../../d4/d8/mi_8h.html#a657">MmSystemCacheWorkingSetList</a> +
00907                                 <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>)) - <a class="code" href="../../d4/d8/mi_8h.html#a658">MmSystemCacheWsle</a>);
00908 
00909     <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
00910 
00911     <span class="keywordflow">while</span> (NumberOfEntriesMapped &lt; <a class="code" href="../../d4/d8/mi_8h.html#a664">MmSystemCacheWsMaximum</a>) {
00912 
00913         PointerPte += 1;
00914         i = <a class="code" href="../../d7/d5/pfnlist_8c.html#a14">MiRemoveZeroPage</a>(<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a124">MI_GET_PAGE_COLOR_FROM_PTE</a> (PointerPte));
00915         PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber = i;
00916         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a186">MI_WRITE_VALID_PTE</a> (PointerPte, PteContents);
00917         <a class="code" href="../../d8/d2/pagfault_8c.html#a22">MiInitializePfn</a> (i, PointerPte, 1<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>);
00918         NumberOfEntriesMapped += <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> / <span class="keyword">sizeof</span>(<a class="code" href="../../d1/d8/struct__MMWSLE.html">MMWSLE</a>);
00919     }
00920 
00921     <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
00922 
00923     <span class="comment">//</span>
00924     <span class="comment">// Initialize the following slots as free.</span>
00925     <span class="comment">//</span>
00926 
00927     WslEntry = <a class="code" href="../../d4/d8/mi_8h.html#a658">MmSystemCacheWsle</a> + 1;
00928 
00929     <span class="keywordflow">for</span> (i = 1; i &lt; NumberOfEntriesMapped; i++) {
00930 
00931         <span class="comment">//</span>
00932         <span class="comment">// Build the free list, note that the first working</span>
00933         <span class="comment">// set entries (CurrentEntry) are not on the free list.</span>
00934         <span class="comment">// These entries are reserved for the pages which</span>
00935         <span class="comment">// map the working set and the page which contains the PDE.</span>
00936         <span class="comment">//</span>
00937 
00938         WslEntry-&gt;<a class="code" href="../../d1/d8/struct__MMWSLE.html#o3">u1</a>.Long = (i + 1) &lt;&lt; <a class="code" href="../../d4/d8/mi_8h.html#a9">MM_FREE_WSLE_SHIFT</a>;
00939         WslEntry += 1;
00940     }
00941 
00942     WslEntry -= 1;
00943     WslEntry-&gt;<a class="code" href="../../d1/d8/struct__MMWSLE.html#o3">u1</a>.Long = <a class="code" href="../../d4/d8/mi_8h.html#a10">WSLE_NULL_INDEX</a> &lt;&lt; <a class="code" href="../../d4/d8/mi_8h.html#a9">MM_FREE_WSLE_SHIFT</a>;  <span class="comment">// End of list.</span>
00944 
00945     <a class="code" href="../../d4/d8/mi_8h.html#a657">MmSystemCacheWorkingSetList</a>-&gt;<a class="code" href="../../d0/d8/struct__MMWSL.html#o7">LastInitializedWsle</a> = NumberOfEntriesMapped - 1;
00946 
00947     <span class="comment">//</span>
00948     <span class="comment">// Build a free list structure in the PTEs for the system cache.</span>
00949     <span class="comment">//</span>
00950 
00951     <a class="code" href="../../d1/d5/mapcache_8c.html#a5">MmSystemCachePteBase</a> = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a2">MI_PTE_BASE_FOR_LOWEST_KERNEL_ADDRESS</a>;
00952 
00953     SizeOfSystemCacheInPages = <a class="code" href="../../d2/d1/mm_8h.html#a9">COMPUTE_PAGES_SPANNED</a> (<a class="code" href="../../d8/d5/kddata_8c.html#a11">MmSystemCacheStart</a>,
00954                                 (PCHAR)<a class="code" href="../../d8/d5/kddata_8c.html#a12">MmSystemCacheEnd</a> - (PCHAR)<a class="code" href="../../d8/d5/kddata_8c.html#a11">MmSystemCacheStart</a> + 1);
00955 
00956     HunksOf256KInCache = SizeOfSystemCacheInPages / (<a class="code" href="../../d1/d5/mapcache_8c.html#a0">X256K</a> / <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
00957 
00958     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (<a class="code" href="../../d8/d5/kddata_8c.html#a11">MmSystemCacheStart</a>);
00959 
00960     <a class="code" href="../../d1/d5/mapcache_8c.html#a2">MmFirstFreeSystemCache</a> = PointerPte;
00961 
00962     <span class="keywordflow">for</span> (i = 0; i &lt; HunksOf256KInCache; i += 1) {
00963         PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.List.NextEntry = (PointerPte + (<a class="code" href="../../d1/d5/mapcache_8c.html#a0">X256K</a> / <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>)) - <a class="code" href="../../d1/d5/mapcache_8c.html#a5">MmSystemCachePteBase</a>;
00964         PointerPte += <a class="code" href="../../d1/d5/mapcache_8c.html#a0">X256K</a> / <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
00965     }
00966 
00967     PointerPte -= <a class="code" href="../../d1/d5/mapcache_8c.html#a0">X256K</a> / <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
00968 
00969 <span class="preprocessor">#if defined(_X86_)</span>
00970 <span class="preprocessor"></span>
00971     <span class="comment">//</span>
00972     <span class="comment">// Add any extended ranges.</span>
00973     <span class="comment">//</span>
00974 
00975     <span class="keywordflow">if</span> (<a class="code" href="../../d2/d2/data386_8c.html#a30">MiSystemCacheEndExtra</a> != <a class="code" href="../../d8/d5/kddata_8c.html#a12">MmSystemCacheEnd</a>) {
00976 
00977         SizeOfSystemCacheInPages = <a class="code" href="../../d2/d1/mm_8h.html#a9">COMPUTE_PAGES_SPANNED</a> (<a class="code" href="../../d2/d2/data386_8c.html#a29">MiSystemCacheStartExtra</a>,
00978                                     (PCHAR)<a class="code" href="../../d2/d2/data386_8c.html#a30">MiSystemCacheEndExtra</a> - (PCHAR)<a class="code" href="../../d2/d2/data386_8c.html#a29">MiSystemCacheStartExtra</a> + 1);
00979     
00980         HunksOf256KInCache = SizeOfSystemCacheInPages / (<a class="code" href="../../d1/d5/mapcache_8c.html#a0">X256K</a> / <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
00981     
00982         <span class="keywordflow">if</span> (HunksOf256KInCache) {
00983 
00984             <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPteExtended;
00985     
00986             PointerPteExtended = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (<a class="code" href="../../d2/d2/data386_8c.html#a29">MiSystemCacheStartExtra</a>);
00987             PointerPte-&gt;u.List.NextEntry = PointerPteExtended - <a class="code" href="../../d1/d5/mapcache_8c.html#a5">MmSystemCachePteBase</a>;
00988             PointerPte = PointerPteExtended;
00989 
00990             <span class="keywordflow">for</span> (i = 0; i &lt; HunksOf256KInCache; i += 1) {
00991                 PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.List.NextEntry = (PointerPte + (<a class="code" href="../../d1/d5/mapcache_8c.html#a0">X256K</a> / <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>)) - <a class="code" href="../../d1/d5/mapcache_8c.html#a5">MmSystemCachePteBase</a>;
00992                 PointerPte += <a class="code" href="../../d1/d5/mapcache_8c.html#a0">X256K</a> / <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
00993             }
00994     
00995             PointerPte -= <a class="code" href="../../d1/d5/mapcache_8c.html#a0">X256K</a> / <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
00996         }
00997     }
00998 <span class="preprocessor">#endif</span>
00999 <span class="preprocessor"></span>
01000     PointerPte-&gt;u.List.NextEntry = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a1">MM_EMPTY_PTE_LIST</a>;
01001     <a class="code" href="../../d1/d5/mapcache_8c.html#a3">MmLastFreeSystemCache</a> = PointerPte;
01002 
01003     <span class="keywordflow">if</span> (MaximumWorkingSet &gt; ((1536*1024) &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>)) {
01004 
01005         <span class="comment">//</span>
01006         <span class="comment">// The working set list consists of more than a single page.</span>
01007         <span class="comment">//</span>
01008 
01009         <a class="code" href="../../d4/d8/mi_8h.html#a144">LOCK_SYSTEM_WS</a> (OldIrql);
01010         <a class="code" href="../../d4/d0/wslist_8c.html#a33">MiGrowWsleHash</a> (&amp;<a class="code" href="../../d6/d8/sysinfo_8c.html#a21">MmSystemCacheWs</a>);
01011         <a class="code" href="../../d4/d8/mi_8h.html#a145">UNLOCK_SYSTEM_WS</a> (OldIrql);
01012     }
01013 }
01014 
01015 BOOLEAN
<a name="l01016"></a><a class="code" href="../../d1/d5/mapcache_8c.html#a13">01016</a> <a class="code" href="../../d1/d5/mapcache_8c.html#a13">MmCheckCachedPageState</a> (
01017     IN PVOID Address,
01018     IN BOOLEAN SetToZero
01019     )
01020 
01021 <span class="comment">/*++</span>
01022 <span class="comment"></span>
01023 <span class="comment">Routine Description:</span>
01024 <span class="comment"></span>
01025 <span class="comment">    This routine checks the state of the specified page that is mapped in</span>
01026 <span class="comment">    the system cache.  If the specified virtual address can be made valid</span>
01027 <span class="comment">    (i.e., the page is already in memory), it is made valid and the value</span>
01028 <span class="comment">    TRUE is returned.</span>
01029 <span class="comment"></span>
01030 <span class="comment">    If the page is not in memory, and SetToZero is FALSE, the</span>
01031 <span class="comment">    value FALSE is returned.  However, if SetToZero is TRUE, a page of</span>
01032 <span class="comment">    zeroes is materialized for the specified virtual address and the address</span>
01033 <span class="comment">    is made valid and the value TRUE is returned.</span>
01034 <span class="comment"></span>
01035 <span class="comment">    This routine is for usage by the cache manager.</span>
01036 <span class="comment"></span>
01037 <span class="comment">Arguments:</span>
01038 <span class="comment"></span>
01039 <span class="comment">    Address - Supplies the address of a page mapped in the system cache.</span>
01040 <span class="comment"></span>
01041 <span class="comment">    SetToZero - Supplies TRUE if a page of zeroes should be created in the</span>
01042 <span class="comment">                case where no page is already mapped.</span>
01043 <span class="comment"></span>
01044 <span class="comment">Return Value:</span>
01045 <span class="comment"></span>
01046 <span class="comment">    FALSE if there if touching this page would cause a page fault resulting</span>
01047 <span class="comment">          in a page read.</span>
01048 <span class="comment"></span>
01049 <span class="comment">    TRUE if there is a physical page in memory for this address.</span>
01050 <span class="comment"></span>
01051 <span class="comment">Environment:</span>
01052 <span class="comment"></span>
01053 <span class="comment">    Kernel mode.</span>
01054 <span class="comment"></span>
01055 <span class="comment">--*/</span>
01056 
01057 {
01058     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
01059     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPde;
01060     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> ProtoPte;
01061     PFN_NUMBER PageFrameIndex;
01062     <a class="code" href="../../d4/d8/mi_8h.html#a435">WSLE_NUMBER</a> WorkingSetIndex;
01063     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> TempPte;
01064     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> ProtoPteContents;
01065     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn1;
01066     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn2;
01067     KIRQL OldIrql;
01068     LOGICAL BarrierNeeded;
01069     ULONG BarrierStamp;
01070 
01071     BarrierNeeded = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01072 
01073     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (Address);
01074 
01075     <span class="comment">//</span>
01076     <span class="comment">// Make the PTE valid if possible.</span>
01077     <span class="comment">//</span>
01078 
01079     <span class="keywordflow">if</span> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1) {
01080         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01081     }
01082 
01083     <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
01084 
01085     <span class="keywordflow">if</span> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1) {
01086         <span class="keywordflow">goto</span> UnlockAndReturnTrue;
01087     }
01088 
01089     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Prototype == 1);
01090 
01091     ProtoPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a144">MiPteToProto</a> (PointerPte);
01092 
01093     <span class="comment">//</span>
01094     <span class="comment">// Pte is not valid, check the state of the prototype PTE.</span>
01095     <span class="comment">//</span>
01096 
01097     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d2/mmsup_8c.html#a11">MiMakeSystemAddressValidPfn</a> (ProtoPte)) {
01098 
01099         <span class="comment">//</span>
01100         <span class="comment">// If page fault occurred, recheck state of original PTE.</span>
01101         <span class="comment">//</span>
01102 
01103         <span class="keywordflow">if</span> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1) {
01104             <span class="keywordflow">goto</span> UnlockAndReturnTrue;
01105         }
01106     }
01107 
01108     ProtoPteContents = *ProtoPte;
01109 
01110     <span class="keywordflow">if</span> (ProtoPteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1) {
01111 
01112         PageFrameIndex = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a182">MI_GET_PAGE_FRAME_FROM_PTE</a> (&amp;ProtoPteContents);
01113         Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PageFrameIndex);
01114 
01115         <span class="comment">//</span>
01116         <span class="comment">// The prototype PTE is valid, make the cache PTE</span>
01117         <span class="comment">// valid and add it to the working set.</span>
01118         <span class="comment">//</span>
01119 
01120         TempPte = ProtoPteContents;
01121 
01122     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((ProtoPteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Transition == 1) &amp;&amp;
01123                (ProtoPteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Prototype == 0)) {
01124 
01125         <span class="comment">//</span>
01126         <span class="comment">// Prototype PTE is in the transition state.  Remove the page</span>
01127         <span class="comment">// from the page list and make it valid.</span>
01128         <span class="comment">//</span>
01129 
01130         PageFrameIndex = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a183">MI_GET_PAGE_FRAME_FROM_TRANSITION_PTE</a> (&amp;ProtoPteContents);
01131         Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PageFrameIndex);
01132         <span class="keywordflow">if</span> ((Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.ReadInProgress) ||
01133             (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.InPageError)) {
01134 
01135             <span class="comment">//</span>
01136             <span class="comment">// Collided page fault, return.</span>
01137             <span class="comment">//</span>
01138 
01139             <span class="keywordflow">goto</span> UnlockAndReturnTrue;
01140         }
01141 
01142         <a class="code" href="../../d7/d5/pfnlist_8c.html#a11">MiUnlinkPageFromList</a> (Pfn1);
01143 
01144         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount += 1;
01145         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PageLocation = <a class="code" href="../../d2/d1/mm_8h.html#a345a177">ActiveAndValid</a>;
01146 
01147         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a105">MI_MAKE_VALID_PTE</a> (TempPte,
01148                            PageFrameIndex,
01149                            Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o16">OriginalPte</a>.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Protection,
01150                            <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
01151 
01152         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a186">MI_WRITE_VALID_PTE</a> (ProtoPte, TempPte);
01153 
01154         <span class="comment">//</span>
01155         <span class="comment">// Increment the valid PTE count for the page containing</span>
01156         <span class="comment">// the prototype PTE.</span>
01157         <span class="comment">//</span>
01158 
01159         Pfn2 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o17">PteFrame</a>);
01160 
01161     } <span class="keywordflow">else</span> {
01162 
01163         <span class="comment">//</span>
01164         <span class="comment">// Page is not in memory, if a page of zeroes is requested,</span>
01165         <span class="comment">// get a page of zeroes and make it valid.</span>
01166         <span class="comment">//</span>
01167 
01168         <span class="keywordflow">if</span> ((SetToZero == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) || (<a class="code" href="../../d5/d5/cc_8h.html#a94">MmAvailablePages</a> &lt; 8)) {
01169             <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
01170 
01171             <span class="comment">//</span>
01172             <span class="comment">// Fault the page into memory.</span>
01173             <span class="comment">//</span>
01174 
01175             <a class="code" href="../../d4/d1/mmfault_8c.html#a2">MmAccessFault</a> (<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, Address, <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>, (PVOID)0);
01176             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01177         }
01178 
01179         <span class="comment">//</span>
01180         <span class="comment">// Increment the count of Pfn references for the control area</span>
01181         <span class="comment">// corresponding to this file.</span>
01182         <span class="comment">//</span>
01183 
01184         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a148">MiGetSubsectionAddress</a> (
01185                     ProtoPte)-&gt;ControlArea-&gt;NumberOfPfnReferences += 1;
01186 
01187         PageFrameIndex = <a class="code" href="../../d7/d5/pfnlist_8c.html#a14">MiRemoveZeroPage</a>(<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a124">MI_GET_PAGE_COLOR_FROM_PTE</a> (ProtoPte));
01188 
01189         Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PageFrameIndex);
01190 
01191         <span class="comment">//</span>
01192         <span class="comment">// This barrier check is needed after zeroing the page and</span>
01193         <span class="comment">// before setting the PTE (not the prototype PTE) valid.</span>
01194         <span class="comment">// Capture it now, check it at the last possible moment.</span>
01195         <span class="comment">//</span>
01196 
01197         BarrierNeeded = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01198         BarrierStamp = (ULONG)Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o17">PteFrame</a>;
01199 
01200         <a class="code" href="../../d8/d2/pagfault_8c.html#a22">MiInitializePfn</a> (PageFrameIndex, ProtoPte, 1);
01201         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount = 0;
01202         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PrototypePte = 1;
01203 
01204         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a105">MI_MAKE_VALID_PTE</a> (TempPte,
01205                            PageFrameIndex,
01206                            Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o16">OriginalPte</a>.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Protection,
01207                            <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
01208 
01209         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a186">MI_WRITE_VALID_PTE</a> (ProtoPte, TempPte);
01210     }
01211 
01212     <span class="comment">//</span>
01213     <span class="comment">// Increment the share count since the page is being put into a working</span>
01214     <span class="comment">// set.</span>
01215     <span class="comment">//</span>
01216 
01217     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount += 1;
01218 
01219     <span class="keywordflow">if</span> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o5">u1</a>.Event == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01220         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o5">u1</a>.Event = (PVOID)<a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
01221     }
01222 
01223     <span class="comment">//</span>
01224     <span class="comment">// Increment the reference count of the page table</span>
01225     <span class="comment">// page for this PTE.</span>
01226     <span class="comment">//</span>
01227 
01228     PointerPde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (PointerPte);
01229     Pfn2 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PointerPde-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber);
01230 
01231     Pfn2-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount += 1;
01232 
01233     <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a116">MI_SET_GLOBAL_STATE</a> (TempPte, 1);
01234 
01235 <span class="preprocessor">#if defined (_WIN64)</span>
01236 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a136">MI_DETERMINE_OWNER</a> (PointerPte) == 0) {
01237         TempPte.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long &amp;= ~<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a79">MM_PTE_OWNER_MASK</a>;
01238     }
01239 <span class="preprocessor">#else</span>
01240 <span class="preprocessor"></span>    TempPte.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Owner = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a136">MI_DETERMINE_OWNER</a> (PointerPte);
01241 <span class="preprocessor">#endif</span>
01242 <span class="preprocessor"></span>
01243     <span class="keywordflow">if</span> (BarrierNeeded) {
01244         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a197">MI_BARRIER_SYNCHRONIZE</a> (BarrierStamp);
01245     }
01246 
01247     <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a186">MI_WRITE_VALID_PTE</a> (PointerPte, TempPte);
01248 
01249     <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
01250 
01251     <a class="code" href="../../d4/d8/mi_8h.html#a144">LOCK_SYSTEM_WS</a> (OldIrql);
01252 
01253     WorkingSetIndex = <a class="code" href="../../d4/d0/wslist_8c.html#a21">MiLocateAndReserveWsle</a> (&amp;<a class="code" href="../../d6/d8/sysinfo_8c.html#a21">MmSystemCacheWs</a>);
01254 
01255     <a class="code" href="../../d4/d0/wslist_8c.html#a25">MiUpdateWsle</a> (&amp;WorkingSetIndex,
01256                   <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a> (PointerPte),
01257                   <a class="code" href="../../d4/d8/mi_8h.html#a657">MmSystemCacheWorkingSetList</a>,
01258                   Pfn1);
01259 
01260     <a class="code" href="../../d4/d8/mi_8h.html#a658">MmSystemCacheWsle</a>[WorkingSetIndex].<a class="code" href="../../d1/d8/struct__MMWSLE.html#o3">u1</a>.e1.SameProtectAsProto = 1;
01261 
01262     <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a109">MI_SET_PTE_IN_WORKING_SET</a> (PointerPte, WorkingSetIndex);
01263 
01264     <a class="code" href="../../d4/d8/mi_8h.html#a145">UNLOCK_SYSTEM_WS</a> (OldIrql);
01265 
01266     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01267 
01268 UnlockAndReturnTrue:
01269     <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
01270     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01271 }
01272 
01273 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l01274"></a><a class="code" href="../../d1/d5/mapcache_8c.html#a14">01274</a> <a class="code" href="../../d1/d5/mapcache_8c.html#a14">MmCopyToCachedPage</a> (
01275     IN PVOID Address,
01276     IN PVOID UserBuffer,
01277     IN ULONG Offset,
01278     IN SIZE_T CountInBytes,
01279     IN BOOLEAN DontZero
01280     )
01281 
01282 <span class="comment">/*++</span>
01283 <span class="comment"></span>
01284 <span class="comment">Routine Description:</span>
01285 <span class="comment"></span>
01286 <span class="comment">    This routine checks the state of the specified page that is mapped in</span>
01287 <span class="comment">    the system cache.  If the specified virtual address can be made valid</span>
01288 <span class="comment">    (i.e., the page is already in memory), it is made valid and the value</span>
01289 <span class="comment">    TRUE is returned.</span>
01290 <span class="comment"></span>
01291 <span class="comment">    If the page is not in memory, and SetToZero is FALSE, the</span>
01292 <span class="comment">    value FALSE is returned.  However, if SetToZero is TRUE, a page of</span>
01293 <span class="comment">    zeroes is materialized for the specified virtual address and the address</span>
01294 <span class="comment">    is made valid and the value TRUE is returned.</span>
01295 <span class="comment"></span>
01296 <span class="comment">    This routine is for usage by the cache manager.</span>
01297 <span class="comment"></span>
01298 <span class="comment">Arguments:</span>
01299 <span class="comment"></span>
01300 <span class="comment">    Address - Supplies the address of a page mapped in the system cache.</span>
01301 <span class="comment">              This MUST be a page aligned address!</span>
01302 <span class="comment"></span>
01303 <span class="comment">    UserBuffer - Supplies the address of a user buffer to copy into the</span>
01304 <span class="comment">                 system cache at the specified address + offset.</span>
01305 <span class="comment"></span>
01306 <span class="comment">    Offset - Supplies the offset into the UserBuffer to copy the data.</span>
01307 <span class="comment"></span>
01308 <span class="comment">    CountInBytes - Supplies the byte count to copy from the user buffer.</span>
01309 <span class="comment"></span>
01310 <span class="comment">    DontZero - Supplies TRUE if the buffer should not be zeroed (the</span>
01311 <span class="comment">               caller will track zeroing).  FALSE if it should be zeroed.</span>
01312 <span class="comment"></span>
01313 <span class="comment">Return Value:</span>
01314 <span class="comment"></span>
01315 <span class="comment">    Returns the status of the copy.</span>
01316 <span class="comment"></span>
01317 <span class="comment">Environment:</span>
01318 <span class="comment"></span>
01319 <span class="comment">    Kernel mode, &lt;= APC_LEVEL.</span>
01320 <span class="comment"></span>
01321 <span class="comment">--*/</span>
01322 
01323 {
01324     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
01325     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPde;
01326     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> ProtoPte;
01327     PFN_NUMBER PageFrameIndex;
01328     <a class="code" href="../../d4/d8/mi_8h.html#a435">WSLE_NUMBER</a> WorkingSetIndex;
01329     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> TempPte;
01330     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> ProtoPteContents;
01331     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn1;
01332     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn2;
01333     KIRQL OldIrql;
01334     ULONG TransitionState;
01335     ULONG AddToWorkingSet;
01336     LOGICAL ShareCountUpped;
01337     SIZE_T EndFill;
01338     PVOID <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>;
01339     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
01340     <a class="code" href="../../d4/d2/struct__MMINPAGE__SUPPORT.html">PMMINPAGE_SUPPORT</a> <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>;
01341     <a class="code" href="../../d8/d7/struct__CONTROL__AREA.html">PCONTROL_AREA</a> ControlArea;
01342     <a class="code" href="../../d5/d6/struct__ETHREAD.html">PETHREAD</a> Thread;
01343     ULONG SavedState;
01344     LOGICAL ApcsExplicitlyBlocked;
01345     LOGICAL ApcNeeded;
01346 
01347     TransitionState = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01348     AddToWorkingSet = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01349     ApcsExplicitlyBlocked = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01350     ApcNeeded = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01351 
01352     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (((ULONG_PTR)Address &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1)) == 0);
01353     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ((CountInBytes + <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>) &lt;= <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
01354     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (KeGetCurrentIrql() &lt; <a class="code" href="../../d6/d7/halmips_8h.html#a53">DISPATCH_LEVEL</a>);
01355 
01356     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (Address);
01357 
01358     <span class="keywordflow">if</span> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1) {
01359         <span class="keywordflow">goto</span> <a class="code" href="../../d9/d0/cmdata_8h.html#a104a97">Copy</a>;
01360     }
01361 
01362     <span class="comment">//</span>
01363     <span class="comment">// Touch the user's buffer to make it resident.  This is required in</span>
01364     <span class="comment">// order to safely detect the case where both the system and user</span>
01365     <span class="comment">// address are pointing at the same physical page.  This case causes</span>
01366     <span class="comment">// a deadlock during the RtlCopyBytes if the inpage support block needed</span>
01367     <span class="comment">// to be allocated and the PTE for the user page is not valid.  This</span>
01368     <span class="comment">// potential deadlock is resolved because if the user page causes a</span>
01369     <span class="comment">// collided fault, the initiator thread is checked for.  If they are</span>
01370     <span class="comment">// the same, then an exception is thrown by the pager.</span>
01371     <span class="comment">//</span>
01372 
01373     <span class="keywordflow">try</span> {
01374 
01375         *(<span class="keyword">volatile</span> <a class="code" href="../../d1/d1/bench_8c.html#a16">CHAR</a> *)UserBuffer;
01376 
01377     } except (<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
01378         <span class="keywordflow">return</span> GetExceptionCode();
01379     }
01380 
01381     <span class="comment">//</span>
01382     <span class="comment">// Make the PTE valid if possible.</span>
01383     <span class="comment">//</span>
01384 
01385     <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
01386 
01387 Recheck:
01388 
01389     <span class="keywordflow">if</span> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1) {
01390         <span class="keywordflow">goto</span> UnlockAndCopy;
01391     }
01392 
01393     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Prototype == 1);
01394 
01395     ProtoPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a144">MiPteToProto</a> (PointerPte);
01396 
01397     <span class="comment">//</span>
01398     <span class="comment">// Pte is not valid, check the state of the prototype PTE.</span>
01399     <span class="comment">//</span>
01400 
01401     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d2/mmsup_8c.html#a11">MiMakeSystemAddressValidPfn</a> (ProtoPte)) {
01402 
01403         <span class="comment">//</span>
01404         <span class="comment">// If page fault occurred, recheck state of original PTE.</span>
01405         <span class="comment">//</span>
01406 
01407         <span class="keywordflow">if</span> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1) {
01408             <span class="keywordflow">goto</span> UnlockAndCopy;
01409         }
01410     }
01411 
01412     ShareCountUpped = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01413     ProtoPteContents = *ProtoPte;
01414 
01415     <span class="keywordflow">if</span> (ProtoPteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1) {
01416 
01417         PageFrameIndex = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a182">MI_GET_PAGE_FRAME_FROM_PTE</a> (&amp;ProtoPteContents);
01418         Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PageFrameIndex);
01419 
01420         <span class="comment">//</span>
01421         <span class="comment">// Increment the share count so the prototype PTE will remain</span>
01422         <span class="comment">// valid until this can be added into the system's working set.</span>
01423         <span class="comment">//</span>
01424 
01425         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount += 1;
01426         ShareCountUpped = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01427 
01428         <span class="comment">//</span>
01429         <span class="comment">// The prototype PTE is valid, make the cache PTE</span>
01430         <span class="comment">// valid and add it to the working set.</span>
01431         <span class="comment">//</span>
01432 
01433         TempPte = ProtoPteContents;
01434 
01435     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((ProtoPteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Transition == 1) &amp;&amp;
01436                (ProtoPteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Prototype == 0)) {
01437 
01438         <span class="comment">//</span>
01439         <span class="comment">// Prototype PTE is in the transition state.  Remove the page</span>
01440         <span class="comment">// from the page list and make it valid.</span>
01441         <span class="comment">//</span>
01442 
01443         PageFrameIndex = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a183">MI_GET_PAGE_FRAME_FROM_TRANSITION_PTE</a> (&amp;ProtoPteContents);
01444         Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PageFrameIndex);
01445         <span class="keywordflow">if</span> ((Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.ReadInProgress) ||
01446             (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.InPageError)) {
01447 
01448             <span class="comment">//</span>
01449             <span class="comment">// Collided page fault or in page error, try the copy</span>
01450             <span class="comment">// operation incurring a page fault.</span>
01451             <span class="comment">//</span>
01452 
01453             <span class="keywordflow">goto</span> UnlockAndCopy;
01454         }
01455 
01456         <a class="code" href="../../d7/d5/pfnlist_8c.html#a11">MiUnlinkPageFromList</a> (Pfn1);
01457 
01458         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount += 1;
01459         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PageLocation = <a class="code" href="../../d2/d1/mm_8h.html#a345a177">ActiveAndValid</a>;
01460         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.Modified = 1;
01461         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount == 0);
01462         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount += 1;
01463         ShareCountUpped = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01464 
01465         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a105">MI_MAKE_VALID_PTE</a> (TempPte,
01466                            PageFrameIndex,
01467                            Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o16">OriginalPte</a>.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Protection,
01468                            <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
01469         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a112">MI_SET_PTE_DIRTY</a> (TempPte);
01470 
01471         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a186">MI_WRITE_VALID_PTE</a> (ProtoPte, TempPte);
01472 
01473         <span class="comment">//</span>
01474         <span class="comment">// Increment the valid pte count for the page containing</span>
01475         <span class="comment">// the prototype PTE.</span>
01476         <span class="comment">//</span>
01477 
01478     } <span class="keywordflow">else</span> {
01479 
01480         <span class="comment">//</span>
01481         <span class="comment">// Page is not in memory, if a page of zeroes is requested,</span>
01482         <span class="comment">// get a page of zeroes and make it valid.</span>
01483         <span class="comment">//</span>
01484 
01485         <span class="keywordflow">if</span> (<a class="code" href="../../d7/d5/pfnlist_8c.html#a13">MiEnsureAvailablePageOrWait</a> (<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
01486 
01487             <span class="comment">//</span>
01488             <span class="comment">// A wait operation occurred which could have changed the</span>
01489             <span class="comment">// state of the PTE.  Recheck the PTE state.</span>
01490             <span class="comment">//</span>
01491 
01492             <span class="keywordflow">goto</span> Recheck;
01493         }
01494 
01495         <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a> = <a class="code" href="../../d8/d2/pagfault_8c.html#a29">MiGetInPageSupportBlock</a> ();
01496         <span class="keywordflow">if</span> (<a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01497             <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
01498             <a class="code" href="../../d1/d7/wait_8c.html#a2">KeDelayExecutionThread</a> (<a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, (PLARGE_INTEGER)&amp;<a class="code" href="../../d4/d8/mi_8h.html#a420">MmShortTime</a>);
01499             <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
01500             <span class="keywordflow">goto</span> Recheck;
01501         }
01502 
01503         <span class="comment">//</span>
01504         <span class="comment">// Increment the count of Pfn references for the control area</span>
01505         <span class="comment">// corresponding to this file.</span>
01506         <span class="comment">//</span>
01507 
01508         ControlArea = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a148">MiGetSubsectionAddress</a> (ProtoPte)-&gt;ControlArea;
01509         ControlArea-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o3">NumberOfPfnReferences</a> += 1;
01510         <span class="keywordflow">if</span> (ControlArea-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o7">NumberOfUserReferences</a> &gt; 0) {
01511 
01512             <span class="comment">//</span>
01513             <span class="comment">// There is a user reference to this file, always zero ahead.</span>
01514             <span class="comment">//</span>
01515 
01516             DontZero = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01517         }
01518 
01519         <span class="comment">//</span>
01520         <span class="comment">// Remove any page from the list and turn it into a transition</span>
01521         <span class="comment">// page in the cache with read in progress set.  This causes</span>
01522         <span class="comment">// any other references to this page to block on the specified</span>
01523         <span class="comment">// event while the copy operation to the cache is on-going.</span>
01524         <span class="comment">//</span>
01525 
01526         PageFrameIndex = <a class="code" href="../../d7/d5/pfnlist_8c.html#a15">MiRemoveAnyPage</a>(<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a124">MI_GET_PAGE_COLOR_FROM_PTE</a> (ProtoPte));
01527 
01528         Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PageFrameIndex);
01529 
01530         <span class="comment">//</span>
01531         <span class="comment">// Increment the valid PTE count for the page containing</span>
01532         <span class="comment">// the prototype PTE.</span>
01533         <span class="comment">//</span>
01534 
01535         <a class="code" href="../../d8/d2/pagfault_8c.html#a24">MiInitializeTransitionPfn</a> (PageFrameIndex, ProtoPte, 0xFFFFFFFF);
01536 
01537         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount = 0;
01538 
01539         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount = 0;     <span class="comment">// for the add_locked_page macro</span>
01540         <a class="code" href="../../d4/d8/mi_8h.html#a187">MI_ADD_LOCKED_PAGE_CHARGE_FOR_MODIFIED_PAGE</a> (Pfn1, 24);
01541 
01542         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount = 1;
01543         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PrototypePte = 1;
01544         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.Modified = 1;
01545         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.ReadInProgress = 1;
01546         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o5">u1</a>.Event = &amp;<a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>-&gt;Event;
01547         <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>-&gt;Pfn = Pfn1;
01548 
01549         <span class="comment">//</span>
01550         <span class="comment">// This is needed in case a special kernel APC fires that ends up</span>
01551         <span class="comment">// referencing the same page (this may even be through a different</span>
01552         <span class="comment">// virtual address from the user/system one here).</span>
01553         <span class="comment">//</span>
01554 
01555         Thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a> ();
01556         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Thread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o2">NestedFaultCount</a> &lt;= 1);
01557         Thread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o2">NestedFaultCount</a> += 1;
01558 
01559         TransitionState = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01560 
01561         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a105">MI_MAKE_VALID_PTE</a> (TempPte,
01562                            PageFrameIndex,
01563                            Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o16">OriginalPte</a>.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Protection,
01564                            <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
01565         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a112">MI_SET_PTE_DIRTY</a> (TempPte);
01566 
01567         <span class="comment">//</span>
01568         <span class="comment">// APCs must be explicitly disabled to prevent suspend APCs from</span>
01569         <span class="comment">// interrupting this thread before the RtlCopyBytes completes.</span>
01570         <span class="comment">// Otherwise this page can remain in transition indefinitely (until</span>
01571         <span class="comment">// the suspend APC is released) which blocks any other threads that</span>
01572         <span class="comment">// may reference it.</span>
01573         <span class="comment">//</span>
01574 
01575         <a class="code" href="../../d4/d9/ke_8h.html#a28">KeEnterCriticalRegion</a>();
01576         ApcsExplicitlyBlocked = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01577     }
01578 
01579     <span class="comment">//</span>
01580     <span class="comment">// Increment the share count of the page table page for this PTE.</span>
01581     <span class="comment">//</span>
01582 
01583     PointerPde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (PointerPte);
01584     Pfn2 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PointerPde-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber);
01585 
01586     Pfn2-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount += 1;
01587 
01588     <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a116">MI_SET_GLOBAL_STATE</a> (TempPte, 1);
01589 <span class="preprocessor">#if defined (_WIN64)</span>
01590 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a136">MI_DETERMINE_OWNER</a> (PointerPte) == 0) {
01591         TempPte.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long &amp;= ~<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a79">MM_PTE_OWNER_MASK</a>;
01592     }
01593 <span class="preprocessor">#else</span>
01594 <span class="preprocessor"></span>    TempPte.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Owner = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a136">MI_DETERMINE_OWNER</a> (PointerPte);
01595 <span class="preprocessor">#endif</span>
01596 <span class="preprocessor"></span>    <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a186">MI_WRITE_VALID_PTE</a> (PointerPte, TempPte);
01597 
01598     AddToWorkingSet = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01599 
01600 UnlockAndCopy:
01601 
01602     <span class="comment">//</span>
01603     <span class="comment">// Unlock the PFN database and perform the copy.</span>
01604     <span class="comment">//</span>
01605 
01606     <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
01607 
01608 <a class="code" href="../../d9/d0/cmdata_8h.html#a104a97">Copy</a>:
01609 
01610     Thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a> ();
01611     <a class="code" href="../../d2/d1/mm_8h.html#a19">MmSavePageFaultReadAhead</a>( Thread, &amp;SavedState );
01612     <a class="code" href="../../d2/d1/mm_8h.html#a20">MmSetPageFaultReadAhead</a>( Thread, 0 );
01613     status = STATUS_SUCCESS;
01614 
01615     <span class="comment">//</span>
01616     <span class="comment">// Copy the user buffer into the cache under an exception handler.</span>
01617     <span class="comment">//</span>
01618 
01619     <span class="keywordflow">try</span> {
01620 
01621         <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> = (PVOID)((PCHAR)Address + <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>);
01622         RtlCopyBytes (<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>, UserBuffer, CountInBytes);
01623 
01624         <span class="keywordflow">if</span> (TransitionState) {
01625 
01626             <span class="comment">//</span>
01627             <span class="comment">// Only zero the memory outside the range if a page was taken</span>
01628             <span class="comment">// from the free list.</span>
01629             <span class="comment">//</span>
01630 
01631             <span class="keywordflow">if</span> (<a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> != 0) {
01632                 RtlZeroMemory (Address, <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>);
01633             }
01634 
01635             <span class="keywordflow">if</span> (DontZero == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01636                 EndFill = <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - (<a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> + CountInBytes);
01637 
01638                 <span class="keywordflow">if</span> (EndFill != 0) {
01639                     <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> = (PVOID)((PCHAR)<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> + CountInBytes);
01640                     RtlZeroMemory (<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>, EndFill);
01641                 }
01642             }
01643         }
01644     } except (<a class="code" href="../../d1/d5/mapcache_8c.html#a8">MiMapCacheExceptionFilter</a> (&amp;status, GetExceptionInformation())) {
01645 
01646         <span class="keywordflow">if</span> (status == STATUS_MULTIPLE_FAULT_VIOLATION) {
01647             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (TransitionState == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
01648         }
01649 
01650         <span class="comment">//</span>
01651         <span class="comment">// Zero out the page if it came from the free list.</span>
01652         <span class="comment">//</span>
01653 
01654         <span class="keywordflow">if</span> (TransitionState) {
01655             RtlZeroMemory (Address, <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
01656         }
01657     }
01658 
01659     <a class="code" href="../../d2/d1/mm_8h.html#a21">MmResetPageFaultReadAhead</a>(Thread, SavedState);
01660 
01661     <span class="keywordflow">if</span> (AddToWorkingSet) {
01662 
01663         <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
01664 
01665         <span class="keywordflow">if</span> (ApcsExplicitlyBlocked == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
01666             <a class="code" href="../../d4/d9/ke_8h.html#a29">KeLeaveCriticalRegion</a>();
01667         }
01668 
01669         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount != 0);
01670         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a> == ProtoPte);
01671 
01672         <span class="keywordflow">if</span> (TransitionState) {
01673 
01674             <span class="comment">//</span>
01675             <span class="comment">// This is a newly allocated page.</span>
01676             <span class="comment">//</span>
01677 
01678             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (ShareCountUpped == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
01679             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount &lt;= 1);
01680             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o5">u1</a>.Event == &amp;<a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>-&gt;Event);
01681 
01682             <a class="code" href="../../d0/d2/mmsup_8c.html#a11">MiMakeSystemAddressValidPfn</a> (ProtoPte);
01683             <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a116">MI_SET_GLOBAL_STATE</a> (TempPte, 0);
01684             <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a186">MI_WRITE_VALID_PTE</a> (ProtoPte, TempPte);
01685             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o5">u1</a>.Event = (PVOID)<a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
01686             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount != 0);
01687             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o17">PteFrame</a> != <a class="code" href="../../d4/d8/mi_8h.html#a170">MI_MAGIC_AWE_PTEFRAME</a>);
01688 
01689             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (<a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>-&gt;Completed == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
01690             <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>-&gt;Completed = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01691 
01692             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount == 0);
01693             <a class="code" href="../../d4/d8/mi_8h.html#a189">MI_REMOVE_LOCKED_PAGE_CHARGE</a>(Pfn1, 41);
01694             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PageLocation = <a class="code" href="../../d2/d1/mm_8h.html#a345a177">ActiveAndValid</a>;
01695 
01696             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.ReadInProgress == 1);
01697             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.ReadInProgress = 0;
01698 
01699             <span class="comment">//</span>
01700             <span class="comment">// Increment the share count since the page is</span>
01701             <span class="comment">// being put into a working set.</span>
01702             <span class="comment">//</span>
01703 
01704             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount += 1;
01705 
01706             <span class="keywordflow">if</span> (<a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>-&gt;WaitCount != 1) {
01707                 <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>-&gt;IoStatus.Status = STATUS_SUCCESS;
01708                 <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>-&gt;IoStatus.Information = 0;
01709                 <a class="code" href="../../d2/d8/eventobj_8c.html#a8">KeSetEvent</a> (&amp;<a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>-&gt;Event, 0, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
01710             }
01711 
01712             <a class="code" href="../../d8/d2/pagfault_8c.html#a30">MiFreeInPageSupportBlock</a> (<a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>);
01713             <span class="keywordflow">if</span> (DontZero != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01714                 <a class="code" href="../../d4/d8/mi_8h.html#a186">MI_ADD_LOCKED_PAGE_CHARGE</a>(Pfn1, 40);
01715                 Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount += 1;
01716                 status = STATUS_CACHE_PAGE_LOCKED;
01717             }
01718 
01719             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Thread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o2">NestedFaultCount</a> &lt;= 3);
01720             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Thread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o2">NestedFaultCount</a> != 0);
01721     
01722             Thread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o2">NestedFaultCount</a> -= 1;
01723 
01724             <span class="keywordflow">if</span> ((Thread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o3">ApcNeeded</a> == 1) &amp;&amp; (Thread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o2">NestedFaultCount</a> == 0)) {
01725                 ApcNeeded = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01726                 Thread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o3">ApcNeeded</a> = 0;
01727             }
01728 
01729         } <span class="keywordflow">else</span> {
01730 
01731             <span class="comment">//</span>
01732             <span class="comment">// This is either a frame that was originally on the transition list</span>
01733             <span class="comment">// or was already valid when this routine began execution.  Either</span>
01734             <span class="comment">// way, the share count (and therefore the systemwide locked pages</span>
01735             <span class="comment">// count) has been dealt with.</span>
01736             <span class="comment">//</span>
01737 
01738             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (ShareCountUpped == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
01739 
01740             <span class="keywordflow">if</span> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o5">u1</a>.Event == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01741                 Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o5">u1</a>.Event = (PVOID)<a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
01742             }
01743         }
01744 
01745         <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
01746 
01747         <a class="code" href="../../d4/d8/mi_8h.html#a144">LOCK_SYSTEM_WS</a> (OldIrql);
01748 
01749         WorkingSetIndex = <a class="code" href="../../d4/d0/wslist_8c.html#a21">MiLocateAndReserveWsle</a> (&amp;<a class="code" href="../../d6/d8/sysinfo_8c.html#a21">MmSystemCacheWs</a>);
01750 
01751         <a class="code" href="../../d4/d0/wslist_8c.html#a25">MiUpdateWsle</a> (&amp;WorkingSetIndex,
01752                       <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a> (PointerPte),
01753                       <a class="code" href="../../d4/d8/mi_8h.html#a657">MmSystemCacheWorkingSetList</a>,
01754                       Pfn1);
01755 
01756         <a class="code" href="../../d4/d8/mi_8h.html#a658">MmSystemCacheWsle</a>[WorkingSetIndex].<a class="code" href="../../d1/d8/struct__MMWSLE.html#o3">u1</a>.e1.SameProtectAsProto = 1;
01757 
01758         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a109">MI_SET_PTE_IN_WORKING_SET</a> (PointerPte, WorkingSetIndex);
01759     
01760         <a class="code" href="../../d4/d8/mi_8h.html#a145">UNLOCK_SYSTEM_WS</a> (OldIrql);
01761 
01762         <span class="keywordflow">if</span> (ApcNeeded == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
01763             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (OldIrql &lt; <a class="code" href="../../d6/d7/halmips_8h.html#a52">APC_LEVEL</a>);
01764             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Thread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o2">NestedFaultCount</a> == 0);
01765             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Thread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o3">ApcNeeded</a> == 0);
01766             <a class="code" href="../../d9/d5/verifier_8c.html#a116">KeRaiseIrql</a> (<a class="code" href="../../d6/d7/halmips_8h.html#a52">APC_LEVEL</a>, &amp;OldIrql);
01767             <a class="code" href="../../d4/d6/iosubs_8c.html#a136">IoRetryIrpCompletions</a> ();
01768             <a class="code" href="../../d9/d5/verifier_8c.html#a117">KeLowerIrql</a> (OldIrql);
01769         }
01770     }
01771     <span class="keywordflow">else</span> {
01772         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (ApcsExplicitlyBlocked == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
01773     }
01774 
01775     <span class="keywordflow">return</span> status;
01776 }
01777 
01778 LONG
<a name="l01779"></a><a class="code" href="../../d1/d5/mapcache_8c.html#a8">01779</a> <a class="code" href="../../d8/d8/sysload_8c.html#a40">MiMapCacheExceptionFilter</a> (
01780     IN PNTSTATUS Status,
01781     IN PEXCEPTION_POINTERS ExceptionPointer
01782     )
01783 
01784 <span class="comment">/*++</span>
01785 <span class="comment"></span>
01786 <span class="comment">Routine Description:</span>
01787 <span class="comment"></span>
01788 <span class="comment">    This routine is a filter for exceptions during copying data</span>
01789 <span class="comment">    from the user buffer to the system cache.  It stores the</span>
01790 <span class="comment">    status code from the exception record into the status argument.</span>
01791 <span class="comment">    In the case of an in page i/o error it returns the actual</span>
01792 <span class="comment">    error code and in the case of an access violation it returns</span>
01793 <span class="comment">    STATUS_INVALID_USER_BUFFER.</span>
01794 <span class="comment"></span>
01795 <span class="comment">Arguments:</span>
01796 <span class="comment"></span>
01797 <span class="comment">    Status - Returns the status from the exception record.</span>
01798 <span class="comment"></span>
01799 <span class="comment">    ExceptionCode - Supplies the exception code to being checked.</span>
01800 <span class="comment"></span>
01801 <span class="comment">Return Value:</span>
01802 <span class="comment"></span>
01803 <span class="comment">    ULONG - returns EXCEPTION_EXECUTE_HANDLER</span>
01804 <span class="comment"></span>
01805 <span class="comment">--*/</span>
01806 
01807 {
01808     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> local;
01809 
01810     local = ExceptionPointer-&gt;ExceptionRecord-&gt;ExceptionCode;
01811 
01812     <span class="comment">//</span>
01813     <span class="comment">// If the exception is STATUS_IN_PAGE_ERROR, get the I/O error code</span>
01814     <span class="comment">// from the exception record.</span>
01815     <span class="comment">//</span>
01816 
01817     <span class="keywordflow">if</span> (local == STATUS_IN_PAGE_ERROR) {
01818         <span class="keywordflow">if</span> (ExceptionPointer-&gt;ExceptionRecord-&gt;NumberParameters &gt;= 3) {
01819             local = (<a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>)ExceptionPointer-&gt;ExceptionRecord-&gt;ExceptionInformation[2];
01820         }
01821     }
01822 
01823     <span class="keywordflow">if</span> (local == STATUS_ACCESS_VIOLATION) {
01824         local = STATUS_INVALID_USER_BUFFER;
01825     }
01826 
01827     *<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = local;
01828     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>;
01829 }
01830 
01831 
01832 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01833"></a><a class="code" href="../../d1/d5/mapcache_8c.html#a15">01833</a> <a class="code" href="../../d1/d5/mapcache_8c.html#a15">MmUnlockCachedPage</a> (
01834     IN PVOID AddressInCache
01835     )
01836 
01837 <span class="comment">/*++</span>
01838 <span class="comment"></span>
01839 <span class="comment">Routine Description:</span>
01840 <span class="comment"></span>
01841 <span class="comment">    This routine unlocks a previous locked cached page.</span>
01842 <span class="comment"></span>
01843 <span class="comment">Arguments:</span>
01844 <span class="comment"></span>
01845 <span class="comment">    AddressInCache - Supplies the address where the page was locked</span>
01846 <span class="comment">                     in the system cache.  This must be the same</span>
01847 <span class="comment">                     address that MmCopyToCachedPage was called with.</span>
01848 <span class="comment"></span>
01849 <span class="comment">Return Value:</span>
01850 <span class="comment"></span>
01851 <span class="comment">    None.</span>
01852 <span class="comment"></span>
01853 <span class="comment">--*/</span>
01854 
01855 {
01856     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
01857     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn1;
01858     KIRQL OldIrql;
01859 
01860     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (AddressInCache);
01861 
01862     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1);
01863     Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber);
01864 
01865     <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
01866 
01867     <span class="keywordflow">if</span> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount &lt;= 1) {
01868         <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a> (MEMORY_MANAGEMENT,
01869                       0x777,
01870                       (ULONG_PTR)PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber,
01871                       Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount,
01872                       (ULONG_PTR)AddressInCache);
01873         <span class="keywordflow">return</span>;
01874     }
01875 
01876     <a class="code" href="../../d4/d8/mi_8h.html#a189">MI_REMOVE_LOCKED_PAGE_CHARGE</a>(Pfn1, 25);
01877     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount -= 1;
01878 
01879     <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
01880     <span class="keywordflow">return</span>;
01881 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:40:42 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
