<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: obwait.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>obwait.c</h1><a href="../../d1/d2/obwait_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1989  Microsoft Corporation</span>
00004 <span class="comment">Copyright (c) 1992  Microsoft Corporation</span>
00005 <span class="comment"></span>
00006 <span class="comment">Module Name:</span>
00007 <span class="comment"></span>
00008 <span class="comment">    obwait.c</span>
00009 <span class="comment"></span>
00010 <span class="comment">Abstract:</span>
00011 <span class="comment"></span>
00012 <span class="comment">    This module implements the generic wait system services.</span>
00013 <span class="comment"></span>
00014 <span class="comment">Author:</span>
00015 <span class="comment"></span>
00016 <span class="comment">    Steve Wood (stevewo) 12-May-1989</span>
00017 <span class="comment"></span>
00018 <span class="comment">Revision History:</span>
00019 <span class="comment"></span>
00020 <span class="comment">--*/</span>
00021 
00022 <span class="preprocessor">#include "<a class="code" href="../../d5/d1/obp_8h.html">obp.h</a>"</span>
00023 
00024 <span class="preprocessor">#ifdef ALLOC_PRAGMA</span>
00025 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, NtWaitForSingleObject)</span>
00026 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00027 <span class="preprocessor"></span>
00028 <span class="comment">//</span>
00029 <span class="comment">//  We special case these three object types in the wait routine</span>
00030 <span class="comment">//</span>
00031 
<a name="l00032"></a><a class="code" href="../../d1/d2/obwait_8c.html#a0">00032</a> <span class="keyword">extern</span> <a class="code" href="../../d3/d6/struct__OBJECT__TYPE.html">POBJECT_TYPE</a> <a class="code" href="../../d7/d7/ntapi_8c.html#a3">ExEventObjectType</a>;
<a name="l00033"></a><a class="code" href="../../d1/d2/obwait_8c.html#a1">00033</a> <span class="keyword">extern</span> <a class="code" href="../../d3/d6/struct__OBJECT__TYPE.html">POBJECT_TYPE</a> <a class="code" href="../../d2/d5/mutant_8c.html#a0">ExMutantObjectType</a>;
<a name="l00034"></a><a class="code" href="../../d1/d2/obwait_8c.html#a2">00034</a> <span class="keyword">extern</span> <a class="code" href="../../d3/d6/struct__OBJECT__TYPE.html">POBJECT_TYPE</a> <a class="code" href="../../d2/d6/semphore_8c.html#a1">ExSemaphoreObjectType</a>;
00035 
00036 
00037 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00038"></a><a class="code" href="../../d1/d2/obwait_8c.html#a3">00038</a> <a class="code" href="../../d1/d2/obwait_8c.html#a3">NtSignalAndWaitForSingleObject</a> (
00039     IN HANDLE SignalHandle,
00040     IN HANDLE WaitHandle,
00041     IN BOOLEAN Alertable,
00042     IN PLARGE_INTEGER Timeout OPTIONAL
00043     )
00044 
00045 <span class="comment">/*++</span>
00046 <span class="comment"></span>
00047 <span class="comment">Routine Description:</span>
00048 <span class="comment"></span>
00049 <span class="comment">    This function atomically signals the specified signal object and then</span>
00050 <span class="comment">    waits until the specified wait object attains a state of Signaled.  An</span>
00051 <span class="comment">    optional timeout can also be specified.  If a timeout is not specified,</span>
00052 <span class="comment">    then the wait will not be satisfied until the wait object attains a</span>
00053 <span class="comment">    state of Signaled.  If a timeout is specified, and the wait object has</span>
00054 <span class="comment">    not attained a state of Signaled when the timeout expires, then the</span>
00055 <span class="comment">    wait is automatically satisfied.  If an explicit timeout value of zero</span>
00056 <span class="comment">    is specified, then no wait will occur if the wait cannot be satisfied</span>
00057 <span class="comment">    immediately.  The wait can also be specified as alertable.</span>
00058 <span class="comment"></span>
00059 <span class="comment">Arguments:</span>
00060 <span class="comment"></span>
00061 <span class="comment">    SignalHandle - Supplies the handle of the signal object.</span>
00062 <span class="comment"></span>
00063 <span class="comment">    WaitHandle  - Supplies the handle for the wait object.</span>
00064 <span class="comment"></span>
00065 <span class="comment">    Alertable - Supplies a boolean value that specifies whether the wait</span>
00066 <span class="comment">        is alertable.</span>
00067 <span class="comment"></span>
00068 <span class="comment">    Timeout - Supplies an pointer to an absolute or relative time over</span>
00069 <span class="comment">        which the wait is to occur.</span>
00070 <span class="comment"></span>
00071 <span class="comment">Return Value:</span>
00072 <span class="comment"></span>
00073 <span class="comment">    The wait completion status.  A value of STATUS_TIMEOUT is returned if a</span>
00074 <span class="comment">    timeout occurred.  A value of STATUS_SUCCESS is returned if the specified</span>
00075 <span class="comment">    object satisfied the wait.  A value of STATUS_ALERTED is returned if the</span>
00076 <span class="comment">    wait was aborted to deliver an alert to the current thread.  A value of</span>
00077 <span class="comment">    STATUS_USER_APC is returned if the wait was aborted to deliver a user</span>
00078 <span class="comment">    APC to the current thread.</span>
00079 <span class="comment"></span>
00080 <span class="comment">--*/</span>
00081 
00082 {
00083     <a class="code" href="../../d3/d5/struct__OBJECT__HANDLE__INFORMATION.html">OBJECT_HANDLE_INFORMATION</a> HandleInformation;
00084     <a class="code" href="../../d0/d9/ntosdef_8h.html#a39">KPROCESSOR_MODE</a> PreviousMode;
00085     PVOID RealObject;
00086     PVOID SignalObject;
00087     <a class="code" href="../../d4/d5/struct__OBJECT__HEADER.html">POBJECT_HEADER</a> SignalObjectHeader;
00088     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00089     LARGE_INTEGER TimeoutValue;
00090     PVOID WaitObject;
00091     <a class="code" href="../../d4/d5/struct__OBJECT__HEADER.html">POBJECT_HEADER</a> WaitObjectHeader;
00092 
00093     <span class="comment">//</span>
00094     <span class="comment">//  Establish an exception handler and probe the specified timeout value</span>
00095     <span class="comment">//  if necessary.  If the probe fails, then return the exception code as</span>
00096     <span class="comment">//  the service status.</span>
00097     <span class="comment">//</span>
00098 
00099     PreviousMode = KeGetPreviousMode();
00100 
00101     <span class="keywordflow">if</span> ((ARGUMENT_PRESENT(Timeout)) &amp;&amp; (PreviousMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>)) {
00102 
00103         <span class="keywordflow">try</span> {
00104 
00105             TimeoutValue = <a class="code" href="../../d5/d8/ex_8h.html#a24">ProbeAndReadLargeInteger</a>(Timeout);
00106             Timeout = &amp;TimeoutValue;
00107 
00108         } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
00109 
00110             <span class="keywordflow">return</span> GetExceptionCode();
00111         }
00112     }
00113 
00114     <span class="comment">//</span>
00115     <span class="comment">//  Reference the signal object by handle.</span>
00116     <span class="comment">//</span>
00117 
00118     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d7/d1/obref_8c.html#a4">ObReferenceObjectByHandle</a>( SignalHandle,
00119                                         0,
00120                                         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00121                                         PreviousMode,
00122                                         &amp;SignalObject,
00123                                         &amp;HandleInformation );
00124 
00125     <span class="comment">//</span>
00126     <span class="comment">//  If the reference was successful, then reference the wait object by</span>
00127     <span class="comment">//  handle.</span>
00128     <span class="comment">//</span>
00129 
00130     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
00131 
00132         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d7/d1/obref_8c.html#a4">ObReferenceObjectByHandle</a>( WaitHandle,
00133                                             SYNCHRONIZE,
00134                                             <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00135                                             PreviousMode,
00136                                             &amp;WaitObject,
00137                                             <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00138 
00139         <span class="comment">//</span>
00140         <span class="comment">//  If the reference was successful, then determine the real wait</span>
00141         <span class="comment">//  object, check the signal object access, signal the signal object,</span>
00142         <span class="comment">//  and wait for the real wait object.</span>
00143         <span class="comment">//</span>
00144 
00145         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
00146 
00147             WaitObjectHeader = <a class="code" href="../../d4/d0/ob_8h.html#a8">OBJECT_TO_OBJECT_HEADER</a>(WaitObject);
00148             RealObject = WaitObjectHeader-&gt;<a class="code" href="../../d4/d5/struct__OBJECT__HEADER.html#o3">Type</a>-&gt;<a class="code" href="../../d3/d6/struct__OBJECT__TYPE.html#o3">DefaultObject</a>;
00149 
00150             <span class="keywordflow">if</span> ((LONG_PTR)RealObject &gt;= 0) {
00151 
00152                 RealObject = (PVOID)((PCHAR)WaitObject + (ULONG_PTR)RealObject);
00153             }
00154 
00155             <span class="comment">//</span>
00156             <span class="comment">//  If the signal object is an event, then check for modify access</span>
00157             <span class="comment">//  and set the event.  Otherwise, if the signal object is a</span>
00158             <span class="comment">//  mutant, then attempt to release ownership of the mutant.</span>
00159             <span class="comment">//  Otherwise, if the object is a semaphore, then check for modify</span>
00160             <span class="comment">//  access and release the semaphore.  Otherwise, the signal objet</span>
00161             <span class="comment">//  is invalid.</span>
00162             <span class="comment">//</span>
00163 
00164             SignalObjectHeader = <a class="code" href="../../d4/d0/ob_8h.html#a8">OBJECT_TO_OBJECT_HEADER</a>(SignalObject);
00165             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_ACCESS_DENIED;
00166 
00167             <span class="keywordflow">if</span> (SignalObjectHeader-&gt;<a class="code" href="../../d4/d5/struct__OBJECT__HEADER.html#o3">Type</a> == <a class="code" href="../../d7/d7/ntapi_8c.html#a3">ExEventObjectType</a>) {
00168 
00169                 <span class="comment">//</span>
00170                 <span class="comment">//  Check for access to the specified event object,</span>
00171                 <span class="comment">//</span>
00172 
00173                 <span class="keywordflow">if</span> ((PreviousMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) &amp;&amp;
00174                     (<a class="code" href="../../d0/d5/se_8h.html#a8">SeComputeDeniedAccesses</a>( HandleInformation.<a class="code" href="../../d3/d5/struct__OBJECT__HANDLE__INFORMATION.html#o1">GrantedAccess</a>,
00175                                               EVENT_MODIFY_STATE) != 0 )) {
00176 
00177                     <span class="keywordflow">goto</span> WaitExit;
00178                 }
00179 
00180                 <span class="comment">//</span>
00181                 <span class="comment">//  Set the specified event and wait atomically.</span>
00182                 <span class="comment">//</span>
00183 
00184                 <a class="code" href="../../d2/d8/eventobj_8c.html#a8">KeSetEvent</a>((<a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>)SignalObject, <a class="code" href="../../d7/d8/exboosts_8h.html#a0">EVENT_INCREMENT</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
00185 
00186             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (SignalObjectHeader-&gt;<a class="code" href="../../d4/d5/struct__OBJECT__HEADER.html#o3">Type</a> == <a class="code" href="../../d2/d5/mutant_8c.html#a0">ExMutantObjectType</a>) {
00187 
00188                 <span class="comment">//</span>
00189                 <span class="comment">//  Release the specified mutant and wait atomically.</span>
00190                 <span class="comment">//</span>
00191                 <span class="comment">//  N.B. The release will only be successful if the current</span>
00192                 <span class="comment">//       thread is the owner of the mutant.</span>
00193                 <span class="comment">//</span>
00194 
00195                 <span class="keywordflow">try</span> {
00196 
00197                     <a class="code" href="../../d3/d5/mutntobj_8c.html#a4">KeReleaseMutant</a>( (<a class="code" href="../../d3/d7/struct__KMUTANT.html">PKMUTANT</a>)SignalObject,
00198                                      <a class="code" href="../../d7/d8/exboosts_8h.html#a15">MUTANT_INCREMENT</a>,
00199                                      <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00200                                      <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
00201 
00202                 } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
00203 
00204                     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = GetExceptionCode();
00205 
00206                     <span class="keywordflow">goto</span> WaitExit;
00207                 }
00208 
00209             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (SignalObjectHeader-&gt;<a class="code" href="../../d4/d5/struct__OBJECT__HEADER.html#o3">Type</a> == <a class="code" href="../../d2/d6/semphore_8c.html#a1">ExSemaphoreObjectType</a>) {
00210 
00211                 <span class="comment">//</span>
00212                 <span class="comment">//  Check for access to the specified semaphore object,</span>
00213                 <span class="comment">//</span>
00214 
00215                 <span class="keywordflow">if</span> ((PreviousMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) &amp;&amp;
00216                     (<a class="code" href="../../d0/d5/se_8h.html#a8">SeComputeDeniedAccesses</a>( HandleInformation.<a class="code" href="../../d3/d5/struct__OBJECT__HANDLE__INFORMATION.html#o1">GrantedAccess</a>,
00217                                               SEMAPHORE_MODIFY_STATE) != 0 )) {
00218 
00219                     <span class="keywordflow">goto</span> WaitExit;
00220                 }
00221 
00222                 <span class="comment">//</span>
00223                 <span class="comment">//  Release the specified semaphore and wait atomically.</span>
00224                 <span class="comment">//</span>
00225 
00226                 <span class="keywordflow">try</span> {
00227 
00228                     <span class="comment">//</span>
00229                     <span class="comment">//  Release the specified semaphore and wait atomically.</span>
00230                     <span class="comment">//</span>
00231 
00232                     <a class="code" href="../../d1/d6/semphobj_8c.html#a3">KeReleaseSemaphore</a>( (<a class="code" href="../../d8/d7/struct__KSEMAPHORE.html">PKSEMAPHORE</a>)SignalObject,
00233                                         <a class="code" href="../../d7/d8/exboosts_8h.html#a16">SEMAPHORE_INCREMENT</a>,
00234                                         1,
00235                                         <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
00236 
00237                 } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
00238 
00239                     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = GetExceptionCode();
00240 
00241                     <span class="keywordflow">goto</span> WaitExit;
00242                 }
00243 
00244             } <span class="keywordflow">else</span> {
00245 
00246                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_OBJECT_TYPE_MISMATCH;
00247 
00248                 <span class="keywordflow">goto</span> WaitExit;
00249             }
00250 
00251             <span class="comment">//</span>
00252             <span class="comment">//  Protect the wait call just in case KeWait decides to raise</span>
00253             <span class="comment">//  For example, a mutant level is exceeded</span>
00254             <span class="comment">//</span>
00255 
00256             <span class="keywordflow">try</span> {
00257 
00258                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( RealObject,
00259                                                 <a class="code" href="../../d4/d9/ke_8h.html#a407a204">UserRequest</a>,
00260                                                 PreviousMode,
00261                                                 Alertable,
00262                                                 Timeout );
00263 
00264             } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
00265 
00266                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = GetExceptionCode();
00267             }
00268 
00269 WaitExit:
00270 
00271             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>(WaitObject);
00272         }
00273 
00274         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>(SignalObject);
00275     }
00276 
00277     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00278 }
00279 
00280 
00281 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00282"></a><a class="code" href="../../d1/d2/obwait_8c.html#a4">00282</a> <a class="code" href="../../d1/d2/obwait_8c.html#a4">NtWaitForSingleObject</a> (
00283     IN HANDLE Handle,
00284     IN BOOLEAN Alertable,
00285     IN PLARGE_INTEGER Timeout OPTIONAL
00286     )
00287 
00288 <span class="comment">/*++</span>
00289 <span class="comment"></span>
00290 <span class="comment">Routine Description:</span>
00291 <span class="comment"></span>
00292 <span class="comment">    This function waits until the specified object attains a state of</span>
00293 <span class="comment">    Signaled.  An optional timeout can also be specified.  If a timeout</span>
00294 <span class="comment">    is not specified, then the wait will not be satisfied until the</span>
00295 <span class="comment">    object attains a state of Signaled.  If a timeout is specified, and</span>
00296 <span class="comment">    the object has not attained a state of Signaled when the timeout</span>
00297 <span class="comment">    expires, then the wait is automatically satisfied.  If an explicit</span>
00298 <span class="comment">    timeout value of zero is specified, then no wait will occur if the</span>
00299 <span class="comment">    wait cannot be satisfied immediately.  The wait can also be specified</span>
00300 <span class="comment">    as alertable.</span>
00301 <span class="comment"></span>
00302 <span class="comment">Arguments:</span>
00303 <span class="comment"></span>
00304 <span class="comment">    Handle  - Supplies the handle for the wait object.</span>
00305 <span class="comment"></span>
00306 <span class="comment">    Alertable - Supplies a boolean value that specifies whether the wait</span>
00307 <span class="comment">        is alertable.</span>
00308 <span class="comment"></span>
00309 <span class="comment">    Timeout - Supplies an pointer to an absolute or relative time over</span>
00310 <span class="comment">        which the wait is to occur.</span>
00311 <span class="comment"></span>
00312 <span class="comment">Return Value:</span>
00313 <span class="comment"></span>
00314 <span class="comment">    The wait completion status. A value of STATUS_TIMEOUT is returned if a</span>
00315 <span class="comment">    timeout occurred.  A value of STATUS_SUCCESS is returned if the specified</span>
00316 <span class="comment">    object satisfied the wait.  A value of STATUS_ALERTED is returned if the</span>
00317 <span class="comment">    wait was aborted to deliver an alert to the current thread. A value of</span>
00318 <span class="comment">    STATUS_USER_APC is returned if the wait was aborted to deliver a user</span>
00319 <span class="comment">    APC to the current thread.</span>
00320 <span class="comment"></span>
00321 <span class="comment">--*/</span>
00322 
00323 {
00324     PVOID Object;
00325     <a class="code" href="../../d4/d5/struct__OBJECT__HEADER.html">POBJECT_HEADER</a> ObjectHeader;
00326     <a class="code" href="../../d0/d9/ntosdef_8h.html#a39">KPROCESSOR_MODE</a> PreviousMode;
00327     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00328     LARGE_INTEGER TimeoutValue;
00329     PVOID WaitObject;
00330 
00331     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00332 
00333     <span class="comment">//</span>
00334     <span class="comment">//  Get previous processor mode and probe and capture timeout argument</span>
00335     <span class="comment">//  if necessary.</span>
00336     <span class="comment">//</span>
00337 
00338     PreviousMode = KeGetPreviousMode();
00339 
00340     <span class="keywordflow">if</span> ((ARGUMENT_PRESENT(Timeout)) &amp;&amp; (PreviousMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>)) {
00341 
00342         <span class="keywordflow">try</span> {
00343 
00344             TimeoutValue = <a class="code" href="../../d5/d8/ex_8h.html#a24">ProbeAndReadLargeInteger</a>(Timeout);
00345             Timeout = &amp;TimeoutValue;
00346 
00347         } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
00348 
00349             <span class="keywordflow">return</span> GetExceptionCode();
00350         }
00351     }
00352 
00353     <span class="comment">//</span>
00354     <span class="comment">//  Get a referenced pointer to the specified object with synchronize</span>
00355     <span class="comment">//  access.</span>
00356     <span class="comment">//</span>
00357 
00358     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d7/d1/obref_8c.html#a4">ObReferenceObjectByHandle</a>( <a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a>,
00359                                         SYNCHRONIZE,
00360                                         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00361                                         PreviousMode,
00362                                         &amp;Object,
00363                                         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00364 
00365     <span class="comment">//</span>
00366     <span class="comment">//  If access is granted, then check to determine if the specified object</span>
00367     <span class="comment">//  can be waited on.</span>
00368     <span class="comment">//</span>
00369 
00370     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
00371 
00372         ObjectHeader = <a class="code" href="../../d4/d0/ob_8h.html#a8">OBJECT_TO_OBJECT_HEADER</a>( Object );
00373         WaitObject = ObjectHeader-&gt;<a class="code" href="../../d4/d5/struct__OBJECT__HEADER.html#o3">Type</a>-&gt;<a class="code" href="../../d3/d6/struct__OBJECT__TYPE.html#o3">DefaultObject</a>;
00374 
00375         <span class="keywordflow">if</span> ((LONG_PTR)WaitObject &gt;= 0) {
00376 
00377             WaitObject = (PVOID)((PCHAR)Object + (ULONG_PTR)WaitObject);
00378         }
00379 
00380         <span class="comment">//</span>
00381         <span class="comment">//  Protect the wait call just in case KeWait decides to raise</span>
00382         <span class="comment">//  For example, a mutant level is exceeded</span>
00383         <span class="comment">//</span>
00384 
00385         <span class="keywordflow">try</span> {
00386 
00387             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( WaitObject,
00388                                             <a class="code" href="../../d4/d9/ke_8h.html#a407a204">UserRequest</a>,
00389                                             PreviousMode,
00390                                             Alertable,
00391                                             Timeout );
00392 
00393         } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
00394 
00395             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = GetExceptionCode();
00396         }
00397 
00398         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>(Object);
00399     }
00400 
00401     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00402 }
00403 
00404 
00405 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00406"></a><a class="code" href="../../d1/d2/obwait_8c.html#a5">00406</a> <a class="code" href="../../d1/d2/obwait_8c.html#a5">NtWaitForMultipleObjects</a> (
00407     IN ULONG Count,
00408     IN HANDLE Handles[],
00409     IN WAIT_TYPE WaitType,
00410     IN BOOLEAN Alertable,
00411     IN PLARGE_INTEGER Timeout OPTIONAL
00412     )
00413 
00414 <span class="comment">/*++</span>
00415 <span class="comment"></span>
00416 <span class="comment">Routine Description:</span>
00417 <span class="comment"></span>
00418 <span class="comment">    This function waits until the specified objects attain a state of</span>
00419 <span class="comment">    Signaled.  The wait can be specified to wait until all of the objects</span>
00420 <span class="comment">    attain a state of Signaled or until one of the objects attains a state</span>
00421 <span class="comment">    of Signaled.  An optional timeout can also be specified.  If a timeout</span>
00422 <span class="comment">    is not specified, then the wait will not be satisfied until the objects</span>
00423 <span class="comment">    attain a state of Signaled.  If a timeout is specified, and the objects</span>
00424 <span class="comment">    have not attained a state of Signaled when the timeout expires, then</span>
00425 <span class="comment">    the wait is automatically satisfied.  If an explicit timeout value of</span>
00426 <span class="comment">    zero is specified, then no wait will occur if the wait cannot be satisfied</span>
00427 <span class="comment">    immediately.  The wait can also be specified as alertable.</span>
00428 <span class="comment"></span>
00429 <span class="comment">Arguments:</span>
00430 <span class="comment"></span>
00431 <span class="comment">    Count - Supplies a count of the number of objects that are to be waited</span>
00432 <span class="comment">        on.</span>
00433 <span class="comment"></span>
00434 <span class="comment">    Handles[] - Supplies an array of handles to wait objects.</span>
00435 <span class="comment"></span>
00436 <span class="comment">    WaitType - Supplies the type of wait to perform (WaitAll, WaitAny).</span>
00437 <span class="comment"></span>
00438 <span class="comment">    Alertable - Supplies a boolean value that specifies whether the wait is</span>
00439 <span class="comment">        alertable.</span>
00440 <span class="comment"></span>
00441 <span class="comment">    Timeout - Supplies a pointer to an optional absolute of relative time over</span>
00442 <span class="comment">        which the wait is to occur.</span>
00443 <span class="comment"></span>
00444 <span class="comment">Return Value:</span>
00445 <span class="comment"></span>
00446 <span class="comment">    The wait completion status.  A value of STATUS_TIMEOUT is returned if a</span>
00447 <span class="comment">    timeout occurred.  The index of the object (zero based) in the object</span>
00448 <span class="comment">    pointer array is returned if an object satisfied the wait.  A value of</span>
00449 <span class="comment">    STATUS_ALERTED is returned if the wait was aborted to deliver an alert</span>
00450 <span class="comment">    to the current thread.  A value of STATUS_USER_APC is returned if the</span>
00451 <span class="comment">    wait was aborted to deliver a user APC to the current thread.</span>
00452 <span class="comment"></span>
00453 <span class="comment">--*/</span>
00454 
00455 {
00456     HANDLE CapturedHandles[MAXIMUM_WAIT_OBJECTS];
00457     ULONG i;
00458     ULONG j;
00459     <a class="code" href="../../d4/d5/struct__OBJECT__HEADER.html">POBJECT_HEADER</a> ObjectHeader;
00460     PVOID Objects[MAXIMUM_WAIT_OBJECTS];
00461     <a class="code" href="../../d0/d9/ntosdef_8h.html#a39">KPROCESSOR_MODE</a> PreviousMode;
00462     ULONG <a class="code" href="../../d0/d3/ppc_2initkr_8c.html#a5">RefCount</a>;
00463     ULONG <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
00464     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00465     LARGE_INTEGER TimeoutValue;
00466     <a class="code" href="../../d4/d8/struct__KWAIT__BLOCK.html">PKWAIT_BLOCK</a> WaitBlockArray;
00467     ACCESS_MASK GrantedAccess;
00468     PVOID WaitObjects[MAXIMUM_WAIT_OBJECTS];
00469     <a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html">PHANDLE_TABLE</a> HandleTable;
00470     <a class="code" href="../../d7/d3/struct__HANDLE__TABLE__ENTRY.html">PHANDLE_TABLE_ENTRY</a> HandleEntry;
00471     BOOLEAN AttachedToProcess = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00472     BOOLEAN InCriticalRegion = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00473     <a class="code" href="../../d3/d5/struct__KAPC__STATE.html">KAPC_STATE</a> ApcState;
00474 
00475     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00476 
00477     <span class="comment">//</span>
00478     <span class="comment">//  Protect ourselves from being interrupted while we hold a handle table</span>
00479     <span class="comment">//  entry lock</span>
00480     <span class="comment">//</span>
00481 
00482     <a class="code" href="../../d4/d9/ke_8h.html#a28">KeEnterCriticalRegion</a>();
00483     InCriticalRegion = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00484 
00485     <span class="keywordflow">try</span> {
00486 
00487         <span class="comment">//</span>
00488         <span class="comment">//  If the number of objects is zero or greater than the largest number</span>
00489         <span class="comment">//  that can be waited on, then return and invalid parameter status.</span>
00490         <span class="comment">//</span>
00491 
00492         <span class="keywordflow">if</span> ((<a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> == 0) || (<a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> &gt; MAXIMUM_WAIT_OBJECTS)) {
00493 
00494             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_PARAMETER_1;
00495             leave;
00496         }
00497 
00498         <span class="comment">//</span>
00499         <span class="comment">//  If the wait type is not wait any or wait all, then return an invalid</span>
00500         <span class="comment">//  parameter status.</span>
00501         <span class="comment">//</span>
00502 
00503         <span class="keywordflow">if</span> ((WaitType != WaitAny) &amp;&amp; (WaitType != WaitAll)) {
00504 
00505             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_PARAMETER_3;
00506             leave;
00507         }
00508 
00509         <span class="comment">//</span>
00510         <span class="comment">//  Get previous processor mode and probe and capture input arguments if</span>
00511         <span class="comment">//  necessary.</span>
00512         <span class="comment">//</span>
00513 
00514         PreviousMode = KeGetPreviousMode();
00515 
00516         <span class="keywordflow">try</span> {
00517 
00518             <span class="keywordflow">if</span> (PreviousMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
00519 
00520                 <span class="keywordflow">if</span> (ARGUMENT_PRESENT(Timeout)) {
00521 
00522                     TimeoutValue = <a class="code" href="../../d5/d8/ex_8h.html#a24">ProbeAndReadLargeInteger</a>(Timeout);
00523                     Timeout = &amp;TimeoutValue;
00524                 }
00525 
00526                 <a class="code" href="../../d5/d8/ex_8h.html#a11">ProbeForRead</a>( Handles, <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> * <span class="keyword">sizeof</span>(HANDLE), <span class="keyword">sizeof</span>(HANDLE) );
00527             }
00528 
00529             i= 0;
00530 
00531             <span class="keywordflow">do</span> {
00532 
00533                 CapturedHandles[i] = Handles[i];
00534                 i += 1;
00535 
00536             } <span class="keywordflow">while</span> (i &lt; <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a>);
00537 
00538         } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
00539 
00540             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = GetExceptionCode();
00541             leave;
00542         }
00543 
00544         <span class="comment">//</span>
00545         <span class="comment">//  If the number of objects to be waited on is greater than the number</span>
00546         <span class="comment">//  of builtin wait blocks, then allocate an array of wait blocks from</span>
00547         <span class="comment">//  nonpaged pool. If the wait block array cannot be allocated, then</span>
00548         <span class="comment">//  return insufficient resources.</span>
00549         <span class="comment">//</span>
00550 
00551         WaitBlockArray = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00552 
00553         <span class="keywordflow">if</span> (<a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> &gt; <a class="code" href="../../d4/d9/ke_8h.html#a6">THREAD_WAIT_OBJECTS</a>) {
00554 
00555             <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> = <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> * <span class="keyword">sizeof</span>( <a class="code" href="../../d4/d8/struct__KWAIT__BLOCK.html">KWAIT_BLOCK</a> );
00556             WaitBlockArray = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>(<a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>, 'tiaW');
00557 
00558             <span class="keywordflow">if</span> (WaitBlockArray == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00559 
00560                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INSUFFICIENT_RESOURCES;
00561                 leave;
00562             }
00563         }
00564 
00565         <span class="comment">//</span>
00566         <span class="comment">//  Loop through the array of handles and get a referenced pointer to</span>
00567         <span class="comment">//  each object.</span>
00568         <span class="comment">//</span>
00569 
00570         i = 0;
00571         <a class="code" href="../../d0/d3/ppc_2initkr_8c.html#a5">RefCount</a> = 0;
00572 
00573         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
00574 
00575         <span class="keywordflow">do</span> {
00576 
00577 <span class="preprocessor">    #if DBG</span>
00578 <span class="preprocessor"></span>            <span class="comment">//</span>
00579             <span class="comment">//  On checked builds, check that if the Kernel handle bit is set,</span>
00580             <span class="comment">//  then we're coming from Kernel mode.  We should probably fail the</span>
00581             <span class="comment">//  call if bit set &amp;&amp; !Kmode</span>
00582             <span class="comment">//</span>
00583 
00584             <span class="keywordflow">if</span> ((CapturedHandles[i] != NtCurrentThread()) &amp;&amp;
00585                 (CapturedHandles[i] != NtCurrentProcess())) {
00586 
00587                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>((CapturedHandles[i] &lt; 0) ? (PreviousMode == <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) : <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
00588             }
00589 <span class="preprocessor">    #endif</span>
00590 <span class="preprocessor"></span>
00591             <span class="comment">//</span>
00592             <span class="comment">//  Get a pointer to the object table entry.  Check if this is a kernel</span>
00593             <span class="comment">//  handle and if so then use the kernel handle table otherwise use the</span>
00594             <span class="comment">//  processes handle table.  If we are going for a kernel handle we'll</span>
00595             <span class="comment">//  need to attach to the kernel process otherwise we need to ensure</span>
00596             <span class="comment">//  that we aren't attached.</span>
00597             <span class="comment">//</span>
00598 
00599             <span class="keywordflow">if</span> (<a class="code" href="../../d6/d6/ioverifier_8c.html#a14">IsKernelHandle</a>( CapturedHandles[i], PreviousMode )) {
00600 
00601                 HANDLE KernelHandle;
00602 
00603                 <span class="comment">//</span>
00604                 <span class="comment">//  If we aren't already attached to the system process do so now</span>
00605                 <span class="comment">//  and remember that we are</span>
00606                 <span class="comment">//</span>
00607 
00608                 <span class="keywordflow">if</span> (<a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a>() != <a class="code" href="../../d1/d9/ps_8h.html#a53">PsInitialSystemProcess</a>) {
00609                     <a class="code" href="../../d3/d5/procobj_8c.html#a6">KeStackAttachProcess</a> (&amp;<a class="code" href="../../d1/d9/ps_8h.html#a53">PsInitialSystemProcess</a>-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o0">Pcb</a>, &amp;ApcState);
00610                     AttachedToProcess = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00611                 }
00612 
00613                 <span class="comment">//</span>
00614                 <span class="comment">//  Decode the user supplied handle into a regular handle value</span>
00615                 <span class="comment">//  and get its handle table entry</span>
00616                 <span class="comment">//</span>
00617 
00618                 KernelHandle = <a class="code" href="../../d5/d1/obp_8h.html#a27">DecodeKernelHandle</a>( CapturedHandles[i] );
00619 
00620                 HandleTable = <a class="code" href="../../d5/d1/obp_8h.html#a54">ObpKernelHandleTable</a>;
00621                 HandleEntry = <a class="code" href="../../d5/d8/ex_8h.html#a299">ExMapHandleToPointer</a>( HandleTable, KernelHandle );
00622 
00623             } <span class="keywordflow">else</span> {
00624 
00625                 <span class="comment">//</span>
00626                 <span class="comment">//  If we are attached to the system process then go back to the</span>
00627                 <span class="comment">//  original callers process</span>
00628                 <span class="comment">//</span>
00629 
00630                 <span class="keywordflow">if</span> (AttachedToProcess) {
00631                     <a class="code" href="../../d3/d5/procobj_8c.html#a8">KeUnstackDetachProcess</a>(&amp;ApcState);
00632                     AttachedToProcess = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00633                 }
00634 
00635                 <span class="comment">//</span>
00636                 <span class="comment">//  Get the handle table entry</span>
00637                 <span class="comment">//</span>
00638 
00639                 HandleTable = <a class="code" href="../../d5/d1/obp_8h.html#a12">ObpGetObjectTable</a>();
00640                 HandleEntry = <a class="code" href="../../d5/d8/ex_8h.html#a299">ExMapHandleToPointer</a>( HandleTable, CapturedHandles[ i ] );
00641             }
00642 
00643             <span class="comment">//</span>
00644             <span class="comment">//  Make sure the handle really did translate to a valid</span>
00645             <span class="comment">//  entry</span>
00646             <span class="comment">//</span>
00647 
00648             <span class="keywordflow">if</span> (HandleEntry != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00649 
00650                 <span class="comment">//</span>
00651                 <span class="comment">//  Get the granted access for the handle</span>
00652                 <span class="comment">//</span>
00653 
00654 <span class="preprocessor">    #if i386 &amp;&amp; !FPO</span>
00655 <span class="preprocessor"></span>
00656                 <span class="keywordflow">if</span> (<a class="code" href="../../d9/d2/ldrp_8h.html#a33">NtGlobalFlag</a> &amp; FLG_KERNEL_STACK_TRACE_DB) {
00657 
00658                     <span class="keywordflow">if</span> (PreviousMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
00659 
00660                         GrantedAccess = ObpTranslateGrantedAccessIndex( HandleEntry-&gt;<a class="code" href="../../d7/d3/struct__HANDLE__TABLE__ENTRY.html#o3">GrantedAccessIndex</a> );
00661                     }
00662 
00663                 } <span class="keywordflow">else</span> {
00664 
00665                     GrantedAccess = HandleEntry-&gt;<a class="code" href="../../d7/d3/struct__HANDLE__TABLE__ENTRY.html#o2">GrantedAccess</a>;
00666                 }
00667 
00668 <span class="preprocessor">    #else</span>
00669 <span class="preprocessor"></span>                GrantedAccess = HandleEntry-&gt;<a class="code" href="../../d7/d3/struct__HANDLE__TABLE__ENTRY.html#o2">GrantedAccess</a>;
00670 
00671 <span class="preprocessor">    #endif // i386 &amp;&amp; !FPO</span>
00672 <span class="preprocessor"></span>
00673                 <span class="comment">//</span>
00674                 <span class="comment">//  Make sure the handle as synchronize access to the</span>
00675                 <span class="comment">//  object</span>
00676                 <span class="comment">//</span>
00677 
00678                 <span class="keywordflow">if</span> ((PreviousMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) &amp;&amp;
00679                     (<a class="code" href="../../d0/d5/se_8h.html#a8">SeComputeDeniedAccesses</a>( GrantedAccess, SYNCHRONIZE ) != 0)) {
00680 
00681                     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_ACCESS_DENIED;
00682 
00683                     <a class="code" href="../../d5/d8/ex_8h.html#a288">ExUnlockHandleTableEntry</a>( HandleTable, HandleEntry );
00684 
00685                     <span class="keywordflow">goto</span> ServiceFailed;
00686 
00687                 } <span class="keywordflow">else</span> {
00688 
00689                     <span class="comment">//</span>
00690                     <span class="comment">//  We have a object with proper access so get the header</span>
00691                     <span class="comment">//  and if the default objects points to a real object</span>
00692                     <span class="comment">//  then that is the one we're going to wait on.</span>
00693                     <span class="comment">//  Otherwise we'll find the kernel wait object at an</span>
00694                     <span class="comment">//  offset into the object body</span>
00695                     <span class="comment">//</span>
00696 
00697                     ObjectHeader = (<a class="code" href="../../d4/d5/struct__OBJECT__HEADER.html">POBJECT_HEADER</a>)(((ULONG_PTR)(HandleEntry-&gt;<a class="code" href="../../d7/d3/struct__HANDLE__TABLE__ENTRY.html#o0">Object</a>)) &amp; ~<a class="code" href="../../d5/d1/obp_8h.html#a17">OBJ_HANDLE_ATTRIBUTES</a>);
00698 
00699                     <span class="keywordflow">if</span> ((LONG_PTR)ObjectHeader-&gt;<a class="code" href="../../d4/d5/struct__OBJECT__HEADER.html#o3">Type</a>-&gt;<a class="code" href="../../d3/d6/struct__OBJECT__TYPE.html#o3">DefaultObject</a> &lt; 0) {
00700 
00701                         <a class="code" href="../../d0/d3/ppc_2initkr_8c.html#a5">RefCount</a> += 1;
00702                         Objects[i] = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00703                         WaitObjects[i] = ObjectHeader-&gt;<a class="code" href="../../d4/d5/struct__OBJECT__HEADER.html#o3">Type</a>-&gt;<a class="code" href="../../d3/d6/struct__OBJECT__TYPE.html#o3">DefaultObject</a>;
00704 
00705                     } <span class="keywordflow">else</span> {
00706 
00707                         <a class="code" href="../../d5/d1/obp_8h.html#a3">ObpIncrPointerCount</a>( ObjectHeader );
00708                         <a class="code" href="../../d0/d3/ppc_2initkr_8c.html#a5">RefCount</a> += 1;
00709                         Objects[i] = &amp;ObjectHeader-&gt;<a class="code" href="../../d4/d5/struct__OBJECT__HEADER.html#o11">Body</a>;
00710 
00711                         <span class="comment">//</span>
00712                         <span class="comment">//  Compute the address of the kernel wait object.</span>
00713                         <span class="comment">//</span>
00714 
00715                         WaitObjects[i] = (PVOID)((PCHAR)&amp;ObjectHeader-&gt;<a class="code" href="../../d4/d5/struct__OBJECT__HEADER.html#o11">Body</a> +
00716                                                  (ULONG_PTR)ObjectHeader-&gt;<a class="code" href="../../d4/d5/struct__OBJECT__HEADER.html#o3">Type</a>-&gt;<a class="code" href="../../d3/d6/struct__OBJECT__TYPE.html#o3">DefaultObject</a>);
00717                     }
00718                 }
00719 
00720                 <a class="code" href="../../d5/d8/ex_8h.html#a288">ExUnlockHandleTableEntry</a>( HandleTable, HandleEntry );
00721 
00722             } <span class="keywordflow">else</span> {
00723 
00724                 <span class="comment">//</span>
00725                 <span class="comment">//  The entry in the handle table isn't in use</span>
00726                 <span class="comment">//</span>
00727 
00728                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_HANDLE;
00729 
00730                 <span class="keywordflow">goto</span> ServiceFailed;
00731             }
00732 
00733             i += 1;
00734 
00735         } <span class="keywordflow">while</span> (i &lt; <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a>);
00736 
00737         <span class="comment">//</span>
00738         <span class="comment">//  At this point the WaitObjects[] is set to the kernel wait objects</span>
00739         <span class="comment">//</span>
00740         <span class="comment">//  Now Check to determine if any of the objects are specified more than</span>
00741         <span class="comment">//  once, but we only need to check this for wait all, with a wait any</span>
00742         <span class="comment">//  the user can specify the same object multiple times.</span>
00743         <span class="comment">//</span>
00744 
00745         <span class="keywordflow">if</span> (WaitType == WaitAll) {
00746 
00747             i = 0;
00748 
00749             <span class="keywordflow">do</span> {
00750 
00751                 <span class="keywordflow">for</span> (j = i + 1; j &lt; <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a>; j += 1) {
00752 
00753                     <span class="keywordflow">if</span> (WaitObjects[i] == WaitObjects[j]) {
00754 
00755                         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_PARAMETER_MIX;
00756 
00757                         <span class="keywordflow">goto</span> ServiceFailed;
00758                     }
00759                 }
00760 
00761                 i += 1;
00762 
00763             } <span class="keywordflow">while</span> (i &lt; <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a>);
00764         }
00765 
00766         <span class="comment">//</span>
00767         <span class="comment">//  Wait for the specified objects to attain a state of Signaled or a</span>
00768         <span class="comment">//  time out to occur.  Protect the wait call just in case KeWait decides</span>
00769         <span class="comment">//  to raise For example, a mutant level is exceeded</span>
00770         <span class="comment">//</span>
00771 
00772         <span class="keywordflow">try</span> {
00773 
00774             InCriticalRegion = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00775             <a class="code" href="../../d4/d9/ke_8h.html#a29">KeLeaveCriticalRegion</a>();
00776             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d1/d7/wait_8c.html#a3">KeWaitForMultipleObjects</a>( <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a>,
00777                                                WaitObjects,
00778                                                WaitType,
00779                                                <a class="code" href="../../d4/d9/ke_8h.html#a407a204">UserRequest</a>,
00780                                                PreviousMode,
00781                                                Alertable,
00782                                                Timeout,
00783                                                WaitBlockArray );
00784 
00785         } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
00786 
00787             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = GetExceptionCode();
00788         }
00789 
00790         <span class="comment">//</span>
00791         <span class="comment">//  If any objects were referenced, then deference them.</span>
00792         <span class="comment">//</span>
00793 
00794     ServiceFailed:
00795 
00796         <span class="keywordflow">while</span> (<a class="code" href="../../d0/d3/ppc_2initkr_8c.html#a5">RefCount</a> &gt; 0) {
00797 
00798             <a class="code" href="../../d0/d3/ppc_2initkr_8c.html#a5">RefCount</a> -= 1;
00799 
00800             <span class="keywordflow">if</span> (Objects[<a class="code" href="../../d0/d3/ppc_2initkr_8c.html#a5">RefCount</a>] != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00801 
00802                 <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>(Objects[<a class="code" href="../../d0/d3/ppc_2initkr_8c.html#a5">RefCount</a>]);
00803             }
00804         }
00805 
00806         <span class="comment">//</span>
00807         <span class="comment">//  If are attached to the system process then return back to our callers</span>
00808         <span class="comment">//  process</span>
00809 
00810         <span class="keywordflow">if</span> (AttachedToProcess) {
00811             <a class="code" href="../../d3/d5/procobj_8c.html#a8">KeUnstackDetachProcess</a>(&amp;ApcState);
00812             AttachedToProcess = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00813         }
00814 
00815         <span class="comment">//</span>
00816         <span class="comment">//  If a wait block array was allocated, then deallocate it.</span>
00817         <span class="comment">//</span>
00818 
00819         <span class="keywordflow">if</span> (WaitBlockArray != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00820 
00821             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(WaitBlockArray);
00822         }
00823 
00824     } finally {
00825 
00826         <span class="keywordflow">if</span> ( InCriticalRegion ) {
00827 
00828             <a class="code" href="../../d4/d9/ke_8h.html#a29">KeLeaveCriticalRegion</a>();
00829         }
00830     }
00831 
00832     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00833 }
00834 
00835 
00836 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00837"></a><a class="code" href="../../d1/d2/obwait_8c.html#a6">00837</a> <a class="code" href="../../d1/d2/obwait_8c.html#a6">ObWaitForSingleObject</a> (
00838     IN HANDLE Handle,
00839     IN BOOLEAN Alertable,
00840     IN PLARGE_INTEGER Timeout OPTIONAL
00841     )
00842 
00843 <span class="comment">/*++</span>
00844 <span class="comment"></span>
00845 <span class="comment">Routine Description:</span>
00846 <span class="comment"></span>
00847 <span class="comment">    Please refer to NtWaitForSingleObject</span>
00848 <span class="comment"></span>
00849 <span class="comment">Arguments:</span>
00850 <span class="comment"></span>
00851 <span class="comment">    Handle  - Supplies the handle for the wait object.</span>
00852 <span class="comment"></span>
00853 <span class="comment">    Alertable - Supplies a boolean value that specifies whether the wait</span>
00854 <span class="comment">        is alertable.</span>
00855 <span class="comment"></span>
00856 <span class="comment">    Timeout - Supplies an pointer to an absolute or relative time over</span>
00857 <span class="comment">        which the wait is to occur.</span>
00858 <span class="comment"></span>
00859 <span class="comment">Return Value:</span>
00860 <span class="comment"></span>
00861 <span class="comment">    The wait completion status. A value of STATUS_TIMEOUT is returned if a</span>
00862 <span class="comment">    timeout occurred.  A value of STATUS_SUCCESS is returned if the specified</span>
00863 <span class="comment">    object satisfied the wait.  A value of STATUS_ALERTED is returned if the</span>
00864 <span class="comment">    wait was aborted to deliver an alert to the current thread. A value of</span>
00865 <span class="comment">    STATUS_USER_APC is returned if the wait was aborted to deliver a user</span>
00866 <span class="comment">    APC to the current thread.</span>
00867 <span class="comment"></span>
00868 <span class="comment">--*/</span>
00869 
00870 {
00871     <a class="code" href="../../d4/d5/struct__OBJECT__HEADER.html">POBJECT_HEADER</a> ObjectHeader;
00872     PVOID Object;
00873     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00874     PVOID WaitObject;
00875 
00876     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00877 
00878     <span class="comment">//</span>
00879     <span class="comment">//  Get a referenced pointer to the specified object with synchronize</span>
00880     <span class="comment">//  access.</span>
00881     <span class="comment">//</span>
00882 
00883     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d7/d1/obref_8c.html#a4">ObReferenceObjectByHandle</a>( <a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a>,
00884                                         SYNCHRONIZE,
00885                                         (<a class="code" href="../../d3/d6/struct__OBJECT__TYPE.html">POBJECT_TYPE</a>)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00886                                         <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
00887                                         &amp;Object,
00888                                         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00889 
00890     <span class="comment">//</span>
00891     <span class="comment">//  If access is granted, then check to determine if the specified object</span>
00892     <span class="comment">//  can be waited on.</span>
00893     <span class="comment">//</span>
00894 
00895     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> ) != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
00896 
00897         ObjectHeader = <a class="code" href="../../d4/d0/ob_8h.html#a8">OBJECT_TO_OBJECT_HEADER</a>( Object );
00898 
00899         <span class="keywordflow">if</span> ((LONG_PTR)ObjectHeader-&gt;<a class="code" href="../../d4/d5/struct__OBJECT__HEADER.html#o3">Type</a>-&gt;<a class="code" href="../../d3/d6/struct__OBJECT__TYPE.html#o3">DefaultObject</a> &lt; 0) {
00900 
00901             WaitObject = (PVOID)ObjectHeader-&gt;<a class="code" href="../../d4/d5/struct__OBJECT__HEADER.html#o3">Type</a>-&gt;<a class="code" href="../../d3/d6/struct__OBJECT__TYPE.html#o3">DefaultObject</a>;
00902 
00903         } <span class="keywordflow">else</span> {
00904 
00905             WaitObject = (PVOID)((PCHAR)Object + (ULONG_PTR)ObjectHeader-&gt;<a class="code" href="../../d4/d5/struct__OBJECT__HEADER.html#o3">Type</a>-&gt;<a class="code" href="../../d3/d6/struct__OBJECT__TYPE.html#o3">DefaultObject</a>);
00906         }
00907 
00908         <span class="comment">//</span>
00909         <span class="comment">//  Protect the wait call just in case KeWait decides</span>
00910         <span class="comment">//  to raise For example, a mutant level is exceeded</span>
00911         <span class="comment">//</span>
00912 
00913         <span class="keywordflow">try</span> {
00914 
00915             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( WaitObject,
00916                                             <a class="code" href="../../d4/d9/ke_8h.html#a407a204">UserRequest</a>,
00917                                             <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
00918                                             Alertable,
00919                                             Timeout );
00920 
00921         } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
00922 
00923             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = GetExceptionCode();
00924         }
00925 
00926         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>(Object);
00927     }
00928 
00929     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00930 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:41:06 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
