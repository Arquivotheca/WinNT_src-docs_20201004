<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: largemcb.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>largemcb.c</h1><a href="../../d1/d1/largemcb_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1989  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    LargeMcb.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    The MCB routines provide support for maintaining an in-memory copy of</span>
00012 <span class="comment">    the retrieval mapping information for a file.  The general idea is to</span>
00013 <span class="comment">    have the file system lookup the retrieval mapping for a VBN once from</span>
00014 <span class="comment">    the disk, add the mapping to the MCB structure, and then utilize the</span>
00015 <span class="comment">    MCB to retrieve the mapping for subsequent accesses to the file.  A</span>
00016 <span class="comment">    variable of type MCB is used to store the mapping information.</span>
00017 <span class="comment"></span>
00018 <span class="comment">    The routines provided here allow the user to incrementally store some</span>
00019 <span class="comment">    or all of the retrieval mapping for a file and to do so in any order.</span>
00020 <span class="comment">    That is, the mapping can be inserted to the MCB structure all at once</span>
00021 <span class="comment">    starting from the beginning and working to the end of the file, or it</span>
00022 <span class="comment">    can be randomly scattered throughout the file.</span>
00023 <span class="comment"></span>
00024 <span class="comment">    The package identifies each contiguous run of sectors mapping VBNs</span>
00025 <span class="comment">    and LBNs indenpendent of the order they are added to the MCB</span>
00026 <span class="comment">    structure.  For example a user can define a mapping between VBN</span>
00027 <span class="comment">    sector 0 and LBN sector 107, and between VBN sector 2 and LBN sector</span>
00028 <span class="comment">    109.  The mapping now contains two runs each one sector in length.</span>
00029 <span class="comment">    Now if the user adds an additional mapping between VBN sector 1 and</span>
00030 <span class="comment">    LBN sector 106 the MCB structure will contain only one run 3 sectors</span>
00031 <span class="comment">    in length.</span>
00032 <span class="comment"></span>
00033 <span class="comment">    Concurrent access to the MCB structure is control by this package.</span>
00034 <span class="comment"></span>
00035 <span class="comment">    The following routines are provided by this package:</span>
00036 <span class="comment"></span>
00037 <span class="comment">      o  FsRtlInitializeMcb - Initialize a new MCB structure.  There</span>
00038 <span class="comment">         should be one MCB for every opened file.  Each MCB structure</span>
00039 <span class="comment">         must be initialized before it can be used by the system.</span>
00040 <span class="comment"></span>
00041 <span class="comment">      o  FsRtlUninitializeMcb - Uninitialize an MCB structure.  This call</span>
00042 <span class="comment">         is used to cleanup any anciallary structures allocated and</span>
00043 <span class="comment">         maintained by the MCB.  After being uninitialized the MCB must</span>
00044 <span class="comment">         again be initialized before it can be used by the system.</span>
00045 <span class="comment"></span>
00046 <span class="comment">      o  FsRtlAddMcbEntry - This routine adds a new range of mappings</span>
00047 <span class="comment">         between LBNs and VBNs to the MCB structure.</span>
00048 <span class="comment"></span>
00049 <span class="comment">      o  FsRtlRemoveMcbEntry - This routines removes an existing range of</span>
00050 <span class="comment">         mappings between LBNs and VBNs from the MCB structure.</span>
00051 <span class="comment"></span>
00052 <span class="comment">      o  FsRtlLookupMcbEntry - This routine returns the LBN mapped to by</span>
00053 <span class="comment">         a VBN, and indicates, in sectors, the length of the run.</span>
00054 <span class="comment"></span>
00055 <span class="comment">      o  FsRtlLookupLastMcbEntry - This routine returns the mapping for</span>
00056 <span class="comment">         the largest VBN stored in the structure.</span>
00057 <span class="comment"></span>
00058 <span class="comment">      o  FsRtlLookupLastMcbEntryAndIndex - This routine returns the mapping</span>
00059 <span class="comment">         for the largest VBN stored in the structure as well as its index</span>
00060 <span class="comment">         Note that calling LookupLastMcbEntry and NumberOfRunsInMcb cannot</span>
00061 <span class="comment">         be synchronized except by the caller.</span>
00062 <span class="comment"></span>
00063 <span class="comment">      o  FsRtlNumberOfRunsInMcb - This routine tells the caller total</span>
00064 <span class="comment">         number of discontiguous sectors runs stored in the MCB</span>
00065 <span class="comment">         structure.</span>
00066 <span class="comment"></span>
00067 <span class="comment">      o  FsRtlGetNextMcbEntry - This routine returns the the caller the</span>
00068 <span class="comment">         starting VBN and LBN of a given run stored in the MCB structure.</span>
00069 <span class="comment"></span>
00070 <span class="comment">Author:</span>
00071 <span class="comment"></span>
00072 <span class="comment">    Gary Kimura     [GaryKi]    5-Feb-1990</span>
00073 <span class="comment"></span>
00074 <span class="comment">Revision History:</span>
00075 <span class="comment"></span>
00076 <span class="comment">--*/</span>
00077 
00078 <span class="preprocessor">#include "FsRtlP.h"</span>
00079 
00080 <span class="comment">//</span>
00081 <span class="comment">//  Trace level for the module</span>
00082 <span class="comment">//</span>
00083 
<a name="l00084"></a><a class="code" href="../../d1/d1/largemcb_8c.html#a0">00084</a> <span class="preprocessor">#define Dbg                              (0x80000000)</span>
00085 <span class="preprocessor"></span>
00086 
00087 <span class="comment">//</span>
00088 <span class="comment">//  Retrieval mapping data structures.  The following two structure together</span>
00089 <span class="comment">//  are used to map a Vbn to an Lbn.  It is layed out as follows:</span>
00090 <span class="comment">//</span>
00091 <span class="comment">//</span>
00092 <span class="comment">//  MCB:</span>
00093 <span class="comment">//      +----------------+----------------+</span>
00094 <span class="comment">//      |    PairCount   |MaximumPairCount|</span>
00095 <span class="comment">//      +----------------+----------------+</span>
00096 <span class="comment">//      |     Mapping    |    PoolType    |</span>
00097 <span class="comment">//      +----------------+----------------+</span>
00098 <span class="comment">//</span>
00099 <span class="comment">//</span>
00100 <span class="comment">//  MAPPING:</span>
00101 <span class="comment">//      +----------------+----------------+</span>
00102 <span class="comment">//      |       Lbn      |    NextVbn     | : 0</span>
00103 <span class="comment">//      +----------------+----------------+</span>
00104 <span class="comment">//      |                                 |</span>
00105 <span class="comment">//      /                                 /</span>
00106 <span class="comment">//      /                                 /</span>
00107 <span class="comment">//      |                                 |</span>
00108 <span class="comment">//      +----------------+----------------+</span>
00109 <span class="comment">//      |       Lbn      |    NextVbn     | : PairCount</span>
00110 <span class="comment">//      +----------------+----------------+</span>
00111 <span class="comment">//      |                                 |</span>
00112 <span class="comment">//      /                                 /</span>
00113 <span class="comment">//      /                                 /</span>
00114 <span class="comment">//      |                                 |</span>
00115 <span class="comment">//      +----------------+----------------+</span>
00116 <span class="comment">//      |       Lbn      |    NextVbn     |</span>
00117 <span class="comment">//      +----------------+----------------+</span>
00118 <span class="comment">//</span>
00119 <span class="comment">//                                          : MaximumPairCount</span>
00120 <span class="comment">//</span>
00121 <span class="comment">//  The pairs from 0 to PairCount - 1 are valid.  Given an index between</span>
00122 <span class="comment">//  0 and PairCount - 1 (inclusive) it represents the following Vbn</span>
00123 <span class="comment">//  to Lbn mapping information</span>
00124 <span class="comment">//</span>
00125 <span class="comment">//</span>
00126 <span class="comment">//                     { if Index == 0 then 0</span>
00127 <span class="comment">//      StartingVbn   {</span>
00128 <span class="comment">//                     { if Index &lt;&gt; 0 then NextVbn[i-1]</span>
00129 <span class="comment">//</span>
00130 <span class="comment">//</span>
00131 <span class="comment">//      EndingVbn      = NextVbn[i] - 1</span>
00132 <span class="comment">//</span>
00133 <span class="comment">//</span>
00134 <span class="comment">//      StartingLbn    = Lbn[i]</span>
00135 <span class="comment">//</span>
00136 <span class="comment">//</span>
00137 <span class="comment">//  To compute the mapping of a Vbn to an Lbn the following algorithm</span>
00138 <span class="comment">//  is used</span>
00139 <span class="comment">//</span>
00140 <span class="comment">//      1. search through the pairs until we find the slot "i" that contains</span>
00141 <span class="comment">//         the Vbn we after.  Report an error if none if found.</span>
00142 <span class="comment">//</span>
00143 <span class="comment">//      2. Lbn = StartingLbn + (Vbn - StartingVbn);</span>
00144 <span class="comment">//</span>
00145 <span class="comment">//  A hole in the allocation (i.e., a sparse allocation) is represented by</span>
00146 <span class="comment">//  an Lbn value of -1 (note that is is different than Mcb.c).</span>
00147 <span class="comment">//</span>
00148 
<a name="l00149"></a><a class="code" href="../../d1/d1/largemcb_8c.html#a1">00149</a> <span class="preprocessor">#define UNUSED_LBN                       (-1)</span>
00150 <span class="preprocessor"></span>
<a name="l00151"></a><a class="code" href="../../d8/d6/struct__MAPPING.html">00151</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d8/d6/struct__MAPPING.html">_MAPPING</a> {
<a name="l00152"></a><a class="code" href="../../d8/d6/struct__MAPPING.html#o0">00152</a>     <a class="code" href="../../d1/d8/fsrtl_8h.html#a52">VBN</a> <a class="code" href="../../d8/d6/struct__MAPPING.html#o0">NextVbn</a>;
<a name="l00153"></a><a class="code" href="../../d8/d6/struct__MAPPING.html#o1">00153</a>     <a class="code" href="../../d1/d8/fsrtl_8h.html#a50">LBN</a> <a class="code" href="../../d8/d6/struct__MAPPING.html#o1">Lbn</a>;
00154 } <a class="code" href="../../d8/d6/struct__MAPPING.html">MAPPING</a>;
<a name="l00155"></a><a class="code" href="../../d1/d1/largemcb_8c.html#a19">00155</a> <span class="keyword">typedef</span> <a class="code" href="../../d8/d6/struct__MAPPING.html">MAPPING</a> *<a class="code" href="../../d8/d6/struct__MAPPING.html">PMAPPING</a>;
00156 
<a name="l00157"></a><a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html">00157</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html">_NONOPAQUE_MCB</a> {
<a name="l00158"></a><a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o0">00158</a>     <a class="code" href="../../d6/d9/struct__FAST__MUTEX.html">PFAST_MUTEX</a> <a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o0">FastMutex</a>;
<a name="l00159"></a><a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o1">00159</a>     ULONG <a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o1">MaximumPairCount</a>;
<a name="l00160"></a><a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o2">00160</a>     ULONG <a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o2">PairCount</a>;
<a name="l00161"></a><a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o3">00161</a>     <a class="code" href="../../d5/d8/ex_8h.html#a96">POOL_TYPE</a> <a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o3">PoolType</a>;
<a name="l00162"></a><a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o4">00162</a>     <a class="code" href="../../d1/d1/largemcb_8c.html#a19">PMAPPING</a> <a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o4">Mapping</a>;
00163 } <a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html">NONOPAQUE_MCB</a>;
<a name="l00164"></a><a class="code" href="../../d1/d1/largemcb_8c.html#a21">00164</a> <span class="keyword">typedef</span> <a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html">NONOPAQUE_MCB</a> *<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html">PNONOPAQUE_MCB</a>;
00165 
00166 <span class="comment">//</span>
00167 <span class="comment">//  A macro to return the size, in bytes, of a retrieval mapping structure</span>
00168 <span class="comment">//</span>
00169 
<a name="l00170"></a><a class="code" href="../../d1/d1/largemcb_8c.html#a2">00170</a> <span class="preprocessor">#define SizeOfMapping(MCB) ((sizeof(MAPPING) * (MCB)-&gt;MaximumPairCount))</span>
00171 <span class="preprocessor"></span>
00172 <span class="comment">//</span>
00173 <span class="comment">//  The parts of a run can be computed as follows:</span>
00174 <span class="comment">//</span>
00175 <span class="comment">//</span>
00176 <span class="comment">//                StartingVbn(MCB,I)           Mapping[I].NextVbn</span>
00177 <span class="comment">//                       |                             |</span>
00178 <span class="comment">//                       V                             V</span>
00179 <span class="comment">//</span>
00180 <span class="comment">//        Run-(I-1)---+ +---------Run-(I)-----------+ +---Run-(I+1)</span>
00181 <span class="comment">//</span>
00182 <span class="comment">//                       A                         A</span>
00183 <span class="comment">//                       |                         |</span>
00184 <span class="comment">//                 Mapping[I].Lbn            EndingLbn(MCB,I)</span>
00185 <span class="comment">//</span>
00186 
<a name="l00187"></a><a class="code" href="../../d1/d1/largemcb_8c.html#a3">00187</a> <span class="preprocessor">#define PreviousEndingVbn(MCB,I) (                      \</span>
00188 <span class="preprocessor">    (VBN)((I) == 0 ? 0xffffffff : EndingVbn(MCB,(I)-1)) \</span>
00189 <span class="preprocessor">)</span>
00190 <span class="preprocessor"></span>
<a name="l00191"></a><a class="code" href="../../d1/d1/largemcb_8c.html#a4">00191</a> <span class="preprocessor">#define StartingVbn(MCB,I) (                                \</span>
00192 <span class="preprocessor">    (VBN)((I) == 0 ? 0 : (((MCB)-&gt;Mapping))[(I)-1].NextVbn) \</span>
00193 <span class="preprocessor">)</span>
00194 <span class="preprocessor"></span>
<a name="l00195"></a><a class="code" href="../../d1/d1/largemcb_8c.html#a5">00195</a> <span class="preprocessor">#define EndingVbn(MCB,I) (                     \</span>
00196 <span class="preprocessor">    (VBN)((((MCB)-&gt;Mapping)[(I)].NextVbn) - 1) \</span>
00197 <span class="preprocessor">)</span>
00198 <span class="preprocessor"></span>
<a name="l00199"></a><a class="code" href="../../d1/d1/largemcb_8c.html#a6">00199</a> <span class="preprocessor">#define NextStartingVbn(MCB,I) (                                \</span>
00200 <span class="preprocessor">    (VBN)((I) &gt;= (MCB)-&gt;PairCount ? 0 : StartingVbn(MCB,(I)+1)) \</span>
00201 <span class="preprocessor">)</span>
00202 <span class="preprocessor"></span>
00203 
00204 
00205 
<a name="l00206"></a><a class="code" href="../../d1/d1/largemcb_8c.html#a7">00206</a> <span class="preprocessor">#define PreviousEndingLbn(MCB,I) (                      \</span>
00207 <span class="preprocessor">    (LBN)((I) == 0 ? UNUSED_LBN : EndingLbn(MCB,(I)-1)) \</span>
00208 <span class="preprocessor">)</span>
00209 <span class="preprocessor"></span>
<a name="l00210"></a><a class="code" href="../../d1/d1/largemcb_8c.html#a8">00210</a> <span class="preprocessor">#define StartingLbn(MCB,I) (         \</span>
00211 <span class="preprocessor">    (LBN)(((MCB)-&gt;Mapping)[(I)].Lbn) \</span>
00212 <span class="preprocessor">)</span>
00213 <span class="preprocessor"></span>
<a name="l00214"></a><a class="code" href="../../d1/d1/largemcb_8c.html#a9">00214</a> <span class="preprocessor">#define EndingLbn(MCB,I) (                                       \</span>
00215 <span class="preprocessor">    (LBN)(StartingLbn(MCB,I) == UNUSED_LBN ?                     \</span>
00216 <span class="preprocessor">          UNUSED_LBN :                                           \</span>
00217 <span class="preprocessor">          ((MCB)-&gt;Mapping[(I)].Lbn +                             \</span>
00218 <span class="preprocessor">           (MCB)-&gt;Mapping[(I)].NextVbn - StartingVbn(MCB,I) - 1) \</span>
00219 <span class="preprocessor">         )                                                       \</span>
00220 <span class="preprocessor">)</span>
00221 <span class="preprocessor"></span>
<a name="l00222"></a><a class="code" href="../../d1/d1/largemcb_8c.html#a10">00222</a> <span class="preprocessor">#define NextStartingLbn(MCB,I) (                                             \</span>
00223 <span class="preprocessor">    (LBN)((I) &gt;= (MCB)-&gt;PairCount - 1 ? UNUSED_LBN : StartingLbn(MCB,(I)+1)) \</span>
00224 <span class="preprocessor">)</span>
00225 <span class="preprocessor"></span>
00226 <span class="preprocessor">#if 0</span>
00227 <span class="preprocessor"></span><a class="code" href="../../d1/d8/fsrtl_8h.html#a50">LBN</a>
00228 <a class="code" href="../../d1/d1/largemcb_8c.html#a10">NextStartingLbn</a>(
00229     PNONOPAQUE_MCB Mcb,
00230     ULONG I
00231     )
00232 {
00233     <span class="keywordflow">if</span> ( I &gt;= Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o2">PairCount</a> - 1 ) {
00234         <span class="keywordflow">return</span> (<a class="code" href="../../d1/d8/fsrtl_8h.html#a50">LBN</a>)<a class="code" href="../../d1/d1/largemcb_8c.html#a1">UNUSED_LBN</a>;
00235         }
00236     <span class="keywordflow">else</span> {
00237         <span class="keywordflow">return</span> <a class="code" href="../../d1/d1/largemcb_8c.html#a8">StartingLbn</a>(Mcb,I+1);
00238         }
00239 }
00240 <span class="preprocessor">#endif</span>
00241 <span class="preprocessor"></span>
<a name="l00242"></a><a class="code" href="../../d1/d1/largemcb_8c.html#a11">00242</a> <span class="preprocessor">#define SectorsWithinRun(MCB,I) (                      \</span>
00243 <span class="preprocessor">    (ULONG)(EndingVbn(MCB,I) - StartingVbn(MCB,I) + 1) \</span>
00244 <span class="preprocessor">)</span>
00245 <span class="preprocessor"></span>
00246 <span class="comment">//</span>
00247 <span class="comment">//  Define a tag for general pool allocations from this module</span>
00248 <span class="comment">//</span>
00249 
00250 <span class="preprocessor">#undef MODULE_POOL_TAG</span>
<a name="l00251"></a><a class="code" href="../../d1/d1/largemcb_8c.html#a12">00251</a> <span class="preprocessor"></span><span class="preprocessor">#define MODULE_POOL_TAG                  ('mrSF')</span>
00252 <span class="preprocessor"></span>
00253 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00254 <a class="code" href="../../d1/d1/largemcb_8c.html#a24">FsRtlRemoveMcbEntryPrivate</a> (
00255     IN PNONOPAQUE_MCB OpaqueMcb,
00256     IN ULONG Vbn,
00257     IN ULONG SectorCount
00258     );
00259 
00260 <span class="comment">//</span>
00261 <span class="comment">//  A private routine to search a mapping structure for a Vbn</span>
00262 <span class="comment">//</span>
00263 
00264 BOOLEAN
00265 <a class="code" href="../../d1/d1/largemcb_8c.html#a25">FsRtlFindLargeIndex</a> (
00266     IN PNONOPAQUE_MCB Mcb,
00267     IN VBN Vbn,
00268     OUT PULONG Index
00269     );
00270 
00271 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00272 <a class="code" href="../../d1/d1/largemcb_8c.html#a26">FsRtlAddLargeEntry</a> (
00273     IN PNONOPAQUE_MCB Mcb,
00274     IN ULONG WhereToAddIndex,
00275     IN ULONG AmountToAdd
00276     );
00277 
00278 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00279 <a class="code" href="../../d1/d1/largemcb_8c.html#a27">FsRtlRemoveLargeEntry</a> (
00280     IN PNONOPAQUE_MCB Mcb,
00281     IN ULONG WhereToRemoveIndex,
00282     IN ULONG AmountToRemove
00283     );
00284 
00285 <span class="comment">//</span>
00286 <span class="comment">//  Some private routines to handle common allocations.</span>
00287 <span class="comment">//</span>
00288 
<a name="l00289"></a><a class="code" href="../../d1/d1/largemcb_8c.html#a13">00289</a> <span class="preprocessor">#define FsRtlAllocateFirstMapping() \</span>
00290 <span class="preprocessor">    (PVOID)ExAllocateFromPagedLookasideList( &amp;FsRtlFirstMappingLookasideList )</span>
00291 <span class="preprocessor"></span>
<a name="l00292"></a><a class="code" href="../../d1/d1/largemcb_8c.html#a14">00292</a> <span class="preprocessor">#define FsRtlFreeFirstMapping(Mapping) \</span>
00293 <span class="preprocessor">    ExFreeToPagedLookasideList( &amp;FsRtlFirstMappingLookasideList, (Mapping) )</span>
00294 <span class="preprocessor"></span>
<a name="l00295"></a><a class="code" href="../../d1/d1/largemcb_8c.html#a15">00295</a> <span class="preprocessor">#define FsRtlAllocateFastMutex()      \</span>
00296 <span class="preprocessor">    (PFAST_MUTEX)ExAllocateFromNPagedLookasideList( &amp;FsRtlFastMutexLookasideList )</span>
00297 <span class="preprocessor"></span>
<a name="l00298"></a><a class="code" href="../../d1/d1/largemcb_8c.html#a16">00298</a> <span class="preprocessor">#define FsRtlFreeFastMutex(FastMutex) \</span>
00299 <span class="preprocessor">    ExFreeToNPagedLookasideList( &amp;FsRtlFastMutexLookasideList, (FastMutex) )</span>
00300 <span class="preprocessor"></span>
00301 <span class="preprocessor">#ifdef ALLOC_PRAGMA</span>
00302 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, FsRtlInitializeLargeMcbs)</span>
00303 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, FsRtlInitializeMcb)</span>
00304 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, FsRtlUninitializeMcb)</span>
00305 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00306 <span class="preprocessor"></span>
00307 
00308 <span class="comment">//</span>
00309 <span class="comment">//  Define a small cache of free mapping pairs structures and also the</span>
00310 <span class="comment">//  initial size of the mapping pair</span>
00311 <span class="comment">//</span>
00312 
<a name="l00313"></a><a class="code" href="../../d1/d1/largemcb_8c.html#a17">00313</a> <span class="preprocessor">#define INITIAL_MAXIMUM_PAIR_COUNT       (15)</span>
00314 <span class="preprocessor"></span>
<a name="l00315"></a><a class="code" href="../../d1/d1/largemcb_8c.html#a22">00315</a> <a class="code" href="../../d1/d8/struct__PAGED__LOOKASIDE__LIST.html">PAGED_LOOKASIDE_LIST</a> <a class="code" href="../../d1/d1/largemcb_8c.html#a22">FsRtlFirstMappingLookasideList</a>;
00316 
00317 <span class="comment">//</span>
00318 <span class="comment">//  The following lookaside is used to keep all the Fast Mutexes we will need to</span>
00319 <span class="comment">//  boot contiguous.</span>
00320 <span class="comment">//</span>
00321 
<a name="l00322"></a><a class="code" href="../../d1/d1/largemcb_8c.html#a23">00322</a> <a class="code" href="../../d1/d4/struct__NPAGED__LOOKASIDE__LIST.html">NPAGED_LOOKASIDE_LIST</a> <a class="code" href="../../d1/d1/largemcb_8c.html#a23">FsRtlFastMutexLookasideList</a>;
00323 
00324 
00325 <span class="comment">//</span>
00326 <span class="comment">//  The following few routines define the small mcb package which is</span>
00327 <span class="comment">//  implemented behind everyones back as large mcbs.  The only funny</span>
00328 <span class="comment">//  thing we really need to do here is to make sure that unused Lbns</span>
00329 <span class="comment">//  get returned as 0 and not -1.  This is the result of an historical</span>
00330 <span class="comment">//  difference between the original Mcb and LargeMcb packages.</span>
00331 <span class="comment">//</span>
00332 
00333 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00334"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a151">00334</a> <a class="code" href="../../d1/d8/fsrtl_8h.html#a151">FsRtlInitializeMcb</a> (
00335     IN <a class="code" href="../../d2/d7/struct__MCB.html">PMCB</a> Mcb,
00336     IN POOL_TYPE PoolType
00337     )
00338 {
00339     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00340 
00341     <a class="code" href="../../d1/d8/fsrtl_8h.html#a139">FsRtlInitializeLargeMcb</a>( (<a class="code" href="../../d0/d9/struct__LARGE__MCB.html">PLARGE_MCB</a>)Mcb,
00342                              PoolType );
00343 
00344     <span class="keywordflow">return</span>;
00345 }
00346 
00347 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00348"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a152">00348</a> <a class="code" href="../../d1/d8/fsrtl_8h.html#a152">FsRtlUninitializeMcb</a> (
00349     IN <a class="code" href="../../d2/d7/struct__MCB.html">PMCB</a> Mcb
00350     )
00351 
00352 {
00353     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00354 
00355     <a class="code" href="../../d1/d8/fsrtl_8h.html#a140">FsRtlUninitializeLargeMcb</a>( (<a class="code" href="../../d0/d9/struct__LARGE__MCB.html">PLARGE_MCB</a>)Mcb );
00356 
00357     <span class="keywordflow">return</span>;
00358 }
00359 
00360 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00361"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a153">00361</a> <a class="code" href="../../d1/d8/fsrtl_8h.html#a153">FsRtlTruncateMcb</a> (
00362     IN <a class="code" href="../../d2/d7/struct__MCB.html">PMCB</a> Mcb,
00363     IN VBN Vbn
00364     )
00365 {
00366    <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00367 
00368    <a class="code" href="../../d1/d8/fsrtl_8h.html#a142">FsRtlTruncateLargeMcb</a>( (<a class="code" href="../../d0/d9/struct__LARGE__MCB.html">PLARGE_MCB</a>)Mcb,
00369                           (LONGLONG)(Vbn) );
00370 
00371    <span class="keywordflow">return</span>;
00372 }
00373 
00374 BOOLEAN
<a name="l00375"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a154">00375</a> <a class="code" href="../../d1/d8/fsrtl_8h.html#a154">FsRtlAddMcbEntry</a> (
00376     IN <a class="code" href="../../d2/d7/struct__MCB.html">PMCB</a> Mcb,
00377     IN VBN Vbn,
00378     IN LBN Lbn,
00379     IN ULONG SectorCount
00380     )
00381 
00382 {
00383     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00384 
00385     <span class="keywordflow">return</span> <a class="code" href="../../d1/d8/fsrtl_8h.html#a143">FsRtlAddLargeMcbEntry</a>( (<a class="code" href="../../d0/d9/struct__LARGE__MCB.html">PLARGE_MCB</a>)Mcb,
00386                                   (LONGLONG)(Vbn),
00387                                   (LONGLONG)(Lbn),
00388                                   (LONGLONG)(SectorCount) );
00389 }
00390 
00391 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00392"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a155">00392</a> <a class="code" href="../../d1/d8/fsrtl_8h.html#a155">FsRtlRemoveMcbEntry</a> (
00393     IN <a class="code" href="../../d2/d7/struct__MCB.html">PMCB</a> OpaqueMcb,
00394     IN VBN Vbn,
00395     IN ULONG SectorCount
00396     )
00397 
00398 {
00399     <a class="code" href="../../d1/d1/largemcb_8c.html#a21">PNONOPAQUE_MCB</a> Mcb = (<a class="code" href="../../d1/d1/largemcb_8c.html#a21">PNONOPAQUE_MCB</a>)OpaqueMcb;
00400 
00401     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00402 
00403     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlRemoveMcbEntry, Mcb = %08lx\n"</span>, Mcb );
00404     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">" Vbn         = %08lx\n"</span>, Vbn );
00405     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">" SectorCount = %08lx\n"</span>, SectorCount );
00406 
00407     ExAcquireFastMutex( Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o0">FastMutex</a> );
00408 
00409     <span class="keywordflow">try</span> {
00410 
00411         <a class="code" href="../../d1/d1/largemcb_8c.html#a24">FsRtlRemoveMcbEntryPrivate</a>( Mcb,
00412                                     Vbn,
00413                                     SectorCount );
00414 
00415     } finally {
00416 
00417         ExReleaseFastMutex( Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o0">FastMutex</a> );
00418 
00419         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlRemoveMcbEntry -&gt; VOID\n"</span>, 0 );
00420     }
00421 
00422     <span class="keywordflow">return</span>;
00423 }
00424 
00425 BOOLEAN
<a name="l00426"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a156">00426</a> <a class="code" href="../../d1/d8/fsrtl_8h.html#a156">FsRtlLookupMcbEntry</a> (
00427     IN <a class="code" href="../../d2/d7/struct__MCB.html">PMCB</a> Mcb,
00428     IN VBN Vbn,
00429     OUT PLBN Lbn,
00430     OUT PULONG SectorCount OPTIONAL,
00431     OUT PULONG Index OPTIONAL
00432     )
00433 
00434 {
00435     BOOLEAN Results;
00436     LONGLONG LiLbn;
00437     LONGLONG LiSectorCount;
00438 
00439     Results = <a class="code" href="../../d1/d8/fsrtl_8h.html#a145">FsRtlLookupLargeMcbEntry</a>( (<a class="code" href="../../d0/d9/struct__LARGE__MCB.html">PLARGE_MCB</a>)Mcb,
00440                                         (LONGLONG)(Vbn),
00441                                         &amp;LiLbn,
00442                                         ARGUMENT_PRESENT(SectorCount) ? &amp;LiSectorCount : <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00443                                         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00444                                         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00445                                         <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> );
00446 
00447     *Lbn = (((ULONG)LiLbn) == -1 ? 0 : ((ULONG)LiLbn));
00448 
00449     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(SectorCount)) { *SectorCount = ((ULONG)LiSectorCount); }
00450 
00451     <span class="keywordflow">return</span> Results;
00452 }
00453 
00454 BOOLEAN
<a name="l00455"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a157">00455</a> <a class="code" href="../../d1/d8/fsrtl_8h.html#a157">FsRtlLookupLastMcbEntry</a> (
00456     IN <a class="code" href="../../d2/d7/struct__MCB.html">PMCB</a> Mcb,
00457     OUT PVBN Vbn,
00458     OUT PLBN Lbn
00459     )
00460 
00461 {
00462     BOOLEAN Results;
00463     LONGLONG LiVbn;
00464     LONGLONG LiLbn;
00465 
00466     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00467 
00468     Results = <a class="code" href="../../d1/d8/fsrtl_8h.html#a146">FsRtlLookupLastLargeMcbEntry</a>( (<a class="code" href="../../d0/d9/struct__LARGE__MCB.html">PLARGE_MCB</a>)Mcb,
00469                                             &amp;LiVbn,
00470                                             &amp;LiLbn );
00471 
00472     *Vbn = ((ULONG)LiVbn);
00473     *Lbn = (((ULONG)LiLbn) == -1 ? 0 : ((ULONG)LiLbn));
00474 
00475     <span class="keywordflow">return</span> Results;
00476 }
00477 
00478 ULONG
<a name="l00479"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a158">00479</a> <a class="code" href="../../d1/d8/fsrtl_8h.html#a158">FsRtlNumberOfRunsInMcb</a> (
00480     IN <a class="code" href="../../d2/d7/struct__MCB.html">PMCB</a> Mcb
00481     )
00482 
00483 {
00484     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00485 
00486     <span class="keywordflow">return</span> <a class="code" href="../../d1/d8/fsrtl_8h.html#a148">FsRtlNumberOfRunsInLargeMcb</a>( (<a class="code" href="../../d0/d9/struct__LARGE__MCB.html">PLARGE_MCB</a>)Mcb );
00487 }
00488 
00489 BOOLEAN
<a name="l00490"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a159">00490</a> <a class="code" href="../../d1/d8/fsrtl_8h.html#a159">FsRtlGetNextMcbEntry</a> (
00491     IN <a class="code" href="../../d2/d7/struct__MCB.html">PMCB</a> Mcb,
00492     IN ULONG RunIndex,
00493     OUT PVBN Vbn,
00494     OUT PLBN Lbn,
00495     OUT PULONG SectorCount
00496     )
00497 
00498 {
00499     BOOLEAN Results;
00500     LONGLONG LiVbn;
00501     LONGLONG LiLbn;
00502     LONGLONG LiSectorCount;
00503 
00504     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00505 
00506     Results = <a class="code" href="../../d1/d8/fsrtl_8h.html#a149">FsRtlGetNextLargeMcbEntry</a>( (<a class="code" href="../../d0/d9/struct__LARGE__MCB.html">PLARGE_MCB</a>)Mcb,
00507                                          RunIndex,
00508                                          &amp;LiVbn,
00509                                          &amp;LiLbn,
00510                                          &amp;LiSectorCount );
00511 
00512     *Vbn = ((ULONG)LiVbn);
00513     *Lbn = (((ULONG)LiLbn) == -1 ? 0 : ((ULONG)LiLbn));
00514     *SectorCount = ((ULONG)LiSectorCount);
00515 
00516     <span class="keywordflow">return</span> Results;
00517 }
00518 
00519 
00520 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00521"></a><a class="code" href="../../d1/d1/largemcb_8c.html#a37">00521</a> <a class="code" href="../../d1/d1/largemcb_8c.html#a37">FsRtlInitializeLargeMcbs</a> (
00522     VOID
00523     )
00524 
00525 <span class="comment">/*++</span>
00526 <span class="comment"></span>
00527 <span class="comment">Routine Description:</span>
00528 <span class="comment"></span>
00529 <span class="comment">    This routine initializes the global portion of the large mcb package</span>
00530 <span class="comment">    at system initialization time.</span>
00531 <span class="comment"></span>
00532 <span class="comment">Arguments:</span>
00533 <span class="comment"></span>
00534 <span class="comment">    None.</span>
00535 <span class="comment"></span>
00536 <span class="comment">Return Value:</span>
00537 <span class="comment"></span>
00538 <span class="comment">    None.</span>
00539 <span class="comment"></span>
00540 <span class="comment">--*/</span>
00541 
00542 {
00543     <span class="comment">//</span>
00544     <span class="comment">//  Initialize the lookaside of paged initial mapping arrays.</span>
00545     <span class="comment">//</span>
00546 
00547     <a class="code" href="../../d5/d8/ex_8h.html#a250">ExInitializePagedLookasideList</a>( &amp;<a class="code" href="../../d1/d1/largemcb_8c.html#a22">FsRtlFirstMappingLookasideList</a>,
00548                                     <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00549                                     <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00550                                     <a class="code" href="../../d5/d8/ex_8h.html#a3">POOL_RAISE_IF_ALLOCATION_FAILURE</a>,
00551                                     <span class="keyword">sizeof</span>( <a class="code" href="../../d8/d6/struct__MAPPING.html">MAPPING</a> ) * <a class="code" href="../../d1/d1/largemcb_8c.html#a17">INITIAL_MAXIMUM_PAIR_COUNT</a>,
00552                                     'miSF',
00553                                     4 );
00554 
00555     <span class="comment">//</span>
00556     <span class="comment">//  Initialize the Fast Mutex lookaside list.</span>
00557     <span class="comment">//</span>
00558 
00559     <a class="code" href="../../d5/d8/ex_8h.html#a246">ExInitializeNPagedLookasideList</a>( &amp;<a class="code" href="../../d1/d1/largemcb_8c.html#a23">FsRtlFastMutexLookasideList</a>,
00560                                      <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00561                                      <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00562                                      <a class="code" href="../../d5/d8/ex_8h.html#a3">POOL_RAISE_IF_ALLOCATION_FAILURE</a>,
00563                                      <span class="keyword">sizeof</span>( <a class="code" href="../../d6/d9/struct__FAST__MUTEX.html">FAST_MUTEX</a>),
00564                                      'mfSF',
00565                                      32 );
00566 
00567 
00568 }
00569 
00570 
00571 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00572"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a139">00572</a> <a class="code" href="../../d1/d8/fsrtl_8h.html#a139">FsRtlInitializeLargeMcb</a> (
00573     IN <a class="code" href="../../d0/d9/struct__LARGE__MCB.html">PLARGE_MCB</a> OpaqueMcb,
00574     IN POOL_TYPE PoolType
00575     )
00576 
00577 <span class="comment">/*++</span>
00578 <span class="comment"></span>
00579 <span class="comment">Routine Description:</span>
00580 <span class="comment"></span>
00581 <span class="comment">    This routine initializes a new Mcb structure.  The caller must</span>
00582 <span class="comment">    supply the memory for the Mcb structure.  This call must precede all</span>
00583 <span class="comment">    other calls that set/query the Mcb structure.</span>
00584 <span class="comment"></span>
00585 <span class="comment">    If pool is not available this routine will raise a status value</span>
00586 <span class="comment">    indicating insufficient resources.</span>
00587 <span class="comment"></span>
00588 <span class="comment">Arguments:</span>
00589 <span class="comment"></span>
00590 <span class="comment">    OpaqueMcb - Supplies a pointer to the Mcb structure to initialize.</span>
00591 <span class="comment"></span>
00592 <span class="comment">    PoolType - Supplies the pool type to use when allocating additional</span>
00593 <span class="comment">        internal Mcb memory.</span>
00594 <span class="comment"></span>
00595 <span class="comment">Return Value:</span>
00596 <span class="comment"></span>
00597 <span class="comment">    None.</span>
00598 <span class="comment"></span>
00599 <span class="comment">--*/</span>
00600 
00601 {
00602     <a class="code" href="../../d1/d1/largemcb_8c.html#a21">PNONOPAQUE_MCB</a> Mcb = (<a class="code" href="../../d1/d1/largemcb_8c.html#a21">PNONOPAQUE_MCB</a>)OpaqueMcb;
00603 
00604     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlInitializeLargeMcb, Mcb = %08lx\n"</span>, Mcb );
00605 
00606     <span class="comment">//</span>
00607     <span class="comment">//  Preset the following fields to null so we know to deallocate them</span>
00608     <span class="comment">//  during an abnormal termination</span>
00609     <span class="comment">//</span>
00610 
00611     Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o0">FastMutex</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00612     Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o4">Mapping</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00613 
00614     <span class="keywordflow">try</span> {
00615 
00616         <span class="comment">//</span>
00617         <span class="comment">//  Initialize the fields in the Mcb</span>
00618         <span class="comment">//</span>
00619 
00620         Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o0">FastMutex</a> = <a class="code" href="../../d1/d1/largemcb_8c.html#a15">FsRtlAllocateFastMutex</a>();
00621 
00622         <a class="code" href="../../d5/d8/ex_8h.html#a8">ExInitializeFastMutex</a>( Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o0">FastMutex</a> );
00623 
00624         Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o2">PairCount</a> = 0;
00625         Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o3">PoolType</a> = PoolType;
00626 
00627         <span class="comment">//</span>
00628         <span class="comment">//  Allocate a new buffer an initial size is one that will hold</span>
00629         <span class="comment">//  16 runs</span>
00630         <span class="comment">//</span>
00631 
00632         <span class="keywordflow">if</span> (PoolType == <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>) {
00633 
00634             Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o4">Mapping</a> = <a class="code" href="../../d1/d1/largemcb_8c.html#a13">FsRtlAllocateFirstMapping</a>();
00635 
00636         } <span class="keywordflow">else</span> {
00637 
00638             Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o4">Mapping</a> = <a class="code" href="../../d3/d8/fsrtlp_8h.html#a2">FsRtlpAllocatePool</a>( Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o3">PoolType</a>, <span class="keyword">sizeof</span>(<a class="code" href="../../d8/d6/struct__MAPPING.html">MAPPING</a>) * <a class="code" href="../../d1/d1/largemcb_8c.html#a17">INITIAL_MAXIMUM_PAIR_COUNT</a> );
00639         }
00640 
00641         <span class="comment">//**** RtlZeroMemory( Mcb-&gt;Mapping, sizeof(MAPPING) * INITIAL_MAXIMUM_PAIR_COUNT );</span>
00642 
00643         Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o1">MaximumPairCount</a> = <a class="code" href="../../d1/d1/largemcb_8c.html#a17">INITIAL_MAXIMUM_PAIR_COUNT</a>;
00644 
00645     } finally {
00646 
00647         <span class="comment">//</span>
00648         <span class="comment">//  If this is an abnormal termination then we need to deallocate</span>
00649         <span class="comment">//  the FastMutex and/or mapping (but once the mapping is allocated,</span>
00650         <span class="comment">//  we can't raise).</span>
00651         <span class="comment">//</span>
00652 
00653         <span class="keywordflow">if</span> (AbnormalTermination()) {
00654 
00655             <span class="keywordflow">if</span> (Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o0">FastMutex</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) { <a class="code" href="../../d1/d1/largemcb_8c.html#a16">FsRtlFreeFastMutex</a>( Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o0">FastMutex</a> ); }
00656         }
00657 
00658         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlInitializeLargeMcb -&gt; VOID\n"</span>, 0 );
00659     }
00660 
00661     <span class="comment">//</span>
00662     <span class="comment">//  And return to our caller</span>
00663     <span class="comment">//</span>
00664 
00665     <span class="keywordflow">return</span>;
00666 }
00667 
00668 
00669 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00670"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a140">00670</a> <a class="code" href="../../d1/d8/fsrtl_8h.html#a140">FsRtlUninitializeLargeMcb</a> (
00671     IN <a class="code" href="../../d0/d9/struct__LARGE__MCB.html">PLARGE_MCB</a> OpaqueMcb
00672     )
00673 
00674 <span class="comment">/*++</span>
00675 <span class="comment"></span>
00676 <span class="comment">Routine Description:</span>
00677 <span class="comment"></span>
00678 <span class="comment">    This routine uninitializes an Mcb structure.  After calling this routine</span>
00679 <span class="comment">    the input Mcb structure must be re-initialized before being used again.</span>
00680 <span class="comment"></span>
00681 <span class="comment">Arguments:</span>
00682 <span class="comment"></span>
00683 <span class="comment">    OpaqueMcb - Supplies a pointer to the Mcb structure to uninitialize.</span>
00684 <span class="comment"></span>
00685 <span class="comment">Return Value:</span>
00686 <span class="comment"></span>
00687 <span class="comment">    None.</span>
00688 <span class="comment"></span>
00689 <span class="comment">--*/</span>
00690 
00691 {
00692     <a class="code" href="../../d1/d1/largemcb_8c.html#a21">PNONOPAQUE_MCB</a> Mcb = (<a class="code" href="../../d1/d1/largemcb_8c.html#a21">PNONOPAQUE_MCB</a>)OpaqueMcb;
00693 
00694     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlUninitializeLargeMcb, Mcb = %08lx\n"</span>, Mcb );
00695 
00696     <span class="comment">//</span>
00697     <span class="comment">//  Protect against some user calling us to uninitialize an mcb twice</span>
00698     <span class="comment">//</span>
00699 
00700     <span class="keywordflow">if</span> (Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o0">FastMutex</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00701 
00702         <span class="comment">// ASSERTMSG("Being called to uninitialize an Mcb that is already Uninitialized ", FALSE);</span>
00703 
00704         <span class="keywordflow">return</span>;
00705     }
00706 
00707     <span class="comment">//</span>
00708     <span class="comment">//  Deallocate the FastMutex and mapping buffer</span>
00709     <span class="comment">//</span>
00710 
00711     <a class="code" href="../../d1/d1/largemcb_8c.html#a16">FsRtlFreeFastMutex</a>( Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o0">FastMutex</a> );
00712 
00713     Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o0">FastMutex</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00714 
00715     <span class="keywordflow">if</span> ((Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o3">PoolType</a> == <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>) &amp;&amp; (Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o1">MaximumPairCount</a> == <a class="code" href="../../d1/d1/largemcb_8c.html#a17">INITIAL_MAXIMUM_PAIR_COUNT</a>)) {
00716 
00717         <a class="code" href="../../d1/d1/largemcb_8c.html#a14">FsRtlFreeFirstMapping</a>( Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o4">Mapping</a> );
00718 
00719     } <span class="keywordflow">else</span> {
00720 
00721         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o4">Mapping</a> );
00722     }
00723 
00724     <span class="comment">//</span>
00725     <span class="comment">//  Now zero our all of the fields in the Mcb</span>
00726     <span class="comment">//</span>
00727 
00728     <span class="comment">//**** Mcb-&gt;MaximumPairCount = 0;</span>
00729     <span class="comment">//**** Mcb-&gt;PairCount = 0;</span>
00730     <span class="comment">//**** Mcb-&gt;Mapping = NULL;</span>
00731 
00732     <span class="comment">//</span>
00733     <span class="comment">//  And return to our caller</span>
00734     <span class="comment">//</span>
00735 
00736     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlUninitializeLargeMcb -&gt; VOID\n"</span>, 0 );
00737 
00738     <span class="keywordflow">return</span>;
00739 }
00740 
00741 
00742 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00743"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a142">00743</a> <a class="code" href="../../d1/d8/fsrtl_8h.html#a142">FsRtlTruncateLargeMcb</a> (
00744     IN <a class="code" href="../../d0/d9/struct__LARGE__MCB.html">PLARGE_MCB</a> OpaqueMcb,
00745     IN LONGLONG LargeVbn
00746     )
00747 
00748 <span class="comment">/*++</span>
00749 <span class="comment"></span>
00750 <span class="comment">Routine Description:</span>
00751 <span class="comment"></span>
00752 <span class="comment">    This routine truncates an Mcb structure to the specified Vbn.</span>
00753 <span class="comment">    After calling this routine the Mcb will only contain mappings</span>
00754 <span class="comment">    up to and not including the input vbn.</span>
00755 <span class="comment"></span>
00756 <span class="comment">Arguments:</span>
00757 <span class="comment"></span>
00758 <span class="comment">    OpaqueMcb - Supplies a pointer to the Mcb structure to truncate.</span>
00759 <span class="comment"></span>
00760 <span class="comment">    LargeVbn - Specifies the last Vbn at which is no longer to be</span>
00761 <span class="comment">      mapped.</span>
00762 <span class="comment"></span>
00763 <span class="comment">Return Value:</span>
00764 <span class="comment"></span>
00765 <span class="comment">    None.</span>
00766 <span class="comment"></span>
00767 <span class="comment">--*/</span>
00768 
00769 {
00770     <a class="code" href="../../d1/d1/largemcb_8c.html#a21">PNONOPAQUE_MCB</a> Mcb = (<a class="code" href="../../d1/d1/largemcb_8c.html#a21">PNONOPAQUE_MCB</a>)OpaqueMcb;
00771 
00772     <a class="code" href="../../d1/d8/fsrtl_8h.html#a52">VBN</a> Vbn = ((ULONG)LargeVbn);
00773     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
00774 
00775     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00776 
00777     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlTruncateLargeMcb, Mcb = %08lx\n"</span>, Mcb );
00778 
00779     ExAcquireFastMutex( Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o0">FastMutex</a> );
00780 
00781     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a8">ASSERTMSG</a>(<span class="stringliteral">"LargeInteger not supported yet "</span>, ((((PLARGE_INTEGER)&amp;LargeVbn)-&gt;HighPart == 0) ||
00782                                                   (Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o2">PairCount</a> == 0) ||
00783                                                   ((((PLARGE_INTEGER)&amp;LargeVbn)-&gt;HighPart == 0x7FFFFFFF) &amp;&amp;
00784                                                    (((ULONG)LargeVbn) == 0xFFFFFFFF))));
00785 
00786     <span class="keywordflow">try</span> {
00787 
00788         <span class="comment">//</span>
00789         <span class="comment">//  Do a quick test to see if we are truncating the entire Mcb.</span>
00790         <span class="comment">//</span>
00791 
00792         <span class="keywordflow">if</span> (Vbn == 0) {
00793 
00794             Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o2">PairCount</a> = 0;
00795 
00796         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o2">PairCount</a> &gt; 0) {
00797 
00798             <span class="comment">//</span>
00799             <span class="comment">//  Find the index for the entry with the last Vcn we want to keep.</span>
00800             <span class="comment">//  There is nothing to do if the Mcb already ends prior to</span>
00801             <span class="comment">//  this point.</span>
00802             <span class="comment">//</span>
00803 
00804             <span class="keywordflow">if</span> (<a class="code" href="../../d1/d1/largemcb_8c.html#a25">FsRtlFindLargeIndex</a>(Mcb, Vbn - 1, &amp;<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>)) {
00805 
00806                 <span class="comment">//</span>
00807                 <span class="comment">//  If this entry currently describes a hole then</span>
00808                 <span class="comment">//  truncate to the previous entry.</span>
00809                 <span class="comment">//</span>
00810 
00811                 <span class="keywordflow">if</span> (<a class="code" href="../../d1/d1/largemcb_8c.html#a8">StartingLbn</a>(Mcb, <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>) == <a class="code" href="../../d1/d1/largemcb_8c.html#a1">UNUSED_LBN</a>) {
00812 
00813                     Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o2">PairCount</a> = <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
00814 
00815                 <span class="comment">//</span>
00816                 <span class="comment">//  Otherwise we will truncate the Mcb to this point.  Truncate</span>
00817                 <span class="comment">//  the number of Vbns of this run if necessary.</span>
00818                 <span class="comment">//</span>
00819 
00820                 } <span class="keywordflow">else</span> {
00821 
00822                     Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o2">PairCount</a> = <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> + 1;
00823 
00824                     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d1/largemcb_8c.html#a6">NextStartingVbn</a>(Mcb, <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>) &gt; Vbn) {
00825 
00826                         (Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o4">Mapping</a>)[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].NextVbn = Vbn;
00827                     }
00828                 }
00829             }
00830         }
00831 
00832         <span class="comment">//</span>
00833         <span class="comment">//  Now see if we can shrink the allocation for the mapping pairs.</span>
00834         <span class="comment">//  We'll shrink the mapping pair buffer if the new pair count will</span>
00835         <span class="comment">//  fit within a quarter of the current maximum pair count and the</span>
00836         <span class="comment">//  current maximum is greater than the initial pair count.</span>
00837         <span class="comment">//</span>
00838 
00839         <span class="keywordflow">if</span> ((Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o2">PairCount</a> &lt; (Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o1">MaximumPairCount</a> / 4)) &amp;&amp;
00840             (Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o1">MaximumPairCount</a> &gt; <a class="code" href="../../d1/d1/largemcb_8c.html#a17">INITIAL_MAXIMUM_PAIR_COUNT</a>)) {
00841 
00842             ULONG NewMax;
00843             <a class="code" href="../../d1/d1/largemcb_8c.html#a19">PMAPPING</a> Mapping;
00844 
00845             <span class="comment">//</span>
00846             <span class="comment">//  We need to allocate a new mapping so compute a new maximum pair</span>
00847             <span class="comment">//  count.  We'll allocate double the current pair count, but never</span>
00848             <span class="comment">//  less than the initial pair count.</span>
00849             <span class="comment">//</span>
00850 
00851             NewMax = Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o2">PairCount</a> * 2;
00852 
00853             <span class="keywordflow">if</span> (NewMax &lt; <a class="code" href="../../d1/d1/largemcb_8c.html#a17">INITIAL_MAXIMUM_PAIR_COUNT</a>) {
00854                 NewMax = <a class="code" href="../../d1/d1/largemcb_8c.html#a17">INITIAL_MAXIMUM_PAIR_COUNT</a>;
00855             }
00856 
00857             <span class="comment">//</span>
00858             <span class="comment">//  Be careful to trap failures due to resource exhaustion.</span>
00859             <span class="comment">//</span>
00860                 
00861             <span class="keywordflow">try</span> {
00862                     
00863                 <span class="keywordflow">if</span> (NewMax == <a class="code" href="../../d1/d1/largemcb_8c.html#a17">INITIAL_MAXIMUM_PAIR_COUNT</a> &amp;&amp; Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o3">PoolType</a> == <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>) {
00864 
00865                     Mapping = <a class="code" href="../../d1/d1/largemcb_8c.html#a13">FsRtlAllocateFirstMapping</a>();
00866 
00867                 } <span class="keywordflow">else</span> {
00868             
00869                     Mapping = <a class="code" href="../../d3/d8/fsrtlp_8h.html#a2">FsRtlpAllocatePool</a>( Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o3">PoolType</a>, <span class="keyword">sizeof</span>(<a class="code" href="../../d8/d6/struct__MAPPING.html">MAPPING</a>) * NewMax );
00870                 }
00871 
00872             } except (<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
00873 
00874                   Mapping = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00875             }
00876 
00877             <span class="comment">//</span>
00878             <span class="comment">//  Now check if we really got a new buffer</span>
00879             <span class="comment">//</span>
00880 
00881             <span class="keywordflow">if</span> (Mapping != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00882 
00883                 <span class="comment">//</span>
00884                 <span class="comment">//  Now copy over the old mapping to the new buffer</span>
00885                 <span class="comment">//</span>
00886 
00887                 RtlCopyMemory( Mapping, Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o4">Mapping</a>, <span class="keyword">sizeof</span>(<a class="code" href="../../d8/d6/struct__MAPPING.html">MAPPING</a>) * Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o2">PairCount</a> );
00888 
00889                 <span class="comment">//</span>
00890                 <span class="comment">//  Deallocate the old buffer.  This should never be the size of an</span>
00891                 <span class="comment">//  initial mapping ...</span>
00892                 <span class="comment">//</span>
00893 
00894                 <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o4">Mapping</a> );
00895 
00896                 <span class="comment">//</span>
00897                 <span class="comment">//  And set up the new buffer in the Mcb</span>
00898                 <span class="comment">//</span>
00899 
00900                 Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o4">Mapping</a> = Mapping;
00901                 Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o1">MaximumPairCount</a> = NewMax;
00902             }
00903         }
00904 
00905     } finally {
00906 
00907         ExReleaseFastMutex( Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o0">FastMutex</a> );
00908     }
00909 
00910     <span class="comment">//</span>
00911     <span class="comment">//  And return to our caller</span>
00912     <span class="comment">//</span>
00913 
00914     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlTruncateLargeMcb -&gt; VOID\n"</span>, 0 );
00915 
00916     <span class="keywordflow">return</span>;
00917 }
00918 
00919 
00920 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00921 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00922"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a141">00922</a> <a class="code" href="../../d1/d8/fsrtl_8h.html#a141">FsRtlResetLargeMcb</a> (
00923     IN <a class="code" href="../../d0/d9/struct__LARGE__MCB.html">PLARGE_MCB</a> OpaqueMcb,
00924     IN BOOLEAN SelfSynchronized
00925     )
00926 
00927 <span class="comment">/*++</span>
00928 <span class="comment"></span>
00929 <span class="comment">Routine Description:</span>
00930 <span class="comment"></span>
00931 <span class="comment">    This routine truncates an Mcb structure to contain zero mapping</span>
00932 <span class="comment">    pairs.  It does not shrink the mapping pairs array.</span>
00933 <span class="comment"></span>
00934 <span class="comment">Arguments:</span>
00935 <span class="comment"></span>
00936 <span class="comment">    OpaqueMcb - Supplies a pointer to the Mcb structure to truncate.</span>
00937 <span class="comment"></span>
00938 <span class="comment">    SelfSynchronized - Indicates whether the caller is already synchronized</span>
00939 <span class="comment">        with respect to the Mcb.</span>
00940 <span class="comment"></span>
00941 <span class="comment">Return Value:</span>
00942 <span class="comment"></span>
00943 <span class="comment">    None.</span>
00944 <span class="comment"></span>
00945 <span class="comment">--*/</span>
00946 
00947 {
00948     <a class="code" href="../../d1/d1/largemcb_8c.html#a21">PNONOPAQUE_MCB</a> Mcb = (<a class="code" href="../../d1/d1/largemcb_8c.html#a21">PNONOPAQUE_MCB</a>)OpaqueMcb;
00949 
00950     <span class="keywordflow">if</span> (SelfSynchronized) {
00951         
00952         <span class="comment">//</span>
00953         <span class="comment">//  If we are self-synchronized, then all we do is clear out the </span>
00954         <span class="comment">//  current mapping pair count.</span>
00955         <span class="comment">//</span>
00956         
00957         Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o2">PairCount</a> = 0;
00958     
00959     } <span class="keywordflow">else</span> {
00960         
00961         <span class="comment">//</span>
00962         <span class="comment">//  Since we are not self-synchronized, we must serialize access to</span>
00963         <span class="comment">//  the Mcb before clearing the pair count</span>
00964         <span class="comment">//</span>
00965         
00966         ExAcquireFastMutex( Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o0">FastMutex</a> );
00967         Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o2">PairCount</a> = 0;
00968         ExReleaseFastMutex( Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o0">FastMutex</a> );
00969     
00970     }
00971 
00972     <span class="keywordflow">return</span>;
00973 }
00974 
00975 
00976 BOOLEAN
<a name="l00977"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a143">00977</a> <a class="code" href="../../d1/d8/fsrtl_8h.html#a143">FsRtlAddLargeMcbEntry</a> (
00978     IN <a class="code" href="../../d0/d9/struct__LARGE__MCB.html">PLARGE_MCB</a> OpaqueMcb,
00979     IN LONGLONG LargeVbn,
00980     IN LONGLONG LargeLbn,
00981     IN LONGLONG LargeSectorCount
00982     )
00983 
00984 <span class="comment">/*++</span>
00985 <span class="comment"></span>
00986 <span class="comment">Routine Description:</span>
00987 <span class="comment"></span>
00988 <span class="comment">    This routine is used to add a new mapping of VBNs to LBNs to an existing</span>
00989 <span class="comment">    Mcb. The information added will map</span>
00990 <span class="comment"></span>
00991 <span class="comment">        Vbn to Lbn,</span>
00992 <span class="comment"></span>
00993 <span class="comment">        Vbn+1 to Lbn+1,...</span>
00994 <span class="comment"></span>
00995 <span class="comment">        Vbn+(SectorCount-1) to Lbn+(SectorCount-1).</span>
00996 <span class="comment"></span>
00997 <span class="comment">    The mapping for the VBNs must not already exist in the Mcb.  If the</span>
00998 <span class="comment">    mapping continues a previous run, then this routine will actually coalesce</span>
00999 <span class="comment">    them into 1 run.</span>
01000 <span class="comment"></span>
01001 <span class="comment">    If pool is not available to store the information this routine will raise a</span>
01002 <span class="comment">    status value indicating insufficient resources.</span>
01003 <span class="comment"></span>
01004 <span class="comment">    An input Lbn value of zero is illegal (i.e., the Mcb structure will never</span>
01005 <span class="comment">    map a Vbn to a zero Lbn value).</span>
01006 <span class="comment"></span>
01007 <span class="comment">Arguments:</span>
01008 <span class="comment"></span>
01009 <span class="comment">    OpaqueMcb - Supplies the Mcb in which to add the new mapping.</span>
01010 <span class="comment"></span>
01011 <span class="comment">    Vbn - Supplies the starting Vbn of the new mapping run to add to the Mcb.</span>
01012 <span class="comment"></span>
01013 <span class="comment">    Lbn - Supplies the starting Lbn of the new mapping run to add to the Mcb.</span>
01014 <span class="comment"></span>
01015 <span class="comment">    SectorCount - Supplies the size of the new mapping run (in sectors).</span>
01016 <span class="comment"></span>
01017 <span class="comment">Return Value:</span>
01018 <span class="comment"></span>
01019 <span class="comment">    BOOLEAN - TRUE if the mapping was added successfully (i.e., the new</span>
01020 <span class="comment">        Vbns did not collide with existing Vbns), and FALSE otherwise.  If</span>
01021 <span class="comment">        FALSE is returned then the Mcb is not changed.</span>
01022 <span class="comment"></span>
01023 <span class="comment">--*/</span>
01024 
01025 {
01026     <a class="code" href="../../d1/d1/largemcb_8c.html#a21">PNONOPAQUE_MCB</a> Mcb = (<a class="code" href="../../d1/d1/largemcb_8c.html#a21">PNONOPAQUE_MCB</a>)OpaqueMcb;
01027 
01028     <a class="code" href="../../d1/d8/fsrtl_8h.html#a52">VBN</a> Vbn = ((ULONG)LargeVbn);
01029     <a class="code" href="../../d1/d8/fsrtl_8h.html#a50">LBN</a> Lbn = ((ULONG)LargeLbn);
01030     ULONG SectorCount = ((ULONG)LargeSectorCount);
01031 
01032     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
01033 
01034     <a class="code" href="../../d1/d8/fsrtl_8h.html#a52">VBN</a> LastVbn;
01035 
01036     BOOLEAN Result;
01037 
01038     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a8">ASSERTMSG</a>(<span class="stringliteral">"LargeInteger not supported yet "</span>, ((PLARGE_INTEGER)&amp;LargeVbn)-&gt;HighPart == 0);
01039     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a8">ASSERTMSG</a>(<span class="stringliteral">"LargeInteger not supported yet "</span>, ((PLARGE_INTEGER)&amp;LargeLbn)-&gt;HighPart == 0);
01040     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a8">ASSERTMSG</a>(<span class="stringliteral">"LargeInteger not supported yet "</span>, ((PLARGE_INTEGER)&amp;LargeSectorCount)-&gt;HighPart == 0);
01041 
01042     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01043 
01044     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlAddLargeMcbEntry, Mcb = %08lx\n"</span>, Mcb );
01045     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">" Vbn         = %08lx\n"</span>, Vbn );
01046     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">" Lbn         = %08lx\n"</span>, Lbn );
01047     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">" SectorCount = %08lx\n"</span>, SectorCount );
01048 
01049     ExAcquireFastMutex( Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o0">FastMutex</a> );
01050 
01051     <span class="keywordflow">try</span> {
01052 
01053         <span class="keywordflow">if</span> (<a class="code" href="../../d1/d1/largemcb_8c.html#a25">FsRtlFindLargeIndex</a>(Mcb, Vbn, &amp;<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>)) {
01054 
01055             ULONG EndVbn = Vbn + SectorCount - 1;
01056             ULONG EndIndex;
01057 
01058             <span class="comment">//</span>
01059             <span class="comment">//  First check the case where we are adding to an existing mcb run</span>
01060             <span class="comment">//  and if so then we will modify the insertion to complete the run</span>
01061             <span class="comment">//</span>
01062             <span class="comment">//      --ExistingRun--|      ==becomes==&gt;  --ExistingRun--|</span>
01063             <span class="comment">//              |--NewRun--|                               |---|</span>
01064             <span class="comment">//</span>
01065             <span class="comment">//      --ExistingRun----|    ==becomes==&gt; a noop</span>
01066             <span class="comment">//          |--NewRun--|</span>
01067             <span class="comment">//</span>
01068 
01069             <span class="keywordflow">if</span> (<a class="code" href="../../d1/d1/largemcb_8c.html#a8">StartingLbn</a>(Mcb, <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>) != <a class="code" href="../../d1/d1/largemcb_8c.html#a1">UNUSED_LBN</a>) {
01070 
01071                 <span class="comment">//</span>
01072                 <span class="comment">//  Check that the Lbn's line up between the new and existing run</span>
01073                 <span class="comment">//</span>
01074 
01075                 <span class="keywordflow">if</span> (Lbn != (<a class="code" href="../../d1/d1/largemcb_8c.html#a8">StartingLbn</a>(Mcb, <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>) + (Vbn - <a class="code" href="../../d1/d1/largemcb_8c.html#a4">StartingVbn</a>(Mcb, <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>)))) {
01076 
01077                     <span class="comment">//</span>
01078                     <span class="comment">//  Let our caller know we couldn't insert the run.</span>
01079                     <span class="comment">//</span>
01080 
01081                     <a class="code" href="../../d5/d5/cc_8h.html#a90">try_return</a>(Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
01082                 }
01083 
01084                 <span class="comment">//</span>
01085                 <span class="comment">//  Check if the new run is contained in the existing run</span>
01086                 <span class="comment">//</span>
01087 
01088                 <span class="keywordflow">if</span> (EndVbn &lt;= <a class="code" href="../../d1/d1/largemcb_8c.html#a5">EndingVbn</a>(Mcb, <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>)) {
01089 
01090                     <span class="comment">//</span>
01091                     <span class="comment">//  Do nothing because the run is contained within the existing run</span>
01092                     <span class="comment">//</span>
01093 
01094                     <a class="code" href="../../d5/d5/cc_8h.html#a90">try_return</a>(Result = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
01095                 }
01096 
01097                 <span class="comment">//</span>
01098                 <span class="comment">//  Otherwise we will simply trim off the request for the new run</span>
01099                 <span class="comment">//  to not overlap with the existing run</span>
01100                 <span class="comment">//</span>
01101 
01102                 Vbn = <a class="code" href="../../d1/d1/largemcb_8c.html#a6">NextStartingVbn</a>(Mcb, <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>);
01103                 Lbn = <a class="code" href="../../d1/d1/largemcb_8c.html#a9">EndingLbn</a>(Mcb, <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>) + 1;
01104 
01105                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(EndVbn &gt;= Vbn);
01106 
01107                 SectorCount = EndVbn - Vbn + 1;
01108 
01109             <span class="comment">//</span>
01110             <span class="comment">//  At this point the new run start in a hole, now check that if</span>
01111             <span class="comment">//  crosses into a non hole and if so then adjust new run to fit</span>
01112             <span class="comment">//  in the hole</span>
01113             <span class="comment">//</span>
01114             <span class="comment">//</span>
01115             <span class="comment">//            |--ExistingRun--  ==becomes==&gt;        |--ExistingRun--</span>
01116             <span class="comment">//      |--NewRun--|                          |--New|</span>
01117             <span class="comment">//</span>
01118 
01119             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="../../d1/d1/largemcb_8c.html#a25">FsRtlFindLargeIndex</a>(Mcb, EndVbn, &amp;EndIndex) &amp;&amp; (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> == (EndIndex-1))) {
01120 
01121                 <span class="comment">//</span>
01122                 <span class="comment">//  Check that the Lbn's line up in the overlap</span>
01123                 <span class="comment">//</span>
01124 
01125                 <span class="keywordflow">if</span> (<a class="code" href="../../d1/d1/largemcb_8c.html#a8">StartingLbn</a>(Mcb, EndIndex) != Lbn + (<a class="code" href="../../d1/d1/largemcb_8c.html#a4">StartingVbn</a>(Mcb, EndIndex) - Vbn)) {
01126 
01127                     <span class="comment">//</span>
01128                     <span class="comment">//  Let our caller know we couldn't insert the run.</span>
01129                     <span class="comment">//</span>
01130 
01131                     <a class="code" href="../../d5/d5/cc_8h.html#a90">try_return</a>(Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
01132                 }
01133 
01134                 <span class="comment">//</span>
01135                 <span class="comment">//  Truncate the sector count to go up to but not include</span>
01136                 <span class="comment">//  the existing run</span>
01137                 <span class="comment">//</span>
01138 
01139                 SectorCount = <a class="code" href="../../d1/d1/largemcb_8c.html#a4">StartingVbn</a>(Mcb, EndIndex) - Vbn;
01140             }
01141         }
01142 
01143         <span class="comment">//</span>
01144         <span class="comment">//  Find the index for the starting Vbn of our new run, if there isn't</span>
01145         <span class="comment">//  a hole found then index will be set to paircount.</span>
01146         <span class="comment">//</span>
01147 
01148         <span class="keywordflow">if</span> (((<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o2">PairCount</a>) == 0) ||
01149             (<a class="code" href="../../d1/d1/largemcb_8c.html#a3">PreviousEndingVbn</a>(Mcb,<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>)+1 &lt;= Vbn) ||
01150             !<a class="code" href="../../d1/d1/largemcb_8c.html#a25">FsRtlFindLargeIndex</a>(Mcb, Vbn, &amp;<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>)) {
01151 
01152             <span class="comment">//</span>
01153             <span class="comment">//  We didn't find a mapping, therefore this new mapping must</span>
01154             <span class="comment">//  go on at the end of the current mapping.</span>
01155             <span class="comment">//</span>
01156             <span class="comment">//  See if we can just grow the last mapping in the current mcb.</span>
01157             <span class="comment">//  We can grow the last entry if (1) the Vbns follow on, and (2)</span>
01158             <span class="comment">//  the Lbns follow on.  We can only grow the last mapping if the</span>
01159             <span class="comment">//  index is not 0.</span>
01160             <span class="comment">//</span>
01161 
01162             <span class="keywordflow">if</span> ((<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> != 0) &amp;&amp;
01163                 (<a class="code" href="../../d1/d1/largemcb_8c.html#a3">PreviousEndingVbn</a>(Mcb,<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>) + 1 == Vbn) &amp;&amp;
01164                 (<a class="code" href="../../d1/d1/largemcb_8c.html#a7">PreviousEndingLbn</a>(Mcb,<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>) + 1 == Lbn)) {
01165 
01166                 <span class="comment">//</span>
01167                 <span class="comment">//      --LastRun--|---NewRun--|</span>
01168                 <span class="comment">//</span>
01169 
01170                 <span class="comment">//</span>
01171                 <span class="comment">//  Extend the last run in the mcb</span>
01172                 <span class="comment">//</span>
01173 
01174                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"Continuing last run\n"</span>, 0);
01175 
01176                 (Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o4">Mapping</a>)[Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o2">PairCount</a>-1].NextVbn += SectorCount;
01177 
01178                 <a class="code" href="../../d5/d5/cc_8h.html#a90">try_return</a> (Result = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
01179             }
01180 
01181             <span class="comment">//</span>
01182             <span class="comment">//  We couldn't grow the last mapping, now check to see if</span>
01183             <span class="comment">//  this is a continuation of the last Vbn (i.e., there isn't</span>
01184             <span class="comment">//  going to be a hole in the mapping).  Or if this is the first</span>
01185             <span class="comment">//  run in the mapping</span>
01186             <span class="comment">//</span>
01187 
01188             <span class="keywordflow">if</span> ((Vbn == 0) ||
01189                 (<a class="code" href="../../d1/d1/largemcb_8c.html#a3">PreviousEndingVbn</a>(Mcb,<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>) + 1 == Vbn)) {
01190 
01191                 <span class="comment">//</span>
01192                 <span class="comment">//      --LastRun--||---NewRun--|</span>
01193                 <span class="comment">//</span>
01194                 <span class="comment">//      0:|--NewRun--|</span>
01195                 <span class="comment">//</span>
01196 
01197                 <span class="comment">//</span>
01198                 <span class="comment">//  We only need to add one more run to the mcb, so make sure</span>
01199                 <span class="comment">//  there is enough room for one.</span>
01200                 <span class="comment">//</span>
01201 
01202                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"Adding new contiguous last run\n"</span>, 0);
01203 
01204                 <a class="code" href="../../d1/d1/largemcb_8c.html#a26">FsRtlAddLargeEntry</a>( Mcb, <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>, 1 );
01205 
01206                 <span class="comment">//</span>
01207                 <span class="comment">//  Add the new mapping</span>
01208                 <span class="comment">//</span>
01209 
01210                 (Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o4">Mapping</a>)[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].Lbn = Lbn;
01211                 (Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o4">Mapping</a>)[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].NextVbn = Vbn + SectorCount;
01212 
01213                 <a class="code" href="../../d5/d5/cc_8h.html#a90">try_return</a> (Result = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
01214             }
01215 
01216             <span class="comment">//</span>
01217             <span class="comment">//  If we reach this point then there is going to be a hole in the</span>
01218             <span class="comment">//  mapping. and the mapping gets appended to the end of the current</span>
01219             <span class="comment">//  allocation.  So need to make room for two more runs in the mcb.</span>
01220             <span class="comment">//</span>
01221 
01222             <span class="comment">//</span>
01223             <span class="comment">//      --LastRun--|   hole   |---NewRun--|</span>
01224             <span class="comment">//</span>
01225             <span class="comment">//      0:  hole  |--NewRun--|</span>
01226             <span class="comment">//</span>
01227 
01228             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"Adding new noncontiguous last run\n"</span>, 0);
01229 
01230             <a class="code" href="../../d1/d1/largemcb_8c.html#a26">FsRtlAddLargeEntry</a>( Mcb, <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>, 2 );
01231 
01232             <span class="comment">//</span>
01233             <span class="comment">//  Add the hole</span>
01234             <span class="comment">//</span>
01235 
01236             (Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o4">Mapping</a>)[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].Lbn = (<a class="code" href="../../d1/d8/fsrtl_8h.html#a50">LBN</a>)<a class="code" href="../../d1/d1/largemcb_8c.html#a1">UNUSED_LBN</a>;
01237             (Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o4">Mapping</a>)[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].NextVbn = Vbn;
01238 
01239             <span class="comment">//</span>
01240             <span class="comment">//  Add the new mapping</span>
01241             <span class="comment">//</span>
01242 
01243             (Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o4">Mapping</a>)[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>+1].Lbn = Lbn;
01244             (Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o4">Mapping</a>)[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>+1].NextVbn = Vbn + SectorCount;
01245 
01246             <a class="code" href="../../d5/d5/cc_8h.html#a90">try_return</a> (Result = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
01247         }
01248 
01249         <span class="comment">//</span>
01250         <span class="comment">//  We found an index for the Vbn therefore we must be trying</span>
01251         <span class="comment">//  to fill up a hole in the mcb.  So first we need to check to make</span>
01252         <span class="comment">//  sure there really is a hole to be filled</span>
01253         <span class="comment">//</span>
01254 
01255         LastVbn = Vbn + SectorCount - 1;
01256 
01257         <span class="keywordflow">if</span> ((<a class="code" href="../../d1/d1/largemcb_8c.html#a8">StartingLbn</a>(Mcb,<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>) == <a class="code" href="../../d1/d1/largemcb_8c.html#a1">UNUSED_LBN</a>) &amp;&amp;
01258             (<a class="code" href="../../d1/d1/largemcb_8c.html#a4">StartingVbn</a>(Mcb,<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>) &lt;= Vbn) &amp;&amp; (LastVbn &lt;= <a class="code" href="../../d1/d1/largemcb_8c.html#a5">EndingVbn</a>(Mcb,<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>))) {
01259 
01260             <span class="comment">//</span>
01261             <span class="comment">//  The mapping fits in this hole, but now here are the following</span>
01262             <span class="comment">//  cases we must consider for the new mapping</span>
01263             <span class="comment">//</span>
01264 
01265             <span class="keywordflow">if</span> ((<a class="code" href="../../d1/d1/largemcb_8c.html#a4">StartingVbn</a>(Mcb,<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>) &lt; Vbn) &amp;&amp; (LastVbn &lt; <a class="code" href="../../d1/d1/largemcb_8c.html#a5">EndingVbn</a>(Mcb,<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>))) {
01266 
01267                 <span class="comment">//  Leaves a hole are both ends</span>
01268                 <span class="comment">//</span>
01269                 <span class="comment">//  --PreviousRun--|  hole  |--NewRun--|  hole  |--FollowingRun--</span>
01270                 <span class="comment">//</span>
01271                 <span class="comment">//  0:  hole  |--NewRun--|  hole  |--FollowingRun--</span>
01272                 <span class="comment">//</span>
01273 
01274                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"Hole at both ends\n"</span>, 0);
01275 
01276                 <span class="comment">//</span>
01277                 <span class="comment">//  Make room for two more entries.  The NextVbn field of the</span>
01278                 <span class="comment">//  one we're shifting remains valid.</span>
01279                 <span class="comment">//</span>
01280 
01281                 <a class="code" href="../../d1/d1/largemcb_8c.html#a26">FsRtlAddLargeEntry</a>( Mcb, <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>, 2 );
01282 
01283                 <span class="comment">//</span>
01284                 <span class="comment">//  Add the first hole</span>
01285                 <span class="comment">//</span>
01286 
01287                 (Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o4">Mapping</a>)[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].Lbn = (<a class="code" href="../../d1/d8/fsrtl_8h.html#a50">LBN</a>)<a class="code" href="../../d1/d1/largemcb_8c.html#a1">UNUSED_LBN</a>;
01288                 (Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o4">Mapping</a>)[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].NextVbn = Vbn;
01289 
01290                 <span class="comment">//</span>
01291                 <span class="comment">//  Add the new mapping</span>
01292                 <span class="comment">//</span>
01293 
01294                 (Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o4">Mapping</a>)[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>+1].Lbn = Lbn;
01295                 (Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o4">Mapping</a>)[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>+1].NextVbn = Vbn + SectorCount;
01296 
01297                 <span class="comment">//</span>
01298                 <span class="comment">//  The second hole is already set up by the add entry call, because</span>
01299                 <span class="comment">//  that call just shift over the original hole to that slot</span>
01300                 <span class="comment">//</span>
01301 
01302                 <a class="code" href="../../d5/d5/cc_8h.html#a90">try_return</a> (Result = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
01303             }
01304 
01305             <span class="keywordflow">if</span> ((<a class="code" href="../../d1/d1/largemcb_8c.html#a4">StartingVbn</a>(Mcb,<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>) == Vbn) &amp;&amp; (LastVbn &lt; <a class="code" href="../../d1/d1/largemcb_8c.html#a5">EndingVbn</a>(Mcb,<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>))) {
01306 
01307                 <span class="keywordflow">if</span> (<a class="code" href="../../d1/d1/largemcb_8c.html#a7">PreviousEndingLbn</a>(Mcb,<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>) + 1 == Lbn) {
01308 
01309                     <span class="comment">//</span>
01310                     <span class="comment">//  Leaves a hole at the rear, and continues the earlier run</span>
01311                     <span class="comment">//</span>
01312                     <span class="comment">//  --PreviousRun--|--NewRun--|  hole  |--FollowingRun--</span>
01313                     <span class="comment">//</span>
01314 
01315                     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"Hole at rear and continue\n"</span>, 0);
01316 
01317                     <span class="comment">//</span>
01318                     <span class="comment">//  We just need to extend the previous run</span>
01319                     <span class="comment">//</span>
01320 
01321                     (Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o4">Mapping</a>)[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>-1].NextVbn += SectorCount;
01322 
01323                     <a class="code" href="../../d5/d5/cc_8h.html#a90">try_return</a> (Result = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
01324 
01325                 } <span class="keywordflow">else</span> {
01326 
01327                     <span class="comment">//</span>
01328                     <span class="comment">//  Leaves a hole at the rear, and does not continue the</span>
01329                     <span class="comment">//  earlier run.  As occurs if index is zero.</span>
01330                     <span class="comment">//</span>
01331                     <span class="comment">//  --PreviousRun--||--NewRun--|  hole  |--FollowingRun--</span>
01332                     <span class="comment">//</span>
01333                     <span class="comment">//  0:|--NewRun--|  hole  |--FollowingRun--</span>
01334                     <span class="comment">//</span>
01335 
01336                     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"Hole at rear and not continue\n"</span>, 0);
01337 
01338                     <span class="comment">//</span>
01339                     <span class="comment">//  Make room for one more entry.  The NextVbn field of the</span>
01340                     <span class="comment">//  one we're shifting remains valid.</span>
01341                     <span class="comment">//</span>
01342 
01343                     <a class="code" href="../../d1/d1/largemcb_8c.html#a26">FsRtlAddLargeEntry</a>( Mcb, <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>, 1 );
01344 
01345                     <span class="comment">//</span>
01346                     <span class="comment">//  Add the new mapping</span>
01347                     <span class="comment">//</span>
01348 
01349                     (Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o4">Mapping</a>)[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].Lbn = Lbn;
01350                     (Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o4">Mapping</a>)[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].NextVbn = Vbn + SectorCount;
01351 
01352                     <span class="comment">//</span>
01353                     <span class="comment">//  The hole is already set up by the add entry call, because</span>
01354                     <span class="comment">//  that call just shift over the original hole to that slot</span>
01355                     <span class="comment">//</span>
01356 
01357                     <a class="code" href="../../d5/d5/cc_8h.html#a90">try_return</a> (Result = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
01358                 }
01359             }
01360 
01361             <span class="keywordflow">if</span> ((<a class="code" href="../../d1/d1/largemcb_8c.html#a4">StartingVbn</a>(Mcb,<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>) &lt; Vbn) &amp;&amp; (LastVbn == <a class="code" href="../../d1/d1/largemcb_8c.html#a5">EndingVbn</a>(Mcb,<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>))) {
01362 
01363                 <span class="keywordflow">if</span> (<a class="code" href="../../d1/d1/largemcb_8c.html#a10">NextStartingLbn</a>(Mcb,<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>) == Lbn + SectorCount) {
01364 
01365                     <span class="comment">//</span>
01366                     <span class="comment">//  Leaves a hole at the front, and continues the following run</span>
01367                     <span class="comment">//</span>
01368                     <span class="comment">//  --PreviousRun--|  hole  |--NewRun--|--FollowingRun--</span>
01369                     <span class="comment">//</span>
01370                     <span class="comment">//  0:  hole  |--NewRun--|--FollowingRun--</span>
01371                     <span class="comment">//</span>
01372 
01373                     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"Hole at front and continue\n"</span>, 0);
01374 
01375                     <span class="comment">//</span>
01376                     <span class="comment">//  We just need to extend the following run</span>
01377                     <span class="comment">//</span>
01378 
01379                     (Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o4">Mapping</a>)[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].NextVbn = Vbn;
01380                     (Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o4">Mapping</a>)[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>+1].Lbn = Lbn;
01381 
01382                     <a class="code" href="../../d5/d5/cc_8h.html#a90">try_return</a> (Result = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
01383 
01384                 } <span class="keywordflow">else</span> {
01385 
01386                     <span class="comment">//</span>
01387                     <span class="comment">//  Leaves a hole at the front, and does not continue the following</span>
01388                     <span class="comment">//  run</span>
01389                     <span class="comment">//</span>
01390                     <span class="comment">//  --PreviousRun--|  hole  |--NewRun--||--FollowingRun--</span>
01391                     <span class="comment">//</span>
01392                     <span class="comment">//  0:  hole  |--NewRun--||--FollowingRun--</span>
01393                     <span class="comment">//</span>
01394 
01395                     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"Hole at front and not continue\n"</span>, 0);
01396 
01397                     <span class="comment">//</span>
01398                     <span class="comment">//  Make room for one more entry.  The NextVbn field of the</span>
01399                     <span class="comment">//  one we're shifting remains valid.</span>
01400                     <span class="comment">//</span>
01401 
01402                     <a class="code" href="../../d1/d1/largemcb_8c.html#a26">FsRtlAddLargeEntry</a>( Mcb, <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>, 1 );
01403 
01404                     <span class="comment">//</span>
01405                     <span class="comment">//  Add the hole</span>
01406                     <span class="comment">//</span>
01407 
01408                     (Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o4">Mapping</a>)[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].Lbn = (<a class="code" href="../../d1/d8/fsrtl_8h.html#a50">LBN</a>)<a class="code" href="../../d1/d1/largemcb_8c.html#a1">UNUSED_LBN</a>;
01409                     (Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o4">Mapping</a>)[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].NextVbn = Vbn;
01410 
01411                     <span class="comment">//</span>
01412                     <span class="comment">//  Add the new mapping</span>
01413                     <span class="comment">//</span>
01414 
01415                     (Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o4">Mapping</a>)[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>+1].Lbn = Lbn;
01416 
01417                     <a class="code" href="../../d5/d5/cc_8h.html#a90">try_return</a> (Result = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
01418                 }
01419 
01420             }
01421 
01422             <span class="keywordflow">if</span> ((<a class="code" href="../../d1/d1/largemcb_8c.html#a7">PreviousEndingLbn</a>(Mcb,<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>) + 1 == Lbn) &amp;&amp;
01423                 (<a class="code" href="../../d1/d1/largemcb_8c.html#a10">NextStartingLbn</a>(Mcb,<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>) == Lbn + SectorCount)) {
01424 
01425                 <span class="comment">//</span>
01426                 <span class="comment">//  Leaves no holes, and continues both runs</span>
01427                 <span class="comment">//</span>
01428                 <span class="comment">//  --PreviousRun--|--NewRun--|--FollowingRun--</span>
01429                 <span class="comment">//</span>
01430 
01431                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"No holes, and continues both runs\n"</span>, 0);
01432 
01433                 <span class="comment">//</span>
01434                 <span class="comment">//  We need to collapse the current index and the following index</span>
01435                 <span class="comment">//  but first we copy the NextVbn of the follwing run into</span>
01436                 <span class="comment">//  the NextVbn field of the previous run to so it all becomes</span>
01437                 <span class="comment">//  one run</span>
01438                 <span class="comment">//</span>
01439 
01440                 (Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o4">Mapping</a>)[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>-1].NextVbn = (Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o4">Mapping</a>)[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>+1].NextVbn;
01441 
01442                 <a class="code" href="../../d1/d1/largemcb_8c.html#a27">FsRtlRemoveLargeEntry</a>( Mcb, <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>, 2 );
01443 
01444                 <a class="code" href="../../d5/d5/cc_8h.html#a90">try_return</a> (Result = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
01445             }
01446 
01447             <span class="keywordflow">if</span> (<a class="code" href="../../d1/d1/largemcb_8c.html#a10">NextStartingLbn</a>(Mcb,<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>) == Lbn + SectorCount) {
01448 
01449                 <span class="comment">//</span>
01450                 <span class="comment">//  Leaves no holes, and continues only following run</span>
01451                 <span class="comment">//</span>
01452                 <span class="comment">//  --PreviousRun--||--NewRun--|--FollowingRun--</span>
01453                 <span class="comment">//</span>
01454                 <span class="comment">//  0:|--NewRun--|--FollowingRun--</span>
01455                 <span class="comment">//</span>
01456 
01457                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"No holes, and continues following\n"</span>, 0);
01458 
01459                 <span class="comment">//</span>
01460                 <span class="comment">//  This index is going away so we need to stretch the</span>
01461                 <span class="comment">//  following run to meet up with the previous run</span>
01462                 <span class="comment">//</span>
01463 
01464                 (Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o4">Mapping</a>)[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>+1].Lbn = Lbn;
01465 
01466                 <a class="code" href="../../d1/d1/largemcb_8c.html#a27">FsRtlRemoveLargeEntry</a>( Mcb, <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>, 1 );
01467 
01468                 <a class="code" href="../../d5/d5/cc_8h.html#a90">try_return</a> (Result = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
01469             }
01470 
01471             <span class="keywordflow">if</span> (<a class="code" href="../../d1/d1/largemcb_8c.html#a7">PreviousEndingLbn</a>(Mcb,<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>) + 1 == Lbn) {
01472 
01473                 <span class="comment">//</span>
01474                 <span class="comment">//  Leaves no holes, and continues only earlier run</span>
01475                 <span class="comment">//</span>
01476                 <span class="comment">//  --PreviousRun--|--NewRun--||--FollowingRun--</span>
01477                 <span class="comment">//</span>
01478 
01479                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"No holes, and continues earlier\n"</span>, 0);
01480 
01481                 <span class="comment">//</span>
01482                 <span class="comment">//  This index is going away so we need to stretch the</span>
01483                 <span class="comment">//  previous run to meet up with the following run</span>
01484                 <span class="comment">//</span>
01485 
01486                 (Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o4">Mapping</a>)[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>-1].NextVbn = (Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o4">Mapping</a>)[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].NextVbn;
01487 
01488                 <a class="code" href="../../d1/d1/largemcb_8c.html#a27">FsRtlRemoveLargeEntry</a>( Mcb, <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>, 1 );
01489 
01490                 <a class="code" href="../../d5/d5/cc_8h.html#a90">try_return</a> (Result = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
01491             }
01492 
01493             <span class="comment">//</span>
01494             <span class="comment">//  Leaves no holes, and continues neither run</span>
01495             <span class="comment">//</span>
01496             <span class="comment">//      --PreviousRun--||--NewRun--||--FollowingRun--</span>
01497             <span class="comment">//</span>
01498             <span class="comment">//      0:|--NewRun--||--FollowingRun--</span>
01499             <span class="comment">//</span>
01500 
01501             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"No holes, and continues none\n"</span>, 0);
01502 
01503             (Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o4">Mapping</a>)[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].Lbn = Lbn;
01504 
01505             <a class="code" href="../../d5/d5/cc_8h.html#a90">try_return</a> (Result = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
01506         }
01507 
01508         <span class="comment">//</span>
01509         <span class="comment">//  We tried to overwrite an existing mapping so we'll have to</span>
01510         <span class="comment">//  tell our caller that it's not possible</span>
01511         <span class="comment">//</span>
01512 
01513         Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01514 
01515     try_exit: NOTHING;
01516     } finally {
01517 
01518         ExReleaseFastMutex( Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o0">FastMutex</a> );
01519 
01520         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlAddLargeMcbEntry -&gt; %08lx\n"</span>, Result );
01521     }
01522 
01523     <span class="keywordflow">return</span> Result;
01524 }
01525 
01526 
01527 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01528"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a144">01528</a> <a class="code" href="../../d1/d8/fsrtl_8h.html#a144">FsRtlRemoveLargeMcbEntry</a> (
01529     IN <a class="code" href="../../d0/d9/struct__LARGE__MCB.html">PLARGE_MCB</a> OpaqueMcb,
01530     IN LONGLONG LargeVbn,
01531     IN LONGLONG LargeSectorCount
01532     )
01533 
01534 <span class="comment">/*++</span>
01535 <span class="comment"></span>
01536 <span class="comment">Routine Description:</span>
01537 <span class="comment"></span>
01538 <span class="comment">    This routine removes a mapping of VBNs to LBNs from an Mcb.  The mappings</span>
01539 <span class="comment">    removed are for</span>
01540 <span class="comment"></span>
01541 <span class="comment">        Vbn,</span>
01542 <span class="comment"></span>
01543 <span class="comment">        Vbn+1, to</span>
01544 <span class="comment"></span>
01545 <span class="comment">        Vbn+(SectorCount-1).</span>
01546 <span class="comment"></span>
01547 <span class="comment">    The operation works even if the mapping for a Vbn in the specified range</span>
01548 <span class="comment">    does not already exist in the Mcb.  If the specified range of Vbn includes</span>
01549 <span class="comment">    the last mapped Vbn in the Mcb then the Mcb mapping shrinks accordingly.</span>
01550 <span class="comment"></span>
01551 <span class="comment">    If pool is not available to store the information this routine will raise</span>
01552 <span class="comment">    a status value indicating insufficient resources.</span>
01553 <span class="comment"></span>
01554 <span class="comment">Arguments:</span>
01555 <span class="comment"></span>
01556 <span class="comment">    OpaqueMcb - Supplies the Mcb from which to remove the mapping.</span>
01557 <span class="comment"></span>
01558 <span class="comment">    Vbn - Supplies the starting Vbn of the mappings to remove.</span>
01559 <span class="comment"></span>
01560 <span class="comment">    SectorCount - Supplies the size of the mappings to remove (in sectors).</span>
01561 <span class="comment"></span>
01562 <span class="comment">Return Value:</span>
01563 <span class="comment"></span>
01564 <span class="comment">    None.</span>
01565 <span class="comment"></span>
01566 <span class="comment">--*/</span>
01567 
01568 {
01569     <a class="code" href="../../d1/d1/largemcb_8c.html#a21">PNONOPAQUE_MCB</a> Mcb = (<a class="code" href="../../d1/d1/largemcb_8c.html#a21">PNONOPAQUE_MCB</a>)OpaqueMcb;
01570 
01571     <a class="code" href="../../d1/d8/fsrtl_8h.html#a52">VBN</a> Vbn = ((ULONG)LargeVbn);
01572     ULONG SectorCount = ((ULONG)LargeSectorCount);
01573 
01574     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01575 
01576     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a8">ASSERTMSG</a>(<span class="stringliteral">"LargeInteger not supported yet "</span>, ((PLARGE_INTEGER)&amp;LargeVbn)-&gt;HighPart == 0);
01577 
01578     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlRemoveLargeMcbEntry, Mcb = %08lx\n"</span>, Mcb );
01579     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">" Vbn         = %08lx\n"</span>, Vbn );
01580     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">" SectorCount = %08lx\n"</span>, SectorCount );
01581 
01582     ExAcquireFastMutex( Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o0">FastMutex</a> );
01583 
01584     <span class="keywordflow">try</span> {
01585 
01586         <a class="code" href="../../d1/d1/largemcb_8c.html#a24">FsRtlRemoveMcbEntryPrivate</a>( Mcb, Vbn, SectorCount );
01587 
01588     } finally {
01589 
01590         ExReleaseFastMutex( Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o0">FastMutex</a> );
01591 
01592         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlRemoveLargeMcbEntry -&gt; VOID\n"</span>, 0 );
01593     }
01594 
01595     <span class="keywordflow">return</span>;
01596 }
01597 
01598 
01599 BOOLEAN
<a name="l01600"></a><a class="code" href="../../d1/d1/largemcb_8c.html#a44">01600</a> <a class="code" href="../../d1/d8/fsrtl_8h.html#a145">FsRtlLookupLargeMcbEntry</a> (
01601     IN <a class="code" href="../../d0/d9/struct__LARGE__MCB.html">PLARGE_MCB</a> OpaqueMcb,
01602     IN LONGLONG LargeVbn,
01603     OUT PLONGLONG LargeLbn OPTIONAL,
01604     OUT PLONGLONG LargeSectorCount OPTIONAL,
01605     OUT PLONGLONG LargeStartingLbn OPTIONAL,
01606     OUT PLONGLONG LargeCountFromStartingLbn OPTIONAL,
01607     OUT PULONG Index OPTIONAL
01608     )
01609 
01610 <span class="comment">/*++</span>
01611 <span class="comment"></span>
01612 <span class="comment">Routine Description:</span>
01613 <span class="comment"></span>
01614 <span class="comment">    This routine retrieves the mapping of a Vbn to an Lbn from an Mcb.</span>
01615 <span class="comment">    It indicates if the mapping exists and the size of the run.</span>
01616 <span class="comment"></span>
01617 <span class="comment">Arguments:</span>
01618 <span class="comment"></span>
01619 <span class="comment">    OpaqueMcb - Supplies the Mcb being examined.</span>
01620 <span class="comment"></span>
01621 <span class="comment">    Vbn - Supplies the Vbn to lookup.</span>
01622 <span class="comment"></span>
01623 <span class="comment">    Lbn - Receives the Lbn corresponding to the Vbn.  A value of -1 is</span>
01624 <span class="comment">        returned if the Vbn does not have a corresponding Lbn.</span>
01625 <span class="comment"></span>
01626 <span class="comment">    SectorCount - Receives the number of sectors that map from the Vbn to</span>
01627 <span class="comment">        contiguous Lbn values beginning with the input Vbn.</span>
01628 <span class="comment"></span>
01629 <span class="comment">    Index - Receives the index of the run found.</span>
01630 <span class="comment"></span>
01631 <span class="comment">Return Value:</span>
01632 <span class="comment"></span>
01633 <span class="comment">    BOOLEAN - TRUE if the Vbn is within the range of VBNs mapped by the</span>
01634 <span class="comment">        MCB (even if it corresponds to a hole in the mapping), and FALSE</span>
01635 <span class="comment">        if the Vbn is beyond the range of the MCB's mapping.</span>
01636 <span class="comment"></span>
01637 <span class="comment">        For example, if an MCB has a mapping for VBNs 5 and 7 but not for</span>
01638 <span class="comment">        6, then a lookup on Vbn 5 or 7 will yield a non zero Lbn and a sector</span>
01639 <span class="comment">        count of 1.  A lookup for Vbn 6 will return TRUE with an Lbn value of</span>
01640 <span class="comment">        0, and lookup for Vbn 8 or above will return FALSE.</span>
01641 <span class="comment"></span>
01642 <span class="comment">--*/</span>
01643 
01644 {
01645     <a class="code" href="../../d1/d1/largemcb_8c.html#a21">PNONOPAQUE_MCB</a> Mcb = (<a class="code" href="../../d1/d1/largemcb_8c.html#a21">PNONOPAQUE_MCB</a>)OpaqueMcb;
01646 
01647     BOOLEAN Result;
01648 
01649     ULONG LocalIndex;
01650 
01651     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlLookupLargeMcbEntry, Mcb = %08lx\n"</span>, Mcb );
01652     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"  LargeVbn.LowPart = %08lx\n"</span>, LargeVbn.LowPart );
01653 
01654     ExAcquireFastMutex( Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o0">FastMutex</a> );
01655 
01656     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a8">ASSERTMSG</a>(<span class="stringliteral">"LargeInteger not supported yet "</span>, ((((PLARGE_INTEGER)&amp;LargeVbn)-&gt;HighPart == 0) ||
01657                                                   (Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o2">PairCount</a> == 0) ||
01658                                                   ((((PLARGE_INTEGER)&amp;LargeVbn)-&gt;HighPart == 0x7FFFFFFF) &amp;&amp;
01659                                                    (((ULONG)LargeVbn) == 0xFFFFFFFF))));
01660 
01661     <span class="keywordflow">try</span> {
01662 
01663         <span class="keywordflow">if</span> (!<a class="code" href="../../d1/d1/largemcb_8c.html#a25">FsRtlFindLargeIndex</a>(Mcb, ((ULONG)LargeVbn), &amp;LocalIndex)) {
01664 
01665             <a class="code" href="../../d5/d5/cc_8h.html#a90">try_return</a> (Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
01666         }
01667 
01668         <span class="comment">//</span>
01669         <span class="comment">//  Compute the lbn for corresponding to the vbn, the value is the</span>
01670         <span class="comment">//  starting lbn of the run plus the number of sectors offset into the</span>
01671         <span class="comment">//  run.  But if it's a hole then the sector Lbn is zero.</span>
01672         <span class="comment">//</span>
01673 
01674         <span class="keywordflow">if</span> (ARGUMENT_PRESENT(LargeLbn)) {
01675 
01676             <span class="keywordflow">if</span> (<a class="code" href="../../d1/d1/largemcb_8c.html#a8">StartingLbn</a>(Mcb,LocalIndex) == <a class="code" href="../../d1/d1/largemcb_8c.html#a1">UNUSED_LBN</a>) {
01677 
01678                 *((PULONG)LargeLbn) = (<a class="code" href="../../d1/d8/fsrtl_8h.html#a50">LBN</a>)<a class="code" href="../../d1/d1/largemcb_8c.html#a1">UNUSED_LBN</a>;
01679 
01680             } <span class="keywordflow">else</span> {
01681 
01682                 *((PULONG)LargeLbn) = <a class="code" href="../../d1/d1/largemcb_8c.html#a8">StartingLbn</a>(Mcb,LocalIndex) + (((ULONG)LargeVbn) - <a class="code" href="../../d1/d1/largemcb_8c.html#a4">StartingVbn</a>(Mcb,LocalIndex));
01683             }
01684         }
01685 
01686         <span class="comment">//</span>
01687         <span class="comment">//  If there sector count argument is present then we'll return the number</span>
01688         <span class="comment">//  of sectors remaing in the run.</span>
01689         <span class="comment">//</span>
01690 
01691         <span class="keywordflow">if</span> (ARGUMENT_PRESENT(LargeSectorCount)) {
01692 
01693             *((PULONG)LargeSectorCount) = <a class="code" href="../../d1/d1/largemcb_8c.html#a5">EndingVbn</a>(Mcb,LocalIndex) - ((ULONG)LargeVbn) + 1;
01694         }
01695 
01696         <span class="comment">//</span>
01697         <span class="comment">//  Compute the starting lbn for corresponding to the start of the run, the value is the</span>
01698         <span class="comment">//  starting lbn of the run.  But if it's a hole then the sector Lbn is zero.</span>
01699         <span class="comment">//</span>
01700 
01701         <span class="keywordflow">if</span> (ARGUMENT_PRESENT(LargeStartingLbn)) {
01702 
01703             <span class="keywordflow">if</span> (<a class="code" href="../../d1/d1/largemcb_8c.html#a8">StartingLbn</a>(Mcb,LocalIndex) == <a class="code" href="../../d1/d1/largemcb_8c.html#a1">UNUSED_LBN</a>) {
01704 
01705                 *((PULONG)LargeStartingLbn) = (<a class="code" href="../../d1/d8/fsrtl_8h.html#a50">LBN</a>)<a class="code" href="../../d1/d1/largemcb_8c.html#a1">UNUSED_LBN</a>;
01706 
01707             } <span class="keywordflow">else</span> {
01708 
01709                 *((PULONG)LargeStartingLbn) = <a class="code" href="../../d1/d1/largemcb_8c.html#a8">StartingLbn</a>(Mcb,LocalIndex);
01710             }
01711         }
01712 
01713         <span class="comment">//</span>
01714         <span class="comment">//  If there sector count argument is present then we'll return the number</span>
01715         <span class="comment">//  of sectors in the run.</span>
01716         <span class="comment">//</span>
01717 
01718         <span class="keywordflow">if</span> (ARGUMENT_PRESENT(LargeCountFromStartingLbn)) {
01719 
01720             *((PULONG)LargeCountFromStartingLbn) = <a class="code" href="../../d1/d1/largemcb_8c.html#a5">EndingVbn</a>(Mcb,LocalIndex) - <a class="code" href="../../d1/d1/largemcb_8c.html#a4">StartingVbn</a>(Mcb,LocalIndex) + 1;
01721         }
01722 
01723         <span class="comment">//</span>
01724         <span class="comment">//  If the caller want to know the Index number, fill it in.</span>
01725         <span class="comment">//</span>
01726 
01727         <span class="keywordflow">if</span> (ARGUMENT_PRESENT(<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>)) {
01728 
01729             *<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = LocalIndex;
01730         }
01731 
01732         Result = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01733 
01734     try_exit: NOTHING;
01735     } finally {
01736 
01737         ExReleaseFastMutex( Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o0">FastMutex</a> );
01738 
01739         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlLookupLargeMcbEntry -&gt; %08lx\n"</span>, Result );
01740     }
01741 
01742     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(LargeLbn)) {
01743         ((PLARGE_INTEGER)LargeLbn)-&gt;HighPart = (*((PULONG)LargeLbn) == <a class="code" href="../../d1/d1/largemcb_8c.html#a1">UNUSED_LBN</a> ? <a class="code" href="../../d1/d1/largemcb_8c.html#a1">UNUSED_LBN</a> : 0);
01744     }
01745 
01746     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(LargeSectorCount)) {
01747         ((PLARGE_INTEGER)LargeSectorCount)-&gt;HighPart = 0;
01748     }
01749 
01750     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(LargeStartingLbn)) {
01751         ((PLARGE_INTEGER)LargeStartingLbn)-&gt;HighPart = (*((PULONG)LargeStartingLbn) == <a class="code" href="../../d1/d1/largemcb_8c.html#a1">UNUSED_LBN</a> ? <a class="code" href="../../d1/d1/largemcb_8c.html#a1">UNUSED_LBN</a> : 0);
01752     }
01753 
01754     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(LargeCountFromStartingLbn)) {
01755         ((PLARGE_INTEGER)LargeCountFromStartingLbn)-&gt;HighPart = 0;
01756     }
01757 
01758     <span class="keywordflow">return</span> Result;
01759 }
01760 
01761 
01762 BOOLEAN
<a name="l01763"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a146">01763</a> <a class="code" href="../../d1/d8/fsrtl_8h.html#a146">FsRtlLookupLastLargeMcbEntry</a> (
01764     IN <a class="code" href="../../d0/d9/struct__LARGE__MCB.html">PLARGE_MCB</a> OpaqueMcb,
01765     OUT PLONGLONG LargeVbn,
01766     OUT PLONGLONG LargeLbn
01767     )
01768 
01769 <span class="comment">/*++</span>
01770 <span class="comment"></span>
01771 <span class="comment">Routine Description:</span>
01772 <span class="comment"></span>
01773 <span class="comment">    This routine retrieves the last Vbn to Lbn mapping stored in the Mcb.</span>
01774 <span class="comment">    It returns the mapping for the last sector or the last run in the</span>
01775 <span class="comment">    Mcb.  The results of this function is useful when extending an existing</span>
01776 <span class="comment">    file and needing to a hint on where to try and allocate sectors on the</span>
01777 <span class="comment">    disk.</span>
01778 <span class="comment"></span>
01779 <span class="comment">Arguments:</span>
01780 <span class="comment"></span>
01781 <span class="comment">    OpaqueMcb - Supplies the Mcb being examined.</span>
01782 <span class="comment"></span>
01783 <span class="comment">    Vbn - Receives the last Vbn value mapped.</span>
01784 <span class="comment"></span>
01785 <span class="comment">    Lbn - Receives the Lbn corresponding to the Vbn.</span>
01786 <span class="comment"></span>
01787 <span class="comment">Return Value:</span>
01788 <span class="comment"></span>
01789 <span class="comment">    BOOLEAN - TRUE if there is a mapping within the Mcb and FALSE otherwise</span>
01790 <span class="comment">        (i.e., the Mcb does not contain any mapping).</span>
01791 <span class="comment"></span>
01792 <span class="comment">--*/</span>
01793 
01794 {
01795     <a class="code" href="../../d1/d1/largemcb_8c.html#a21">PNONOPAQUE_MCB</a> Mcb = (<a class="code" href="../../d1/d1/largemcb_8c.html#a21">PNONOPAQUE_MCB</a>)OpaqueMcb;
01796 
01797     BOOLEAN Result;
01798 
01799     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01800 
01801     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlLookupLastLargeMcbEntry, Mcb = %08lx\n"</span>, Mcb );
01802 
01803     ExAcquireFastMutex( Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o0">FastMutex</a> );
01804 
01805     <span class="keywordflow">try</span> {
01806 
01807         <span class="comment">//</span>
01808         <span class="comment">//  Check to make sure there is at least one run in the mcb</span>
01809         <span class="comment">//</span>
01810 
01811         <span class="keywordflow">if</span> (Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o2">PairCount</a> &lt;= 0) {
01812 
01813             <a class="code" href="../../d5/d5/cc_8h.html#a90">try_return</a> (Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
01814         }
01815 
01816         <span class="comment">//</span>
01817         <span class="comment">//  Return the last mapping of the last run</span>
01818         <span class="comment">//</span>
01819 
01820         *((PULONG)LargeLbn) = <a class="code" href="../../d1/d1/largemcb_8c.html#a9">EndingLbn</a>(Mcb,Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o2">PairCount</a>-1);
01821         *((PULONG)LargeVbn) = <a class="code" href="../../d1/d1/largemcb_8c.html#a5">EndingVbn</a>(Mcb,Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o2">PairCount</a>-1);
01822 
01823         Result = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01824 
01825     try_exit: NOTHING;
01826     } finally {
01827 
01828         ExReleaseFastMutex( Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o0">FastMutex</a> );
01829 
01830         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlLookupLastLargeMcbEntry -&gt; %08lx\n"</span>, Result );
01831     }
01832 
01833     ((PLARGE_INTEGER)LargeVbn)-&gt;HighPart = (*((PULONG)LargeVbn) == <a class="code" href="../../d1/d1/largemcb_8c.html#a1">UNUSED_LBN</a> ? <a class="code" href="../../d1/d1/largemcb_8c.html#a1">UNUSED_LBN</a> : 0);
01834     ((PLARGE_INTEGER)LargeLbn)-&gt;HighPart = (*((PULONG)LargeLbn) == <a class="code" href="../../d1/d1/largemcb_8c.html#a1">UNUSED_LBN</a> ? <a class="code" href="../../d1/d1/largemcb_8c.html#a1">UNUSED_LBN</a> : 0);
01835 
01836     <span class="keywordflow">return</span> Result;
01837 }
01838 
01839 
01840 BOOLEAN
<a name="l01841"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a147">01841</a> <a class="code" href="../../d1/d8/fsrtl_8h.html#a147">FsRtlLookupLastLargeMcbEntryAndIndex</a> (
01842     IN <a class="code" href="../../d0/d9/struct__LARGE__MCB.html">PLARGE_MCB</a> OpaqueMcb,
01843     OUT PLONGLONG LargeVbn,
01844     OUT PLONGLONG LargeLbn,
01845     OUT PULONG Index
01846     )
01847 
01848 <span class="comment">/*++</span>
01849 <span class="comment"></span>
01850 <span class="comment">Routine Description:</span>
01851 <span class="comment"></span>
01852 <span class="comment">    This routine retrieves the last Vbn to Lbn mapping stored in the Mcb.</span>
01853 <span class="comment">    It returns the mapping for the last sector or the last run in the</span>
01854 <span class="comment">    Mcb.  The results of this function is useful when extending an existing</span>
01855 <span class="comment">    file and needing to a hint on where to try and allocate sectors on the</span>
01856 <span class="comment">    disk.</span>
01857 <span class="comment"></span>
01858 <span class="comment">Arguments:</span>
01859 <span class="comment"></span>
01860 <span class="comment">    OpaqueMcb - Supplies the Mcb being examined.</span>
01861 <span class="comment"></span>
01862 <span class="comment">    Vbn - Receives the last Vbn value mapped.</span>
01863 <span class="comment"></span>
01864 <span class="comment">    Lbn - Receives the Lbn corresponding to the Vbn.</span>
01865 <span class="comment">    </span>
01866 <span class="comment">    Index - Receives the index of the last run.</span>
01867 <span class="comment"></span>
01868 <span class="comment">Return Value:</span>
01869 <span class="comment"></span>
01870 <span class="comment">    BOOLEAN - TRUE if there is a mapping within the Mcb and FALSE otherwise</span>
01871 <span class="comment">        (i.e., the Mcb does not contain any mapping).</span>
01872 <span class="comment"></span>
01873 <span class="comment">--*/</span>
01874 
01875 {
01876     <a class="code" href="../../d1/d1/largemcb_8c.html#a21">PNONOPAQUE_MCB</a> Mcb = (<a class="code" href="../../d1/d1/largemcb_8c.html#a21">PNONOPAQUE_MCB</a>)OpaqueMcb;
01877 
01878     BOOLEAN Result;
01879 
01880     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01881 
01882     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlLookupLastLargeMcbEntryAndIndex, Mcb = %08lx\n"</span>, Mcb );
01883 
01884     ExAcquireFastMutex( Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o0">FastMutex</a> );
01885 
01886     <span class="keywordflow">try</span> {
01887 
01888         <span class="comment">//</span>
01889         <span class="comment">//  Check to make sure there is at least one run in the mcb</span>
01890         <span class="comment">//</span>
01891 
01892         <span class="keywordflow">if</span> (Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o2">PairCount</a> &lt;= 0) {
01893 
01894             <a class="code" href="../../d5/d5/cc_8h.html#a90">try_return</a> (Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
01895         }
01896 
01897         <span class="comment">//</span>
01898         <span class="comment">//  Return the last mapping of the last run</span>
01899         <span class="comment">//</span>
01900 
01901         *((PULONG)LargeLbn) = <a class="code" href="../../d1/d1/largemcb_8c.html#a9">EndingLbn</a>(Mcb,Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o2">PairCount</a>-1);
01902         *((PULONG)LargeVbn) = <a class="code" href="../../d1/d1/largemcb_8c.html#a5">EndingVbn</a>(Mcb,Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o2">PairCount</a>-1);
01903 
01904         *<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o2">PairCount</a> - 1;
01905 
01906         Result = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01907 
01908     try_exit: NOTHING;
01909     } finally {
01910 
01911         ExReleaseFastMutex( Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o0">FastMutex</a> );
01912 
01913         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlLookupLastLargeMcbEntryAndIndex -&gt; %08lx\n"</span>, Result );
01914     }
01915 
01916     ((PLARGE_INTEGER)LargeVbn)-&gt;HighPart = (*((PULONG)LargeVbn) == <a class="code" href="../../d1/d1/largemcb_8c.html#a1">UNUSED_LBN</a> ? <a class="code" href="../../d1/d1/largemcb_8c.html#a1">UNUSED_LBN</a> : 0);
01917     ((PLARGE_INTEGER)LargeLbn)-&gt;HighPart = (*((PULONG)LargeLbn) == <a class="code" href="../../d1/d1/largemcb_8c.html#a1">UNUSED_LBN</a> ? <a class="code" href="../../d1/d1/largemcb_8c.html#a1">UNUSED_LBN</a> : 0);
01918 
01919     <span class="keywordflow">return</span> Result;
01920 }
01921 
01922 
01923 ULONG
<a name="l01924"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a148">01924</a> <a class="code" href="../../d1/d8/fsrtl_8h.html#a148">FsRtlNumberOfRunsInLargeMcb</a> (
01925     IN <a class="code" href="../../d0/d9/struct__LARGE__MCB.html">PLARGE_MCB</a> OpaqueMcb
01926     )
01927 
01928 <span class="comment">/*++</span>
01929 <span class="comment"></span>
01930 <span class="comment">Routine Description:</span>
01931 <span class="comment"></span>
01932 <span class="comment">    This routine returns to the its caller the number of distinct runs</span>
01933 <span class="comment">    mapped by an Mcb.  Holes (i.e., Vbns that map to Lbn=UNUSED_LBN) are counted</span>
01934 <span class="comment">    as runs.  For example, an Mcb containing a mapping for only Vbns 0 and 3</span>
01935 <span class="comment">    will have 3 runs, one for the first mapped sector, a second for the</span>
01936 <span class="comment">    hole covering Vbns 1 and 2, and a third for Vbn 3.</span>
01937 <span class="comment"></span>
01938 <span class="comment">Arguments:</span>
01939 <span class="comment"></span>
01940 <span class="comment">    OpaqueMcb - Supplies the Mcb being examined.</span>
01941 <span class="comment"></span>
01942 <span class="comment">Return Value:</span>
01943 <span class="comment"></span>
01944 <span class="comment">    ULONG - Returns the number of distinct runs mapped by the input Mcb.</span>
01945 <span class="comment"></span>
01946 <span class="comment">--*/</span>
01947 
01948 {
01949     <a class="code" href="../../d1/d1/largemcb_8c.html#a21">PNONOPAQUE_MCB</a> Mcb = (<a class="code" href="../../d1/d1/largemcb_8c.html#a21">PNONOPAQUE_MCB</a>)OpaqueMcb;
01950 
01951     ULONG <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a>;
01952 
01953     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01954 
01955     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlNumberOfRunsInLargeMcb, Mcb = %08lx\n"</span>, Mcb );
01956 
01957     ExAcquireFastMutex( Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o0">FastMutex</a> );
01958 
01959     <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> = Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o2">PairCount</a>;
01960 
01961     ExReleaseFastMutex( Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o0">FastMutex</a> );
01962 
01963     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlNumberOfRunsInLargeMcb -&gt; %08lx\n"</span>, <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> );
01964 
01965     <span class="keywordflow">return</span> <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a>;
01966 }
01967 
01968 
01969 BOOLEAN
<a name="l01970"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a149">01970</a> <a class="code" href="../../d1/d8/fsrtl_8h.html#a149">FsRtlGetNextLargeMcbEntry</a> (
01971     IN <a class="code" href="../../d0/d9/struct__LARGE__MCB.html">PLARGE_MCB</a> OpaqueMcb,
01972     IN ULONG RunIndex,
01973     OUT PLONGLONG LargeVbn,
01974     OUT PLONGLONG LargeLbn,
01975     OUT PLONGLONG LargeSectorCount
01976     )
01977 
01978 <span class="comment">/*++</span>
01979 <span class="comment"></span>
01980 <span class="comment">Routine Description:</span>
01981 <span class="comment"></span>
01982 <span class="comment">    This routine returns to its caller the Vbn, Lbn, and SectorCount for</span>
01983 <span class="comment">    distinct runs mapped by an Mcb.  Holes are counted as runs.  For example,</span>
01984 <span class="comment">    to construct to print out all of the runs in a a file is:</span>
01985 <span class="comment"></span>
01986 <span class="comment">//. .   for (i = 0; FsRtlGetNextLargeMcbEntry(Mcb,i,&amp;Vbn,&amp;Lbn,&amp;Count); i++) {</span>
01987 <span class="comment">//</span>
01988 <span class="comment">//. .       // print out vbn, lbn, and count</span>
01989 <span class="comment">//</span>
01990 <span class="comment">//. .       }</span>
01991 <span class="comment"></span>
01992 <span class="comment">Arguments:</span>
01993 <span class="comment"></span>
01994 <span class="comment">    OpaqueMcb - Supplies the Mcb being examined.</span>
01995 <span class="comment"></span>
01996 <span class="comment">    RunIndex - Supplies the index of the run (zero based) to return to the</span>
01997 <span class="comment">        caller.</span>
01998 <span class="comment"></span>
01999 <span class="comment">    Vbn - Receives the starting Vbn of the returned run, or zero if the</span>
02000 <span class="comment">        run does not exist.</span>
02001 <span class="comment"></span>
02002 <span class="comment">    Lbn - Recieves the starting Lbn of the returned run, or zero if the</span>
02003 <span class="comment">        run does not exist.</span>
02004 <span class="comment"></span>
02005 <span class="comment">    SectorCount - Receives the number of sectors within the returned run,</span>
02006 <span class="comment">        or zero if the run does not exist.</span>
02007 <span class="comment"></span>
02008 <span class="comment">Return Value:</span>
02009 <span class="comment"></span>
02010 <span class="comment">    BOOLEAN - TRUE if the specified run (i.e., RunIndex) exists in the Mcb,</span>
02011 <span class="comment">        and FALSE otherwise.  If FALSE is returned then the Vbn, Lbn, and</span>
02012 <span class="comment">        SectorCount parameters receive zero.</span>
02013 <span class="comment"></span>
02014 <span class="comment">--*/</span>
02015 
02016 {
02017     <a class="code" href="../../d1/d1/largemcb_8c.html#a21">PNONOPAQUE_MCB</a> Mcb = (<a class="code" href="../../d1/d1/largemcb_8c.html#a21">PNONOPAQUE_MCB</a>)OpaqueMcb;
02018 
02019     BOOLEAN Result;
02020 
02021     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
02022 
02023     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlGetNextLargeMcbEntry, Mcb = %08lx\n"</span>, Mcb );
02024     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">" RunIndex = %08lx\n"</span>, RunIndex );
02025 
02026     ExAcquireFastMutex( Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o0">FastMutex</a> );
02027 
02028     <span class="keywordflow">try</span> {
02029 
02030         <span class="comment">//</span>
02031         <span class="comment">//  Make sure the run index is within range</span>
02032         <span class="comment">//</span>
02033 
02034         <span class="keywordflow">if</span> (RunIndex &gt;= Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o2">PairCount</a>) {
02035 
02036             <a class="code" href="../../d5/d5/cc_8h.html#a90">try_return</a> (Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
02037         }
02038 
02039         <span class="comment">//</span>
02040         <span class="comment">//  Set the return variables</span>
02041         <span class="comment">//</span>
02042 
02043         *((PULONG)LargeVbn) = <a class="code" href="../../d1/d1/largemcb_8c.html#a4">StartingVbn</a>(Mcb,RunIndex);
02044         *((PULONG)LargeLbn) = <a class="code" href="../../d1/d1/largemcb_8c.html#a8">StartingLbn</a>(Mcb,RunIndex);
02045         *((PULONG)LargeSectorCount) = <a class="code" href="../../d1/d1/largemcb_8c.html#a11">SectorsWithinRun</a>(Mcb,RunIndex);
02046 
02047         Result = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02048 
02049     try_exit: NOTHING;
02050     } finally {
02051 
02052         ExReleaseFastMutex( Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o0">FastMutex</a> );
02053 
02054         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlGetNextLargeMcbEntry -&gt; %08lx\n"</span>, Result );
02055     }
02056 
02057     ((PLARGE_INTEGER)LargeVbn)-&gt;HighPart = (*((PULONG)LargeVbn) == <a class="code" href="../../d1/d1/largemcb_8c.html#a1">UNUSED_LBN</a> ? <a class="code" href="../../d1/d1/largemcb_8c.html#a1">UNUSED_LBN</a> : 0);
02058     ((PLARGE_INTEGER)LargeLbn)-&gt;HighPart = (*((PULONG)LargeLbn) == <a class="code" href="../../d1/d1/largemcb_8c.html#a1">UNUSED_LBN</a> ? <a class="code" href="../../d1/d1/largemcb_8c.html#a1">UNUSED_LBN</a> : 0);
02059     ((PLARGE_INTEGER)LargeSectorCount)-&gt;HighPart = 0;
02060 
02061     <span class="keywordflow">return</span> Result;
02062 }
02063 
02064 
02065 BOOLEAN
<a name="l02066"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a150">02066</a> <a class="code" href="../../d1/d8/fsrtl_8h.html#a150">FsRtlSplitLargeMcb</a> (
02067     IN <a class="code" href="../../d0/d9/struct__LARGE__MCB.html">PLARGE_MCB</a> OpaqueMcb,
02068     IN LONGLONG LargeVbn,
02069     IN LONGLONG LargeAmount
02070     )
02071 
02072 <span class="comment">/*++</span>
02073 <span class="comment"></span>
02074 <span class="comment">Routine Description:</span>
02075 <span class="comment"></span>
02076 <span class="comment">    This routine is used to create a hole within an MCB, by shifting the</span>
02077 <span class="comment">    mapping of Vbns.  All mappings above the input vbn are shifted by the</span>
02078 <span class="comment">    amount specified and while keeping their current lbn value.  Pictorially</span>
02079 <span class="comment">    we have as input the following MCB</span>
02080 <span class="comment"></span>
02081 <span class="comment">        VBN :       LargeVbn-1 LargeVbn         N</span>
02082 <span class="comment">            +-----------------+------------------+</span>
02083 <span class="comment">        LBN :             X        Y</span>
02084 <span class="comment"></span>
02085 <span class="comment">    And after the split we have</span>
02086 <span class="comment"></span>
02087 <span class="comment">        VBN :       LargeVbn-1               LargeVbn+Amount    N+Amount</span>
02088 <span class="comment">            +-----------------+.............+---------------------------+</span>
02089 <span class="comment">        LBN :             X      UnusedLbn       Y</span>
02090 <span class="comment"></span>
02091 <span class="comment">    When doing the split we have a few cases to consider.  They are:</span>
02092 <span class="comment"></span>
02093 <span class="comment">    1. The input Vbn is beyond the last run.  In this case this operation</span>
02094 <span class="comment">       is a noop.</span>
02095 <span class="comment"></span>
02096 <span class="comment">    2. The input Vbn is within or adjacent to a existing run of unused Lbns.</span>
02097 <span class="comment">       In this case we simply need to extend the size of the existing hole</span>
02098 <span class="comment">       and shift succeeding runs.</span>
02099 <span class="comment"></span>
02100 <span class="comment">    3. The input Vbn is between two existing runs, including the an input vbn</span>
02101 <span class="comment">       value of zero.  In this case we need to add a new entry for the hole</span>
02102 <span class="comment">       and shift succeeding runs.</span>
02103 <span class="comment"></span>
02104 <span class="comment">    4. The input Vbn is within an existing run.  In this case we need to add</span>
02105 <span class="comment">       two new entries to contain the split run and the hole.</span>
02106 <span class="comment"></span>
02107 <span class="comment">    If pool is not available to store the information this routine will raise a</span>
02108 <span class="comment">    status value indicating insufficient resources.</span>
02109 <span class="comment"></span>
02110 <span class="comment">Arguments:</span>
02111 <span class="comment"></span>
02112 <span class="comment">    OpaqueMcb - Supplies the Mcb in which to add the new mapping.</span>
02113 <span class="comment"></span>
02114 <span class="comment">    Vbn - Supplies the starting Vbn that is to be shifted.</span>
02115 <span class="comment"></span>
02116 <span class="comment">    Amount - Supplies the amount to shift by.</span>
02117 <span class="comment"></span>
02118 <span class="comment">Return Value:</span>
02119 <span class="comment"></span>
02120 <span class="comment">    BOOLEAN - TRUE if the mapping was successfully shifted, and FALSE otherwise.</span>
02121 <span class="comment">        If FALSE is returned then the Mcb is not changed.</span>
02122 <span class="comment"></span>
02123 <span class="comment">--*/</span>
02124 
02125 {
02126     <a class="code" href="../../d1/d1/largemcb_8c.html#a21">PNONOPAQUE_MCB</a> Mcb = (<a class="code" href="../../d1/d1/largemcb_8c.html#a21">PNONOPAQUE_MCB</a>)OpaqueMcb;
02127 
02128     <a class="code" href="../../d1/d8/fsrtl_8h.html#a52">VBN</a> Vbn = ((ULONG)LargeVbn);
02129     ULONG Amount = ((ULONG)LargeAmount);
02130 
02131     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
02132 
02133     BOOLEAN Result;
02134 
02135     ULONG i;
02136 
02137     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
02138 
02139     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlSplitLargeMcb, Mcb = %08lx\n"</span>, Mcb );
02140     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">" Vbn    = %08lx\n"</span>, Vbn );
02141     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">" Amount = %08lx\n"</span>, Amount );
02142 
02143     ExAcquireFastMutex( Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o0">FastMutex</a> );
02144 
02145     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a8">ASSERTMSG</a>(<span class="stringliteral">"LargeInteger not supported yet "</span>, ((((PLARGE_INTEGER)&amp;LargeVbn)-&gt;HighPart == 0) ||
02146                                                   (Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o2">PairCount</a> == 0)));
02147     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a8">ASSERTMSG</a>(<span class="stringliteral">"LargeInteger not supported yet "</span>, ((((PLARGE_INTEGER)&amp;LargeAmount)-&gt;HighPart == 0) ||
02148                                                   (Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o2">PairCount</a> == 0)));
02149 
02150     <span class="keywordflow">try</span> {
02151 
02152         <span class="comment">//</span>
02153         <span class="comment">//  First lookup the index for the entry that we are going to split.</span>
02154         <span class="comment">//  If we can't find the entry then there is nothing to split.  This</span>
02155         <span class="comment">//  takes care of the case where the input vbn is beyond the last run</span>
02156         <span class="comment">//  in the mcb</span>
02157         <span class="comment">//</span>
02158 
02159         <span class="keywordflow">if</span> (!<a class="code" href="../../d1/d1/largemcb_8c.html#a25">FsRtlFindLargeIndex</a>( Mcb, Vbn, &amp;<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>)) {
02160 
02161             <a class="code" href="../../d5/d5/cc_8h.html#a90">try_return</a>(Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
02162         }
02163 
02164         <span class="comment">//</span>
02165         <span class="comment">//  Now check if the input Vbn is within a hole</span>
02166         <span class="comment">//</span>
02167 
02168         <span class="keywordflow">if</span> (<a class="code" href="../../d1/d1/largemcb_8c.html#a8">StartingLbn</a>(Mcb,<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>) == <a class="code" href="../../d1/d1/largemcb_8c.html#a1">UNUSED_LBN</a>) {
02169 
02170             <span class="comment">//</span>
02171             <span class="comment">//  Before: --PreviousRun--||--IndexHole--||--FollowingRun--</span>
02172             <span class="comment">//  After:  --PreviousRun--||----IndexHole----||--FollowingRun--</span>
02173             <span class="comment">//</span>
02174             <span class="comment">//      In this case the vbn is somewhere within the hole and we</span>
02175             <span class="comment">//      simply need to added the amount of each existing run</span>
02176             <span class="comment">//      beyond the hole.</span>
02177             <span class="comment">//</span>
02178 
02179             <span class="comment">//</span>
02180             <span class="comment">//  In this case there is really nothing to do here because the</span>
02181             <span class="comment">//  ending code will already shift the runs by proper amount</span>
02182             <span class="comment">//  starting at index</span>
02183             <span class="comment">//</span>
02184 
02185             NOTHING;
02186 
02187         <span class="comment">//</span>
02188         <span class="comment">//  Now check if the input vbn is between a hole and an existing run.</span>
02189         <span class="comment">//</span>
02190 
02191         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((<a class="code" href="../../d1/d1/largemcb_8c.html#a4">StartingVbn</a>(Mcb,<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>) == Vbn) &amp;&amp; (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> != 0) &amp;&amp; (<a class="code" href="../../d1/d1/largemcb_8c.html#a7">PreviousEndingLbn</a>(Mcb,<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>) == <a class="code" href="../../d1/d1/largemcb_8c.html#a1">UNUSED_LBN</a>)) {
02192 
02193             <span class="comment">//</span>
02194             <span class="comment">//  Before: --Hole--||--IndexRun--</span>
02195             <span class="comment">//  After:  --Hole------||--IndexRun--</span>
02196             <span class="comment">//</span>
02197             <span class="comment">//      In this case the vbn points to the start of the existing</span>
02198             <span class="comment">//      run and we need to do the split between the hole and the</span>
02199             <span class="comment">//      existing run by simply adding the amount to each existing</span>
02200             <span class="comment">//      run beyond the hole.</span>
02201             <span class="comment">//</span>
02202 
02203             <span class="comment">//</span>
02204             <span class="comment">//  In this case we need to decement the index by 1 and then</span>
02205             <span class="comment">//  fall to the bottom code which will do the shifting for us</span>
02206             <span class="comment">//</span>
02207 
02208             <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> -= 1;
02209 
02210         <span class="comment">//</span>
02211         <span class="comment">//  Now check if the input vbn is between two existing runs</span>
02212         <span class="comment">//</span>
02213 
02214         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="../../d1/d1/largemcb_8c.html#a4">StartingVbn</a>(Mcb,<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>) == Vbn) {
02215 
02216             <span class="comment">//</span>
02217             <span class="comment">//  Before: --PreviousRun--||--IndexRun--</span>
02218             <span class="comment">//  After:  --PreviousRun--||--NewHole--||--IndexRun--</span>
02219             <span class="comment">//</span>
02220             <span class="comment">//  Before: 0:|--IndexRun--</span>
02221             <span class="comment">//  After:  0:|--NewHole--||--IndexRun--</span>
02222             <span class="comment">//</span>
02223             <span class="comment">//      In this case the vbn points to the start of an existing</span>
02224             <span class="comment">//      run and the preceeding is either a real run or the start</span>
02225             <span class="comment">//      of mapping pairs We simply add a new entry for the hole</span>
02226             <span class="comment">//      and shift succeeding runs.</span>
02227             <span class="comment">//</span>
02228 
02229             <a class="code" href="../../d1/d1/largemcb_8c.html#a26">FsRtlAddLargeEntry</a>( Mcb, <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>, 1 );
02230 
02231             (Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o4">Mapping</a>)[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].Lbn = (<a class="code" href="../../d1/d8/fsrtl_8h.html#a50">LBN</a>)<a class="code" href="../../d1/d1/largemcb_8c.html#a1">UNUSED_LBN</a>;
02232             (Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o4">Mapping</a>)[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].NextVbn = Vbn + Amount;
02233 
02234             <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> += 1;
02235 
02236         <span class="comment">//</span>
02237         <span class="comment">//  Otherwise the input vbn is inside an existing run</span>
02238         <span class="comment">//</span>
02239 
02240         } <span class="keywordflow">else</span> {
02241 
02242             <span class="comment">//</span>
02243             <span class="comment">//  Before: --IndexRun--</span>
02244             <span class="comment">//  After:  --SplitRun--||--NewHole--||--SplitRun--</span>
02245             <span class="comment">//</span>
02246             <span class="comment">//      In this case the vbn points within an existing run</span>
02247             <span class="comment">//      we need to add two new extries for hole and split</span>
02248             <span class="comment">//      run and shift succeeding runs</span>
02249             <span class="comment">//</span>
02250 
02251             <a class="code" href="../../d1/d1/largemcb_8c.html#a26">FsRtlAddLargeEntry</a>( Mcb, <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>, 2 );
02252 
02253             (Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o4">Mapping</a>)[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].Lbn = (Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o4">Mapping</a>)[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>+2].Lbn;
02254             (Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o4">Mapping</a>)[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].NextVbn = Vbn;
02255 
02256             (Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o4">Mapping</a>)[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>+1].Lbn = (<a class="code" href="../../d1/d8/fsrtl_8h.html#a50">LBN</a>)<a class="code" href="../../d1/d1/largemcb_8c.html#a1">UNUSED_LBN</a>;
02257             (Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o4">Mapping</a>)[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>+1].NextVbn = Vbn + Amount;
02258 
02259             (Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o4">Mapping</a>)[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>+2].Lbn = (Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o4">Mapping</a>)[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>+2].Lbn +
02260                                           <a class="code" href="../../d1/d1/largemcb_8c.html#a4">StartingVbn</a>(Mcb, <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>+1) -
02261                                           <a class="code" href="../../d1/d1/largemcb_8c.html#a4">StartingVbn</a>(Mcb, <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>);
02262 
02263             <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> += 2;
02264 
02265         }
02266 
02267         <span class="comment">//</span>
02268         <span class="comment">//  At this point we have completed most of the work we now need to</span>
02269         <span class="comment">//  shift existing runs from the index to the end of the mappings</span>
02270         <span class="comment">//  by the specified amount</span>
02271         <span class="comment">//</span>
02272 
02273         <span class="keywordflow">for</span> (i = <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>; i &lt; Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o2">PairCount</a>; i += 1) {
02274 
02275             (Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o4">Mapping</a>)[i].NextVbn += Amount;
02276         }
02277 
02278         Result = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02279 
02280     try_exit: NOTHING;
02281     } finally {
02282 
02283         ExReleaseFastMutex( Mcb-&gt;<a class="code" href="../../d5/d3/struct__NONOPAQUE__MCB.html#o0">FastMutex</a> );
02284 
02285         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlSplitLargeMcb -&gt; %08lx\n"</span>, Result );
02286     }
02287 
02288     <span class="keywordflow">return</span> Result;
02289 }
02290 
02291 
02292 <span class="comment">//</span>
02293 <span class="comment">//  Private support routine</span>
02294 <span class="comment">//</span>
02295 
02296 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l02297"></a><a class="code" href="../../d1/d1/largemcb_8c.html#a24">02297</a> <a class="code" href="../../d1/d1/largemcb_8c.html#a24">FsRtlRemoveMcbEntryPrivate</a> (
02298     IN PNONOPAQUE_MCB Mcb,
02299     IN ULONG Vbn,
02300     IN ULONG SectorCount
02301     )
02302 
02303 <span class="comment">/*++</span>
02304 <span class="comment"></span>
02305 <span class="comment">Routine Description:</span>
02306 <span class="comment"></span>
02307 <span class="comment">    This is the work routine for remove large mcb entry.  It does the work</span>
02308 <span class="comment">    without taking out the mcb FastMutex.</span>
02309 <span class="comment"></span>
02310 <span class="comment">Arguments:</span>
02311 <span class="comment"></span>
02312 <span class="comment">    Mcb - Supplies the Mcb from which to remove the mapping.</span>
02313 <span class="comment"></span>
02314 <span class="comment">    Vbn - Supplies the starting Vbn of the mappings to remove.</span>
02315 <span class="comment"></span>
02316 <span class="comment">    SectorCount - Supplies the size of the mappings to remove (in sectors).</span>
02317 <span class="comment"></span>
02318 <span class="comment">Return Value:</span>
02319 <span class="comment"></span>
02320 <span class="comment">    None.</span>
02321 <span class="comment"></span>
02322 <span class="comment">--*/</span>
02323 
02324 {
02325     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
02326 
02327     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
02328 
02329     <span class="comment">//</span>
02330     <span class="comment">//  Do a quick test to see if we are wiping out the entire MCB.</span>
02331     <span class="comment">//</span>
02332 
02333     <span class="keywordflow">if</span> ((Vbn == 0) &amp;&amp; (Mcb-&gt;PairCount &gt; 0) &amp;&amp; (SectorCount &gt;= Mcb-&gt;Mapping[Mcb-&gt;PairCount-1].NextVbn)) {
02334 
02335         Mcb-&gt;PairCount = 0;
02336 
02337         <span class="keywordflow">return</span>;
02338     }
02339 
02340     <span class="comment">//</span>
02341     <span class="comment">//  While there is some more mapping to remove we'll continue</span>
02342     <span class="comment">//  with our main loop</span>
02343     <span class="comment">//</span>
02344 
02345     <span class="keywordflow">while</span> (SectorCount &gt; 0) {
02346 
02347         <span class="comment">//</span>
02348         <span class="comment">//  Locate the mapping for the vbn</span>
02349         <span class="comment">//</span>
02350 
02351         <span class="keywordflow">if</span> (!<a class="code" href="../../d1/d1/largemcb_8c.html#a25">FsRtlFindLargeIndex</a>(Mcb, Vbn, &amp;<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>)) {
02352 
02353             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlRemoveLargeMcbEntry, Cannot remove an unmapped Vbn = %08lx\n"</span>, Vbn );
02354 
02355             <span class="keywordflow">return</span>;
02356         }
02357 
02358         <span class="comment">//</span>
02359         <span class="comment">//  Now that we some something to remove the following cases must</span>
02360         <span class="comment">//  be considered</span>
02361         <span class="comment">//</span>
02362 
02363         <span class="keywordflow">if</span> ((<a class="code" href="../../d1/d1/largemcb_8c.html#a4">StartingVbn</a>(Mcb,<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>) == Vbn) &amp;&amp;
02364             (<a class="code" href="../../d1/d1/largemcb_8c.html#a5">EndingVbn</a>(Mcb,<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>) &lt; Vbn + SectorCount)) {
02365 
02366             ULONG i;
02367 
02368             <span class="comment">//</span>
02369             <span class="comment">//  Removes the entire run</span>
02370             <span class="comment">//</span>
02371 
02372             <span class="comment">//</span>
02373             <span class="comment">//  Update the amount to remove</span>
02374             <span class="comment">//</span>
02375 
02376             i = <a class="code" href="../../d1/d1/largemcb_8c.html#a11">SectorsWithinRun</a>(Mcb,<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>);
02377             Vbn += i;
02378             SectorCount -= i;
02379 
02380             <span class="comment">//</span>
02381             <span class="comment">//  If already a hole then leave it alone</span>
02382             <span class="comment">//</span>
02383 
02384             <span class="keywordflow">if</span> (<a class="code" href="../../d1/d1/largemcb_8c.html#a8">StartingLbn</a>(Mcb,<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>) == <a class="code" href="../../d1/d1/largemcb_8c.html#a1">UNUSED_LBN</a>) {
02385 
02386                 NOTHING;
02387 
02388             <span class="comment">//</span>
02389             <span class="comment">//  Test for last run</span>
02390             <span class="comment">//</span>
02391 
02392             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> == Mcb-&gt;PairCount - 1) {
02393 
02394                 <span class="keywordflow">if</span> ((<a class="code" href="../../d1/d1/largemcb_8c.html#a7">PreviousEndingLbn</a>(Mcb,<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>) != <a class="code" href="../../d1/d1/largemcb_8c.html#a1">UNUSED_LBN</a>) ||
02395                     (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> == 0)) {
02396 
02397                     <span class="comment">//</span>
02398                     <span class="comment">//  Previous is not hole, index is last run</span>
02399                     <span class="comment">//</span>
02400                     <span class="comment">//  --Previous--|  Hole</span>
02401                     <span class="comment">//</span>
02402                     <span class="comment">//  0:  Hole</span>
02403                     <span class="comment">//</span>
02404 
02405                     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"Entire run, Previous not hole, index is last run\n"</span>, 0);
02406 
02407                     <span class="comment">//</span>
02408                     <span class="comment">//  Just remove this entry</span>
02409                     <span class="comment">//</span>
02410 
02411                     <a class="code" href="../../d1/d1/largemcb_8c.html#a27">FsRtlRemoveLargeEntry</a>( Mcb, <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>, 1);
02412 
02413                 } <span class="keywordflow">else</span> {
02414 
02415                     <span class="comment">//</span>
02416                     <span class="comment">//  Previous is hole, index is last run</span>
02417                     <span class="comment">//</span>
02418                     <span class="comment">//  --Hole--|  Hole</span>
02419                     <span class="comment">//</span>
02420 
02421                     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"Entire run, Previous hole, index is last run\n"</span>, 0);
02422 
02423                     <span class="comment">//</span>
02424                     <span class="comment">//  Just remove this entry, and preceding entry</span>
02425                     <span class="comment">//</span>
02426 
02427                     <a class="code" href="../../d1/d1/largemcb_8c.html#a27">FsRtlRemoveLargeEntry</a>( Mcb, <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>-1, 2);
02428                 }
02429 
02430             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (((<a class="code" href="../../d1/d1/largemcb_8c.html#a7">PreviousEndingLbn</a>(Mcb,<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>) != <a class="code" href="../../d1/d1/largemcb_8c.html#a1">UNUSED_LBN</a>) || (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> == 0)) &amp;&amp;
02431                        (<a class="code" href="../../d1/d1/largemcb_8c.html#a10">NextStartingLbn</a>(Mcb,<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>) != <a class="code" href="../../d1/d1/largemcb_8c.html#a1">UNUSED_LBN</a>)) {
02432 
02433                 <span class="comment">//</span>
02434                 <span class="comment">//  Previous and following are not holes</span>
02435                 <span class="comment">//</span>
02436                 <span class="comment">//  --Previous--|  Hole  |--Following--</span>
02437                 <span class="comment">//</span>
02438                 <span class="comment">//  0:  Hole  |--Following--</span>
02439                 <span class="comment">//</span>
02440 
02441                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"Entire run, Previous &amp; Following not holes\n"</span>, 0);
02442 
02443                 <span class="comment">//</span>
02444                 <span class="comment">//  Make this index a hole</span>
02445                 <span class="comment">//</span>
02446 
02447                 (Mcb-&gt;Mapping)[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].Lbn = (<a class="code" href="../../d1/d8/fsrtl_8h.html#a50">LBN</a>)<a class="code" href="../../d1/d1/largemcb_8c.html#a1">UNUSED_LBN</a>;
02448 
02449             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (((<a class="code" href="../../d1/d1/largemcb_8c.html#a7">PreviousEndingLbn</a>(Mcb,<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>) != <a class="code" href="../../d1/d1/largemcb_8c.html#a1">UNUSED_LBN</a>) || (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> == 0)) &amp;&amp;
02450                        (<a class="code" href="../../d1/d1/largemcb_8c.html#a10">NextStartingLbn</a>(Mcb,<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>) == <a class="code" href="../../d1/d1/largemcb_8c.html#a1">UNUSED_LBN</a>)) {
02451 
02452                 <span class="comment">//</span>
02453                 <span class="comment">//  Following is hole</span>
02454                 <span class="comment">//</span>
02455                 <span class="comment">//  --Previous--|  Hole  |--Hole--</span>
02456                 <span class="comment">//</span>
02457                 <span class="comment">//  0:  Hole  |--Hole--</span>
02458                 <span class="comment">//</span>
02459 
02460                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"Entire run, Following is hole\n"</span>, 0);
02461 
02462                 <span class="comment">//</span>
02463                 <span class="comment">//  Simply remove this entry</span>
02464                 <span class="comment">//</span>
02465 
02466                 <a class="code" href="../../d1/d1/largemcb_8c.html#a27">FsRtlRemoveLargeEntry</a>( Mcb, <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>, 1 );
02467 
02468             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((<a class="code" href="../../d1/d1/largemcb_8c.html#a7">PreviousEndingLbn</a>(Mcb,<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>) == <a class="code" href="../../d1/d1/largemcb_8c.html#a1">UNUSED_LBN</a>) &amp;&amp;
02469                        (<a class="code" href="../../d1/d1/largemcb_8c.html#a10">NextStartingLbn</a>(Mcb,<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>) != <a class="code" href="../../d1/d1/largemcb_8c.html#a1">UNUSED_LBN</a>)) {
02470 
02471                 <span class="comment">//</span>
02472                 <span class="comment">//  Previous is hole</span>
02473                 <span class="comment">//</span>
02474                 <span class="comment">//  --Hole--|  Hole  |--Following--</span>
02475                 <span class="comment">//</span>
02476 
02477                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"Entire run, Previous is hole\n"</span>, 0);
02478 
02479                 <span class="comment">//</span>
02480                 <span class="comment">//  Mark current entry a hole</span>
02481                 <span class="comment">//</span>
02482 
02483                 (Mcb-&gt;Mapping)[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].Lbn = (<a class="code" href="../../d1/d8/fsrtl_8h.html#a50">LBN</a>)<a class="code" href="../../d1/d1/largemcb_8c.html#a1">UNUSED_LBN</a>;
02484 
02485                 <span class="comment">//</span>
02486                 <span class="comment">//  Remove previous entry</span>
02487                 <span class="comment">//</span>
02488 
02489                 <a class="code" href="../../d1/d1/largemcb_8c.html#a27">FsRtlRemoveLargeEntry</a>( Mcb, <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> - 1, 1 );
02490 
02491             } <span class="keywordflow">else</span> {
02492 
02493                 <span class="comment">//</span>
02494                 <span class="comment">//  Previous and following are holes</span>
02495                 <span class="comment">//</span>
02496                 <span class="comment">//  --Hole--|  Hole  |--Hole--</span>
02497                 <span class="comment">//</span>
02498 
02499                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"Entire run, Previous &amp; following are holes\n"</span>, 0);
02500 
02501                 <span class="comment">//</span>
02502                 <span class="comment">//  Remove previous and this entry</span>
02503                 <span class="comment">//</span>
02504 
02505                 <a class="code" href="../../d1/d1/largemcb_8c.html#a27">FsRtlRemoveLargeEntry</a>( Mcb, <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> - 1, 2 );
02506             }
02507 
02508         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="../../d1/d1/largemcb_8c.html#a4">StartingVbn</a>(Mcb,<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>) == Vbn) {
02509 
02510             <span class="comment">//</span>
02511             <span class="comment">//  Removes first part of run</span>
02512             <span class="comment">//</span>
02513 
02514             <span class="comment">//</span>
02515             <span class="comment">//  If already a hole then leave it alone</span>
02516             <span class="comment">//</span>
02517 
02518             <span class="keywordflow">if</span> (<a class="code" href="../../d1/d1/largemcb_8c.html#a8">StartingLbn</a>(Mcb,<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>) == <a class="code" href="../../d1/d1/largemcb_8c.html#a1">UNUSED_LBN</a>) {
02519 
02520                 NOTHING;
02521 
02522             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((<a class="code" href="../../d1/d1/largemcb_8c.html#a7">PreviousEndingLbn</a>(Mcb,<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>) != <a class="code" href="../../d1/d1/largemcb_8c.html#a1">UNUSED_LBN</a>) || (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> == 0)) {
02523 
02524                 <span class="comment">//</span>
02525                 <span class="comment">//  Previous is not hole</span>
02526                 <span class="comment">//</span>
02527                 <span class="comment">//  --Previous--|  Hole  |--Index--||--Following--</span>
02528                 <span class="comment">//</span>
02529                 <span class="comment">//  0:  Hole  |--Index--||--Following--</span>
02530                 <span class="comment">//</span>
02531 
02532                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"1st part, Previous is not hole\n"</span>, 0);
02533 
02534                 <span class="comment">//</span>
02535                 <span class="comment">//  Make room for one more entry.  The NextVbn field of the</span>
02536                 <span class="comment">//  one we're shifting remains valid.</span>
02537                 <span class="comment">//</span>
02538 
02539                 <a class="code" href="../../d1/d1/largemcb_8c.html#a26">FsRtlAddLargeEntry</a>( Mcb, <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>, 1 );
02540 
02541                 <span class="comment">//</span>
02542                 <span class="comment">//  Set the hole</span>
02543                 <span class="comment">//</span>
02544 
02545                 (Mcb-&gt;Mapping)[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].Lbn = (<a class="code" href="../../d1/d8/fsrtl_8h.html#a50">LBN</a>)<a class="code" href="../../d1/d1/largemcb_8c.html#a1">UNUSED_LBN</a>;
02546                 (Mcb-&gt;Mapping)[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].NextVbn = Vbn + SectorCount;
02547 
02548                 <span class="comment">//</span>
02549                 <span class="comment">//  Set the new Lbn for the remaining run</span>
02550                 <span class="comment">//</span>
02551 
02552                 (Mcb-&gt;Mapping)[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>+1].Lbn += SectorCount;
02553 
02554             } <span class="keywordflow">else</span> {
02555 
02556                 <span class="comment">//</span>
02557                 <span class="comment">//  Previous is hole</span>
02558                 <span class="comment">//</span>
02559                 <span class="comment">//  --Hole--|  Hole  |--Index--||--Following--</span>
02560                 <span class="comment">//</span>
02561 
02562                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"1st part, Previous is hole\n"</span>, 0);
02563 
02564                 <span class="comment">//</span>
02565                 <span class="comment">//  Expand the preceding hole</span>
02566                 <span class="comment">//</span>
02567 
02568                 (Mcb-&gt;Mapping)[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>-1].NextVbn += SectorCount;
02569 
02570                 <span class="comment">//</span>
02571                 <span class="comment">//  Set the new Lbn for the remaining run</span>
02572                 <span class="comment">//</span>
02573 
02574                 (Mcb-&gt;Mapping)[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].Lbn += SectorCount;
02575             }
02576 
02577             <span class="comment">//</span>
02578             <span class="comment">//  Update the amount to remove</span>
02579             <span class="comment">//</span>
02580 
02581             Vbn += SectorCount;
02582             SectorCount = 0;
02583 
02584         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="../../d1/d1/largemcb_8c.html#a5">EndingVbn</a>(Mcb,<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>) &lt; Vbn + SectorCount) {
02585 
02586             ULONG AmountToRemove;
02587 
02588             AmountToRemove = <a class="code" href="../../d1/d1/largemcb_8c.html#a5">EndingVbn</a>(Mcb,<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>) - Vbn + 1;
02589 
02590             <span class="comment">//</span>
02591             <span class="comment">//  Removes last part of run</span>
02592             <span class="comment">//</span>
02593 
02594             <span class="comment">//</span>
02595             <span class="comment">//  If already a hole then leave it alone</span>
02596             <span class="comment">//</span>
02597 
02598             <span class="keywordflow">if</span> (<a class="code" href="../../d1/d1/largemcb_8c.html#a8">StartingLbn</a>(Mcb,<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>) == <a class="code" href="../../d1/d1/largemcb_8c.html#a1">UNUSED_LBN</a>) {
02599 
02600                 NOTHING;
02601 
02602             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> == Mcb-&gt;PairCount - 1) {
02603 
02604                 <span class="comment">//</span>
02605                 <span class="comment">//  Index is last run</span>
02606                 <span class="comment">//</span>
02607                 <span class="comment">//  --Previous--||--Index--|  Hole</span>
02608                 <span class="comment">//</span>
02609                 <span class="comment">//  0:|--Index--|  Hole</span>
02610                 <span class="comment">//</span>
02611 
02612                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"last part, Index is last run\n"</span>, 0);
02613 
02614                 <span class="comment">//</span>
02615                 <span class="comment">//  Shrink back the size of the current index</span>
02616                 <span class="comment">//</span>
02617 
02618                 (Mcb-&gt;Mapping)[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].NextVbn -= AmountToRemove;
02619 
02620             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="../../d1/d1/largemcb_8c.html#a10">NextStartingLbn</a>(Mcb,<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>) == <a class="code" href="../../d1/d1/largemcb_8c.html#a1">UNUSED_LBN</a>) {
02621 
02622                 <span class="comment">//</span>
02623                 <span class="comment">//  Following is hole</span>
02624                 <span class="comment">//</span>
02625                 <span class="comment">//  --Previous--||--Index--|  Hole  |--Hole--</span>
02626                 <span class="comment">//</span>
02627                 <span class="comment">//  0:|--Index--|  Hole  |--Hole--</span>
02628                 <span class="comment">//</span>
02629 
02630                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"last part, Following is hole\n"</span>, 0);
02631 
02632                 <span class="comment">//</span>
02633                 <span class="comment">//  Shrink back the size of the current index</span>
02634                 <span class="comment">//</span>
02635 
02636                 (Mcb-&gt;Mapping)[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].NextVbn -= AmountToRemove;
02637 
02638             } <span class="keywordflow">else</span> {
02639 
02640                 <span class="comment">//</span>
02641                 <span class="comment">//  Following is not hole</span>
02642                 <span class="comment">//</span>
02643                 <span class="comment">//  --Previous--||--Index--|  Hole  |--Following--</span>
02644                 <span class="comment">//</span>
02645                 <span class="comment">//</span>
02646                 <span class="comment">//  0:|--Index--|  Hole  |--Following--</span>
02647                 <span class="comment">//</span>
02648 
02649                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"last part, Following is not hole\n"</span>, 0);
02650 
02651                 <span class="comment">//</span>
02652                 <span class="comment">//  Make room for one more entry.  The NextVbn field of the</span>
02653                 <span class="comment">//  one we're shifting remains valid.</span>
02654                 <span class="comment">//</span>
02655 
02656                 <a class="code" href="../../d1/d1/largemcb_8c.html#a26">FsRtlAddLargeEntry</a>( Mcb, <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>+1, 1 );
02657 
02658                 <span class="comment">//</span>
02659                 <span class="comment">//  Set the new hole</span>
02660                 <span class="comment">//</span>
02661 
02662                 (Mcb-&gt;Mapping)[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>+1].Lbn = (<a class="code" href="../../d1/d8/fsrtl_8h.html#a50">LBN</a>)<a class="code" href="../../d1/d1/largemcb_8c.html#a1">UNUSED_LBN</a>;
02663                 (Mcb-&gt;Mapping)[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>+1].NextVbn = (Mcb-&gt;Mapping)[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].NextVbn;
02664 
02665                 <span class="comment">//</span>
02666                 <span class="comment">//  Shrink back the size of the current index</span>
02667                 <span class="comment">//</span>
02668 
02669                 (Mcb-&gt;Mapping)[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].NextVbn -= AmountToRemove;
02670             }
02671 
02672             <span class="comment">//</span>
02673             <span class="comment">//  Update amount to remove</span>
02674             <span class="comment">//</span>
02675 
02676             Vbn += AmountToRemove;
02677             SectorCount -= AmountToRemove;
02678 
02679         } <span class="keywordflow">else</span> {
02680 
02681             <span class="comment">//</span>
02682             <span class="comment">//  If already a hole then leave it alone</span>
02683             <span class="comment">//</span>
02684 
02685             <span class="keywordflow">if</span> (<a class="code" href="../../d1/d1/largemcb_8c.html#a8">StartingLbn</a>(Mcb,<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>) == <a class="code" href="../../d1/d1/largemcb_8c.html#a1">UNUSED_LBN</a>) {
02686 
02687                 NOTHING;
02688 
02689             } <span class="keywordflow">else</span> {
02690 
02691                 <span class="comment">//</span>
02692                 <span class="comment">//  Remove middle of run</span>
02693                 <span class="comment">//</span>
02694                 <span class="comment">//  --Previous--||--Index--|  Hole  |--Index--||--Following--</span>
02695                 <span class="comment">//</span>
02696                 <span class="comment">//  0:|--Index--|  Hole  |--Index--||--Following--</span>
02697                 <span class="comment">//</span>
02698 
02699                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"Middle of run\n"</span>, 0);
02700 
02701                 <span class="comment">//</span>
02702                 <span class="comment">//  Make room for two more entries.  The NextVbn field of the</span>
02703                 <span class="comment">//  one we're shifting remains valid.</span>
02704                 <span class="comment">//</span>
02705 
02706                 <a class="code" href="../../d1/d1/largemcb_8c.html#a26">FsRtlAddLargeEntry</a>( Mcb, <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>, 2 );
02707 
02708                 <span class="comment">//</span>
02709                 <span class="comment">//  Set up the first remaining run</span>
02710                 <span class="comment">//</span>
02711 
02712                 (Mcb-&gt;Mapping)[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].Lbn = (Mcb-&gt;Mapping)[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>+2].Lbn;
02713                 (Mcb-&gt;Mapping)[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].NextVbn = Vbn;
02714 
02715                 <span class="comment">//</span>
02716                 <span class="comment">//  Set up the hole</span>
02717                 <span class="comment">//</span>
02718 
02719                 (Mcb-&gt;Mapping)[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>+1].Lbn = (<a class="code" href="../../d1/d8/fsrtl_8h.html#a50">LBN</a>)<a class="code" href="../../d1/d1/largemcb_8c.html#a1">UNUSED_LBN</a>;
02720                 (Mcb-&gt;Mapping)[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>+1].NextVbn = Vbn + SectorCount;
02721 
02722                 <span class="comment">//</span>
02723                 <span class="comment">//  Set up the second remaining run</span>
02724                 <span class="comment">//</span>
02725 
02726                 (Mcb-&gt;Mapping)[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>+2].Lbn += <a class="code" href="../../d1/d1/largemcb_8c.html#a11">SectorsWithinRun</a>(Mcb,<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>) +
02727                                                <a class="code" href="../../d1/d1/largemcb_8c.html#a11">SectorsWithinRun</a>(Mcb,<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>+1);
02728             }
02729 
02730             <span class="comment">//</span>
02731             <span class="comment">//  Update amount to remove</span>
02732             <span class="comment">//</span>
02733 
02734             Vbn += SectorCount;
02735             SectorCount = 0;
02736         }
02737     }
02738 
02739     <span class="keywordflow">return</span>;
02740 }
02741 
02742 
02743 <span class="comment">//</span>
02744 <span class="comment">//  Private routine</span>
02745 <span class="comment">//</span>
02746 
02747 BOOLEAN
<a name="l02748"></a><a class="code" href="../../d1/d1/largemcb_8c.html#a25">02748</a> <a class="code" href="../../d1/d1/largemcb_8c.html#a25">FsRtlFindLargeIndex</a> (
02749     IN PNONOPAQUE_MCB Mcb,
02750     IN VBN Vbn,
02751     OUT PULONG Index
02752     )
02753 
02754 <span class="comment">/*++</span>
02755 <span class="comment"></span>
02756 <span class="comment">Routine Description:</span>
02757 <span class="comment"></span>
02758 <span class="comment">    This is a private routine that locates a mapping for a Vbn</span>
02759 <span class="comment">    in a given mapping array</span>
02760 <span class="comment"></span>
02761 <span class="comment">Arguments:</span>
02762 <span class="comment"></span>
02763 <span class="comment">    Mcb - Supplies the mapping array to examine</span>
02764 <span class="comment"></span>
02765 <span class="comment">    Vbn - Supplies the Vbn to look up</span>
02766 <span class="comment"></span>
02767 <span class="comment">    Index - Receives the index within the mapping array of the mapping</span>
02768 <span class="comment">        containing the Vbn.  If none if found then the index is set to</span>
02769 <span class="comment">        PairCount.</span>
02770 <span class="comment"></span>
02771 <span class="comment">Return Value:</span>
02772 <span class="comment"></span>
02773 <span class="comment">    BOOLEAN - TRUE if Vbn is found and FALSE otherwise</span>
02774 <span class="comment"></span>
02775 <span class="comment">--*/</span>
02776 
02777 {
02778     LONG MinIndex;
02779     LONG MaxIndex;
02780     LONG MidIndex;
02781 
02782     <span class="comment">//</span>
02783     <span class="comment">//  We'll just do a binary search for the mapping entry.  Min and max</span>
02784     <span class="comment">//  are our search boundaries</span>
02785     <span class="comment">//</span>
02786 
02787     MinIndex = 0;
02788     MaxIndex = Mcb-&gt;PairCount - 1;
02789 
02790     <span class="keywordflow">while</span> (MinIndex &lt;= MaxIndex) {
02791 
02792         <span class="comment">//</span>
02793         <span class="comment">//  Compute the middle index to look at</span>
02794         <span class="comment">//</span>
02795 
02796         MidIndex = ((MaxIndex + MinIndex) / 2);
02797 
02798         <span class="comment">//</span>
02799         <span class="comment">//  check if the Vbn is less than the mapping at the mid index</span>
02800         <span class="comment">//</span>
02801 
02802         <span class="keywordflow">if</span> (Vbn &lt; <a class="code" href="../../d1/d1/largemcb_8c.html#a4">StartingVbn</a>(Mcb, MidIndex)) {
02803 
02804             <span class="comment">//</span>
02805             <span class="comment">//  Vbn is less than the middle index so we need to drop</span>
02806             <span class="comment">//  the max down</span>
02807             <span class="comment">//</span>
02808 
02809             MaxIndex = MidIndex - 1;
02810 
02811         <span class="comment">//</span>
02812         <span class="comment">//  check if the Vbn is greater than the mapping at the mid index</span>
02813         <span class="comment">//</span>
02814 
02815         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Vbn &gt; <a class="code" href="../../d1/d1/largemcb_8c.html#a5">EndingVbn</a>(Mcb, MidIndex)) {
02816 
02817             <span class="comment">//</span>
02818             <span class="comment">//  Vbn is greater than the middle index so we need to bring</span>
02819             <span class="comment">//  up the min</span>
02820             <span class="comment">//</span>
02821 
02822             MinIndex = MidIndex + 1;
02823 
02824         <span class="comment">//</span>
02825         <span class="comment">//  Otherwise we've found the index containing the Vbn so set the</span>
02826         <span class="comment">//  index and return TRUE.</span>
02827         <span class="comment">//</span>
02828 
02829         } <span class="keywordflow">else</span> {
02830 
02831             *<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = MidIndex;
02832 
02833             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02834         }
02835     }
02836 
02837     <span class="comment">//</span>
02838     <span class="comment">//  A match wasn't found so set index to PairCount and return FALSE</span>
02839     <span class="comment">//</span>
02840 
02841     *<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = Mcb-&gt;PairCount;
02842 
02843     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02844 }
02845 
02846 
02847 <span class="comment">//</span>
02848 <span class="comment">//  Private Routine</span>
02849 <span class="comment">//</span>
02850 
02851 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l02852"></a><a class="code" href="../../d1/d1/largemcb_8c.html#a26">02852</a> <a class="code" href="../../d1/d1/largemcb_8c.html#a26">FsRtlAddLargeEntry</a> (
02853     IN PNONOPAQUE_MCB Mcb,
02854     IN ULONG WhereToAddIndex,
02855     IN ULONG AmountToAdd
02856     )
02857 
02858 <span class="comment">/*++</span>
02859 <span class="comment"></span>
02860 <span class="comment">Routine Description:</span>
02861 <span class="comment"></span>
02862 <span class="comment">    This routine takes a current Mcb and detemines if there is enough</span>
02863 <span class="comment">    room to add the new mapping entries.  If there is not enough room</span>
02864 <span class="comment">    it reallocates a new mcb buffer and copies over the current mapping.</span>
02865 <span class="comment">    If also will spread out the current mappings to leave the specified</span>
02866 <span class="comment">    index slots in the mapping unfilled.  For example, if WhereToAddIndex</span>
02867 <span class="comment">    is equal to the current pair count then we don't need to make a hole</span>
02868 <span class="comment">    in the mapping, but if the index is less than the current pair count</span>
02869 <span class="comment">    then we'll need to slide some of the mappings down to make room</span>
02870 <span class="comment">    at the specified index.</span>
02871 <span class="comment"></span>
02872 <span class="comment">Arguments:</span>
02873 <span class="comment"></span>
02874 <span class="comment">    Mcb - Supplies the mcb being checked and modified</span>
02875 <span class="comment"></span>
02876 <span class="comment">    WhereToAddIndex - Supplies the index of where the additional entries</span>
02877 <span class="comment">        need to be made</span>
02878 <span class="comment"></span>
02879 <span class="comment">    AmountToAdd - Supplies the number of additional entries needed in the</span>
02880 <span class="comment">        mcb</span>
02881 <span class="comment"></span>
02882 <span class="comment">Return Value:</span>
02883 <span class="comment"></span>
02884 <span class="comment">    None.</span>
02885 <span class="comment"></span>
02886 <span class="comment">--*/</span>
02887 
02888 {
02889     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
02890 
02891     <span class="comment">//</span>
02892     <span class="comment">//  Check to see if the current buffer is large enough to hold</span>
02893     <span class="comment">//  the additional entries</span>
02894     <span class="comment">//</span>
02895 
02896     <span class="keywordflow">if</span> (Mcb-&gt;PairCount + AmountToAdd &gt; Mcb-&gt;MaximumPairCount) {
02897 
02898         ULONG NewMax;
02899         <a class="code" href="../../d1/d1/largemcb_8c.html#a19">PMAPPING</a> Mapping;
02900 
02901         <span class="comment">//</span>
02902         <span class="comment">//  We need to allocate a new mapping so compute a new maximum pair</span>
02903         <span class="comment">//  count.  We'll only be asked to grow by at most 2 at a time, so</span>
02904         <span class="comment">//  doubling will definitely make us large enough for the new amount.</span>
02905         <span class="comment">//  But we won't double without bounds we'll stop doubling if the</span>
02906         <span class="comment">//  pair count gets too high.</span>
02907         <span class="comment">//</span>
02908 
02909         <span class="keywordflow">if</span> (Mcb-&gt;MaximumPairCount &lt; 2048) {
02910 
02911             NewMax = Mcb-&gt;MaximumPairCount * 2;
02912 
02913         } <span class="keywordflow">else</span> {
02914 
02915             NewMax = Mcb-&gt;MaximumPairCount + 2048;
02916         }
02917 
02918         Mapping = <a class="code" href="../../d3/d8/fsrtlp_8h.html#a2">FsRtlpAllocatePool</a>( Mcb-&gt;PoolType, <span class="keyword">sizeof</span>(<a class="code" href="../../d8/d6/struct__MAPPING.html">MAPPING</a>) * NewMax );
02919 
02920         <span class="comment">//**** RtlZeroMemory( Mapping, sizeof(MAPPING) * NewMax );</span>
02921 
02922         <span class="comment">//</span>
02923         <span class="comment">//  Now copy over the old mapping to the new buffer</span>
02924         <span class="comment">//</span>
02925 
02926         RtlCopyMemory( Mapping, Mcb-&gt;Mapping, <span class="keyword">sizeof</span>(<a class="code" href="../../d1/d1/largemcb_8c.html#a18">MAPPING</a>) * Mcb-&gt;PairCount );
02927 
02928         <span class="comment">//</span>
02929         <span class="comment">//  Deallocate the old buffer</span>
02930         <span class="comment">//</span>
02931 
02932         <span class="keywordflow">if</span> ((Mcb-&gt;PoolType == <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>) &amp;&amp; (Mcb-&gt;MaximumPairCount == <a class="code" href="../../d1/d1/largemcb_8c.html#a17">INITIAL_MAXIMUM_PAIR_COUNT</a>)) {
02933 
02934             <a class="code" href="../../d1/d1/largemcb_8c.html#a14">FsRtlFreeFirstMapping</a>( Mcb-&gt;Mapping );
02935 
02936         } <span class="keywordflow">else</span> {
02937 
02938             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( Mcb-&gt;Mapping );
02939         }
02940 
02941         <span class="comment">//</span>
02942         <span class="comment">//  And set up the new buffer in the Mcb</span>
02943         <span class="comment">//</span>
02944 
02945         Mcb-&gt;Mapping = Mapping;
02946         Mcb-&gt;MaximumPairCount = NewMax;
02947     }
02948 
02949     <span class="comment">//</span>
02950     <span class="comment">//  Now see if we need to shift some entries over according to the</span>
02951     <span class="comment">//  WhereToAddIndex value</span>
02952     <span class="comment">//</span>
02953 
02954     <span class="keywordflow">if</span> (WhereToAddIndex &lt; Mcb-&gt;PairCount) {
02955 
02956         RtlMoveMemory( &amp;((Mcb-&gt;Mapping)[WhereToAddIndex + AmountToAdd]),
02957                        &amp;((Mcb-&gt;Mapping)[WhereToAddIndex]),
02958                        (Mcb-&gt;PairCount - WhereToAddIndex) * <span class="keyword">sizeof</span>(<a class="code" href="../../d8/d6/struct__MAPPING.html">MAPPING</a>) );
02959     }
02960 
02961     <span class="comment">//</span>
02962     <span class="comment">//  Now zero out the new additions</span>
02963     <span class="comment">//</span>
02964 
02965     <span class="comment">//**** RtlZeroMemory( &amp;((Mcb-&gt;Mapping)[WhereToAddIndex]), sizeof(MAPPING) * AmountToAdd );</span>
02966 
02967     <span class="comment">//</span>
02968     <span class="comment">//  Now increment the PairCount</span>
02969     <span class="comment">//</span>
02970 
02971     Mcb-&gt;PairCount += AmountToAdd;
02972 
02973     <span class="comment">//</span>
02974     <span class="comment">//  And return to our caller</span>
02975     <span class="comment">//</span>
02976 
02977     <span class="keywordflow">return</span>;
02978 }
02979 
02980 
02981 <span class="comment">//</span>
02982 <span class="comment">//  Private Routine</span>
02983 <span class="comment">//</span>
02984 
02985 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l02986"></a><a class="code" href="../../d1/d1/largemcb_8c.html#a27">02986</a> <a class="code" href="../../d1/d1/largemcb_8c.html#a27">FsRtlRemoveLargeEntry</a> (
02987     IN PNONOPAQUE_MCB Mcb,
02988     IN ULONG WhereToRemoveIndex,
02989     IN ULONG AmountToRemove
02990     )
02991 
02992 <span class="comment">/*++</span>
02993 <span class="comment"></span>
02994 <span class="comment">Routine Description:</span>
02995 <span class="comment"></span>
02996 <span class="comment">    This routine takes a current Mcb and removes one or more entries.</span>
02997 <span class="comment"></span>
02998 <span class="comment">Arguments:</span>
02999 <span class="comment"></span>
03000 <span class="comment">    Mcb - Supplies the mcb being checked and modified</span>
03001 <span class="comment"></span>
03002 <span class="comment">    WhereToRemoveIndex - Supplies the index of the entries to remove</span>
03003 <span class="comment"></span>
03004 <span class="comment">    AmountToRemove - Supplies the number of entries to remove</span>
03005 <span class="comment"></span>
03006 <span class="comment">Return Value:</span>
03007 <span class="comment"></span>
03008 <span class="comment">    None.</span>
03009 <span class="comment"></span>
03010 <span class="comment">--*/</span>
03011 
03012 {
03013     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
03014 
03015     <span class="comment">//</span>
03016     <span class="comment">//  Check to see if we need to shift everything down because the</span>
03017     <span class="comment">//  entries to remove do not include the last entry in the mcb</span>
03018     <span class="comment">//</span>
03019 
03020     <span class="keywordflow">if</span> (WhereToRemoveIndex + AmountToRemove &lt; Mcb-&gt;PairCount) {
03021 
03022         RtlMoveMemory( &amp;((Mcb-&gt;Mapping)[WhereToRemoveIndex]),
03023                       &amp;((Mcb-&gt;Mapping)[WhereToRemoveIndex + AmountToRemove]),
03024                       (Mcb-&gt;PairCount - (WhereToRemoveIndex + AmountToRemove))
03025                                                            * <span class="keyword">sizeof</span>(<a class="code" href="../../d8/d6/struct__MAPPING.html">MAPPING</a>) );
03026     }
03027 
03028     <span class="comment">//</span>
03029     <span class="comment">//  Now zero out the entries beyond the part we just shifted down</span>
03030     <span class="comment">//</span>
03031 
03032     <span class="comment">//**** RtlZeroMemory( &amp;((Mcb-&gt;Mapping)[Mcb-&gt;PairCount - AmountToRemove]), AmountToRemove * sizeof(MAPPING) );</span>
03033 
03034     <span class="comment">//</span>
03035     <span class="comment">//  Now decrement the PairCount</span>
03036     <span class="comment">//</span>
03037 
03038     Mcb-&gt;PairCount -= AmountToRemove;
03039 
03040     <span class="comment">//</span>
03041     <span class="comment">//  And return to our caller</span>
03042     <span class="comment">//</span>
03043 
03044     <span class="keywordflow">return</span>;
03045 }
03046 
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:40:35 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
