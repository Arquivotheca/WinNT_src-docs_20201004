<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: allocpag.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>allocpag.c</h1><a href="../../d1/d6/allocpag_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1989  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">   allocpag.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module contains the routines which allocate and deallocate</span>
00012 <span class="comment">    one or more pages from paged or nonpaged pool.</span>
00013 <span class="comment"></span>
00014 <span class="comment">Author:</span>
00015 <span class="comment"></span>
00016 <span class="comment">    Lou Perazzoli (loup) 6-Apr-1989</span>
00017 <span class="comment">    Landy Wang (landyw) 02-June-1997</span>
00018 <span class="comment"></span>
00019 <span class="comment">Revision History:</span>
00020 <span class="comment"></span>
00021 <span class="comment">--*/</span>
00022 
00023 <span class="preprocessor">#include "<a class="code" href="../../d4/d8/mi_8h.html">mi.h</a>"</span>
00024 
00025 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00026 <a class="code" href="../../d5/d1/mminit_8c.html#a44">MiInitializeSpecialPool</a> (
00027     VOID
00028     );
00029 
00030 <span class="preprocessor">#ifndef NO_POOL_CHECKS</span>
00031 <span class="preprocessor"></span><a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00032 <a class="code" href="../../d5/d1/mminit_8c.html#a50">MiInitializeSpecialPoolCriteria</a> (
00033     IN VOID
00034     );
00035 
00036 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00037 <a class="code" href="../../d1/d6/allocpag_8c.html#a37">MiSpecialPoolTimerDispatch</a> (
00038     IN <a class="code" href="../../d1/d6/struct__KDPC.html">PKDPC</a> Dpc,
00039     IN PVOID DeferredContext,
00040     IN PVOID SystemArgument1,
00041     IN PVOID SystemArgument2
00042     );
00043 
00044 PVOID
00045 <a class="code" href="../../d1/d6/allocpag_8c.html#a38">MmSqueezeBadTags</a> (
00046     IN SIZE_T NumberOfBytes,
00047     IN ULONG Tag,
00048     IN POOL_TYPE PoolType,
00049     IN ULONG SpecialPoolType
00050     );
00051 <span class="preprocessor">#endif</span>
00052 <span class="preprocessor"></span>
00053 LOGICAL
00054 <a class="code" href="../../d1/d6/allocpag_8c.html#a39">MmSetSpecialPool</a> (
00055     IN LOGICAL Enable
00056     );
00057 
00058 PVOID
00059 <a class="code" href="../../d1/d6/allocpag_8c.html#a40">MiAllocateSpecialPool</a> (
00060     IN SIZE_T NumberOfBytes,
00061     IN ULONG Tag,
00062     IN POOL_TYPE PoolType,
00063     IN ULONG SpecialPoolType
00064     );
00065 
00066 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00067 <a class="code" href="../../d1/d6/allocpag_8c.html#a41">MmFreeSpecialPool</a> (
00068     IN PVOID P
00069     );
00070 
00071 LOGICAL
00072 <a class="code" href="../../d1/d6/allocpag_8c.html#a42">MiProtectSpecialPool</a> (
00073     IN PVOID VirtualAddress,
00074     IN ULONG NewProtect
00075     );
00076 
00077 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00078 <a class="code" href="../../d1/d6/allocpag_8c.html#a43">MiMakeSpecialPoolPagable</a> (
00079     IN PVOID VirtualAddress,
00080     IN <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte
00081     );
00082 
00083 <span class="preprocessor">#ifdef ALLOC_PRAGMA</span>
00084 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(INIT, MiInitializeNonPagedPool)</span>
00085 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(INIT, MiInitializeSpecialPool)</span>
00086 <span class="preprocessor"></span>
00087 <span class="preprocessor">#pragma alloc_text(PAGELK, MiFindContiguousMemory)</span>
00088 <span class="preprocessor"></span>
00089 <span class="preprocessor">#pragma alloc_text(PAGEHYDRA, MiCheckSessionPoolAllocations)</span>
00090 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEHYDRA, MiSessionPoolAllocated)</span>
00091 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEHYDRA, MiSessionPoolFreed)</span>
00092 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEHYDRA, MiSessionPoolVector)</span>
00093 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEHYDRA, MiInitializeSessionPool)</span>
00094 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEHYDRA, MiFreeSessionPoolBitMaps)</span>
00095 <span class="preprocessor"></span>
00096 <span class="preprocessor">#pragma alloc_text(PAGESPEC, MmFreeSpecialPool)</span>
00097 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGESPEC, MiAllocateSpecialPool)</span>
00098 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGESPEC, MiMakeSpecialPoolPagable)</span>
00099 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGESPEC, MiProtectSpecialPool)</span>
00100 <span class="preprocessor"></span>
00101 <span class="preprocessor">#pragma alloc_text(POOLMI, MiAllocatePoolPages)</span>
00102 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(POOLMI, MiFreePoolPages)</span>
00103 <span class="preprocessor"></span>
00104 <span class="preprocessor">#if DBG || (i386 &amp;&amp; !FPO)</span>
00105 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGELK, MmSnapShotPool)</span>
00106 <span class="preprocessor"></span><span class="preprocessor">#endif // DBG || (i386 &amp;&amp; !FPO)</span>
00107 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00108 <span class="preprocessor"></span>
<a name="l00109"></a><a class="code" href="../../d1/d6/allocpag_8c.html#a4">00109</a> ULONG <a class="code" href="../../d8/d5/kddata_8c.html#a34">MmPagedPoolCommit</a>;        <span class="comment">// used by the debugger</span>
00110 
<a name="l00111"></a><a class="code" href="../../d1/d6/allocpag_8c.html#a5">00111</a> PFN_NUMBER <a class="code" href="../../d9/d5/4_2kddata_8c.html#a52">MmAllocatedNonPagedPool</a>;
<a name="l00112"></a><a class="code" href="../../d1/d6/allocpag_8c.html#a6">00112</a> PFN_NUMBER <a class="code" href="../../d1/d6/allocpag_8c.html#a6">MiEndOfInitialPoolFrame</a>;
00113 
<a name="l00114"></a><a class="code" href="../../d1/d6/allocpag_8c.html#a7">00114</a> PVOID <a class="code" href="../../d1/d6/allocpag_8c.html#a7">MmNonPagedPoolExpansionStart</a>;
00115 
<a name="l00116"></a><a class="code" href="../../d1/d6/allocpag_8c.html#a8">00116</a> LIST_ENTRY <a class="code" href="../../d1/d6/allocpag_8c.html#a8">MmNonPagedPoolFreeListHead</a>[<a class="code" href="../../d4/d8/mi_8h.html#a324">MI_MAX_FREE_LIST_HEADS</a>];
00117 
<a name="l00118"></a><a class="code" href="../../d1/d6/allocpag_8c.html#a9">00118</a> <span class="keyword">extern</span> <a class="code" href="../../d4/d8/struct__POOL__DESCRIPTOR.html">POOL_DESCRIPTOR</a> <a class="code" href="../../d2/d2/ex_2pool_8c.html#a52">NonPagedPoolDescriptor</a>;
00119 
<a name="l00120"></a><a class="code" href="../../d1/d6/allocpag_8c.html#a10">00120</a> <span class="keyword">extern</span> LOGICAL <a class="code" href="../../d1/d6/allocpag_8c.html#a10">MmPagedPoolMaximumDesired</a>;
00121 
<a name="l00122"></a><a class="code" href="../../d1/d6/allocpag_8c.html#a0">00122</a> <span class="preprocessor">#define MM_SMALL_ALLOCATIONS 4</span>
00123 <span class="preprocessor"></span>
00124 <span class="preprocessor">#if DBG</span>
00125 <span class="preprocessor"></span>
00126 <span class="comment">//</span>
00127 <span class="comment">// Set this to a nonzero (ie: 10000) value to cause every pool allocation to</span>
00128 <span class="comment">// be checked and an ASSERT fires if the allocation is larger than this value.</span>
00129 <span class="comment">//</span>
00130 
00131 ULONG MmCheckRequestInPages = 0;
00132 
00133 <span class="comment">//</span>
00134 <span class="comment">// Set this to a nonzero (ie: 0x23456789) value to cause this pattern to be</span>
00135 <span class="comment">// written into freed nonpaged pool pages.</span>
00136 <span class="comment">//</span>
00137 
00138 ULONG MiFillFreedPool = 0;
00139 <span class="preprocessor">#endif</span>
00140 <span class="preprocessor"></span>
<a name="l00141"></a><a class="code" href="../../d1/d6/allocpag_8c.html#a11">00141</a> <span class="keyword">extern</span> ULONG <a class="code" href="../../d1/d6/allocpag_8c.html#a11">MmUnusedSegmentForceFree</a>;
00142 
<a name="l00143"></a><a class="code" href="../../d1/d6/allocpag_8c.html#a1">00143</a> <span class="preprocessor">#define MI_MEMORY_MAKER(Thread) \</span>
00144 <span class="preprocessor">    ((Thread-&gt;StartAddress == (PVOID)MiModifiedPageWriter) || \</span>
00145 <span class="preprocessor">     (Thread-&gt;StartAddress == (PVOID)MiMappedPageWriter) || \</span>
00146 <span class="preprocessor">     (Thread-&gt;StartAddress == (PVOID)MiDereferenceSegmentThread))</span>
00147 <span class="preprocessor"></span>
00148 
00149 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00150"></a><a class="code" href="../../d5/d6/iosup_8c.html#a37">00150</a> <a class="code" href="../../d5/d6/iosup_8c.html#a37">MiProtectFreeNonPagedPool</a> (
00151     IN PVOID VirtualAddress,
00152     IN ULONG SizeInPages
00153     )
00154 
00155 <span class="comment">/*++</span>
00156 <span class="comment"></span>
00157 <span class="comment">Routine Description:</span>
00158 <span class="comment"></span>
00159 <span class="comment">    This function protects freed nonpaged pool.</span>
00160 <span class="comment"></span>
00161 <span class="comment">Arguments:</span>
00162 <span class="comment"></span>
00163 <span class="comment">    VirtualAddress - Supplies the freed pool address to protect.</span>
00164 <span class="comment"></span>
00165 <span class="comment">    SizeInPages - Supplies the size of the request in pages.</span>
00166 <span class="comment"></span>
00167 <span class="comment">Return Value:</span>
00168 <span class="comment"></span>
00169 <span class="comment">    None.</span>
00170 <span class="comment"></span>
00171 <span class="comment">Environment:</span>
00172 <span class="comment"></span>
00173 <span class="comment">    Kernel mode.</span>
00174 <span class="comment"></span>
00175 <span class="comment">--*/</span>
00176 
00177 {
00178     ULONG i;
00179     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> PteContents;
00180     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
00181 
00182     <span class="comment">//</span>
00183     <span class="comment">// Prevent anyone from touching the free non paged pool</span>
00184     <span class="comment">//</span>
00185 
00186     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a178">MI_IS_PHYSICAL_ADDRESS</a>(VirtualAddress) == 0) {
00187         PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (VirtualAddress);
00188 
00189         <span class="keywordflow">for</span> (i = 0; i &lt; SizeInPages; i += 1) {
00190 
00191             PteContents = *PointerPte;
00192 
00193             PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid = 0;
00194             PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Prototype = 1;
00195     
00196             <a class="code" href="../../d0/d6/ppc_2flushtb_8c.html#a2">KeFlushSingleTb</a> (VirtualAddress,
00197                              <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
00198                              <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
00199                              (PHARDWARE_PTE)PointerPte,
00200                              PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Flush);
00201             VirtualAddress = (PVOID)((PCHAR)VirtualAddress + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
00202             PointerPte += 1;
00203         }
00204     }
00205 }
00206 
00207 
00208 LOGICAL
<a name="l00209"></a><a class="code" href="../../d5/d6/iosup_8c.html#a38">00209</a> <a class="code" href="../../d5/d6/iosup_8c.html#a38">MiUnProtectFreeNonPagedPool</a> (
00210     IN PVOID VirtualAddress,
00211     IN ULONG SizeInPages
00212     )
00213 
00214 <span class="comment">/*++</span>
00215 <span class="comment"></span>
00216 <span class="comment">Routine Description:</span>
00217 <span class="comment"></span>
00218 <span class="comment">    This function unprotects freed nonpaged pool.</span>
00219 <span class="comment"></span>
00220 <span class="comment">Arguments:</span>
00221 <span class="comment"></span>
00222 <span class="comment">    VirtualAddress - Supplies the freed pool address to unprotect.</span>
00223 <span class="comment"></span>
00224 <span class="comment">    SizeInPages - Supplies the size of the request in pages - zero indicates</span>
00225 <span class="comment">                  to keep going until there are no more protected PTEs (ie: the</span>
00226 <span class="comment">                  caller doesn't know how many protected PTEs there are).</span>
00227 <span class="comment"></span>
00228 <span class="comment">Return Value:</span>
00229 <span class="comment"></span>
00230 <span class="comment">    TRUE if pages were unprotected, FALSE if not.</span>
00231 <span class="comment"></span>
00232 <span class="comment">Environment:</span>
00233 <span class="comment"></span>
00234 <span class="comment">    Kernel mode.</span>
00235 <span class="comment"></span>
00236 <span class="comment">--*/</span>
00237 
00238 {
00239     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
00240     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> PteContents;
00241     ULONG PagesDone;
00242 
00243     PagesDone = 0;
00244 
00245     <span class="comment">//</span>
00246     <span class="comment">// Unprotect the previously freed pool so it can be manipulated</span>
00247     <span class="comment">//</span>
00248 
00249     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a178">MI_IS_PHYSICAL_ADDRESS</a>(VirtualAddress) == 0) {
00250 
00251         PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>((PVOID)VirtualAddress);
00252 
00253         PteContents = *PointerPte;
00254 
00255         <span class="keywordflow">while</span> (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 0 &amp;&amp; PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Prototype == 1) {
00256 
00257             PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid = 1;
00258             PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Prototype = 0;
00259     
00260             <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a186">MI_WRITE_VALID_PTE</a> (PointerPte, PteContents);
00261 
00262             PagesDone += 1;
00263 
00264             <span class="keywordflow">if</span> (PagesDone == SizeInPages) {
00265                 <span class="keywordflow">break</span>;
00266             }
00267 
00268             PointerPte += 1;
00269             PteContents = *PointerPte;
00270         }
00271     }
00272 
00273     <span class="keywordflow">if</span> (PagesDone == 0) {
00274         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00275     }
00276 
00277     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00278 }
00279 
00280 
00281 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00282"></a><a class="code" href="../../d1/d6/allocpag_8c.html#a46">00282</a> <a class="code" href="../../d1/d6/allocpag_8c.html#a46">MiProtectedPoolInsertList</a> (
00283     IN PLIST_ENTRY ListHead,
00284     IN PLIST_ENTRY Entry,
00285     IN LOGICAL InsertHead
00286     )
00287 
00288 <span class="comment">/*++</span>
00289 <span class="comment"></span>
00290 <span class="comment">Routine Description:</span>
00291 <span class="comment"></span>
00292 <span class="comment">    This function inserts the entry into the protected list.</span>
00293 <span class="comment"></span>
00294 <span class="comment">Arguments:</span>
00295 <span class="comment"></span>
00296 <span class="comment">    ListHead - Supplies the list head to add onto.</span>
00297 <span class="comment"></span>
00298 <span class="comment">    Entry - Supplies the list entry to insert.</span>
00299 <span class="comment"></span>
00300 <span class="comment">    InsertHead - If TRUE, insert at the head otherwise at the tail.</span>
00301 <span class="comment"></span>
00302 <span class="comment">Return Value:</span>
00303 <span class="comment"></span>
00304 <span class="comment">    None.</span>
00305 <span class="comment"></span>
00306 <span class="comment">Environment:</span>
00307 <span class="comment"></span>
00308 <span class="comment">    Kernel mode.</span>
00309 <span class="comment"></span>
00310 <span class="comment">--*/</span>
00311 {
00312     PVOID FreeFlink;
00313     PVOID FreeBlink;
00314     PVOID VirtualAddress;
00315 
00316     <span class="comment">//</span>
00317     <span class="comment">// Either the flink or the blink may be pointing</span>
00318     <span class="comment">// at protected nonpaged pool.  Unprotect now.</span>
00319     <span class="comment">//</span>
00320 
00321     FreeFlink = (PVOID)0;
00322     FreeBlink = (PVOID)0;
00323 
00324     <span class="keywordflow">if</span> (IsListEmpty(ListHead) == 0) {
00325 
00326         VirtualAddress = (PVOID)ListHead-&gt;Flink;
00327         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/iosup_8c.html#a38">MiUnProtectFreeNonPagedPool</a> (VirtualAddress, 1) == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
00328             FreeFlink = VirtualAddress;
00329         }
00330     }
00331 
00332     <span class="keywordflow">if</span> (((PVOID)Entry == ListHead-&gt;Blink) == 0) {
00333         VirtualAddress = (PVOID)ListHead-&gt;Blink;
00334         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/iosup_8c.html#a38">MiUnProtectFreeNonPagedPool</a> (VirtualAddress, 1) == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
00335             FreeBlink = VirtualAddress;
00336         }
00337     }
00338 
00339     <span class="keywordflow">if</span> (InsertHead == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
00340         InsertHeadList (ListHead, Entry);
00341     }
00342     <span class="keywordflow">else</span> {
00343         InsertTailList (ListHead, Entry);
00344     }
00345 
00346     <span class="keywordflow">if</span> (FreeFlink) {
00347         <span class="comment">//</span>
00348         <span class="comment">// Reprotect the flink.</span>
00349         <span class="comment">//</span>
00350 
00351         <a class="code" href="../../d5/d6/iosup_8c.html#a37">MiProtectFreeNonPagedPool</a> (FreeFlink, 1);
00352     }
00353 
00354     <span class="keywordflow">if</span> (FreeBlink) {
00355         <span class="comment">//</span>
00356         <span class="comment">// Reprotect the blink.</span>
00357         <span class="comment">//</span>
00358 
00359         <a class="code" href="../../d5/d6/iosup_8c.html#a37">MiProtectFreeNonPagedPool</a> (FreeBlink, 1);
00360     }
00361 }
00362 
00363 
00364 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00365"></a><a class="code" href="../../d1/d6/allocpag_8c.html#a47">00365</a> <a class="code" href="../../d1/d6/allocpag_8c.html#a47">MiProtectedPoolRemoveEntryList</a> (
00366     IN PLIST_ENTRY Entry
00367     )
00368 
00369 <span class="comment">/*++</span>
00370 <span class="comment"></span>
00371 <span class="comment">Routine Description:</span>
00372 <span class="comment"></span>
00373 <span class="comment">    This function unlinks the list pointer from protected freed nonpaged pool.</span>
00374 <span class="comment"></span>
00375 <span class="comment">Arguments:</span>
00376 <span class="comment"></span>
00377 <span class="comment">    Entry - Supplies the list entry to remove.</span>
00378 <span class="comment"></span>
00379 <span class="comment">Return Value:</span>
00380 <span class="comment"></span>
00381 <span class="comment">    None.</span>
00382 <span class="comment"></span>
00383 <span class="comment">Environment:</span>
00384 <span class="comment"></span>
00385 <span class="comment">    Kernel mode.</span>
00386 <span class="comment"></span>
00387 <span class="comment">--*/</span>
00388 {
00389     PVOID FreeFlink;
00390     PVOID FreeBlink;
00391     PVOID VirtualAddress;
00392 
00393     <span class="comment">//</span>
00394     <span class="comment">// Either the flink or the blink may be pointing</span>
00395     <span class="comment">// at protected nonpaged pool.  Unprotect now.</span>
00396     <span class="comment">//</span>
00397 
00398     FreeFlink = (PVOID)0;
00399     FreeBlink = (PVOID)0;
00400 
00401     <span class="keywordflow">if</span> (IsListEmpty(Entry) == 0) {
00402 
00403         VirtualAddress = (PVOID)Entry-&gt;Flink;
00404         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/iosup_8c.html#a38">MiUnProtectFreeNonPagedPool</a> (VirtualAddress, 1) == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
00405             FreeFlink = VirtualAddress;
00406         }
00407     }
00408 
00409     <span class="keywordflow">if</span> (((PVOID)Entry == Entry-&gt;Blink) == 0) {
00410         VirtualAddress = (PVOID)Entry-&gt;Blink;
00411         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/iosup_8c.html#a38">MiUnProtectFreeNonPagedPool</a> (VirtualAddress, 1) == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
00412             FreeBlink = VirtualAddress;
00413         }
00414     }
00415 
00416     RemoveEntryList (Entry);
00417 
00418     <span class="keywordflow">if</span> (FreeFlink) {
00419         <span class="comment">//</span>
00420         <span class="comment">// Reprotect the flink.</span>
00421         <span class="comment">//</span>
00422 
00423         <a class="code" href="../../d5/d6/iosup_8c.html#a37">MiProtectFreeNonPagedPool</a> (FreeFlink, 1);
00424     }
00425 
00426     <span class="keywordflow">if</span> (FreeBlink) {
00427         <span class="comment">//</span>
00428         <span class="comment">// Reprotect the blink.</span>
00429         <span class="comment">//</span>
00430 
00431         <a class="code" href="../../d5/d6/iosup_8c.html#a37">MiProtectFreeNonPagedPool</a> (FreeBlink, 1);
00432     }
00433 }
00434 
00435 
00436 <a class="code" href="../../d5/d8/ex_8h.html#a96">POOL_TYPE</a>
<a name="l00437"></a><a class="code" href="../../d1/d6/allocpag_8c.html#a48">00437</a> <a class="code" href="../../d1/d6/allocpag_8c.html#a48">MmDeterminePoolType</a> (
00438     IN PVOID VirtualAddress
00439     )
00440 
00441 <span class="comment">/*++</span>
00442 <span class="comment"></span>
00443 <span class="comment">Routine Description:</span>
00444 <span class="comment"></span>
00445 <span class="comment">    This function determines which pool a virtual address resides within.</span>
00446 <span class="comment"></span>
00447 <span class="comment">Arguments:</span>
00448 <span class="comment"></span>
00449 <span class="comment">    VirtualAddress - Supplies the virtual address to determine which pool</span>
00450 <span class="comment">                     it resides within.</span>
00451 <span class="comment"></span>
00452 <span class="comment">Return Value:</span>
00453 <span class="comment"></span>
00454 <span class="comment">    Returns the POOL_TYPE (PagedPool, NonPagedPool, PagedPoolSession or</span>
00455 <span class="comment">            NonPagedPoolSession), it never returns any information about</span>
00456 <span class="comment">            MustSucceed pool types.</span>
00457 <span class="comment"></span>
00458 <span class="comment">Environment:</span>
00459 <span class="comment"></span>
00460 <span class="comment">    Kernel Mode Only.</span>
00461 <span class="comment"></span>
00462 <span class="comment">--*/</span>
00463 
00464 {
00465     <span class="keywordflow">if</span> ((VirtualAddress &gt;= <a class="code" href="../../d8/d5/kddata_8c.html#a25">MmPagedPoolStart</a>) &amp;&amp;
00466         (VirtualAddress &lt;= <a class="code" href="../../d8/d5/kddata_8c.html#a26">MmPagedPoolEnd</a>)) {
00467         <span class="keywordflow">return</span> <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>;
00468     }
00469 
00470     <span class="keywordflow">if</span> (<a class="code" href="../../d4/d8/mi_8h.html#a353">MI_IS_SESSION_POOL_ADDRESS</a> (VirtualAddress) == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
00471         <span class="keywordflow">return</span> <a class="code" href="../../d5/d8/ex_8h.html#a329a182">PagedPoolSession</a>;
00472     }
00473 
00474     <span class="keywordflow">return</span> <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>;
00475 }
00476 
00477 
00478 PVOID
<a name="l00479"></a><a class="code" href="../../d1/d6/allocpag_8c.html#a49">00479</a> <a class="code" href="../../d1/d6/allocpag_8c.html#a49">MiSessionPoolVector</a>(
00480     VOID
00481     )
00482 
00483 <span class="comment">/*++</span>
00484 <span class="comment"></span>
00485 <span class="comment">Routine Description:</span>
00486 <span class="comment"></span>
00487 <span class="comment">    This function returns the session pool descriptor for the current session.</span>
00488 <span class="comment"></span>
00489 <span class="comment">Arguments:</span>
00490 <span class="comment"></span>
00491 <span class="comment">    None.</span>
00492 <span class="comment"></span>
00493 <span class="comment">Return Value:</span>
00494 <span class="comment"></span>
00495 <span class="comment">    Pool descriptor.</span>
00496 <span class="comment"></span>
00497 <span class="comment">--*/</span>
00498 
00499 {
00500     <span class="keywordflow">return</span> (PVOID)&amp;<a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o37">PagedPool</a>;
00501 }
00502 
00503 
00504 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00505"></a><a class="code" href="../../d1/d6/allocpag_8c.html#a50">00505</a> <a class="code" href="../../d1/d6/allocpag_8c.html#a50">MiSessionPoolAllocated</a>(
00506     IN PVOID VirtualAddress,
00507     IN SIZE_T NumberOfBytes,
00508     IN POOL_TYPE PoolType
00509     )
00510 
00511 <span class="comment">/*++</span>
00512 <span class="comment"></span>
00513 <span class="comment">Routine Description:</span>
00514 <span class="comment"></span>
00515 <span class="comment">    This function charges the new pool allocation for the current session.</span>
00516 <span class="comment">    On session exit, this charge must be zero.</span>
00517 <span class="comment"></span>
00518 <span class="comment">Arguments:</span>
00519 <span class="comment"></span>
00520 <span class="comment">    VirtualAddress - Supplies the allocated pool address.</span>
00521 <span class="comment"></span>
00522 <span class="comment">    NumberOfBytes - Supplies the number of bytes allocated.</span>
00523 <span class="comment"></span>
00524 <span class="comment">    PoolType - Supplies the type of the above pool allocation.</span>
00525 <span class="comment"></span>
00526 <span class="comment">Return Value:</span>
00527 <span class="comment"></span>
00528 <span class="comment">    None.</span>
00529 <span class="comment"></span>
00530 <span class="comment">--*/</span>
00531 
00532 {
00533     <span class="keywordflow">if</span> ((PoolType &amp; <a class="code" href="../../d4/d2/pool_8h.html#a5">BASE_POOL_TYPE_MASK</a>) == <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>) {
00534         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (<a class="code" href="../../d4/d8/mi_8h.html#a353">MI_IS_SESSION_POOL_ADDRESS</a>(VirtualAddress) == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
00535         <a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o9">NonPagedPoolBytes</a> += NumberOfBytes;
00536         <a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o11">NonPagedPoolAllocations</a> += 1;
00537     }
00538     <span class="keywordflow">else</span> {
00539         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (<a class="code" href="../../d4/d8/mi_8h.html#a353">MI_IS_SESSION_POOL_ADDRESS</a>(VirtualAddress) == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
00540         <a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o10">PagedPoolBytes</a> += NumberOfBytes;
00541         <a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o12">PagedPoolAllocations</a> += 1;
00542     }
00543 }
00544 
00545 
00546 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00547"></a><a class="code" href="../../d1/d6/allocpag_8c.html#a51">00547</a> <a class="code" href="../../d1/d6/allocpag_8c.html#a51">MiSessionPoolFreed</a>(
00548     IN PVOID VirtualAddress,
00549     IN SIZE_T NumberOfBytes,
00550     IN POOL_TYPE PoolType
00551     )
00552 
00553 <span class="comment">/*++</span>
00554 <span class="comment"></span>
00555 <span class="comment">Routine Description:</span>
00556 <span class="comment"></span>
00557 <span class="comment">    This function returns the specified pool allocation for the current session.</span>
00558 <span class="comment">    On session exit, this charge must be zero.</span>
00559 <span class="comment"></span>
00560 <span class="comment">Arguments:</span>
00561 <span class="comment"></span>
00562 <span class="comment">    VirtualAddress - Supplies the pool address being freed.</span>
00563 <span class="comment"></span>
00564 <span class="comment">    NumberOfBytes - Supplies the number of bytes being freed.</span>
00565 <span class="comment"></span>
00566 <span class="comment">    PoolType - Supplies the type of the above pool allocation.</span>
00567 <span class="comment"></span>
00568 <span class="comment">Return Value:</span>
00569 <span class="comment"></span>
00570 <span class="comment">    None.</span>
00571 <span class="comment"></span>
00572 <span class="comment">--*/</span>
00573 
00574 {
00575     <span class="keywordflow">if</span> ((PoolType &amp; <a class="code" href="../../d4/d2/pool_8h.html#a5">BASE_POOL_TYPE_MASK</a>) == <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>) {
00576         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (<a class="code" href="../../d4/d8/mi_8h.html#a353">MI_IS_SESSION_POOL_ADDRESS</a>(VirtualAddress) == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
00577         <a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o9">NonPagedPoolBytes</a> -= NumberOfBytes;
00578         <a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o11">NonPagedPoolAllocations</a> -= 1;
00579     }
00580     <span class="keywordflow">else</span> {
00581         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (<a class="code" href="../../d4/d8/mi_8h.html#a353">MI_IS_SESSION_POOL_ADDRESS</a>(VirtualAddress) == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
00582         <a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o10">PagedPoolBytes</a> -= NumberOfBytes;
00583         <a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o12">PagedPoolAllocations</a> -= 1;
00584     }
00585 }
00586 
00587 
00588 LOGICAL
<a name="l00589"></a><a class="code" href="../../d1/d6/allocpag_8c.html#a52">00589</a> <a class="code" href="../../d1/d6/allocpag_8c.html#a52">MmResourcesAvailable</a> (
00590     IN POOL_TYPE PoolType,
00591     IN SIZE_T NumberOfBytes,
00592     IN <a class="code" href="../../d5/d8/ex_8h.html#a97">EX_POOL_PRIORITY</a> Priority
00593     )
00594 
00595 <span class="comment">/*++</span>
00596 <span class="comment"></span>
00597 <span class="comment">Routine Description:</span>
00598 <span class="comment"></span>
00599 <span class="comment">    This function examines various resources to determine if this</span>
00600 <span class="comment">    pool allocation should be allowed to proceed.</span>
00601 <span class="comment"></span>
00602 <span class="comment">Arguments:</span>
00603 <span class="comment"></span>
00604 <span class="comment">    PoolType - Supplies the type of pool to retrieve information about.</span>
00605 <span class="comment"></span>
00606 <span class="comment">    NumberOfBytes - Supplies the number of bytes to allocate.</span>
00607 <span class="comment"></span>
00608 <span class="comment">    Priority - Supplies an indication as to how important it is that this</span>
00609 <span class="comment">               request succeed under low available resource conditions.                       </span>
00610 <span class="comment">Return Value:</span>
00611 <span class="comment"></span>
00612 <span class="comment">    TRUE if the pool allocation should be allowed to proceed, FALSE if not.</span>
00613 <span class="comment"></span>
00614 <span class="comment">--*/</span>
00615 
00616 {
00617     KIRQL OldIrql;
00618     PFN_NUMBER NumberOfPages;
00619     SIZE_T FreePoolInBytes;
00620     <a class="code" href="../../d5/d6/struct__ETHREAD.html">PETHREAD</a> Thread;
00621     LOGICAL SignalDereferenceThread;
00622 
00623     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Priority != <a class="code" href="../../d5/d8/ex_8h.html#a330a194">HighPoolPriority</a>);
00624     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ((PoolType &amp; <a class="code" href="../../d4/d2/pool_8h.html#a6">MUST_SUCCEED_POOL_TYPE_MASK</a>) == 0);
00625 
00626     NumberOfPages = <a class="code" href="../../d2/d1/mm_8h.html#a5">BYTES_TO_PAGES</a> (NumberOfBytes);
00627 
00628     <span class="keywordflow">if</span> ((PoolType &amp; <a class="code" href="../../d4/d2/pool_8h.html#a5">BASE_POOL_TYPE_MASK</a>) == <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>) {
00629         FreePoolInBytes = <a class="code" href="../../d8/d5/kddata_8c.html#a21">MmMaximumNonPagedPoolInBytes</a> - (<a class="code" href="../../d9/d5/4_2kddata_8c.html#a52">MmAllocatedNonPagedPool</a> &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
00630     }
00631     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (PoolType &amp; <a class="code" href="../../d4/d2/pool_8h.html#a8">SESSION_POOL_MASK</a>) {
00632         FreePoolInBytes = <a class="code" href="../../d4/d8/mi_8h.html#a337">MI_SESSION_POOL_SIZE</a> - <a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o10">PagedPoolBytes</a>;
00633     }
00634     <span class="keywordflow">else</span> {
00635         FreePoolInBytes = <a class="code" href="../../d8/d0/cmdat3_8c.html#a18">MmSizeOfPagedPoolInBytes</a> - (<a class="code" href="../../d8/d5/kddata_8c.html#a27">MmPagedPoolInfo</a>.AllocatedPagedPool &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
00636     }
00637 
00638     <span class="comment">//</span>
00639     <span class="comment">// Check available VA space.</span>
00640     <span class="comment">//</span>
00641 
00642     <span class="keywordflow">if</span> (Priority == <a class="code" href="../../d5/d8/ex_8h.html#a330a191">NormalPoolPriority</a>) {
00643         <span class="keywordflow">if</span> ((SIZE_T)NumberOfBytes + 512*1024 &gt; FreePoolInBytes) {
00644             Thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a> ();
00645             <span class="keywordflow">if</span> (!<a class="code" href="../../d1/d6/allocpag_8c.html#a1">MI_MEMORY_MAKER</a>(Thread)) {
00646                 <span class="keywordflow">goto</span> nopool;
00647             }
00648         }
00649     }
00650     <span class="keywordflow">else</span> {
00651         <span class="keywordflow">if</span> ((SIZE_T)NumberOfBytes + 2*1024*1024 &gt; FreePoolInBytes) {
00652             Thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a> ();
00653             <span class="keywordflow">if</span> (!<a class="code" href="../../d1/d6/allocpag_8c.html#a1">MI_MEMORY_MAKER</a>(Thread)) {
00654                 <span class="keywordflow">goto</span> nopool;
00655             }
00656         }
00657     }
00658 
00659     <span class="comment">//</span>
00660     <span class="comment">// Paged allocations (session and normal) can also fail for lack of commit.</span>
00661     <span class="comment">//</span>
00662 
00663     <span class="keywordflow">if</span> ((PoolType &amp; <a class="code" href="../../d4/d2/pool_8h.html#a5">BASE_POOL_TYPE_MASK</a>) == <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>) {
00664         <span class="keywordflow">if</span> (<a class="code" href="../../d6/d8/sysinfo_8c.html#a3">MmTotalCommittedPages</a> + NumberOfPages &gt; <a class="code" href="../../d9/d5/4_2kddata_8c.html#a54">MmTotalCommitLimitMaximum</a>) {
00665             Thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a> ();
00666             <span class="keywordflow">if</span> (!<a class="code" href="../../d1/d6/allocpag_8c.html#a1">MI_MEMORY_MAKER</a>(Thread)) {
00667                 <a class="code" href="../../d6/d3/modwrite_8c.html#a59">MiIssuePageExtendRequestNoWait</a> (NumberOfPages);
00668                 <span class="keywordflow">goto</span> nopool;
00669             }
00670         }
00671     }
00672 
00673     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00674 
00675 nopool:
00676 
00677     <span class="comment">//</span>
00678     <span class="comment">// Running low on pool - if this request is not for session pool,</span>
00679     <span class="comment">// force unused segment trimming when appropriate.</span>
00680     <span class="comment">//</span>
00681 
00682     <span class="keywordflow">if</span> ((PoolType &amp; <a class="code" href="../../d4/d2/pool_8h.html#a8">SESSION_POOL_MASK</a>) == 0) {
00683 
00684         <span class="keywordflow">if</span> (<a class="code" href="../../d4/d8/mi_8h.html#a328">MI_UNUSED_SEGMENTS_SURPLUS</a>()) {
00685             <a class="code" href="../../d2/d8/eventobj_8c.html#a8">KeSetEvent</a> (&amp;<a class="code" href="../../d4/d8/mi_8h.html#a699">MmUnusedSegmentCleanup</a>, 0, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
00686         }
00687         <span class="keywordflow">else</span> {
00688             SignalDereferenceThread = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00689             <a class="code" href="../../d4/d8/mi_8h.html#a130">LOCK_PFN2</a> (OldIrql);
00690             <span class="keywordflow">if</span> (<a class="code" href="../../d1/d6/allocpag_8c.html#a11">MmUnusedSegmentForceFree</a> == 0) {
00691                 <span class="keywordflow">if</span> (!IsListEmpty(&amp;<a class="code" href="../../d4/d8/mi_8h.html#a698">MmUnusedSegmentList</a>)) {
00692                     SignalDereferenceThread = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00693                     <a class="code" href="../../d1/d6/allocpag_8c.html#a11">MmUnusedSegmentForceFree</a> = 30;
00694                 }
00695             }
00696             <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrql);
00697             <span class="keywordflow">if</span> (SignalDereferenceThread == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
00698                 <a class="code" href="../../d2/d8/eventobj_8c.html#a8">KeSetEvent</a> (&amp;<a class="code" href="../../d4/d8/mi_8h.html#a699">MmUnusedSegmentCleanup</a>, 0, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
00699             }
00700         }
00701     }
00702 
00703     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00704 }
00705 
00706 
00707 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00708"></a><a class="code" href="../../d1/d6/allocpag_8c.html#a53">00708</a> <a class="code" href="../../d1/d6/allocpag_8c.html#a53">MiFreeNonPagedPool</a> (
00709     IN PVOID StartingAddress,
00710     IN PFN_NUMBER NumberOfPages
00711     )
00712 
00713 <span class="comment">/*++</span>
00714 <span class="comment"></span>
00715 <span class="comment">Routine Description:</span>
00716 <span class="comment"></span>
00717 <span class="comment">    This function releases virtually mapped nonpaged expansion pool.</span>
00718 <span class="comment"></span>
00719 <span class="comment">Arguments:</span>
00720 <span class="comment"></span>
00721 <span class="comment">    StartingAddress - Supplies the starting address.</span>
00722 <span class="comment"></span>
00723 <span class="comment">    NumberOfPages - Supplies the number of pages to free.</span>
00724 <span class="comment"></span>
00725 <span class="comment">Return Value:</span>
00726 <span class="comment"></span>
00727 <span class="comment">    None.</span>
00728 <span class="comment"></span>
00729 <span class="comment">Environment:</span>
00730 <span class="comment"></span>
00731 <span class="comment">    These functions are used by the internal Mm page allocation/free routines</span>
00732 <span class="comment">    only and should not be called directly.</span>
00733 <span class="comment"></span>
00734 <span class="comment">    Mutexes guarding the pool databases must be held when calling</span>
00735 <span class="comment">    this function.</span>
00736 <span class="comment"></span>
00737 <span class="comment">--*/</span>
00738 
00739 {
00740     PFN_NUMBER i;
00741     KIRQL OldIrql;
00742     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn1;
00743     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
00744     PFN_NUMBER PageFrameIndex;
00745 
00746     <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a173">MI_MAKING_MULTIPLE_PTES_INVALID</a> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
00747 
00748     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (StartingAddress);
00749 
00750     <span class="comment">//</span>
00751     <span class="comment">// Return commitment.</span>
00752     <span class="comment">//</span>
00753 
00754     <a class="code" href="../../d6/d1/mmquota_8c.html#a19">MiReturnCommitment</a> (NumberOfPages);
00755 
00756     <a class="code" href="../../d4/d8/mi_8h.html#a254">MM_TRACK_COMMIT</a> (<a class="code" href="../../d4/d8/mi_8h.html#a286">MM_DBG_COMMIT_RETURN_NONPAGED_POOL_EXPANSION</a>,
00757                      NumberOfPages);
00758 
00759     <a class="code" href="../../d4/d8/mi_8h.html#a130">LOCK_PFN2</a> (OldIrql);
00760 
00761     <span class="keywordflow">for</span> (i = 0; i &lt; NumberOfPages; i += 1) {
00762 
00763         PageFrameIndex = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a182">MI_GET_PAGE_FRAME_FROM_PTE</a> (PointerPte);
00764 
00765         <span class="comment">//</span>
00766         <span class="comment">// Set the pointer to the PTE as empty so the page</span>
00767         <span class="comment">// is deleted when the reference count goes to zero.</span>
00768         <span class="comment">//</span>
00769 
00770         Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PageFrameIndex);
00771         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount == 1);
00772         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount = 0;
00773         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a120">MI_SET_PFN_DELETED</a> (Pfn1);
00774 <span class="preprocessor">#if DBG</span>
00775 <span class="preprocessor"></span>        Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PageLocation = <a class="code" href="../../d2/d1/mm_8h.html#a345a173">StandbyPageList</a>;
00776 <span class="preprocessor">#endif //DBG</span>
00777 <span class="preprocessor"></span>        <a class="code" href="../../d6/d5/pfndec_8c.html#a2">MiDecrementReferenceCount</a> (PageFrameIndex);
00778 
00779         (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>)<a class="code" href="../../d0/d6/ppc_2flushtb_8c.html#a2">KeFlushSingleTb</a> (StartingAddress,
00780                                <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
00781                                <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
00782                                (PHARDWARE_PTE)PointerPte,
00783                                <a class="code" href="../../d4/d2/datalpha_8c.html#a1">ZeroKernelPte</a>.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Flush);
00784 
00785         StartingAddress = (PVOID)((PCHAR)StartingAddress + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
00786         PointerPte += 1;
00787     }
00788 
00789     <span class="comment">//</span>
00790     <span class="comment">// Update the count of available resident pages.</span>
00791     <span class="comment">//</span>
00792 
00793     <a class="code" href="../../d8/d5/kddata_8c.html#a42">MmResidentAvailablePages</a> += NumberOfPages;
00794     <a class="code" href="../../d4/d8/mi_8h.html#a322">MM_BUMP_COUNTER</a>(2, NumberOfPages);
00795 
00796     <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a>(OldIrql);
00797 
00798     PointerPte -= NumberOfPages;
00799 
00800     <a class="code" href="../../d0/d9/sysptes_8c.html#a26">MiReleaseSystemPtes</a> (PointerPte,
00801                          (ULONG)NumberOfPages,
00802                          <a class="code" href="../../d4/d8/mi_8h.html#a1003a770">NonPagedPoolExpansion</a>);
00803 }
00804 
00805 
00806 PVOID
<a name="l00807"></a><a class="code" href="../../d1/d6/allocpag_8c.html#a54">00807</a> <a class="code" href="../../d1/d6/allocpag_8c.html#a54">MiAllocatePoolPages</a> (
00808     IN POOL_TYPE PoolType,
00809     IN SIZE_T SizeInBytes,
00810     IN ULONG IsLargeSessionAllocation
00811     )
00812 
00813 <span class="comment">/*++</span>
00814 <span class="comment"></span>
00815 <span class="comment">Routine Description:</span>
00816 <span class="comment"></span>
00817 <span class="comment">    This function allocates a set of pages from the specified pool</span>
00818 <span class="comment">-   and returns the starting virtual address to the caller.</span>
00819 <span class="comment"></span>
00820 <span class="comment">    For the NonPagedPoolMustSucceed case, the caller must first</span>
00821 <span class="comment">    attempt to get NonPagedPool and if and ONLY IF that fails, then</span>
00822 <span class="comment">    MiAllocatePoolPages should be called again with the PoolType of</span>
00823 <span class="comment">    NonPagedPoolMustSucceed.</span>
00824 <span class="comment"></span>
00825 <span class="comment">Arguments:</span>
00826 <span class="comment"></span>
00827 <span class="comment">    PoolType - Supplies the type of pool from which to obtain pages.</span>
00828 <span class="comment"></span>
00829 <span class="comment">    SizeInBytes - Supplies the size of the request in bytes.  The actual</span>
00830 <span class="comment">                  size returned is rounded up to a page boundary.</span>
00831 <span class="comment"></span>
00832 <span class="comment">    IsLargeSessionAllocation - Supplies nonzero if the allocation is a single</span>
00833 <span class="comment">                               large session allocation.  Zero otherwise.</span>
00834 <span class="comment"></span>
00835 <span class="comment">Return Value:</span>
00836 <span class="comment"></span>
00837 <span class="comment">    Returns a pointer to the allocated pool, or NULL if no more pool is</span>
00838 <span class="comment">    available.</span>
00839 <span class="comment"></span>
00840 <span class="comment">Environment:</span>
00841 <span class="comment"></span>
00842 <span class="comment">    These functions are used by the general pool allocation routines</span>
00843 <span class="comment">    and should not be called directly.</span>
00844 <span class="comment"></span>
00845 <span class="comment">    Mutexes guarding the pool databases must be held when calling</span>
00846 <span class="comment">    these functions.</span>
00847 <span class="comment"></span>
00848 <span class="comment">    Kernel mode, IRQL at DISPATCH_LEVEL.</span>
00849 <span class="comment"></span>
00850 <span class="comment">--*/</span>
00851 
00852 {
00853     PFN_NUMBER SizeInPages;
00854     ULONG StartPosition;
00855     ULONG EndPosition;
00856     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> StartingPte;
00857     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
00858     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn1;
00859     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> TempPte;
00860     PFN_NUMBER PageFrameIndex;
00861     PVOID BaseVa;
00862     KIRQL OldIrql;
00863     KIRQL SessionIrql;
00864     PFN_NUMBER i;
00865     PLIST_ENTRY Entry;
00866     <a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html">PMMFREE_POOL_ENTRY</a> FreePageInfo;
00867     <a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html">PMM_SESSION_SPACE</a> SessionSpace;
00868     <a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html">PMM_PAGED_POOL_INFO</a> PagedPoolInfo;
00869     PVOID VirtualAddress;
00870     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
00871     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> SessionPte;
00872     ULONG WsEntry;
00873     ULONG WsSwapEntry;
00874     ULONG PageTableCount;
00875     LOGICAL FreedPool;
00876     LOGICAL SignalDereferenceThread;
00877     <a class="code" href="../../d5/d6/struct__ETHREAD.html">PETHREAD</a> Thread;
00878 
00879     SizeInPages = <a class="code" href="../../d2/d1/mm_8h.html#a5">BYTES_TO_PAGES</a> (SizeInBytes);
00880 
00881 <span class="preprocessor">#if DBG</span>
00882 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (MmCheckRequestInPages != 0) {
00883         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (SizeInPages &lt; MmCheckRequestInPages);
00884     }
00885 <span class="preprocessor">#endif</span>
00886 <span class="preprocessor"></span>
00887     <span class="keywordflow">if</span> (PoolType &amp; <a class="code" href="../../d4/d2/pool_8h.html#a6">MUST_SUCCEED_POOL_TYPE_MASK</a>) {
00888 
00889         <span class="comment">//</span>
00890         <span class="comment">// Pool expansion failed, see if any Must Succeed</span>
00891         <span class="comment">// pool is still left.</span>
00892         <span class="comment">//</span>
00893 
00894         <span class="keywordflow">if</span> (<a class="code" href="../../d4/d8/mi_8h.html#a649">MmNonPagedMustSucceed</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00895 
00896             <span class="comment">//</span>
00897             <span class="comment">// No more pool exists.  Bug Check.</span>
00898             <span class="comment">//</span>
00899 
00900             <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a> (MUST_SUCCEED_POOL_EMPTY,
00901                           SizeInBytes,
00902                           <a class="code" href="../../d2/d2/ex_2pool_8c.html#a52">NonPagedPoolDescriptor</a>.<a class="code" href="../../d4/d8/struct__POOL__DESCRIPTOR.html#o1">TotalPages</a>,
00903                           <a class="code" href="../../d2/d2/ex_2pool_8c.html#a52">NonPagedPoolDescriptor</a>.<a class="code" href="../../d4/d8/struct__POOL__DESCRIPTOR.html#o8">TotalBigPages</a>,
00904                           <a class="code" href="../../d5/d5/cc_8h.html#a94">MmAvailablePages</a>);
00905         }
00906 
00907         <span class="comment">//</span>
00908         <span class="comment">// Remove a page from the must succeed pool.  More than one is illegal.</span>
00909         <span class="comment">//</span>
00910 
00911         <span class="keywordflow">if</span> (SizeInBytes &gt; <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>) {
00912             <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a> (BAD_POOL_CALLER,
00913                           0x98,
00914                           (ULONG_PTR)SizeInBytes,
00915                           (ULONG_PTR)SizeInPages,
00916                           PoolType);
00917         }
00918 
00919         BaseVa = <a class="code" href="../../d4/d8/mi_8h.html#a649">MmNonPagedMustSucceed</a>;
00920 
00921         <span class="keywordflow">if</span> (IsLargeSessionAllocation != 0) {
00922 
00923             <span class="comment">//</span>
00924             <span class="comment">// Mark this as a large session allocation in the PFN database.</span>
00925             <span class="comment">//</span>
00926 
00927             <span class="keywordflow">if</span> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a178">MI_IS_PHYSICAL_ADDRESS</a>(BaseVa)) {
00928                 PageFrameIndex = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a179">MI_CONVERT_PHYSICAL_TO_PFN</a> (BaseVa);
00929             } <span class="keywordflow">else</span> {
00930                 PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>(BaseVa);
00931                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1);
00932                 PageFrameIndex = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a182">MI_GET_PAGE_FRAME_FROM_PTE</a> (PointerPte);
00933             }
00934             Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PageFrameIndex);
00935 
00936             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.LargeSessionAllocation == 0);
00937 
00938             <a class="code" href="../../d4/d8/mi_8h.html#a123">CONSISTENCY_LOCK_PFN2</a> (OldIrql);
00939 
00940             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.LargeSessionAllocation = 1;
00941 
00942             <a class="code" href="../../d4/d8/mi_8h.html#a124">CONSISTENCY_UNLOCK_PFN2</a> (OldIrql);
00943 
00944             <a class="code" href="../../d1/d6/allocpag_8c.html#a50">MiSessionPoolAllocated</a> (BaseVa, <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>, <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>);
00945         }
00946         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (PoolType &amp; <a class="code" href="../../d4/d2/pool_8h.html#a9">POOL_VERIFIER_MASK</a>) {
00947 
00948             <span class="keywordflow">if</span> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a178">MI_IS_PHYSICAL_ADDRESS</a>(BaseVa)) {
00949                 PageFrameIndex = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a179">MI_CONVERT_PHYSICAL_TO_PFN</a> (BaseVa);
00950             } <span class="keywordflow">else</span> {
00951                 PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>(BaseVa);
00952                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1);
00953                 PageFrameIndex = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a182">MI_GET_PAGE_FRAME_FROM_PTE</a> (PointerPte);
00954             }
00955 
00956             Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PageFrameIndex);
00957 
00958             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.VerifierAllocation == 0);
00959             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.VerifierAllocation = 1;
00960         }
00961 
00962         <a class="code" href="../../d4/d8/mi_8h.html#a649">MmNonPagedMustSucceed</a> = (PVOID)(*(PULONG_PTR)BaseVa);
00963         <span class="keywordflow">return</span> BaseVa;
00964     }
00965 
00966     <span class="keywordflow">if</span> ((PoolType &amp; <a class="code" href="../../d4/d2/pool_8h.html#a5">BASE_POOL_TYPE_MASK</a>) == <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>) {
00967 
00968         <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = (ULONG)(SizeInPages - 1);
00969 
00970         <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &gt;= <a class="code" href="../../d4/d8/mi_8h.html#a324">MI_MAX_FREE_LIST_HEADS</a>) {
00971             <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = <a class="code" href="../../d4/d8/mi_8h.html#a324">MI_MAX_FREE_LIST_HEADS</a> - 1;
00972         }
00973 
00974         <span class="comment">//</span>
00975         <span class="comment">// NonPaged pool is linked together through the pages themselves.</span>
00976         <span class="comment">//</span>
00977 
00978         <span class="keywordflow">while</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &lt; <a class="code" href="../../d4/d8/mi_8h.html#a324">MI_MAX_FREE_LIST_HEADS</a>) {
00979 
00980             Entry = <a class="code" href="../../d1/d6/allocpag_8c.html#a8">MmNonPagedPoolFreeListHead</a>[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].Flink;
00981 
00982             <span class="keywordflow">while</span> (Entry != &amp;<a class="code" href="../../d1/d6/allocpag_8c.html#a8">MmNonPagedPoolFreeListHead</a>[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>]) {
00983 
00984                 <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a36">MmProtectFreedNonPagedPool</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
00985                     <a class="code" href="../../d5/d6/iosup_8c.html#a38">MiUnProtectFreeNonPagedPool</a> ((PVOID)Entry, 0);
00986                 }
00987     
00988                 <span class="comment">//</span>
00989                 <span class="comment">// The list is not empty, see if this one has enough space.</span>
00990                 <span class="comment">//</span>
00991     
00992                 FreePageInfo = CONTAINING_RECORD(Entry,
00993                                                  <a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html">MMFREE_POOL_ENTRY</a>,
00994                                                  <a class="code" href="../../d1/d0/cmchek_8c.html#a12">List</a>);
00995     
00996                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (FreePageInfo-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o2">Signature</a> == <a class="code" href="../../d4/d8/mi_8h.html#a11">MM_FREE_POOL_SIGNATURE</a>);
00997                 <span class="keywordflow">if</span> (FreePageInfo-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o1">Size</a> &gt;= SizeInPages) {
00998     
00999                     <span class="comment">//</span>
01000                     <span class="comment">// This entry has sufficient space, remove</span>
01001                     <span class="comment">// the pages from the end of the allocation.</span>
01002                     <span class="comment">//</span>
01003     
01004                     FreePageInfo-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o1">Size</a> -= SizeInPages;
01005     
01006                     BaseVa = (PVOID)((PCHAR)FreePageInfo +
01007                                             (FreePageInfo-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o1">Size</a>  &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>));
01008     
01009                     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a36">MmProtectFreedNonPagedPool</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01010                         RemoveEntryList (&amp;FreePageInfo-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o0">List</a>);
01011                     }
01012                     <span class="keywordflow">else</span> {
01013                         <a class="code" href="../../d1/d6/allocpag_8c.html#a47">MiProtectedPoolRemoveEntryList</a> (&amp;FreePageInfo-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o0">List</a>);
01014                     }
01015 
01016                     <span class="keywordflow">if</span> (FreePageInfo-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o1">Size</a> != 0) {
01017     
01018                         <span class="comment">//</span>
01019                         <span class="comment">// Insert any remainder into the correct list.</span>
01020                         <span class="comment">//</span>
01021     
01022                         <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = (ULONG)(FreePageInfo-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o1">Size</a> - 1);
01023                         <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &gt;= <a class="code" href="../../d4/d8/mi_8h.html#a324">MI_MAX_FREE_LIST_HEADS</a>) {
01024                             <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = <a class="code" href="../../d4/d8/mi_8h.html#a324">MI_MAX_FREE_LIST_HEADS</a> - 1;
01025                         }
01026 
01027                         <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a36">MmProtectFreedNonPagedPool</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01028                             InsertTailList (&amp;<a class="code" href="../../d1/d6/allocpag_8c.html#a8">MmNonPagedPoolFreeListHead</a>[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>],
01029                                             &amp;FreePageInfo-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o0">List</a>);
01030                         }
01031                         <span class="keywordflow">else</span> {
01032                             <a class="code" href="../../d1/d6/allocpag_8c.html#a46">MiProtectedPoolInsertList</a> (&amp;<a class="code" href="../../d1/d6/allocpag_8c.html#a8">MmNonPagedPoolFreeListHead</a>[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>],
01033                                                        &amp;FreePageInfo-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o0">List</a>,
01034                                                        <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
01035 
01036                             <a class="code" href="../../d5/d6/iosup_8c.html#a37">MiProtectFreeNonPagedPool</a> ((PVOID)FreePageInfo,
01037                                                        (ULONG)FreePageInfo-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o1">Size</a>);
01038                         }
01039                     }
01040     
01041                     <span class="comment">//</span>
01042                     <span class="comment">// Adjust the number of free pages remaining in the pool.</span>
01043                     <span class="comment">//</span>
01044     
01045                     <a class="code" href="../../d4/d8/mi_8h.html#a630">MmNumberOfFreeNonPagedPool</a> -= SizeInPages;
01046                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ((LONG)<a class="code" href="../../d4/d8/mi_8h.html#a630">MmNumberOfFreeNonPagedPool</a> &gt;= 0);
01047     
01048                     <span class="comment">//</span>
01049                     <span class="comment">// Mark start and end of allocation in the PFN database.</span>
01050                     <span class="comment">//</span>
01051     
01052                     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a178">MI_IS_PHYSICAL_ADDRESS</a>(BaseVa)) {
01053     
01054                         <span class="comment">//</span>
01055                         <span class="comment">// On certain architectures, virtual addresses</span>
01056                         <span class="comment">// may be physical and hence have no corresponding PTE.</span>
01057                         <span class="comment">//</span>
01058     
01059                         PageFrameIndex = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a179">MI_CONVERT_PHYSICAL_TO_PFN</a> (BaseVa);
01060                     } <span class="keywordflow">else</span> {
01061                         PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>(BaseVa);
01062                         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1);
01063                         PageFrameIndex = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a182">MI_GET_PAGE_FRAME_FROM_PTE</a> (PointerPte);
01064                     }
01065                     Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PageFrameIndex);
01066     
01067                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.StartOfAllocation == 0);
01068                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.VerifierAllocation == 0);
01069     
01070                     <a class="code" href="../../d4/d8/mi_8h.html#a123">CONSISTENCY_LOCK_PFN2</a> (OldIrql);
01071     
01072                     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.StartOfAllocation = 1;
01073     
01074                     <span class="keywordflow">if</span> (PoolType &amp; <a class="code" href="../../d4/d2/pool_8h.html#a9">POOL_VERIFIER_MASK</a>) {
01075                         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.VerifierAllocation = 1;
01076                     }
01077 
01078                     <a class="code" href="../../d4/d8/mi_8h.html#a124">CONSISTENCY_UNLOCK_PFN2</a> (OldIrql);
01079     
01080                     <span class="comment">//</span>
01081                     <span class="comment">// Mark this as a large session allocation in the PFN database.</span>
01082                     <span class="comment">//</span>
01083     
01084                     <span class="keywordflow">if</span> (IsLargeSessionAllocation != 0) {
01085                         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.LargeSessionAllocation == 0);
01086     
01087                         <a class="code" href="../../d4/d8/mi_8h.html#a123">CONSISTENCY_LOCK_PFN2</a> (OldIrql);
01088     
01089                         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.LargeSessionAllocation = 1;
01090     
01091                         <a class="code" href="../../d4/d8/mi_8h.html#a124">CONSISTENCY_UNLOCK_PFN2</a> (OldIrql);
01092     
01093                         <a class="code" href="../../d1/d6/allocpag_8c.html#a50">MiSessionPoolAllocated</a> (BaseVa,
01094                                                 SizeInPages &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>,
01095                                                 <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>);
01096                     }
01097     
01098                     <span class="comment">//</span>
01099                     <span class="comment">// Calculate the ending PTE's address.</span>
01100                     <span class="comment">//</span>
01101     
01102                     <span class="keywordflow">if</span> (SizeInPages != 1) {
01103                         <span class="keywordflow">if</span> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a178">MI_IS_PHYSICAL_ADDRESS</a>(BaseVa)) {
01104                             Pfn1 += SizeInPages - 1;
01105                         } <span class="keywordflow">else</span> {
01106                             PointerPte += SizeInPages - 1;
01107                             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1);
01108                             Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber);
01109                         }
01110                     }
01111                     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a36">MmProtectFreedNonPagedPool</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01112     
01113                        <span class="comment">//</span>
01114                        <span class="comment">// Map this with KSEG0 if possible.</span>
01115                        <span class="comment">//</span>
01116 <span class="preprocessor">#if defined (_X86_)</span>
01117 <span class="preprocessor"></span>                       <span class="keywordflow">if</span>  ((BaseVa &gt; (PVOID)<a class="code" href="../../d6/d8/mi386_8h.html#a11">MM_KSEG2_BASE</a>) &amp;&amp;
01118                             (PageFrameIndex &gt;= <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a179">MI_CONVERT_PHYSICAL_TO_PFN</a>(<a class="code" href="../../d8/d5/kddata_8c.html#a16">MmSubsectionBase</a>)) &amp;&amp;
01119                             (PageFrameIndex &lt; <a class="code" href="../../d4/d8/mi_8h.html#a580">MmSubsectionTopPage</a>) &amp;&amp;
01120                             (<a class="code" href="../../d2/d2/data386_8c.html#a19">MmKseg2Frame</a> != 0))
01121 <span class="preprocessor">#elif defined (_ALPHA_)</span>
01122 <span class="preprocessor"></span>                       <span class="keywordflow">if</span>  ((BaseVa &gt; (PVOID)<a class="code" href="../../d6/d7/halmips_8h.html#a445">KSEG2_BASE</a>) &amp;&amp;
01123                             (PageFrameIndex &gt;= <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a179">MI_CONVERT_PHYSICAL_TO_PFN</a>(<a class="code" href="../../d8/d5/kddata_8c.html#a16">MmSubsectionBase</a>)) &amp;&amp;
01124                             (PageFrameIndex &lt; <a class="code" href="../../d4/d8/mi_8h.html#a580">MmSubsectionTopPage</a>))
01125 <span class="preprocessor">#else</span>
01126 <span class="preprocessor"></span>                       <span class="keywordflow">if</span>  ((BaseVa &gt; (PVOID)<a class="code" href="../../d6/d7/halmips_8h.html#a445">KSEG2_BASE</a>) &amp;&amp;
01127                             (PageFrameIndex &lt; <a class="code" href="../../d4/d8/mi_8h.html#a580">MmSubsectionTopPage</a>))
01128 <span class="preprocessor">#endif</span>
01129 <span class="preprocessor"></span>                       {
01130                            BaseVa = (PVOID)(<a class="code" href="../../d6/d7/halmips_8h.html#a443">KSEG0_BASE</a> + (PageFrameIndex &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>));
01131                        }
01132                     }
01133     
01134                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.EndOfAllocation == 0);
01135     
01136                     <a class="code" href="../../d4/d8/mi_8h.html#a123">CONSISTENCY_LOCK_PFN2</a> (OldIrql);
01137     
01138                     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.EndOfAllocation = 1;
01139     
01140                     <a class="code" href="../../d4/d8/mi_8h.html#a124">CONSISTENCY_UNLOCK_PFN2</a> (OldIrql);
01141     
01142                     <a class="code" href="../../d9/d5/4_2kddata_8c.html#a52">MmAllocatedNonPagedPool</a> += SizeInPages;
01143                     <span class="keywordflow">return</span> BaseVa;
01144                 }
01145     
01146                 Entry = FreePageInfo-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o0">List</a>.Flink;
01147     
01148                 <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a36">MmProtectFreedNonPagedPool</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
01149                     <a class="code" href="../../d5/d6/iosup_8c.html#a37">MiProtectFreeNonPagedPool</a> ((PVOID)FreePageInfo,
01150                                                (ULONG)FreePageInfo-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o1">Size</a>);
01151                 }
01152             }
01153             <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> += 1;
01154         }
01155 
01156         <span class="comment">//</span>
01157         <span class="comment">// No more entries on the list, expand nonpaged pool if</span>
01158         <span class="comment">// possible to satisfy this request.</span>
01159         <span class="comment">//</span>
01160 
01161         <span class="comment">//</span>
01162         <span class="comment">// Check to see if there are too many unused segments laying</span>
01163         <span class="comment">// around.  If so, set an event so they get deleted.</span>
01164         <span class="comment">//</span>
01165 
01166         <span class="keywordflow">if</span> (<a class="code" href="../../d4/d8/mi_8h.html#a328">MI_UNUSED_SEGMENTS_SURPLUS</a>()) {
01167             <a class="code" href="../../d2/d8/eventobj_8c.html#a8">KeSetEvent</a> (&amp;<a class="code" href="../../d4/d8/mi_8h.html#a699">MmUnusedSegmentCleanup</a>, 0, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
01168         }
01169 
01170         <a class="code" href="../../d4/d8/mi_8h.html#a130">LOCK_PFN2</a> (OldIrql);
01171 
01172         <span class="comment">//</span>
01173         <span class="comment">// Make sure we have 1 more than the number of pages</span>
01174         <span class="comment">// requested available.</span>
01175         <span class="comment">//</span>
01176 
01177         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a94">MmAvailablePages</a> &lt;= SizeInPages) {
01178 
01179             <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrql);
01180 
01181             <span class="comment">//</span>
01182             <span class="comment">// There are no free physical pages to expand</span>
01183             <span class="comment">// nonpaged pool.</span>
01184             <span class="comment">//</span>
01185 
01186             <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01187         }
01188 
01189         <span class="comment">//</span>
01190         <span class="comment">// Try to find system PTEs to expand the pool into.</span>
01191         <span class="comment">//</span>
01192 
01193         StartingPte = <a class="code" href="../../d0/d9/sysptes_8c.html#a25">MiReserveSystemPtes</a> ((ULONG)SizeInPages,
01194                                            <a class="code" href="../../d4/d8/mi_8h.html#a1003a770">NonPagedPoolExpansion</a>,
01195                                            0,
01196                                            0,
01197                                            <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
01198 
01199         <span class="keywordflow">if</span> (StartingPte == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01200 
01201             <span class="comment">//</span>
01202             <span class="comment">// There are no free physical PTEs to expand nonpaged pool.</span>
01203             <span class="comment">// If there are any cached expansion PTEs, free them now in</span>
01204             <span class="comment">// an attempt to get enough contiguous VA for our caller.</span>
01205             <span class="comment">//</span>
01206 
01207             <span class="keywordflow">if</span> ((SizeInPages &gt; 1) &amp;&amp; (<a class="code" href="../../d4/d8/mi_8h.html#a630">MmNumberOfFreeNonPagedPool</a> != 0)) {
01208 
01209                 FreedPool = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01210 
01211                 <span class="keywordflow">for</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = 0; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &lt; <a class="code" href="../../d4/d8/mi_8h.html#a324">MI_MAX_FREE_LIST_HEADS</a>; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> += 1) {
01212         
01213                     Entry = <a class="code" href="../../d1/d6/allocpag_8c.html#a8">MmNonPagedPoolFreeListHead</a>[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].Flink;
01214         
01215                     <span class="keywordflow">while</span> (Entry != &amp;<a class="code" href="../../d1/d6/allocpag_8c.html#a8">MmNonPagedPoolFreeListHead</a>[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>]) {
01216         
01217                         <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a36">MmProtectFreedNonPagedPool</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
01218                             <a class="code" href="../../d5/d6/iosup_8c.html#a38">MiUnProtectFreeNonPagedPool</a> ((PVOID)Entry, 0);
01219                         }
01220 
01221                         <span class="comment">//</span>
01222                         <span class="comment">// The list is not empty, see if this one is virtually</span>
01223                         <span class="comment">// mapped.</span>
01224                         <span class="comment">//</span>
01225             
01226                         FreePageInfo = CONTAINING_RECORD(Entry,
01227                                                          <a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html">MMFREE_POOL_ENTRY</a>,
01228                                                          <a class="code" href="../../d1/d0/cmchek_8c.html#a12">List</a>);
01229             
01230                         <span class="keywordflow">if</span> ((!<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a178">MI_IS_PHYSICAL_ADDRESS</a>(FreePageInfo)) &amp;&amp;
01231                             ((PVOID)FreePageInfo &gt;= <a class="code" href="../../d1/d6/allocpag_8c.html#a7">MmNonPagedPoolExpansionStart</a>)) {
01232                             <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a36">MmProtectFreedNonPagedPool</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01233                                 RemoveEntryList (&amp;FreePageInfo-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o0">List</a>);
01234                             }
01235                             <span class="keywordflow">else</span> {
01236                                 <a class="code" href="../../d1/d6/allocpag_8c.html#a47">MiProtectedPoolRemoveEntryList</a> (&amp;FreePageInfo-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o0">List</a>);
01237                             }
01238 
01239                             <a class="code" href="../../d4/d8/mi_8h.html#a630">MmNumberOfFreeNonPagedPool</a> -= FreePageInfo-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o1">Size</a>;
01240                             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ((LONG)<a class="code" href="../../d4/d8/mi_8h.html#a630">MmNumberOfFreeNonPagedPool</a> &gt;= 0);
01241     
01242                             <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrql);
01243 
01244                             FreedPool = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01245 
01246                             <a class="code" href="../../d1/d6/allocpag_8c.html#a53">MiFreeNonPagedPool</a> ((PVOID)FreePageInfo,
01247                                                 FreePageInfo-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o1">Size</a>);
01248 
01249                             <a class="code" href="../../d4/d8/mi_8h.html#a130">LOCK_PFN2</a> (OldIrql);
01250                             <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = 0;
01251                             <span class="keywordflow">break</span>;
01252                         }
01253 
01254                         Entry = FreePageInfo-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o0">List</a>.Flink;
01255         
01256                         <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a36">MmProtectFreedNonPagedPool</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
01257                             <a class="code" href="../../d5/d6/iosup_8c.html#a37">MiProtectFreeNonPagedPool</a> ((PVOID)FreePageInfo,
01258                                                        (ULONG)FreePageInfo-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o1">Size</a>);
01259                         }
01260                     }
01261                 }
01262 
01263                 <span class="keywordflow">if</span> (FreedPool == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
01264                     StartingPte = <a class="code" href="../../d0/d9/sysptes_8c.html#a25">MiReserveSystemPtes</a> ((ULONG)SizeInPages,
01265                                                        <a class="code" href="../../d4/d8/mi_8h.html#a1003a770">NonPagedPoolExpansion</a>,
01266                                                        0,
01267                                                        0,
01268                                                        <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
01269             
01270                     <span class="keywordflow">if</span> (StartingPte != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01271                         <span class="keywordflow">goto</span> gotpool;
01272                     }
01273                 }
01274             }
01275 
01276             <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrql);
01277 
01278 nopool:
01279 
01280             <span class="comment">//</span>
01281             <span class="comment">// Running low on pool - if this request is not for session pool,</span>
01282             <span class="comment">// force unused segment trimming when appropriate.</span>
01283             <span class="comment">//</span>
01284         
01285             SignalDereferenceThread = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01286             <a class="code" href="../../d4/d8/mi_8h.html#a130">LOCK_PFN2</a> (OldIrql);
01287             <span class="keywordflow">if</span> (<a class="code" href="../../d1/d6/allocpag_8c.html#a11">MmUnusedSegmentForceFree</a> == 0) {
01288                 <span class="keywordflow">if</span> (!IsListEmpty(&amp;<a class="code" href="../../d4/d8/mi_8h.html#a698">MmUnusedSegmentList</a>)) {
01289                     SignalDereferenceThread = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01290                     <a class="code" href="../../d1/d6/allocpag_8c.html#a11">MmUnusedSegmentForceFree</a> = 30;
01291                 }
01292             }
01293             <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrql);
01294             <span class="keywordflow">if</span> (SignalDereferenceThread == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
01295                 <a class="code" href="../../d2/d8/eventobj_8c.html#a8">KeSetEvent</a> (&amp;<a class="code" href="../../d4/d8/mi_8h.html#a699">MmUnusedSegmentCleanup</a>, 0, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
01296             }
01297 
01298             <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01299         }
01300 
01301 gotpool:
01302 
01303         <span class="comment">//</span>
01304         <span class="comment">// Update the count of available resident pages.</span>
01305         <span class="comment">//</span>
01306 
01307         <a class="code" href="../../d8/d5/kddata_8c.html#a42">MmResidentAvailablePages</a> -= SizeInPages;
01308         <a class="code" href="../../d4/d8/mi_8h.html#a322">MM_BUMP_COUNTER</a>(0, SizeInPages);
01309 
01310         <span class="comment">//</span>
01311         <span class="comment">// Charge commitment as non paged pool uses physical memory.</span>
01312         <span class="comment">//</span>
01313 
01314         <a class="code" href="../../d4/d8/mi_8h.html#a254">MM_TRACK_COMMIT</a> (<a class="code" href="../../d4/d8/mi_8h.html#a257">MM_DBG_COMMIT_NONPAGED_POOL_EXPANSION</a>, SizeInPages);
01315 
01316         <a class="code" href="../../d6/d1/mmquota_8c.html#a18">MiChargeCommitmentCantExpand</a> (SizeInPages, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
01317 
01318         <span class="comment">//</span>
01319         <span class="comment">//  Expand the pool.</span>
01320         <span class="comment">//</span>
01321 
01322         PointerPte = StartingPte;
01323         TempPte = <a class="code" href="../../d4/d2/datalpha_8c.html#a2">ValidKernelPte</a>;
01324         <a class="code" href="../../d9/d5/4_2kddata_8c.html#a52">MmAllocatedNonPagedPool</a> += SizeInPages;
01325         i = SizeInPages;
01326 
01327         <span class="keywordflow">do</span> {
01328             PageFrameIndex = <a class="code" href="../../d7/d5/pfnlist_8c.html#a15">MiRemoveAnyPage</a> (
01329                                 <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a124">MI_GET_PAGE_COLOR_FROM_PTE</a> (PointerPte));
01330 
01331             Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PageFrameIndex);
01332 
01333             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount = 1;
01334             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount = 1;
01335             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a> = PointerPte;
01336             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o16">OriginalPte</a>.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a95">MM_DEMAND_ZERO_WRITE_PTE</a>;
01337             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o17">PteFrame</a> = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a182">MI_GET_PAGE_FRAME_FROM_PTE</a> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>(PointerPte));
01338 
01339             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PageLocation = <a class="code" href="../../d2/d1/mm_8h.html#a345a177">ActiveAndValid</a>;
01340             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.LargeSessionAllocation = 0;
01341             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.VerifierAllocation = 0;
01342 
01343             TempPte.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber = PageFrameIndex;
01344             <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a186">MI_WRITE_VALID_PTE</a> (PointerPte, TempPte);
01345             PointerPte += 1;
01346             SizeInPages -= 1;
01347         } <span class="keywordflow">while</span> (SizeInPages &gt; 0);
01348 
01349         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.EndOfAllocation = 1;
01350 
01351         Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (StartingPte-&gt;u.Hard.PageFrameNumber);
01352         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.StartOfAllocation = 1;
01353 
01354         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.VerifierAllocation == 0);
01355 
01356         <span class="keywordflow">if</span> (PoolType &amp; <a class="code" href="../../d4/d2/pool_8h.html#a9">POOL_VERIFIER_MASK</a>) {
01357             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.VerifierAllocation = 1;
01358         }
01359 
01360         <span class="comment">//</span>
01361         <span class="comment">// Mark this as a large session allocation in the PFN database.</span>
01362         <span class="comment">//</span>
01363 
01364         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.LargeSessionAllocation == 0);
01365 
01366         <span class="keywordflow">if</span> (IsLargeSessionAllocation != 0) {
01367             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.LargeSessionAllocation = 1;
01368 
01369             <a class="code" href="../../d1/d6/allocpag_8c.html#a50">MiSessionPoolAllocated</a>(<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a> (StartingPte),
01370                                    i &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>,
01371                                    <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>);
01372         }
01373 
01374         <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrql);
01375 
01376         BaseVa = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a> (StartingPte);
01377 
01378         <span class="keywordflow">if</span> (i == 1) {
01379 
01380             <span class="comment">//</span>
01381             <span class="comment">// Map this with KSEG0 if possible.</span>
01382             <span class="comment">//</span>
01383 
01384 <span class="preprocessor">#if defined (_X86_)</span>
01385 <span class="preprocessor"></span>            <span class="keywordflow">if</span> ((PageFrameIndex &gt;= <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a179">MI_CONVERT_PHYSICAL_TO_PFN</a>(<a class="code" href="../../d8/d5/kddata_8c.html#a16">MmSubsectionBase</a>)) &amp;&amp;
01386                 (PageFrameIndex &lt; <a class="code" href="../../d4/d8/mi_8h.html#a580">MmSubsectionTopPage</a>) &amp;&amp;
01387                 (<a class="code" href="../../d2/d2/data386_8c.html#a19">MmKseg2Frame</a> != 0))
01388 <span class="preprocessor">#elif defined (_ALPHA_)</span>
01389 <span class="preprocessor"></span>            <span class="keywordflow">if</span> ((PageFrameIndex &gt;= <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a179">MI_CONVERT_PHYSICAL_TO_PFN</a>(<a class="code" href="../../d8/d5/kddata_8c.html#a16">MmSubsectionBase</a>)) &amp;&amp;
01390                 (PageFrameIndex &lt; <a class="code" href="../../d4/d8/mi_8h.html#a580">MmSubsectionTopPage</a>))
01391 <span class="preprocessor">#else</span>
01392 <span class="preprocessor"></span>            <span class="keywordflow">if</span> (PageFrameIndex &lt; <a class="code" href="../../d4/d8/mi_8h.html#a580">MmSubsectionTopPage</a>)
01393 <span class="preprocessor">#endif</span>
01394 <span class="preprocessor"></span>            {
01395                  BaseVa = (PVOID)(<a class="code" href="../../d6/d7/halmips_8h.html#a443">KSEG0_BASE</a> + (PageFrameIndex &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>));
01396             }
01397         }
01398 
01399         <span class="keywordflow">return</span> BaseVa;
01400     }
01401 
01402     <span class="comment">//</span>
01403     <span class="comment">// Paged Pool.</span>
01404     <span class="comment">//</span>
01405 
01406     <span class="keywordflow">if</span> ((PoolType &amp; <a class="code" href="../../d4/d2/pool_8h.html#a8">SESSION_POOL_MASK</a>) == 0) {
01407         SessionSpace = (<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html">PMM_SESSION_SPACE</a>)0;
01408         PagedPoolInfo = &amp;<a class="code" href="../../d8/d5/kddata_8c.html#a27">MmPagedPoolInfo</a>;
01409     }
01410     <span class="keywordflow">else</span> {
01411         SessionSpace = <a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>;
01412         PagedPoolInfo = &amp;SessionSpace-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o21">PagedPoolInfo</a>;
01413     }
01414 
01415     StartPosition = <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a31">RtlFindClearBitsAndSet</a> (
01416                                PagedPoolInfo-&gt;<a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html#o0">PagedPoolAllocationMap</a>,
01417                                (ULONG)SizeInPages,
01418                                PagedPoolInfo-&gt;<a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html#o6">PagedPoolHint</a>
01419                                );
01420 
01421     <span class="keywordflow">if</span> ((StartPosition == 0xFFFFFFFF) &amp;&amp; (PagedPoolInfo-&gt;<a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html#o6">PagedPoolHint</a> != 0)) {
01422 
01423         <span class="keywordflow">if</span> (<a class="code" href="../../d4/d8/mi_8h.html#a328">MI_UNUSED_SEGMENTS_SURPLUS</a>()) {
01424             <a class="code" href="../../d2/d8/eventobj_8c.html#a8">KeSetEvent</a> (&amp;<a class="code" href="../../d4/d8/mi_8h.html#a699">MmUnusedSegmentCleanup</a>, 0, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
01425         }
01426 
01427         <span class="comment">//</span>
01428         <span class="comment">// No free bits were found, check from the start of</span>
01429         <span class="comment">// the bit map.</span>
01430 
01431         StartPosition = <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a31">RtlFindClearBitsAndSet</a> (
01432                                    PagedPoolInfo-&gt;<a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html#o0">PagedPoolAllocationMap</a>,
01433                                    (ULONG)SizeInPages,
01434                                    0
01435                                    );
01436     }
01437 
01438     <span class="comment">//</span>
01439     <span class="comment">// If start position = -1, no room in pool.  Attempt to expand PagedPool.</span>
01440     <span class="comment">//</span>
01441 
01442     <span class="keywordflow">if</span> (StartPosition == 0xFFFFFFFF) {
01443 
01444         <span class="comment">//</span>
01445         <span class="comment">// Attempt to expand the paged pool.</span>
01446         <span class="comment">//</span>
01447 
01448         StartPosition = (((ULONG)SizeInPages - 1) / <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a103">PTE_PER_PAGE</a>) + 1;
01449 
01450         <span class="comment">//</span>
01451         <span class="comment">// Make sure there is enough space to create the prototype PTEs.</span>
01452         <span class="comment">//</span>
01453 
01454         <span class="keywordflow">if</span> (((StartPosition - 1) + PagedPoolInfo-&gt;<a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html#o5">NextPdeForPagedPoolExpansion</a>) &gt;
01455             <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (PagedPoolInfo-&gt;<a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html#o4">LastPteForPagedPool</a>)) {
01456 
01457             <span class="comment">//</span>
01458             <span class="comment">// Can't expand pool any more.  If this request is not for session</span>
01459             <span class="comment">// pool, force unused segment trimming when appropriate.</span>
01460             <span class="comment">//</span>
01461 
01462             <span class="keywordflow">if</span> (SessionSpace == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01463                 <span class="keywordflow">goto</span> nopool;
01464             }
01465 
01466             <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01467         }
01468 
01469         <span class="keywordflow">if</span> (SessionSpace) {
01470             TempPte = <a class="code" href="../../d4/d2/datalpha_8c.html#a8">ValidKernelPdeLocal</a>;
01471             PageTableCount = StartPosition;
01472         }
01473         <span class="keywordflow">else</span> {
01474             TempPte = <a class="code" href="../../d4/d2/datalpha_8c.html#a7">ValidKernelPde</a>;
01475         }
01476 
01477         <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
01478 
01479         <span class="comment">//</span>
01480         <span class="comment">// Make sure we have 1 more than the number of pages</span>
01481         <span class="comment">// requested available.</span>
01482         <span class="comment">//</span>
01483 
01484         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a94">MmAvailablePages</a> &lt;= StartPosition) {
01485 
01486             <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
01487 
01488             <span class="comment">//</span>
01489             <span class="comment">// There are no free physical pages to expand</span>
01490             <span class="comment">// paged pool.</span>
01491             <span class="comment">//</span>
01492 
01493             <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01494         }
01495 
01496         <span class="comment">//</span>
01497         <span class="comment">// Update the count of available resident pages.</span>
01498         <span class="comment">//</span>
01499 
01500         <a class="code" href="../../d8/d5/kddata_8c.html#a42">MmResidentAvailablePages</a> -= StartPosition;
01501         <a class="code" href="../../d4/d8/mi_8h.html#a322">MM_BUMP_COUNTER</a>(1, StartPosition);
01502 
01503         <span class="comment">//</span>
01504         <span class="comment">//  Expand the pool.</span>
01505         <span class="comment">//</span>
01506 
01507         EndPosition = (ULONG)((PagedPoolInfo-&gt;<a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html#o5">NextPdeForPagedPoolExpansion</a> -
01508                           <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>(PagedPoolInfo-&gt;<a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html#o3">FirstPteForPagedPool</a>)) *
01509                           <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a103">PTE_PER_PAGE</a>);
01510 
01511         <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a33">RtlClearBits</a> (PagedPoolInfo-&gt;<a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html#o0">PagedPoolAllocationMap</a>,
01512                       EndPosition,
01513                       (ULONG) StartPosition * <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a103">PTE_PER_PAGE</a>);
01514 
01515         PointerPte = PagedPoolInfo-&gt;<a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html#o5">NextPdeForPagedPoolExpansion</a>;
01516         StartingPte = (<a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a>)<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a>(PointerPte);
01517         PagedPoolInfo-&gt;<a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html#o5">NextPdeForPagedPoolExpansion</a> += StartPosition;
01518 
01519         <span class="keywordflow">do</span> {
01520             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 0);
01521 
01522             <a class="code" href="../../d4/d8/mi_8h.html#a254">MM_TRACK_COMMIT</a> (<a class="code" href="../../d4/d8/mi_8h.html#a258">MM_DBG_COMMIT_PAGED_POOL_PAGETABLE</a>, 1);
01523 
01524             <a class="code" href="../../d6/d1/mmquota_8c.html#a18">MiChargeCommitmentCantExpand</a> (1, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
01525 
01526             PageFrameIndex = <a class="code" href="../../d7/d5/pfnlist_8c.html#a15">MiRemoveAnyPage</a> (
01527                                 <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a124">MI_GET_PAGE_COLOR_FROM_PTE</a> (PointerPte));
01528 
01529             TempPte.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber = PageFrameIndex;
01530             <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a186">MI_WRITE_VALID_PTE</a> (PointerPte, TempPte);
01531 
01532             <span class="comment">//</span>
01533             <span class="comment">// Map valid PDE into system (or session) address space as well.</span>
01534             <span class="comment">//</span>
01535 
01536             VirtualAddress = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a> (PointerPte);
01537 
01538 <span class="preprocessor">#if defined (_WIN64)</span>
01539 <span class="preprocessor"></span>
01540             <a class="code" href="../../d8/d2/pagfault_8c.html#a22">MiInitializePfn</a> (PageFrameIndex,
01541                              PointerPte,
01542                              1);
01543 
01544 <span class="preprocessor">#else</span>
01545 <span class="preprocessor"></span>
01546             <span class="keywordflow">if</span> (SessionSpace) {
01547 
01548                 <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = (ULONG)(PointerPte - <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a151">MiGetPdeAddress</a> (<a class="code" href="../../d4/d8/mi_8h.html#a748">MmSessionBase</a>));
01549                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (<a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o16">PageTables</a>[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].u.Long == 0);
01550                 <a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o16">PageTables</a>[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>] = TempPte;
01551 
01552                 <a class="code" href="../../d8/d2/pagfault_8c.html#a27">MiInitializePfnForOtherProcess</a> (PageFrameIndex,
01553                                                 PointerPte,
01554                                                 <a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o5">SessionPageDirectoryIndex</a>);
01555 
01556                 <a class="code" href="../../d4/d8/mi_8h.html#a384">MM_BUMP_SESS_COUNTER</a>(<a class="code" href="../../d4/d8/mi_8h.html#a372">MM_DBG_SESSION_PAGEDPOOL_PAGETABLE_ALLOC1</a>, 1);
01557             }
01558             <span class="keywordflow">else</span> {
01559 <span class="preprocessor">#if !defined (_X86PAE_)</span>
01560 <span class="preprocessor"></span>                <a class="code" href="../../d4/d8/mi_8h.html#a636">MmSystemPagePtes</a> [((ULONG_PTR)PointerPte &amp;
01561                     ((<span class="keyword">sizeof</span>(<a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a>) * <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a102">PDE_PER_PAGE</a>) - 1)) / <span class="keyword">sizeof</span>(<a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a>)] =
01562                                      TempPte;
01563                 <a class="code" href="../../d8/d2/pagfault_8c.html#a27">MiInitializePfnForOtherProcess</a> (PageFrameIndex,
01564                                                 PointerPte,
01565                                                 <a class="code" href="../../d4/d8/mi_8h.html#a637">MmSystemPageDirectory</a>);
01566 <span class="preprocessor">#else</span>
01567 <span class="preprocessor"></span>                <a class="code" href="../../d4/d8/mi_8h.html#a636">MmSystemPagePtes</a> [((ULONG_PTR)PointerPte &amp;
01568                     (PD_PER_SYSTEM * (<span class="keyword">sizeof</span>(<a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a>) * <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a102">PDE_PER_PAGE</a>) - 1)) / <span class="keyword">sizeof</span>(<a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a>)] =
01569                                      TempPte;
01570                 <a class="code" href="../../d8/d2/pagfault_8c.html#a27">MiInitializePfnForOtherProcess</a> (PageFrameIndex,
01571                                                 PointerPte,
01572                                                 <a class="code" href="../../d4/d8/mi_8h.html#a637">MmSystemPageDirectory</a>[(PointerPte - <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a151">MiGetPdeAddress</a>(0)) / <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a102">PDE_PER_PAGE</a>]);
01573 <span class="preprocessor">#endif</span>
01574 <span class="preprocessor"></span>            }
01575 <span class="preprocessor">#endif</span>
01576 <span class="preprocessor"></span>
01577             KeFillEntryTb ((PHARDWARE_PTE) PointerPte, VirtualAddress, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
01578 
01579             <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a189">MiFillMemoryPte</a> (StartingPte,
01580                              <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>,
01581                              <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a97">MM_KERNEL_NOACCESS_PTE</a>);
01582 
01583             PointerPte += 1;
01584             StartingPte += <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> / <span class="keyword">sizeof</span>(<a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a>);
01585             StartPosition -= 1;
01586         } <span class="keywordflow">while</span> (StartPosition &gt; 0);
01587 
01588         <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
01589 
01590         <span class="keywordflow">if</span> (SessionSpace) {
01591 
01592             PointerPte -= PageTableCount;
01593 
01594             <a class="code" href="../../d4/d8/mi_8h.html#a407">LOCK_SESSION_SPACE_WS</a> (SessionIrql);
01595 
01596             <a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o13">NonPagablePages</a> += PageTableCount;
01597             <a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o14">CommittedPages</a> += PageTableCount;
01598 
01599             <span class="keywordflow">do</span> {
01600                 Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber);
01601     
01602                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o5">u1</a>.Event == 0);
01603                 Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o5">u1</a>.Event = (PVOID) <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a> ();
01604     
01605                 SessionPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a> (PointerPte);
01606     
01607                 <a class="code" href="../../d8/d2/pagfault_8c.html#a28">MiAddValidPageToWorkingSet</a> (SessionPte,
01608                                             PointerPte,
01609                                             Pfn1,
01610                                             0);
01611     
01612                 WsEntry = <a class="code" href="../../d7/d0/wstree_8c.html#a7">MiLocateWsle</a> (SessionPte,
01613                                         <a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o30">Vm</a>.<a class="code" href="../../d3/d6/struct__MMSUPPORT.html#o7">VmWorkingSetList</a>,
01614                                         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o5">u1</a>.WsIndex);
01615     
01616                 <span class="keywordflow">if</span> (WsEntry &gt;= <a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o30">Vm</a>.<a class="code" href="../../d3/d6/struct__MMSUPPORT.html#o7">VmWorkingSetList</a>-&gt;<a class="code" href="../../d0/d8/struct__MMWSL.html#o2">FirstDynamic</a>) {
01617         
01618                     WsSwapEntry = <a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o30">Vm</a>.<a class="code" href="../../d3/d6/struct__MMSUPPORT.html#o7">VmWorkingSetList</a>-&gt;<a class="code" href="../../d0/d8/struct__MMWSL.html#o2">FirstDynamic</a>;
01619         
01620                     <span class="keywordflow">if</span> (WsEntry != <a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o30">Vm</a>.<a class="code" href="../../d3/d6/struct__MMSUPPORT.html#o7">VmWorkingSetList</a>-&gt;<a class="code" href="../../d0/d8/struct__MMWSL.html#o2">FirstDynamic</a>) {
01621         
01622                         <span class="comment">//</span>
01623                         <span class="comment">// Swap this entry with the one at first dynamic.</span>
01624                         <span class="comment">//</span>
01625         
01626                         <a class="code" href="../../d7/d0/wstree_8c.html#a9">MiSwapWslEntries</a> (WsEntry, WsSwapEntry, &amp;<a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o30">Vm</a>);
01627                     }
01628         
01629                     <a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o30">Vm</a>.<a class="code" href="../../d3/d6/struct__MMSUPPORT.html#o7">VmWorkingSetList</a>-&gt;<a class="code" href="../../d0/d8/struct__MMWSL.html#o2">FirstDynamic</a> += 1;
01630                 }
01631                 <span class="keywordflow">else</span> {
01632                     WsSwapEntry = WsEntry;
01633                 }
01634         
01635                 <span class="comment">//</span>
01636                 <span class="comment">// Indicate that the page is locked.</span>
01637                 <span class="comment">//</span>
01638         
01639                 <a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o31">Wsle</a>[WsSwapEntry].<a class="code" href="../../d1/d8/struct__MMWSLE.html#o3">u1</a>.e1.LockedInWs = 1;
01640     
01641                 PointerPte += 1;
01642                 PageTableCount -= 1;
01643             } <span class="keywordflow">while</span> (PageTableCount &gt; 0);
01644             <a class="code" href="../../d4/d8/mi_8h.html#a408">UNLOCK_SESSION_SPACE_WS</a> (SessionIrql);
01645         }
01646 
01647         StartPosition = <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a31">RtlFindClearBitsAndSet</a> (
01648                                    PagedPoolInfo-&gt;<a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html#o0">PagedPoolAllocationMap</a>,
01649                                    (ULONG)SizeInPages,
01650                                    EndPosition
01651                                    );
01652 
01653         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (StartPosition != 0xffffffff);
01654     }
01655 
01656     <span class="comment">//</span>
01657     <span class="comment">// This is paged pool, the start and end can't be saved</span>
01658     <span class="comment">// in the PFN database as the page isn't always resident</span>
01659     <span class="comment">// in memory.  The ideal place to save the start and end</span>
01660     <span class="comment">// would be in the prototype PTE, but there are no free</span>
01661     <span class="comment">// bits.  To solve this problem, a bitmap which parallels</span>
01662     <span class="comment">// the allocation bitmap exists which contains set bits</span>
01663     <span class="comment">// in the positions where an allocation ends.  This</span>
01664     <span class="comment">// allows pages to be deallocated with only their starting</span>
01665     <span class="comment">// address.</span>
01666     <span class="comment">//</span>
01667     <span class="comment">// For sanity's sake, the starting address can be verified</span>
01668     <span class="comment">// from the 2 bitmaps as well.  If the page before the starting</span>
01669     <span class="comment">// address is not allocated (bit is zero in allocation bitmap)</span>
01670     <span class="comment">// then this page is obviously a start of an allocation block.</span>
01671     <span class="comment">// If the page before is allocated and the other bit map does</span>
01672     <span class="comment">// not indicate the previous page is the end of an allocation,</span>
01673     <span class="comment">// then the starting address is wrong and a bug check should</span>
01674     <span class="comment">// be issued.</span>
01675     <span class="comment">//</span>
01676 
01677     <span class="keywordflow">if</span> (SizeInPages == 1) {
01678         PagedPoolInfo-&gt;<a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html#o6">PagedPoolHint</a> = StartPosition + (ULONG)SizeInPages;
01679     }
01680 
01681     <span class="keywordflow">if</span> (<a class="code" href="../../d6/d1/mmquota_8c.html#a18">MiChargeCommitmentCantExpand</a> (SizeInPages, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01682         Thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a> ();
01683         <span class="keywordflow">if</span> (<a class="code" href="../../d1/d6/allocpag_8c.html#a1">MI_MEMORY_MAKER</a>(Thread)) {
01684             <a class="code" href="../../d6/d1/mmquota_8c.html#a18">MiChargeCommitmentCantExpand</a> (SizeInPages, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
01685         }
01686         <span class="keywordflow">else</span> {
01687             <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a33">RtlClearBits</a> (PagedPoolInfo-&gt;<a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html#o0">PagedPoolAllocationMap</a>,
01688                           StartPosition,
01689                           (ULONG)SizeInPages);
01690     
01691             <span class="comment">//</span>
01692             <span class="comment">// Could not commit the page(s), return NULL indicating</span>
01693             <span class="comment">// no pool was allocated.  Note that the lack of commit may be due</span>
01694             <span class="comment">// to unused segments and the MmSharedCommit, prototype PTEs, etc</span>
01695             <span class="comment">// associated with them.  So force a reduction now.</span>
01696             <span class="comment">//</span>
01697     
01698             <a class="code" href="../../d6/d3/modwrite_8c.html#a59">MiIssuePageExtendRequestNoWait</a> (SizeInPages);
01699 
01700             SignalDereferenceThread = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01701             <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
01702             <span class="keywordflow">if</span> (<a class="code" href="../../d1/d6/allocpag_8c.html#a11">MmUnusedSegmentForceFree</a> == 0) {
01703                 <span class="keywordflow">if</span> (!IsListEmpty(&amp;<a class="code" href="../../d4/d8/mi_8h.html#a698">MmUnusedSegmentList</a>)) {
01704                     SignalDereferenceThread = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01705                     <a class="code" href="../../d1/d6/allocpag_8c.html#a11">MmUnusedSegmentForceFree</a> = 30;
01706                 }
01707             }
01708             <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
01709             <span class="keywordflow">if</span> (SignalDereferenceThread == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
01710                 <a class="code" href="../../d2/d8/eventobj_8c.html#a8">KeSetEvent</a> (&amp;<a class="code" href="../../d4/d8/mi_8h.html#a699">MmUnusedSegmentCleanup</a>, 0, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
01711             }
01712 
01713             <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01714         }
01715     }
01716 
01717     <a class="code" href="../../d4/d8/mi_8h.html#a254">MM_TRACK_COMMIT</a> (<a class="code" href="../../d4/d8/mi_8h.html#a259">MM_DBG_COMMIT_PAGED_POOL_PAGES</a>, SizeInPages);
01718 
01719     <span class="keywordflow">if</span> (SessionSpace) {
01720         <a class="code" href="../../d4/d8/mi_8h.html#a407">LOCK_SESSION_SPACE_WS</a> (OldIrql);
01721         SessionSpace-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o14">CommittedPages</a> += SizeInPages;
01722         <a class="code" href="../../d4/d8/mi_8h.html#a384">MM_BUMP_SESS_COUNTER</a>(<a class="code" href="../../d4/d8/mi_8h.html#a377">MM_DBG_SESSION_COMMIT_PAGEDPOOL_PAGES</a>, SizeInPages);
01723         <a class="code" href="../../d4/d8/mi_8h.html#a408">UNLOCK_SESSION_SPACE_WS</a> (OldIrql);
01724         BaseVa = (PVOID)((PCHAR)SessionSpace-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o18">PagedPoolStart</a> +
01725                                 (StartPosition &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>));
01726     }
01727     <span class="keywordflow">else</span> {
01728         <a class="code" href="../../d8/d5/kddata_8c.html#a34">MmPagedPoolCommit</a> += (ULONG)SizeInPages;
01729         BaseVa = (PVOID)((PUCHAR)<a class="code" href="../../d4/d8/mi_8h.html#a653">MmPageAlignedPoolBase</a>[<a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>] +
01730                                 (StartPosition &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>));
01731     }
01732 
01733 <span class="preprocessor">#if DBG</span>
01734 <span class="preprocessor"></span>    PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (BaseVa);
01735     <span class="keywordflow">for</span> (i = 0; i &lt; SizeInPages; i += 1) {
01736         <span class="keywordflow">if</span> (*(ULONG *)PointerPte != <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a97">MM_KERNEL_NOACCESS_PTE</a>) {
01737             <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"MiAllocatePoolPages: PP not zero PTE (%x %x %x)\n"</span>,
01738                 BaseVa, PointerPte, *PointerPte);
01739             DbgBreakPoint();
01740         }
01741         PointerPte += 1;
01742     }
01743 <span class="preprocessor">#endif</span>
01744 <span class="preprocessor"></span>    PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (BaseVa);
01745     <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a189">MiFillMemoryPte</a> (PointerPte,
01746                      SizeInPages * <span class="keyword">sizeof</span>(<a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a>),
01747                      <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a96">MM_KERNEL_DEMAND_ZERO_PTE</a>);
01748 
01749     PagedPoolInfo-&gt;<a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html#o7">PagedPoolCommit</a> += SizeInPages;
01750     EndPosition = StartPosition + (ULONG)SizeInPages - 1;
01751     <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a34">RtlSetBits</a> (PagedPoolInfo-&gt;<a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html#o1">EndOfPagedPoolBitmap</a>, EndPosition, 1<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>);
01752 
01753     <span class="comment">//</span>
01754     <span class="comment">// Mark this as a large session allocation in the PFN database.</span>
01755     <span class="comment">//</span>
01756 
01757     <span class="keywordflow">if</span> (IsLargeSessionAllocation != 0) {
01758         <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a34">RtlSetBits</a> (PagedPoolInfo-&gt;<a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html#o2">PagedPoolLargeSessionAllocationMap</a>,
01759                     StartPosition,
01760                     1<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>);
01761 
01762         <a class="code" href="../../d1/d6/allocpag_8c.html#a50">MiSessionPoolAllocated</a> (BaseVa,
01763                                 SizeInPages &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>,
01764                                 <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>);
01765     }
01766     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (PoolType &amp; <a class="code" href="../../d4/d2/pool_8h.html#a9">POOL_VERIFIER_MASK</a>) {
01767         <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a34">RtlSetBits</a> (<a class="code" href="../../d4/d8/mi_8h.html#a654">VerifierLargePagedPoolMap</a>,
01768                     StartPosition,
01769                     1<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>);
01770     }
01771 
01772     PagedPoolInfo-&gt;<a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html#o8">AllocatedPagedPool</a> += SizeInPages;
01773 
01774     <span class="keywordflow">return</span> BaseVa;
01775 }
01776 
01777 ULONG
<a name="l01778"></a><a class="code" href="../../d1/d6/allocpag_8c.html#a55">01778</a> <a class="code" href="../../d1/d6/allocpag_8c.html#a55">MiFreePoolPages</a> (
01779     IN PVOID StartingAddress
01780     )
01781 
01782 <span class="comment">/*++</span>
01783 <span class="comment"></span>
01784 <span class="comment">Routine Description:</span>
01785 <span class="comment"></span>
01786 <span class="comment">    This function returns a set of pages back to the pool from</span>
01787 <span class="comment">    which they were obtained.  Once the pages have been deallocated</span>
01788 <span class="comment">    the region provided by the allocation becomes available for</span>
01789 <span class="comment">    allocation to other callers, i.e. any data in the region is now</span>
01790 <span class="comment">    trashed and cannot be referenced.</span>
01791 <span class="comment"></span>
01792 <span class="comment">Arguments:</span>
01793 <span class="comment"></span>
01794 <span class="comment">    StartingAddress - Supplies the starting address which was returned</span>
01795 <span class="comment">                      in a previous call to MiAllocatePoolPages.</span>
01796 <span class="comment"></span>
01797 <span class="comment">Return Value:</span>
01798 <span class="comment"></span>
01799 <span class="comment">    Returns the number of pages deallocated.</span>
01800 <span class="comment"></span>
01801 <span class="comment">Environment:</span>
01802 <span class="comment"></span>
01803 <span class="comment">    These functions are used by the general pool allocation routines</span>
01804 <span class="comment">    and should not be called directly.</span>
01805 <span class="comment"></span>
01806 <span class="comment">    Mutexes guarding the pool databases must be held when calling</span>
01807 <span class="comment">    these functions.</span>
01808 <span class="comment"></span>
01809 <span class="comment">--*/</span>
01810 
01811 {
01812     ULONG StartPosition;
01813     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
01814     PFN_NUMBER i;
01815     PFN_NUMBER NumberOfPages;
01816     <a class="code" href="../../d5/d8/ex_8h.html#a96">POOL_TYPE</a> PoolType;
01817     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
01818     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn1;
01819     PFN_NUMBER PageFrameIndex;
01820     KIRQL OldIrql;
01821     ULONG IsLargeSessionAllocation;
01822     ULONG IsLargeVerifierAllocation;
01823     <a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html">PMMFREE_POOL_ENTRY</a> Entry;
01824     <a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html">PMMFREE_POOL_ENTRY</a> NextEntry;
01825     <a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html">PMM_PAGED_POOL_INFO</a> PagedPoolInfo;
01826     <a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html">PMM_SESSION_SPACE</a> SessionSpace;
01827     LOGICAL SessionAllocation;
01828     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> <a class="code" href="../../d4/d2/datalpha_8c.html#a13">NoAccessPte</a>;
01829     PFN_NUMBER PagesFreed;
01830 
01831     NumberOfPages = 1;
01832 
01833     <span class="comment">//</span>
01834     <span class="comment">// Determine Pool type base on the virtual address of the block</span>
01835     <span class="comment">// to deallocate.</span>
01836     <span class="comment">//</span>
01837     <span class="comment">// This assumes NonPagedPool starts at a higher virtual address</span>
01838     <span class="comment">// then PagedPool.</span>
01839     <span class="comment">//</span>
01840 
01841     <span class="keywordflow">if</span> ((StartingAddress &gt;= <a class="code" href="../../d8/d5/kddata_8c.html#a25">MmPagedPoolStart</a>) &amp;&amp;
01842         (StartingAddress &lt;= <a class="code" href="../../d8/d5/kddata_8c.html#a26">MmPagedPoolEnd</a>)) {
01843         PoolType = <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>;
01844         SessionSpace = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01845         PagedPoolInfo = &amp;<a class="code" href="../../d8/d5/kddata_8c.html#a27">MmPagedPoolInfo</a>;
01846         StartPosition = (ULONG)(((PCHAR)StartingAddress -
01847                           (PCHAR)<a class="code" href="../../d4/d8/mi_8h.html#a653">MmPageAlignedPoolBase</a>[PoolType]) &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
01848     }
01849     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="../../d4/d8/mi_8h.html#a353">MI_IS_SESSION_POOL_ADDRESS</a> (StartingAddress) == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
01850         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (<a class="code" href="../../d4/d8/mi_8h.html#a581">MiHydra</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
01851         PoolType = <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>;
01852         SessionSpace = <a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>;
01853         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (SessionSpace);
01854         PagedPoolInfo = &amp;SessionSpace-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o21">PagedPoolInfo</a>;
01855         StartPosition = (ULONG)(((PCHAR)StartingAddress -
01856                           (PCHAR)SessionSpace-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o18">PagedPoolStart</a>) &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
01857     }
01858     <span class="keywordflow">else</span> {
01859 
01860         <span class="keywordflow">if</span> (StartingAddress &lt; MM_SYSTEM_RANGE_START) {
01861             <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a> (BAD_POOL_CALLER,
01862                           0x40,
01863                           (ULONG_PTR)StartingAddress,
01864                           (ULONG_PTR)MM_SYSTEM_RANGE_START,
01865                           0);
01866         }
01867 
01868         PoolType = <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>;
01869         SessionSpace = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01870         PagedPoolInfo = &amp;<a class="code" href="../../d8/d5/kddata_8c.html#a27">MmPagedPoolInfo</a>;
01871         StartPosition = (ULONG)(((PCHAR)StartingAddress -
01872                           (PCHAR)<a class="code" href="../../d4/d8/mi_8h.html#a653">MmPageAlignedPoolBase</a>[PoolType]) &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
01873     }
01874 
01875     <span class="comment">//</span>
01876     <span class="comment">// Check to ensure this page is really the start of an allocation.</span>
01877     <span class="comment">//</span>
01878 
01879     <span class="keywordflow">if</span> (PoolType == <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>) {
01880 
01881         <span class="keywordflow">if</span> (StartPosition &lt; <a class="code" href="../../d4/d8/mi_8h.html#a631">MmMustSucceedPoolBitPosition</a>) {
01882 
01883             PULONG_PTR NextList;
01884 
01885             <span class="comment">//</span>
01886             <span class="comment">// This is must succeed pool, don't free it, just</span>
01887             <span class="comment">// add it to the front of the list.</span>
01888             <span class="comment">//</span>
01889             <span class="comment">// Note - only a single page can be released at a time.</span>
01890             <span class="comment">//</span>
01891 
01892             <span class="keywordflow">if</span> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a178">MI_IS_PHYSICAL_ADDRESS</a>(StartingAddress)) {
01893                 PageFrameIndex = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a179">MI_CONVERT_PHYSICAL_TO_PFN</a> (StartingAddress);
01894             } <span class="keywordflow">else</span> {
01895                 PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>(StartingAddress);
01896                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1);
01897                 PageFrameIndex = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a182">MI_GET_PAGE_FRAME_FROM_PTE</a> (PointerPte);
01898             }
01899             Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PageFrameIndex);
01900     
01901             <span class="keywordflow">if</span> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.VerifierAllocation == 1) {
01902                 Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.VerifierAllocation = 0;
01903                 <a class="code" href="../../d9/d5/verifier_8c.html#a91">VerifierFreeTrackedPool</a> (StartingAddress,
01904                                          <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>,
01905                                          <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>,
01906                                          <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
01907             }
01908 
01909             <span class="comment">//</span>
01910             <span class="comment">// Check for this being a large session allocation. If it is,</span>
01911             <span class="comment">// we need to return the pool charge accordingly.</span>
01912             <span class="comment">//</span>
01913 
01914             <span class="keywordflow">if</span> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.LargeSessionAllocation) {
01915                 Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.LargeSessionAllocation = 0;
01916                 <a class="code" href="../../d1/d6/allocpag_8c.html#a51">MiSessionPoolFreed</a> (StartingAddress,
01917                                     <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>,
01918                                     <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>);
01919             }
01920 
01921             NextList = (PULONG_PTR)StartingAddress;
01922             *NextList = (ULONG_PTR)<a class="code" href="../../d4/d8/mi_8h.html#a649">MmNonPagedMustSucceed</a>;
01923             <a class="code" href="../../d4/d8/mi_8h.html#a649">MmNonPagedMustSucceed</a> = StartingAddress;
01924             <span class="keywordflow">return</span> (ULONG)NumberOfPages;
01925         }
01926 
01927         <span class="keywordflow">if</span> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a178">MI_IS_PHYSICAL_ADDRESS</a> (StartingAddress)) {
01928 
01929             <span class="comment">//</span>
01930             <span class="comment">// On certain architectures, virtual addresses</span>
01931             <span class="comment">// may be physical and hence have no corresponding PTE.</span>
01932             <span class="comment">//</span>
01933 
01934             Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a179">MI_CONVERT_PHYSICAL_TO_PFN</a> (StartingAddress));
01935             <span class="keywordflow">if</span> (StartPosition &gt;= <a class="code" href="../../d4/d8/mi_8h.html#a629">MmExpandedPoolBitPosition</a>) {
01936                 PointerPte = Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a>;
01937                 StartingAddress = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a> (PointerPte);
01938             }
01939         } <span class="keywordflow">else</span> {
01940             PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (StartingAddress);
01941             Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber);
01942         }
01943 
01944         <span class="keywordflow">if</span> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.StartOfAllocation == 0) {
01945             <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a> (BAD_POOL_CALLER,
01946                           0x41,
01947                           (ULONG_PTR)StartingAddress,
01948                           (ULONG_PTR)(Pfn1 - <a class="code" href="../../d2/d3/dumpctl_8c.html#a15">MmPfnDatabase</a>),
01949                           <a class="code" href="../../d6/d8/sysinfo_8c.html#a7">MmHighestPhysicalPage</a>);
01950         }
01951 
01952         <a class="code" href="../../d4/d8/mi_8h.html#a123">CONSISTENCY_LOCK_PFN2</a> (OldIrql);
01953 
01954         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o17">PteFrame</a> != <a class="code" href="../../d4/d8/mi_8h.html#a170">MI_MAGIC_AWE_PTEFRAME</a>);
01955 
01956         IsLargeVerifierAllocation = Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.VerifierAllocation;
01957         IsLargeSessionAllocation = Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.LargeSessionAllocation;
01958 
01959         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.StartOfAllocation = 0;
01960         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.VerifierAllocation = 0;
01961         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.LargeSessionAllocation = 0;
01962 
01963         <a class="code" href="../../d4/d8/mi_8h.html#a124">CONSISTENCY_UNLOCK_PFN2</a> (OldIrql);
01964 
01965 <span class="preprocessor">#if DBG</span>
01966 <span class="preprocessor"></span>        <span class="keywordflow">if</span> ((Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount &gt; 1) &amp;&amp;
01967             (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.WriteInProgress == 0)) {
01968             <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a> (<span class="stringliteral">"MM: MiFreePoolPages - deleting pool locked for I/O %lx\n"</span>,
01969                  Pfn1);
01970             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount == 1);
01971         }
01972 <span class="preprocessor">#endif //DBG</span>
01973 <span class="preprocessor"></span>
01974         <span class="comment">//</span>
01975         <span class="comment">// Find end of allocation and release the pages.</span>
01976         <span class="comment">//</span>
01977 
01978         <span class="keywordflow">while</span> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.EndOfAllocation == 0) {
01979             <span class="keywordflow">if</span> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a178">MI_IS_PHYSICAL_ADDRESS</a>(StartingAddress)) {
01980                 Pfn1 += 1;
01981             } <span class="keywordflow">else</span> {
01982                 PointerPte += 1;
01983                 Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber);
01984             }
01985             NumberOfPages += 1;
01986 <span class="preprocessor">#if DBG</span>
01987 <span class="preprocessor"></span>            <span class="keywordflow">if</span> ((Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount &gt; 1) &amp;&amp;
01988                 (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.WriteInProgress == 0)) {
01989                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a> (<span class="stringliteral">"MM:MiFreePoolPages - deleting pool locked for I/O %lx\n"</span>,
01990                      Pfn1);
01991                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount == 1);
01992             }
01993 <span class="preprocessor">#endif //DBG</span>
01994 <span class="preprocessor"></span>        }
01995 
01996         <a class="code" href="../../d9/d5/4_2kddata_8c.html#a52">MmAllocatedNonPagedPool</a> -= NumberOfPages;
01997 
01998         <span class="keywordflow">if</span> (IsLargeVerifierAllocation != 0) {
01999             <a class="code" href="../../d9/d5/verifier_8c.html#a91">VerifierFreeTrackedPool</a> (StartingAddress,
02000                                      NumberOfPages &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>,
02001                                      <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>,
02002                                      <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
02003         }
02004 
02005         <span class="keywordflow">if</span> (IsLargeSessionAllocation != 0) {
02006             <a class="code" href="../../d1/d6/allocpag_8c.html#a51">MiSessionPoolFreed</a> (StartingAddress,
02007                                 NumberOfPages &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>,
02008                                 <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>);
02009         }
02010 
02011         <a class="code" href="../../d4/d8/mi_8h.html#a123">CONSISTENCY_LOCK_PFN2</a> (OldIrql);
02012 
02013         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.EndOfAllocation = 0;
02014 
02015         <a class="code" href="../../d4/d8/mi_8h.html#a124">CONSISTENCY_UNLOCK_PFN2</a> (OldIrql);
02016 
02017 <span class="preprocessor">#if DBG</span>
02018 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (MiFillFreedPool != 0) {
02019             RtlFillMemoryUlong (StartingAddress,
02020                                 <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> * NumberOfPages,
02021                                 MiFillFreedPool);
02022         }
02023 <span class="preprocessor">#endif //DBG</span>
02024 <span class="preprocessor"></span>
02025         <span class="keywordflow">if</span> (StartingAddress &gt; <a class="code" href="../../d1/d6/allocpag_8c.html#a7">MmNonPagedPoolExpansionStart</a>) {
02026 
02027             <span class="comment">//</span>
02028             <span class="comment">// This page was from the expanded pool, should</span>
02029             <span class="comment">// it be freed?</span>
02030             <span class="comment">//</span>
02031             <span class="comment">// NOTE: all pages in the expanded pool area have PTEs</span>
02032             <span class="comment">// so no physical address checks need to be performed.</span>
02033             <span class="comment">//</span>
02034 
02035             <span class="keywordflow">if</span> ((NumberOfPages &gt; 3) || (<a class="code" href="../../d4/d8/mi_8h.html#a630">MmNumberOfFreeNonPagedPool</a> &gt; 5)) {
02036 
02037                 <span class="comment">//</span>
02038                 <span class="comment">// Free these pages back to the free page list.</span>
02039                 <span class="comment">//</span>
02040 
02041                 <a class="code" href="../../d1/d6/allocpag_8c.html#a53">MiFreeNonPagedPool</a> (StartingAddress, NumberOfPages);
02042 
02043                 <span class="keywordflow">return</span> (ULONG)NumberOfPages;
02044             }
02045         }
02046 
02047         <span class="comment">//</span>
02048         <span class="comment">// Add the pages to the list of free pages.</span>
02049         <span class="comment">//</span>
02050 
02051         <a class="code" href="../../d4/d8/mi_8h.html#a630">MmNumberOfFreeNonPagedPool</a> += NumberOfPages;
02052 
02053         <span class="comment">//</span>
02054         <span class="comment">// Check to see if the next allocation is free.</span>
02055         <span class="comment">// We cannot walk off the end of nonpaged initial or expansion</span>
02056         <span class="comment">// pages as the highest initial allocation is never freed and</span>
02057         <span class="comment">// the highest expansion allocation is guard-paged.</span>
02058         <span class="comment">//</span>
02059 
02060         i = NumberOfPages;
02061 
02062         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (<a class="code" href="../../d1/d6/allocpag_8c.html#a6">MiEndOfInitialPoolFrame</a> != 0);
02063 
02064         <span class="keywordflow">if</span> ((PFN_NUMBER)(Pfn1 - <a class="code" href="../../d2/d3/dumpctl_8c.html#a15">MmPfnDatabase</a>) == <a class="code" href="../../d1/d6/allocpag_8c.html#a6">MiEndOfInitialPoolFrame</a>) {
02065             PointerPte += 1;
02066             Pfn1 = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02067         }
02068         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a178">MI_IS_PHYSICAL_ADDRESS</a>(StartingAddress)) {
02069             Pfn1 += 1;
02070             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ((PCHAR)StartingAddress + NumberOfPages &lt; (PCHAR)<a class="code" href="../../d8/d5/kddata_8c.html#a23">MmNonPagedPoolStart</a> + <a class="code" href="../../d8/d0/cmdat3_8c.html#a19">MmSizeOfNonPagedPoolInBytes</a>);
02071         } <span class="keywordflow">else</span> {
02072             PointerPte += 1;
02073             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ((PCHAR)StartingAddress + NumberOfPages &lt;= (PCHAR)<a class="code" href="../../d8/d5/kddata_8c.html#a24">MmNonPagedPoolEnd</a>);
02074 
02075             <span class="comment">//</span>
02076             <span class="comment">// Unprotect the previously freed pool so it can be merged.</span>
02077             <span class="comment">//</span>
02078 
02079             <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a36">MmProtectFreedNonPagedPool</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
02080                 <a class="code" href="../../d5/d6/iosup_8c.html#a38">MiUnProtectFreeNonPagedPool</a> (
02081                     (PVOID)<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a>(PointerPte),
02082                     0);
02083             }
02084 
02085             <span class="keywordflow">if</span> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1) {
02086                 Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber);
02087             } <span class="keywordflow">else</span> {
02088                 Pfn1 = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02089             }
02090         }
02091 
02092         <span class="keywordflow">if</span> ((Pfn1 != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp; (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.StartOfAllocation == 0)) {
02093 
02094             <span class="comment">//</span>
02095             <span class="comment">// This range of pages is free.  Remove this entry</span>
02096             <span class="comment">// from the list and add these pages to the current</span>
02097             <span class="comment">// range being freed.</span>
02098             <span class="comment">//</span>
02099 
02100             Entry = (<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html">PMMFREE_POOL_ENTRY</a>)((PCHAR)StartingAddress
02101                                         + (NumberOfPages &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>));
02102             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Entry-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o2">Signature</a> == <a class="code" href="../../d4/d8/mi_8h.html#a11">MM_FREE_POOL_SIGNATURE</a>);
02103             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Entry-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o3">Owner</a> == Entry);
02104 <span class="preprocessor">#if DBG</span>
02105 <span class="preprocessor"></span>            {
02106                 <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> DebugPte;
02107                 <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> DebugPfn;
02108 
02109                 DebugPfn = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02110 
02111                 <span class="keywordflow">if</span> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a178">MI_IS_PHYSICAL_ADDRESS</a>(StartingAddress)) {
02112 
02113                     <span class="comment">//</span>
02114                     <span class="comment">// On certain architectures, virtual addresses</span>
02115                     <span class="comment">// may be physical and hence have no corresponding PTE.</span>
02116                     <span class="comment">//</span>
02117 
02118                     DebugPfn = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a179">MI_CONVERT_PHYSICAL_TO_PFN</a> (Entry));
02119                     DebugPfn += Entry-&gt;Size;
02120                     <span class="keywordflow">if</span> ((PFN_NUMBER)((DebugPfn - 1) - <a class="code" href="../../d2/d3/dumpctl_8c.html#a15">MmPfnDatabase</a>) != <a class="code" href="../../d1/d6/allocpag_8c.html#a6">MiEndOfInitialPoolFrame</a>) {
02121                         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (DebugPfn-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.StartOfAllocation == 1);
02122                     }
02123                 } <span class="keywordflow">else</span> {
02124                     DebugPte = PointerPte + Entry-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o1">Size</a>;
02125                     <span class="keywordflow">if</span> ((DebugPte-1)-&gt;u.Hard.Valid == 1) {
02126                         DebugPfn = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> ((DebugPte-1)-&gt;u.Hard.PageFrameNumber);
02127                         <span class="keywordflow">if</span> ((PFN_NUMBER)(DebugPfn - <a class="code" href="../../d2/d3/dumpctl_8c.html#a15">MmPfnDatabase</a>) != <a class="code" href="../../d1/d6/allocpag_8c.html#a6">MiEndOfInitialPoolFrame</a>) {
02128                             <span class="keywordflow">if</span> (DebugPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1) {
02129                                 DebugPfn = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (DebugPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber);
02130                                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (DebugPfn-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.StartOfAllocation == 1);
02131                             }
02132                         }
02133 
02134                     }
02135                 }
02136             }
02137 <span class="preprocessor">#endif //DBG</span>
02138 <span class="preprocessor"></span>
02139             i += Entry-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o1">Size</a>;
02140             <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a36">MmProtectFreedNonPagedPool</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
02141                 RemoveEntryList (&amp;Entry-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o0">List</a>);
02142             }
02143             <span class="keywordflow">else</span> {
02144                 <a class="code" href="../../d1/d6/allocpag_8c.html#a47">MiProtectedPoolRemoveEntryList</a> (&amp;Entry-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o0">List</a>);
02145             }
02146         }
02147 
02148         <span class="comment">//</span>
02149         <span class="comment">// Check to see if the previous page is the end of an allocation.</span>
02150         <span class="comment">// If it is not the end of an allocation, it must be free and</span>
02151         <span class="comment">// therefore this allocation can be tagged onto the end of</span>
02152         <span class="comment">// that allocation.</span>
02153         <span class="comment">//</span>
02154         <span class="comment">// We cannot walk off the beginning of expansion pool because it is</span>
02155         <span class="comment">// guard-paged.  If the initial pool is superpaged instead, we are also</span>
02156         <span class="comment">// safe as the must succeed pages always have EndOfAllocation set.</span>
02157         <span class="comment">//</span>
02158 
02159         Entry = (<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html">PMMFREE_POOL_ENTRY</a>)StartingAddress;
02160 
02161         <span class="keywordflow">if</span> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a178">MI_IS_PHYSICAL_ADDRESS</a>(StartingAddress)) {
02162             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (StartingAddress != <a class="code" href="../../d8/d5/kddata_8c.html#a23">MmNonPagedPoolStart</a>);
02163 
02164             Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a179">MI_CONVERT_PHYSICAL_TO_PFN</a> (
02165                                     (PVOID)((PCHAR)Entry - <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>)));
02166 
02167         } <span class="keywordflow">else</span> {
02168             PointerPte -= NumberOfPages + 1;
02169 
02170             <span class="comment">//</span>
02171             <span class="comment">// Unprotect the previously freed pool so it can be merged.</span>
02172             <span class="comment">//</span>
02173 
02174             <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a36">MmProtectFreedNonPagedPool</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
02175                 <a class="code" href="../../d5/d6/iosup_8c.html#a38">MiUnProtectFreeNonPagedPool</a> (
02176                     (PVOID)<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a>(PointerPte),
02177                     0);
02178             }
02179 
02180             <span class="keywordflow">if</span> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1) {
02181                 Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber);
02182             } <span class="keywordflow">else</span> {
02183                 Pfn1 = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02184             }
02185         }
02186         <span class="keywordflow">if</span> (Pfn1 != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02187             <span class="keywordflow">if</span> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.EndOfAllocation == 0) {
02188 
02189                 <span class="comment">//</span>
02190                 <span class="comment">// This range of pages is free, add these pages to</span>
02191                 <span class="comment">// this entry.  The owner field points to the address</span>
02192                 <span class="comment">// of the list entry which is linked into the free pool</span>
02193                 <span class="comment">// pages list.</span>
02194                 <span class="comment">//</span>
02195 
02196                 Entry = (<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html">PMMFREE_POOL_ENTRY</a>)((PCHAR)StartingAddress - <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
02197                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Entry-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o2">Signature</a> == <a class="code" href="../../d4/d8/mi_8h.html#a11">MM_FREE_POOL_SIGNATURE</a>);
02198                 Entry = Entry-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o3">Owner</a>;
02199 
02200                 <span class="comment">//</span>
02201                 <span class="comment">// Unprotect the previously freed pool so we can merge it</span>
02202                 <span class="comment">//</span>
02203 
02204                 <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a36">MmProtectFreedNonPagedPool</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
02205                     <a class="code" href="../../d5/d6/iosup_8c.html#a38">MiUnProtectFreeNonPagedPool</a> ((PVOID)Entry, 0);
02206                 }
02207 
02208                 <span class="comment">//</span>
02209                 <span class="comment">// If this entry became larger than MM_SMALL_ALLOCATIONS</span>
02210                 <span class="comment">// pages, move it to the tail of the list.  This keeps the</span>
02211                 <span class="comment">// small allocations at the front of the list.</span>
02212                 <span class="comment">//</span>
02213 
02214                 <span class="keywordflow">if</span> (Entry-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o1">Size</a> &lt; <a class="code" href="../../d4/d8/mi_8h.html#a324">MI_MAX_FREE_LIST_HEADS</a> - 1) {
02215 
02216                     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a36">MmProtectFreedNonPagedPool</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
02217                         RemoveEntryList (&amp;Entry-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o0">List</a>);
02218                     }
02219                     <span class="keywordflow">else</span> {
02220                         <a class="code" href="../../d1/d6/allocpag_8c.html#a47">MiProtectedPoolRemoveEntryList</a> (&amp;Entry-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o0">List</a>);
02221                     }
02222 
02223                     <span class="comment">//</span>
02224                     <span class="comment">// Add these pages to the previous entry.</span>
02225                     <span class="comment">//</span>
02226     
02227                     Entry-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o1">Size</a> += i;
02228 
02229                     <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = (ULONG)(Entry-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o1">Size</a> - 1);
02230             
02231                     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &gt;= <a class="code" href="../../d4/d8/mi_8h.html#a324">MI_MAX_FREE_LIST_HEADS</a>) {
02232                         <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = <a class="code" href="../../d4/d8/mi_8h.html#a324">MI_MAX_FREE_LIST_HEADS</a> - 1;
02233                     }
02234 
02235                     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a36">MmProtectFreedNonPagedPool</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
02236                         InsertTailList (&amp;<a class="code" href="../../d1/d6/allocpag_8c.html#a8">MmNonPagedPoolFreeListHead</a>[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>],
02237                                         &amp;Entry-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o0">List</a>);
02238                     }
02239                     <span class="keywordflow">else</span> {
02240                         <a class="code" href="../../d1/d6/allocpag_8c.html#a46">MiProtectedPoolInsertList</a> (&amp;<a class="code" href="../../d1/d6/allocpag_8c.html#a8">MmNonPagedPoolFreeListHead</a>[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>],
02241                                           &amp;Entry-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o0">List</a>,
02242                                           Entry-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o1">Size</a> &lt; <a class="code" href="../../d1/d6/allocpag_8c.html#a0">MM_SMALL_ALLOCATIONS</a> ?
02243                                               <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> : <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
02244                     }
02245                 }
02246                 <span class="keywordflow">else</span> {
02247 
02248                     <span class="comment">//</span>
02249                     <span class="comment">// Add these pages to the previous entry.</span>
02250                     <span class="comment">//</span>
02251     
02252                     Entry-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o1">Size</a> += i;
02253                 }
02254             }
02255         }
02256 
02257         <span class="keywordflow">if</span> (Entry == (<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html">PMMFREE_POOL_ENTRY</a>)StartingAddress) {
02258 
02259             <span class="comment">//</span>
02260             <span class="comment">// This entry was not combined with the previous, insert it</span>
02261             <span class="comment">// into the list.</span>
02262             <span class="comment">//</span>
02263 
02264             Entry-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o1">Size</a> = i;
02265 
02266             <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = (ULONG)(Entry-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o1">Size</a> - 1);
02267     
02268             <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &gt;= <a class="code" href="../../d4/d8/mi_8h.html#a324">MI_MAX_FREE_LIST_HEADS</a>) {
02269                 <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = <a class="code" href="../../d4/d8/mi_8h.html#a324">MI_MAX_FREE_LIST_HEADS</a> - 1;
02270             }
02271 
02272             <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a36">MmProtectFreedNonPagedPool</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
02273                 InsertTailList (&amp;<a class="code" href="../../d1/d6/allocpag_8c.html#a8">MmNonPagedPoolFreeListHead</a>[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>],
02274                                 &amp;Entry-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o0">List</a>);
02275             }
02276             <span class="keywordflow">else</span> {
02277                 <a class="code" href="../../d1/d6/allocpag_8c.html#a46">MiProtectedPoolInsertList</a> (&amp;<a class="code" href="../../d1/d6/allocpag_8c.html#a8">MmNonPagedPoolFreeListHead</a>[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>],
02278                                       &amp;Entry-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o0">List</a>,
02279                                       Entry-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o1">Size</a> &lt; <a class="code" href="../../d1/d6/allocpag_8c.html#a0">MM_SMALL_ALLOCATIONS</a> ?
02280                                           <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> : <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
02281             }
02282         }
02283 
02284         <span class="comment">//</span>
02285         <span class="comment">// Set the owner field in all these pages.</span>
02286         <span class="comment">//</span>
02287 
02288         NextEntry = (<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html">PMMFREE_POOL_ENTRY</a>)StartingAddress;
02289         <span class="keywordflow">while</span> (i &gt; 0) {
02290             NextEntry-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o3">Owner</a> = Entry;
02291 <span class="preprocessor">#if DBG</span>
02292 <span class="preprocessor"></span>            NextEntry-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o2">Signature</a> = <a class="code" href="../../d4/d8/mi_8h.html#a11">MM_FREE_POOL_SIGNATURE</a>;
02293 <span class="preprocessor">#endif</span>
02294 <span class="preprocessor"></span>
02295             NextEntry = (<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html">PMMFREE_POOL_ENTRY</a>)((PCHAR)NextEntry + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
02296             i -= 1;
02297         }
02298 
02299 <span class="preprocessor">#if DBG</span>
02300 <span class="preprocessor"></span>        NextEntry = Entry;
02301         <span class="keywordflow">for</span> (i = 0; i &lt; Entry-&gt;Size; i += 1) {
02302             <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> DebugPte;
02303             <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> DebugPfn;
02304             <span class="keywordflow">if</span> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a178">MI_IS_PHYSICAL_ADDRESS</a>(StartingAddress)) {
02305 
02306                 <span class="comment">//</span>
02307                 <span class="comment">// On certain architectures, virtual addresses</span>
02308                 <span class="comment">// may be physical and hence have no corresponding PTE.</span>
02309                 <span class="comment">//</span>
02310 
02311                 DebugPfn = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a179">MI_CONVERT_PHYSICAL_TO_PFN</a> (NextEntry));
02312             } <span class="keywordflow">else</span> {
02313 
02314                 DebugPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (NextEntry);
02315                 DebugPfn = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (DebugPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber);
02316             }
02317             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (DebugPfn-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.StartOfAllocation == 0);
02318             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (DebugPfn-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.EndOfAllocation == 0);
02319             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (NextEntry-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o3">Owner</a> == Entry);
02320             NextEntry = (<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html">PMMFREE_POOL_ENTRY</a>)((PCHAR)NextEntry + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
02321         }
02322 <span class="preprocessor">#endif</span>
02323 <span class="preprocessor"></span>
02324         <span class="comment">//</span>
02325         <span class="comment">// Prevent anyone from touching non paged pool after freeing it.</span>
02326         <span class="comment">//</span>
02327 
02328         <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a36">MmProtectFreedNonPagedPool</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
02329             <a class="code" href="../../d5/d6/iosup_8c.html#a37">MiProtectFreeNonPagedPool</a> ((PVOID)Entry, (ULONG)Entry-&gt;Size);
02330         }
02331 
02332         <span class="keywordflow">return</span> (ULONG)NumberOfPages;
02333 
02334     } <span class="keywordflow">else</span> {
02335 
02336         <span class="comment">//</span>
02337         <span class="comment">// Paged pool.  Need to verify start of allocation using</span>
02338         <span class="comment">// end of allocation bitmap.</span>
02339         <span class="comment">//</span>
02340 
02341         <span class="keywordflow">if</span> (!RtlCheckBit (PagedPoolInfo-&gt;<a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html#o0">PagedPoolAllocationMap</a>, StartPosition)) {
02342             <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a> (BAD_POOL_CALLER,
02343                           0x50,
02344                           (ULONG_PTR)StartingAddress,
02345                           (ULONG_PTR)StartPosition,
02346                           <a class="code" href="../../d8/d0/cmdat3_8c.html#a18">MmSizeOfPagedPoolInBytes</a>);
02347         }
02348 
02349 <span class="preprocessor">#if DBG</span>
02350 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (StartPosition &gt; 0) {
02351             <span class="keywordflow">if</span> (RtlCheckBit (PagedPoolInfo-&gt;<a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html#o0">PagedPoolAllocationMap</a>, StartPosition - 1)) {
02352                 <span class="keywordflow">if</span> (!RtlCheckBit (PagedPoolInfo-&gt;<a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html#o1">EndOfPagedPoolBitmap</a>, StartPosition - 1)) {
02353 
02354                     <span class="comment">//</span>
02355                     <span class="comment">// In the middle of an allocation... bugcheck.</span>
02356                     <span class="comment">//</span>
02357 
02358                     <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"paged pool in middle of allocation\n"</span>);
02359                     <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a> (MEMORY_MANAGEMENT,
02360                                   0x41286,
02361                                   (ULONG_PTR)PagedPoolInfo-&gt;<a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html#o0">PagedPoolAllocationMap</a>,
02362                                   (ULONG_PTR)PagedPoolInfo-&gt;<a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html#o1">EndOfPagedPoolBitmap</a>,
02363                                   StartPosition);
02364                 }
02365             }
02366         }
02367 <span class="preprocessor">#endif</span>
02368 <span class="preprocessor"></span>
02369         i = StartPosition;
02370         PointerPte = PagedPoolInfo-&gt;<a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html#o3">FirstPteForPagedPool</a> + i;
02371 
02372         <span class="comment">//</span>
02373         <span class="comment">// Find the last allocated page and check to see if any</span>
02374         <span class="comment">// of the pages being deallocated are in the paging file.</span>
02375         <span class="comment">//</span>
02376 
02377         <span class="keywordflow">while</span> (!RtlCheckBit (PagedPoolInfo-&gt;<a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html#o1">EndOfPagedPoolBitmap</a>, i)) {
02378             NumberOfPages += 1;
02379             i += 1;
02380         }
02381 
02382         <a class="code" href="../../d4/d2/datalpha_8c.html#a13">NoAccessPte</a>.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a97">MM_KERNEL_NOACCESS_PTE</a>;
02383 
02384         <span class="keywordflow">if</span> (SessionSpace) {
02385 
02386             <span class="comment">//</span>
02387             <span class="comment">// This is needed purely to verify no one leaks pool.  This</span>
02388             <span class="comment">// could be removed if we believe everyone was good.</span>
02389             <span class="comment">//</span>
02390 
02391             <span class="keywordflow">if</span> (RtlCheckBit (PagedPoolInfo-&gt;<a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html#o2">PagedPoolLargeSessionAllocationMap</a>,
02392                              StartPosition)) {
02393 
02394                 <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a33">RtlClearBits</a> (PagedPoolInfo-&gt;<a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html#o2">PagedPoolLargeSessionAllocationMap</a>,
02395                               StartPosition,
02396                               1<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>);
02397 
02398                 <a class="code" href="../../d1/d6/allocpag_8c.html#a51">MiSessionPoolFreed</a> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a> (PointerPte),
02399                                     NumberOfPages &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>,
02400                                     <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>);
02401             }
02402 
02403             SessionAllocation = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02404         }
02405         <span class="keywordflow">else</span> {
02406             SessionAllocation = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02407 
02408             <span class="keywordflow">if</span> (<a class="code" href="../../d4/d8/mi_8h.html#a654">VerifierLargePagedPoolMap</a>) {
02409 
02410                 <span class="keywordflow">if</span> (RtlCheckBit (<a class="code" href="../../d4/d8/mi_8h.html#a654">VerifierLargePagedPoolMap</a>, StartPosition)) {
02411     
02412                     <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a33">RtlClearBits</a> (<a class="code" href="../../d4/d8/mi_8h.html#a654">VerifierLargePagedPoolMap</a>,
02413                                   StartPosition,
02414                                   1<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>);
02415     
02416                     <a class="code" href="../../d9/d5/verifier_8c.html#a91">VerifierFreeTrackedPool</a> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a> (PointerPte),
02417                                              NumberOfPages &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>,
02418                                              <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>,
02419                                              <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
02420                 }
02421             }
02422         }
02423 
02424         PagesFreed = <a class="code" href="../../d8/d8/sysload_8c.html#a61">MiDeleteSystemPagableVm</a> (PointerPte,
02425                                               NumberOfPages,
02426                                               <a class="code" href="../../d4/d2/datalpha_8c.html#a13">NoAccessPte</a>,
02427                                               SessionAllocation,
02428                                               <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
02429 
02430         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PagesFreed == NumberOfPages);
02431 
02432         <span class="keywordflow">if</span> (SessionSpace) {
02433             <a class="code" href="../../d4/d8/mi_8h.html#a407">LOCK_SESSION_SPACE_WS</a> (OldIrql);
02434             <a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o14">CommittedPages</a> -= NumberOfPages;
02435     
02436             <a class="code" href="../../d4/d8/mi_8h.html#a384">MM_BUMP_SESS_COUNTER</a>(<a class="code" href="../../d4/d8/mi_8h.html#a379">MM_DBG_SESSION_COMMIT_POOL_FREED</a>,
02437                  NumberOfPages);
02438 
02439             <a class="code" href="../../d4/d8/mi_8h.html#a408">UNLOCK_SESSION_SPACE_WS</a> (OldIrql);
02440         }
02441         <span class="keywordflow">else</span> {
02442             <a class="code" href="../../d8/d5/kddata_8c.html#a34">MmPagedPoolCommit</a> -= (ULONG)NumberOfPages;
02443         }
02444     
02445         <a class="code" href="../../d6/d1/mmquota_8c.html#a19">MiReturnCommitment</a> (NumberOfPages);
02446 
02447         <a class="code" href="../../d4/d8/mi_8h.html#a254">MM_TRACK_COMMIT</a> (<a class="code" href="../../d4/d8/mi_8h.html#a287">MM_DBG_COMMIT_RETURN_PAGED_POOL_PAGES</a>, NumberOfPages);
02448 
02449         <span class="comment">//</span>
02450         <span class="comment">// Clear the end of allocation bit in the bit map.</span>
02451         <span class="comment">//</span>
02452 
02453         <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a33">RtlClearBits</a> (PagedPoolInfo-&gt;<a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html#o1">EndOfPagedPoolBitmap</a>, (ULONG)i, 1<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>);
02454 
02455         PagedPoolInfo-&gt;<a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html#o7">PagedPoolCommit</a> -= NumberOfPages;
02456         PagedPoolInfo-&gt;<a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html#o8">AllocatedPagedPool</a> -= NumberOfPages;
02457 
02458         <span class="comment">//</span>
02459         <span class="comment">// Clear the allocation bits in the bit map.</span>
02460         <span class="comment">//</span>
02461 
02462         <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a33">RtlClearBits</a> (PagedPoolInfo-&gt;<a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html#o0">PagedPoolAllocationMap</a>,
02463                       StartPosition,
02464                       (ULONG)NumberOfPages
02465                       );
02466 
02467         <span class="keywordflow">if</span> (StartPosition &lt; PagedPoolInfo-&gt;<a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html#o6">PagedPoolHint</a>) {
02468             PagedPoolInfo-&gt;<a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html#o6">PagedPoolHint</a> = StartPosition;
02469         }
02470 
02471         <span class="keywordflow">return</span> (ULONG)NumberOfPages;
02472     }
02473 }
02474 
02475 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l02476"></a><a class="code" href="../../d4/d8/mi_8h.html#a778">02476</a> <a class="code" href="../../d4/d8/mi_8h.html#a778">MiInitializeNonPagedPool</a> (
02477     VOID
02478     )
02479 
02480 <span class="comment">/*++</span>
02481 <span class="comment"></span>
02482 <span class="comment">Routine Description:</span>
02483 <span class="comment"></span>
02484 <span class="comment">    This function initializes the NonPaged pool.</span>
02485 <span class="comment"></span>
02486 <span class="comment">    NonPaged Pool is linked together through the pages.</span>
02487 <span class="comment"></span>
02488 <span class="comment">Arguments:</span>
02489 <span class="comment"></span>
02490 <span class="comment">    None.</span>
02491 <span class="comment"></span>
02492 <span class="comment">Return Value:</span>
02493 <span class="comment"></span>
02494 <span class="comment">    None.</span>
02495 <span class="comment"></span>
02496 <span class="comment">Environment:</span>
02497 <span class="comment"></span>
02498 <span class="comment">    Kernel mode, during initialization.</span>
02499 <span class="comment"></span>
02500 <span class="comment">--*/</span>
02501 
02502 {
02503     ULONG PagesInPool;
02504     ULONG <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
02505     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
02506     <a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html">PMMFREE_POOL_ENTRY</a> FreeEntry;
02507     <a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html">PMMFREE_POOL_ENTRY</a> FirstEntry;
02508     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
02509     PFN_NUMBER i;
02510     PULONG_PTR ThisPage;
02511     PULONG_PTR NextPage;
02512     PVOID EndOfInitialPool;
02513     PFN_NUMBER PageFrameIndex;
02514 
02515     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
02516 
02517     <span class="comment">//</span>
02518     <span class="comment">// Initialize the list heads for free pages.</span>
02519     <span class="comment">//</span>
02520 
02521     <span class="keywordflow">for</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = 0; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &lt; <a class="code" href="../../d4/d8/mi_8h.html#a324">MI_MAX_FREE_LIST_HEADS</a>; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> += 1) {
02522         InitializeListHead (&amp;<a class="code" href="../../d1/d6/allocpag_8c.html#a8">MmNonPagedPoolFreeListHead</a>[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>]);
02523     }
02524 
02525     <span class="comment">//</span>
02526     <span class="comment">// Initialize the must succeed pool (this occupies the first</span>
02527     <span class="comment">// pages of the pool area).</span>
02528     <span class="comment">//</span>
02529 
02530     <span class="comment">//</span>
02531     <span class="comment">// Allocate NonPaged pool for the NonPagedPoolMustSucceed pool.</span>
02532     <span class="comment">//</span>
02533 
02534     <a class="code" href="../../d4/d8/mi_8h.html#a649">MmNonPagedMustSucceed</a> = (PCHAR)<a class="code" href="../../d8/d5/kddata_8c.html#a23">MmNonPagedPoolStart</a>;
02535 
02536     i = <a class="code" href="../../d4/d8/mi_8h.html#a627">MmSizeOfNonPagedMustSucceed</a> - <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
02537 
02538     <a class="code" href="../../d4/d8/mi_8h.html#a631">MmMustSucceedPoolBitPosition</a> = <a class="code" href="../../d2/d1/mm_8h.html#a5">BYTES_TO_PAGES</a>(<a class="code" href="../../d4/d8/mi_8h.html#a627">MmSizeOfNonPagedMustSucceed</a>);
02539 
02540     ThisPage = (PULONG_PTR)<a class="code" href="../../d4/d8/mi_8h.html#a649">MmNonPagedMustSucceed</a>;
02541 
02542     <span class="keywordflow">while</span> (i &gt; 0) {
02543         NextPage = (PULONG_PTR)((PCHAR)ThisPage + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
02544         *ThisPage = (ULONG_PTR)NextPage;
02545         ThisPage = NextPage;
02546         i -= <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
02547     }
02548     *ThisPage = 0;
02549 
02550     <span class="comment">//</span>
02551     <span class="comment">// Set up the remaining pages as non paged pool pages.</span>
02552     <span class="comment">//</span>
02553 
02554     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ((<a class="code" href="../../d4/d8/mi_8h.html#a627">MmSizeOfNonPagedMustSucceed</a> &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1)) == 0);
02555     FreeEntry = (<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html">PMMFREE_POOL_ENTRY</a>)((PCHAR)<a class="code" href="../../d8/d5/kddata_8c.html#a23">MmNonPagedPoolStart</a> +
02556                                             <a class="code" href="../../d4/d8/mi_8h.html#a627">MmSizeOfNonPagedMustSucceed</a>);
02557     FirstEntry = FreeEntry;
02558 
02559     PagesInPool = <a class="code" href="../../d2/d1/mm_8h.html#a5">BYTES_TO_PAGES</a>(<a class="code" href="../../d8/d0/cmdat3_8c.html#a19">MmSizeOfNonPagedPoolInBytes</a> -
02560                                     <a class="code" href="../../d4/d8/mi_8h.html#a627">MmSizeOfNonPagedMustSucceed</a>);
02561 
02562     <span class="comment">//</span>
02563     <span class="comment">// Set the location of expanded pool.</span>
02564     <span class="comment">//</span>
02565 
02566     <a class="code" href="../../d4/d8/mi_8h.html#a629">MmExpandedPoolBitPosition</a> = <a class="code" href="../../d2/d1/mm_8h.html#a5">BYTES_TO_PAGES</a> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a19">MmSizeOfNonPagedPoolInBytes</a>);
02567 
02568     <a class="code" href="../../d4/d8/mi_8h.html#a630">MmNumberOfFreeNonPagedPool</a> = PagesInPool;
02569 
02570     <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = (ULONG)(<a class="code" href="../../d4/d8/mi_8h.html#a630">MmNumberOfFreeNonPagedPool</a> - 1);
02571     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &gt;= <a class="code" href="../../d4/d8/mi_8h.html#a324">MI_MAX_FREE_LIST_HEADS</a>) {
02572         <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = <a class="code" href="../../d4/d8/mi_8h.html#a324">MI_MAX_FREE_LIST_HEADS</a> - 1;
02573     }
02574 
02575     InsertHeadList (&amp;<a class="code" href="../../d1/d6/allocpag_8c.html#a8">MmNonPagedPoolFreeListHead</a>[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>], &amp;FreeEntry-&gt;List);
02576 
02577     FreeEntry-&gt;Size = PagesInPool;
02578 <span class="preprocessor">#if DBG</span>
02579 <span class="preprocessor"></span>    FreeEntry-&gt;Signature = <a class="code" href="../../d4/d8/mi_8h.html#a11">MM_FREE_POOL_SIGNATURE</a>;
02580 <span class="preprocessor">#endif</span>
02581 <span class="preprocessor"></span>    FreeEntry-&gt;Owner = FirstEntry;
02582 
02583     <span class="keywordflow">while</span> (PagesInPool &gt; 1) {
02584         FreeEntry = (<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html">PMMFREE_POOL_ENTRY</a>)((PCHAR)FreeEntry + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
02585 <span class="preprocessor">#if DBG</span>
02586 <span class="preprocessor"></span>        FreeEntry-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o2">Signature</a> = <a class="code" href="../../d4/d8/mi_8h.html#a11">MM_FREE_POOL_SIGNATURE</a>;
02587 <span class="preprocessor">#endif</span>
02588 <span class="preprocessor"></span>        FreeEntry-&gt;Owner = FirstEntry;
02589         PagesInPool -= 1;
02590     }
02591 
02592     <span class="comment">//</span>
02593     <span class="comment">// Set the last nonpaged pool PFN so coalescing on free doesn't go</span>
02594     <span class="comment">// past the end of the initial pool.</span>
02595     <span class="comment">//</span>
02596 
02597     EndOfInitialPool = (PVOID)((ULONG_PTR)<a class="code" href="../../d8/d5/kddata_8c.html#a23">MmNonPagedPoolStart</a> + <a class="code" href="../../d8/d0/cmdat3_8c.html#a19">MmSizeOfNonPagedPoolInBytes</a> - 1);
02598 
02599     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a178">MI_IS_PHYSICAL_ADDRESS</a>(EndOfInitialPool)) {
02600         PageFrameIndex = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a179">MI_CONVERT_PHYSICAL_TO_PFN</a> (EndOfInitialPool);
02601     } <span class="keywordflow">else</span> {
02602         PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>(EndOfInitialPool);
02603         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1);
02604         PageFrameIndex = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a182">MI_GET_PAGE_FRAME_FROM_PTE</a> (PointerPte);
02605     }
02606     <a class="code" href="../../d1/d6/allocpag_8c.html#a6">MiEndOfInitialPoolFrame</a> = PageFrameIndex;
02607 
02608     <span class="comment">//</span>
02609     <span class="comment">// Set up the system PTEs for nonpaged pool expansion.</span>
02610     <span class="comment">//</span>
02611 
02612     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (<a class="code" href="../../d1/d6/allocpag_8c.html#a7">MmNonPagedPoolExpansionStart</a>);
02613     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 0);
02614 
02615     <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> = <a class="code" href="../../d2/d1/mm_8h.html#a5">BYTES_TO_PAGES</a>(<a class="code" href="../../d8/d5/kddata_8c.html#a21">MmMaximumNonPagedPoolInBytes</a> -
02616                             <a class="code" href="../../d8/d0/cmdat3_8c.html#a19">MmSizeOfNonPagedPoolInBytes</a>);
02617 
02618     <span class="comment">//</span>
02619     <span class="comment">// Insert a guard PTE at the bottom of expanded nonpaged pool.</span>
02620     <span class="comment">//</span>
02621 
02622     <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> -= 1;
02623     PointerPte += 1;
02624 
02625     <a class="code" href="../../d0/d9/sysptes_8c.html#a27">MiInitializeSystemPtes</a> (PointerPte,
02626                             <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>,
02627                             <a class="code" href="../../d4/d8/mi_8h.html#a1003a770">NonPagedPoolExpansion</a>
02628                             );
02629 
02630     <span class="comment">//</span>
02631     <span class="comment">// A guard PTE is built at the top by our caller.  This allows us to</span>
02632     <span class="comment">// freely increment virtual addresses in MiFreePoolPages and just check</span>
02633     <span class="comment">// for a blank PTE.</span>
02634     <span class="comment">//</span>
02635 }
02636 
02637 <span class="preprocessor">#if DBG || (i386 &amp;&amp; !FPO)</span>
02638 <span class="preprocessor"></span>
02639 <span class="comment">//</span>
02640 <span class="comment">// This only works on checked builds, because the TraceLargeAllocs array is</span>
02641 <span class="comment">// kept in that case to keep track of page size pool allocations.  Otherwise</span>
02642 <span class="comment">// we will call ExpSnapShotPoolPages with a page size pool allocation containing</span>
02643 <span class="comment">// arbitrary data and it will potentially go off in the weeds trying to</span>
02644 <span class="comment">// interpret it as a suballocated pool page.  Ideally, there would be another</span>
02645 <span class="comment">// bit map that identified single page pool allocations so</span>
02646 <span class="comment">// ExpSnapShotPoolPages would NOT be called for those.</span>
02647 <span class="comment">//</span>
02648 
02649 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
02650 MmSnapShotPool(
02651     IN POOL_TYPE PoolType,
02652     IN PMM_SNAPSHOT_POOL_PAGE SnapShotPoolPage,
02653     IN PSYSTEM_POOL_INFORMATION PoolInformation,
02654     IN ULONG Length,
02655     IN OUT PULONG RequiredLength
02656     )
02657 {
02658     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
02659     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
02660     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> xStatus;
02661     PCHAR p, pStart;
02662     PVOID *pp;
02663     ULONG <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
02664     ULONG BusyFlag;
02665     ULONG CurrentPage, NumberOfPages;
02666     PSYSTEM_POOL_ENTRY PoolEntryInfo;
02667     PLIST_ENTRY Entry;
02668     <a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html">PMMFREE_POOL_ENTRY</a> FreePageInfo;
02669     ULONG StartPosition;
02670     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
02671     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn1;
02672     LOGICAL NeedsReprotect;
02673 
02674     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
02675     PoolEntryInfo = &amp;PoolInformation-&gt;Entries[0];
02676 
02677     <span class="keywordflow">if</span> (PoolType == <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>) {
02678         PoolInformation-&gt;TotalSize = (PCHAR)<a class="code" href="../../d8/d5/kddata_8c.html#a26">MmPagedPoolEnd</a> -
02679                                      (PCHAR)<a class="code" href="../../d8/d5/kddata_8c.html#a25">MmPagedPoolStart</a>;
02680         PoolInformation-&gt;FirstEntry = <a class="code" href="../../d8/d5/kddata_8c.html#a25">MmPagedPoolStart</a>;
02681         p = <a class="code" href="../../d8/d5/kddata_8c.html#a25">MmPagedPoolStart</a>;
02682         CurrentPage = 0;
02683         <span class="keywordflow">while</span> (p &lt; (PCHAR)<a class="code" href="../../d8/d5/kddata_8c.html#a26">MmPagedPoolEnd</a>) {
02684             pStart = p;
02685             BusyFlag = RtlCheckBit (<a class="code" href="../../d8/d5/kddata_8c.html#a27">MmPagedPoolInfo</a>.PagedPoolAllocationMap, CurrentPage);
02686             <span class="keywordflow">while</span> (~(BusyFlag ^ RtlCheckBit (<a class="code" href="../../d8/d5/kddata_8c.html#a27">MmPagedPoolInfo</a>.PagedPoolAllocationMap, CurrentPage))) {
02687                 p += <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
02688                 <span class="keywordflow">if</span> (RtlCheckBit (<a class="code" href="../../d8/d5/kddata_8c.html#a27">MmPagedPoolInfo</a>.EndOfPagedPoolBitmap, CurrentPage)) {
02689                     CurrentPage += 1;
02690                     <span class="keywordflow">break</span>;
02691                 }
02692 
02693                 CurrentPage += 1;
02694                 <span class="keywordflow">if</span> (p &gt; (PCHAR)<a class="code" href="../../d8/d5/kddata_8c.html#a26">MmPagedPoolEnd</a>) {
02695                     <span class="keywordflow">break</span>;
02696                }
02697             }
02698 
02699             <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> = (ULONG)(p - pStart);
02700             <span class="keywordflow">if</span> (BusyFlag) {
02701                 xStatus = (*SnapShotPoolPage)(pStart,
02702                                               <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>,
02703                                               PoolInformation,
02704                                               &amp;PoolEntryInfo,
02705                                               Length,
02706                                               RequiredLength
02707                                               );
02708                 <span class="keywordflow">if</span> (xStatus != STATUS_COMMITMENT_LIMIT) {
02709                     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = xStatus;
02710                 }
02711             }
02712             <span class="keywordflow">else</span> {
02713                 PoolInformation-&gt;NumberOfEntries += 1;
02714                 *RequiredLength += <span class="keyword">sizeof</span> (SYSTEM_POOL_ENTRY);
02715                 <span class="keywordflow">if</span> (Length &lt; *RequiredLength) {
02716                     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INFO_LENGTH_MISMATCH;
02717                 }
02718                 <span class="keywordflow">else</span> {
02719                     PoolEntryInfo-&gt;Allocated = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02720                     PoolEntryInfo-&gt;Size = <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
02721                     PoolEntryInfo-&gt;AllocatorBackTraceIndex = 0;
02722                     PoolEntryInfo-&gt;TagUlong = 0;
02723                     PoolEntryInfo += 1;
02724                     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
02725                 }
02726             }
02727         }
02728     }
02729     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (PoolType == <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>) {
02730         PoolInformation-&gt;TotalSize = <a class="code" href="../../d8/d0/cmdat3_8c.html#a19">MmSizeOfNonPagedPoolInBytes</a>;
02731         PoolInformation-&gt;FirstEntry = <a class="code" href="../../d8/d5/kddata_8c.html#a23">MmNonPagedPoolStart</a>;
02732 
02733         p = <a class="code" href="../../d8/d5/kddata_8c.html#a23">MmNonPagedPoolStart</a>;
02734         <span class="keywordflow">while</span> (p &lt; (PCHAR)<a class="code" href="../../d8/d5/kddata_8c.html#a24">MmNonPagedPoolEnd</a>) {
02735 
02736             <span class="comment">//</span>
02737             <span class="comment">// NonPaged pool is linked together through the pages themselves.</span>
02738             <span class="comment">//</span>
02739 
02740             pp = (PVOID *)<a class="code" href="../../d4/d8/mi_8h.html#a649">MmNonPagedMustSucceed</a>;
02741             <span class="keywordflow">while</span> (pp) {
02742                 <span class="keywordflow">if</span> (p == (PCHAR)pp) {
02743                     PoolInformation-&gt;NumberOfEntries += 1;
02744                     *RequiredLength += <span class="keyword">sizeof</span>( SYSTEM_POOL_ENTRY );
02745                     <span class="keywordflow">if</span> (Length &lt; *RequiredLength) {
02746                         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INFO_LENGTH_MISMATCH;
02747                     }
02748                     <span class="keywordflow">else</span> {
02749                         PoolEntryInfo-&gt;Allocated = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02750                         PoolEntryInfo-&gt;Size = <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
02751                         PoolEntryInfo-&gt;AllocatorBackTraceIndex = 0;
02752                         PoolEntryInfo-&gt;TagUlong = 0;
02753                         PoolEntryInfo += 1;
02754                         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
02755                     }
02756 
02757                     p += <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
02758                     pp = (PVOID *)<a class="code" href="../../d4/d8/mi_8h.html#a649">MmNonPagedMustSucceed</a>;
02759                 }
02760                 <span class="keywordflow">else</span> {
02761                     pp = (PVOID *)*pp;
02762                 }
02763             }
02764 
02765             NeedsReprotect = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02766 
02767             <span class="keywordflow">for</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = 0; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &lt; <a class="code" href="../../d4/d8/mi_8h.html#a324">MI_MAX_FREE_LIST_HEADS</a>; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> += 1) {
02768 
02769                 Entry = <a class="code" href="../../d1/d6/allocpag_8c.html#a8">MmNonPagedPoolFreeListHead</a>[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].Flink;
02770     
02771                 <span class="keywordflow">while</span> (Entry != &amp;<a class="code" href="../../d1/d6/allocpag_8c.html#a8">MmNonPagedPoolFreeListHead</a>[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>]) {
02772     
02773                     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a36">MmProtectFreedNonPagedPool</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
02774                         <a class="code" href="../../d5/d6/iosup_8c.html#a38">MiUnProtectFreeNonPagedPool</a> ((PVOID)Entry, 0);
02775                         NeedsReprotect = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02776                     }
02777 
02778                     FreePageInfo = CONTAINING_RECORD( Entry,
02779                                                       <a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html">MMFREE_POOL_ENTRY</a>,
02780                                                       List
02781                                                     );
02782     
02783                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (FreePageInfo-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o2">Signature</a> == MM_FREE_POOL_SIGNATURE);
02784     
02785                     <span class="keywordflow">if</span> (p == (PCHAR)FreePageInfo) {
02786     
02787                         <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> = (ULONG)(FreePageInfo-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o1">Size</a> &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
02788                         PoolInformation-&gt;NumberOfEntries += 1;
02789                         *RequiredLength += <span class="keyword">sizeof</span>( SYSTEM_POOL_ENTRY );
02790                         <span class="keywordflow">if</span> (Length &lt; *RequiredLength) {
02791                             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INFO_LENGTH_MISMATCH;
02792                         }
02793                         <span class="keywordflow">else</span> {
02794                             PoolEntryInfo-&gt;Allocated = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02795                             PoolEntryInfo-&gt;Size = <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
02796                             PoolEntryInfo-&gt;AllocatorBackTraceIndex = 0;
02797                             PoolEntryInfo-&gt;TagUlong = 0;
02798                             PoolEntryInfo += 1;
02799                             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
02800                         }
02801     
02802                         p += <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
02803                         <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = <a class="code" href="../../d4/d8/mi_8h.html#a324">MI_MAX_FREE_LIST_HEADS</a>;
02804                         <span class="keywordflow">break</span>;
02805                     }
02806     
02807                     Entry = FreePageInfo-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o0">List</a>.Flink;
02808     
02809                     <span class="keywordflow">if</span> (NeedsReprotect == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
02810                         <a class="code" href="../../d5/d6/iosup_8c.html#a37">MiProtectFreeNonPagedPool</a> ((PVOID)FreePageInfo,
02811                                                    (ULONG)FreePageInfo-&gt;Size);
02812                         NeedsReprotect = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02813                     }
02814                 }
02815             }
02816 
02817             StartPosition = <a class="code" href="../../d2/d1/mm_8h.html#a5">BYTES_TO_PAGES</a>((PCHAR)p -
02818                   (PCHAR)MmPageAlignedPoolBase[NonPagedPool]);
02819             <span class="keywordflow">if</span> (StartPosition &gt;= <a class="code" href="../../d4/d8/mi_8h.html#a629">MmExpandedPoolBitPosition</a>) {
02820                 <span class="keywordflow">if</span> (NeedsReprotect == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
02821                     <a class="code" href="../../d5/d6/iosup_8c.html#a37">MiProtectFreeNonPagedPool</a> ((PVOID)FreePageInfo,
02822                                                (ULONG)FreePageInfo-&gt;Size);
02823                 }
02824                 <span class="keywordflow">break</span>;
02825             }
02826 
02827             <span class="keywordflow">if</span> (StartPosition &lt; <a class="code" href="../../d4/d8/mi_8h.html#a631">MmMustSucceedPoolBitPosition</a>) {
02828                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (NeedsReprotect == FALSE);
02829                 <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
02830                 xStatus = (*SnapShotPoolPage) (p,
02831                                                <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>,
02832                                                PoolInformation,
02833                                                &amp;PoolEntryInfo,
02834                                                Length,
02835                                                RequiredLength
02836                                               );
02837                 <span class="keywordflow">if</span> (xStatus != STATUS_COMMITMENT_LIMIT) {
02838                     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = xStatus;
02839                 }
02840             }
02841             <span class="keywordflow">else</span> {
02842                 <span class="keywordflow">if</span> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a178">MI_IS_PHYSICAL_ADDRESS</a>(p)) {
02843                     <span class="comment">//</span>
02844                     <span class="comment">// On certain architectures, virtual addresses</span>
02845                     <span class="comment">// may be physical and hence have no corresponding PTE.</span>
02846                     <span class="comment">//</span>
02847                     PointerPte = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02848                     Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (MI_CONVERT_PHYSICAL_TO_PFN (p));
02849                 } <span class="keywordflow">else</span> {
02850                     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (p);
02851                     Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber);
02852                 }
02853                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.StartOfAllocation != 0);
02854 
02855                 <span class="comment">//</span>
02856                 <span class="comment">// Find end of allocation and determine size.</span>
02857                 <span class="comment">//</span>
02858 
02859                 NumberOfPages = 1;
02860                 <span class="keywordflow">while</span> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.EndOfAllocation == 0) {
02861                     NumberOfPages += 1;
02862                     <span class="keywordflow">if</span> (PointerPte == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02863                         Pfn1 += 1;
02864                     }
02865                     <span class="keywordflow">else</span> {
02866                         PointerPte += 1;
02867                         Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber);
02868                     }
02869                 }
02870 
02871                 <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> = NumberOfPages &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>;
02872                 xStatus = (*SnapShotPoolPage) (p,
02873                                                <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>,
02874                                                PoolInformation,
02875                                                &amp;PoolEntryInfo,
02876                                                Length,
02877                                                RequiredLength
02878                                               );
02879                 <span class="keywordflow">if</span> (NeedsReprotect == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
02880                     <a class="code" href="../../d5/d6/iosup_8c.html#a37">MiProtectFreeNonPagedPool</a> ((PVOID)FreePageInfo,
02881                                                (ULONG)FreePageInfo-&gt;Size);
02882                 }
02883 
02884                 <span class="keywordflow">if</span> (xStatus != STATUS_COMMITMENT_LIMIT) {
02885                     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = xStatus;
02886                 }
02887             }
02888 
02889             p += <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
02890         }
02891     }
02892     <span class="keywordflow">else</span> {
02893         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_NOT_IMPLEMENTED;
02894     }
02895 
02896     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
02897 }
02898 
02899 <span class="preprocessor">#endif // DBG || (i386 &amp;&amp; !FPO)</span>
02900 <span class="preprocessor"></span>
<a name="l02901"></a><a class="code" href="../../d1/d6/allocpag_8c.html#a12">02901</a> ULONG <a class="code" href="../../d2/d1/mm_8h.html#a159">MmSpecialPoolTag</a>;
<a name="l02902"></a><a class="code" href="../../d1/d6/allocpag_8c.html#a13">02902</a> PVOID <a class="code" href="../../d2/d1/mm_8h.html#a160">MmSpecialPoolStart</a>;
<a name="l02903"></a><a class="code" href="../../d1/d6/allocpag_8c.html#a14">02903</a> PVOID <a class="code" href="../../d2/d1/mm_8h.html#a161">MmSpecialPoolEnd</a>;
02904 
<a name="l02905"></a><a class="code" href="../../d1/d6/allocpag_8c.html#a15">02905</a> ULONG <a class="code" href="../../d1/d6/allocpag_8c.html#a15">MmSpecialPoolRejected</a>[5];
<a name="l02906"></a><a class="code" href="../../d1/d6/allocpag_8c.html#a16">02906</a> LOGICAL <a class="code" href="../../d8/d0/cmdat3_8c.html#a28">MmSpecialPoolCatchOverruns</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02907 
02908 
<a name="l02909"></a><a class="code" href="../../d1/d6/allocpag_8c.html#a17">02909</a> <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> <a class="code" href="../../d1/d6/allocpag_8c.html#a17">MiSpecialPoolFirstPte</a>;
<a name="l02910"></a><a class="code" href="../../d1/d6/allocpag_8c.html#a18">02910</a> <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> <a class="code" href="../../d1/d6/allocpag_8c.html#a18">MiSpecialPoolLastPte</a>;
02911 
<a name="l02912"></a><a class="code" href="../../d1/d6/allocpag_8c.html#a19">02912</a> ULONG <a class="code" href="../../d1/d6/allocpag_8c.html#a19">MiSpecialPagesNonPaged</a>;
<a name="l02913"></a><a class="code" href="../../d1/d6/allocpag_8c.html#a20">02913</a> ULONG <a class="code" href="../../d1/d6/allocpag_8c.html#a20">MiSpecialPagesPagable</a>;
<a name="l02914"></a><a class="code" href="../../d1/d6/allocpag_8c.html#a21">02914</a> ULONG <a class="code" href="../../d1/d6/allocpag_8c.html#a21">MmSpecialPagesInUse</a>;      <span class="comment">// Used by the debugger</span>
02915 
<a name="l02916"></a><a class="code" href="../../d1/d6/allocpag_8c.html#a22">02916</a> ULONG <a class="code" href="../../d1/d6/allocpag_8c.html#a22">MiSpecialPagesNonPagedPeak</a>;
<a name="l02917"></a><a class="code" href="../../d1/d6/allocpag_8c.html#a23">02917</a> ULONG <a class="code" href="../../d1/d6/allocpag_8c.html#a23">MiSpecialPagesPagablePeak</a>;
<a name="l02918"></a><a class="code" href="../../d1/d6/allocpag_8c.html#a24">02918</a> ULONG <a class="code" href="../../d1/d6/allocpag_8c.html#a24">MiSpecialPagesInUsePeak</a>;
02919 
<a name="l02920"></a><a class="code" href="../../d1/d6/allocpag_8c.html#a25">02920</a> ULONG <a class="code" href="../../d1/d6/allocpag_8c.html#a25">MiSpecialPagesNonPagedMaximum</a>;
02921 
<a name="l02922"></a><a class="code" href="../../d1/d6/allocpag_8c.html#a26">02922</a> ULONG <a class="code" href="../../d1/d6/allocpag_8c.html#a26">MiSpecialPoolPtes</a>;
02923 
<a name="l02924"></a><a class="code" href="../../d1/d6/allocpag_8c.html#a27">02924</a> LOGICAL <a class="code" href="../../d1/d6/allocpag_8c.html#a27">MiSpecialPoolEnabled</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02925 
02926 SIZE_T
<a name="l02927"></a><a class="code" href="../../d1/d6/allocpag_8c.html#a57">02927</a> <a class="code" href="../../d1/d6/allocpag_8c.html#a57">MmQuerySpecialPoolBlockSize</a> (
02928     IN PVOID P
02929     )
02930 
02931 <span class="comment">/*++</span>
02932 <span class="comment"></span>
02933 <span class="comment">Routine Description:</span>
02934 <span class="comment"></span>
02935 <span class="comment">    This routine returns the size of a special pool allocation.</span>
02936 <span class="comment"></span>
02937 <span class="comment">Arguments:</span>
02938 <span class="comment"></span>
02939 <span class="comment">    VirtualAddress - Supplies the special pool virtual address to query.</span>
02940 <span class="comment"></span>
02941 <span class="comment">Return Value:</span>
02942 <span class="comment"></span>
02943 <span class="comment">    The size in bytes of the allocation.</span>
02944 <span class="comment"></span>
02945 <span class="comment">Environment:</span>
02946 <span class="comment"></span>
02947 <span class="comment">    Kernel mode, APC_LEVEL or below for pagable addresses, DISPATCH_LEVEL or</span>
02948 <span class="comment">    below for nonpaged addresses.</span>
02949 <span class="comment"></span>
02950 <span class="comment">--*/</span>
02951 
02952 {
02953     <a class="code" href="../../d5/d8/struct__POOL__HEADER.html">PPOOL_HEADER</a> <a class="code" href="../../d3/d3/dumpuser_8c.html#a17">Header</a>;
02954 
02955     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ((P &gt;= <a class="code" href="../../d2/d1/mm_8h.html#a160">MmSpecialPoolStart</a>) &amp;&amp; (P &lt; <a class="code" href="../../d2/d1/mm_8h.html#a161">MmSpecialPoolEnd</a>));
02956 
02957     <span class="keywordflow">if</span> (((ULONG_PTR)P &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1))) {
02958         <a class="code" href="../../d3/d3/dumpuser_8c.html#a17">Header</a> = <a class="code" href="../../d2/d1/mm_8h.html#a7">PAGE_ALIGN</a> (P);
02959     }
02960     <span class="keywordflow">else</span> {
02961         <a class="code" href="../../d3/d3/dumpuser_8c.html#a17">Header</a> = (<a class="code" href="../../d5/d8/struct__POOL__HEADER.html">PPOOL_HEADER</a>)((PCHAR)<a class="code" href="../../d2/d1/mm_8h.html#a7">PAGE_ALIGN</a> (P) + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - <a class="code" href="../../d5/d2/poolhack_8c.html#a6">POOL_OVERHEAD</a>);
02962     }
02963 
02964     <span class="keywordflow">return</span> (SIZE_T)(<a class="code" href="../../d3/d3/dumpuser_8c.html#a17">Header</a>-&gt;Ulong1 &amp; ~(<a class="code" href="../../d4/d8/mi_8h.html#a2">MI_SPECIAL_POOL_PAGABLE</a> | <a class="code" href="../../d4/d8/mi_8h.html#a3">MI_SPECIAL_POOL_VERIFIER</a>));
02965 }
02966 
02967 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
02968 <a class="code" href="../../d1/d6/allocpag_8c.html#a43">MiMakeSpecialPoolPagable</a> (
02969     IN PVOID VirtualAddress,
02970     IN <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte
02971     );
02972 
02973 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l02974"></a><a class="code" href="../../d1/d6/allocpag_8c.html#a35">02974</a> <a class="code" href="../../d5/d1/mminit_8c.html#a44">MiInitializeSpecialPool</a> (
02975     VOID
02976     )
02977 
02978 <span class="comment">/*++</span>
02979 <span class="comment"></span>
02980 <span class="comment">Routine Description:</span>
02981 <span class="comment"></span>
02982 <span class="comment">    This routine initializes the special pool used to catch pool corruptors.</span>
02983 <span class="comment"></span>
02984 <span class="comment">Arguments:</span>
02985 <span class="comment"></span>
02986 <span class="comment">    None.</span>
02987 <span class="comment"></span>
02988 <span class="comment">Return Value:</span>
02989 <span class="comment"></span>
02990 <span class="comment">    None.</span>
02991 <span class="comment"></span>
02992 <span class="comment">Environment:</span>
02993 <span class="comment"></span>
02994 <span class="comment">    Kernel mode, no locks held.</span>
02995 <span class="comment"></span>
02996 <span class="comment">--*/</span>
02997 
02998 {
02999     ULONG BugCheckOnFailure;
03000     KIRQL OldIrql;
03001     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
03002 
03003     <span class="keywordflow">if</span> ((<a class="code" href="../../d8/d0/cmdat3_8c.html#a10">MmVerifyDriverBufferLength</a> == (ULONG)-1) &amp;&amp;
03004         ((<a class="code" href="../../d2/d1/mm_8h.html#a159">MmSpecialPoolTag</a> == 0) || (<a class="code" href="../../d2/d1/mm_8h.html#a159">MmSpecialPoolTag</a> == (ULONG)-1))) {
03005             <span class="keywordflow">return</span>;
03006     }
03007 
03008 <span class="preprocessor">#if PFN_CONSISTENCY</span>
03009 <span class="preprocessor"></span>    MiUnMapPfnDatabase ();
03010 <span class="preprocessor">#endif</span>
03011 <span class="preprocessor"></span>
03012     <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
03013 
03014     <span class="comment">//</span>
03015     <span class="comment">// Even though we asked for some number of system PTEs to map special pool,</span>
03016     <span class="comment">// we may not have been given them all.  Large memory systems are</span>
03017     <span class="comment">// autoconfigured so that a large nonpaged pool is the default.</span>
03018     <span class="comment">// x86 systems booted with the 3GB switch and all Alphas don't have enough</span>
03019     <span class="comment">// contiguous virtual address space to support this, so our request may</span>
03020     <span class="comment">// have been trimmed.  Handle that intelligently here so we don't exhaust</span>
03021     <span class="comment">// the system PTE pool and fail to handle thread stacks and I/O.</span>
03022     <span class="comment">//</span>
03023 
03024     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a23">MmNumberOfSystemPtes</a> &lt; 0x3000) {
03025         <a class="code" href="../../d1/d6/allocpag_8c.html#a26">MiSpecialPoolPtes</a> = <a class="code" href="../../d8/d0/cmdat3_8c.html#a23">MmNumberOfSystemPtes</a> / 6;
03026     }
03027     <span class="keywordflow">else</span> {
03028         <a class="code" href="../../d1/d6/allocpag_8c.html#a26">MiSpecialPoolPtes</a> = <a class="code" href="../../d8/d0/cmdat3_8c.html#a23">MmNumberOfSystemPtes</a> / 3;
03029     }
03030 
03031 <span class="preprocessor">#if !defined (_WIN64)</span>
03032 <span class="preprocessor"></span>
03033     <span class="comment">//</span>
03034     <span class="comment">// 32-bit systems are very cramped on virtual address space.  Apply</span>
03035     <span class="comment">// a cap here to prevent overzealousness.</span>
03036     <span class="comment">//</span>
03037 
03038     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d6/allocpag_8c.html#a26">MiSpecialPoolPtes</a> &gt; <a class="code" href="../../d4/d8/mi_8h.html#a248">MM_SPECIAL_POOL_PTES</a>) {
03039         <a class="code" href="../../d1/d6/allocpag_8c.html#a26">MiSpecialPoolPtes</a> = <a class="code" href="../../d4/d8/mi_8h.html#a248">MM_SPECIAL_POOL_PTES</a>;
03040     }
03041 <span class="preprocessor">#endif</span>
03042 <span class="preprocessor"></span>
03043 <span class="preprocessor">#ifdef _X86_</span>
03044 <span class="preprocessor"></span>
03045     <span class="comment">//</span>
03046     <span class="comment">// For x86, we can actually use an additional range of special PTEs to</span>
03047     <span class="comment">// map memory with and so we can raise the limit from 25000 to approximately</span>
03048     <span class="comment">// 96000.</span>
03049     <span class="comment">//</span>
03050 
03051     <span class="keywordflow">if</span> ((<a class="code" href="../../d2/d2/data386_8c.html#a27">MiNumberOfExtraSystemPdes</a> != 0) &amp;&amp;
03052         ((<a class="code" href="../../d4/d8/mi_8h.html#a581">MiHydra</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) || (<a class="code" href="../../d8/d0/cmdat3_8c.html#a54">ExpMultiUserTS</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>)) &amp;&amp;
03053         (<a class="code" href="../../d4/d8/mi_8h.html#a633">MiRequestedSystemPtes</a> != (ULONG)-1)) {
03054 
03055         <span class="keywordflow">if</span> (<a class="code" href="../../d1/d6/allocpag_8c.html#a10">MmPagedPoolMaximumDesired</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
03056 
03057             <span class="comment">//</span>
03058             <span class="comment">// The low PTEs between 0xA4000000 &amp; 0xC0000000 must be used</span>
03059             <span class="comment">// for both regular system PTE usage and special pool usage.</span>
03060             <span class="comment">//</span>
03061 
03062             <a class="code" href="../../d1/d6/allocpag_8c.html#a26">MiSpecialPoolPtes</a> = (<a class="code" href="../../d2/d2/data386_8c.html#a27">MiNumberOfExtraSystemPdes</a> / 2) * <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a103">PTE_PER_PAGE</a>;
03063         }
03064         <span class="keywordflow">else</span> {
03065 
03066             <span class="comment">//</span>
03067             <span class="comment">// The low PTEs between 0xA4000000 &amp; 0xC0000000 can be used</span>
03068             <span class="comment">// exclusively for special pool.</span>
03069             <span class="comment">//</span>
03070 
03071             <a class="code" href="../../d1/d6/allocpag_8c.html#a26">MiSpecialPoolPtes</a> = <a class="code" href="../../d2/d2/data386_8c.html#a27">MiNumberOfExtraSystemPdes</a> * <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a103">PTE_PER_PAGE</a>;
03072         }
03073     }
03074 
03075 <span class="preprocessor">#endif</span>
03076 <span class="preprocessor"></span>
03077     <span class="comment">//</span>
03078     <span class="comment">// A PTE disappears for double mapping the system page directory.</span>
03079     <span class="comment">// When guard paging for system PTEs is enabled, a few more go also.</span>
03080     <span class="comment">// Thus, not being able to get all the PTEs we wanted is not fatal and</span>
03081     <span class="comment">// we just back off a bit and retry.</span>
03082     <span class="comment">//</span>
03083 
03084     <span class="comment">//</span>
03085     <span class="comment">// Always request an even number of PTEs so each one can be guard paged.</span>
03086     <span class="comment">//</span>
03087 
03088     <a class="code" href="../../d1/d6/allocpag_8c.html#a26">MiSpecialPoolPtes</a> &amp;= ~0x1;
03089 
03090     BugCheckOnFailure = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03091 
03092     <span class="keywordflow">do</span> {
03093         <a class="code" href="../../d1/d6/allocpag_8c.html#a17">MiSpecialPoolFirstPte</a> = <a class="code" href="../../d0/d9/sysptes_8c.html#a25">MiReserveSystemPtes</a> (<a class="code" href="../../d1/d6/allocpag_8c.html#a26">MiSpecialPoolPtes</a>,
03094                                                      <a class="code" href="../../d4/d8/mi_8h.html#a1003a769">SystemPteSpace</a>,
03095                                                      0,
03096                                                      0,
03097                                                      BugCheckOnFailure);
03098         <span class="keywordflow">if</span> (<a class="code" href="../../d1/d6/allocpag_8c.html#a17">MiSpecialPoolFirstPte</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03099             <span class="keywordflow">break</span>;
03100         }
03101 
03102         <span class="keywordflow">if</span> (<a class="code" href="../../d1/d6/allocpag_8c.html#a26">MiSpecialPoolPtes</a> == 0) {
03103             BugCheckOnFailure = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03104             <span class="keywordflow">continue</span>;
03105         }
03106 
03107         <a class="code" href="../../d1/d6/allocpag_8c.html#a26">MiSpecialPoolPtes</a> -= 2;
03108     } <span class="keywordflow">while</span> (1);
03109 
03110     <span class="comment">//</span>
03111     <span class="comment">// Build the list of PTE pairs.</span>
03112     <span class="comment">//</span>
03113 
03114     <a class="code" href="../../d1/d6/allocpag_8c.html#a18">MiSpecialPoolLastPte</a> = <a class="code" href="../../d1/d6/allocpag_8c.html#a17">MiSpecialPoolFirstPte</a> + <a class="code" href="../../d1/d6/allocpag_8c.html#a26">MiSpecialPoolPtes</a>;
03115     <a class="code" href="../../d2/d1/mm_8h.html#a160">MmSpecialPoolStart</a> = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a> (<a class="code" href="../../d1/d6/allocpag_8c.html#a17">MiSpecialPoolFirstPte</a>);
03116 
03117     PointerPte = <a class="code" href="../../d1/d6/allocpag_8c.html#a17">MiSpecialPoolFirstPte</a>;
03118     <span class="keywordflow">while</span> (PointerPte &lt; <a class="code" href="../../d1/d6/allocpag_8c.html#a18">MiSpecialPoolLastPte</a>) {
03119         PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.List.NextEntry = ((PointerPte + 2) - <a class="code" href="../../d4/d8/mi_8h.html#a671">MmSystemPteBase</a>);
03120         PointerPte += 2;
03121     }
03122     PointerPte -= 2;
03123     PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.List.NextEntry = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a1">MM_EMPTY_PTE_LIST</a>;
03124     <a class="code" href="../../d1/d6/allocpag_8c.html#a18">MiSpecialPoolLastPte</a> = PointerPte;
03125     <a class="code" href="../../d2/d1/mm_8h.html#a161">MmSpecialPoolEnd</a> = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a> (<a class="code" href="../../d1/d6/allocpag_8c.html#a18">MiSpecialPoolLastPte</a> + 1);
03126 
03127     <span class="comment">//</span>
03128     <span class="comment">// Cap nonpaged special pool based on the memory size.</span>
03129     <span class="comment">//</span>
03130 
03131     <a class="code" href="../../d1/d6/allocpag_8c.html#a25">MiSpecialPagesNonPagedMaximum</a> = (ULONG)(<a class="code" href="../../d8/d5/kddata_8c.html#a42">MmResidentAvailablePages</a> &gt;&gt; 4);
03132 
03133     <span class="keywordflow">if</span> (<a class="code" href="../../d2/d1/mm_8h.html#a136">MmNumberOfPhysicalPages</a> &gt; 0x3FFF) {
03134         <a class="code" href="../../d1/d6/allocpag_8c.html#a25">MiSpecialPagesNonPagedMaximum</a> = (ULONG)(<a class="code" href="../../d8/d5/kddata_8c.html#a42">MmResidentAvailablePages</a> &gt;&gt; 3);
03135     }
03136 
03137     <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
03138 }
03139 
03140 LOGICAL
<a name="l03141"></a><a class="code" href="../../d2/d1/mm_8h.html#a321">03141</a> <a class="code" href="../../d1/d6/allocpag_8c.html#a39">MmSetSpecialPool</a> (
03142     IN LOGICAL Enable
03143     )
03144 
03145 <span class="comment">/*++</span>
03146 <span class="comment"></span>
03147 <span class="comment">Routine Description:</span>
03148 <span class="comment"></span>
03149 <span class="comment">    This routine enables/disables special pool.  This allows callers to ensure</span>
03150 <span class="comment">    that subsequent allocations do not come from special pool.  It is relied</span>
03151 <span class="comment">    upon by callers that require KSEG0 addresses.</span>
03152 <span class="comment"></span>
03153 <span class="comment">Arguments:</span>
03154 <span class="comment"></span>
03155 <span class="comment">    Enable - Supplies TRUE to enable special pool, FALSE to disable it.</span>
03156 <span class="comment"></span>
03157 <span class="comment">Return Value:</span>
03158 <span class="comment"></span>
03159 <span class="comment">    Current special pool state (enabled or disabled).</span>
03160 <span class="comment"></span>
03161 <span class="comment">Environment:</span>
03162 <span class="comment"></span>
03163 <span class="comment">    Kernel mode, IRQL of DISPATCH_LEVEL or below.</span>
03164 <span class="comment"></span>
03165 <span class="comment">--*/</span>
03166 
03167 {
03168     KIRQL OldIrql;
03169     LOGICAL OldEnable;
03170 
03171     <a class="code" href="../../d4/d8/mi_8h.html#a130">LOCK_PFN2</a> (OldIrql);
03172 
03173     OldEnable = <a class="code" href="../../d1/d6/allocpag_8c.html#a27">MiSpecialPoolEnabled</a>;
03174 
03175     <a class="code" href="../../d1/d6/allocpag_8c.html#a27">MiSpecialPoolEnabled</a> = Enable;
03176 
03177     <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrql);
03178 
03179     <span class="keywordflow">return</span> OldEnable;
03180 }
03181 
03182 <span class="preprocessor">#ifndef NO_POOL_CHECKS</span>
<a name="l03183"></a><a class="code" href="../../d0/d9/struct__MI__BAD__TAGS.html">03183</a> <span class="preprocessor"></span><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d0/d9/struct__MI__BAD__TAGS.html">_MI_BAD_TAGS</a> {
<a name="l03184"></a><a class="code" href="../../d0/d9/struct__MI__BAD__TAGS.html#o0">03184</a>     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>  <a class="code" href="../../d0/d9/struct__MI__BAD__TAGS.html#o0">Enabled</a>;
<a name="l03185"></a><a class="code" href="../../d0/d9/struct__MI__BAD__TAGS.html#o1">03185</a>     UCHAR   <a class="code" href="../../d0/d9/struct__MI__BAD__TAGS.html#o1">TargetChar</a>;
<a name="l03186"></a><a class="code" href="../../d0/d9/struct__MI__BAD__TAGS.html#o2">03186</a>     UCHAR   <a class="code" href="../../d0/d9/struct__MI__BAD__TAGS.html#o2">AllOthers</a>;
<a name="l03187"></a><a class="code" href="../../d0/d9/struct__MI__BAD__TAGS.html#o3">03187</a>     ULONG   <a class="code" href="../../d0/d9/struct__MI__BAD__TAGS.html#o3">Dispatches</a>;
<a name="l03188"></a><a class="code" href="../../d0/d9/struct__MI__BAD__TAGS.html#o4">03188</a>     ULONG   <a class="code" href="../../d0/d9/struct__MI__BAD__TAGS.html#o4">Allocations</a>;
<a name="l03189"></a><a class="code" href="../../d0/d9/struct__MI__BAD__TAGS.html#o5">03189</a>     ULONG   <a class="code" href="../../d0/d9/struct__MI__BAD__TAGS.html#o5">RandomizerEnabled</a>;
03190 } <a class="code" href="../../d0/d9/struct__MI__BAD__TAGS.html">MI_BAD_TAGS</a>, *<a class="code" href="../../d0/d9/struct__MI__BAD__TAGS.html">PMI_BAD_TAGS</a>;
03191 
<a name="l03192"></a><a class="code" href="../../d1/d6/allocpag_8c.html#a30">03192</a> <a class="code" href="../../d0/d9/struct__MI__BAD__TAGS.html">MI_BAD_TAGS</a> <a class="code" href="../../d1/d6/allocpag_8c.html#a30">MiBadTags</a>;
<a name="l03193"></a><a class="code" href="../../d1/d6/allocpag_8c.html#a31">03193</a> <a class="code" href="../../d3/d8/struct__KTIMER.html">KTIMER</a> <a class="code" href="../../d1/d6/allocpag_8c.html#a31">MiSpecialPoolTimer</a>;
<a name="l03194"></a><a class="code" href="../../d1/d6/allocpag_8c.html#a32">03194</a> <a class="code" href="../../d1/d6/struct__KDPC.html">KDPC</a> <a class="code" href="../../d1/d6/allocpag_8c.html#a32">MiSpecialPoolTimerDpc</a>;
<a name="l03195"></a><a class="code" href="../../d1/d6/allocpag_8c.html#a33">03195</a> LARGE_INTEGER <a class="code" href="../../d1/d6/allocpag_8c.html#a33">MiTimerDueTime</a>;
03196 
<a name="l03197"></a><a class="code" href="../../d1/d6/allocpag_8c.html#a2">03197</a> <span class="preprocessor">#define MI_THREE_SECONDS     3</span>
03198 <span class="preprocessor"></span>
03199 
03200 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l03201"></a><a class="code" href="../../d1/d6/allocpag_8c.html#a37">03201</a> <a class="code" href="../../d1/d6/allocpag_8c.html#a37">MiSpecialPoolTimerDispatch</a> (
03202     IN <a class="code" href="../../d1/d6/struct__KDPC.html">PKDPC</a> Dpc,
03203     IN PVOID DeferredContext,
03204     IN PVOID SystemArgument1,
03205     IN PVOID SystemArgument2
03206     )
03207 
03208 <span class="comment">/*++</span>
03209 <span class="comment"></span>
03210 <span class="comment">Routine Description:</span>
03211 <span class="comment"></span>
03212 <span class="comment">    This routine is executed every 3 seconds.  Just toggle the enable bit.</span>
03213 <span class="comment">    If not many squeezed allocations have been made then just leave it</span>
03214 <span class="comment">    continuously enabled.  Switch to a different tag if it looks like this</span>
03215 <span class="comment">    one isn't getting any hits.</span>
03216 <span class="comment"></span>
03217 <span class="comment">    No locks needed.</span>
03218 <span class="comment"></span>
03219 <span class="comment">Arguments:</span>
03220 <span class="comment"></span>
03221 <span class="comment">    Dpc - Supplies a pointer to a control object of type DPC.</span>
03222 <span class="comment"></span>
03223 <span class="comment">    DeferredContext - Optional deferred context;  not used.</span>
03224 <span class="comment"></span>
03225 <span class="comment">    SystemArgument1 - Optional argument 1;  not used.</span>
03226 <span class="comment"></span>
03227 <span class="comment">    SystemArgument2 - Optional argument 2;  not used.</span>
03228 <span class="comment"></span>
03229 <span class="comment">Return Value:</span>
03230 <span class="comment"></span>
03231 <span class="comment">    None.</span>
03232 <span class="comment"></span>
03233 <span class="comment">--*/</span>
03234 
03235 {
03236     UCHAR NewChar;
03237 
03238     UNREFERENCED_PARAMETER (Dpc);
03239     UNREFERENCED_PARAMETER (DeferredContext);
03240     UNREFERENCED_PARAMETER (SystemArgument1);
03241     UNREFERENCED_PARAMETER (SystemArgument2);
03242 
03243     <a class="code" href="../../d1/d6/allocpag_8c.html#a30">MiBadTags</a>.<a class="code" href="../../d0/d9/struct__MI__BAD__TAGS.html#o3">Dispatches</a> += 1;
03244 
03245     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d6/allocpag_8c.html#a30">MiBadTags</a>.<a class="code" href="../../d0/d9/struct__MI__BAD__TAGS.html#o4">Allocations</a> &gt; 500) {
03246         <a class="code" href="../../d1/d6/allocpag_8c.html#a30">MiBadTags</a>.<a class="code" href="../../d0/d9/struct__MI__BAD__TAGS.html#o0">Enabled</a> += 1;
03247     }
03248     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((<a class="code" href="../../d1/d6/allocpag_8c.html#a30">MiBadTags</a>.<a class="code" href="../../d0/d9/struct__MI__BAD__TAGS.html#o4">Allocations</a> == 0) &amp;&amp; (<a class="code" href="../../d1/d6/allocpag_8c.html#a30">MiBadTags</a>.<a class="code" href="../../d0/d9/struct__MI__BAD__TAGS.html#o3">Dispatches</a> &gt; 100)) {
03249         <span class="keywordflow">if</span> (<a class="code" href="../../d1/d6/allocpag_8c.html#a30">MiBadTags</a>.<a class="code" href="../../d0/d9/struct__MI__BAD__TAGS.html#o2">AllOthers</a> == 0) {
03250             NewChar = (UCHAR)(<a class="code" href="../../d1/d6/allocpag_8c.html#a30">MiBadTags</a>.<a class="code" href="../../d0/d9/struct__MI__BAD__TAGS.html#o1">TargetChar</a> + 1);
03251             <span class="keywordflow">if</span> (NewChar &gt;= <span class="charliteral">'a'</span> &amp;&amp; NewChar &lt;= <span class="charliteral">'z'</span>) {
03252                 <a class="code" href="../../d1/d6/allocpag_8c.html#a30">MiBadTags</a>.<a class="code" href="../../d0/d9/struct__MI__BAD__TAGS.html#o1">TargetChar</a> = NewChar;
03253             }
03254             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (NewChar == <span class="charliteral">'z'</span> + 1) {
03255                 <a class="code" href="../../d1/d6/allocpag_8c.html#a30">MiBadTags</a>.<a class="code" href="../../d0/d9/struct__MI__BAD__TAGS.html#o1">TargetChar</a> = <span class="charliteral">'a'</span>;
03256             }
03257             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (NewChar &gt;= <span class="charliteral">'A'</span> &amp;&amp; NewChar &lt;= <span class="charliteral">'Z'</span>) {
03258                 <a class="code" href="../../d1/d6/allocpag_8c.html#a30">MiBadTags</a>.<a class="code" href="../../d0/d9/struct__MI__BAD__TAGS.html#o1">TargetChar</a> = NewChar;
03259             }
03260             <span class="keywordflow">else</span> {
03261                 <a class="code" href="../../d1/d6/allocpag_8c.html#a30">MiBadTags</a>.<a class="code" href="../../d0/d9/struct__MI__BAD__TAGS.html#o1">TargetChar</a> = <span class="charliteral">'A'</span>;
03262             }
03263         }
03264     }
03265 }
03266 
<a name="l03267"></a><a class="code" href="../../d1/d6/allocpag_8c.html#a34">03267</a> <span class="keyword">extern</span> ULONG <a class="code" href="../../d8/d1/init_8h.html#a21">InitializationPhase</a>;
03268 
03269 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l03270"></a><a class="code" href="../../d1/d6/allocpag_8c.html#a58">03270</a> <a class="code" href="../../d5/d1/mminit_8c.html#a50">MiInitializeSpecialPoolCriteria</a> (
03271     VOID
03272     )
03273 {
03274     LARGE_INTEGER SystemTime;
03275     TIME_FIELDS <a class="code" href="../../d6/d6/ttime_8c.html#a13">TimeFields</a>;
03276 
03277     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d1/init_8h.html#a21">InitializationPhase</a> == 0) {
03278 <span class="preprocessor">#if defined (_MI_SPECIAL_POOL_BY_DEFAULT)</span>
03279 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (<a class="code" href="../../d2/d1/mm_8h.html#a159">MmSpecialPoolTag</a> == 0) {
03280             <a class="code" href="../../d2/d1/mm_8h.html#a159">MmSpecialPoolTag</a> = (ULONG)-2;
03281         }
03282 <span class="preprocessor">#endif</span>
03283 <span class="preprocessor"></span>        <span class="keywordflow">return</span>;
03284     }
03285 
03286     <span class="keywordflow">if</span> (<a class="code" href="../../d2/d1/mm_8h.html#a159">MmSpecialPoolTag</a> != (ULONG)-2) {
03287         <span class="keywordflow">return</span>;
03288     }
03289 
03290     <a class="code" href="../../d7/d0/ke_2miscc_8c.html#a3">KeQuerySystemTime</a> (&amp;SystemTime);
03291 
03292     <a class="code" href="../../d1/d2/time_8c.html#a26">RtlTimeToTimeFields</a> (&amp;SystemTime, &amp;<a class="code" href="../../d6/d6/ttime_8c.html#a13">TimeFields</a>);
03293 
03294     <span class="keywordflow">if</span> (<a class="code" href="../../d6/d6/ttime_8c.html#a13">TimeFields</a>.Second &lt;= 25) {
03295         <a class="code" href="../../d1/d6/allocpag_8c.html#a30">MiBadTags</a>.<a class="code" href="../../d0/d9/struct__MI__BAD__TAGS.html#o1">TargetChar</a> = (UCHAR)(<span class="charliteral">'a'</span> + (UCHAR)<a class="code" href="../../d6/d6/ttime_8c.html#a13">TimeFields</a>.Second);
03296     }
03297     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="../../d6/d6/ttime_8c.html#a13">TimeFields</a>.Second &lt;= 51) {
03298         <a class="code" href="../../d1/d6/allocpag_8c.html#a30">MiBadTags</a>.<a class="code" href="../../d0/d9/struct__MI__BAD__TAGS.html#o1">TargetChar</a> = (UCHAR)(<span class="charliteral">'A'</span> + (UCHAR)(<a class="code" href="../../d6/d6/ttime_8c.html#a13">TimeFields</a>.Second - 26));
03299     }
03300     <span class="keywordflow">else</span> {
03301         <a class="code" href="../../d1/d6/allocpag_8c.html#a30">MiBadTags</a>.<a class="code" href="../../d0/d9/struct__MI__BAD__TAGS.html#o2">AllOthers</a> = 1;
03302     }
03303 
03304     <a class="code" href="../../d1/d6/allocpag_8c.html#a30">MiBadTags</a>.<a class="code" href="../../d0/d9/struct__MI__BAD__TAGS.html#o5">RandomizerEnabled</a> = 1;
03305 
03306     <span class="comment">//</span>
03307     <span class="comment">// Initialize a periodic timer to go off every three seconds.</span>
03308     <span class="comment">//</span>
03309 
03310     <a class="code" href="../../d4/d1/dpcobj_8c.html#a1">KeInitializeDpc</a> (&amp;<a class="code" href="../../d1/d6/allocpag_8c.html#a32">MiSpecialPoolTimerDpc</a>, <a class="code" href="../../d1/d6/allocpag_8c.html#a37">MiSpecialPoolTimerDispatch</a>, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
03311 
03312     <a class="code" href="../../d3/d2/timerobj_8c.html#a1">KeInitializeTimer</a> (&amp;<a class="code" href="../../d1/d6/allocpag_8c.html#a31">MiSpecialPoolTimer</a>);
03313 
03314     <a class="code" href="../../d1/d6/allocpag_8c.html#a33">MiTimerDueTime</a>.QuadPart = Int32x32To64 (<a class="code" href="../../d1/d6/allocpag_8c.html#a2">MI_THREE_SECONDS</a>, -10000000);
03315 
03316     <a class="code" href="../../d3/d2/timerobj_8c.html#a7">KeSetTimerEx</a> (&amp;<a class="code" href="../../d1/d6/allocpag_8c.html#a31">MiSpecialPoolTimer</a>,
03317                   <a class="code" href="../../d1/d6/allocpag_8c.html#a33">MiTimerDueTime</a>,
03318                   <a class="code" href="../../d1/d6/allocpag_8c.html#a2">MI_THREE_SECONDS</a> * 1000,
03319                   &amp;<a class="code" href="../../d1/d6/allocpag_8c.html#a32">MiSpecialPoolTimerDpc</a>);
03320 
03321     <a class="code" href="../../d1/d6/allocpag_8c.html#a30">MiBadTags</a>.<a class="code" href="../../d0/d9/struct__MI__BAD__TAGS.html#o0">Enabled</a> += 1;
03322 }
03323 
03324 PVOID
<a name="l03325"></a><a class="code" href="../../d2/d2/ex_2pool_8c.html#a62">03325</a> <a class="code" href="../../d1/d6/allocpag_8c.html#a38">MmSqueezeBadTags</a> (
03326     IN SIZE_T NumberOfBytes,
03327     IN ULONG Tag,
03328     IN POOL_TYPE PoolType,
03329     IN ULONG SpecialPoolType
03330     )
03331 
03332 <span class="comment">/*++</span>
03333 <span class="comment"></span>
03334 <span class="comment">Routine Description:</span>
03335 <span class="comment"></span>
03336 <span class="comment">    This routine squeezes bad tags by forcing them into special pool in a</span>
03337 <span class="comment">    systematic fashion.</span>
03338 <span class="comment"></span>
03339 <span class="comment">Arguments:</span>
03340 <span class="comment"></span>
03341 <span class="comment">    NumberOfBytes - Supplies the number of bytes to commit.</span>
03342 <span class="comment"></span>
03343 <span class="comment">    Tag - Supplies the tag of the requested allocation.</span>
03344 <span class="comment"></span>
03345 <span class="comment">    PoolType - Supplies the pool type of the requested allocation.</span>
03346 <span class="comment"></span>
03347 <span class="comment">    SpecialPoolType - Supplies the special pool type of the</span>
03348 <span class="comment">                      requested allocation.</span>
03349 <span class="comment"></span>
03350 <span class="comment">                      - 0 indicates overruns.</span>
03351 <span class="comment">                      - 1 indicates underruns.</span>
03352 <span class="comment">                      - 2 indicates use the systemwide pool policy.</span>
03353 <span class="comment"></span>
03354 <span class="comment">Return Value:</span>
03355 <span class="comment"></span>
03356 <span class="comment">    A non-NULL pointer if the requested allocation was fulfilled from special</span>
03357 <span class="comment">    pool.  NULL if the allocation was not made.</span>
03358 <span class="comment"></span>
03359 <span class="comment">Environment:</span>
03360 <span class="comment"></span>
03361 <span class="comment">    Kernel mode, no locks (not even pool locks) held.</span>
03362 <span class="comment"></span>
03363 <span class="comment">--*/</span>
03364 
03365 {
03366     PUCHAR tc;
03367 
03368     <span class="keywordflow">if</span> ((<a class="code" href="../../d1/d6/allocpag_8c.html#a30">MiBadTags</a>.<a class="code" href="../../d0/d9/struct__MI__BAD__TAGS.html#o0">Enabled</a> % 0x10) == 0) {
03369         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03370     }
03371 
03372     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d6/allocpag_8c.html#a30">MiBadTags</a>.<a class="code" href="../../d0/d9/struct__MI__BAD__TAGS.html#o5">RandomizerEnabled</a> == 0) {
03373         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03374     }
03375 
03376     tc = (PUCHAR)&amp;Tag;
03377     <span class="keywordflow">if</span> (*tc == <a class="code" href="../../d1/d6/allocpag_8c.html#a30">MiBadTags</a>.<a class="code" href="../../d0/d9/struct__MI__BAD__TAGS.html#o1">TargetChar</a>) {
03378         ;
03379     }
03380     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="../../d1/d6/allocpag_8c.html#a30">MiBadTags</a>.<a class="code" href="../../d0/d9/struct__MI__BAD__TAGS.html#o2">AllOthers</a> == 1) {
03381         <span class="keywordflow">if</span> (*tc &gt;= <span class="charliteral">'a'</span> &amp;&amp; *tc &lt;= <span class="charliteral">'z'</span>) {
03382             <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03383         }
03384         <span class="keywordflow">if</span> (*tc &gt;= <span class="charliteral">'A'</span> &amp;&amp; *tc &lt;= <span class="charliteral">'Z'</span>) {
03385             <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03386         }
03387     }
03388     <span class="keywordflow">else</span> {
03389         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03390     }
03391 
03392     <a class="code" href="../../d1/d6/allocpag_8c.html#a30">MiBadTags</a>.<a class="code" href="../../d0/d9/struct__MI__BAD__TAGS.html#o4">Allocations</a> += 1;
03393 
03394     <span class="keywordflow">return</span> <a class="code" href="../../d1/d6/allocpag_8c.html#a60">MmAllocateSpecialPool</a>(NumberOfBytes, Tag, PoolType, SpecialPoolType);
03395 }
03396 
03397 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l03398"></a><a class="code" href="../../d4/d8/mi_8h.html#a956">03398</a> <a class="code" href="../../d4/d8/mi_8h.html#a956">MiEnableRandomSpecialPool</a> (
03399     IN LOGICAL Enable
03400     )
03401 {
03402     <a class="code" href="../../d1/d6/allocpag_8c.html#a30">MiBadTags</a>.<a class="code" href="../../d0/d9/struct__MI__BAD__TAGS.html#o5">RandomizerEnabled</a> = Enable;
03403 }
03404 
03405 <span class="preprocessor">#endif</span>
03406 <span class="preprocessor"></span>
03407 PVOID
<a name="l03408"></a><a class="code" href="../../d1/d6/allocpag_8c.html#a60">03408</a> <a class="code" href="../../d1/d6/allocpag_8c.html#a60">MmAllocateSpecialPool</a> (
03409     IN SIZE_T NumberOfBytes,
03410     IN ULONG Tag,
03411     IN POOL_TYPE PoolType,
03412     IN ULONG SpecialPoolType
03413     )
03414 
03415 <span class="comment">/*++</span>
03416 <span class="comment"></span>
03417 <span class="comment">Routine Description:</span>
03418 <span class="comment"></span>
03419 <span class="comment">    This routine allocates virtual memory from special pool.  This allocation</span>
03420 <span class="comment">    is made from the end of a physical page with the next PTE set to no access</span>
03421 <span class="comment">    so that any reads or writes will cause an immediate fatal system crash.</span>
03422 <span class="comment">    </span>
03423 <span class="comment">    This lets us catch components that corrupt pool.</span>
03424 <span class="comment"></span>
03425 <span class="comment">Arguments:</span>
03426 <span class="comment"></span>
03427 <span class="comment">    NumberOfBytes - Supplies the number of bytes to commit.</span>
03428 <span class="comment"></span>
03429 <span class="comment">    Tag - Supplies the tag of the requested allocation.</span>
03430 <span class="comment"></span>
03431 <span class="comment">    PoolType - Supplies the pool type of the requested allocation.</span>
03432 <span class="comment"></span>
03433 <span class="comment">    SpecialPoolType - Supplies the special pool type of the</span>
03434 <span class="comment">                      requested allocation.</span>
03435 <span class="comment"></span>
03436 <span class="comment">                      - 0 indicates overruns.</span>
03437 <span class="comment">                      - 1 indicates underruns.</span>
03438 <span class="comment">                      - 2 indicates use the systemwide pool policy.</span>
03439 <span class="comment"></span>
03440 <span class="comment">Return Value:</span>
03441 <span class="comment"></span>
03442 <span class="comment">    A non-NULL pointer if the requested allocation was fulfilled from special</span>
03443 <span class="comment">    pool.  NULL if the allocation was not made.</span>
03444 <span class="comment"></span>
03445 <span class="comment">Environment:</span>
03446 <span class="comment"></span>
03447 <span class="comment">    Kernel mode, no pool locks held.</span>
03448 <span class="comment"></span>
03449 <span class="comment">    Note this is a nonpagable wrapper so that machines without special pool</span>
03450 <span class="comment">    can still support drivers allocating nonpaged pool at DISPATCH_LEVEL</span>
03451 <span class="comment">    requesting special pool.</span>
03452 <span class="comment"></span>
03453 <span class="comment">--*/</span>
03454 
03455 {
03456     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d6/allocpag_8c.html#a26">MiSpecialPoolPtes</a> == 0) {
03457 
03458         <span class="comment">//</span>
03459         <span class="comment">// The special pool allocation code was never initialized.</span>
03460         <span class="comment">//</span>
03461 
03462         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03463     }
03464 
03465     <span class="keywordflow">return</span> <a class="code" href="../../d1/d6/allocpag_8c.html#a40">MiAllocateSpecialPool</a> (NumberOfBytes,
03466                                   Tag,
03467                                   PoolType,
03468                                   SpecialPoolType);
03469 }
03470 
03471 PVOID
<a name="l03472"></a><a class="code" href="../../d1/d6/allocpag_8c.html#a40">03472</a> <a class="code" href="../../d1/d6/allocpag_8c.html#a40">MiAllocateSpecialPool</a> (
03473     IN SIZE_T NumberOfBytes,
03474     IN ULONG Tag,
03475     IN POOL_TYPE PoolType,
03476     IN ULONG SpecialPoolType
03477     )
03478 
03479 <span class="comment">/*++</span>
03480 <span class="comment"></span>
03481 <span class="comment">Routine Description:</span>
03482 <span class="comment"></span>
03483 <span class="comment">    This routine allocates virtual memory from special pool.  This allocation</span>
03484 <span class="comment">    is made from the end of a physical page with the next PTE set to no access</span>
03485 <span class="comment">    so that any reads or writes will cause an immediate fatal system crash.</span>
03486 <span class="comment">    </span>
03487 <span class="comment">    This lets us catch components that corrupt pool.</span>
03488 <span class="comment"></span>
03489 <span class="comment">Arguments:</span>
03490 <span class="comment"></span>
03491 <span class="comment">    NumberOfBytes - Supplies the number of bytes to commit.</span>
03492 <span class="comment"></span>
03493 <span class="comment">    Tag - Supplies the tag of the requested allocation.</span>
03494 <span class="comment"></span>
03495 <span class="comment">    PoolType - Supplies the pool type of the requested allocation.</span>
03496 <span class="comment"></span>
03497 <span class="comment">    SpecialPoolType - Supplies the special pool type of the</span>
03498 <span class="comment">                      requested allocation.</span>
03499 <span class="comment"></span>
03500 <span class="comment">                      - 0 indicates overruns.</span>
03501 <span class="comment">                      - 1 indicates underruns.</span>
03502 <span class="comment">                      - 2 indicates use the systemwide pool policy.</span>
03503 <span class="comment"></span>
03504 <span class="comment">Return Value:</span>
03505 <span class="comment"></span>
03506 <span class="comment">    A non-NULL pointer if the requested allocation was fulfilled from special</span>
03507 <span class="comment">    pool.  NULL if the allocation was not made.</span>
03508 <span class="comment"></span>
03509 <span class="comment">Environment:</span>
03510 <span class="comment"></span>
03511 <span class="comment">    Kernel mode, no locks (not even pool locks) held.</span>
03512 <span class="comment"></span>
03513 <span class="comment">--*/</span>
03514 
03515 {
03516     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> TempPte;
03517     PFN_NUMBER PageFrameIndex;
03518     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
03519     KIRQL OldIrql;
03520     PVOID Entry;
03521     <a class="code" href="../../d5/d8/struct__POOL__HEADER.html">PPOOL_HEADER</a> <a class="code" href="../../d3/d3/dumpuser_8c.html#a17">Header</a>;
03522     LARGE_INTEGER CurrentTime;
03523     LOGICAL CatchOverruns;
03524 
03525     <span class="keywordflow">if</span> ((PoolType &amp; <a class="code" href="../../d4/d2/pool_8h.html#a5">BASE_POOL_TYPE_MASK</a>) == <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>) {
03526 
03527         <span class="keywordflow">if</span> (KeGetCurrentIrql() &gt; <a class="code" href="../../d6/d7/halmips_8h.html#a52">APC_LEVEL</a>) {
03528 
03529             <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a> (SPECIAL_POOL_DETECTED_MEMORY_CORRUPTION,
03530                           KeGetCurrentIrql(),
03531                           PoolType,
03532                           NumberOfBytes,
03533                           0x30);
03534         }
03535     }
03536     <span class="keywordflow">else</span> {
03537         <span class="keywordflow">if</span> (KeGetCurrentIrql() &gt; <a class="code" href="../../d6/d7/halmips_8h.html#a53">DISPATCH_LEVEL</a>) {
03538 
03539             <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a> (SPECIAL_POOL_DETECTED_MEMORY_CORRUPTION,
03540                           KeGetCurrentIrql(),
03541                           PoolType,
03542                           NumberOfBytes,
03543                           0x30);
03544         }
03545     }
03546 
03547 <span class="preprocessor">#if defined (_X86_) &amp;&amp; !defined (_X86PAE_)</span>
03548 <span class="preprocessor"></span>
03549     <span class="keywordflow">if</span> (<a class="code" href="../../d2/d2/data386_8c.html#a27">MiNumberOfExtraSystemPdes</a> != 0) {
03550 
03551         <span class="keyword">extern</span> ULONG <a class="code" href="../../d0/d8/creasect_8c.html#a8">MMSECT</a>;
03552 
03553         <span class="comment">//</span>
03554         <span class="comment">// Prototype PTEs cannot come from lower special pool because</span>
03555         <span class="comment">// their address is encoded into PTEs and the encoding only covers</span>
03556         <span class="comment">// a max of 1GB from the start of paged pool.  Likewise fork</span>
03557         <span class="comment">// prototype PTEs.</span>
03558         <span class="comment">//</span>
03559 
03560         <span class="keywordflow">if</span> (Tag == <a class="code" href="../../d0/d8/creasect_8c.html#a8">MMSECT</a> || Tag == 'lCmM') {
03561             <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03562         }
03563     }
03564 
03565 <span class="preprocessor">#endif</span>
03566 <span class="preprocessor"></span>
03567 <span class="preprocessor">#if !defined (_WIN64) &amp;&amp; !defined (_X86PAE_)</span>
03568 <span class="preprocessor"></span>
03569     <span class="keywordflow">if</span> (Tag == 'bSmM' || Tag == 'iCmM' || Tag == 'aCmM') {
03570 
03571         <span class="comment">//</span>
03572         <span class="comment">// Mm subsections cannot come from this special pool because they</span>
03573         <span class="comment">// get encoded into PTEs - they must come from normal nonpaged pool.</span>
03574         <span class="comment">//</span>
03575 
03576         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03577     }
03578 
03579 <span class="preprocessor">#endif</span>
03580 <span class="preprocessor"></span>
03581     TempPte = <a class="code" href="../../d4/d2/datalpha_8c.html#a2">ValidKernelPte</a>;
03582 
03583     <a class="code" href="../../d4/d8/mi_8h.html#a130">LOCK_PFN2</a> (OldIrql);
03584 
03585     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d6/allocpag_8c.html#a27">MiSpecialPoolEnabled</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
03586 
03587         <span class="comment">//</span>
03588         <span class="comment">// The special pool allocation code is currently disabled.</span>
03589         <span class="comment">//</span>
03590 
03591         <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrql);
03592         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03593     }
03594 
03595     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a94">MmAvailablePages</a> &lt; 200) {
03596         <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrql);
03597         <a class="code" href="../../d1/d6/allocpag_8c.html#a15">MmSpecialPoolRejected</a>[0] += 1;
03598         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03599     }
03600 
03601     <span class="comment">//</span>
03602     <span class="comment">// Don't get too aggressive until a paging file gets set up.</span>
03603     <span class="comment">//</span>
03604 
03605     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d5/kddata_8c.html#a17">MmNumberOfPagingFiles</a> == 0 &amp;&amp; <a class="code" href="../../d1/d6/allocpag_8c.html#a21">MmSpecialPagesInUse</a> &gt; <a class="code" href="../../d5/d5/cc_8h.html#a94">MmAvailablePages</a> / 2) {
03606         <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrql);
03607         <a class="code" href="../../d1/d6/allocpag_8c.html#a15">MmSpecialPoolRejected</a>[3] += 1;
03608         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03609     }
03610 
03611     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d6/allocpag_8c.html#a17">MiSpecialPoolFirstPte</a>-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.List.NextEntry == <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a1">MM_EMPTY_PTE_LIST</a>) {
03612         <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrql);
03613         <a class="code" href="../../d1/d6/allocpag_8c.html#a15">MmSpecialPoolRejected</a>[2] += 1;
03614         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03615     }
03616 
03617     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d5/kddata_8c.html#a42">MmResidentAvailablePages</a> &lt; 100) {
03618         <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrql);
03619         <a class="code" href="../../d1/d6/allocpag_8c.html#a15">MmSpecialPoolRejected</a>[4] += 1;
03620         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03621     }
03622 
03623     <span class="comment">//</span>
03624     <span class="comment">// Cap nonpaged allocations to prevent runaways.</span>
03625     <span class="comment">//</span>
03626 
03627     <span class="keywordflow">if</span> ((PoolType &amp; <a class="code" href="../../d4/d2/pool_8h.html#a5">BASE_POOL_TYPE_MASK</a>) == <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>) {
03628 
03629         <span class="keywordflow">if</span> (<a class="code" href="../../d1/d6/allocpag_8c.html#a19">MiSpecialPagesNonPaged</a> &gt; <a class="code" href="../../d1/d6/allocpag_8c.html#a25">MiSpecialPagesNonPagedMaximum</a>) {
03630             <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrql);
03631             <a class="code" href="../../d1/d6/allocpag_8c.html#a15">MmSpecialPoolRejected</a>[1] += 1;
03632             <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03633         }
03634 
03635         <a class="code" href="../../d8/d5/kddata_8c.html#a42">MmResidentAvailablePages</a> -= 1;
03636 
03637         <a class="code" href="../../d4/d8/mi_8h.html#a322">MM_BUMP_COUNTER</a>(31, 1);
03638 
03639         <a class="code" href="../../d1/d6/allocpag_8c.html#a19">MiSpecialPagesNonPaged</a> += 1;
03640         <span class="keywordflow">if</span> (<a class="code" href="../../d1/d6/allocpag_8c.html#a19">MiSpecialPagesNonPaged</a> &gt; <a class="code" href="../../d1/d6/allocpag_8c.html#a22">MiSpecialPagesNonPagedPeak</a>) {
03641             <a class="code" href="../../d1/d6/allocpag_8c.html#a22">MiSpecialPagesNonPagedPeak</a> = <a class="code" href="../../d1/d6/allocpag_8c.html#a19">MiSpecialPagesNonPaged</a>;
03642         }
03643     }
03644     <span class="keywordflow">else</span> {
03645         <a class="code" href="../../d1/d6/allocpag_8c.html#a20">MiSpecialPagesPagable</a> += 1;
03646         <span class="keywordflow">if</span> (<a class="code" href="../../d1/d6/allocpag_8c.html#a20">MiSpecialPagesPagable</a> &gt; <a class="code" href="../../d1/d6/allocpag_8c.html#a23">MiSpecialPagesPagablePeak</a>) {
03647             <a class="code" href="../../d1/d6/allocpag_8c.html#a23">MiSpecialPagesPagablePeak</a> = <a class="code" href="../../d1/d6/allocpag_8c.html#a20">MiSpecialPagesPagable</a>;
03648         }
03649     }
03650 
03651     PointerPte = <a class="code" href="../../d1/d6/allocpag_8c.html#a17">MiSpecialPoolFirstPte</a>;
03652 
03653     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (<a class="code" href="../../d1/d6/allocpag_8c.html#a17">MiSpecialPoolFirstPte</a>-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.List.NextEntry != <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a1">MM_EMPTY_PTE_LIST</a>);
03654 
03655     <a class="code" href="../../d1/d6/allocpag_8c.html#a17">MiSpecialPoolFirstPte</a> = PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.List.NextEntry + <a class="code" href="../../d4/d8/mi_8h.html#a671">MmSystemPteBase</a>;
03656 
03657     PageFrameIndex = <a class="code" href="../../d7/d5/pfnlist_8c.html#a15">MiRemoveAnyPage</a> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a124">MI_GET_PAGE_COLOR_FROM_PTE</a> (PointerPte));
03658 
03659     <a class="code" href="../../d1/d6/allocpag_8c.html#a21">MmSpecialPagesInUse</a> += 1;
03660     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d6/allocpag_8c.html#a21">MmSpecialPagesInUse</a> &gt; <a class="code" href="../../d1/d6/allocpag_8c.html#a24">MiSpecialPagesInUsePeak</a>) {
03661         <a class="code" href="../../d1/d6/allocpag_8c.html#a24">MiSpecialPagesInUsePeak</a> = <a class="code" href="../../d1/d6/allocpag_8c.html#a21">MmSpecialPagesInUse</a>;
03662     }
03663 
03664     TempPte.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber = PageFrameIndex;
03665 
03666     <span class="keywordflow">if</span> ((PoolType &amp; <a class="code" href="../../d4/d2/pool_8h.html#a5">BASE_POOL_TYPE_MASK</a>) == <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>) {
03667         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a112">MI_SET_PTE_DIRTY</a> (TempPte);
03668     }
03669 
03670     <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a186">MI_WRITE_VALID_PTE</a> (PointerPte, TempPte);
03671     <a class="code" href="../../d8/d2/pagfault_8c.html#a22">MiInitializePfn</a> (PageFrameIndex, PointerPte, 1);
03672     <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrql);
03673 
03674     <span class="comment">//</span>
03675     <span class="comment">// Fill the page with a random pattern.</span>
03676     <span class="comment">//</span>
03677 
03678     <a class="code" href="../../d7/d0/ke_2miscc_8c.html#a4">KeQueryTickCount</a>(&amp;CurrentTime);
03679 
03680     Entry = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a> (PointerPte);
03681 
03682     RtlFillMemory (Entry, <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>, (UCHAR) CurrentTime.LowPart);
03683 
03684     <span class="keywordflow">if</span> ((PoolType &amp; <a class="code" href="../../d4/d2/pool_8h.html#a5">BASE_POOL_TYPE_MASK</a>) == <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>) {
03685         <a class="code" href="../../d1/d6/allocpag_8c.html#a43">MiMakeSpecialPoolPagable</a> (Entry, PointerPte);
03686         (PointerPte + 1)-&gt;u.Soft.PageFileHigh = <a class="code" href="../../d4/d8/mi_8h.html#a4">MI_SPECIAL_POOL_PTE_PAGABLE</a>;
03687     }
03688     <span class="keywordflow">else</span> {
03689         (PointerPte + 1)-&gt;u.Soft.PageFileHigh = <a class="code" href="../../d4/d8/mi_8h.html#a5">MI_SPECIAL_POOL_PTE_NONPAGABLE</a>;
03690     }
03691 
03692     <span class="keywordflow">if</span> (SpecialPoolType == 0) {
03693         CatchOverruns = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03694     }
03695     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (SpecialPoolType == 1) {
03696         CatchOverruns = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03697     }
03698     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a28">MmSpecialPoolCatchOverruns</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
03699         CatchOverruns = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03700     }
03701     <span class="keywordflow">else</span> {
03702         CatchOverruns = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03703     }
03704 
03705     <span class="keywordflow">if</span> (CatchOverruns == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
03706         <a class="code" href="../../d3/d3/dumpuser_8c.html#a17">Header</a> = (<a class="code" href="../../d5/d8/struct__POOL__HEADER.html">PPOOL_HEADER</a>) Entry;
03707         Entry = (PVOID)(((LONG_PTR)(((PCHAR)Entry + (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - NumberOfBytes)))) &amp; ~((LONG_PTR)<a class="code" href="../../d5/d2/poolhack_8c.html#a6">POOL_OVERHEAD</a> - 1));
03708     }
03709     <span class="keywordflow">else</span> {
03710         <a class="code" href="../../d3/d3/dumpuser_8c.html#a17">Header</a> = (<a class="code" href="../../d5/d8/struct__POOL__HEADER.html">PPOOL_HEADER</a>) ((PCHAR)Entry + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - <a class="code" href="../../d5/d2/poolhack_8c.html#a6">POOL_OVERHEAD</a>);
03711     }
03712 
03713     <span class="comment">//</span>
03714     <span class="comment">// Zero the header and stash any information needed at release time.</span>
03715     <span class="comment">//</span>
03716 
03717     RtlZeroMemory (<a class="code" href="../../d3/d3/dumpuser_8c.html#a17">Header</a>, <a class="code" href="../../d5/d2/poolhack_8c.html#a6">POOL_OVERHEAD</a>);
03718 
03719     <a class="code" href="../../d3/d3/dumpuser_8c.html#a17">Header</a>-&gt;Ulong1 = (ULONG)NumberOfBytes;
03720 
03721     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (NumberOfBytes &lt;= <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - <a class="code" href="../../d5/d2/poolhack_8c.html#a6">POOL_OVERHEAD</a> &amp;&amp; <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> &lt;= 32 * 1024);
03722 
03723     <span class="keywordflow">if</span> ((PoolType &amp; <a class="code" href="../../d4/d2/pool_8h.html#a5">BASE_POOL_TYPE_MASK</a>) == <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>) {
03724         <a class="code" href="../../d3/d3/dumpuser_8c.html#a17">Header</a>-&gt;Ulong1 |= <a class="code" href="../../d4/d8/mi_8h.html#a2">MI_SPECIAL_POOL_PAGABLE</a>;
03725     }
03726 
03727     <span class="keywordflow">if</span> (PoolType &amp; <a class="code" href="../../d4/d2/pool_8h.html#a9">POOL_VERIFIER_MASK</a>) {
03728         <a class="code" href="../../d3/d3/dumpuser_8c.html#a17">Header</a>-&gt;Ulong1 |= <a class="code" href="../../d4/d8/mi_8h.html#a3">MI_SPECIAL_POOL_VERIFIER</a>;
03729     }
03730 
03731     <a class="code" href="../../d3/d3/dumpuser_8c.html#a17">Header</a>-&gt;BlockSize = (UCHAR) CurrentTime.LowPart;
03732     <a class="code" href="../../d3/d3/dumpuser_8c.html#a17">Header</a>-&gt;PoolTag = Tag;
03733 
03734     <a class="code" href="../../d6/d1/mmquota_8c.html#a18">MiChargeCommitmentCantExpand</a> (1, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
03735 
03736     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ((<a class="code" href="../../d3/d3/dumpuser_8c.html#a17">Header</a>-&gt;PoolType &amp; <a class="code" href="../../d4/d2/pool_8h.html#a11">POOL_QUOTA_MASK</a>) == 0);
03737 
03738     <span class="keywordflow">return</span> Entry;
03739 }
03740 
03741 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l03742"></a><a class="code" href="../../d2/d1/mm_8h.html#a320">03742</a> <a class="code" href="../../d1/d6/allocpag_8c.html#a41">MmFreeSpecialPool</a> (
03743     IN PVOID P
03744     )
03745 
03746 <span class="comment">/*++</span>
03747 <span class="comment"></span>
03748 <span class="comment">Routine Description:</span>
03749 <span class="comment"></span>
03750 <span class="comment">    This routine frees a special pool allocation.  The backing page is freed</span>
03751 <span class="comment">    and the mapping virtual address is made no access (the next virtual</span>
03752 <span class="comment">    address is already no access).</span>
03753 <span class="comment"></span>
03754 <span class="comment">    The virtual address PTE pair is then placed into an LRU queue to provide</span>
03755 <span class="comment">    maximum no-access (protection) life to catch components that access</span>
03756 <span class="comment">    deallocated pool.</span>
03757 <span class="comment"></span>
03758 <span class="comment">Arguments:</span>
03759 <span class="comment"></span>
03760 <span class="comment">    VirtualAddress - Supplies the special pool virtual address to free.</span>
03761 <span class="comment"></span>
03762 <span class="comment">Return Value:</span>
03763 <span class="comment"></span>
03764 <span class="comment">    None.</span>
03765 <span class="comment"></span>
03766 <span class="comment">Environment:</span>
03767 <span class="comment"></span>
03768 <span class="comment">    Kernel mode, no locks (not even pool locks) held.</span>
03769 <span class="comment"></span>
03770 <span class="comment">--*/</span>
03771 
03772 {
03773     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> PteContents;
03774     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
03775     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn1;
03776     KIRQL OldIrql;
03777     ULONG SlopBytes;
03778     ULONG NumberOfBytesCalculated;
03779     ULONG NumberOfBytesRequested;
03780     <a class="code" href="../../d5/d8/ex_8h.html#a96">POOL_TYPE</a> PoolType;
03781     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> <a class="code" href="../../d4/d2/datalpha_8c.html#a13">NoAccessPte</a>;
03782     <a class="code" href="../../d5/d8/struct__POOL__HEADER.html">PPOOL_HEADER</a> <a class="code" href="../../d3/d3/dumpuser_8c.html#a17">Header</a>;
03783     PUCHAR Slop;
03784     ULONG i;
03785     LOGICAL BufferAtPageEnd;
03786     <a class="code" href="../../d1/d9/struct__MI__FREED__SPECIAL__POOL.html">PMI_FREED_SPECIAL_POOL</a> AllocationBase;
03787     LARGE_INTEGER CurrentTime;
03788     PULONG_PTR StackPointer;
03789 
03790     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (P);
03791     PteContents = *PointerPte;
03792 
03793     <span class="comment">//</span>
03794     <span class="comment">// Check the PTE now so we can give a more friendly bugcheck rather than</span>
03795     <span class="comment">// crashing below on a bad reference.</span>
03796     <span class="comment">//</span>
03797 
03798     <span class="keywordflow">if</span> (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 0) {
03799         <span class="keywordflow">if</span> ((PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Protection == 0) ||
03800             (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Protection == <a class="code" href="../../d4/d8/mi_8h.html#a46">MM_NOACCESS</a>)) {
03801             <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a> (SPECIAL_POOL_DETECTED_MEMORY_CORRUPTION,
03802                           (ULONG_PTR)P,
03803                           (ULONG_PTR)PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long,
03804                           0,
03805                           0x20);
03806         }
03807     }
03808 
03809     <span class="keywordflow">if</span> (((ULONG_PTR)P &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1))) {
03810         <a class="code" href="../../d3/d3/dumpuser_8c.html#a17">Header</a> = <a class="code" href="../../d2/d1/mm_8h.html#a7">PAGE_ALIGN</a> (P);
03811         BufferAtPageEnd = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03812     }
03813     <span class="keywordflow">else</span> {
03814         <a class="code" href="../../d3/d3/dumpuser_8c.html#a17">Header</a> = (<a class="code" href="../../d5/d8/struct__POOL__HEADER.html">PPOOL_HEADER</a>)((PCHAR)<a class="code" href="../../d2/d1/mm_8h.html#a7">PAGE_ALIGN</a> (P) + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - <a class="code" href="../../d5/d2/poolhack_8c.html#a6">POOL_OVERHEAD</a>);
03815         BufferAtPageEnd = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03816     }
03817 
03818     <span class="keywordflow">if</span> (<a class="code" href="../../d3/d3/dumpuser_8c.html#a17">Header</a>-&gt;Ulong1 &amp; <a class="code" href="../../d4/d8/mi_8h.html#a2">MI_SPECIAL_POOL_PAGABLE</a>) {
03819         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ((PointerPte + 1)-&gt;u.Soft.PageFileHigh == <a class="code" href="../../d4/d8/mi_8h.html#a4">MI_SPECIAL_POOL_PTE_PAGABLE</a>);
03820         <span class="keywordflow">if</span> (KeGetCurrentIrql() &gt; <a class="code" href="../../d6/d7/halmips_8h.html#a52">APC_LEVEL</a>) {
03821             <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a> (SPECIAL_POOL_DETECTED_MEMORY_CORRUPTION,
03822                           KeGetCurrentIrql(),
03823                           <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>,
03824                           (ULONG_PTR)P,
03825                           0x31);
03826         }
03827         PoolType = <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>;
03828     }
03829     <span class="keywordflow">else</span> {
03830         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ((PointerPte + 1)-&gt;u.Soft.PageFileHigh == <a class="code" href="../../d4/d8/mi_8h.html#a5">MI_SPECIAL_POOL_PTE_NONPAGABLE</a>);
03831         <span class="keywordflow">if</span> (KeGetCurrentIrql() &gt; <a class="code" href="../../d6/d7/halmips_8h.html#a53">DISPATCH_LEVEL</a>) {
03832             <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a> (SPECIAL_POOL_DETECTED_MEMORY_CORRUPTION,
03833                           KeGetCurrentIrql(),
03834                           <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>,
03835                           (ULONG_PTR)P,
03836                           0x31);
03837         }
03838         PoolType = <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>;
03839     }
03840 
03841     NumberOfBytesRequested = (ULONG)(<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(<a class="code" href="../../d3/d3/dumpuser_8c.html#a17">Header</a>-&gt;Ulong1 &amp; ~(<a class="code" href="../../d4/d8/mi_8h.html#a2">MI_SPECIAL_POOL_PAGABLE</a> | <a class="code" href="../../d4/d8/mi_8h.html#a3">MI_SPECIAL_POOL_VERIFIER</a>));
03842 
03843     <span class="comment">//</span>
03844     <span class="comment">// We gave the caller pool-header aligned data, so account for</span>
03845     <span class="comment">// that when checking here.</span>
03846     <span class="comment">//</span>
03847 
03848     <span class="keywordflow">if</span> (BufferAtPageEnd == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
03849 
03850         NumberOfBytesCalculated = <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - <a class="code" href="../../d2/d1/mm_8h.html#a6">BYTE_OFFSET</a>(P);
03851     
03852         <span class="keywordflow">if</span> (NumberOfBytesRequested &gt; NumberOfBytesCalculated) {
03853     
03854             <span class="comment">//</span>
03855             <span class="comment">// Seems like we didn't give the caller enough - this is an error.</span>
03856             <span class="comment">//</span>
03857     
03858             <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a> (SPECIAL_POOL_DETECTED_MEMORY_CORRUPTION,
03859                           (ULONG_PTR)P,
03860                           NumberOfBytesRequested,
03861                           NumberOfBytesCalculated,
03862                           0x21);
03863         }
03864     
03865         <span class="keywordflow">if</span> (NumberOfBytesRequested + <a class="code" href="../../d5/d2/poolhack_8c.html#a6">POOL_OVERHEAD</a> &lt; NumberOfBytesCalculated) {
03866     
03867             <span class="comment">//</span>
03868             <span class="comment">// Seems like we gave the caller too much - also an error.</span>
03869             <span class="comment">//</span>
03870     
03871             <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a> (SPECIAL_POOL_DETECTED_MEMORY_CORRUPTION,
03872                           (ULONG_PTR)P,
03873                           NumberOfBytesRequested,
03874                           NumberOfBytesCalculated,
03875                           0x22);
03876         }
03877 
03878         <span class="comment">//</span>
03879         <span class="comment">// Check the memory before the start of the caller's allocation.</span>
03880         <span class="comment">//</span>
03881     
03882         Slop = (PUCHAR)(<a class="code" href="../../d3/d3/dumpuser_8c.html#a17">Header</a> + 1);
03883         <span class="keywordflow">if</span> (<a class="code" href="../../d3/d3/dumpuser_8c.html#a17">Header</a>-&gt;Ulong1 &amp; <a class="code" href="../../d4/d8/mi_8h.html#a3">MI_SPECIAL_POOL_VERIFIER</a>) {
03884             Slop += <span class="keyword">sizeof</span>(<a class="code" href="../../d5/d9/struct__MI__VERIFIER__POOL__HEADER.html">MI_VERIFIER_POOL_HEADER</a>);
03885         }
03886 
03887         <span class="keywordflow">for</span> ( ; Slop &lt; (PUCHAR)P; Slop += 1) {
03888     
03889             <span class="keywordflow">if</span> (*Slop != <a class="code" href="../../d3/d3/dumpuser_8c.html#a17">Header</a>-&gt;BlockSize) {
03890     
03891                 <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a> (SPECIAL_POOL_DETECTED_MEMORY_CORRUPTION,
03892                               (ULONG_PTR)P,
03893                               (ULONG_PTR)Slop,
03894                               <a class="code" href="../../d3/d3/dumpuser_8c.html#a17">Header</a>-&gt;Ulong1,
03895                               0x23);
03896             }
03897         }
03898     }
03899     <span class="keywordflow">else</span> {
03900         NumberOfBytesCalculated = 0;
03901     }
03902 
03903     <span class="comment">//</span>
03904     <span class="comment">// Check the memory after the end of the caller's allocation.</span>
03905     <span class="comment">//</span>
03906 
03907     Slop = (PUCHAR)P + NumberOfBytesRequested;
03908 
03909     SlopBytes = (ULONG)((PUCHAR)(<a class="code" href="../../d2/d1/mm_8h.html#a7">PAGE_ALIGN</a>(P)) + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - Slop);
03910 
03911     <span class="keywordflow">if</span> (BufferAtPageEnd == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
03912         SlopBytes -= <a class="code" href="../../d5/d2/poolhack_8c.html#a6">POOL_OVERHEAD</a>;
03913         <span class="keywordflow">if</span> (<a class="code" href="../../d3/d3/dumpuser_8c.html#a17">Header</a>-&gt;Ulong1 &amp; <a class="code" href="../../d4/d8/mi_8h.html#a3">MI_SPECIAL_POOL_VERIFIER</a>) {
03914             SlopBytes -= <span class="keyword">sizeof</span>(<a class="code" href="../../d5/d9/struct__MI__VERIFIER__POOL__HEADER.html">MI_VERIFIER_POOL_HEADER</a>);
03915         }
03916     }
03917 
03918     <span class="keywordflow">for</span> (i = 0; i &lt; SlopBytes; i += 1) {
03919 
03920         <span class="keywordflow">if</span> (*Slop != <a class="code" href="../../d3/d3/dumpuser_8c.html#a17">Header</a>-&gt;BlockSize) {
03921 
03922             <span class="comment">//</span>
03923             <span class="comment">// The caller wrote slop between the free alignment we gave and the</span>
03924             <span class="comment">// end of the page (this is not detectable from page protection).</span>
03925             <span class="comment">//</span>
03926     
03927             <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a> (SPECIAL_POOL_DETECTED_MEMORY_CORRUPTION,
03928                           (ULONG_PTR)P,
03929                           (ULONG_PTR)Slop,
03930                           <a class="code" href="../../d3/d3/dumpuser_8c.html#a17">Header</a>-&gt;Ulong1,
03931                           0x24);
03932         }
03933         Slop += 1;
03934     }
03935 
03936     <span class="keywordflow">if</span> (<a class="code" href="../../d3/d3/dumpuser_8c.html#a17">Header</a>-&gt;Ulong1 &amp; <a class="code" href="../../d4/d8/mi_8h.html#a3">MI_SPECIAL_POOL_VERIFIER</a>) {
03937         <a class="code" href="../../d9/d5/verifier_8c.html#a91">VerifierFreeTrackedPool</a> (P,
03938                                  NumberOfBytesRequested,
03939                                  PoolType,
03940                                  <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
03941     }
03942 
03943     AllocationBase = (<a class="code" href="../../d1/d9/struct__MI__FREED__SPECIAL__POOL.html">PMI_FREED_SPECIAL_POOL</a>)(<a class="code" href="../../d2/d1/mm_8h.html#a7">PAGE_ALIGN</a> (P));
03944 
03945     AllocationBase-&gt;<a class="code" href="../../d1/d9/struct__MI__FREED__SPECIAL__POOL.html#o2">Signature</a> = <a class="code" href="../../d4/d8/mi_8h.html#a255">MI_FREED_SPECIAL_POOL_SIGNATURE</a>;
03946 
03947     <a class="code" href="../../d7/d0/ke_2miscc_8c.html#a4">KeQueryTickCount</a>(&amp;CurrentTime);
03948     AllocationBase-&gt;<a class="code" href="../../d1/d9/struct__MI__FREED__SPECIAL__POOL.html#o3">TickCount</a> = CurrentTime.LowPart;
03949 
03950     AllocationBase-&gt;<a class="code" href="../../d1/d9/struct__MI__FREED__SPECIAL__POOL.html#o4">NumberOfBytesRequested</a> = NumberOfBytesRequested;
03951     AllocationBase-&gt;<a class="code" href="../../d1/d9/struct__MI__FREED__SPECIAL__POOL.html#o5">Pagable</a> = (ULONG)PoolType;
03952     AllocationBase-&gt;<a class="code" href="../../d1/d9/struct__MI__FREED__SPECIAL__POOL.html#o6">VirtualAddress</a> = P;
03953     AllocationBase-&gt;<a class="code" href="../../d1/d9/struct__MI__FREED__SPECIAL__POOL.html#o9">Thread</a> = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a> ();
03954 
03955 <span class="preprocessor">#if defined (_X86_)</span>
03956 <span class="preprocessor"></span>    _asm {
03957         mov StackPointer, esp
03958     }
03959 
03960     AllocationBase-&gt;<a class="code" href="../../d1/d9/struct__MI__FREED__SPECIAL__POOL.html#o7">StackPointer</a> = StackPointer;
03961 
03962     <span class="comment">//</span>
03963     <span class="comment">// For now, don't get fancy with copying more than what's in the current</span>
03964     <span class="comment">// stack page.  To do so would require checking the thread stack limits,</span>
03965     <span class="comment">// DPC stack limits, etc.</span>
03966     <span class="comment">//</span>
03967 
03968     AllocationBase-&gt;<a class="code" href="../../d1/d9/struct__MI__FREED__SPECIAL__POOL.html#o8">StackBytes</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - <a class="code" href="../../d2/d1/mm_8h.html#a6">BYTE_OFFSET</a>(StackPointer);
03969 
03970     <span class="keywordflow">if</span> (AllocationBase-&gt;<a class="code" href="../../d1/d9/struct__MI__FREED__SPECIAL__POOL.html#o8">StackBytes</a> != 0) {
03971 
03972         <span class="keywordflow">if</span> (AllocationBase-&gt;<a class="code" href="../../d1/d9/struct__MI__FREED__SPECIAL__POOL.html#o8">StackBytes</a> &gt; <a class="code" href="../../d4/d8/mi_8h.html#a256">MI_STACK_BYTES</a>) {
03973             AllocationBase-&gt;<a class="code" href="../../d1/d9/struct__MI__FREED__SPECIAL__POOL.html#o8">StackBytes</a> = <a class="code" href="../../d4/d8/mi_8h.html#a256">MI_STACK_BYTES</a>;
03974         }
03975 
03976         RtlCopyMemory (AllocationBase-&gt;<a class="code" href="../../d1/d9/struct__MI__FREED__SPECIAL__POOL.html#o10">StackData</a>,
03977                        StackPointer,
03978                        AllocationBase-&gt;<a class="code" href="../../d1/d9/struct__MI__FREED__SPECIAL__POOL.html#o8">StackBytes</a>);
03979     }
03980 <span class="preprocessor">#else</span>
03981 <span class="preprocessor"></span>    AllocationBase-&gt;<a class="code" href="../../d1/d9/struct__MI__FREED__SPECIAL__POOL.html#o7">StackPointer</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03982     AllocationBase-&gt;<a class="code" href="../../d1/d9/struct__MI__FREED__SPECIAL__POOL.html#o8">StackBytes</a> = 0;
03983 <span class="preprocessor">#endif</span>
03984 <span class="preprocessor"></span>
03985     <span class="keywordflow">if</span> (PoolType == <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>) {
03986         <a class="code" href="../../d4/d2/datalpha_8c.html#a13">NoAccessPte</a>.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a97">MM_KERNEL_NOACCESS_PTE</a>;
03987         <a class="code" href="../../d8/d8/sysload_8c.html#a61">MiDeleteSystemPagableVm</a> (PointerPte,
03988                                  1,
03989                                  <a class="code" href="../../d4/d2/datalpha_8c.html#a13">NoAccessPte</a>,
03990                                  <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
03991                                  <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
03992         <a class="code" href="../../d4/d8/mi_8h.html#a130">LOCK_PFN2</a> (OldIrql);
03993         <a class="code" href="../../d1/d6/allocpag_8c.html#a20">MiSpecialPagesPagable</a> -= 1;
03994     }
03995     <span class="keywordflow">else</span> {
03996 
03997         Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PointerPte-&gt;u.Hard.PageFrameNumber);
03998         <a class="code" href="../../d4/d8/mi_8h.html#a130">LOCK_PFN2</a> (OldIrql);
03999         <a class="code" href="../../d1/d6/allocpag_8c.html#a19">MiSpecialPagesNonPaged</a> -= 1;
04000         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a120">MI_SET_PFN_DELETED</a> (Pfn1);
04001         <a class="code" href="../../d6/d5/pfndec_8c.html#a1">MiDecrementShareCount</a> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a182">MI_GET_PAGE_FRAME_FROM_PTE</a> (PointerPte));
04002         <a class="code" href="../../d0/d6/ppc_2flushtb_8c.html#a2">KeFlushSingleTb</a> (<a class="code" href="../../d2/d1/mm_8h.html#a7">PAGE_ALIGN</a>(P),
04003                          <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
04004                          <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
04005                          (PHARDWARE_PTE)PointerPte,
04006                          <a class="code" href="../../d4/d2/datalpha_8c.html#a1">ZeroKernelPte</a>.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Flush);
04007         <a class="code" href="../../d8/d5/kddata_8c.html#a42">MmResidentAvailablePages</a> += 1;
04008         <a class="code" href="../../d4/d8/mi_8h.html#a322">MM_BUMP_COUNTER</a>(37, 1);
04009     }
04010 
04011     <span class="comment">// </span>
04012     <span class="comment">// Clear the adjacent PTE to support MmIsSpecialPoolAddressFree().</span>
04013     <span class="comment">// </span>
04014 
04015     (PointerPte + 1)-&gt;u.Long = 0;
04016 
04017     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (<a class="code" href="../../d1/d6/allocpag_8c.html#a18">MiSpecialPoolLastPte</a>-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.List.NextEntry == <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a1">MM_EMPTY_PTE_LIST</a>);
04018     <a class="code" href="../../d1/d6/allocpag_8c.html#a18">MiSpecialPoolLastPte</a>-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.List.NextEntry = PointerPte - <a class="code" href="../../d4/d8/mi_8h.html#a671">MmSystemPteBase</a>;
04019 
04020     <a class="code" href="../../d1/d6/allocpag_8c.html#a18">MiSpecialPoolLastPte</a> = PointerPte;
04021     <a class="code" href="../../d1/d6/allocpag_8c.html#a18">MiSpecialPoolLastPte</a>-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.List.NextEntry = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a1">MM_EMPTY_PTE_LIST</a>;
04022 
04023     <a class="code" href="../../d1/d6/allocpag_8c.html#a21">MmSpecialPagesInUse</a> -= 1;
04024 
04025     <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrql);
04026 
04027     <a class="code" href="../../d6/d1/mmquota_8c.html#a19">MiReturnCommitment</a> (1);
04028 
04029     <span class="keywordflow">return</span>;
04030 }
04031 
04032 
04033 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l04034"></a><a class="code" href="../../d1/d6/allocpag_8c.html#a43">04034</a> <a class="code" href="../../d1/d6/allocpag_8c.html#a43">MiMakeSpecialPoolPagable</a> (
04035     IN PVOID VirtualAddress,
04036     IN <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte
04037     )
04038 
04039 <span class="comment">/*++</span>
04040 <span class="comment"></span>
04041 <span class="comment">Routine Description:</span>
04042 <span class="comment"></span>
04043 <span class="comment">    Make a special pool allocation pagable.</span>
04044 <span class="comment"></span>
04045 <span class="comment">Arguments:</span>
04046 <span class="comment"></span>
04047 <span class="comment">    VirtualAddress - Supplies the faulting address.</span>
04048 <span class="comment"></span>
04049 <span class="comment">    PointerPte - Supplies the PTE for the faulting address.</span>
04050 <span class="comment"></span>
04051 <span class="comment">Return Value:</span>
04052 <span class="comment"></span>
04053 <span class="comment">    None.</span>
04054 <span class="comment"></span>
04055 <span class="comment">Environment:</span>
04056 <span class="comment"></span>
04057 <span class="comment">    Kernel mode, no locks (not even pool locks) held.</span>
04058 <span class="comment"></span>
04059 <span class="comment">--*/</span>
04060 
04061 {
04062     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn1;
04063     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> TempPte;
04064 <span class="preprocessor">#if defined(_ALPHA_) &amp;&amp; !defined(_AXP64_)</span>
04065 <span class="preprocessor"></span>    KIRQL OldIrql;
04066 <span class="preprocessor">#endif</span>
04067 <span class="preprocessor"></span>    KIRQL PreviousIrql;
04068     PFN_NUMBER PageFrameIndex;
04069 <span class="preprocessor">#if PFN_CONSISTENCY</span>
04070 <span class="preprocessor"></span>    KIRQL PfnIrql;
04071 <span class="preprocessor">#endif</span>
04072 <span class="preprocessor"></span>
04073     <a class="code" href="../../d4/d8/mi_8h.html#a144">LOCK_SYSTEM_WS</a> (PreviousIrql);
04074 
04075     <span class="comment">//</span>
04076     <span class="comment">// As this page is now allocated, add it to the system working set to</span>
04077     <span class="comment">// make it pagable.</span>
04078     <span class="comment">//</span>
04079 
04080     TempPte = *PointerPte;
04081 
04082     PageFrameIndex = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a183">MI_GET_PAGE_FRAME_FROM_TRANSITION_PTE</a> (&amp;TempPte);
04083 
04084     Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PageFrameIndex);
04085 
04086     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o5">u1</a>.Event == 0);
04087 
04088     <a class="code" href="../../d4/d8/mi_8h.html#a121">CONSISTENCY_LOCK_PFN</a> (PfnIrql);
04089 
04090     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o5">u1</a>.Event = (PVOID) <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
04091 
04092     <a class="code" href="../../d4/d8/mi_8h.html#a122">CONSISTENCY_UNLOCK_PFN</a> (PfnIrql);
04093 
04094     <a class="code" href="../../d8/d2/pagfault_8c.html#a28">MiAddValidPageToWorkingSet</a> (VirtualAddress,
04095                                 PointerPte,
04096                                 Pfn1,
04097                                 0);
04098 
04099     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (KeGetCurrentIrql() == <a class="code" href="../../d6/d7/halmips_8h.html#a52">APC_LEVEL</a>);
04100 
04101     <span class="keywordflow">if</span> (<a class="code" href="../../d6/d8/sysinfo_8c.html#a21">MmSystemCacheWs</a>.<a class="code" href="../../d3/d6/struct__MMSUPPORT.html#o9">AllowWorkingSetAdjustment</a> == <a class="code" href="../../d4/d8/mi_8h.html#a32">MM_GROW_WSLE_HASH</a>) {
04102         <a class="code" href="../../d4/d0/wslist_8c.html#a33">MiGrowWsleHash</a> (&amp;<a class="code" href="../../d6/d8/sysinfo_8c.html#a21">MmSystemCacheWs</a>);
04103 <span class="preprocessor">#if defined(_ALPHA_) &amp;&amp; !defined(_AXP64_)</span>
04104 <span class="preprocessor"></span>        <a class="code" href="../../d4/d8/mi_8h.html#a142">LOCK_EXPANSION_IF_ALPHA</a> (OldIrql);
04105 <span class="preprocessor">#endif</span>
04106 <span class="preprocessor"></span>        <a class="code" href="../../d6/d8/sysinfo_8c.html#a21">MmSystemCacheWs</a>.<a class="code" href="../../d3/d6/struct__MMSUPPORT.html#o9">AllowWorkingSetAdjustment</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04107 <span class="preprocessor">#if defined(_ALPHA_) &amp;&amp; !defined(_AXP64_)</span>
04108 <span class="preprocessor"></span>        <a class="code" href="../../d4/d8/mi_8h.html#a143">UNLOCK_EXPANSION_IF_ALPHA</a> (OldIrql);
04109 <span class="preprocessor">#endif</span>
04110 <span class="preprocessor"></span>    }
04111     <a class="code" href="../../d4/d8/mi_8h.html#a145">UNLOCK_SYSTEM_WS</a> (PreviousIrql);
04112 }
04113 
04114 
04115 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l04116"></a><a class="code" href="../../d4/d8/mi_8h.html#a974">04116</a> <a class="code" href="../../d4/d8/mi_8h.html#a974">MiCheckSessionPoolAllocations</a>(
04117     VOID
04118     )
04119 
04120 <span class="comment">/*++</span>
04121 <span class="comment"></span>
04122 <span class="comment">Routine Description:</span>
04123 <span class="comment"></span>
04124 <span class="comment">    Ensure that the current session has no pool allocations since it is about</span>
04125 <span class="comment">    to exit.  All session allocations must be freed prior to session exit.</span>
04126 <span class="comment"></span>
04127 <span class="comment">Arguments:</span>
04128 <span class="comment"></span>
04129 <span class="comment">    None.</span>
04130 <span class="comment"></span>
04131 <span class="comment">Return Value:</span>
04132 <span class="comment"></span>
04133 <span class="comment">    None.</span>
04134 <span class="comment"></span>
04135 <span class="comment">Environment:</span>
04136 <span class="comment"></span>
04137 <span class="comment">    Kernel mode.</span>
04138 <span class="comment"></span>
04139 <span class="comment">--*/</span>
04140 
04141 {
04142     ULONG i;
04143     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> StartPde;
04144     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> EndPde;
04145     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
04146     PVOID VirtualAddress;
04147 
04148     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
04149 
04150     <span class="keywordflow">if</span> (<a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o9">NonPagedPoolBytes</a> || <a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o10">PagedPoolBytes</a>) {
04151 
04152         <span class="comment">//</span>
04153         <span class="comment">// All page tables for this session's paged pool must be freed by now.</span>
04154         <span class="comment">// Being here means they aren't - this is fatal.  Force in any valid</span>
04155         <span class="comment">// pages so that a debugger can show who the guilty party is.</span>
04156         <span class="comment">//</span>
04157 
04158         StartPde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a151">MiGetPdeAddress</a> (<a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o18">PagedPoolStart</a>);
04159         EndPde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a151">MiGetPdeAddress</a> (<a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o19">PagedPoolEnd</a>);
04160 
04161         <span class="keywordflow">while</span> (StartPde &lt;= EndPde) {
04162 
04163             <span class="keywordflow">if</span> (StartPde-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long != 0 &amp;&amp; StartPde-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long != <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a97">MM_KERNEL_NOACCESS_PTE</a>) {
04164                 <span class="comment">//</span>
04165                 <span class="comment">// Hunt through the page table page for valid pages and force</span>
04166                 <span class="comment">// them in.  Note this also forces in the page table page if</span>
04167                 <span class="comment">// it is not already.</span>
04168                 <span class="comment">//</span>
04169 
04170                 PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a> (StartPde);
04171 
04172                 <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a103">PTE_PER_PAGE</a>; i += 1) {
04173                     <span class="keywordflow">if</span> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long != 0 &amp;&amp; PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long != <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a97">MM_KERNEL_NOACCESS_PTE</a>) {
04174                         VirtualAddress = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a> (PointerPte);
04175                         *(<span class="keyword">volatile</span> BOOLEAN *)VirtualAddress = *(<span class="keyword">volatile</span> BOOLEAN *)VirtualAddress;
04176 
04177 <span class="preprocessor">#if DBG</span>
04178 <span class="preprocessor"></span>                        <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"MiCheckSessionPoolAllocations: Address %p still valid\n"</span>,
04179                             VirtualAddress);
04180 <span class="preprocessor">#endif</span>
04181 <span class="preprocessor"></span>                    }
04182                     PointerPte += 1;
04183                 }
04184 
04185             }
04186 
04187             StartPde += 1;
04188         }
04189 
04190 <span class="preprocessor">#if DBG</span>
04191 <span class="preprocessor"></span>        <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a> (<span class="stringliteral">"MiCheckSessionPoolAllocations: This exiting session (ID %d) is leaking pool !\n"</span>,  <a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o4">SessionId</a>);
04192 
04193         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a> (<span class="stringliteral">"This means win32k.sys, rdpdd.sys, atmfd.sys or a video/font driver is broken\n"</span>);
04194 
04195         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a> (<span class="stringliteral">"%d nonpaged allocation leaks for %d bytes and %d paged allocation leaks for %d bytes\n"</span>,
04196             <a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o11">NonPagedPoolAllocations</a>,
04197             <a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o9">NonPagedPoolBytes</a>,
04198             <a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o12">PagedPoolAllocations</a>,
04199             <a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o10">PagedPoolBytes</a>);
04200 <span class="preprocessor">#endif</span>
04201 <span class="preprocessor"></span>
04202         <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a> (SESSION_HAS_VALID_POOL_ON_EXIT,
04203                       (ULONG_PTR)<a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o4">SessionId</a>,
04204                       <a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o10">PagedPoolBytes</a>,
04205                       <a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o9">NonPagedPoolBytes</a>,
04206 #<span class="keywordflow">if</span> defined (_WIN64)
04207                       (<a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o11">NonPagedPoolAllocations</a> &lt;&lt; 32) |
04208                         (<a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o12">PagedPoolAllocations</a>)
04209 #<a class="code" href="../../d2/d0/nt6_2user32_8def.html#a85">else</a>
04210                       (<a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o11">NonPagedPoolAllocations</a> &lt;&lt; 16) |
04211                         (<a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o12">PagedPoolAllocations</a>)
04212 #endif
04213                     );
04214     }
04215 
04216     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (<a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o11">NonPagedPoolAllocations</a> == 0);
04217     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (<a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o12">PagedPoolAllocations</a> == 0);
04218 }
04219 
04220 
04221 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l04222"></a><a class="code" href="../../d4/d8/mi_8h.html#a973">04222</a> <a class="code" href="../../d4/d8/mi_8h.html#a973">MiInitializeSessionPool</a>(
04223     VOID
04224     )
04225 
04226 <span class="comment">/*++</span>
04227 <span class="comment"></span>
04228 <span class="comment">Routine Description:</span>
04229 <span class="comment"></span>
04230 <span class="comment">    Initialize the current session's pool structure.</span>
04231 <span class="comment"></span>
04232 <span class="comment">Arguments:</span>
04233 <span class="comment"></span>
04234 <span class="comment">    None.</span>
04235 <span class="comment"></span>
04236 <span class="comment">Return Value:</span>
04237 <span class="comment"></span>
04238 <span class="comment">    Status of the pool initialization.</span>
04239 <span class="comment"></span>
04240 <span class="comment">Environment:</span>
04241 <span class="comment"></span>
04242 <span class="comment">    Kernel mode.</span>
04243 <span class="comment"></span>
04244 <span class="comment">--*/</span>
04245 
04246 {
04247     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
04248     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> TempPte;
04249     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPde, PointerPte;
04250     PFN_NUMBER PageFrameIndex;
04251     <a class="code" href="../../d4/d8/struct__POOL__DESCRIPTOR.html">PPOOL_DESCRIPTOR</a> PoolDescriptor;
04252     <a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html">PMM_SESSION_SPACE</a> SessionGlobal;
04253     <a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html">PMM_PAGED_POOL_INFO</a> PagedPoolInfo;
04254     KIRQL OldIrql;
04255     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn1;
04256     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> PreviousPte;
04257 <span class="preprocessor">#if DBG</span>
04258 <span class="preprocessor"></span>    <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> StartPde, EndPde;
04259 <span class="preprocessor">#endif</span>
04260 <span class="preprocessor"></span>
04261     SessionGlobal = <a class="code" href="../../d4/d8/mi_8h.html#a356">SESSION_GLOBAL</a>(<a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>);
04262 
04263     <a class="code" href="../../d5/d8/ex_8h.html#a8">ExInitializeFastMutex</a> (&amp;SessionGlobal-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o17">PagedPoolMutex</a>);
04264 
04265     PoolDescriptor = &amp;<a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o37">PagedPool</a>;
04266 
04267     <a class="code" href="../../d4/d2/pool_8h.html#a35">ExpInitializePoolDescriptor</a> (PoolDescriptor,
04268                                  <a class="code" href="../../d5/d8/ex_8h.html#a329a182">PagedPoolSession</a>,
04269                                  0,
04270                                  0,
04271                                  &amp;SessionGlobal-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o17">PagedPoolMutex</a>);
04272 
04273     <a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o18">PagedPoolStart</a> = (PVOID)<a class="code" href="../../d4/d8/mi_8h.html#a350">MI_SESSION_POOL</a>;
04274 
04275     <a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o19">PagedPoolEnd</a> = (PVOID)((<a class="code" href="../../d4/d8/mi_8h.html#a350">MI_SESSION_POOL</a> + <a class="code" href="../../d4/d8/mi_8h.html#a337">MI_SESSION_POOL_SIZE</a>)-1);
04276 
04277     PagedPoolInfo = &amp;<a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o21">PagedPoolInfo</a>;
04278     PagedPoolInfo-&gt;<a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html#o7">PagedPoolCommit</a> = 0;
04279     PagedPoolInfo-&gt;<a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html#o6">PagedPoolHint</a> = 0;
04280     PagedPoolInfo-&gt;<a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html#o8">AllocatedPagedPool</a> = 0;
04281 
04282     <span class="comment">//</span>
04283     <span class="comment">// Build the page table page for paged pool.</span>
04284     <span class="comment">//</span>
04285 
04286     PointerPde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a151">MiGetPdeAddress</a> (<a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o18">PagedPoolStart</a>);
04287     <a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o20">PagedPoolBasePde</a> = PointerPde;
04288 
04289     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (<a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o18">PagedPoolStart</a>);
04290 
04291     PagedPoolInfo-&gt;<a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html#o3">FirstPteForPagedPool</a> = PointerPte;
04292     PagedPoolInfo-&gt;<a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html#o4">LastPteForPagedPool</a> = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (<a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o19">PagedPoolEnd</a>);
04293 
04294 <span class="preprocessor">#if DBG</span>
04295 <span class="preprocessor"></span>    <span class="comment">//</span>
04296     <span class="comment">// Session pool better be unused.</span>
04297     <span class="comment">//</span>
04298 
04299     StartPde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a151">MiGetPdeAddress</a> (<a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o18">PagedPoolStart</a>);
04300     EndPde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a151">MiGetPdeAddress</a> (<a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o19">PagedPoolEnd</a>);
04301 
04302     <span class="keywordflow">while</span> (StartPde &lt;= EndPde) {
04303         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (StartPde-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long == 0);
04304         StartPde += 1;
04305     }
04306 <span class="preprocessor">#endif</span>
04307 <span class="preprocessor"></span>
04308     <span class="comment">//</span>
04309     <span class="comment">// Mark all PDEs as empty.</span>
04310     <span class="comment">//</span>
04311 
04312     <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a189">MiFillMemoryPte</a> (PointerPde,
04313                      <span class="keyword">sizeof</span>(<a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a>) *
04314                          (1 + <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a151">MiGetPdeAddress</a> (<a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o19">PagedPoolEnd</a>) - PointerPde),
04315                      <a class="code" href="../../d4/d2/datalpha_8c.html#a1">ZeroKernelPte</a>.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long);
04316 
04317     <span class="keywordflow">if</span> (<a class="code" href="../../d6/d1/mmquota_8c.html#a17">MiChargeCommitment</a> (1, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
04318         <a class="code" href="../../d4/d8/mi_8h.html#a396">MM_BUMP_SESSION_FAILURES</a> (<a class="code" href="../../d4/d8/mi_8h.html#a387">MM_SESSION_FAILURE_NO_COMMIT</a>);
04319         <span class="keywordflow">return</span> STATUS_NO_MEMORY;
04320     }
04321 
04322     <a class="code" href="../../d4/d8/mi_8h.html#a254">MM_TRACK_COMMIT</a> (<a class="code" href="../../d4/d8/mi_8h.html#a260">MM_DBG_COMMIT_SESSION_POOL_PAGE_TABLES</a>, 1);
04323 
04324     TempPte = <a class="code" href="../../d4/d2/datalpha_8c.html#a8">ValidKernelPdeLocal</a>;
04325 
04326     <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
04327 
04328     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a94">MmAvailablePages</a> &lt;= 1) {
04329         <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
04330         <a class="code" href="../../d6/d1/mmquota_8c.html#a19">MiReturnCommitment</a> (1);
04331         <a class="code" href="../../d4/d8/mi_8h.html#a254">MM_TRACK_COMMIT</a> (<a class="code" href="../../d4/d8/mi_8h.html#a288">MM_DBG_COMMIT_RETURN_SESSION_POOL_PAGE_TABLES</a>, 1);
04332         <a class="code" href="../../d4/d8/mi_8h.html#a396">MM_BUMP_SESSION_FAILURES</a> (<a class="code" href="../../d4/d8/mi_8h.html#a388">MM_SESSION_FAILURE_NO_RESIDENT</a>);
04333         <span class="keywordflow">return</span> STATUS_NO_MEMORY;
04334     }
04335 
04336     <a class="code" href="../../d8/d5/kddata_8c.html#a42">MmResidentAvailablePages</a> -= 1;
04337     <a class="code" href="../../d4/d8/mi_8h.html#a322">MM_BUMP_COUNTER</a>(42, 1);
04338     <a class="code" href="../../d4/d8/mi_8h.html#a384">MM_BUMP_SESS_COUNTER</a>(<a class="code" href="../../d4/d8/mi_8h.html#a366">MM_DBG_SESSION_PAGEDPOOL_PAGETABLE_ALLOC</a>, 1);
04339 
04340     <a class="code" href="../../d7/d5/pfnlist_8c.html#a13">MiEnsureAvailablePageOrWait</a> (<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
04341 
04342     <span class="comment">//</span>
04343     <span class="comment">// Allocate and map in the initial page table page for session pool.</span>
04344     <span class="comment">//</span>
04345 
04346     PageFrameIndex = <a class="code" href="../../d7/d5/pfnlist_8c.html#a15">MiRemoveAnyPage</a> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a124">MI_GET_PAGE_COLOR_FROM_PTE</a> (PointerPde));
04347     TempPte.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber = PageFrameIndex;
04348     <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a186">MI_WRITE_VALID_PTE</a> (PointerPde, TempPte);
04349 
04350     <a class="code" href="../../d8/d2/pagfault_8c.html#a27">MiInitializePfnForOtherProcess</a> (PageFrameIndex,
04351                                     PointerPde,
04352                                     <a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o5">SessionPageDirectoryIndex</a>);
04353 
04354     Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PageFrameIndex);
04355 
04356     <span class="comment">//</span>
04357     <span class="comment">// This page will be locked into working set and assigned an index when</span>
04358     <span class="comment">// the working set is set up on return.</span>
04359     <span class="comment">//</span>
04360 
04361     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o5">u1</a>.WsIndex == 0);
04362 
04363     <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
04364 
04365     KeFillEntryTb ((PHARDWARE_PTE) PointerPde, PointerPte, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
04366 
04367 <span class="preprocessor">#if !defined (_WIN64)</span>
04368 <span class="preprocessor"></span>
04369     <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = <a class="code" href="../../d4/d8/mi_8h.html#a409">MiGetPdeSessionIndex</a> (<a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o18">PagedPoolStart</a>);
04370 
04371     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (<a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o16">PageTables</a>[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].u.Long == 0);
04372     <a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o16">PageTables</a>[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>] = TempPte;
04373 
04374 <span class="preprocessor">#endif</span>
04375 <span class="preprocessor"></span>
04376     <a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o13">NonPagablePages</a> += 1;
04377     <a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o14">CommittedPages</a> += 1;
04378 
04379     <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a189">MiFillMemoryPte</a> (PointerPte, <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>, <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a97">MM_KERNEL_NOACCESS_PTE</a>);
04380 
04381     PagedPoolInfo-&gt;<a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html#o5">NextPdeForPagedPoolExpansion</a> = PointerPde + 1;
04382 
04383     <span class="comment">//</span>
04384     <span class="comment">// Initialize the bitmaps.</span>
04385     <span class="comment">//</span>
04386 
04387     <a class="code" href="../../d4/d8/mi_8h.html#a233">MiCreateBitMap</a> (&amp;PagedPoolInfo-&gt;<a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html#o0">PagedPoolAllocationMap</a>,
04388                     <a class="code" href="../../d4/d8/mi_8h.html#a337">MI_SESSION_POOL_SIZE</a> &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>,
04389                     <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>);
04390 
04391     <span class="keywordflow">if</span> (PagedPoolInfo-&gt;<a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html#o0">PagedPoolAllocationMap</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
04392         <a class="code" href="../../d4/d8/mi_8h.html#a396">MM_BUMP_SESSION_FAILURES</a> (<a class="code" href="../../d4/d8/mi_8h.html#a392">MM_SESSION_FAILURE_NO_NONPAGED_POOL</a>);
04393         <span class="keywordflow">goto</span> Failure;
04394     }
04395 
04396     <span class="comment">//</span>
04397     <span class="comment">// We start with all pages in the virtual address space as "busy", and</span>
04398     <span class="comment">// clear bits to make pages available as we dynamically expand the pool.</span>
04399     <span class="comment">//</span>
04400 
04401     <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a28">RtlSetAllBits</a>( PagedPoolInfo-&gt;<a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html#o0">PagedPoolAllocationMap</a> );
04402 
04403     <span class="comment">//</span>
04404     <span class="comment">// Indicate first page worth of PTEs are available.</span>
04405     <span class="comment">//</span>
04406 
04407     <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a33">RtlClearBits</a> (PagedPoolInfo-&gt;<a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html#o0">PagedPoolAllocationMap</a>, 0, <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a103">PTE_PER_PAGE</a>);
04408 
04409     <span class="comment">//</span>
04410     <span class="comment">// Create the end of allocation range bitmap.</span>
04411     <span class="comment">//</span>
04412 
04413     <a class="code" href="../../d4/d8/mi_8h.html#a233">MiCreateBitMap</a> (&amp;PagedPoolInfo-&gt;<a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html#o1">EndOfPagedPoolBitmap</a>,
04414                     <a class="code" href="../../d4/d8/mi_8h.html#a337">MI_SESSION_POOL_SIZE</a> &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>,
04415                     <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>);
04416 
04417     <span class="keywordflow">if</span> (PagedPoolInfo-&gt;<a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html#o1">EndOfPagedPoolBitmap</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
04418         <a class="code" href="../../d4/d8/mi_8h.html#a396">MM_BUMP_SESSION_FAILURES</a> (<a class="code" href="../../d4/d8/mi_8h.html#a392">MM_SESSION_FAILURE_NO_NONPAGED_POOL</a>);
04419         <span class="keywordflow">goto</span> Failure;
04420     }
04421 
04422     <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a27">RtlClearAllBits</a> (PagedPoolInfo-&gt;<a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html#o1">EndOfPagedPoolBitmap</a>);
04423 
04424     <span class="comment">//</span>
04425     <span class="comment">// Create the large session allocation bitmap.</span>
04426     <span class="comment">//</span>
04427 
04428     <a class="code" href="../../d4/d8/mi_8h.html#a233">MiCreateBitMap</a> (&amp;PagedPoolInfo-&gt;<a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html#o2">PagedPoolLargeSessionAllocationMap</a>,
04429                     <a class="code" href="../../d4/d8/mi_8h.html#a337">MI_SESSION_POOL_SIZE</a> &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>,
04430                     <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>);
04431 
04432     <span class="keywordflow">if</span> (PagedPoolInfo-&gt;<a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html#o2">PagedPoolLargeSessionAllocationMap</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
04433         <a class="code" href="../../d4/d8/mi_8h.html#a396">MM_BUMP_SESSION_FAILURES</a> (<a class="code" href="../../d4/d8/mi_8h.html#a392">MM_SESSION_FAILURE_NO_NONPAGED_POOL</a>);
04434         <span class="keywordflow">goto</span> Failure;
04435     }
04436 
04437     <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a27">RtlClearAllBits</a> (PagedPoolInfo-&gt;<a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html#o2">PagedPoolLargeSessionAllocationMap</a>);
04438 
04439     <span class="keywordflow">return</span> STATUS_SUCCESS;
04440 
04441 Failure:
04442 
04443     <a class="code" href="../../d4/d8/mi_8h.html#a975">MiFreeSessionPoolBitMaps</a> ();
04444 
04445     <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
04446 
04447     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (<a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o5">SessionPageDirectoryIndex</a> == Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o17">PteFrame</a>);
04448     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount == 1);
04449     <a class="code" href="../../d4/d8/mi_8h.html#a242">MiDecrementShareAndValidCount</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o17">PteFrame</a>);
04450     <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a120">MI_SET_PFN_DELETED</a> (Pfn1);
04451     <a class="code" href="../../d4/d8/mi_8h.html#a241">MiDecrementShareCountOnly</a> (PageFrameIndex);
04452 
04453     <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a199">MI_FLUSH_SINGLE_SESSION_TB</a> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>(PointerPde),
04454                                 <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
04455                                 <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
04456                                 (PHARDWARE_PTE)PointerPde,
04457                                 <a class="code" href="../../d4/d2/datalpha_8c.html#a1">ZeroKernelPte</a>.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Flush,
04458                                 PreviousPte);
04459 
04460     <a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o13">NonPagablePages</a> -= 1;
04461     <a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o14">CommittedPages</a> -= 1;
04462 
04463     <a class="code" href="../../d8/d5/kddata_8c.html#a42">MmResidentAvailablePages</a> += 1;
04464     <a class="code" href="../../d4/d8/mi_8h.html#a322">MM_BUMP_COUNTER</a>(51, 1);
04465     <a class="code" href="../../d4/d8/mi_8h.html#a384">MM_BUMP_SESS_COUNTER</a>(<a class="code" href="../../d4/d8/mi_8h.html#a367">MM_DBG_SESSION_PAGEDPOOL_PAGETABLE_FREE_FAIL1</a>, 1);
04466 
04467     <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
04468 
04469     <a class="code" href="../../d6/d1/mmquota_8c.html#a19">MiReturnCommitment</a> (1);
04470 
04471     <a class="code" href="../../d4/d8/mi_8h.html#a254">MM_TRACK_COMMIT</a> (<a class="code" href="../../d4/d8/mi_8h.html#a287">MM_DBG_COMMIT_RETURN_PAGED_POOL_PAGES</a>, 1);
04472 
04473     <span class="keywordflow">return</span> STATUS_NO_MEMORY;
04474 }
04475 
04476 
04477 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l04478"></a><a class="code" href="../../d4/d8/mi_8h.html#a975">04478</a> <a class="code" href="../../d4/d8/mi_8h.html#a975">MiFreeSessionPoolBitMaps</a>(
04479     VOID
04480     )
04481 
04482 <span class="comment">/*++</span>
04483 <span class="comment"></span>
04484 <span class="comment">Routine Description:</span>
04485 <span class="comment"></span>
04486 <span class="comment">    Free the current session's pool bitmap structures.</span>
04487 <span class="comment"></span>
04488 <span class="comment">Arguments:</span>
04489 <span class="comment"></span>
04490 <span class="comment">    None.</span>
04491 <span class="comment"></span>
04492 <span class="comment">Return Value:</span>
04493 <span class="comment"></span>
04494 <span class="comment">    None.</span>
04495 <span class="comment"></span>
04496 <span class="comment">Environment:</span>
04497 <span class="comment"></span>
04498 <span class="comment">    Kernel mode.</span>
04499 <span class="comment"></span>
04500 <span class="comment">--*/</span>
04501 
04502 {
04503     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
04504 
04505     <span class="keywordflow">if</span> (<a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o21">PagedPoolInfo</a>.<a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html#o0">PagedPoolAllocationMap</a> ) {
04506         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (<a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o21">PagedPoolInfo</a>.<a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html#o0">PagedPoolAllocationMap</a>);
04507         <a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o21">PagedPoolInfo</a>.<a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html#o0">PagedPoolAllocationMap</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04508     }
04509 
04510     <span class="keywordflow">if</span> (<a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o21">PagedPoolInfo</a>.<a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html#o1">EndOfPagedPoolBitmap</a> ) {
04511         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (<a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o21">PagedPoolInfo</a>.<a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html#o1">EndOfPagedPoolBitmap</a>);
04512         <a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o21">PagedPoolInfo</a>.<a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html#o1">EndOfPagedPoolBitmap</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04513     }
04514 
04515     <span class="keywordflow">if</span> (<a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o21">PagedPoolInfo</a>.<a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html#o2">PagedPoolLargeSessionAllocationMap</a>) {
04516         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (<a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o21">PagedPoolInfo</a>.<a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html#o2">PagedPoolLargeSessionAllocationMap</a>);
04517         <a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o21">PagedPoolInfo</a>.<a class="code" href="../../d9/d9/struct__MM__PAGED__POOL__INFO.html#o2">PagedPoolLargeSessionAllocationMap</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04518     }
04519 }
04520 
04521 <span class="preprocessor">#if DBG</span>
04522 <span class="preprocessor"></span>
04523 <span class="preprocessor">#define MI_LOG_CONTIGUOUS  100</span>
04524 <span class="preprocessor"></span>
04525 <span class="keyword">typedef</span> <span class="keyword">struct </span>_MI_CONTIGUOUS_ALLOCATORS {
04526     PVOID BaseAddress;
04527     SIZE_T NumberOfBytes;
04528     PVOID CallingAddress;
04529 } MI_CONTIGUOUS_ALLOCATORS, *PMI_CONTIGUOUS_ALLOCATORS;
04530 
04531 ULONG MiContiguousIndex;
04532 MI_CONTIGUOUS_ALLOCATORS MiContiguousAllocators[MI_LOG_CONTIGUOUS];
04533 
04534 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
04535 <a class="code" href="../../d1/d6/allocpag_8c.html#a3">MiInsertContiguousTag</a> (
04536     IN PVOID BaseAddress,
04537     IN SIZE_T NumberOfBytes,
04538     IN PVOID CallingAddress
04539     )
04540 {
04541     KIRQL OldIrql;
04542 
04543 <span class="preprocessor">#if !DBG</span>
04544 <span class="preprocessor"></span>    <span class="keywordflow">if</span> ((<a class="code" href="../../d9/d2/ldrp_8h.html#a33">NtGlobalFlag</a> &amp; FLG_POOL_ENABLE_TAGGING) == 0) {
04545         <span class="keywordflow">return</span>;
04546     }
04547 <span class="preprocessor">#endif</span>
04548 <span class="preprocessor"></span>
04549     OldIrql = <a class="code" href="../../d5/d8/ex_8h.html#a226">ExLockPool</a> (NonPagedPool);
04550 
04551     <span class="keywordflow">if</span> (MiContiguousIndex &gt;= MI_LOG_CONTIGUOUS) {
04552         MiContiguousIndex = 0;
04553     }
04554 
04555     MiContiguousAllocators[MiContiguousIndex].BaseAddress = BaseAddress;
04556     MiContiguousAllocators[MiContiguousIndex].NumberOfBytes = NumberOfBytes;
04557     MiContiguousAllocators[MiContiguousIndex].CallingAddress = CallingAddress;
04558 
04559     MiContiguousIndex += 1;
04560 
04561     <a class="code" href="../../d5/d8/ex_8h.html#a227">ExUnlockPool</a> (NonPagedPool, OldIrql);
04562 }
04563 <span class="preprocessor">#else</span>
<a name="l04564"></a><a class="code" href="../../d1/d6/allocpag_8c.html#a3">04564</a> <span class="preprocessor"></span><span class="preprocessor">#define MiInsertContiguousTag(a, b, c)</span>
04565 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
04566 <span class="preprocessor"></span>
04567 
04568 PVOID
<a name="l04569"></a><a class="code" href="../../d4/d8/mi_8h.html#a794">04569</a> <a class="code" href="../../d4/d8/mi_8h.html#a794">MiFindContiguousMemory</a> (
04570     IN PFN_NUMBER LowestPfn,
04571     IN PFN_NUMBER HighestPfn,
04572     IN PFN_NUMBER BoundaryPfn,
04573     IN PFN_NUMBER SizeInPages,
04574     IN PVOID CallingAddress
04575     )
04576 
04577 <span class="comment">/*++</span>
04578 <span class="comment"></span>
04579 <span class="comment">Routine Description:</span>
04580 <span class="comment"></span>
04581 <span class="comment">    This function searches nonpaged pool and the free, zeroed,</span>
04582 <span class="comment">    and standby lists for contiguous pages that satisfy the</span>
04583 <span class="comment">    request.</span>
04584 <span class="comment"></span>
04585 <span class="comment">Arguments:</span>
04586 <span class="comment"></span>
04587 <span class="comment">    LowestPfn - Supplies the lowest acceptable physical page number.</span>
04588 <span class="comment"></span>
04589 <span class="comment">    HighestPfn - Supplies the highest acceptable physical page number.</span>
04590 <span class="comment"></span>
04591 <span class="comment">    BoundaryPfn - Supplies the page frame number multiple the allocation must</span>
04592 <span class="comment">                  not cross.  0 indicates it can cross any boundary.</span>
04593 <span class="comment"></span>
04594 <span class="comment">    SizeInPages - Supplies the number of pages to allocate.</span>
04595 <span class="comment"></span>
04596 <span class="comment">    CallingAddress - Supplies the calling address of the allocator.</span>
04597 <span class="comment"></span>
04598 <span class="comment">Return Value:</span>
04599 <span class="comment"></span>
04600 <span class="comment">    NULL - a contiguous range could not be found to satisfy the request.</span>
04601 <span class="comment"></span>
04602 <span class="comment">    NON-NULL - Returns a pointer (virtual address in the nonpaged portion</span>
04603 <span class="comment">               of the system) to the allocated physically contiguous</span>
04604 <span class="comment">               memory.</span>
04605 <span class="comment"></span>
04606 <span class="comment">Environment:</span>
04607 <span class="comment"></span>
04608 <span class="comment">    Kernel mode, IRQL of APC_LEVEL or below.</span>
04609 <span class="comment"></span>
04610 <span class="comment">--*/</span>
04611 {
04612     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
04613     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn1;
04614     PVOID BaseAddress;
04615     PVOID BaseAddress2;
04616     KIRQL OldIrql;
04617     KIRQL OldIrql2;
04618     <a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html">PMMFREE_POOL_ENTRY</a> FreePageInfo;
04619     PLIST_ENTRY Entry;
04620     ULONG start;
04621     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
04622     PFN_NUMBER count;
04623     PFN_NUMBER Page;
04624     PFN_NUMBER LastPage;
04625     PFN_NUMBER found;
04626     PFN_NUMBER BoundaryMask;
04627     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> TempPte;
04628     ULONG PageColor;
04629     ULONG AllocationPosition;
04630     PVOID Va;
04631     LOGICAL AddressIsPhysical;
04632     PFN_NUMBER SpanInPages;
04633     PFN_NUMBER SpanInPages2;
04634 
04635     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a> ();
04636 
04637     BaseAddress = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04638 
04639     BoundaryMask = ~(BoundaryPfn - 1);
04640 
04641     <span class="comment">//</span>
04642     <span class="comment">// A suitable pool page was not allocated via the pool allocator.</span>
04643     <span class="comment">// Grab the pool lock and manually search for a page which meets</span>
04644     <span class="comment">// the requirements.</span>
04645     <span class="comment">//</span>
04646 
04647     <a class="code" href="../../d5/d6/iosup_8c.html#a76">MmLockPagableSectionByHandle</a> (<a class="code" href="../../d5/d8/ex_8h.html#a166">ExPageLockHandle</a>);
04648 
04649     ExAcquireFastMutex (&amp;<a class="code" href="../../d9/d3/dynmem_8c.html#a1">MmDynamicMemoryMutex</a>);
04650 
04651     OldIrql = <a class="code" href="../../d5/d8/ex_8h.html#a226">ExLockPool</a> (<a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>);
04652 
04653     <span class="comment">//</span>
04654     <span class="comment">// Trace through the page allocator's pool headers for a page which</span>
04655     <span class="comment">// meets the requirements.</span>
04656     <span class="comment">//</span>
04657 
04658     <span class="comment">//</span>
04659     <span class="comment">// NonPaged pool is linked together through the pages themselves.</span>
04660     <span class="comment">//</span>
04661 
04662     <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = (ULONG)(SizeInPages - 1);
04663 
04664     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &gt;= <a class="code" href="../../d4/d8/mi_8h.html#a324">MI_MAX_FREE_LIST_HEADS</a>) {
04665         <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = <a class="code" href="../../d4/d8/mi_8h.html#a324">MI_MAX_FREE_LIST_HEADS</a> - 1;
04666     }
04667 
04668     <span class="keywordflow">while</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &lt; <a class="code" href="../../d4/d8/mi_8h.html#a324">MI_MAX_FREE_LIST_HEADS</a>) {
04669 
04670         Entry = <a class="code" href="../../d1/d6/allocpag_8c.html#a8">MmNonPagedPoolFreeListHead</a>[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].Flink;
04671     
04672         <span class="keywordflow">while</span> (Entry != &amp;<a class="code" href="../../d1/d6/allocpag_8c.html#a8">MmNonPagedPoolFreeListHead</a>[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>]) {
04673     
04674             <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a36">MmProtectFreedNonPagedPool</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
04675                 <a class="code" href="../../d5/d6/iosup_8c.html#a38">MiUnProtectFreeNonPagedPool</a> ((PVOID)Entry, 0);
04676             }
04677     
04678             <span class="comment">//</span>
04679             <span class="comment">// The list is not empty, see if this one meets the physical</span>
04680             <span class="comment">// requirements.</span>
04681             <span class="comment">//</span>
04682     
04683             FreePageInfo = CONTAINING_RECORD(Entry,
04684                                              <a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html">MMFREE_POOL_ENTRY</a>,
04685                                              <a class="code" href="../../d1/d0/cmchek_8c.html#a12">List</a>);
04686     
04687             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (FreePageInfo-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o2">Signature</a> == <a class="code" href="../../d4/d8/mi_8h.html#a11">MM_FREE_POOL_SIGNATURE</a>);
04688             <span class="keywordflow">if</span> (FreePageInfo-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o1">Size</a> &gt;= SizeInPages) {
04689     
04690                 <span class="comment">//</span>
04691                 <span class="comment">// This entry has sufficient space, check to see if the</span>
04692                 <span class="comment">// pages meet the physical requirements.</span>
04693                 <span class="comment">//</span>
04694     
04695                 Va = <a class="code" href="../../d4/d8/mi_8h.html#a795">MiCheckForContiguousMemory</a> (<a class="code" href="../../d2/d1/mm_8h.html#a7">PAGE_ALIGN</a>(Entry),
04696                                                  FreePageInfo-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o1">Size</a>,
04697                                                  SizeInPages,
04698                                                  LowestPfn,
04699                                                  HighestPfn,
04700                                                  BoundaryPfn);
04701      
04702                 <span class="keywordflow">if</span> (Va != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
04703 
04704                     <span class="comment">//</span>
04705                     <span class="comment">// These pages meet the requirements.  The returned</span>
04706                     <span class="comment">// address may butt up on the end, the front or be</span>
04707                     <span class="comment">// somewhere in the middle.  Split the Entry based</span>
04708                     <span class="comment">// on which case it is.</span>
04709                     <span class="comment">//</span>
04710 
04711                     Entry = <a class="code" href="../../d2/d1/mm_8h.html#a7">PAGE_ALIGN</a>(Entry);
04712                     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a36">MmProtectFreedNonPagedPool</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
04713                         RemoveEntryList (&amp;FreePageInfo-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o0">List</a>);
04714                     }
04715                     <span class="keywordflow">else</span> {
04716                         <a class="code" href="../../d1/d6/allocpag_8c.html#a47">MiProtectedPoolRemoveEntryList</a> (&amp;FreePageInfo-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o0">List</a>);
04717                     }
04718     
04719                     <span class="comment">//</span>
04720                     <span class="comment">// Adjust the number of free pages remaining in the pool.</span>
04721                     <span class="comment">// The TotalBigPages calculation appears incorrect for the</span>
04722                     <span class="comment">// case where we're splitting a block, but it's done this</span>
04723                     <span class="comment">// way because ExFreePool corrects it when we free the</span>
04724                     <span class="comment">// fragment block below.  Likewise for</span>
04725                     <span class="comment">// MmAllocatedNonPagedPool and MmNumberOfFreeNonPagedPool</span>
04726                     <span class="comment">// which is corrected by MiFreePoolPages for the fragment.</span>
04727                     <span class="comment">//</span>
04728     
04729                     <a class="code" href="../../d2/d2/ex_2pool_8c.html#a52">NonPagedPoolDescriptor</a>.<a class="code" href="../../d4/d8/struct__POOL__DESCRIPTOR.html#o8">TotalBigPages</a> += (ULONG)FreePageInfo-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o1">Size</a>;
04730                     <a class="code" href="../../d9/d5/4_2kddata_8c.html#a52">MmAllocatedNonPagedPool</a> += FreePageInfo-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o1">Size</a>;
04731                     <a class="code" href="../../d4/d8/mi_8h.html#a630">MmNumberOfFreeNonPagedPool</a> -= FreePageInfo-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o1">Size</a>;
04732     
04733                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ((LONG)<a class="code" href="../../d4/d8/mi_8h.html#a630">MmNumberOfFreeNonPagedPool</a> &gt;= 0);
04734     
04735                     <span class="keywordflow">if</span> (Va == Entry) {
04736 
04737                         <span class="comment">//</span>
04738                         <span class="comment">// Butted against the front.</span>
04739                         <span class="comment">//</span>
04740 
04741                         AllocationPosition = 0;
04742                     }
04743                     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (((PCHAR)Va + (SizeInPages &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>)) == ((PCHAR)Entry + (FreePageInfo-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o1">Size</a> &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>))) {
04744 
04745                         <span class="comment">//</span>
04746                         <span class="comment">// Butted against the end.</span>
04747                         <span class="comment">//</span>
04748 
04749                         AllocationPosition = 2;
04750                     }
04751                     <span class="keywordflow">else</span> {
04752 
04753                         <span class="comment">//</span>
04754                         <span class="comment">// Somewhere in the middle.</span>
04755                         <span class="comment">//</span>
04756 
04757                         AllocationPosition = 1;
04758                     }
04759 
04760                     <span class="comment">//</span>
04761                     <span class="comment">// Pages are being removed from the front of</span>
04762                     <span class="comment">// the list entry and the whole list entry</span>
04763                     <span class="comment">// will be removed and then the remainder inserted.</span>
04764                     <span class="comment">//</span>
04765     
04766                     <span class="comment">//</span>
04767                     <span class="comment">// Mark start and end for the block at the top of the</span>
04768                     <span class="comment">// list.</span>
04769                     <span class="comment">//</span>
04770     
04771                     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a178">MI_IS_PHYSICAL_ADDRESS</a>(Va)) {
04772     
04773                         <span class="comment">//</span>
04774                         <span class="comment">// On certain architectures, virtual addresses</span>
04775                         <span class="comment">// may be physical and hence have no corresponding PTE.</span>
04776                         <span class="comment">//</span>
04777     
04778                         AddressIsPhysical = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04779                         Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a179">MI_CONVERT_PHYSICAL_TO_PFN</a> (Va));
04780                     } <span class="keywordflow">else</span> {
04781                         AddressIsPhysical = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04782                         PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>(Va);
04783                         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1);
04784                         Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber);
04785                     }
04786     
04787                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.VerifierAllocation == 0);
04788                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.LargeSessionAllocation == 0);
04789                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.StartOfAllocation == 0);
04790                     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.StartOfAllocation = 1;
04791     
04792                     <span class="comment">//</span>
04793                     <span class="comment">// Calculate the ending PFN address, note that since</span>
04794                     <span class="comment">// these pages are contiguous, just add to the PFN.</span>
04795                     <span class="comment">//</span>
04796     
04797                     Pfn1 += SizeInPages - 1;
04798                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.VerifierAllocation == 0);
04799                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.LargeSessionAllocation == 0);
04800                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.EndOfAllocation == 0);
04801                     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.EndOfAllocation = 1;
04802     
04803                     <span class="keywordflow">if</span> (SizeInPages == FreePageInfo-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o1">Size</a>) {
04804     
04805                         <span class="comment">//</span>
04806                         <span class="comment">// Unlock the pool and return.</span>
04807                         <span class="comment">//</span>
04808                         BaseAddress = (PVOID)Va;
04809                         <span class="keywordflow">goto</span> Done;
04810                     }
04811     
04812                     BaseAddress = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04813 
04814                     <span class="keywordflow">if</span> (AllocationPosition != 2) {
04815 
04816                         <span class="comment">//</span>
04817                         <span class="comment">// The end piece needs to be freed as the removal</span>
04818                         <span class="comment">// came from the front or the middle.</span>
04819                         <span class="comment">//</span>
04820 
04821                         BaseAddress = (PVOID)((PCHAR)Va + (SizeInPages &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>));
04822                         SpanInPages = FreePageInfo-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o1">Size</a> - SizeInPages -
04823                             (((ULONG_PTR)Va - (ULONG_PTR)Entry) &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
04824     
04825                         <span class="comment">//</span>
04826                         <span class="comment">// Mark start and end of the allocation in the PFN database.</span>
04827                         <span class="comment">//</span>
04828         
04829                         <span class="keywordflow">if</span> (AddressIsPhysical == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
04830         
04831                             <span class="comment">//</span>
04832                             <span class="comment">// On certain architectures, virtual addresses</span>
04833                             <span class="comment">// may be physical and hence have no corresponding PTE.</span>
04834                             <span class="comment">//</span>
04835         
04836                             Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a179">MI_CONVERT_PHYSICAL_TO_PFN</a> (BaseAddress));
04837                         } <span class="keywordflow">else</span> {
04838                             PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>(BaseAddress);
04839                             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1);
04840                             Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber);
04841                         }
04842         
04843                         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.VerifierAllocation == 0);
04844                         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.LargeSessionAllocation == 0);
04845                         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.StartOfAllocation == 0);
04846                         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.StartOfAllocation = 1;
04847         
04848                         <span class="comment">//</span>
04849                         <span class="comment">// Calculate the ending PTE's address, can't depend on</span>
04850                         <span class="comment">// these pages being physically contiguous.</span>
04851                         <span class="comment">//</span>
04852         
04853                         <span class="keywordflow">if</span> (AddressIsPhysical == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
04854                             Pfn1 += (SpanInPages - 1);
04855                         } <span class="keywordflow">else</span> {
04856                             PointerPte += (SpanInPages - 1);
04857                             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1);
04858                             Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber);
04859                         }
04860                         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.EndOfAllocation == 0);
04861                         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.EndOfAllocation = 1;
04862         
04863                         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (((ULONG_PTR)BaseAddress &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> -1)) == 0);
04864         
04865                         SpanInPages2 = SpanInPages;
04866                     }
04867         
04868                     BaseAddress2 = BaseAddress;
04869                     BaseAddress = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04870 
04871                     <span class="keywordflow">if</span> (AllocationPosition != 0) {
04872 
04873                         <span class="comment">//</span>
04874                         <span class="comment">// The front piece needs to be freed as the removal</span>
04875                         <span class="comment">// came from the middle or the end.</span>
04876                         <span class="comment">//</span>
04877 
04878                         BaseAddress = (PVOID)Entry;
04879 
04880                         SpanInPages = ((ULONG_PTR)Va - (ULONG_PTR)Entry) &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>;
04881     
04882                         <span class="comment">//</span>
04883                         <span class="comment">// Mark start and end of the allocation in the PFN database.</span>
04884                         <span class="comment">//</span>
04885         
04886                         <span class="keywordflow">if</span> (AddressIsPhysical == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
04887         
04888                             <span class="comment">//</span>
04889                             <span class="comment">// On certain architectures, virtual addresses</span>
04890                             <span class="comment">// may be physical and hence have no corresponding PTE.</span>
04891                             <span class="comment">//</span>
04892         
04893                             Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a179">MI_CONVERT_PHYSICAL_TO_PFN</a> (BaseAddress));
04894                         } <span class="keywordflow">else</span> {
04895                             PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>(BaseAddress);
04896                             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1);
04897                             Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber);
04898                         }
04899         
04900                         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.VerifierAllocation == 0);
04901                         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.LargeSessionAllocation == 0);
04902                         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.StartOfAllocation == 0);
04903                         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.StartOfAllocation = 1;
04904         
04905                         <span class="comment">//</span>
04906                         <span class="comment">// Calculate the ending PTE's address, can't depend on</span>
04907                         <span class="comment">// these pages being physically contiguous.</span>
04908                         <span class="comment">//</span>
04909         
04910                         <span class="keywordflow">if</span> (AddressIsPhysical == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
04911                             Pfn1 += (SpanInPages - 1);
04912                         } <span class="keywordflow">else</span> {
04913                             PointerPte += (SpanInPages - 1);
04914                             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1);
04915                             Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber);
04916                         }
04917                         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.EndOfAllocation == 0);
04918                         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.EndOfAllocation = 1;
04919         
04920                         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (((ULONG_PTR)BaseAddress &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> -1)) == 0);
04921                     }
04922         
04923                     <span class="comment">//</span>
04924                     <span class="comment">// Unlock the pool.</span>
04925                     <span class="comment">//</span>
04926     
04927                     <a class="code" href="../../d5/d8/ex_8h.html#a227">ExUnlockPool</a> (<a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, OldIrql);
04928     
04929                     ExReleaseFastMutex (&amp;<a class="code" href="../../d9/d3/dynmem_8c.html#a1">MmDynamicMemoryMutex</a>);
04930 
04931                     <span class="comment">//</span>
04932                     <span class="comment">// Free the split entry at BaseAddress back into the pool.</span>
04933                     <span class="comment">// Note that we have overcharged the pool - the entire free</span>
04934                     <span class="comment">// chunk has been billed.  Here we return the piece we</span>
04935                     <span class="comment">// didn't use and correct the momentary overbilling.</span>
04936                     <span class="comment">//</span>
04937                     <span class="comment">// The start and end allocation bits of this split entry</span>
04938                     <span class="comment">// which we just set up enable ExFreePool and his callees</span>
04939                     <span class="comment">// to correctly adjust the billing.</span>
04940                     <span class="comment">//</span>
04941     
04942                     <span class="keywordflow">if</span> (BaseAddress) {
04943                         <a class="code" href="../../d5/d8/ex_8h.html#a216">ExInsertPoolTag</a> ('tnoC',
04944                                          BaseAddress,
04945                                          SpanInPages &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>,
04946                                          <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>);
04947                         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (BaseAddress);
04948                     }
04949                     <span class="keywordflow">if</span> (BaseAddress2) {
04950                         <a class="code" href="../../d5/d8/ex_8h.html#a216">ExInsertPoolTag</a> ('tnoC',
04951                                          BaseAddress2,
04952                                          SpanInPages2 &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>,
04953                                          <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>);
04954                         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (BaseAddress2);
04955                     }
04956                     BaseAddress = Va;
04957                     <span class="keywordflow">goto</span> Done1;
04958                 }
04959             }
04960             Entry = FreePageInfo-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o0">List</a>.Flink;
04961             <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a36">MmProtectFreedNonPagedPool</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
04962                 <a class="code" href="../../d5/d6/iosup_8c.html#a37">MiProtectFreeNonPagedPool</a> ((PVOID)FreePageInfo,
04963                                            (ULONG)FreePageInfo-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o1">Size</a>);
04964             }
04965         }
04966         <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> += 1;
04967     }
04968 
04969     <span class="comment">//</span>
04970     <span class="comment">// No entry was found in free nonpaged pool that meets the requirements.</span>
04971     <span class="comment">// Search the PFN database for pages that meet the requirements.</span>
04972     <span class="comment">//</span>
04973 
04974     start = 0;
04975     <span class="keywordflow">do</span> {
04976 
04977         count = <a class="code" href="../../d2/d1/mm_8h.html#a131">MmPhysicalMemoryBlock</a>-&gt;<a class="code" href="../../d3/d5/struct__PHYSICAL__MEMORY__DESCRIPTOR.html#o2">Run</a>[start].<a class="code" href="../../d5/d5/struct__PHYSICAL__MEMORY__RUN.html#o1">PageCount</a>;
04978         Page = <a class="code" href="../../d2/d1/mm_8h.html#a131">MmPhysicalMemoryBlock</a>-&gt;<a class="code" href="../../d3/d5/struct__PHYSICAL__MEMORY__DESCRIPTOR.html#o2">Run</a>[start].<a class="code" href="../../d5/d5/struct__PHYSICAL__MEMORY__RUN.html#o0">BasePage</a>;
04979 
04980         <span class="comment">//</span>
04981         <span class="comment">// Close the gaps, then examine the range for a fit.</span>
04982         <span class="comment">//</span>
04983 
04984         LastPage = Page + count; 
04985 
04986         <span class="keywordflow">if</span> (LastPage - 1 &gt; HighestPfn) {
04987             LastPage = HighestPfn + 1;
04988         }
04989     
04990         <span class="keywordflow">if</span> (Page &lt; LowestPfn) {
04991             Page = LowestPfn;
04992         }
04993 
04994         <span class="keywordflow">if</span> ((count != 0) &amp;&amp; (Page + SizeInPages &lt;= LastPage)) {
04995     
04996             <span class="comment">//</span>
04997             <span class="comment">// A fit may be possible in this run, check whether the pages</span>
04998             <span class="comment">// are on the right list.</span>
04999             <span class="comment">//</span>
05000 
05001             found = 0;
05002 
05003             Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (Page);
05004             <a class="code" href="../../d4/d8/mi_8h.html#a130">LOCK_PFN2</a> (OldIrql2);
05005             <span class="keywordflow">do</span> {
05006 
05007                 <span class="keywordflow">if</span> ((Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PageLocation == <a class="code" href="../../d2/d1/mm_8h.html#a345a171">ZeroedPageList</a>) ||
05008                     (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PageLocation == <a class="code" href="../../d2/d1/mm_8h.html#a345a172">FreePageList</a>) ||
05009                     (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PageLocation == <a class="code" href="../../d2/d1/mm_8h.html#a345a173">StandbyPageList</a>)) {
05010 
05011                     <span class="keywordflow">if</span> ((Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o5">u1</a>.Flink != 0) &amp;&amp;
05012                         (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.Blink != 0) &amp;&amp;
05013                         (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount == 0)) {
05014     
05015                         <span class="comment">//</span>
05016                         <span class="comment">// Before starting a new run, ensure that it</span>
05017                         <span class="comment">// can satisfy the boundary requirements (if any).</span>
05018                         <span class="comment">//</span>
05019                         
05020                         <span class="keywordflow">if</span> ((found == 0) &amp;&amp; (BoundaryPfn != 0)) {
05021                             <span class="keywordflow">if</span> (((Page ^ (Page + SizeInPages - 1)) &amp; BoundaryMask) != 0) {
05022                                 <span class="comment">//</span>
05023                                 <span class="comment">// This run's physical address does not meet the</span>
05024                                 <span class="comment">// requirements.</span>
05025                                 <span class="comment">//</span>
05026 
05027                                 <span class="keywordflow">goto</span> NextPage;
05028                             }
05029                         }
05030 
05031                         found += 1;
05032                         <span class="keywordflow">if</span> (found == SizeInPages) {
05033 
05034                             <span class="comment">//</span>
05035                             <span class="comment">// A match has been found, remove these</span>
05036                             <span class="comment">// pages, add them to the free pool and</span>
05037                             <span class="comment">// return.</span>
05038                             <span class="comment">//</span>
05039 
05040                             Page = 1 + Page - found;
05041 
05042                             <span class="comment">//</span>
05043                             <span class="comment">// Try to find system PTES to expand the pool into.</span>
05044                             <span class="comment">//</span>
05045 
05046                             PointerPte = <a class="code" href="../../d0/d9/sysptes_8c.html#a25">MiReserveSystemPtes</a> ((ULONG)SizeInPages,
05047                                                               <a class="code" href="../../d4/d8/mi_8h.html#a1003a770">NonPagedPoolExpansion</a>,
05048                                                               0,
05049                                                               0,
05050                                                               <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
05051 
05052                             <span class="keywordflow">if</span> (PointerPte == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05053                                 <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrql2);
05054                                 <span class="keywordflow">goto</span> Done;
05055                             }
05056 
05057                             <a class="code" href="../../d8/d5/kddata_8c.html#a42">MmResidentAvailablePages</a> -= SizeInPages;
05058                             <a class="code" href="../../d4/d8/mi_8h.html#a322">MM_BUMP_COUNTER</a>(3, SizeInPages);
05059                             <a class="code" href="../../d6/d1/mmquota_8c.html#a18">MiChargeCommitmentCantExpand</a> (SizeInPages, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
05060                             <a class="code" href="../../d4/d8/mi_8h.html#a254">MM_TRACK_COMMIT</a> (<a class="code" href="../../d4/d8/mi_8h.html#a266">MM_DBG_COMMIT_CONTIGUOUS_PAGES</a>, SizeInPages);
05061                             BaseAddress = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a> (PointerPte);
05062                             PageColor = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a125">MI_GET_PAGE_COLOR_FROM_VA</a>(BaseAddress);
05063                             TempPte = <a class="code" href="../../d4/d2/datalpha_8c.html#a2">ValidKernelPte</a>;
05064                             <a class="code" href="../../d9/d5/4_2kddata_8c.html#a52">MmAllocatedNonPagedPool</a> += SizeInPages;
05065                             <a class="code" href="../../d2/d2/ex_2pool_8c.html#a52">NonPagedPoolDescriptor</a>.<a class="code" href="../../d4/d8/struct__POOL__DESCRIPTOR.html#o8">TotalBigPages</a> += (ULONG)SizeInPages;
05066                             Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (Page - 1);
05067 
05068                             <span class="keywordflow">do</span> {
05069                                 Pfn1 += 1;
05070                                 <span class="keywordflow">if</span> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PageLocation == <a class="code" href="../../d2/d1/mm_8h.html#a345a173">StandbyPageList</a>) {
05071                                     <a class="code" href="../../d7/d5/pfnlist_8c.html#a11">MiUnlinkPageFromList</a> (Pfn1);
05072                                     <a class="code" href="../../d0/d2/mmsup_8c.html#a15">MiRestoreTransitionPte</a> (Page);
05073                                 } <span class="keywordflow">else</span> {
05074                                     <a class="code" href="../../d7/d5/pfnlist_8c.html#a12">MiUnlinkFreeOrZeroedPage</a> (Page);
05075                                 }
05076 
05077                                 <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a122">MI_CHECK_PAGE_ALIGNMENT</a>(Page,
05078                                                         PageColor &amp; <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a57">MM_COLOR_MASK</a>);
05079                                 Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PageColor = PageColor &amp; <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a57">MM_COLOR_MASK</a>;
05080                                 PageColor += 1;
05081                                 TempPte.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber = Page;
05082                                 <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a186">MI_WRITE_VALID_PTE</a> (PointerPte, TempPte);
05083 
05084                                 Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount = 1;
05085                                 Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount = 1;
05086                                 Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a> = PointerPte;
05087                                 Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o16">OriginalPte</a>.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a95">MM_DEMAND_ZERO_WRITE_PTE</a>;
05088                                 Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o17">PteFrame</a> = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a182">MI_GET_PAGE_FRAME_FROM_PTE</a> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>(PointerPte));
05089                                 Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PageLocation = <a class="code" href="../../d2/d1/mm_8h.html#a345a177">ActiveAndValid</a>;
05090                                 Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.VerifierAllocation = 0;
05091                                 Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.LargeSessionAllocation = 0;
05092 
05093                                 <span class="keywordflow">if</span> (found == SizeInPages) {
05094                                     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.StartOfAllocation = 1;
05095                                 }
05096                                 PointerPte += 1;
05097                                 Page += 1;
05098                                 found -= 1;
05099                             } <span class="keywordflow">while</span> (found);
05100 
05101                             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.EndOfAllocation = 1;
05102                             <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrql2);
05103                             <span class="keywordflow">goto</span> Done;
05104                         }
05105                     } <span class="keywordflow">else</span> {
05106                         found = 0;
05107                     }
05108                 } <span class="keywordflow">else</span> {
05109                     found = 0;
05110                 }
05111 NextPage:
05112                 Page += 1;
05113                 Pfn1 += 1;
05114             } <span class="keywordflow">while</span> (Page &lt; LastPage);
05115             <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrql2);
05116         }
05117         start += 1;
05118     } <span class="keywordflow">while</span> (start != <a class="code" href="../../d2/d1/mm_8h.html#a131">MmPhysicalMemoryBlock</a>-&gt;<a class="code" href="../../d3/d5/struct__PHYSICAL__MEMORY__DESCRIPTOR.html#o0">NumberOfRuns</a>);
05119 
05120 Done:
05121 
05122     <a class="code" href="../../d5/d8/ex_8h.html#a227">ExUnlockPool</a> (<a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, OldIrql);
05123 
05124     ExReleaseFastMutex (&amp;<a class="code" href="../../d9/d3/dynmem_8c.html#a1">MmDynamicMemoryMutex</a>);
05125 
05126 Done1:
05127 
05128     <a class="code" href="../../d5/d6/iosup_8c.html#a81">MmUnlockPagableImageSection</a> (<a class="code" href="../../d5/d8/ex_8h.html#a166">ExPageLockHandle</a>);
05129 
05130     <span class="keywordflow">if</span> (BaseAddress) {
05131 
05132         <a class="code" href="../../d1/d6/allocpag_8c.html#a3">MiInsertContiguousTag</a> (BaseAddress,
05133                                SizeInPages &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>,
05134                                CallingAddress);
05135 
05136         <a class="code" href="../../d5/d8/ex_8h.html#a216">ExInsertPoolTag</a> ('tnoC',
05137                          BaseAddress,
05138                          SizeInPages &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>,
05139                          <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>);
05140     }
05141 
05142     <span class="keywordflow">return</span> BaseAddress;
05143 }
05144 
05145 LOGICAL
<a name="l05146"></a><a class="code" href="../../d1/d6/allocpag_8c.html#a65">05146</a> <a class="code" href="../../d1/d6/allocpag_8c.html#a65">MmIsHydraAddress</a> (
05147     IN PVOID VirtualAddress
05148     )
05149 
05150 <span class="comment">/*++</span>
05151 <span class="comment"></span>
05152 <span class="comment">Routine Description:</span>
05153 <span class="comment"></span>
05154 <span class="comment">    This function returns TRUE if a Hydra address is specified.</span>
05155 <span class="comment">    FALSE is returned if not.</span>
05156 <span class="comment"></span>
05157 <span class="comment">Arguments:</span>
05158 <span class="comment"></span>
05159 <span class="comment">    VirtualAddress - Supplies the address in question.</span>
05160 <span class="comment"></span>
05161 <span class="comment">Return Value:</span>
05162 <span class="comment"></span>
05163 <span class="comment">    See above.</span>
05164 <span class="comment"></span>
05165 <span class="comment">Environment:</span>
05166 <span class="comment"></span>
05167 <span class="comment">    Kernel mode.  Note this routine is present and nonpaged for both Hydra</span>
05168 <span class="comment">    and non-Hydra systems.</span>
05169 <span class="comment"></span>
05170 <span class="comment">--*/</span>
05171 
05172 {
05173     <span class="keywordflow">return</span> <a class="code" href="../../d4/d8/mi_8h.html#a354">MI_IS_SESSION_ADDRESS</a> (VirtualAddress);
05174 }
05175 
05176 LOGICAL
<a name="l05177"></a><a class="code" href="../../d1/d6/allocpag_8c.html#a66">05177</a> <a class="code" href="../../d1/d6/allocpag_8c.html#a66">MmIsSpecialPoolAddressFree</a> (
05178     IN PVOID VirtualAddress
05179     )
05180 
05181 <span class="comment">/*++</span>
05182 <span class="comment"></span>
05183 <span class="comment">Routine Description:</span>
05184 <span class="comment"></span>
05185 <span class="comment">    This function returns TRUE if a special pool address has been freed.</span>
05186 <span class="comment">    FALSE is returned if it is inuse (ie: the caller overran).</span>
05187 <span class="comment"></span>
05188 <span class="comment">Arguments:</span>
05189 <span class="comment"></span>
05190 <span class="comment">    VirtualAddress - Supplies the special pool address in question.</span>
05191 <span class="comment"></span>
05192 <span class="comment">Return Value:</span>
05193 <span class="comment"></span>
05194 <span class="comment">    See above.</span>
05195 <span class="comment"></span>
05196 <span class="comment">Environment:</span>
05197 <span class="comment"></span>
05198 <span class="comment">    Kernel mode.</span>
05199 <span class="comment"></span>
05200 <span class="comment">--*/</span>
05201 
05202 {
05203     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
05204 
05205     <span class="comment">//</span>
05206     <span class="comment">// Caller must check that the address in in special pool.</span>
05207     <span class="comment">//</span>
05208 
05209     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (VirtualAddress &gt;= <a class="code" href="../../d2/d1/mm_8h.html#a160">MmSpecialPoolStart</a> &amp;&amp; VirtualAddress &lt; <a class="code" href="../../d2/d1/mm_8h.html#a161">MmSpecialPoolEnd</a>);
05210 
05211     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>(VirtualAddress);
05212 
05213     <span class="comment">//</span>
05214     <span class="comment">// Take advantage of the fact that adjacent PTEs have the paged/nonpaged</span>
05215     <span class="comment">// bits set when in use and these bits are cleared on free.  Note also</span>
05216     <span class="comment">// that freed pages get their PTEs chained together through PageFileHigh.</span>
05217     <span class="comment">//</span>
05218 
05219     <span class="keywordflow">if</span> ((PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.PageFileHigh == <a class="code" href="../../d4/d8/mi_8h.html#a4">MI_SPECIAL_POOL_PTE_PAGABLE</a>) ||
05220         (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.PageFileHigh == <a class="code" href="../../d4/d8/mi_8h.html#a5">MI_SPECIAL_POOL_PTE_NONPAGABLE</a>)) {
05221             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
05222     }
05223 
05224     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
05225 }
05226 
05227 LOGICAL
<a name="l05228"></a><a class="code" href="../../d1/d6/allocpag_8c.html#a67">05228</a> <a class="code" href="../../d1/d6/allocpag_8c.html#a67">MmProtectSpecialPool</a> (
05229     IN PVOID VirtualAddress,
05230     IN ULONG NewProtect
05231     )
05232 
05233 <span class="comment">/*++</span>
05234 <span class="comment"></span>
05235 <span class="comment">Routine Description:</span>
05236 <span class="comment"></span>
05237 <span class="comment">    This function protects a special pool allocation.</span>
05238 <span class="comment"></span>
05239 <span class="comment">Arguments:</span>
05240 <span class="comment"></span>
05241 <span class="comment">    VirtualAddress - Supplies the special pool address to protect.</span>
05242 <span class="comment"></span>
05243 <span class="comment">    NewProtect - Supplies the protection to set the pages to (PAGE_XX).</span>
05244 <span class="comment"></span>
05245 <span class="comment">Return Value:</span>
05246 <span class="comment"></span>
05247 <span class="comment">    TRUE if the protection was successfully applied, FALSE if not.</span>
05248 <span class="comment"></span>
05249 <span class="comment">Environment:</span>
05250 <span class="comment"></span>
05251 <span class="comment">    Kernel mode, IRQL at APC_LEVEL or below for pagable pool, DISPATCH or</span>
05252 <span class="comment">    below for nonpagable pool.</span>
05253 <span class="comment"></span>
05254 <span class="comment">    Note that setting an allocation to NO_ACCESS implies that an accessible</span>
05255 <span class="comment">    protection must be applied by the caller prior to this allocation being</span>
05256 <span class="comment">    freed.</span>
05257 <span class="comment"></span>
05258 <span class="comment">    Note this is a nonpagable wrapper so that machines without special pool</span>
05259 <span class="comment">    can still support code attempting to protect special pool at</span>
05260 <span class="comment">    DISPATCH_LEVEL.</span>
05261 <span class="comment"></span>
05262 <span class="comment">--*/</span>
05263 
05264 {
05265     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d6/allocpag_8c.html#a26">MiSpecialPoolPtes</a> == 0) {
05266 
05267         <span class="comment">//</span>
05268         <span class="comment">// The special pool allocation code was never initialized.</span>
05269         <span class="comment">//</span>
05270 
05271         <span class="keywordflow">return</span> (ULONG)-1;
05272     }
05273 
05274     <span class="keywordflow">return</span> <a class="code" href="../../d1/d6/allocpag_8c.html#a42">MiProtectSpecialPool</a> (VirtualAddress, NewProtect);
05275 }
05276 
05277 LOGICAL
<a name="l05278"></a><a class="code" href="../../d1/d6/allocpag_8c.html#a42">05278</a> <a class="code" href="../../d1/d6/allocpag_8c.html#a42">MiProtectSpecialPool</a> (
05279     IN PVOID VirtualAddress,
05280     IN ULONG NewProtect
05281     )
05282 
05283 <span class="comment">/*++</span>
05284 <span class="comment"></span>
05285 <span class="comment">Routine Description:</span>
05286 <span class="comment"></span>
05287 <span class="comment">    This function protects a special pool allocation.</span>
05288 <span class="comment"></span>
05289 <span class="comment">Arguments:</span>
05290 <span class="comment"></span>
05291 <span class="comment">    VirtualAddress - Supplies the special pool address to protect.</span>
05292 <span class="comment"></span>
05293 <span class="comment">    NewProtect - Supplies the protection to set the pages to (PAGE_XX).</span>
05294 <span class="comment"></span>
05295 <span class="comment">Return Value:</span>
05296 <span class="comment"></span>
05297 <span class="comment">    TRUE if the protection was successfully applied, FALSE if not.</span>
05298 <span class="comment"></span>
05299 <span class="comment">Environment:</span>
05300 <span class="comment"></span>
05301 <span class="comment">    Kernel mode, IRQL at APC_LEVEL or below for pagable pool, DISPATCH or</span>
05302 <span class="comment">    below for nonpagable pool.</span>
05303 <span class="comment"></span>
05304 <span class="comment">    Note that setting an allocation to NO_ACCESS implies that an accessible</span>
05305 <span class="comment">    protection must be applied by the caller prior to this allocation being</span>
05306 <span class="comment">    freed.</span>
05307 <span class="comment"></span>
05308 <span class="comment">--*/</span>
05309 
05310 {
05311     KIRQL OldIrql;
05312     KIRQL OldIrql2;
05313     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> PteContents;
05314     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> NewPteContents;
05315     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> PreviousPte;
05316     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
05317     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn1;
05318     ULONG ProtectionMask;
05319     <a class="code" href="../../d4/d8/mi_8h.html#a435">WSLE_NUMBER</a> WsIndex;
05320     LOGICAL SystemWsLocked;
05321 
05322     <span class="keywordflow">if</span> ((VirtualAddress &lt; MmSpecialPoolStart) || (VirtualAddress &gt;= <a class="code" href="../../d2/d1/mm_8h.html#a161">MmSpecialPoolEnd</a>)) {
05323         <span class="keywordflow">return</span> (ULONG)-1;
05324     }
05325 
05326     <span class="keywordflow">try</span> {
05327         ProtectionMask = <a class="code" href="../../d0/d2/mmsup_8c.html#a5">MiMakeProtectionMask</a> (NewProtect);
05328     } except (<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
05329         <span class="keywordflow">return</span> (ULONG)-1;
05330     }
05331 
05332     SystemWsLocked = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
05333 
05334     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (VirtualAddress);
05335 
05336     <span class="keywordflow">if</span> ((PointerPte + 1)-&gt;u.Soft.PageFileHigh == <a class="code" href="../../d4/d8/mi_8h.html#a4">MI_SPECIAL_POOL_PTE_PAGABLE</a>) {
05337         <a class="code" href="../../d4/d8/mi_8h.html#a144">LOCK_SYSTEM_WS</a> (OldIrql);
05338         SystemWsLocked = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
05339     }
05340 
05341     PteContents = *PointerPte;
05342 
05343     <span class="keywordflow">if</span> (ProtectionMask == <a class="code" href="../../d4/d8/mi_8h.html#a46">MM_NOACCESS</a>) {
05344 
05345         <span class="keywordflow">if</span> ((PointerPte + 1)-&gt;u.Soft.PageFileHigh == <a class="code" href="../../d4/d8/mi_8h.html#a4">MI_SPECIAL_POOL_PTE_PAGABLE</a>) {
05346 retry1:
05347             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (SystemWsLocked == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
05348             <span class="keywordflow">if</span> (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1) {
05349 
05350                 Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber);
05351                 WsIndex = Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o5">u1</a>.WsIndex;
05352                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (WsIndex != 0);
05353                 Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o16">OriginalPte</a>.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Protection = ProtectionMask;
05354                 <a class="code" href="../../d4/d0/wslist_8c.html#a23">MiRemovePageFromWorkingSet</a> (PointerPte,
05355                                             Pfn1,
05356                                             &amp;<a class="code" href="../../d6/d8/sysinfo_8c.html#a21">MmSystemCacheWs</a>);
05357             }
05358             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Transition == 1) {
05359 
05360                 <a class="code" href="../../d4/d8/mi_8h.html#a130">LOCK_PFN2</a> (OldIrql2);
05361 
05362                 PteContents = *(<span class="keyword">volatile</span> <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> *)PointerPte;
05363 
05364                 <span class="keywordflow">if</span> (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Transition == 0) {
05365                     <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrql2);
05366                     <span class="keywordflow">goto</span> retry1;
05367                 }
05368 
05369                 Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Trans.PageFrameNumber);
05370                 Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o16">OriginalPte</a>.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Protection = ProtectionMask;
05371                 PointerPte-&gt;u.Soft.Protection = ProtectionMask;
05372                 <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a>(OldIrql2);
05373             }
05374             <span class="keywordflow">else</span> {
05375     
05376                 <span class="comment">//</span>
05377                 <span class="comment">// Must be page file space or demand zero.</span>
05378                 <span class="comment">//</span>
05379     
05380                 PointerPte-&gt;u.Soft.Protection = ProtectionMask;
05381             }
05382             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (SystemWsLocked == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
05383             <a class="code" href="../../d4/d8/mi_8h.html#a145">UNLOCK_SYSTEM_WS</a> (OldIrql);
05384         }
05385         <span class="keywordflow">else</span> {
05386 
05387             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (SystemWsLocked == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
05388 
05389             <span class="comment">//</span>
05390             <span class="comment">// Make it no access regardless of its previous protection state.</span>
05391             <span class="comment">// Note that the page frame number is preserved.</span>
05392             <span class="comment">//</span>
05393 
05394             PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid = 0;
05395             PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Prototype = 0;
05396             PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Protection = <a class="code" href="../../d4/d8/mi_8h.html#a46">MM_NOACCESS</a>;
05397     
05398             Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber);
05399 
05400             <a class="code" href="../../d4/d8/mi_8h.html#a130">LOCK_PFN2</a> (OldIrql2);
05401 
05402             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o16">OriginalPte</a>.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Protection = ProtectionMask;
05403 
05404             PreviousPte.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Flush = <a class="code" href="../../d0/d6/ppc_2flushtb_8c.html#a2">KeFlushSingleTb</a> (VirtualAddress,
05405                                                    <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
05406                                                    <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
05407                                                    (PHARDWARE_PTE)PointerPte,
05408                                                    PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Flush);
05409 
05410             <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a177">MI_CAPTURE_DIRTY_BIT_TO_PFN</a> (&amp;PreviousPte, Pfn1);
05411 
05412             <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a>(OldIrql2);
05413         }
05414 
05415         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
05416     }
05417 
05418     <span class="comment">//</span>
05419     <span class="comment">// No guard pages, noncached pages or copy-on-write for special pool.</span>
05420     <span class="comment">//</span>
05421 
05422     <span class="keywordflow">if</span> ((ProtectionMask &gt;= <a class="code" href="../../d4/d8/mi_8h.html#a43">MM_NOCACHE</a>) || (ProtectionMask == <a class="code" href="../../d4/d8/mi_8h.html#a40">MM_WRITECOPY</a>) || (ProtectionMask == <a class="code" href="../../d4/d8/mi_8h.html#a42">MM_EXECUTE_WRITECOPY</a>)) {
05423         <span class="keywordflow">if</span> (SystemWsLocked == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
05424             <a class="code" href="../../d4/d8/mi_8h.html#a145">UNLOCK_SYSTEM_WS</a> (OldIrql);
05425         }
05426         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
05427     }
05428 
05429     <span class="comment">//</span>
05430     <span class="comment">// Set accessible permissions - the page may already be protected or not.</span>
05431     <span class="comment">//</span>
05432 
05433     <span class="keywordflow">if</span> ((PointerPte + 1)-&gt;u.Soft.PageFileHigh == <a class="code" href="../../d4/d8/mi_8h.html#a5">MI_SPECIAL_POOL_PTE_NONPAGABLE</a>) {
05434 
05435         Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber);
05436         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o16">OriginalPte</a>.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Protection = ProtectionMask;
05437 
05438         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a105">MI_MAKE_VALID_PTE</a> (NewPteContents,
05439                            PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber,
05440                            ProtectionMask,
05441                            PointerPte);
05442 
05443         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a188">MI_WRITE_VALID_PTE_NEW_PROTECTION</a> (PointerPte, NewPteContents);
05444 
05445         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (SystemWsLocked == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
05446         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
05447     }
05448 
05449 retry2:
05450 
05451     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (SystemWsLocked == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
05452 
05453     <span class="keywordflow">if</span> (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1) {
05454 
05455         Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber);
05456         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o5">u1</a>.WsIndex != 0);
05457 
05458         <a class="code" href="../../d4/d8/mi_8h.html#a130">LOCK_PFN2</a> (OldIrql2);
05459 
05460         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o16">OriginalPte</a>.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Protection = ProtectionMask;
05461 
05462         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a105">MI_MAKE_VALID_PTE</a> (PteContents,
05463                            PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber,
05464                            ProtectionMask,
05465                            PointerPte);
05466 
05467         PreviousPte.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Flush = <a class="code" href="../../d0/d6/ppc_2flushtb_8c.html#a2">KeFlushSingleTb</a> (VirtualAddress,
05468                               <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
05469                               <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
05470                               (PHARDWARE_PTE)PointerPte,
05471                               PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Flush);
05472 
05473         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a177">MI_CAPTURE_DIRTY_BIT_TO_PFN</a> (&amp;PreviousPte, Pfn1);
05474 
05475         <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrql2);
05476     }
05477     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Transition == 1) {
05478 
05479         <a class="code" href="../../d4/d8/mi_8h.html#a130">LOCK_PFN2</a> (OldIrql2);
05480 
05481         PteContents = *(<span class="keyword">volatile</span> <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> *)PointerPte;
05482 
05483         <span class="keywordflow">if</span> (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Transition == 0) {
05484             <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrql2);
05485             <span class="keywordflow">goto</span> retry2;
05486         }
05487 
05488         Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Trans.PageFrameNumber);
05489         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o16">OriginalPte</a>.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Protection = ProtectionMask;
05490         PointerPte-&gt;u.Soft.Protection = ProtectionMask;
05491         <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a>(OldIrql2);
05492     }
05493     <span class="keywordflow">else</span> {
05494 
05495         <span class="comment">//</span>
05496         <span class="comment">// Must be page file space or demand zero.</span>
05497         <span class="comment">//</span>
05498 
05499         PointerPte-&gt;u.Soft.Protection = ProtectionMask;
05500     }
05501 
05502     <a class="code" href="../../d4/d8/mi_8h.html#a145">UNLOCK_SYSTEM_WS</a> (OldIrql);
05503     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
05504 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:39:14 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
