<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: chandler.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>chandler.c</h1><a href="../../d1/d6/ia64_2chandler_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1995  Intel Corporation</span>
00004 <span class="comment">Copyright (c) 1990  Microsoft Corporation</span>
00005 <span class="comment"></span>
00006 <span class="comment">Module Name:</span>
00007 <span class="comment"></span>
00008 <span class="comment">    chandler.c</span>
00009 <span class="comment"></span>
00010 <span class="comment">Abstract:</span>
00011 <span class="comment"></span>
00012 <span class="comment">    This module implements the C specific exception handler that provides</span>
00013 <span class="comment">    structured condition handling for the C language.</span>
00014 <span class="comment"></span>
00015 <span class="comment">Author:</span>
00016 <span class="comment"></span>
00017 <span class="comment">    William K. Cheung (wcheung) 29-Dec-1995</span>
00018 <span class="comment"></span>
00019 <span class="comment">    Based on the version by David N. Cutler (davec) 11-Sep-1990</span>
00020 <span class="comment"></span>
00021 <span class="comment">Environment:</span>
00022 <span class="comment"></span>
00023 <span class="comment">    Any mode.</span>
00024 <span class="comment"></span>
00025 <span class="comment">Revision History:</span>
00026 <span class="comment"></span>
00027 <span class="comment">--*/</span>
00028 
00029 <span class="preprocessor">#include "nt.h"</span>
00030 
00031 <span class="comment">//</span>
00032 <span class="comment">// Define procedure prototypes for exception filter and termination handler</span>
00033 <span class="comment">// execution routines defined in jmpunwnd.s.</span>
00034 <span class="comment">//</span>
00035 
00036 LONG
00037 <a class="code" href="../../d3/d6/ppc_2chandler_8c.html#a0">__C_ExecuteExceptionFilter</a> (
00038     ULONGLONG MemoryStack,
00039     ULONGLONG BackingStore,
00040     NTSTATUS ExceptionCode,
00041     PEXCEPTION_POINTERS ExceptionPointers,
00042     ULONGLONG ExceptionFilter,
00043     ULONGLONG GlobalPointer
00044     );
00045 
00046 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00047 <a class="code" href="../../d3/d6/ppc_2chandler_8c.html#a1">__C_ExecuteTerminationHandler</a> (
00048     ULONGLONG MemoryStack,
00049     ULONGLONG BackingStore,
00050     BOOLEAN AbnormalTermination,
00051     ULONGLONG TerminationHandler,
00052     ULONGLONG GlobalPointer
00053     );
00054 
00055 
00056 EXCEPTION_DISPOSITION
<a name="l00057"></a><a class="code" href="../../d1/d6/ia64_2chandler_8c.html#a2">00057</a> <a class="code" href="../../d3/d6/ppc_2chandler_8c.html#a2">__C_specific_handler</a> (
00058     IN PEXCEPTION_RECORD ExceptionRecord,
00059     IN <span class="keywordtype">unsigned</span> __int64 MemoryStackFp,
00060     IN <span class="keywordtype">unsigned</span> __int64 BackingStoreFp,
00061     IN OUT PCONTEXT ContextRecord,
00062     IN OUT PDISPATCHER_CONTEXT DispatcherContext,
00063     IN <span class="keywordtype">unsigned</span> __int64 GlobalPointer
00064     )
00065 
00066 <span class="comment">/*++</span>
00067 <span class="comment"></span>
00068 <span class="comment">Routine Description:</span>
00069 <span class="comment"></span>
00070 <span class="comment">    This function scans the scope tables associated with the specified</span>
00071 <span class="comment">    procedure and calls exception and termination handlers as necessary.</span>
00072 <span class="comment"></span>
00073 <span class="comment">Arguments:</span>
00074 <span class="comment"></span>
00075 <span class="comment">    ExceptionRecord - Supplies a pointer to an exception record.</span>
00076 <span class="comment"></span>
00077 <span class="comment">    MemoryStackFp - Supplies a pointer to memory stack frame of the </span>
00078 <span class="comment">        establisher function.</span>
00079 <span class="comment"></span>
00080 <span class="comment">    BackingStoreFp - Supplies a pointer to RSE stack frame of the </span>
00081 <span class="comment">        establisher function.</span>
00082 <span class="comment"></span>
00083 <span class="comment">    ContextRecord - Supplies a pointer to a context record.</span>
00084 <span class="comment"></span>
00085 <span class="comment">    DispatcherContext - Supplies a pointer to the exception dispatcher or</span>
00086 <span class="comment">        unwind dispatcher context.</span>
00087 <span class="comment"></span>
00088 <span class="comment">Return Value:</span>
00089 <span class="comment"></span>
00090 <span class="comment">    If the exception is handled by one of the exception filter routines, then</span>
00091 <span class="comment">    there is no return from this routine and RtlUnwind is called. Otherwise,</span>
00092 <span class="comment">    an exception disposition value of continue execution or continue search is</span>
00093 <span class="comment">    returned.</span>
00094 <span class="comment"></span>
00095 <span class="comment">--*/</span>
00096 
00097 {
00098     ULONGLONG ImageBase;
00099     ULONGLONG ControlPc;
00100     ULONGLONG TargetPc;
00101     ULONGLONG Handler;
00102     EXCEPTION_POINTERS ExceptionPointers;
00103     PRUNTIME_FUNCTION FunctionEntry;
00104     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
00105     ULONG <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
00106     PSCOPE_TABLE ScopeTable;
00107     LONG Value;
00108 
00109     <span class="comment">//</span>
00110     <span class="comment">// Get address of where control left the establisher, the address of the</span>
00111     <span class="comment">// function table entry that describes the function, and the address of</span>
00112     <span class="comment">// the scope table.</span>
00113     <span class="comment">//</span>
00114 
00115     FunctionEntry = DispatcherContext-&gt;FunctionEntry;
00116     ImageBase = DispatcherContext-&gt;ImageBase;
00117     ScopeTable = (PSCOPE_TABLE) (ImageBase + *(PULONG) 
00118                      GetLanguageSpecificData(FunctionEntry, ImageBase));
00119 
00120     ControlPc = DispatcherContext-&gt;ControlPc - ImageBase;
00121 
00122     <span class="comment">//</span>
00123     <span class="comment">// If an unwind is not in progress, then scan the scope table and call</span>
00124     <span class="comment">// the appropriate exception filter routines. Otherwise, scan the scope</span>
00125     <span class="comment">// table and call the appropriate termination handlers using the target</span>
00126     <span class="comment">// PC obtained from the context record.</span>
00127     <span class="comment">// are called.</span>
00128     <span class="comment">//</span>
00129 
00130     <span class="keywordflow">if</span> (IS_DISPATCHING(ExceptionRecord-&gt;ExceptionFlags)) {
00131 
00132         <span class="comment">//</span>
00133         <span class="comment">// Scan the scope table and call the appropriate exception filter</span>
00134         <span class="comment">// routines.</span>
00135         <span class="comment">//</span>
00136 
00137         ExceptionPointers.ExceptionRecord = ExceptionRecord;
00138         ExceptionPointers.ContextRecord = ContextRecord;
00139         <span class="keywordflow">for</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = 0; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &lt; ScopeTable-&gt;Count; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> += 1) {
00140             <span class="keywordflow">if</span> ((ControlPc &gt;= ScopeTable-&gt;ScopeRecord[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].BeginAddress) &amp;&amp;
00141                 (ControlPc &lt; ScopeTable-&gt;ScopeRecord[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].EndAddress) &amp;&amp;
00142                 (ScopeTable-&gt;ScopeRecord[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].JumpTarget != 0)) {
00143 
00144                 <span class="comment">//</span>
00145                 <span class="comment">// Call the exception filter routine.</span>
00146                 <span class="comment">//</span>
00147 
00148                 ULONG <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> = ScopeTable-&gt;ScopeRecord[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].HandlerAddress;
00149 
00150                 <span class="keywordflow">switch</span> (<a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> &amp; 0x7) {
00151 
00152                 <span class="keywordflow">case</span> 7:
00153                     Value = <a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>;
00154                     <span class="keywordflow">break</span>;
00155 
00156                 <span class="keywordflow">case</span> 5:
00157                     Value = <a class="code" href="../../d6/d7/halmips_8h.html#a34">EXCEPTION_CONTINUE_SEARCH</a>;
00158                     <span class="keywordflow">break</span>;
00159 
00160                 <span class="keywordflow">case</span> 3:
00161                     Value = <a class="code" href="../../d6/d7/halmips_8h.html#a35">EXCEPTION_CONTINUE_EXECUTION</a>;
00162                     <span class="keywordflow">break</span>;
00163 
00164                 <span class="keywordflow">default</span>:
00165                     Value = <a class="code" href="../../d3/d6/ppc_2chandler_8c.html#a0">__C_ExecuteExceptionFilter</a>(
00166                                 MemoryStackFp,
00167                                 BackingStoreFp,
00168                                 ExceptionRecord-&gt;ExceptionCode,
00169                                 &amp;ExceptionPointers,
00170                                 (ImageBase + <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>),
00171                                 GlobalPointer);
00172                     <span class="keywordflow">break</span>;
00173                 }
00174 
00175                 <span class="comment">//</span>
00176                 <span class="comment">// If the return value is less than zero, then dismiss the</span>
00177                 <span class="comment">// exception. Otherwise, if the value is greater than zero,</span>
00178                 <span class="comment">// then unwind to the target exception handler. Otherwise,</span>
00179                 <span class="comment">// continue the search for an exception filter.</span>
00180                 <span class="comment">//</span>
00181 
00182                 <span class="keywordflow">if</span> (Value &lt; 0) {
00183                     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a36">ExceptionContinueExecution</a>;
00184 
00185                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Value &gt; 0) {
00186 
00187                     FRAME_POINTERS EstablisherFrame = {MemoryStackFp,
00188                                                        BackingStoreFp};
00189 
00190                     <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a12">RtlUnwind2</a>(EstablisherFrame,
00191                                (PVOID)(ImageBase + ScopeTable-&gt;ScopeRecord[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].JumpTarget),
00192                                ExceptionRecord,
00193                                (PVOID)(ULONGLONG)ExceptionRecord-&gt;ExceptionCode,
00194                                ContextRecord);
00195                 }
00196             }
00197         }
00198 
00199     } <span class="keywordflow">else</span> {
00200 
00201         <span class="comment">//</span>
00202         <span class="comment">// Scan the scope table and call the appropriate termination handler</span>
00203         <span class="comment">// routines.</span>
00204         <span class="comment">//</span>
00205 
00206         TargetPc = ContextRecord-&gt;StIIP - ImageBase;
00207         <span class="keywordflow">for</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = 0; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &lt; ScopeTable-&gt;Count; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> += 1) {
00208             <span class="keywordflow">if</span> ((ControlPc &gt;= ScopeTable-&gt;ScopeRecord[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].BeginAddress) &amp;&amp;
00209                 (ControlPc &lt; ScopeTable-&gt;ScopeRecord[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].EndAddress)) {
00210 
00211                 <span class="comment">//</span>
00212                 <span class="comment">// If the target PC is within the same scope the control PC</span>
00213                 <span class="comment">// is within, then this is an uplevel goto out of an inner try</span>
00214                 <span class="comment">// scope or a long jump back into a try scope. Terminate the</span>
00215                 <span class="comment">// scan termination handlers.</span>
00216                 <span class="comment">//</span>
00217                 <span class="comment">// N.B. The target PC can be just beyond the end of the scope,</span>
00218                 <span class="comment">//      in which case it is a leave from the scope.</span>
00219                 <span class="comment">//</span>
00220 
00221 
00222                 <span class="keywordflow">if</span> ((TargetPc &gt;= ScopeTable-&gt;ScopeRecord[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].BeginAddress) &amp;&amp;
00223                    (TargetPc &lt; ScopeTable-&gt;ScopeRecord[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].EndAddress)) {
00224                     <span class="keywordflow">break</span>;
00225 
00226                 } <span class="keywordflow">else</span> {
00227 
00228                     <span class="comment">//</span>
00229                     <span class="comment">// If the scope table entry describes an exception filter</span>
00230                     <span class="comment">// and the associated exception handler is the target of</span>
00231                     <span class="comment">// the unwind, then terminate the scan for termination</span>
00232                     <span class="comment">// handlers. Otherwise, if the scope table entry describes</span>
00233                     <span class="comment">// a termination handler, then record the address of the</span>
00234                     <span class="comment">// end of the scope as the new control PC address and call</span>
00235                     <span class="comment">// the termination handler.</span>
00236                     <span class="comment">//</span>
00237 
00238                     <span class="keywordflow">if</span> (ScopeTable-&gt;ScopeRecord[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].JumpTarget != 0) {
00239                         <span class="keywordflow">if</span> (TargetPc == ScopeTable-&gt;ScopeRecord[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].JumpTarget) {
00240                             <span class="keywordflow">break</span>;
00241                         }
00242 
00243                     } <span class="keywordflow">else</span> {
00244 
00245                         DispatcherContext-&gt;ControlPc = ImageBase +
00246                                 ScopeTable-&gt;ScopeRecord[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].EndAddress;
00247 
00248                         Handler = ImageBase + ScopeTable-&gt;ScopeRecord[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].HandlerAddress;
00249                         <a class="code" href="../../d3/d6/ppc_2chandler_8c.html#a1">__C_ExecuteTerminationHandler</a>(
00250                             MemoryStackFp,
00251                             BackingStoreFp,
00252                             <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
00253                             Handler,
00254                             GlobalPointer);
00255                     }
00256                 }
00257             }
00258         }
00259     }
00260 
00261     <span class="comment">//</span>
00262     <span class="comment">// Continue search for exception or termination handlers.</span>
00263     <span class="comment">//</span>
00264 
00265     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a37">ExceptionContinueSearch</a>;
00266 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:39:23 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
