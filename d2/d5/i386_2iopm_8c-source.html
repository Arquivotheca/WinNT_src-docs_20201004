<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: iopm.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>iopm.c</h1><a href="../../d1/d6/i386_2iopm_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1991  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    iopm.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module implements interfaces that support manipulation of i386</span>
00012 <span class="comment">    i/o access maps (IOPMs).</span>
00013 <span class="comment"></span>
00014 <span class="comment">    These entry points only exist on i386 machines.</span>
00015 <span class="comment"></span>
00016 <span class="comment">Author:</span>
00017 <span class="comment"></span>
00018 <span class="comment">    Bryan M. Willman (bryanwi) 18-Sep-91</span>
00019 <span class="comment"></span>
00020 <span class="comment">Environment:</span>
00021 <span class="comment"></span>
00022 <span class="comment">    Kernel mode only.</span>
00023 <span class="comment"></span>
00024 <span class="comment">Revision History:</span>
00025 <span class="comment"></span>
00026 <span class="comment">--*/</span>
00027 
00028 <span class="preprocessor">#include "<a class="code" href="../../d0/d0/ki_8h.html">ki.h</a>"</span>
00029 
00030 <span class="comment">//</span>
00031 <span class="comment">// Our notion of alignment is different, so force use of ours</span>
00032 <span class="comment">//</span>
00033 
00034 <span class="preprocessor">#undef  ALIGN_UP</span>
00035 <span class="preprocessor"></span><span class="preprocessor">#undef  ALIGN_DOWN</span>
<a name="l00036"></a><a class="code" href="../../d1/d6/i386_2iopm_8c.html#a0">00036</a> <span class="preprocessor"></span><span class="preprocessor">#define ALIGN_DOWN(address,amt) ((ULONG)(address) &amp; ~(( amt ) - 1))</span>
<a name="l00037"></a><a class="code" href="../../d1/d6/i386_2iopm_8c.html#a1">00037</a> <span class="preprocessor"></span><span class="preprocessor">#define ALIGN_UP(address,amt) (ALIGN_DOWN( (address + (amt) - 1), (amt) ))</span>
00038 <span class="preprocessor"></span>
00039 <span class="comment">//</span>
00040 <span class="comment">// Note on synchronization:</span>
00041 <span class="comment">//</span>
00042 <span class="comment">//  IOPM edits are always done by code running at synchronization level on</span>
00043 <span class="comment">//  the processor whose TSS (map) is being edited.</span>
00044 <span class="comment">//</span>
00045 <span class="comment">//  IOPM only affects user mode code.  User mode code can never interrupt</span>
00046 <span class="comment">//  synchronization level code, therefore, edits and user code never race.</span>
00047 <span class="comment">//</span>
00048 <span class="comment">//  Likewise, switching from one map to another occurs on the processor</span>
00049 <span class="comment">//  for which the switch is being done by IPI_LEVEL code.  The active</span>
00050 <span class="comment">//  map could be switched in the middle of an edit of some map, but</span>
00051 <span class="comment">//  the edit will always complete before any user code gets run on that</span>
00052 <span class="comment">//  processor, therefore, there is no race.</span>
00053 <span class="comment">//</span>
00054 <span class="comment">//  Multiple simultaneous calls to Ke386SetIoAccessMap *could* produce</span>
00055 <span class="comment">//  weird mixes.  Therefore, KiIopmLock must be acquired to</span>
00056 <span class="comment">//  globally serialize edits.</span>
00057 <span class="comment">//</span>
00058 
00059 <span class="comment">//</span>
00060 <span class="comment">// Define forward referenced function prototypes.</span>
00061 <span class="comment">//</span>
00062 
00063 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00064 <a class="code" href="../../d1/d6/i386_2iopm_8c.html#a2">KiSetIoMap</a>(
00065     IN PKIPI_CONTEXT SignalDone,
00066     IN PVOID MapSource,
00067     IN PVOID MapNumber,
00068     IN PVOID Parameter3
00069     );
00070 
00071 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00072 <a class="code" href="../../d1/d6/i386_2iopm_8c.html#a3">KiLoadIopmOffset</a>(
00073     IN PKIPI_CONTEXT SignalDone,
00074     IN PVOID Parameter1,
00075     IN PVOID Parameter2,
00076     IN PVOID Parameter3
00077     );
00078 
00079 BOOLEAN
<a name="l00080"></a><a class="code" href="../../d1/d6/i386_2iopm_8c.html#a4">00080</a> <a class="code" href="../../d1/d6/i386_2iopm_8c.html#a4">Ke386SetIoAccessMap</a> (
00081     ULONG MapNumber,
00082     PKIO_ACCESS_MAP IoAccessMap
00083     )
00084 
00085 <span class="comment">/*++</span>
00086 <span class="comment"></span>
00087 <span class="comment">Routine Description:</span>
00088 <span class="comment"></span>
00089 <span class="comment">    The specified i/o access map will be set to match the</span>
00090 <span class="comment">    definition specified by IoAccessMap (i.e. enable/disable</span>
00091 <span class="comment">    those ports) before the call returns.  The change will take</span>
00092 <span class="comment">    effect on all processors.</span>
00093 <span class="comment"></span>
00094 <span class="comment">    Ke386SetIoAccessMap does not give any process enhanced I/O</span>
00095 <span class="comment">    access, it merely defines a particular access map.</span>
00096 <span class="comment"></span>
00097 <span class="comment">Arguments:</span>
00098 <span class="comment"></span>
00099 <span class="comment">    MapNumber - Number of access map to set.  Map 0 is fixed.</span>
00100 <span class="comment"></span>
00101 <span class="comment">    IoAccessMap - Pointer to bitvector (64K bits, 8K bytes) which</span>
00102 <span class="comment">           defines the specified access map.  Must be in</span>
00103 <span class="comment">           non-paged pool.</span>
00104 <span class="comment"></span>
00105 <span class="comment">Return Value:</span>
00106 <span class="comment"></span>
00107 <span class="comment">    TRUE if successful.  FALSE if failure (attempt to set a map</span>
00108 <span class="comment">    which does not exist, attempt to set map 0)</span>
00109 <span class="comment"></span>
00110 <span class="comment">--*/</span>
00111 
00112 {
00113 
00114     <a class="code" href="../../d5/d7/struct__KPROCESS.html">PKPROCESS</a> CurrentProcess;
00115     KIRQL OldIrql;
00116     PKPRCB Prcb;
00117     PVOID pt;
00118     KAFFINITY TargetProcessors;
00119 
00120     <span class="comment">//</span>
00121     <span class="comment">// Reject illegal requests</span>
00122     <span class="comment">//</span>
00123 
00124     <span class="keywordflow">if</span> ((MapNumber &gt; IOPM_COUNT) || (MapNumber == IO_ACCESS_MAP_NONE)) {
00125         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00126     }
00127 
00128     <span class="comment">//</span>
00129     <span class="comment">// Acquire the context swap lock so a context switch will not occur.</span>
00130     <span class="comment">//</span>
00131 
00132     <a class="code" href="../../d0/d0/ki_8h.html#a11">KiLockContextSwap</a>(&amp;OldIrql);
00133 
00134     <span class="comment">//</span>
00135     <span class="comment">// Compute set of active processors other than this one, if non-empty</span>
00136     <span class="comment">// IPI them to set their maps.</span>
00137     <span class="comment">//</span>
00138 
00139     Prcb = <a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a2">KeGetCurrentPrcb</a>();
00140 
00141 <span class="preprocessor">#if !defined(NT_UP)</span>
00142 <span class="preprocessor"></span>
00143     TargetProcessors = <a class="code" href="../../d4/d9/ke_8h.html#a123">KeActiveProcessors</a> &amp; ~Prcb-&gt;SetMember;
00144     <span class="keywordflow">if</span> (TargetProcessors != 0) {
00145         <a class="code" href="../../d0/d0/ki_8h.html#a91">KiIpiSendPacket</a>(TargetProcessors,
00146                         <a class="code" href="../../d1/d6/i386_2iopm_8c.html#a2">KiSetIoMap</a>,
00147                         IoAccessMap,
00148                         (PVOID)MapNumber,
00149                         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00150     }
00151 
00152 <span class="preprocessor">#endif</span>
00153 <span class="preprocessor"></span>
00154     <span class="comment">//</span>
00155     <span class="comment">// Copy the IOPM map and load the map for the current process.</span>
00156     <span class="comment">//</span>
00157 
00158     pt = &amp;(<a class="code" href="../../d6/d7/halmips_8h.html#a460">KiPcr</a>()-&gt;TSS-&gt;IoMaps[MapNumber-1].IoMap);
00159     RtlMoveMemory(pt, (PVOID)IoAccessMap, IOPM_SIZE);
00160     CurrentProcess = Prcb-&gt;CurrentThread-&gt;ApcState.Process;
00161     <a class="code" href="../../d6/d7/halmips_8h.html#a460">KiPcr</a>()-&gt;TSS-&gt;IoMapBase = CurrentProcess-&gt;IopmOffset;
00162 
00163     <span class="comment">//</span>
00164     <span class="comment">// Wait until all of the target processors have finished copying the</span>
00165     <span class="comment">// new map.</span>
00166     <span class="comment">//</span>
00167 
00168 <span class="preprocessor">#if !defined(NT_UP)</span>
00169 <span class="preprocessor"></span>
00170     <span class="keywordflow">if</span> (TargetProcessors != 0) {
00171         <a class="code" href="../../d2/d1/xipi_8c.html#a2">KiIpiStallOnPacketTargets</a>(TargetProcessors);
00172     }
00173 
00174 <span class="preprocessor">#endif</span>
00175 <span class="preprocessor"></span>
00176     <span class="comment">//</span>
00177     <span class="comment">// Restore IRQL and unlock the context swap lock.</span>
00178     <span class="comment">//</span>
00179 
00180     <a class="code" href="../../d0/d0/ki_8h.html#a12">KiUnlockContextSwap</a>(OldIrql);
00181     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00182 }
00183 
00184 <span class="preprocessor">#if !defined(NT_UP)</span>
00185 <span class="preprocessor"></span>
00186 
00187 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00188"></a><a class="code" href="../../d1/d6/i386_2iopm_8c.html#a2">00188</a> <a class="code" href="../../d1/d6/i386_2iopm_8c.html#a2">KiSetIoMap</a>(
00189     IN PKIPI_CONTEXT SignalDone,
00190     IN PVOID MapSource,
00191     IN PVOID MapNumber,
00192     IN PVOID Parameter3
00193     )
00194 <span class="comment">/*++</span>
00195 <span class="comment"></span>
00196 <span class="comment">Routine Description:</span>
00197 <span class="comment"></span>
00198 <span class="comment">    copy the specified map into this processor's TSS.</span>
00199 <span class="comment">    This procedure runs at IPI level.</span>
00200 <span class="comment"></span>
00201 <span class="comment">Arguments:</span>
00202 <span class="comment"></span>
00203 <span class="comment">    Argument - actually a pointer to a KIPI_SET_IOPM structure</span>
00204 <span class="comment">    ReadyFlag - pointer to flag to set once setiopm has completed</span>
00205 <span class="comment"></span>
00206 <span class="comment">Return Value:</span>
00207 <span class="comment"></span>
00208 <span class="comment">    none</span>
00209 <span class="comment"></span>
00210 <span class="comment">--*/</span>
00211 
00212 {
00213 
00214     <a class="code" href="../../d5/d7/struct__KPROCESS.html">PKPROCESS</a> CurrentProcess;
00215     PKPRCB Prcb;
00216     PVOID pt;
00217 
00218     <span class="comment">//</span>
00219     <span class="comment">// Copy the IOPM map and load the map for the current process.</span>
00220     <span class="comment">//</span>
00221 
00222     Prcb = <a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a2">KeGetCurrentPrcb</a>();
00223     pt = &amp;(<a class="code" href="../../d6/d7/halmips_8h.html#a460">KiPcr</a>()-&gt;TSS-&gt;IoMaps[((ULONG) MapNumber)-1].IoMap);
00224     RtlMoveMemory(pt, MapSource, IOPM_SIZE);
00225     CurrentProcess = Prcb-&gt;CurrentThread-&gt;ApcState.Process;
00226     <a class="code" href="../../d6/d7/halmips_8h.html#a460">KiPcr</a>()-&gt;TSS-&gt;IoMapBase = CurrentProcess-&gt;IopmOffset;
00227     <a class="code" href="../../d0/d0/ki_8h.html#a93">KiIpiSignalPacketDone</a>(SignalDone);
00228     <span class="keywordflow">return</span>;
00229 }
00230 
00231 <span class="preprocessor">#endif</span>
00232 <span class="preprocessor"></span>
00233 
00234 BOOLEAN
<a name="l00235"></a><a class="code" href="../../d1/d6/i386_2iopm_8c.html#a5">00235</a> <a class="code" href="../../d1/d6/i386_2iopm_8c.html#a5">Ke386QueryIoAccessMap</a> (
00236     ULONG MapNumber,
00237     PKIO_ACCESS_MAP IoAccessMap
00238     )
00239 
00240 <span class="comment">/*++</span>
00241 <span class="comment"></span>
00242 <span class="comment">Routine Description:</span>
00243 <span class="comment"></span>
00244 <span class="comment">    The specified i/o access map will be dumped into the buffer.</span>
00245 <span class="comment">    map 0 is a constant, but will be dumped anyway.</span>
00246 <span class="comment"></span>
00247 <span class="comment">Arguments:</span>
00248 <span class="comment"></span>
00249 <span class="comment">    MapNumber - Number of access map to set.  map 0 is fixed.</span>
00250 <span class="comment"></span>
00251 <span class="comment">    IoAccessMap - Pointer to buffer (64K bits, 8K bytes) which</span>
00252 <span class="comment">           is to receive the definition of the access map.</span>
00253 <span class="comment">           Must be in non-paged pool.</span>
00254 <span class="comment"></span>
00255 <span class="comment">Return Value:</span>
00256 <span class="comment"></span>
00257 <span class="comment">    TRUE if successful.  FALSE if failure (attempt to query a map</span>
00258 <span class="comment">    which does not exist)</span>
00259 <span class="comment"></span>
00260 <span class="comment">--*/</span>
00261 
00262 {
00263 
00264     ULONG i;
00265     PVOID Map;
00266     KIRQL OldIrql;
00267     PUCHAR p;
00268 
00269     <span class="comment">//</span>
00270     <span class="comment">// Reject illegal requests</span>
00271     <span class="comment">//</span>
00272 
00273     <span class="keywordflow">if</span> (MapNumber &gt; IOPM_COUNT) {
00274         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00275     }
00276 
00277     <span class="comment">//</span>
00278     <span class="comment">// Acquire the context swap lock so a context switch will not occur.</span>
00279     <span class="comment">//</span>
00280 
00281     <a class="code" href="../../d0/d0/ki_8h.html#a11">KiLockContextSwap</a>(&amp;OldIrql);
00282 
00283     <span class="comment">//</span>
00284     <span class="comment">// Copy out the map</span>
00285     <span class="comment">//</span>
00286 
00287     <span class="keywordflow">if</span> (MapNumber == IO_ACCESS_MAP_NONE) {
00288 
00289         <span class="comment">//</span>
00290         <span class="comment">// no access case, simply return a map of all 1s</span>
00291         <span class="comment">//</span>
00292 
00293         p = (PUCHAR)IoAccessMap;
00294         <span class="keywordflow">for</span> (i = 0; i &lt; IOPM_SIZE; i++) {
00295             p[i] = (UCHAR)-1;
00296         }
00297 
00298     } <span class="keywordflow">else</span> {
00299 
00300         <span class="comment">//</span>
00301         <span class="comment">// normal case, just copy the bits</span>
00302         <span class="comment">//</span>
00303 
00304         Map = (PVOID)&amp;(<a class="code" href="../../d6/d7/halmips_8h.html#a460">KiPcr</a>()-&gt;TSS-&gt;IoMaps[MapNumber-1].IoMap);
00305         RtlMoveMemory((PVOID)IoAccessMap, Map, IOPM_SIZE);
00306     }
00307 
00308     <span class="comment">//</span>
00309     <span class="comment">// Restore IRQL and unlock the context swap lock.</span>
00310     <span class="comment">//</span>
00311 
00312     <a class="code" href="../../d0/d0/ki_8h.html#a12">KiUnlockContextSwap</a>(OldIrql);
00313     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00314 }
00315 
00316 
00317 BOOLEAN
<a name="l00318"></a><a class="code" href="../../d1/d6/i386_2iopm_8c.html#a6">00318</a> <a class="code" href="../../d1/d6/i386_2iopm_8c.html#a6">Ke386IoSetAccessProcess</a> (
00319     <a class="code" href="../../d5/d7/struct__KPROCESS.html">PKPROCESS</a> Process,
00320     ULONG MapNumber
00321     )
00322 <span class="comment">/*++</span>
00323 <span class="comment"></span>
00324 <span class="comment">Routine Description:</span>
00325 <span class="comment"></span>
00326 <span class="comment">    Set the i/o access map which controls user mode i/o access</span>
00327 <span class="comment">    for a particular process.</span>
00328 <span class="comment"></span>
00329 <span class="comment">Arguments:</span>
00330 <span class="comment"></span>
00331 <span class="comment">    Process - Pointer to kernel process object describing the</span>
00332 <span class="comment">    process which for which a map is to be set.</span>
00333 <span class="comment"></span>
00334 <span class="comment">    MapNumber - Number of the map to set.  Value of map is</span>
00335 <span class="comment">    defined by Ke386IoSetAccessProcess.  Setting MapNumber</span>
00336 <span class="comment">    to IO_ACCESS_MAP_NONE will disallow any user mode i/o</span>
00337 <span class="comment">    access from the process.</span>
00338 <span class="comment"></span>
00339 <span class="comment">Return Value:</span>
00340 <span class="comment"></span>
00341 <span class="comment">    TRUE if success, FALSE if failure (illegal MapNumber)</span>
00342 <span class="comment"></span>
00343 <span class="comment">--*/</span>
00344 
00345 {
00346 
00347     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> MapOffset;
00348     KIRQL OldIrql;
00349     PKPRCB Prcb;
00350     KAFFINITY TargetProcessors;
00351 
00352     <span class="comment">//</span>
00353     <span class="comment">// Reject illegal requests</span>
00354     <span class="comment">//</span>
00355 
00356     <span class="keywordflow">if</span> (MapNumber &gt; IOPM_COUNT) {
00357         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00358     }
00359 
00360     MapOffset = KiComputeIopmOffset(MapNumber);
00361 
00362     <span class="comment">//</span>
00363     <span class="comment">// Acquire the context swap lock so a context switch will not occur.</span>
00364     <span class="comment">//</span>
00365 
00366     <a class="code" href="../../d0/d0/ki_8h.html#a11">KiLockContextSwap</a>(&amp;OldIrql);
00367 
00368     <span class="comment">//</span>
00369     <span class="comment">// Store new offset in process object,  compute current set of</span>
00370     <span class="comment">// active processors for process, if this cpu is one, set IOPM.</span>
00371     <span class="comment">//</span>
00372 
00373     Process-&gt;IopmOffset = MapOffset;
00374 
00375     TargetProcessors = Process-&gt;<a class="code" href="../../d5/d7/struct__KPROCESS.html#o3">ActiveProcessors</a>;
00376     Prcb = <a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a2">KeGetCurrentPrcb</a>();
00377     <span class="keywordflow">if</span> (TargetProcessors &amp; Prcb-&gt;SetMember) {
00378         <a class="code" href="../../d6/d7/halmips_8h.html#a460">KiPcr</a>()-&gt;TSS-&gt;IoMapBase = MapOffset;
00379     }
00380 
00381     <span class="comment">//</span>
00382     <span class="comment">// Compute set of active processors other than this one, if non-empty</span>
00383     <span class="comment">// IPI them to load their IOPMs, wait for them.</span>
00384     <span class="comment">//</span>
00385 
00386 <span class="preprocessor">#if !defined(NT_UP)</span>
00387 <span class="preprocessor"></span>
00388     TargetProcessors = TargetProcessors &amp; ~Prcb-&gt;SetMember;
00389     <span class="keywordflow">if</span> (TargetProcessors != 0) {
00390         <a class="code" href="../../d0/d0/ki_8h.html#a91">KiIpiSendPacket</a>(TargetProcessors,
00391                         <a class="code" href="../../d1/d6/i386_2iopm_8c.html#a3">KiLoadIopmOffset</a>,
00392                         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00393                         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00394                         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00395 
00396         <a class="code" href="../../d2/d1/xipi_8c.html#a2">KiIpiStallOnPacketTargets</a>(TargetProcessors);
00397     }
00398 
00399 <span class="preprocessor">#endif</span>
00400 <span class="preprocessor"></span>
00401     <span class="comment">//</span>
00402     <span class="comment">// Restore IRQL and unlock the context swap lock.</span>
00403     <span class="comment">//</span>
00404 
00405     <a class="code" href="../../d0/d0/ki_8h.html#a12">KiUnlockContextSwap</a>(OldIrql);
00406     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00407 }
00408 
00409 <span class="preprocessor">#if !defined(NT_UP)</span>
00410 <span class="preprocessor"></span>
00411 
00412 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00413"></a><a class="code" href="../../d1/d6/i386_2iopm_8c.html#a3">00413</a> <a class="code" href="../../d1/d6/i386_2iopm_8c.html#a3">KiLoadIopmOffset</a>(
00414     IN PKIPI_CONTEXT SignalDone,
00415     IN PVOID Parameter1,
00416     IN PVOID Parameter2,
00417     IN PVOID Parameter3
00418     )
00419 
00420 <span class="comment">/*++</span>
00421 <span class="comment"></span>
00422 <span class="comment">Routine Description:</span>
00423 <span class="comment"></span>
00424 <span class="comment">    Edit IopmBase of Tss to match that of currently running process.</span>
00425 <span class="comment"></span>
00426 <span class="comment">Arguments:</span>
00427 <span class="comment"></span>
00428 <span class="comment">    Argument - actually a pointer to a KIPI_LOAD_IOPM_OFFSET structure</span>
00429 <span class="comment">    ReadyFlag - Pointer to flag to be set once we are done</span>
00430 <span class="comment"></span>
00431 <span class="comment">Return Value:</span>
00432 <span class="comment"></span>
00433 <span class="comment">    none</span>
00434 <span class="comment"></span>
00435 <span class="comment">--*/</span>
00436 
00437 {
00438 
00439     <a class="code" href="../../d5/d7/struct__KPROCESS.html">PKPROCESS</a> CurrentProcess;
00440     PKPRCB Prcb;
00441 
00442     <span class="comment">//</span>
00443     <span class="comment">// Update IOPM field in TSS from current process</span>
00444     <span class="comment">//</span>
00445 
00446     Prcb = <a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a2">KeGetCurrentPrcb</a>();
00447     CurrentProcess = Prcb-&gt;CurrentThread-&gt;ApcState.Process;
00448     <a class="code" href="../../d6/d7/halmips_8h.html#a460">KiPcr</a>()-&gt;TSS-&gt;IoMapBase = CurrentProcess-&gt;IopmOffset;
00449     <a class="code" href="../../d0/d0/ki_8h.html#a93">KiIpiSignalPacketDone</a>(SignalDone);
00450     <span class="keywordflow">return</span>;
00451 }
00452 
00453 <span class="preprocessor">#endif</span>
00454 <span class="preprocessor"></span>
00455 
00456 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00457"></a><a class="code" href="../../d1/d6/i386_2iopm_8c.html#a7">00457</a> <a class="code" href="../../d1/d6/i386_2iopm_8c.html#a7">Ke386SetIOPL</a>(
00458     IN <a class="code" href="../../d5/d7/struct__KPROCESS.html">PKPROCESS</a> Process
00459     )
00460 
00461 <span class="comment">/*++</span>
00462 <span class="comment"></span>
00463 <span class="comment">Routine Description:</span>
00464 <span class="comment"></span>
00465 <span class="comment">    Gives IOPL to the specified process.</span>
00466 <span class="comment"></span>
00467 <span class="comment">    All threads created from this point on will get IOPL.  The current</span>
00468 <span class="comment">    process will get IOPL.  Must be called from context of thread and</span>
00469 <span class="comment">    process that are to have IOPL.</span>
00470 <span class="comment"></span>
00471 <span class="comment">    Iopl (to be made a boolean) in KPROCESS says all</span>
00472 <span class="comment">    new threads to get IOPL.</span>
00473 <span class="comment"></span>
00474 <span class="comment">    Iopl (to be made a boolean) in KTHREAD says given</span>
00475 <span class="comment">    thread to get IOPL.</span>
00476 <span class="comment"></span>
00477 <span class="comment">    N.B.    If a kernel mode only thread calls this procedure, the</span>
00478 <span class="comment">            result is (a) poinless and (b) will break the system.</span>
00479 <span class="comment"></span>
00480 <span class="comment">Arguments:</span>
00481 <span class="comment"></span>
00482 <span class="comment">    Process - Pointer to the process == IGNORED!!!</span>
00483 <span class="comment"></span>
00484 <span class="comment">Return Value:</span>
00485 <span class="comment"></span>
00486 <span class="comment">    none</span>
00487 <span class="comment"></span>
00488 <span class="comment">--*/</span>
00489 
00490 {
00491 
00492     <a class="code" href="../../d1/d8/struct__KTHREAD.html">PKTHREAD</a>    Thread;
00493     <a class="code" href="../../d5/d7/struct__KPROCESS.html">PKPROCESS</a>   Process2;
00494     PKTRAP_FRAME    TrapFrame;
00495     CONTEXT     Context;
00496 
00497     <span class="comment">//</span>
00498     <span class="comment">// get current thread and Process2, set flag for IOPL in both of them</span>
00499     <span class="comment">//</span>
00500 
00501     Thread = <a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a3">KeGetCurrentThread</a>();
00502     Process2 = Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o14">ApcState</a>.<a class="code" href="../../d3/d5/struct__KAPC__STATE.html#o1">Process</a>;
00503 
00504     Process2-&gt;Iopl = 1;
00505     Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o10">Iopl</a> = 1;
00506 
00507     <span class="comment">//</span>
00508     <span class="comment">// Force IOPL to be on for current thread</span>
00509     <span class="comment">//</span>
00510 
00511     TrapFrame = (PKTRAP_FRAME)((PUCHAR)Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o2">InitialStack</a> -
00512                 <a class="code" href="../../d0/d9/ntosdef_8h.html#a4">ALIGN_UP</a>(<span class="keyword">sizeof</span>(KTRAP_FRAME),KTRAP_FRAME_ALIGN) -
00513                 <span class="keyword">sizeof</span>(FX_SAVE_AREA));
00514 
00515     Context.ContextFlags = <a class="code" href="../../d6/d7/halmips_8h.html#a153">CONTEXT_CONTROL</a>;
00516     <a class="code" href="../../d2/d9/ppc_2exceptn_8c.html#a9">KeContextFromKframes</a>(TrapFrame,
00517                          <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00518                          &amp;Context);
00519 
00520     Context.EFlags |= (EFLAGS_IOPL_MASK &amp; -1);  <span class="comment">// IOPL == 3</span>
00521 
00522     <a class="code" href="../../d2/d9/ppc_2exceptn_8c.html#a10">KeContextToKframes</a>(TrapFrame,
00523                        <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00524                        &amp;Context,
00525                        <a class="code" href="../../d6/d7/halmips_8h.html#a153">CONTEXT_CONTROL</a>,
00526                        <a class="code" href="../../d0/d9/ntosdef_8h.html#a76a70">UserMode</a>);
00527 
00528     <span class="keywordflow">return</span>;
00529 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:40:29 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
