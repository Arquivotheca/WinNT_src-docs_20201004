<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: fsrtl.h Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>fsrtl.h</h1><a href="../../d1/d8/fsrtl_8h.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++ BUILD Version: 0001    // Increment this if a change has global effects</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1989  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    FsRtl.h</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module defines all of the general File System Rtl routines</span>
00012 <span class="comment"></span>
00013 <span class="comment">Author:</span>
00014 <span class="comment"></span>
00015 <span class="comment">    Gary Kimura     [GaryKi]    30-Jul-1990</span>
00016 <span class="comment"></span>
00017 <span class="comment">Revision History:</span>
00018 <span class="comment"></span>
00019 <span class="comment">--*/</span>
00020 
00021 <span class="preprocessor">#ifndef _FSRTL_</span>
00022 <span class="preprocessor"></span><span class="preprocessor">#define _FSRTL_</span>
00023 <span class="preprocessor"></span>
00024 <span class="comment">//  begin_ntifs</span>
00025 <span class="comment">//</span>
00026 <span class="comment">//  The following are globally used definitions for an LBN and a VBN</span>
00027 <span class="comment">//</span>
00028 
<a name="l00029"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a50">00029</a> <span class="keyword">typedef</span> ULONG <a class="code" href="../../d1/d8/fsrtl_8h.html#a50">LBN</a>;
<a name="l00030"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a51">00030</a> <span class="keyword">typedef</span> <a class="code" href="../../d1/d8/fsrtl_8h.html#a50">LBN</a> *<a class="code" href="../../d1/d8/fsrtl_8h.html#a51">PLBN</a>;
00031 
<a name="l00032"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a52">00032</a> <span class="keyword">typedef</span> ULONG <a class="code" href="../../d1/d8/fsrtl_8h.html#a52">VBN</a>;
<a name="l00033"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a53">00033</a> <span class="keyword">typedef</span> <a class="code" href="../../d1/d8/fsrtl_8h.html#a52">VBN</a> *<a class="code" href="../../d1/d8/fsrtl_8h.html#a53">PVBN</a>;
00034 
00035 
00036 <span class="comment">//  end_ntifs</span>
00037 <span class="comment">//</span>
00038 <span class="comment">//  The following routine is called during phase 1 initialization to allow</span>
00039 <span class="comment">//  us to create the pool of file system threads and the associated</span>
00040 <span class="comment">//  synchronization resources.</span>
00041 <span class="comment">//</span>
00042 
00043 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00044 BOOLEAN
00045 <a class="code" href="../../d4/d8/fsrtlpc_8c.html#a15">FsRtlInitSystem</a> (
00046     );
00047 
00048 <span class="comment">//  begin_ntifs</span>
00049 <span class="comment">//</span>
00050 <span class="comment">//  Every file system that uses the cache manager must have FsContext</span>
00051 <span class="comment">//  of the file object point to a common fcb header structure.</span>
00052 <span class="comment">//  end_ntifs</span>
00053 <span class="comment">//  Either the normal or compressed FsRtl Header (the latter if the</span>
00054 <span class="comment">//  file system supports Fast I/O for compressed reads and writes).</span>
00055 <span class="comment">//  begin_ntifs</span>
00056 <span class="comment">//</span>
00057 
<a name="l00058"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a188">00058</a> <span class="keyword">typedef</span> <span class="keyword">enum</span> <a class="code" href="../../d1/d8/fsrtl_8h.html#a188">_FAST_IO_POSSIBLE</a> {
00059     <a class="code" href="../../d1/d8/fsrtl_8h.html#a188a86">FastIoIsNotPossible</a> = 0,
00060     <a class="code" href="../../d1/d8/fsrtl_8h.html#a188a87">FastIoIsPossible</a>,
00061     <a class="code" href="../../d1/d8/fsrtl_8h.html#a188a88">FastIoIsQuestionable</a>
00062 } <a class="code" href="../../d1/d8/fsrtl_8h.html#a54">FAST_IO_POSSIBLE</a>;
00063 
00064 <span class="comment">//  end_ntifs</span>
00065 <span class="comment">//  Changes to this structure will affect FSRTL_ADVANCED_FCB_HEADER.</span>
00066 <span class="comment">//  begin_ntifs</span>
00067 
<a name="l00068"></a><a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html">00068</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html">_FSRTL_COMMON_FCB_HEADER</a> {
00069 
<a name="l00070"></a><a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html#o0">00070</a>     CSHORT <a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html#o0">NodeTypeCode</a>;
<a name="l00071"></a><a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html#o1">00071</a>     CSHORT <a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html#o1">NodeByteSize</a>;
00072 
00073     <span class="comment">//</span>
00074     <span class="comment">//  General flags available to FsRtl.</span>
00075     <span class="comment">//</span>
00076 
<a name="l00077"></a><a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html#o2">00077</a>     UCHAR <a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html#o2">Flags</a>;
00078 
00079     <span class="comment">//</span>
00080     <span class="comment">//  Indicates if fast I/O is possible or if we should be calling</span>
00081     <span class="comment">//  the check for fast I/O routine which is found via the driver</span>
00082     <span class="comment">//  object.</span>
00083     <span class="comment">//</span>
00084 
<a name="l00085"></a><a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html#o3">00085</a>     UCHAR <a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html#o3">IsFastIoPossible</a>; <span class="comment">// really type FAST_IO_POSSIBLE</span>
00086 
00087     <span class="comment">//</span>
00088     <span class="comment">//  Second Flags Field</span>
00089     <span class="comment">//</span>
00090 
<a name="l00091"></a><a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html#o4">00091</a>     UCHAR <a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html#o4">Flags2</a>;
00092 
00093     <span class="comment">//</span>
00094     <span class="comment">//  The following reserved field should always be 0</span>
00095     <span class="comment">//</span>
00096 
<a name="l00097"></a><a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html#o5">00097</a>     UCHAR <a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html#o5">Reserved</a>;
00098 
<a name="l00099"></a><a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html#o6">00099</a>     <a class="code" href="../../d6/d4/struct__ERESOURCE.html">PERESOURCE</a> <a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html#o6">Resource</a>;
00100 
<a name="l00101"></a><a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html#o7">00101</a>     <a class="code" href="../../d6/d4/struct__ERESOURCE.html">PERESOURCE</a> <a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html#o7">PagingIoResource</a>;
00102 
<a name="l00103"></a><a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html#o8">00103</a>     LARGE_INTEGER <a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html#o8">AllocationSize</a>;
<a name="l00104"></a><a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html#o9">00104</a>     LARGE_INTEGER <a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html#o9">FileSize</a>;
<a name="l00105"></a><a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html#o10">00105</a>     LARGE_INTEGER <a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html#o10">ValidDataLength</a>;
00106 
00107 <span class="comment">//  end_ntifs</span>
00108 
00109 <span class="preprocessor">#ifndef BUILDING_FSKDEXT</span>
00110 <span class="preprocessor"></span>
00111     <span class="comment">//</span>
00112     <span class="comment">//  FSKD needs fsrtl.h,  but FAT/CDFS/UDFS build using ntifs.h,  which doesn't </span>
00113     <span class="comment">//  define these fields (end_ntifs above).  So when building the FSKD </span>
00114     <span class="comment">//  (fat/cdfs/udfs kdext) don't define these fields.  To be fixed 5.1</span>
00115     <span class="comment">// </span>
00116     
00117  <span class="comment">//</span>
00118  <span class="comment">// The following two fields are supported only if</span>
00119  <span class="comment">// Flags2 contains FSRTL_FLAG2_SUPPORTS_FILTER_CONTEXTS</span>
00120  <span class="comment">//</span>
00121  <span class="comment">// FastMutex was moved here from FSRTL_ADVANCED_FCB_HEADER,</span>
00122  <span class="comment">// but remains at the same offset in that structure.</span>
00123  <span class="comment">// The other fields in the previous definition of the</span>
00124  <span class="comment">// advanced FCB header were moved by this change</span>
00125  <span class="comment">//</span>
00126 
00127     <span class="comment">//</span>
00128     <span class="comment">//  This is a pointer to a Fast Mutex which may be used to</span>
00129     <span class="comment">//  properly synchronize access to the FsRtl header.  The</span>
00130     <span class="comment">//  Fast Mutex must be nonpaged.</span>
00131     <span class="comment">//</span>
00132 
<a name="l00133"></a><a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html#o11">00133</a>     <a class="code" href="../../d6/d9/struct__FAST__MUTEX.html">PFAST_MUTEX</a> <a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html#o11">FastMutex</a>;
00134 
00135     <span class="comment">//</span>
00136     <span class="comment">// This is a pointer to a list of context structures belonging to</span>
00137     <span class="comment">// filesystem filter drivers that are linked above the filesystem.</span>
00138     <span class="comment">// Each structure is headed by FSRTL_FILTER_CONTEXT.</span>
00139     <span class="comment">//</span>
00140 
<a name="l00141"></a><a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html#o12">00141</a>     LIST_ENTRY <a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html#o12">FilterContexts</a>;
00142     
00143 <span class="preprocessor">#endif</span>
00144 <span class="preprocessor"></span>
00145 <span class="comment">//  begin_ntifs</span>
00146 } <a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html">FSRTL_COMMON_FCB_HEADER</a>;
<a name="l00147"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a56">00147</a> <span class="keyword">typedef</span> <a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html">FSRTL_COMMON_FCB_HEADER</a> *<a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html">PFSRTL_COMMON_FCB_HEADER</a>;
00148 
00149 <span class="comment">//  end_ntifs</span>
00150 <span class="comment">//</span>
00151 <span class="comment">//  This Fcb header is used for files which support caching</span>
00152 <span class="comment">//  of compressed data, and related new support.</span>
00153 <span class="comment">//</span>
00154 <span class="comment">//  We start out by prefixing this structure with the normal</span>
00155 <span class="comment">//  FsRtl header from above, which we have to do two different</span>
00156 <span class="comment">//  ways for c++ or c.</span>
00157 <span class="comment">//</span>
00158 
00159 <span class="preprocessor">#ifdef __cplusplus</span>
00160 <span class="preprocessor"></span><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d9/d0/struct__FSRTL__ADVANCED__FCB__HEADER.html">_FSRTL_ADVANCED_FCB_HEADER</a>:<a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html">FSRTL_COMMON_FCB_HEADER</a> {
00161 <span class="preprocessor">#else   // __cplusplus</span>
00162 <span class="preprocessor"></span>
<a name="l00163"></a><a class="code" href="../../d9/d0/struct__FSRTL__ADVANCED__FCB__HEADER.html">00163</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d9/d0/struct__FSRTL__ADVANCED__FCB__HEADER.html">_FSRTL_ADVANCED_FCB_HEADER</a> {
00164 
00165     <span class="comment">//</span>
00166     <span class="comment">//  Put in the standard FsRtl header fields</span>
00167     <span class="comment">//</span>
00168 
<a name="l00169"></a><a class="code" href="../../d9/d0/struct__FSRTL__ADVANCED__FCB__HEADER.html#o0">00169</a>     <a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html">FSRTL_COMMON_FCB_HEADER</a> ;
00170 
00171 <span class="preprocessor">#endif  // __cplusplus</span>
00172 <span class="preprocessor"></span>
00173     <span class="comment">//</span>
00174     <span class="comment">//  This is a pointer to a list head which may be used to queue</span>
00175     <span class="comment">//  up advances to EOF (end of file), via calls to the appropriate</span>
00176     <span class="comment">//  FsRtl routines.  This listhead may be paged.</span>
00177     <span class="comment">//</span>
00178 
<a name="l00179"></a><a class="code" href="../../d9/d0/struct__FSRTL__ADVANCED__FCB__HEADER.html#o1">00179</a>     PLIST_ENTRY PendingEofAdvances;
00180 
00181     <span class="comment">//</span>
00182     <span class="comment">//  When FSRTL_FLAG_ADVANCED_HEADER is set, the following fields</span>
00183     <span class="comment">//  are present in the header.  If the compressed stream has not</span>
00184     <span class="comment">//  been initialized, all of the following fields will be NULL.</span>
00185     <span class="comment">//</span>
00186 
00187     <span class="comment">//</span>
00188     <span class="comment">//  This is the FileObect for the stream in which data is cached</span>
00189     <span class="comment">//  in its compressed form.</span>
00190     <span class="comment">//</span>
00191 
<a name="l00192"></a><a class="code" href="../../d9/d0/struct__FSRTL__ADVANCED__FCB__HEADER.html#o2">00192</a>     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObjectC;
00193 
00194     <span class="comment">//</span>
00195     <span class="comment">//  The following field points to the Section Object Pointers for</span>
00196     <span class="comment">//  the normal data stream used for cache coherency in the fast path.</span>
00197     <span class="comment">//</span>
00198 
<a name="l00199"></a><a class="code" href="../../d9/d0/struct__FSRTL__ADVANCED__FCB__HEADER.html#o3">00199</a>     <a class="code" href="../../d7/d0/struct__SECTION__OBJECT__POINTERS.html">PSECTION_OBJECT_POINTERS</a> SectionObjectPointers;
00200 
00201 } <a class="code" href="../../d9/d0/struct__FSRTL__ADVANCED__FCB__HEADER.html">FSRTL_ADVANCED_FCB_HEADER</a>;
<a name="l00202"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a58">00202</a> <span class="keyword">typedef</span> <a class="code" href="../../d9/d0/struct__FSRTL__ADVANCED__FCB__HEADER.html">FSRTL_ADVANCED_FCB_HEADER</a> *<a class="code" href="../../d9/d0/struct__FSRTL__ADVANCED__FCB__HEADER.html">PFSRTL_ADVANCED_FCB_HEADER</a>;
00203 
00204 <span class="comment">//  begin_ntifs</span>
00205 <span class="comment">//</span>
00206 <span class="comment">//  Define FsRtl common header flags</span>
00207 <span class="comment">//</span>
00208 
<a name="l00209"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a0">00209</a> <span class="preprocessor">#define FSRTL_FLAG_FILE_MODIFIED        (0x01)</span>
<a name="l00210"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a1">00210</a> <span class="preprocessor"></span><span class="preprocessor">#define FSRTL_FLAG_FILE_LENGTH_CHANGED  (0x02)</span>
<a name="l00211"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a2">00211</a> <span class="preprocessor"></span><span class="preprocessor">#define FSRTL_FLAG_LIMIT_MODIFIED_PAGES (0x04)</span>
00212 <span class="preprocessor"></span>
00213 <span class="comment">//</span>
00214 <span class="comment">//  Following flags determine how the modified page writer should</span>
00215 <span class="comment">//  acquire the file.  These flags can't change while either resource</span>
00216 <span class="comment">//  is acquired.  If neither of these flags is set then the</span>
00217 <span class="comment">//  modified/mapped page writer will attempt to acquire the paging io</span>
00218 <span class="comment">//  resource shared.</span>
00219 <span class="comment">//</span>
00220 
<a name="l00221"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a3">00221</a> <span class="preprocessor">#define FSRTL_FLAG_ACQUIRE_MAIN_RSRC_EX (0x08)</span>
<a name="l00222"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a4">00222</a> <span class="preprocessor"></span><span class="preprocessor">#define FSRTL_FLAG_ACQUIRE_MAIN_RSRC_SH (0x10)</span>
00223 <span class="preprocessor"></span>
00224 <span class="comment">//</span>
00225 <span class="comment">//  This flag will be set by the Cache Manager if a view is mapped</span>
00226 <span class="comment">//  to a file.</span>
00227 <span class="comment">//</span>
00228 
<a name="l00229"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a5">00229</a> <span class="preprocessor">#define FSRTL_FLAG_USER_MAPPED_FILE     (0x20)</span>
00230 <span class="preprocessor"></span>
00231 <span class="comment">//  end_ntifs</span>
00232 <span class="comment">//  This flag indicates that the file system supports compression</span>
00233 <span class="comment">//  and this is a compressed FsRtl header.</span>
00234 <span class="comment">//</span>
00235 
<a name="l00236"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a6">00236</a> <span class="preprocessor">#define FSRTL_FLAG_ADVANCED_HEADER      (0x40)</span>
00237 <span class="preprocessor"></span>
00238 <span class="comment">//  begin_ntifs</span>
00239 <span class="comment">//  This flag determines whether there currently is an Eof advance</span>
00240 <span class="comment">//  in progress.  All such advances must be serialized.</span>
00241 <span class="comment">//</span>
00242 
<a name="l00243"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a7">00243</a> <span class="preprocessor">#define FSRTL_FLAG_EOF_ADVANCE_ACTIVE   (0x80)</span>
00244 <span class="preprocessor"></span>
00245 <span class="comment">//</span>
00246 <span class="comment">//  Flag values for Flags2</span>
00247 <span class="comment">//</span>
00248 <span class="comment">//  All unused bits are reserved and should NOT be modified.</span>
00249 <span class="comment">//</span>
00250 
00251 <span class="comment">//</span>
00252 <span class="comment">//  If this flag is set, the Cache Manager will allow modified writing</span>
00253 <span class="comment">//  in spite of the value of FsContext2.</span>
00254 <span class="comment">//</span>
00255 
<a name="l00256"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a8">00256</a> <span class="preprocessor">#define FSRTL_FLAG2_DO_MODIFIED_WRITE        (0x01)</span>
00257 <span class="preprocessor"></span>
00258 <span class="comment">//  end_ntifs</span>
00259 <span class="comment">//</span>
00260 <span class="comment">//  If this flag is set, the additional fields FilterContexts and FastMutex</span>
00261 <span class="comment">//  are supported in FSRTL_COMMON_HEADER, and can be used to associate</span>
00262 <span class="comment">//  context for filesystem filters with streams.</span>
00263 <span class="comment">//</span>
00264 
<a name="l00265"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a9">00265</a> <span class="preprocessor">#define FSRTL_FLAG2_SUPPORTS_FILTER_CONTEXTS  (0x02)</span>
00266 <span class="preprocessor"></span>
00267 <span class="comment">//</span>
00268 <span class="comment">//  If this flag is set, the cache manager will flush and purge the cache map when</span>
00269 <span class="comment">//  a user first maps a file</span>
00270 <span class="comment">//</span>
00271 
<a name="l00272"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a10">00272</a> <span class="preprocessor">#define FSRTL_FLAG2_PURGE_WHEN_MAPPED (0x04)</span>
00273 <span class="preprocessor"></span>
00274 
00275 <span class="comment">//  begin_ntifs</span>
00276 <span class="comment">//</span>
00277 <span class="comment">//  The following constants are used to block top level Irp processing when</span>
00278 <span class="comment">//  (in either the fast io or cc case) file system resources have been</span>
00279 <span class="comment">//  acquired above the file system, or we are in an Fsp thread.</span>
00280 <span class="comment">//</span>
00281 
<a name="l00282"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a11">00282</a> <span class="preprocessor">#define FSRTL_FSP_TOP_LEVEL_IRP         0x01</span>
<a name="l00283"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a12">00283</a> <span class="preprocessor"></span><span class="preprocessor">#define FSRTL_CACHE_TOP_LEVEL_IRP       0x02</span>
<a name="l00284"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a13">00284</a> <span class="preprocessor"></span><span class="preprocessor">#define FSRTL_MOD_WRITE_TOP_LEVEL_IRP   0x03</span>
<a name="l00285"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a14">00285</a> <span class="preprocessor"></span><span class="preprocessor">#define FSRTL_FAST_IO_TOP_LEVEL_IRP     0x04</span>
<a name="l00286"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a15">00286</a> <span class="preprocessor"></span><span class="preprocessor">#define FSRTL_MAX_TOP_LEVEL_IRP_FLAG    0x04</span>
00287 <span class="preprocessor"></span>
00288 <span class="comment">//  end_ntifs</span>
00289 <span class="comment">//</span>
00290 <span class="comment">//  The following structure is used to synchronize Eof extends.</span>
00291 <span class="comment">//</span>
00292 
<a name="l00293"></a><a class="code" href="../../d9/d3/struct__EOF__WAIT__BLOCK.html">00293</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d9/d3/struct__EOF__WAIT__BLOCK.html">_EOF_WAIT_BLOCK</a> {
00294 
<a name="l00295"></a><a class="code" href="../../d9/d3/struct__EOF__WAIT__BLOCK.html#o0">00295</a>     LIST_ENTRY EofWaitLinks;
<a name="l00296"></a><a class="code" href="../../d9/d3/struct__EOF__WAIT__BLOCK.html#o1">00296</a>     <a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a> <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>;
00297 
00298 } <a class="code" href="../../d9/d3/struct__EOF__WAIT__BLOCK.html">EOF_WAIT_BLOCK</a>;
00299 
<a name="l00300"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a60">00300</a> <span class="keyword">typedef</span> <a class="code" href="../../d9/d3/struct__EOF__WAIT__BLOCK.html">EOF_WAIT_BLOCK</a> *<a class="code" href="../../d9/d3/struct__EOF__WAIT__BLOCK.html">PEOF_WAIT_BLOCK</a>;
00301 
00302 <span class="comment">//  begin_ntifs</span>
00303 <span class="comment">//</span>
00304 <span class="comment">//  Normal uncompressed Copy and Mdl Apis</span>
00305 <span class="comment">//</span>
00306 
00307 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00308 BOOLEAN
00309 <a class="code" href="../../d1/d8/fsrtl_8h.html#a93">FsRtlCopyRead</a> (
00310     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
00311     IN PLARGE_INTEGER FileOffset,
00312     IN ULONG Length,
00313     IN BOOLEAN Wait,
00314     IN ULONG LockKey,
00315     OUT PVOID Buffer,
00316     OUT PIO_STATUS_BLOCK IoStatus,
00317     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject
00318     );
00319 
00320 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00321 BOOLEAN
00322 <a class="code" href="../../d1/d8/fsrtl_8h.html#a94">FsRtlCopyWrite</a> (
00323     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
00324     IN PLARGE_INTEGER FileOffset,
00325     IN ULONG Length,
00326     IN BOOLEAN Wait,
00327     IN ULONG LockKey,
00328     IN PVOID Buffer,
00329     OUT PIO_STATUS_BLOCK IoStatus,
00330     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject
00331     );
00332 
00333 <span class="comment">// end_ntifs</span>
00334 
00335 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00336 BOOLEAN
00337 <a class="code" href="../../d1/d8/fsrtl_8h.html#a95">FsRtlMdlRead</a> (
00338     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
00339     IN PLARGE_INTEGER FileOffset,
00340     IN ULONG Length,
00341     IN ULONG LockKey,
00342     OUT <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> *MdlChain,
00343     OUT PIO_STATUS_BLOCK IoStatus
00344     );
00345 
00346 BOOLEAN
00347 <a class="code" href="../../d1/d8/fsrtl_8h.html#a96">FsRtlMdlReadComplete</a> (
00348     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
00349     IN <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> MdlChain
00350     );
00351 
00352 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00353 BOOLEAN
00354 <a class="code" href="../../d1/d8/fsrtl_8h.html#a97">FsRtlPrepareMdlWrite</a> (
00355     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
00356     IN PLARGE_INTEGER FileOffset,
00357     IN ULONG Length,
00358     IN ULONG LockKey,
00359     OUT <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> *MdlChain,
00360     OUT PIO_STATUS_BLOCK IoStatus
00361     );
00362 
00363 BOOLEAN
00364 <a class="code" href="../../d1/d8/fsrtl_8h.html#a98">FsRtlMdlWriteComplete</a> (
00365     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
00366     IN PLARGE_INTEGER FileOffset,
00367     IN <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> MdlChain
00368     );
00369 
00370 <span class="comment">// begin_ntsrv</span>
00371 
00372 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00373 BOOLEAN
00374 <a class="code" href="../../d1/d8/fsrtl_8h.html#a99">FsRtlMdlReadDev</a> (
00375     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
00376     IN PLARGE_INTEGER FileOffset,
00377     IN ULONG Length,
00378     IN ULONG LockKey,
00379     OUT <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> *MdlChain,
00380     OUT PIO_STATUS_BLOCK IoStatus,
00381     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject
00382     );
00383 
00384 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00385 BOOLEAN
00386 <a class="code" href="../../d1/d8/fsrtl_8h.html#a100">FsRtlMdlReadCompleteDev</a> (
00387     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
00388     IN <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> MdlChain,
00389     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject
00390     );
00391 
00392 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00393 BOOLEAN
00394 <a class="code" href="../../d1/d8/fsrtl_8h.html#a101">FsRtlPrepareMdlWriteDev</a> (
00395     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
00396     IN PLARGE_INTEGER FileOffset,
00397     IN ULONG Length,
00398     IN ULONG LockKey,
00399     OUT <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> *MdlChain,
00400     OUT PIO_STATUS_BLOCK IoStatus,
00401     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject
00402     );
00403 
00404 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00405 BOOLEAN
00406 <a class="code" href="../../d1/d8/fsrtl_8h.html#a102">FsRtlMdlWriteCompleteDev</a> (
00407     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
00408     IN PLARGE_INTEGER FileOffset,
00409     IN <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> MdlChain,
00410     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject
00411     );
00412 
00413 <span class="comment">//</span>
00414 <span class="comment">//  In Irps, compressed reads and writes are  designated by the</span>
00415 <span class="comment">//  subfunction IRP_MN_COMPRESSED must be set and the Compressed</span>
00416 <span class="comment">//  Data Info buffer must be described by the following structure</span>
00417 <span class="comment">//  pointed to by Irp-&gt;Tail.Overlay.AuxiliaryBuffer.</span>
00418 <span class="comment">//</span>
00419 
<a name="l00420"></a><a class="code" href="../../d0/d1/struct__FSRTL__AUXILIARY__BUFFER.html">00420</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d0/d1/struct__FSRTL__AUXILIARY__BUFFER.html">_FSRTL_AUXILIARY_BUFFER</a> {
00421 
00422     <span class="comment">//</span>
00423     <span class="comment">//  Buffer description with length.</span>
00424     <span class="comment">//</span>
00425 
<a name="l00426"></a><a class="code" href="../../d0/d1/struct__FSRTL__AUXILIARY__BUFFER.html#o0">00426</a>     PVOID <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>;
<a name="l00427"></a><a class="code" href="../../d0/d1/struct__FSRTL__AUXILIARY__BUFFER.html#o1">00427</a>     ULONG Length;
00428 
00429     <span class="comment">//</span>
00430     <span class="comment">//  Flags</span>
00431     <span class="comment">//</span>
00432 
<a name="l00433"></a><a class="code" href="../../d0/d1/struct__FSRTL__AUXILIARY__BUFFER.html#o2">00433</a>     ULONG Flags;
00434 
00435     <span class="comment">//</span>
00436     <span class="comment">//  Pointer to optional Mdl mapping buffer for file system use</span>
00437     <span class="comment">//</span>
00438 
<a name="l00439"></a><a class="code" href="../../d0/d1/struct__FSRTL__AUXILIARY__BUFFER.html#o3">00439</a>     <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> Mdl;
00440 
00441 } <a class="code" href="../../d0/d1/struct__FSRTL__AUXILIARY__BUFFER.html">FSRTL_AUXILIARY_BUFFER</a>;
<a name="l00442"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a62">00442</a> <span class="keyword">typedef</span> <a class="code" href="../../d0/d1/struct__FSRTL__AUXILIARY__BUFFER.html">FSRTL_AUXILIARY_BUFFER</a> *<a class="code" href="../../d0/d1/struct__FSRTL__AUXILIARY__BUFFER.html">PFSRTL_AUXILIARY_BUFFER</a>;
00443 
00444 <span class="comment">//</span>
00445 <span class="comment">//  If this flag is set, the auxillary buffer structure is</span>
00446 <span class="comment">//  deallocated on Irp completion.  The caller has the</span>
00447 <span class="comment">//  option in this case of appending this structure to the</span>
00448 <span class="comment">//  structure being described, causing it all to be</span>
00449 <span class="comment">//  deallocated at once.  If this flag is clear, no deallocate</span>
00450 <span class="comment">//  occurs.</span>
00451 <span class="comment">//</span>
00452 
<a name="l00453"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a16">00453</a> <span class="preprocessor">#define FSRTL_AUXILIARY_FLAG_DEALLOCATE 0x00000001</span>
00454 <span class="preprocessor"></span>
00455 <span class="comment">//  end_ntsrv</span>
00456 <span class="comment">//</span>
00457 <span class="comment">//  The following routines are intended to be called by Mm to avoid deadlocks.</span>
00458 <span class="comment">//  They pre-acquire file system resources before acquire Mm resources.</span>
00459 <span class="comment">//</span>
00460 
00461 <span class="comment">//</span>
00462 <span class="comment">//  This macro is called once when the ModifiedPageWriter is started.</span>
00463 <span class="comment">//</span>
00464 
<a name="l00465"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a17">00465</a> <span class="preprocessor">#define FsRtlSetTopLevelIrpForModWriter() {            \</span>
00466 <span class="preprocessor">    IoSetTopLevelIrp((PIRP)FSRTL_MOD_WRITE_TOP_LEVEL_IRP); \</span>
00467 <span class="preprocessor">}</span>
00468 <span class="preprocessor"></span>
00469 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00470 BOOLEAN
00471 <a class="code" href="../../d1/d8/fsrtl_8h.html#a103">FsRtlAcquireFileForModWrite</a> (
00472     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
00473     IN PLARGE_INTEGER StartingOffset,
00474     OUT <a class="code" href="../../d6/d4/struct__ERESOURCE.html">PERESOURCE</a> *ResourceToRelease
00475     );
00476 
00477 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00478 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00479 <a class="code" href="../../d1/d8/fsrtl_8h.html#a104">FsRtlReleaseFileForModWrite</a> (
00480     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
00481     IN <a class="code" href="../../d6/d4/struct__ERESOURCE.html">PERESOURCE</a> ResourceToRelease
00482     );
00483 
00484 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00485 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00486 <a class="code" href="../../d1/d8/fsrtl_8h.html#a105">FsRtlAcquireFileForCcFlush</a> (
00487     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject
00488     );
00489 
00490 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00491 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00492 <a class="code" href="../../d1/d8/fsrtl_8h.html#a106">FsRtlReleaseFileForCcFlush</a> (
00493     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject
00494     );
00495 
00496 <span class="comment">//  begin_ntifs</span>
00497 <span class="comment">//</span>
00498 <span class="comment">//  The following two routines are called from NtCreateSection to avoid</span>
00499 <span class="comment">//  deadlocks with the file systems.</span>
00500 <span class="comment">//</span>
00501 
00502 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00503 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00504 <a class="code" href="../../d1/d8/fsrtl_8h.html#a107">FsRtlAcquireFileExclusive</a> (
00505     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject
00506     );
00507 
00508 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00509 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00510 <a class="code" href="../../d1/d8/fsrtl_8h.html#a108">FsRtlReleaseFile</a> (
00511     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject
00512     );
00513 
00514 <span class="comment">//</span>
00515 <span class="comment">//  These routines provide a simple interface for the common operations</span>
00516 <span class="comment">//  of query/set file size.</span>
00517 <span class="comment">//</span>
00518 
00519 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00520 <a class="code" href="../../d1/d8/fsrtl_8h.html#a109">FsRtlGetFileSize</a>(
00521     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
00522     IN OUT PLARGE_INTEGER FileSize
00523     );
00524 
00525 <span class="comment">//  end_ntifs</span>
00526 
00527 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00528 <a class="code" href="../../d1/d8/fsrtl_8h.html#a110">FsRtlSetFileSize</a>(
00529     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
00530     IN OUT PLARGE_INTEGER FileSize
00531     );
00532 
00533 <span class="comment">// begin_ntddk begin_ntifs</span>
00534 <span class="comment">//</span>
00535 <span class="comment">// Determine if there is a complete device failure on an error.</span>
00536 <span class="comment">//</span>
00537 
00538 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00539 BOOLEAN
00540 <a class="code" href="../../d1/d8/fsrtl_8h.html#a111">FsRtlIsTotalDeviceFailure</a>(
00541     IN NTSTATUS Status
00542     );
00543 
00544 <span class="comment">// end_ntddk</span>
00545 
00546 <span class="comment">//</span>
00547 <span class="comment">//  Byte range file lock routines, implemented in FileLock.c</span>
00548 <span class="comment">//</span>
00549 <span class="comment">//  The file lock info record is used to return enumerated information</span>
00550 <span class="comment">//  about a file lock</span>
00551 <span class="comment">//</span>
00552 
<a name="l00553"></a><a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html">00553</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html">_FILE_LOCK_INFO</a> {
00554 
00555     <span class="comment">//</span>
00556     <span class="comment">//  A description of the current locked range, and if the lock</span>
00557     <span class="comment">//  is exclusive or shared</span>
00558     <span class="comment">//</span>
00559 
<a name="l00560"></a><a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o0">00560</a>     LARGE_INTEGER StartingByte;
<a name="l00561"></a><a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o1">00561</a>     LARGE_INTEGER Length;
<a name="l00562"></a><a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o2">00562</a>     BOOLEAN ExclusiveLock;
00563 
00564     <span class="comment">//</span>
00565     <span class="comment">//  The following fields describe the owner of the lock.</span>
00566     <span class="comment">//</span>
00567 
<a name="l00568"></a><a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o3">00568</a>     ULONG <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a51">Key</a>;
<a name="l00569"></a><a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o4">00569</a>     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject;
<a name="l00570"></a><a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o5">00570</a>     PVOID ProcessId;
00571 
00572     <span class="comment">//</span>
00573     <span class="comment">//  The following field is used internally by FsRtl</span>
00574     <span class="comment">//</span>
00575 
<a name="l00576"></a><a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o6">00576</a>     LARGE_INTEGER EndingByte;
00577 
00578 } <a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html">FILE_LOCK_INFO</a>;
<a name="l00579"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a64">00579</a> <span class="keyword">typedef</span> <a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html">FILE_LOCK_INFO</a> *<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html">PFILE_LOCK_INFO</a>;
00580 
00581 <span class="comment">//</span>
00582 <span class="comment">//  The following two procedure prototypes are used by the caller of the</span>
00583 <span class="comment">//  file lock package to supply an alternate routine to call when</span>
00584 <span class="comment">//  completing an IRP and when unlocking a byte range.  Note that the only</span>
00585 <span class="comment">//  utility to us this interface is currently the redirector, all other file</span>
00586 <span class="comment">//  system will probably let the IRP complete normally with IoCompleteRequest.</span>
00587 <span class="comment">//  The user supplied routine returns any value other than success then the</span>
00588 <span class="comment">//  lock package will remove any lock that we just inserted.</span>
00589 <span class="comment">//</span>
00590 
<a name="l00591"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a65">00591</a> <span class="keyword">typedef</span> <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> (*PCOMPLETE_LOCK_IRP_ROUTINE) (
00592     IN PVOID Context,
00593     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>
00594     );
00595 
<a name="l00596"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a66">00596</a> <span class="keyword">typedef</span> <a class="code" href="../../d0/d6/iop_8h.html#a145">VOID</a> (*PUNLOCK_ROUTINE) (
00597     IN PVOID Context,
00598     IN <a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html">PFILE_LOCK_INFO</a> FileLockInfo
00599     );
00600 
00601 <span class="comment">//</span>
00602 <span class="comment">//  A FILE_LOCK is an opaque structure but we need to declare the size of</span>
00603 <span class="comment">//  it here so that users can allocate space for one.</span>
00604 <span class="comment">//</span>
00605 
<a name="l00606"></a><a class="code" href="../../d7/d1/struct__FILE__LOCK.html">00606</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d7/d1/struct__FILE__LOCK.html">_FILE_LOCK</a> {
00607 
00608     <span class="comment">//</span>
00609     <span class="comment">//  The optional procedure to call to complete a request</span>
00610     <span class="comment">//</span>
00611 
<a name="l00612"></a><a class="code" href="../../d7/d1/struct__FILE__LOCK.html#o0">00612</a>     <a class="code" href="../../d1/d8/fsrtl_8h.html#a65">PCOMPLETE_LOCK_IRP_ROUTINE</a> CompleteLockIrpRoutine;
00613 
00614     <span class="comment">//</span>
00615     <span class="comment">//  The optional procedure to call when unlocking a byte range</span>
00616     <span class="comment">//</span>
00617 
<a name="l00618"></a><a class="code" href="../../d7/d1/struct__FILE__LOCK.html#o1">00618</a>     <a class="code" href="../../d1/d8/fsrtl_8h.html#a66">PUNLOCK_ROUTINE</a> UnlockRoutine;
00619 
00620     <span class="comment">//</span>
00621     <span class="comment">//  FastIoIsQuestionable is set to true when... bugbug</span>
00622     <span class="comment">//</span>
00623 
<a name="l00624"></a><a class="code" href="../../d7/d1/struct__FILE__LOCK.html#o2">00624</a>     BOOLEAN <a class="code" href="../../d1/d8/fsrtl_8h.html#a188a88">FastIoIsQuestionable</a>;
<a name="l00625"></a><a class="code" href="../../d7/d1/struct__FILE__LOCK.html#o3">00625</a>     BOOLEAN SpareC[3];
00626 
00627     <span class="comment">//</span>
00628     <span class="comment">//  FsRtl lock information</span>
00629     <span class="comment">//</span>
00630 
<a name="l00631"></a><a class="code" href="../../d7/d1/struct__FILE__LOCK.html#o4">00631</a>     PVOID   LockInformation;
00632 
00633     <span class="comment">//</span>
00634     <span class="comment">//  Contains contination information for FsRtlGetNextFileLock</span>
00635     <span class="comment">//</span>
00636 
<a name="l00637"></a><a class="code" href="../../d7/d1/struct__FILE__LOCK.html#o5">00637</a>     <a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html">FILE_LOCK_INFO</a>  LastReturnedLockInfo;
<a name="l00638"></a><a class="code" href="../../d7/d1/struct__FILE__LOCK.html#o6">00638</a>     PVOID           LastReturnedLock;
00639 
00640 } <a class="code" href="../../d7/d1/struct__FILE__LOCK.html">FILE_LOCK</a>;
<a name="l00641"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a68">00641</a> <span class="keyword">typedef</span> <a class="code" href="../../d7/d1/struct__FILE__LOCK.html">FILE_LOCK</a> *<a class="code" href="../../d7/d1/struct__FILE__LOCK.html">PFILE_LOCK</a>;
00642 
00643 <a class="code" href="../../d7/d1/struct__FILE__LOCK.html">PFILE_LOCK</a>
00644 <a class="code" href="../../d1/d8/fsrtl_8h.html#a112">FsRtlAllocateFileLock</a> (
00645     IN PCOMPLETE_LOCK_IRP_ROUTINE CompleteLockIrpRoutine OPTIONAL,
00646     IN PUNLOCK_ROUTINE UnlockRoutine OPTIONAL
00647     );
00648 
00649 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00650 <a class="code" href="../../d1/d8/fsrtl_8h.html#a113">FsRtlFreeFileLock</a> (
00651     IN <a class="code" href="../../d7/d1/struct__FILE__LOCK.html">PFILE_LOCK</a> FileLock
00652     );
00653 
00654 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00655 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00656 <a class="code" href="../../d1/d8/fsrtl_8h.html#a114">FsRtlInitializeFileLock</a> (
00657     IN <a class="code" href="../../d7/d1/struct__FILE__LOCK.html">PFILE_LOCK</a> FileLock,
00658     IN PCOMPLETE_LOCK_IRP_ROUTINE CompleteLockIrpRoutine OPTIONAL,
00659     IN PUNLOCK_ROUTINE UnlockRoutine OPTIONAL
00660     );
00661 
00662 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00663 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00664 <a class="code" href="../../d1/d8/fsrtl_8h.html#a115">FsRtlUninitializeFileLock</a> (
00665     IN <a class="code" href="../../d7/d1/struct__FILE__LOCK.html">PFILE_LOCK</a> FileLock
00666     );
00667 
00668 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00669 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00670 <a class="code" href="../../d1/d8/fsrtl_8h.html#a116">FsRtlProcessFileLock</a> (
00671     IN <a class="code" href="../../d7/d1/struct__FILE__LOCK.html">PFILE_LOCK</a> FileLock,
00672     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp,
00673     IN PVOID Context OPTIONAL
00674     );
00675 
00676 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00677 BOOLEAN
00678 <a class="code" href="../../d1/d8/fsrtl_8h.html#a117">FsRtlCheckLockForReadAccess</a> (
00679     IN <a class="code" href="../../d7/d1/struct__FILE__LOCK.html">PFILE_LOCK</a> FileLock,
00680     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp
00681     );
00682 
00683 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00684 BOOLEAN
00685 <a class="code" href="../../d1/d8/fsrtl_8h.html#a118">FsRtlCheckLockForWriteAccess</a> (
00686     IN <a class="code" href="../../d7/d1/struct__FILE__LOCK.html">PFILE_LOCK</a> FileLock,
00687     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp
00688     );
00689 
00690 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00691 BOOLEAN
00692 <a class="code" href="../../d1/d8/fsrtl_8h.html#a119">FsRtlFastCheckLockForRead</a> (
00693     IN <a class="code" href="../../d7/d1/struct__FILE__LOCK.html">PFILE_LOCK</a> FileLock,
00694     IN PLARGE_INTEGER StartingByte,
00695     IN PLARGE_INTEGER Length,
00696     IN ULONG Key,
00697     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
00698     IN PVOID ProcessId
00699     );
00700 
00701 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00702 BOOLEAN
00703 <a class="code" href="../../d1/d8/fsrtl_8h.html#a120">FsRtlFastCheckLockForWrite</a> (
00704     IN <a class="code" href="../../d7/d1/struct__FILE__LOCK.html">PFILE_LOCK</a> FileLock,
00705     IN PLARGE_INTEGER StartingByte,
00706     IN PLARGE_INTEGER Length,
00707     IN ULONG Key,
00708     IN PVOID FileObject,
00709     IN PVOID ProcessId
00710     );
00711 
00712 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00713 <a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html">PFILE_LOCK_INFO</a>
00714 <a class="code" href="../../d1/d8/fsrtl_8h.html#a121">FsRtlGetNextFileLock</a> (
00715     IN <a class="code" href="../../d7/d1/struct__FILE__LOCK.html">PFILE_LOCK</a> FileLock,
00716     IN BOOLEAN Restart
00717     );
00718 
00719 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00720 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00721 <a class="code" href="../../d1/d8/fsrtl_8h.html#a122">FsRtlFastUnlockSingle</a> (
00722     IN <a class="code" href="../../d7/d1/struct__FILE__LOCK.html">PFILE_LOCK</a> FileLock,
00723     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
00724     IN LARGE_INTEGER UNALIGNED *FileOffset,
00725     IN PLARGE_INTEGER Length,
00726     IN <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> ProcessId,
00727     IN ULONG Key,
00728     IN PVOID Context OPTIONAL,
00729     IN BOOLEAN AlreadySynchronized
00730     );
00731 
00732 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00733 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00734 <a class="code" href="../../d1/d8/fsrtl_8h.html#a123">FsRtlFastUnlockAll</a> (
00735     IN <a class="code" href="../../d7/d1/struct__FILE__LOCK.html">PFILE_LOCK</a> FileLock,
00736     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
00737     IN <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> ProcessId,
00738     IN PVOID Context OPTIONAL
00739     );
00740 
00741 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00742 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00743 <a class="code" href="../../d1/d8/fsrtl_8h.html#a124">FsRtlFastUnlockAllByKey</a> (
00744     IN <a class="code" href="../../d7/d1/struct__FILE__LOCK.html">PFILE_LOCK</a> FileLock,
00745     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
00746     IN <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> ProcessId,
00747     IN ULONG Key,
00748     IN PVOID Context OPTIONAL
00749     );
00750 
00751 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00752 BOOLEAN
00753 <a class="code" href="../../d1/d8/fsrtl_8h.html#a125">FsRtlPrivateLock</a> (
00754     IN <a class="code" href="../../d7/d1/struct__FILE__LOCK.html">PFILE_LOCK</a> FileLock,
00755     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
00756     IN PLARGE_INTEGER FileOffset,
00757     IN PLARGE_INTEGER Length,
00758     IN <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> ProcessId,
00759     IN ULONG Key,
00760     IN BOOLEAN FailImmediately,
00761     IN BOOLEAN ExclusiveLock,
00762     OUT PIO_STATUS_BLOCK Iosb,
00763     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp,
00764     IN PVOID Context,
00765     IN BOOLEAN AlreadySynchronized
00766     );
00767 
00768 <span class="comment">//</span>
00769 <span class="comment">//  BOOLEAN</span>
00770 <span class="comment">//  FsRtlFastLock (</span>
00771 <span class="comment">//      IN PFILE_LOCK FileLock,</span>
00772 <span class="comment">//      IN PFILE_OBJECT FileObject,</span>
00773 <span class="comment">//      IN PLARGE_INTEGER FileOffset,</span>
00774 <span class="comment">//      IN PLARGE_INTEGER Length,</span>
00775 <span class="comment">//      IN PEPROCESS ProcessId,</span>
00776 <span class="comment">//      IN ULONG Key,</span>
00777 <span class="comment">//      IN BOOLEAN FailImmediately,</span>
00778 <span class="comment">//      IN BOOLEAN ExclusiveLock,</span>
00779 <span class="comment">//      OUT PIO_STATUS_BLOCK Iosb,</span>
00780 <span class="comment">//      IN PVOID Context OPTIONAL,</span>
00781 <span class="comment">//      IN BOOLEAN AlreadySynchronized</span>
00782 <span class="comment">//      );</span>
00783 <span class="comment">//</span>
00784 
<a name="l00785"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a18">00785</a> <span class="preprocessor">#define FsRtlFastLock(A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,A11) ( \</span>
00786 <span class="preprocessor">    FsRtlPrivateLock( A1,   </span><span class="comment">/* FileLock            */</span>       \
00787                       A2,   <span class="comment">/* FileObject          */</span>       \
00788                       A3,   <span class="comment">/* FileOffset          */</span>       \
00789                       A4,   <span class="comment">/* Length              */</span>       \
00790                       A5,   <span class="comment">/* ProcessId           */</span>       \
00791                       A6,   <span class="comment">/* Key                 */</span>       \
00792                       A7,   <span class="comment">/* FailImmediately     */</span>       \
00793                       A8,   <span class="comment">/* ExclusiveLock       */</span>       \
00794                       A9,   <span class="comment">/* Iosb                */</span>       \
00795                       NULL, <span class="comment">/* Irp                 */</span>       \
00796                       A10,  <span class="comment">/* Context             */</span>       \
00797                       A11   <span class="comment">/* AlreadySynchronized */</span> )     \
00798 )
00799 
00800 <span class="comment">//</span>
00801 <span class="comment">//  BOOLEAN</span>
00802 <span class="comment">//  FsRtlAreThereCurrentFileLocks (</span>
00803 <span class="comment">//      IN PFILE_LOCK FileLock</span>
00804 <span class="comment">//      );</span>
00805 <span class="comment">//</span>
00806 
<a name="l00807"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a19">00807</a> <span class="preprocessor">#define FsRtlAreThereCurrentFileLocks(FL) ( \</span>
00808 <span class="preprocessor">    ((FL)-&gt;FastIoIsQuestionable))</span>
00809 <span class="preprocessor"></span>
00810 
00811 
00812 <span class="comment">//</span>
00813 <span class="comment">//  Filesystem property tunneling, implemented in tunnel.c</span>
00814 <span class="comment">//</span>
00815 
00816 <span class="comment">//</span>
00817 <span class="comment">//  Tunnel cache structure</span>
00818 <span class="comment">//</span>
00819 
<a name="l00820"></a><a class="code" href="../../d4/d1/structTUNNEL.html">00820</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
00821 
00822     <span class="comment">//</span>
00823     <span class="comment">//  Mutex for cache manipulation</span>
00824     <span class="comment">//</span>
00825 
<a name="l00826"></a><a class="code" href="../../d4/d1/structTUNNEL.html#o0">00826</a>     <a class="code" href="../../d6/d9/struct__FAST__MUTEX.html">FAST_MUTEX</a>          Mutex;
00827 
00828     <span class="comment">//</span>
00829     <span class="comment">//  Splay Tree of tunneled information keyed by</span>
00830     <span class="comment">//  DirKey ## Name</span>
00831     <span class="comment">//</span>
00832 
<a name="l00833"></a><a class="code" href="../../d4/d1/structTUNNEL.html#o1">00833</a>     PRTL_SPLAY_LINKS    Cache;
00834 
00835     <span class="comment">//</span>
00836     <span class="comment">//  Timer queue used to age entries out of the main cache</span>
00837     <span class="comment">//</span>
00838 
<a name="l00839"></a><a class="code" href="../../d4/d1/structTUNNEL.html#o2">00839</a>     LIST_ENTRY          TimerQueue;
00840 
00841     <span class="comment">//</span>
00842     <span class="comment">//  Keep track of the number of entries in the cache to prevent</span>
00843     <span class="comment">//  excessive use of memory</span>
00844     <span class="comment">//</span>
00845 
<a name="l00846"></a><a class="code" href="../../d4/d1/structTUNNEL.html#o3">00846</a>     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>              NumEntries;
00847 
00848 } <a class="code" href="../../d4/d1/structTUNNEL.html">TUNNEL</a>, *<a class="code" href="../../d1/d8/fsrtl_8h.html#a69">PTUNNEL</a>;
00849 
00850 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00851 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00852 <a class="code" href="../../d1/d8/fsrtl_8h.html#a126">FsRtlInitializeTunnelCache</a> (
00853     IN <a class="code" href="../../d4/d1/structTUNNEL.html">TUNNEL</a> *Cache);
00854 
00855 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00856 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00857 <a class="code" href="../../d1/d8/fsrtl_8h.html#a127">FsRtlAddToTunnelCache</a> (
00858     IN <a class="code" href="../../d4/d1/structTUNNEL.html">TUNNEL</a> *Cache,
00859     IN ULONGLONG DirectoryKey,
00860     IN UNICODE_STRING *ShortName,
00861     IN UNICODE_STRING *LongName,
00862     IN BOOLEAN KeyByShortName,
00863     IN ULONG DataLength,
00864     IN VOID *Data);
00865 
00866 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00867 BOOLEAN
00868 <a class="code" href="../../d1/d8/fsrtl_8h.html#a128">FsRtlFindInTunnelCache</a> (
00869     IN <a class="code" href="../../d4/d1/structTUNNEL.html">TUNNEL</a> *Cache,
00870     IN ULONGLONG DirectoryKey,
00871     IN UNICODE_STRING *Name,
00872     OUT UNICODE_STRING *ShortName,
00873     OUT UNICODE_STRING *LongName,
00874     IN OUT ULONG  *DataLength,
00875     OUT VOID *Data);
00876 
00877 
00878 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00879 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00880 <a class="code" href="../../d1/d8/fsrtl_8h.html#a129">FsRtlDeleteKeyFromTunnelCache</a> (
00881     IN <a class="code" href="../../d4/d1/structTUNNEL.html">TUNNEL</a> *Cache,
00882     IN ULONGLONG DirectoryKey);
00883 
00884 
00885 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00886 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00887 <a class="code" href="../../d1/d8/fsrtl_8h.html#a130">FsRtlDeleteTunnelCache</a> (
00888     IN <a class="code" href="../../d4/d1/structTUNNEL.html">TUNNEL</a> *Cache);
00889 
00890 
00891 <span class="comment">//</span>
00892 <span class="comment">//  Dbcs name support routines, implemented in DbcsName.c</span>
00893 <span class="comment">//</span>
00894 
00895 <span class="comment">//</span>
00896 <span class="comment">//  The following enumerated type is used to denote the result of name</span>
00897 <span class="comment">//  comparisons</span>
00898 <span class="comment">//</span>
00899 
<a name="l00900"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a189">00900</a> <span class="keyword">typedef</span> <span class="keyword">enum</span> <a class="code" href="../../d1/d8/fsrtl_8h.html#a189">_FSRTL_COMPARISON_RESULT</a> {
00901     <a class="code" href="../../d1/d8/fsrtl_8h.html#a189a89">LessThan</a> = -1,
00902     <a class="code" href="../../d1/d8/fsrtl_8h.html#a189a90">EqualTo</a> = 0,
00903     <a class="code" href="../../d1/d8/fsrtl_8h.html#a189a91">GreaterThan</a> = 1
00904 } <a class="code" href="../../d1/d8/fsrtl_8h.html#a70">FSRTL_COMPARISON_RESULT</a>;
00905 
00906 <span class="preprocessor">#ifdef NLS_MB_CODE_PAGE_TAG</span>
00907 <span class="preprocessor"></span><span class="preprocessor">#undef NLS_MB_CODE_PAGE_TAG</span>
00908 <span class="preprocessor"></span><span class="preprocessor">#endif // NLS_MB_CODE_PAGE_TAG</span>
00909 <span class="preprocessor"></span>
00910 <span class="comment">// end_ntifs</span>
00911 <span class="preprocessor">#if defined(_NTIFS_) || defined(_NTDRIVER_)</span>
00912 <span class="preprocessor"></span><span class="comment">// begin_ntifs</span>
00913 
00914 <span class="preprocessor">#define LEGAL_ANSI_CHARACTER_ARRAY        (*FsRtlLegalAnsiCharacterArray)</span>
00915 <span class="preprocessor"></span><span class="preprocessor">#define NLS_MB_CODE_PAGE_TAG              (*NlsMbOemCodePageTag)</span>
00916 <span class="preprocessor"></span><span class="preprocessor">#define NLS_OEM_LEAD_BYTE_INFO            (*NlsOemLeadByteInfo)</span>
00917 <span class="preprocessor"></span>
00918 <span class="comment">// end_ntifs</span>
00919 <span class="preprocessor">#else</span>
00920 <span class="preprocessor"></span>
<a name="l00921"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a20">00921</a> <span class="preprocessor">#define LEGAL_ANSI_CHARACTER_ARRAY        FsRtlLegalAnsiCharacterArray</span>
<a name="l00922"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a21">00922</a> <span class="preprocessor"></span><span class="preprocessor">#define NLS_MB_CODE_PAGE_TAG              NlsMbOemCodePageTag</span>
<a name="l00923"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a22">00923</a> <span class="preprocessor"></span><span class="preprocessor">#define NLS_OEM_LEAD_BYTE_INFO            NlsOemLeadByteInfo</span>
00924 <span class="preprocessor"></span>
00925 <span class="preprocessor">#endif</span>
00926 <span class="preprocessor"></span><span class="comment">// begin_ntifs</span>
00927 
<a name="l00928"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a71">00928</a> <span class="keyword">extern</span> PUCHAR <a class="code" href="../../d1/d8/fsrtl_8h.html#a20">LEGAL_ANSI_CHARACTER_ARRAY</a>;
<a name="l00929"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a72">00929</a> <span class="keyword">extern</span> <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a> <a class="code" href="../../d1/d8/fsrtl_8h.html#a22">NLS_OEM_LEAD_BYTE_INFO</a>;  <span class="comment">// Lead byte info. for ACP</span>
00930 
00931 <span class="comment">//</span>
00932 <span class="comment">//  These following bit values are set in the FsRtlLegalDbcsCharacterArray</span>
00933 <span class="comment">//</span>
00934 
<a name="l00935"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a23">00935</a> <span class="preprocessor">#define FSRTL_FAT_LEGAL         0x01</span>
<a name="l00936"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a24">00936</a> <span class="preprocessor"></span><span class="preprocessor">#define FSRTL_HPFS_LEGAL        0x02</span>
<a name="l00937"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a25">00937</a> <span class="preprocessor"></span><span class="preprocessor">#define FSRTL_NTFS_LEGAL        0x04</span>
<a name="l00938"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a26">00938</a> <span class="preprocessor"></span><span class="preprocessor">#define FSRTL_WILD_CHARACTER    0x08</span>
<a name="l00939"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a27">00939</a> <span class="preprocessor"></span><span class="preprocessor">#define FSRTL_OLE_LEGAL         0x10</span>
<a name="l00940"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a28">00940</a> <span class="preprocessor"></span><span class="preprocessor">#define FSRTL_NTFS_STREAM_LEGAL (FSRTL_NTFS_LEGAL | FSRTL_OLE_LEGAL)</span>
00941 <span class="preprocessor"></span>
00942 <span class="comment">//</span>
00943 <span class="comment">//  The following macro is used to determine if an Ansi character is wild.</span>
00944 <span class="comment">//</span>
00945 
<a name="l00946"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a29">00946</a> <span class="preprocessor">#define FsRtlIsAnsiCharacterWild(C) (                               \</span>
00947 <span class="preprocessor">    FsRtlTestAnsiCharacter((C), FALSE, FALSE, FSRTL_WILD_CHARACTER) \</span>
00948 <span class="preprocessor">)</span>
00949 <span class="preprocessor"></span>
00950 <span class="comment">//</span>
00951 <span class="comment">//  The following macro is used to determine if an Ansi character is Fat legal.</span>
00952 <span class="comment">//</span>
00953 
<a name="l00954"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a30">00954</a> <span class="preprocessor">#define FsRtlIsAnsiCharacterLegalFat(C,WILD_OK) (                 \</span>
00955 <span class="preprocessor">    FsRtlTestAnsiCharacter((C), TRUE, (WILD_OK), FSRTL_FAT_LEGAL) \</span>
00956 <span class="preprocessor">)</span>
00957 <span class="preprocessor"></span>
00958 <span class="comment">//</span>
00959 <span class="comment">//  The following macro is used to determine if an Ansi character is Hpfs legal.</span>
00960 <span class="comment">//</span>
00961 
<a name="l00962"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a31">00962</a> <span class="preprocessor">#define FsRtlIsAnsiCharacterLegalHpfs(C,WILD_OK) (                 \</span>
00963 <span class="preprocessor">    FsRtlTestAnsiCharacter((C), TRUE, (WILD_OK), FSRTL_HPFS_LEGAL) \</span>
00964 <span class="preprocessor">)</span>
00965 <span class="preprocessor"></span>
00966 <span class="comment">//</span>
00967 <span class="comment">//  The following macro is used to determine if an Ansi character is Ntfs legal.</span>
00968 <span class="comment">//</span>
00969 
<a name="l00970"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a32">00970</a> <span class="preprocessor">#define FsRtlIsAnsiCharacterLegalNtfs(C,WILD_OK) (                 \</span>
00971 <span class="preprocessor">    FsRtlTestAnsiCharacter((C), TRUE, (WILD_OK), FSRTL_NTFS_LEGAL) \</span>
00972 <span class="preprocessor">)</span>
00973 <span class="preprocessor"></span>
00974 <span class="comment">//</span>
00975 <span class="comment">//  The following macro is used to determine if an Ansi character is</span>
00976 <span class="comment">//  legal in an Ntfs stream name</span>
00977 <span class="comment">//</span>
00978 
<a name="l00979"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a33">00979</a> <span class="preprocessor">#define FsRtlIsAnsiCharacterLegalNtfsStream(C,WILD_OK) (                    \</span>
00980 <span class="preprocessor">    FsRtlTestAnsiCharacter((C), TRUE, (WILD_OK), FSRTL_NTFS_STREAM_LEGAL)   \</span>
00981 <span class="preprocessor">)</span>
00982 <span class="preprocessor"></span>
00983 <span class="comment">//</span>
00984 <span class="comment">//  The following macro is used to determine if an Ansi character is legal,</span>
00985 <span class="comment">//  according to the caller's specification.</span>
00986 <span class="comment">//</span>
00987 
<a name="l00988"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a34">00988</a> <span class="preprocessor">#define FsRtlIsAnsiCharacterLegal(C,FLAGS) (          \</span>
00989 <span class="preprocessor">    FsRtlTestAnsiCharacter((C), TRUE, FALSE, (FLAGS)) \</span>
00990 <span class="preprocessor">)</span>
00991 <span class="preprocessor"></span>
00992 <span class="comment">//</span>
00993 <span class="comment">//  The following macro is used to test attributes of an Ansi character,</span>
00994 <span class="comment">//  according to the caller's specified flags.</span>
00995 <span class="comment">//</span>
00996 
<a name="l00997"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a35">00997</a> <span class="preprocessor">#define FsRtlTestAnsiCharacter(C, DEFAULT_RET, WILD_OK, FLAGS) (            \</span>
00998 <span class="preprocessor">        ((SCHAR)(C) &lt; 0) ? DEFAULT_RET :                                    \</span>
00999 <span class="preprocessor">                           FlagOn( LEGAL_ANSI_CHARACTER_ARRAY[(C)],         \</span>
01000 <span class="preprocessor">                                   (FLAGS) |                                \</span>
01001 <span class="preprocessor">                                   ((WILD_OK) ? FSRTL_WILD_CHARACTER : 0) ) \</span>
01002 <span class="preprocessor">)</span>
01003 <span class="preprocessor"></span>
01004 
01005 <span class="comment">//</span>
01006 <span class="comment">//  The following two macros use global data defined in ntos\rtl\nlsdata.c</span>
01007 <span class="comment">//</span>
01008 <span class="comment">//  BOOLEAN</span>
01009 <span class="comment">//  FsRtlIsLeadDbcsCharacter (</span>
01010 <span class="comment">//      IN UCHAR DbcsCharacter</span>
01011 <span class="comment">//      );</span>
01012 <span class="comment">//</span>
01013 <span class="comment">//  /*++</span>
01014 <span class="comment">//</span>
01015 <span class="comment">//  Routine Description:</span>
01016 <span class="comment">//</span>
01017 <span class="comment">//      This routine takes the first bytes of a Dbcs character and</span>
01018 <span class="comment">//      returns whether it is a lead byte in the system code page.</span>
01019 <span class="comment">//</span>
01020 <span class="comment">//  Arguments:</span>
01021 <span class="comment">//</span>
01022 <span class="comment">//      DbcsCharacter - Supplies the input character being examined</span>
01023 <span class="comment">//</span>
01024 <span class="comment">//  Return Value:</span>
01025 <span class="comment">//</span>
01026 <span class="comment">//      BOOLEAN - TRUE if the input character is a dbcs lead and</span>
01027 <span class="comment">//              FALSE otherwise</span>
01028 <span class="comment">//</span>
01029 <span class="comment">//  --*/</span>
01030 <span class="comment">//</span>
01031 <span class="comment">//</span>
01032 
<a name="l01033"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a36">01033</a> <span class="preprocessor">#define FsRtlIsLeadDbcsCharacter(DBCS_CHAR) (                      \</span>
01034 <span class="preprocessor">    (BOOLEAN)((UCHAR)(DBCS_CHAR) &lt; 0x80 ? FALSE :                  \</span>
01035 <span class="preprocessor">              (NLS_MB_CODE_PAGE_TAG &amp;&amp;                             \</span>
01036 <span class="preprocessor">               (NLS_OEM_LEAD_BYTE_INFO[(UCHAR)(DBCS_CHAR)] != 0))) \</span>
01037 <span class="preprocessor">)</span>
01038 <span class="preprocessor"></span>
01039 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01040 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01041 <a class="code" href="../../d1/d8/fsrtl_8h.html#a131">FsRtlDissectDbcs</a> (
01042     IN ANSI_STRING InputName,
01043     OUT PANSI_STRING FirstPart,
01044     OUT PANSI_STRING RemainingPart
01045     );
01046 
01047 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01048 BOOLEAN
01049 <a class="code" href="../../d1/d8/fsrtl_8h.html#a132">FsRtlDoesDbcsContainWildCards</a> (
01050     IN PANSI_STRING Name
01051     );
01052 
01053 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01054 BOOLEAN
01055 <a class="code" href="../../d1/d8/fsrtl_8h.html#a133">FsRtlIsDbcsInExpression</a> (
01056     IN PANSI_STRING Expression,
01057     IN PANSI_STRING Name
01058     );
01059 
01060 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01061 BOOLEAN
01062 <a class="code" href="../../d1/d8/fsrtl_8h.html#a134">FsRtlIsFatDbcsLegal</a> (
01063     IN ANSI_STRING DbcsName,
01064     IN BOOLEAN WildCardsPermissible,
01065     IN BOOLEAN PathNamePermissible,
01066     IN BOOLEAN LeadingBackslashPermissible
01067     );
01068 
01069 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01070 BOOLEAN
01071 <a class="code" href="../../d1/d8/fsrtl_8h.html#a135">FsRtlIsHpfsDbcsLegal</a> (
01072     IN ANSI_STRING DbcsName,
01073     IN BOOLEAN WildCardsPermissible,
01074     IN BOOLEAN PathNamePermissible,
01075     IN BOOLEAN LeadingBackslashPermissible
01076     );
01077 
01078 
01079 <span class="comment">//</span>
01080 <span class="comment">//  Exception filter routines, implemented in Filter.c</span>
01081 <span class="comment">//</span>
01082 
01083 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01084 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01085 <a class="code" href="../../d1/d8/fsrtl_8h.html#a136">FsRtlNormalizeNtstatus</a> (
01086     IN NTSTATUS Exception,
01087     IN NTSTATUS GenericException
01088     );
01089 
01090 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01091 BOOLEAN
01092 <a class="code" href="../../d1/d8/fsrtl_8h.html#a137">FsRtlIsNtstatusExpected</a> (
01093     IN NTSTATUS Exception
01094     );
01095 
01096 <span class="comment">//</span>
01097 <span class="comment">//  The following procedures are used to allocate executive pool and raise</span>
01098 <span class="comment">//  insufficient resource status if pool isn't currently available.</span>
01099 <span class="comment">//</span>
01100 
<a name="l01101"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a37">01101</a> <span class="preprocessor">#define FsRtlAllocatePoolWithTag(PoolType, NumberOfBytes, Tag)                \</span>
01102 <span class="preprocessor">    ExAllocatePoolWithTag((POOL_TYPE)((PoolType) | POOL_RAISE_IF_ALLOCATION_FAILURE), \</span>
01103 <span class="preprocessor">                          NumberOfBytes,                                      \</span>
01104 <span class="preprocessor">                          Tag)</span>
01105 <span class="preprocessor"></span>
01106 
<a name="l01107"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a38">01107</a> <span class="preprocessor">#define FsRtlAllocatePoolWithQuotaTag(PoolType, NumberOfBytes, Tag)           \</span>
01108 <span class="preprocessor">    ExAllocatePoolWithQuotaTag((POOL_TYPE)((PoolType) | POOL_RAISE_IF_ALLOCATION_FAILURE), \</span>
01109 <span class="preprocessor">                               NumberOfBytes,                                 \</span>
01110 <span class="preprocessor">                               Tag)</span>
01111 <span class="preprocessor"></span>
01112 <span class="comment">//</span>
01113 <span class="comment">//  The following function allocates a resource from the FsRtl pool.</span>
01114 <span class="comment">//</span>
01115 
01116 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01117 <a class="code" href="../../d6/d4/struct__ERESOURCE.html">PERESOURCE</a>
01118 <a class="code" href="../../d4/d8/fsrtlpc_8c.html#a16">FsRtlAllocateResource</a> (
01119     );
01120 
01121 
01122 <span class="comment">//</span>
01123 <span class="comment">//  Large Integer Mapped Control Blocks routines, implemented in LargeMcb.c</span>
01124 <span class="comment">//</span>
01125 <span class="comment">//  Originally this structure was truely opaque and code outside largemcb was</span>
01126 <span class="comment">//  never allowed to examine or alter the structures.  However, for performance</span>
01127 <span class="comment">//  reasons we want to allow ntfs the ability to quickly truncate down the</span>
01128 <span class="comment">//  mcb without the overhead of an actual call to largemcb.c.  So to do that we</span>
01129 <span class="comment">//  need to export the struture.  This structure is not exact.  The Mapping field</span>
01130 <span class="comment">//  is declared here as a pvoid but largemcb.c it is a pointer to mapping pairs.</span>
01131 <span class="comment">//</span>
01132 
<a name="l01133"></a><a class="code" href="../../d0/d9/struct__LARGE__MCB.html">01133</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d0/d9/struct__LARGE__MCB.html">_LARGE_MCB</a> {
<a name="l01134"></a><a class="code" href="../../d0/d9/struct__LARGE__MCB.html#o0">01134</a>     <a class="code" href="../../d6/d9/struct__FAST__MUTEX.html">PFAST_MUTEX</a> FastMutex;
<a name="l01135"></a><a class="code" href="../../d0/d9/struct__LARGE__MCB.html#o1">01135</a>     ULONG MaximumPairCount;
<a name="l01136"></a><a class="code" href="../../d0/d9/struct__LARGE__MCB.html#o2">01136</a>     ULONG PairCount;
<a name="l01137"></a><a class="code" href="../../d0/d9/struct__LARGE__MCB.html#o3">01137</a>     <a class="code" href="../../d5/d8/ex_8h.html#a96">POOL_TYPE</a> PoolType;
<a name="l01138"></a><a class="code" href="../../d0/d9/struct__LARGE__MCB.html#o4">01138</a>     PVOID Mapping;
01139 } <a class="code" href="../../d0/d9/struct__LARGE__MCB.html">LARGE_MCB</a>;
<a name="l01140"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a74">01140</a> <span class="keyword">typedef</span> <a class="code" href="../../d0/d9/struct__LARGE__MCB.html">LARGE_MCB</a> *<a class="code" href="../../d0/d9/struct__LARGE__MCB.html">PLARGE_MCB</a>;
01141 
01142 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01143 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01144 <a class="code" href="../../d1/d8/fsrtl_8h.html#a139">FsRtlInitializeLargeMcb</a> (
01145     IN <a class="code" href="../../d0/d9/struct__LARGE__MCB.html">PLARGE_MCB</a> Mcb,
01146     IN POOL_TYPE PoolType
01147     );
01148 
01149 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01150 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01151 <a class="code" href="../../d1/d8/fsrtl_8h.html#a140">FsRtlUninitializeLargeMcb</a> (
01152     IN <a class="code" href="../../d0/d9/struct__LARGE__MCB.html">PLARGE_MCB</a> Mcb
01153     );
01154 
01155 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01156 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01157 <a class="code" href="../../d1/d8/fsrtl_8h.html#a141">FsRtlResetLargeMcb</a> (
01158     IN <a class="code" href="../../d0/d9/struct__LARGE__MCB.html">PLARGE_MCB</a> Mcb,
01159     IN BOOLEAN SelfSynchronized
01160     );
01161 
01162 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01163 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01164 <a class="code" href="../../d1/d8/fsrtl_8h.html#a142">FsRtlTruncateLargeMcb</a> (
01165     IN <a class="code" href="../../d0/d9/struct__LARGE__MCB.html">PLARGE_MCB</a> Mcb,
01166     IN LONGLONG Vbn
01167     );
01168 
01169 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01170 BOOLEAN
01171 <a class="code" href="../../d1/d8/fsrtl_8h.html#a143">FsRtlAddLargeMcbEntry</a> (
01172     IN <a class="code" href="../../d0/d9/struct__LARGE__MCB.html">PLARGE_MCB</a> Mcb,
01173     IN LONGLONG Vbn,
01174     IN LONGLONG Lbn,
01175     IN LONGLONG SectorCount
01176     );
01177 
01178 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01179 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01180 <a class="code" href="../../d1/d8/fsrtl_8h.html#a144">FsRtlRemoveLargeMcbEntry</a> (
01181     IN <a class="code" href="../../d0/d9/struct__LARGE__MCB.html">PLARGE_MCB</a> Mcb,
01182     IN LONGLONG Vbn,
01183     IN LONGLONG SectorCount
01184     );
01185 
01186 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01187 BOOLEAN
01188 <a class="code" href="../../d1/d8/fsrtl_8h.html#a145">FsRtlLookupLargeMcbEntry</a> (
01189     IN <a class="code" href="../../d0/d9/struct__LARGE__MCB.html">PLARGE_MCB</a> Mcb,
01190     IN LONGLONG Vbn,
01191     OUT PLONGLONG Lbn OPTIONAL,
01192     OUT PLONGLONG SectorCountFromLbn OPTIONAL,
01193     OUT PLONGLONG StartingLbn OPTIONAL,
01194     OUT PLONGLONG SectorCountFromStartingLbn OPTIONAL,
01195     OUT PULONG Index OPTIONAL
01196     );
01197 
01198 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01199 BOOLEAN
01200 <a class="code" href="../../d1/d8/fsrtl_8h.html#a146">FsRtlLookupLastLargeMcbEntry</a> (
01201     IN <a class="code" href="../../d0/d9/struct__LARGE__MCB.html">PLARGE_MCB</a> Mcb,
01202     OUT PLONGLONG Vbn,
01203     OUT PLONGLONG Lbn
01204     );
01205 
01206 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01207 BOOLEAN
01208 <a class="code" href="../../d1/d8/fsrtl_8h.html#a147">FsRtlLookupLastLargeMcbEntryAndIndex</a> (
01209     IN <a class="code" href="../../d0/d9/struct__LARGE__MCB.html">PLARGE_MCB</a> OpaqueMcb,
01210     OUT PLONGLONG LargeVbn,
01211     OUT PLONGLONG LargeLbn,
01212     OUT PULONG Index
01213     );
01214 
01215 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01216 ULONG
01217 <a class="code" href="../../d1/d8/fsrtl_8h.html#a148">FsRtlNumberOfRunsInLargeMcb</a> (
01218     IN <a class="code" href="../../d0/d9/struct__LARGE__MCB.html">PLARGE_MCB</a> Mcb
01219     );
01220 
01221 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01222 BOOLEAN
01223 <a class="code" href="../../d1/d8/fsrtl_8h.html#a149">FsRtlGetNextLargeMcbEntry</a> (
01224     IN <a class="code" href="../../d0/d9/struct__LARGE__MCB.html">PLARGE_MCB</a> Mcb,
01225     IN ULONG RunIndex,
01226     OUT PLONGLONG Vbn,
01227     OUT PLONGLONG Lbn,
01228     OUT PLONGLONG SectorCount
01229     );
01230 
01231 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01232 BOOLEAN
01233 <a class="code" href="../../d1/d8/fsrtl_8h.html#a150">FsRtlSplitLargeMcb</a> (
01234     IN <a class="code" href="../../d0/d9/struct__LARGE__MCB.html">PLARGE_MCB</a> Mcb,
01235     IN LONGLONG Vbn,
01236     IN LONGLONG Amount
01237     );
01238 
01239 
01240 <span class="comment">//</span>
01241 <span class="comment">//  Mapped Control Blocks routines, implemented in Mcb.c</span>
01242 <span class="comment">//</span>
01243 <span class="comment">//  An MCB is an opaque structure but we need to declare the size of</span>
01244 <span class="comment">//  it here so that users can allocate space for one.  Consequently the</span>
01245 <span class="comment">//  size computation here must be updated by hand if the MCB changes.</span>
01246 <span class="comment">//</span>
01247 
<a name="l01248"></a><a class="code" href="../../d2/d7/struct__MCB.html">01248</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d2/d7/struct__MCB.html">_MCB</a> {
<a name="l01249"></a><a class="code" href="../../d2/d7/struct__MCB.html#o0">01249</a>     <a class="code" href="../../d0/d9/struct__LARGE__MCB.html">LARGE_MCB</a> DummyFieldThatSizesThisStructureCorrectly;
01250 } <a class="code" href="../../d2/d7/struct__MCB.html">MCB</a>;
<a name="l01251"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a76">01251</a> <span class="keyword">typedef</span> <a class="code" href="../../d2/d7/struct__MCB.html">MCB</a> *<a class="code" href="../../d2/d7/struct__MCB.html">PMCB</a>;
01252 
01253 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01254 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01255 <a class="code" href="../../d1/d8/fsrtl_8h.html#a151">FsRtlInitializeMcb</a> (
01256     IN <a class="code" href="../../d2/d7/struct__MCB.html">PMCB</a> Mcb,
01257     IN POOL_TYPE PoolType
01258     );
01259 
01260 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01261 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01262 <a class="code" href="../../d1/d8/fsrtl_8h.html#a152">FsRtlUninitializeMcb</a> (
01263     IN <a class="code" href="../../d2/d7/struct__MCB.html">PMCB</a> Mcb
01264     );
01265 
01266 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01267 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01268 <a class="code" href="../../d1/d8/fsrtl_8h.html#a153">FsRtlTruncateMcb</a> (
01269     IN <a class="code" href="../../d2/d7/struct__MCB.html">PMCB</a> Mcb,
01270     IN VBN Vbn
01271     );
01272 
01273 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01274 BOOLEAN
01275 <a class="code" href="../../d1/d8/fsrtl_8h.html#a154">FsRtlAddMcbEntry</a> (
01276     IN <a class="code" href="../../d2/d7/struct__MCB.html">PMCB</a> Mcb,
01277     IN VBN Vbn,
01278     IN LBN Lbn,
01279     IN ULONG SectorCount
01280     );
01281 
01282 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01283 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01284 <a class="code" href="../../d1/d8/fsrtl_8h.html#a155">FsRtlRemoveMcbEntry</a> (
01285     IN <a class="code" href="../../d2/d7/struct__MCB.html">PMCB</a> Mcb,
01286     IN VBN Vbn,
01287     IN ULONG SectorCount
01288     );
01289 
01290 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01291 BOOLEAN
01292 <a class="code" href="../../d1/d8/fsrtl_8h.html#a156">FsRtlLookupMcbEntry</a> (
01293     IN <a class="code" href="../../d2/d7/struct__MCB.html">PMCB</a> Mcb,
01294     IN VBN Vbn,
01295     OUT PLBN Lbn,
01296     OUT PULONG SectorCount OPTIONAL,
01297     OUT PULONG Index
01298     );
01299 
01300 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01301 BOOLEAN
01302 <a class="code" href="../../d1/d8/fsrtl_8h.html#a157">FsRtlLookupLastMcbEntry</a> (
01303     IN <a class="code" href="../../d2/d7/struct__MCB.html">PMCB</a> Mcb,
01304     OUT PVBN Vbn,
01305     OUT PLBN Lbn
01306     );
01307 
01308 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01309 ULONG
01310 <a class="code" href="../../d1/d8/fsrtl_8h.html#a158">FsRtlNumberOfRunsInMcb</a> (
01311     IN <a class="code" href="../../d2/d7/struct__MCB.html">PMCB</a> Mcb
01312     );
01313 
01314 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01315 BOOLEAN
01316 <a class="code" href="../../d1/d8/fsrtl_8h.html#a159">FsRtlGetNextMcbEntry</a> (
01317     IN <a class="code" href="../../d2/d7/struct__MCB.html">PMCB</a> Mcb,
01318     IN ULONG RunIndex,
01319     OUT PVBN Vbn,
01320     OUT PLBN Lbn,
01321     OUT PULONG SectorCount
01322     );
01323 
01324 <span class="comment">//</span>
01325 <span class="comment">//  Fault Tollerance routines, implemented in FaultTol.c</span>
01326 <span class="comment">//</span>
01327 <span class="comment">//  The routines in this package implement rouines that help file</span>
01328 <span class="comment">//  systems interact with the FT device drivers.</span>
01329 <span class="comment">//</span>
01330 
01331 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01332 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01333 <a class="code" href="../../d1/d8/fsrtl_8h.html#a160">FsRtlBalanceReads</a> (
01334     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> TargetDevice
01335     );
01336 
01337 <span class="comment">// end_ntifs</span>
01338 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01339 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01340 <a class="code" href="../../d1/d8/fsrtl_8h.html#a161">FsRtlSyncVolumes</a> (
01341     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> TargetDevice,
01342     IN PLARGE_INTEGER ByteOffset OPTIONAL,
01343     IN PLARGE_INTEGER ByteCount
01344     );
01345 
01346 <span class="comment">// begin_ntifs</span>
01347 
01348 <span class="comment">//</span>
01349 <span class="comment">//  Oplock routines, implemented in Oplock.c</span>
01350 <span class="comment">//</span>
01351 <span class="comment">//  An OPLOCK is an opaque structure, we declare it as a PVOID and</span>
01352 <span class="comment">//  allocate the actual memory only when needed.</span>
01353 <span class="comment">//</span>
01354 
<a name="l01355"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a78">01355</a> <span class="keyword">typedef</span> PVOID <a class="code" href="../../d1/d8/fsrtl_8h.html#a77">OPLOCK</a>, *<a class="code" href="../../d1/d8/fsrtl_8h.html#a78">POPLOCK</a>;
01356 
01357 <span class="keyword">typedef</span>
01358 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01359"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a79">01359</a> (*POPLOCK_WAIT_COMPLETE_ROUTINE) (
01360     IN PVOID Context,
01361     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>
01362     );
01363 
01364 <span class="keyword">typedef</span>
01365 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01366"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a80">01366</a> (*POPLOCK_FS_PREPOST_IRP) (
01367     IN PVOID Context,
01368     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>
01369     );
01370 
01371 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01372 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01373 <a class="code" href="../../d1/d8/fsrtl_8h.html#a162">FsRtlInitializeOplock</a> (
01374     IN OUT POPLOCK Oplock
01375     );
01376 
01377 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01378 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01379 <a class="code" href="../../d1/d8/fsrtl_8h.html#a163">FsRtlUninitializeOplock</a> (
01380     IN OUT POPLOCK Oplock
01381     );
01382 
01383 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01384 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01385 <a class="code" href="../../d1/d8/fsrtl_8h.html#a164">FsRtlOplockFsctrl</a> (
01386     IN POPLOCK Oplock,
01387     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp,
01388     IN ULONG OpenCount
01389     );
01390 
01391 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01392 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01393 <a class="code" href="../../d1/d8/fsrtl_8h.html#a165">FsRtlCheckOplock</a> (
01394     IN POPLOCK Oplock,
01395     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp,
01396     IN PVOID Context,
01397     IN <a class="code" href="../../d1/d8/fsrtl_8h.html#a79">POPLOCK_WAIT_COMPLETE_ROUTINE</a> CompletionRoutine OPTIONAL,
01398     IN <a class="code" href="../../d1/d8/fsrtl_8h.html#a80">POPLOCK_FS_PREPOST_IRP</a> PostIrpRoutine OPTIONAL
01399     );
01400 
01401 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01402 BOOLEAN
01403 <a class="code" href="../../d1/d8/fsrtl_8h.html#a166">FsRtlOplockIsFastIoPossible</a> (
01404     IN POPLOCK Oplock
01405     );
01406 
01407 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01408 BOOLEAN
01409 <a class="code" href="../../d1/d8/fsrtl_8h.html#a167">FsRtlCurrentBatchOplock</a> (
01410     IN POPLOCK Oplock
01411     );
01412 
01413 
01414 <span class="comment">//</span>
01415 <span class="comment">//  Volume lock/unlock notification routines, implemented in PnP.c</span>
01416 <span class="comment">//</span>
01417 <span class="comment">//  These routines provide PnP volume lock notification support</span>
01418 <span class="comment">//  for all filesystems.</span>
01419 <span class="comment">//</span>
01420 
<a name="l01421"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a39">01421</a> <span class="preprocessor">#define FSRTL_VOLUME_DISMOUNT           1</span>
<a name="l01422"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a40">01422</a> <span class="preprocessor"></span><span class="preprocessor">#define FSRTL_VOLUME_DISMOUNT_FAILED    2</span>
<a name="l01423"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a41">01423</a> <span class="preprocessor"></span><span class="preprocessor">#define FSRTL_VOLUME_LOCK               3</span>
<a name="l01424"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a42">01424</a> <span class="preprocessor"></span><span class="preprocessor">#define FSRTL_VOLUME_LOCK_FAILED        4</span>
<a name="l01425"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a43">01425</a> <span class="preprocessor"></span><span class="preprocessor">#define FSRTL_VOLUME_UNLOCK             5</span>
<a name="l01426"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a44">01426</a> <span class="preprocessor"></span><span class="preprocessor">#define FSRTL_VOLUME_MOUNT              6</span>
01427 <span class="preprocessor"></span>
01428 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01429 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01430 <a class="code" href="../../d1/d8/fsrtl_8h.html#a168">FsRtlNotifyVolumeEvent</a> (
01431     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
01432     IN ULONG EventCode
01433     );
01434 
01435 <span class="comment">//</span>
01436 <span class="comment">//  Notify Change routines, implemented in Notify.c</span>
01437 <span class="comment">//</span>
01438 <span class="comment">//  These routines provide Notify Change support for all filesystems.</span>
01439 <span class="comment">//  Any of the 'Full' notify routines will support returning the</span>
01440 <span class="comment">//  change information into the user's buffer.</span>
01441 <span class="comment">//</span>
01442 
<a name="l01443"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a81">01443</a> <span class="keyword">typedef</span> PVOID <a class="code" href="../../d1/d8/fsrtl_8h.html#a81">PNOTIFY_SYNC</a>;
01444 
01445 <span class="keyword">typedef</span>
<a name="l01446"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a82">01446</a> BOOLEAN (*<a class="code" href="../../d1/d8/fsrtl_8h.html#a82">PCHECK_FOR_TRAVERSE_ACCESS</a>) (
01447             IN PVOID NotifyContext,
01448             IN PVOID TargetContext,
01449             IN <a class="code" href="../../d0/d1/struct__SECURITY__SUBJECT__CONTEXT.html">PSECURITY_SUBJECT_CONTEXT</a> SubjectContext
01450             );
01451 
01452 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01453 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01454 <a class="code" href="../../d1/d8/fsrtl_8h.html#a169">FsRtlNotifyInitializeSync</a> (
01455     IN PNOTIFY_SYNC *NotifySync
01456     );
01457 
01458 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01459 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01460 <a class="code" href="../../d1/d8/fsrtl_8h.html#a170">FsRtlNotifyUninitializeSync</a> (
01461     IN PNOTIFY_SYNC *NotifySync
01462     );
01463 
01464 <span class="comment">// end_ntifs</span>
01465 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01466 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01467 <a class="code" href="../../d1/d8/fsrtl_8h.html#a171">FsRtlNotifyChangeDirectory</a> (
01468     IN PNOTIFY_SYNC NotifySync,
01469     IN PVOID FsContext,
01470     IN PSTRING FullDirectoryName,
01471     IN PLIST_ENTRY NotifyList,
01472     IN BOOLEAN WatchTree,
01473     IN ULONG CompletionFilter,
01474     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> NotifyIrp
01475     );
01476 
01477 <span class="comment">// begin_ntifs</span>
01478 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01479 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01480 <a class="code" href="../../d1/d8/fsrtl_8h.html#a172">FsRtlNotifyFullChangeDirectory</a> (
01481     IN PNOTIFY_SYNC NotifySync,
01482     IN PLIST_ENTRY NotifyList,
01483     IN PVOID FsContext,
01484     IN PSTRING FullDirectoryName,
01485     IN BOOLEAN WatchTree,
01486     IN BOOLEAN IgnoreBuffer,
01487     IN ULONG CompletionFilter,
01488     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> NotifyIrp,
01489     IN PCHECK_FOR_TRAVERSE_ACCESS TraverseCallback OPTIONAL,
01490     IN <a class="code" href="../../d0/d1/struct__SECURITY__SUBJECT__CONTEXT.html">PSECURITY_SUBJECT_CONTEXT</a> SubjectContext OPTIONAL
01491     );
01492 
01493 <span class="comment">// end_ntifs</span>
01494 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01495 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01496 <a class="code" href="../../d1/d8/fsrtl_8h.html#a173">FsRtlNotifyReportChange</a> (
01497     IN PNOTIFY_SYNC NotifySync,
01498     IN PLIST_ENTRY NotifyList,
01499     IN PSTRING FullTargetName,
01500     IN PSTRING TargetName,
01501     IN ULONG FilterMatch
01502     );
01503 
01504 <span class="comment">// begin_ntifs</span>
01505 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01506 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01507 <a class="code" href="../../d1/d8/fsrtl_8h.html#a174">FsRtlNotifyFullReportChange</a> (
01508     IN PNOTIFY_SYNC NotifySync,
01509     IN PLIST_ENTRY NotifyList,
01510     IN PSTRING FullTargetName,
01511     IN USHORT TargetNameOffset,
01512     IN PSTRING StreamName OPTIONAL,
01513     IN PSTRING NormalizedParentName OPTIONAL,
01514     IN ULONG FilterMatch,
01515     IN ULONG Action,
01516     IN PVOID TargetContext
01517     );
01518 
01519 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01520 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01521 <a class="code" href="../../d1/d8/fsrtl_8h.html#a175">FsRtlNotifyCleanup</a> (
01522     IN PNOTIFY_SYNC NotifySync,
01523     IN PLIST_ENTRY NotifyList,
01524     IN PVOID FsContext
01525     );
01526 
01527 
01528 <span class="comment">//</span>
01529 <span class="comment">//  Unicode Name support routines, implemented in Name.c</span>
01530 <span class="comment">//</span>
01531 <span class="comment">//  The routines here are used to manipulate unicode names</span>
01532 <span class="comment">//</span>
01533 
01534 <span class="comment">//</span>
01535 <span class="comment">//  The following macro is used to determine if a character is wild.</span>
01536 <span class="comment">//</span>
01537 
<a name="l01538"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a45">01538</a> <span class="preprocessor">#define FsRtlIsUnicodeCharacterWild(C) (                                \</span>
01539 <span class="preprocessor">      (((C) &gt;= 0x40) ? FALSE : FlagOn( LEGAL_ANSI_CHARACTER_ARRAY[(C)], \</span>
01540 <span class="preprocessor">                                       FSRTL_WILD_CHARACTER ) )         \</span>
01541 <span class="preprocessor">)</span>
01542 <span class="preprocessor"></span>
01543 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01544 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01545 <a class="code" href="../../d1/d8/fsrtl_8h.html#a176">FsRtlDissectName</a> (
01546     IN UNICODE_STRING Path,
01547     OUT PUNICODE_STRING FirstName,
01548     OUT PUNICODE_STRING RemainingName
01549     );
01550 
01551 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01552 BOOLEAN
01553 <a class="code" href="../../d1/d8/fsrtl_8h.html#a177">FsRtlDoesNameContainWildCards</a> (
01554     IN PUNICODE_STRING Name
01555     );
01556 
01557 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01558 BOOLEAN
01559 <a class="code" href="../../d1/d8/fsrtl_8h.html#a178">FsRtlAreNamesEqual</a> (
01560     PCUNICODE_STRING ConstantNameA,
01561     PCUNICODE_STRING ConstantNameB,
01562     IN BOOLEAN IgnoreCase,
01563     IN PCWCH UpcaseTable OPTIONAL
01564     );
01565 
01566 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01567 BOOLEAN
01568 <a class="code" href="../../d1/d8/fsrtl_8h.html#a179">FsRtlIsNameInExpression</a> (
01569     IN PUNICODE_STRING Expression,
01570     IN PUNICODE_STRING Name,
01571     IN BOOLEAN IgnoreCase,
01572     IN PWCH UpcaseTable OPTIONAL
01573     );
01574 
01575 
01576 <span class="comment">//</span>
01577 <span class="comment">//  Stack Overflow support routine, implemented in StackOvf.c</span>
01578 <span class="comment">//</span>
01579 
01580 <span class="keyword">typedef</span>
01581 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01582"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a83">01582</a> (*PFSRTL_STACK_OVERFLOW_ROUTINE) (
01583     IN PVOID Context,
01584     IN <a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a> <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>
01585     );
01586 
01587 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01588 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01589 <a class="code" href="../../d1/d8/fsrtl_8h.html#a180">FsRtlPostStackOverflow</a> (
01590     IN PVOID Context,
01591     IN <a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a> Event,
01592     IN <a class="code" href="../../d1/d8/fsrtl_8h.html#a83">PFSRTL_STACK_OVERFLOW_ROUTINE</a> StackOverflowRoutine
01593     );
01594 
01595 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01596 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01597 <a class="code" href="../../d1/d8/fsrtl_8h.html#a181">FsRtlPostPagingFileStackOverflow</a> (
01598     IN PVOID Context,
01599     IN <a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a> Event,
01600     IN PFSRTL_STACK_OVERFLOW_ROUTINE StackOverflowRoutine
01601     );
01602 
01603 <span class="comment">//</span>
01604 <span class="comment">// UNC Provider support</span>
01605 <span class="comment">//</span>
01606 
01607 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01608 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01609 <a class="code" href="../../d1/d8/fsrtl_8h.html#a182">FsRtlRegisterUncProvider</a>(
01610     IN OUT PHANDLE MupHandle,
01611     IN PUNICODE_STRING RedirectorDeviceName,
01612     IN BOOLEAN MailslotsSupported
01613     );
01614 
01615 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01616 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01617 <a class="code" href="../../d1/d8/fsrtl_8h.html#a183">FsRtlDeregisterUncProvider</a>(
01618     IN HANDLE Handle
01619     );
01620 
01621 <span class="comment">//  end_ntifs</span>
01622 
01623 <span class="comment">//</span>
01624 <span class="comment">//  Filter Driver context support</span>
01625 <span class="comment">//</span>
01626 
01627 <span class="comment">//</span>
01628 <span class="comment">//  Filesystem filter drivers use these APIs to associate context</span>
01629 <span class="comment">//  with open streams (for filesystems that support this).</span>
01630 <span class="comment">//</span>
01631 
01632 <span class="comment">//</span>
01633 <span class="comment">//  OwnerId should uniquely identify a particular filter driver</span>
01634 <span class="comment">//  (e.g. the address of the driver's device object).</span>
01635 <span class="comment">//  InstanceId can be used to distinguish distinct contexts associated</span>
01636 <span class="comment">//  by a filter driver with a single stream (e.g. the address of the</span>
01637 <span class="comment">//  fileobject).</span>
01638 <span class="comment">//  FreeCallback is used by a filesystem when tearing down</span>
01639 <span class="comment">//  an FsContext data structure to free associated FilterContexts.</span>
01640 <span class="comment">//  The callback routine cannot recursively call down into the filesystem</span>
01641 <span class="comment">//  or acquire any of their resources which they might hold when calling</span>
01642 <span class="comment">//  the filesystem outside of the callback.</span>
01643 <span class="comment">//</span>
01644 
<a name="l01645"></a><a class="code" href="../../d2/d1/struct__FSRTL__FILTER__CONTEXT.html">01645</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d2/d1/struct__FSRTL__FILTER__CONTEXT.html">_FSRTL_FILTER_CONTEXT</a> {
<a name="l01646"></a><a class="code" href="../../d2/d1/struct__FSRTL__FILTER__CONTEXT.html#o0">01646</a>     LIST_ENTRY Links;
<a name="l01647"></a><a class="code" href="../../d2/d1/struct__FSRTL__FILTER__CONTEXT.html#o1">01647</a>     PVOID OwnerId;
<a name="l01648"></a><a class="code" href="../../d2/d1/struct__FSRTL__FILTER__CONTEXT.html#o2">01648</a>     PVOID InstanceId;
<a name="l01649"></a><a class="code" href="../../d2/d1/struct__FSRTL__FILTER__CONTEXT.html#o3">01649</a>     <a class="code" href="../../d5/d8/ex_8h.html#a101">PFREE_FUNCTION</a> FreeCallback;
01650 } <a class="code" href="../../d2/d1/struct__FSRTL__FILTER__CONTEXT.html">FSRTL_FILTER_CONTEXT</a>, *<a class="code" href="../../d2/d1/struct__FSRTL__FILTER__CONTEXT.html">PFSRTL_FILTER_CONTEXT</a>;
01651 
01652 <span class="comment">//</span>
01653 <span class="comment">//  Associate the context at Ptr with the stream specified by FileObject.</span>
01654 <span class="comment">//  Ptr-&gt;OwnerId and Ptr-&gt;InstanceId should be filled in by the caller.</span>
01655 <span class="comment">//  If the underlying filesystem does not support filter contexts,</span>
01656 <span class="comment">//  STATUS_INVALID_DEVICE_REQUEST will be returned.</span>
01657 <span class="comment">//</span>
01658 
01659 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01660 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01661 <a class="code" href="../../d1/d8/fsrtl_8h.html#a184">FsRtlInsertFilterContext</a> (
01662     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
01663     IN <a class="code" href="../../d2/d1/struct__FSRTL__FILTER__CONTEXT.html">PFSRTL_FILTER_CONTEXT</a> Ptr
01664     );
01665 
01666 <span class="comment">//</span>
01667 <span class="comment">//  Lookup a filter context associated with the stream specified by FileObject.</span>
01668 <span class="comment">//  The first context matching OwnerId (and InstanceId, if present) is returned.</span>
01669 <span class="comment">//  By not specifying InstanceId, a filter driver can search for any context</span>
01670 <span class="comment">//  that it as previously associated with a file.</span>
01671 <span class="comment">//  If no matching context is found, NULL is returned.</span>
01672 <span class="comment">//</span>
01673 
01674 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01675 <a class="code" href="../../d2/d1/struct__FSRTL__FILTER__CONTEXT.html">PFSRTL_FILTER_CONTEXT</a>
01676 <a class="code" href="../../d1/d8/fsrtl_8h.html#a185">FsRtlLookupFilterContextInternal</a> (
01677     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
01678     IN PVOID OwnerId    OPTIONAL,
01679     IN PVOID InstanceId OPTIONAL
01680     );
01681 
<a name="l01682"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a46">01682</a> <span class="preprocessor">#define FsRtlLookupFilterContext(fo, oid, iid)                              \</span>
01683 <span class="preprocessor"> ((     (fo)-&gt;FsContext                                                     \</span>
01684 <span class="preprocessor">     &amp;&amp; ( ((PFSRTL_COMMON_FCB_HEADER)(fo)-&gt;FsContext)-&gt;Flags2  &amp;            \</span>
01685 <span class="preprocessor">                                FSRTL_FLAG2_SUPPORTS_FILTER_CONTEXTS )      \</span>
01686 <span class="preprocessor">     &amp;&amp; !IsListEmpty( (PLIST_ENTRY)                                         \</span>
01687 <span class="preprocessor">          &amp;((PFSRTL_COMMON_FCB_HEADER)(fo)-&gt;FsContext)-&gt;FilterContexts )    \</span>
01688 <span class="preprocessor">  ) ? FsRtlLookupFilterContextInternal(fo, oid, iid)                        \</span>
01689 <span class="preprocessor">    : NULL)</span>
01690 <span class="preprocessor"></span>
01691 <span class="comment">//</span>
01692 <span class="comment">//  Filter drivers must explicitly remove the context they associate with</span>
01693 <span class="comment">//  a stream (otherwise the underlying filesystem will BugCheck at close).</span>
01694 <span class="comment">//  FsRtlRemoveFilterContext functions identically to FsRtlLookupFilterContext,</span>
01695 <span class="comment">//  except that the returned context has been removed from the list.</span>
01696 <span class="comment">//</span>
01697 
01698 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01699 <a class="code" href="../../d2/d1/struct__FSRTL__FILTER__CONTEXT.html">PFSRTL_FILTER_CONTEXT</a>
01700 <a class="code" href="../../d1/d8/fsrtl_8h.html#a186">FsRtlRemoveFilterContext</a> (
01701     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
01702     IN PVOID OwnerId    OPTIONAL,
01703     IN PVOID InstanceId OPTIONAL
01704     );
01705 
01706 <span class="comment">//</span>
01707 <span class="comment">// File systems call this API to free any filter contexts still associated</span>
01708 <span class="comment">// with an FSRTL_COMMON_FCB_HEADER that they are tearing down.</span>
01709 <span class="comment">// The FreeCallback routine for each filter context will be called.</span>
01710 <span class="comment">//</span>
01711 
01712 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01713 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01714 <a class="code" href="../../d1/d8/fsrtl_8h.html#a187">FsRtlTeardownFilterContexts</a> (
01715   IN PLIST_ENTRY FilterContexts
01716   );
01717 
01718 <span class="comment">//  begin_ntifs</span>
01719 
01720 <span class="comment">//++</span>
01721 <span class="comment">//</span>
01722 <span class="comment">//  VOID</span>
01723 <span class="comment">//  FsRtlCompleteRequest (</span>
01724 <span class="comment">//      IN PIRP Irp,</span>
01725 <span class="comment">//      IN NTSTATUS Status</span>
01726 <span class="comment">//      );</span>
01727 <span class="comment">//</span>
01728 <span class="comment">//  Routine Description:</span>
01729 <span class="comment">//</span>
01730 <span class="comment">//      This routine is used to complete an IRP with the indicated</span>
01731 <span class="comment">//      status.  It does the necessary raise and lower of IRQL.</span>
01732 <span class="comment">//</span>
01733 <span class="comment">//  Arguments:</span>
01734 <span class="comment">//</span>
01735 <span class="comment">//      Irp - Supplies a pointer to the Irp to complete</span>
01736 <span class="comment">//</span>
01737 <span class="comment">//      Status - Supplies the completion status for the Irp</span>
01738 <span class="comment">//</span>
01739 <span class="comment">//  Return Value:</span>
01740 <span class="comment">//</span>
01741 <span class="comment">//      None.</span>
01742 <span class="comment">//</span>
01743 <span class="comment">//--</span>
01744 
<a name="l01745"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a47">01745</a> <span class="preprocessor">#define FsRtlCompleteRequest(IRP,STATUS) {         \</span>
01746 <span class="preprocessor">    (IRP)-&gt;IoStatus.Status = (STATUS);             \</span>
01747 <span class="preprocessor">    IoCompleteRequest( (IRP), IO_DISK_INCREMENT ); \</span>
01748 <span class="preprocessor">}</span>
01749 <span class="preprocessor"></span>
01750 
01751 <span class="comment">//++</span>
01752 <span class="comment">//</span>
01753 <span class="comment">//  VOID</span>
01754 <span class="comment">//  FsRtlEnterFileSystem (</span>
01755 <span class="comment">//      );</span>
01756 <span class="comment">//</span>
01757 <span class="comment">//  Routine Description:</span>
01758 <span class="comment">//</span>
01759 <span class="comment">//      This routine is used when entering a file system (e.g., through its</span>
01760 <span class="comment">//      Fsd entry point).  It ensures that the file system cannot be suspended</span>
01761 <span class="comment">//      while running and thus block other file I/O requests.  Upon exit</span>
01762 <span class="comment">//      the file system must call FsRtlExitFileSystem.</span>
01763 <span class="comment">//</span>
01764 <span class="comment">//  Arguments:</span>
01765 <span class="comment">//</span>
01766 <span class="comment">//  Return Value:</span>
01767 <span class="comment">//</span>
01768 <span class="comment">//      None.</span>
01769 <span class="comment">//</span>
01770 <span class="comment">//--</span>
01771 
<a name="l01772"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a48">01772</a> <span class="preprocessor">#define FsRtlEnterFileSystem() { \</span>
01773 <span class="preprocessor">    KeEnterCriticalRegion();     \</span>
01774 <span class="preprocessor">}</span>
01775 <span class="preprocessor"></span>
01776 <span class="comment">//++</span>
01777 <span class="comment">//</span>
01778 <span class="comment">//  VOID</span>
01779 <span class="comment">//  FsRtlExitFileSystem (</span>
01780 <span class="comment">//      );</span>
01781 <span class="comment">//</span>
01782 <span class="comment">//  Routine Description:</span>
01783 <span class="comment">//</span>
01784 <span class="comment">//      This routine is used when exiting a file system (e.g., through its</span>
01785 <span class="comment">//      Fsd entry point).</span>
01786 <span class="comment">//</span>
01787 <span class="comment">//  Arguments:</span>
01788 <span class="comment">//</span>
01789 <span class="comment">//  Return Value:</span>
01790 <span class="comment">//</span>
01791 <span class="comment">//      None.</span>
01792 <span class="comment">//</span>
01793 <span class="comment">//--</span>
01794 
<a name="l01795"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a49">01795</a> <span class="preprocessor">#define FsRtlExitFileSystem() { \</span>
01796 <span class="preprocessor">    KeLeaveCriticalRegion();    \</span>
01797 <span class="preprocessor">}</span>
01798 <span class="preprocessor"></span>
01799 <span class="comment">//  end_ntifs</span>
01800 
01801 <span class="preprocessor">#endif // _FSRTL_</span>
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:40:04 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
