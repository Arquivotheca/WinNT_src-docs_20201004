<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: tunnel.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>tunnel.c</h1><a href="../../d1/d7/tunnel_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1995  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    Tunnel.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    The tunnel package provides a set of routines that allow compatibility</span>
00012 <span class="comment">    with applications that rely on filesystems being able to "hold onto"</span>
00013 <span class="comment">    file meta-info for a short period of time after deletion/renaming and</span>
00014 <span class="comment">    reinstantiating a new directory entry with that meta-info if a</span>
00015 <span class="comment">    create/rename occurs to cause a file of that name to appear again in a</span>
00016 <span class="comment">    short period of time.</span>
00017 <span class="comment"></span>
00018 <span class="comment">    Note that this violates POSIX rules. This package should not be used</span>
00019 <span class="comment">    on POSIX fileobjects, i.e. fileobjects that have case-sensitive names.</span>
00020 <span class="comment"></span>
00021 <span class="comment">    Entries are keyed by directory and one of the short/long names. An opaque</span>
00022 <span class="comment">    rock of information is also associated (create time, last write time, etc.).</span>
00023 <span class="comment">    This is expected to vary on a per-filesystem basis.</span>
00024 <span class="comment"></span>
00025 <span class="comment">    A TUNNEL variable should be initialized for every volume in the system</span>
00026 <span class="comment">    at mount time. Thereafter, each delete/rename-out should add to the tunnel</span>
00027 <span class="comment">    and each create/rename-in should read from the tunnel. Each directory</span>
00028 <span class="comment">    deletion should also notify the package so that all associated entries can</span>
00029 <span class="comment">    be flushed. The package is responsible for cleaning out aged entries.</span>
00030 <span class="comment"></span>
00031 <span class="comment">    Tunneled information is in the paged pool.</span>
00032 <span class="comment"></span>
00033 <span class="comment">    Concurrent access to the TUNNEL variable is controlled by this package.</span>
00034 <span class="comment">    Callers are responsible for synchronizing access to the FsRtlDeleteTunnelCache</span>
00035 <span class="comment">    call.</span>
00036 <span class="comment"></span>
00037 <span class="comment">    The functions provided in this package are as follows:</span>
00038 <span class="comment"></span>
00039 <span class="comment">      o  FsRtlInitializeTunnel - Initializes the TUNNEL package (called once per boot)</span>
00040 <span class="comment"></span>
00041 <span class="comment">      o  FsRtlInitializeTunnelCache - Initializes a TUNNEL structure (called once on mount)</span>
00042 <span class="comment"></span>
00043 <span class="comment">      o  FsRtlAddToTunnelCache - Adds a new key/value pair to the tunnel</span>
00044 <span class="comment"></span>
00045 <span class="comment">      o  FsRtlFindInTunnelCache - Finds and returns a key/value from the tunnel</span>
00046 <span class="comment"></span>
00047 <span class="comment">      o  FsRtlDeleteKeyFromTunnelCache - Deletes all entries with a given</span>
00048 <span class="comment">           directory key from the tunnel</span>
00049 <span class="comment"></span>
00050 <span class="comment">      o  FsRtlDeleteTunnelCache - Deletes a TUNNEL structure</span>
00051 <span class="comment"></span>
00052 <span class="comment">Author:</span>
00053 <span class="comment"></span>
00054 <span class="comment">    Dan Lovinger     [DanLo]    8-Aug-1995</span>
00055 <span class="comment"></span>
00056 <span class="comment">Revision History:</span>
00057 <span class="comment"></span>
00058 <span class="comment">--*/</span>
00059 
00060 <span class="preprocessor">#include "FsRtlP.h"</span>
00061 
00062 <span class="preprocessor">#ifndef INLINE</span>
<a name="l00063"></a><a class="code" href="../../d1/d7/tunnel_8c.html#a0">00063</a> <span class="preprocessor"></span><span class="preprocessor">#define INLINE __inline</span>
00064 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00065 <span class="preprocessor"></span>
00066 <span class="comment">//</span>
00067 <span class="comment">//  Registry keys/values for controlling tunneling</span>
00068 <span class="comment">//</span>
00069 
<a name="l00070"></a><a class="code" href="../../d1/d7/tunnel_8c.html#a1">00070</a> <span class="preprocessor">#define TUNNEL_KEY_NAME           L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\FileSystem"</span>
<a name="l00071"></a><a class="code" href="../../d1/d7/tunnel_8c.html#a2">00071</a> <span class="preprocessor"></span><span class="preprocessor">#define TUNNEL_AGE_VALUE_NAME     L"MaximumTunnelEntryAgeInSeconds"</span>
<a name="l00072"></a><a class="code" href="../../d1/d7/tunnel_8c.html#a3">00072</a> <span class="preprocessor"></span><span class="preprocessor">#define TUNNEL_SIZE_VALUE_NAME    L"MaximumTunnelEntries"</span>
<a name="l00073"></a><a class="code" href="../../d1/d7/tunnel_8c.html#a4">00073</a> <span class="preprocessor"></span><span class="preprocessor">#define KEY_WORK_AREA ((sizeof(KEY_VALUE_FULL_INFORMATION) + sizeof(ULONG)) + 64)</span>
00074 <span class="preprocessor"></span>
00075 <span class="comment">//</span>
00076 <span class="comment">//  Tunnel expiration paramters (cached once at startup)</span>
00077 <span class="comment">//</span>
00078 
<a name="l00079"></a><a class="code" href="../../d1/d7/tunnel_8c.html#a9">00079</a> ULONG   <a class="code" href="../../d1/d7/tunnel_8c.html#a9">TunnelMaxEntries</a>;
<a name="l00080"></a><a class="code" href="../../d1/d7/tunnel_8c.html#a10">00080</a> ULONG   <a class="code" href="../../d1/d7/tunnel_8c.html#a10">TunnelMaxAge</a>;
00081 
00082 <span class="comment">//</span>
00083 <span class="comment">//  We use a lookaside list to manage the common size tunnel entry. The common size</span>
00084 <span class="comment">//  is contrived to be 128 bytes by adjusting the size we defer for the long name</span>
00085 <span class="comment">//  to 16 characters, which is pretty reasonable. If we ever expect to get more than</span>
00086 <span class="comment">//  a ULONGLONG data element or common names are observed to become larger, adjusting</span>
00087 <span class="comment">//  this may be required.</span>
00088 <span class="comment">//</span>
00089 
<a name="l00090"></a><a class="code" href="../../d1/d7/tunnel_8c.html#a11">00090</a> <a class="code" href="../../d1/d8/struct__PAGED__LOOKASIDE__LIST.html">PAGED_LOOKASIDE_LIST</a>    <a class="code" href="../../d1/d7/tunnel_8c.html#a11">TunnelLookasideList</a>;
<a name="l00091"></a><a class="code" href="../../d1/d7/tunnel_8c.html#a5">00091</a> <span class="preprocessor">#define MAX_LOOKASIDE_DEPTH     256</span>
00092 <span class="preprocessor"></span>
<a name="l00093"></a><a class="code" href="../../d1/d7/tunnel_8c.html#a6">00093</a> <span class="preprocessor">#define LOOKASIDE_NODE_SIZE     ( sizeof(TUNNEL_NODE) +     \</span>
00094 <span class="preprocessor">                                  sizeof(WCHAR)*(8+1+3) +   \</span>
00095 <span class="preprocessor">                                  sizeof(WCHAR)*(16) +      \</span>
00096 <span class="preprocessor">                                  sizeof(ULONGLONG) )</span>
00097 <span class="preprocessor"></span>
00098 <span class="comment">//</span>
00099 <span class="comment">//  Flag bits in the TUNNEL_NODE</span>
00100 <span class="comment">//</span>
00101 
<a name="l00102"></a><a class="code" href="../../d1/d7/tunnel_8c.html#a7">00102</a> <span class="preprocessor">#define TUNNEL_FLAG_NON_LOOKASIDE    0x1</span>
<a name="l00103"></a><a class="code" href="../../d1/d7/tunnel_8c.html#a8">00103</a> <span class="preprocessor"></span><span class="preprocessor">#define TUNNEL_FLAG_KEY_SHORT        0x2</span>
00104 <span class="preprocessor"></span>
00105 <span class="comment">//</span>
00106 <span class="comment">//  A node of tunneled information in the cache</span>
00107 <span class="comment">//</span>
00108 <span class="comment">//  A TUNNEL is allocated in each VCB and initialized at mount time.</span>
00109 <span class="comment">//</span>
00110 <span class="comment">//  TUNNEL_NODES are then arranged off of the TUNNEL in a splay tree keyed</span>
00111 <span class="comment">//  by DirKey ## Name, where Name is whichever of the names was removed from</span>
00112 <span class="comment">//  the directory (short or long). Each node is also timestamped and inserted</span>
00113 <span class="comment">//  into a timer queue for age expiration.</span>
00114 <span class="comment">//</span>
00115 
<a name="l00116"></a><a class="code" href="../../d5/d1/structTUNNEL__NODE.html">00116</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
00117 
00118     <span class="comment">//</span>
00119     <span class="comment">//  Splay links in the Cache tree</span>
00120     <span class="comment">//</span>
00121 
<a name="l00122"></a><a class="code" href="../../d5/d1/structTUNNEL__NODE.html#o0">00122</a>     RTL_SPLAY_LINKS      CacheLinks;
00123 
00124     <span class="comment">//</span>
00125     <span class="comment">//  List links in the timer queue</span>
00126     <span class="comment">//</span>
00127 
<a name="l00128"></a><a class="code" href="../../d5/d1/structTUNNEL__NODE.html#o1">00128</a>     LIST_ENTRY           ListLinks;
00129 
00130     <span class="comment">//</span>
00131     <span class="comment">//  Time this entry was created (for constant time insert)</span>
00132     <span class="comment">//</span>
00133 
<a name="l00134"></a><a class="code" href="../../d5/d1/structTUNNEL__NODE.html#o2">00134</a>     LARGE_INTEGER        CreateTime;
00135 
00136     <span class="comment">//</span>
00137     <span class="comment">//  Directory these names are associated with</span>
00138     <span class="comment">//</span>
00139 
<a name="l00140"></a><a class="code" href="../../d5/d1/structTUNNEL__NODE.html#o3">00140</a>     ULONGLONG            DirKey;
00141 
00142     <span class="comment">//</span>
00143     <span class="comment">//  Flags for the entry</span>
00144     <span class="comment">//</span>
00145 
<a name="l00146"></a><a class="code" href="../../d5/d1/structTUNNEL__NODE.html#o4">00146</a>     ULONG                Flags;
00147 
00148     <span class="comment">//</span>
00149     <span class="comment">//  Long/Short names of the file</span>
00150     <span class="comment">//</span>
00151 
<a name="l00152"></a><a class="code" href="../../d5/d1/structTUNNEL__NODE.html#o5">00152</a>     UNICODE_STRING       LongName;
<a name="l00153"></a><a class="code" href="../../d5/d1/structTUNNEL__NODE.html#o6">00153</a>     UNICODE_STRING       ShortName;
00154 
00155     <span class="comment">//</span>
00156     <span class="comment">//  Opaque tunneled data</span>
00157     <span class="comment">//</span>
00158 
<a name="l00159"></a><a class="code" href="../../d5/d1/structTUNNEL__NODE.html#o7">00159</a>     PVOID                TunnelData;
<a name="l00160"></a><a class="code" href="../../d5/d1/structTUNNEL__NODE.html#o8">00160</a>     ULONG                TunnelDataLength;
00161 
00162 } <a class="code" href="../../d5/d1/structTUNNEL__NODE.html">TUNNEL_NODE</a>, *<a class="code" href="../../d1/d7/tunnel_8c.html#a12">PTUNNEL_NODE</a>;
00163 
00164 <span class="comment">//</span>
00165 <span class="comment">//  Internal utility functions</span>
00166 <span class="comment">//</span>
00167 
00168 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00169 <a class="code" href="../../d1/d7/tunnel_8c.html#a13">FsRtlGetTunnelParameterValue</a> (
00170     IN PUNICODE_STRING ValueName,
00171     IN OUT PULONG Value);
00172 
00173 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00174 <a class="code" href="../../d1/d7/tunnel_8c.html#a14">FsRtlPruneTunnelCache</a> (
00175     IN <a class="code" href="../../d1/d8/fsrtl_8h.html#a69">PTUNNEL</a> Cache,
00176     IN OUT PLIST_ENTRY FreePoolList);
00177 
00178 <span class="preprocessor">#ifdef ALLOC_PRAGMA</span>
00179 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, FsRtlInitializeTunnels)</span>
00180 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, FsRtlInitializeTunnelCache)</span>
00181 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, FsRtlAddToTunnelCache)</span>
00182 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, FsRtlFindInTunnelCache)</span>
00183 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, FsRtlDeleteKeyFromTunnelCache)</span>
00184 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, FsRtlDeleteTunnelCache)</span>
00185 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, FsRtlPruneTunnelCache)</span>
00186 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, FsRtlGetTunnelParameterValue)</span>
00187 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00188 <span class="preprocessor"></span>
00189 <span class="comment">//</span>
00190 <span class="comment">//  Testing and usermode rig support. Define TUNNELTEST to get verbose debugger</span>
00191 <span class="comment">//  output on various operations. Define USERTEST to transform the code into</span>
00192 <span class="comment">//  a form which can be compiled in usermode for more efficient debugging.</span>
00193 <span class="comment">//</span>
00194 
00195 <span class="preprocessor">#if defined(TUNNELTEST) || defined(KEYVIEW)</span>
00196 <span class="preprocessor"></span><a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a> DumpUnicodeString(UNICODE_STRING *s);
00197 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a> DumpNode( <a class="code" href="../../d5/d1/structTUNNEL__NODE.html">TUNNEL_NODE</a> *Node, ULONG Indent );
00198 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a> DumpTunnel( <a class="code" href="../../d4/d1/structTUNNEL.html">TUNNEL</a> *Tunnel );
00199 <span class="preprocessor">#define DblHex64(a) (ULONG)((a &gt;&gt; 32) &amp; 0xffffffff),(ULONG)(a &amp; 0xffffffff)</span>
00200 <span class="preprocessor"></span><span class="preprocessor">#endif // TUNNELTEST</span>
00201 <span class="preprocessor"></span>
00202 <span class="preprocessor">#ifdef USERTEST</span>
00203 <span class="preprocessor"></span><span class="preprocessor">#include &lt;stdio.h&gt;</span>
00204 <span class="preprocessor">#undef KeQuerySystemTime</span>
00205 <span class="preprocessor"></span><span class="preprocessor">#define KeQuerySystemTime NtQuerySystemTime</span>
00206 <span class="preprocessor"></span><span class="preprocessor">#undef ExInitializeFastMutex</span>
00207 <span class="preprocessor"></span><span class="preprocessor">#define ExInitializeFastMutex(arg)</span>
00208 <span class="preprocessor"></span><span class="preprocessor">#define ExAcquireFastMutex(arg)</span>
00209 <span class="preprocessor"></span><span class="preprocessor">#define ExReleaseFastMutex(arg)</span>
00210 <span class="preprocessor"></span><span class="preprocessor">#define DbgPrint printf</span>
00211 <span class="preprocessor"></span><span class="preprocessor">#undef PAGED_CODE</span>
00212 <span class="preprocessor"></span><span class="preprocessor">#define PAGED_CODE()</span>
00213 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00214 <span class="preprocessor"></span>
00215 
00216 <a class="code" href="../../d5/d3/filelock_8c.html#a1">INLINE</a>
00217 LONG
<a name="l00218"></a><a class="code" href="../../d1/d7/tunnel_8c.html#a15">00218</a> <a class="code" href="../../d1/d7/tunnel_8c.html#a15">FsRtlCompareNodeAndKey</a> (
00219     <a class="code" href="../../d5/d1/structTUNNEL__NODE.html">TUNNEL_NODE</a> *Node,
00220     ULONGLONG DirectoryKey,
00221     PUNICODE_STRING Name
00222     )
00223 <span class="comment">/*++</span>
00224 <span class="comment"></span>
00225 <span class="comment">Routine Description:</span>
00226 <span class="comment"></span>
00227 <span class="comment">    Compare a tunnel node with a key/name pair</span>
00228 <span class="comment"></span>
00229 <span class="comment">Arguments:</span>
00230 <span class="comment"></span>
00231 <span class="comment">    Node              - a tunnel node</span>
00232 <span class="comment"></span>
00233 <span class="comment">    DirectoryKey      - a key value</span>
00234 <span class="comment"></span>
00235 <span class="comment">    Name              - a filename</span>
00236 <span class="comment"></span>
00237 <span class="comment">Return Value:</span>
00238 <span class="comment"></span>
00239 <span class="comment">    Signed comparison result</span>
00240 <span class="comment"></span>
00241 <span class="comment">--*/</span>
00242 
00243 {
00244     <span class="keywordflow">return</span>  (Node-&gt;<a class="code" href="../../d5/d1/structTUNNEL__NODE.html#o3">DirKey</a> &gt; DirectoryKey ?  1 :
00245             (Node-&gt;<a class="code" href="../../d5/d1/structTUNNEL__NODE.html#o3">DirKey</a> &lt; DirectoryKey ? -1 :
00246             <a class="code" href="../../d6/d6/nls_8c.html#a41">RtlCompareUnicodeString</a>((<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(Node-&gt;<a class="code" href="../../d5/d1/structTUNNEL__NODE.html#o4">Flags</a>, <a class="code" href="../../d1/d7/tunnel_8c.html#a8">TUNNEL_FLAG_KEY_SHORT</a>) ?
00247                                         &amp;Node-&gt;<a class="code" href="../../d5/d1/structTUNNEL__NODE.html#o6">ShortName</a> : &amp;Node-&gt;<a class="code" href="../../d5/d1/structTUNNEL__NODE.html#o5">LongName</a>),
00248                                     <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>,
00249                                     <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>)));
00250 }
00251 
00252 
00253 <a class="code" href="../../d5/d3/filelock_8c.html#a1">INLINE</a>
00254 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00255"></a><a class="code" href="../../d1/d7/tunnel_8c.html#a16">00255</a> <a class="code" href="../../d1/d7/tunnel_8c.html#a16">FsRtlFreeTunnelNode</a> (
00256     PTUNNEL_NODE Node,
00257     PLIST_ENTRY FreePoolList OPTIONAL
00258     )
00259 <span class="comment">/*++</span>
00260 <span class="comment"></span>
00261 <span class="comment">Routine Description:</span>
00262 <span class="comment"></span>
00263 <span class="comment">    Free a node</span>
00264 <span class="comment"></span>
00265 <span class="comment">Arguments:</span>
00266 <span class="comment"></span>
00267 <span class="comment">    Node            - a tunnel node to free</span>
00268 <span class="comment"></span>
00269 <span class="comment">    FreePoolList    - optional list to hold freeable pool memory</span>
00270 <span class="comment"></span>
00271 <span class="comment">Return Value:</span>
00272 <span class="comment"></span>
00273 <span class="comment">    None</span>
00274 <span class="comment"></span>
00275 <span class="comment">-*/</span>
00276 {
00277     <span class="keywordflow">if</span> (FreePoolList) {
00278 
00279         InsertHeadList(FreePoolList, &amp;Node-&gt;ListLinks);
00280 
00281     } <span class="keywordflow">else</span> {
00282 
00283         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(Node-&gt;Flags, <a class="code" href="../../d1/d7/tunnel_8c.html#a7">TUNNEL_FLAG_NON_LOOKASIDE</a>)) {
00284     
00285             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(Node);
00286     
00287         } <span class="keywordflow">else</span> {
00288     
00289             <a class="code" href="../../d5/d8/ex_8h.html#a253">ExFreeToPagedLookasideList</a>(&amp;<a class="code" href="../../d1/d7/tunnel_8c.html#a11">TunnelLookasideList</a>, Node);
00290         }
00291     }
00292 }
00293 
00294 
00295 <a class="code" href="../../d5/d3/filelock_8c.html#a1">INLINE</a>
00296 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00297"></a><a class="code" href="../../d1/d7/tunnel_8c.html#a17">00297</a> <a class="code" href="../../d1/d7/tunnel_8c.html#a17">FsRtlEmptyFreePoolList</a> (
00298     PLIST_ENTRY FreePoolList
00299     )
00300 <span class="comment">/*++</span>
00301 <span class="comment"></span>
00302 <span class="comment">Routine Description:</span>
00303 <span class="comment"></span>
00304 <span class="comment">    Free all pool memory that has been delayed onto a free list.</span>
00305 <span class="comment"></span>
00306 <span class="comment">Arguments:</span>
00307 <span class="comment"></span>
00308 <span class="comment">    FreePoolList    - a list of freeable pool memory</span>
00309 <span class="comment"></span>
00310 <span class="comment">Return Value:</span>
00311 <span class="comment"></span>
00312 <span class="comment">    None</span>
00313 <span class="comment"></span>
00314 <span class="comment">-*/</span>
00315 {
00316     <a class="code" href="../../d1/d7/tunnel_8c.html#a12">PTUNNEL_NODE</a> FreeNode;
00317 
00318     <span class="keywordflow">while</span> (!IsListEmpty(FreePoolList)) {
00319 
00320         FreeNode = CONTAINING_RECORD(FreePoolList-&gt;Flink, <a class="code" href="../../d5/d1/structTUNNEL__NODE.html">TUNNEL_NODE</a>, ListLinks);
00321         RemoveEntryList(FreePoolList-&gt;Flink);
00322 
00323         <a class="code" href="../../d1/d7/tunnel_8c.html#a16">FsRtlFreeTunnelNode</a>(FreeNode, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00324     }
00325 }
00326 
00327 
00328 <a class="code" href="../../d5/d3/filelock_8c.html#a1">INLINE</a>
00329 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00330"></a><a class="code" href="../../d1/d7/tunnel_8c.html#a18">00330</a> <a class="code" href="../../d1/d7/tunnel_8c.html#a18">FsRtlRemoveNodeFromTunnel</a> (
00331     IN PTUNNEL Cache,
00332     IN PTUNNEL_NODE Node,
00333     IN PLIST_ENTRY FreePoolList,
00334     IN PBOOLEAN Splay OPTIONAL
00335     )
00336 <span class="comment">/*++</span>
00337 <span class="comment"></span>
00338 <span class="comment">Routine Description:</span>
00339 <span class="comment"></span>
00340 <span class="comment">    Performs the common work of deleting a node from a tunnel cache. Pool memory</span>
00341 <span class="comment">    is not deleted immediately but is saved aside on a list for deletion later</span>
00342 <span class="comment">    by the calling routine.</span>
00343 <span class="comment"></span>
00344 <span class="comment">Arguments:</span>
00345 <span class="comment"></span>
00346 <span class="comment">    Cache - the tunnel cache the node is in</span>
00347 <span class="comment"></span>
00348 <span class="comment">    Node - the node being removed</span>
00349 <span class="comment"></span>
00350 <span class="comment">    FreePoolList - an initialized list to take the node if it was allocated from</span>
00351 <span class="comment">        pool</span>
00352 <span class="comment"></span>
00353 <span class="comment">    Splay - an optional flag to indicate whether the tree should be splayed on</span>
00354 <span class="comment">        the delete. Set to FALSE if splaying was performed.</span>
00355 <span class="comment"></span>
00356 <span class="comment">Return Value:</span>
00357 <span class="comment"></span>
00358 <span class="comment">    None.</span>
00359 <span class="comment"></span>
00360 <span class="comment">--*/</span>
00361 {
00362     <span class="keywordflow">if</span> (Splay &amp;&amp; *Splay) {
00363 
00364         Cache-&gt;Cache = <a class="code" href="../../d3/d4/splay_8c.html#a4">RtlDelete</a>(&amp;Node-&gt;CacheLinks);
00365 
00366         *Splay = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00367 
00368     } <span class="keywordflow">else</span> {
00369 
00370         <a class="code" href="../../d3/d4/splay_8c.html#a5">RtlDeleteNoSplay</a>(&amp;Node-&gt;CacheLinks, &amp;Cache-&gt;Cache);
00371     }
00372 
00373     RemoveEntryList(&amp;Node-&gt;ListLinks);
00374 
00375     Cache-&gt;NumEntries--;
00376 
00377     <a class="code" href="../../d1/d7/tunnel_8c.html#a16">FsRtlFreeTunnelNode</a>(Node, FreePoolList);
00378 }
00379 
00380 
00381 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00382"></a><a class="code" href="../../d1/d7/tunnel_8c.html#a19">00382</a> <a class="code" href="../../d1/d7/tunnel_8c.html#a19">FsRtlInitializeTunnels</a> (
00383     VOID
00384     )
00385 <span class="comment">/*++</span>
00386 <span class="comment"></span>
00387 <span class="comment">Routine Description:</span>
00388 <span class="comment"></span>
00389 <span class="comment">    Initializes the global part of the tunneling package.</span>
00390 <span class="comment"></span>
00391 <span class="comment">Arguments:</span>
00392 <span class="comment"></span>
00393 <span class="comment">    None</span>
00394 <span class="comment"></span>
00395 <span class="comment">Return Value:</span>
00396 <span class="comment"></span>
00397 <span class="comment">    None</span>
00398 <span class="comment"></span>
00399 <span class="comment">--*/</span>
00400 {
00401     UNICODE_STRING  <a class="code" href="../../d1/d1/rtdelval_8c.html#a3">ValueName</a>;
00402     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>          LookasideDepth;
00403 
00404     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00405 
00406     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d1/mminit_8c.html#a58">MmIsThisAnNtAsSystem</a>()) {
00407 
00408         <a class="code" href="../../d1/d7/tunnel_8c.html#a9">TunnelMaxEntries</a> = 1024;
00409 
00410     } <span class="keywordflow">else</span> {
00411 
00412         <a class="code" href="../../d1/d7/tunnel_8c.html#a9">TunnelMaxEntries</a> = 256;
00413     }
00414 
00415     <a class="code" href="../../d1/d7/tunnel_8c.html#a10">TunnelMaxAge</a> = 15;
00416 
00417     <span class="comment">//</span>
00418     <span class="comment">//  Query our configurable parameters</span>
00419     <span class="comment">//</span>
00420     <span class="comment">//  Don't worry about failure in retrieving from the registry. We've gotten</span>
00421     <span class="comment">//  this far so fall back on defaults even if there was a problem with resources.</span>
00422     <span class="comment">//</span>
00423 
00424     <a class="code" href="../../d1/d1/rtdelval_8c.html#a3">ValueName</a>.Buffer = <a class="code" href="../../d1/d7/tunnel_8c.html#a3">TUNNEL_SIZE_VALUE_NAME</a>;
00425     <a class="code" href="../../d1/d1/rtdelval_8c.html#a3">ValueName</a>.Length = <span class="keyword">sizeof</span>(<a class="code" href="../../d1/d7/tunnel_8c.html#a3">TUNNEL_SIZE_VALUE_NAME</a>) - <span class="keyword">sizeof</span>(WCHAR);
00426     <a class="code" href="../../d1/d1/rtdelval_8c.html#a3">ValueName</a>.MaximumLength = <span class="keyword">sizeof</span>(<a class="code" href="../../d1/d7/tunnel_8c.html#a3">TUNNEL_SIZE_VALUE_NAME</a>);
00427     (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d1/d7/tunnel_8c.html#a13">FsRtlGetTunnelParameterValue</a>(&amp;<a class="code" href="../../d1/d1/rtdelval_8c.html#a3">ValueName</a>, &amp;<a class="code" href="../../d1/d7/tunnel_8c.html#a9">TunnelMaxEntries</a>);
00428 
00429     <a class="code" href="../../d1/d1/rtdelval_8c.html#a3">ValueName</a>.Buffer = <a class="code" href="../../d1/d7/tunnel_8c.html#a2">TUNNEL_AGE_VALUE_NAME</a>;
00430     <a class="code" href="../../d1/d1/rtdelval_8c.html#a3">ValueName</a>.Length = <span class="keyword">sizeof</span>(<a class="code" href="../../d1/d7/tunnel_8c.html#a2">TUNNEL_AGE_VALUE_NAME</a>) - <span class="keyword">sizeof</span>(WCHAR);
00431     <a class="code" href="../../d1/d1/rtdelval_8c.html#a3">ValueName</a>.MaximumLength = <span class="keyword">sizeof</span>(<a class="code" href="../../d1/d7/tunnel_8c.html#a2">TUNNEL_AGE_VALUE_NAME</a>);
00432     (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d1/d7/tunnel_8c.html#a13">FsRtlGetTunnelParameterValue</a>(&amp;<a class="code" href="../../d1/d1/rtdelval_8c.html#a3">ValueName</a>, &amp;<a class="code" href="../../d1/d7/tunnel_8c.html#a10">TunnelMaxAge</a>);
00433 
00434     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d7/tunnel_8c.html#a10">TunnelMaxAge</a> == 0) {
00435 
00436         <span class="comment">//</span>
00437         <span class="comment">//  If the registry has been set so the timeout is zero, we should force</span>
00438         <span class="comment">//  the number of entries to zero also. This preserves expectations and lets</span>
00439         <span class="comment">//  us key off of max entries alone in performing the hard disabling of the</span>
00440         <span class="comment">//  caching code.</span>
00441         <span class="comment">//</span>
00442 
00443         <a class="code" href="../../d1/d7/tunnel_8c.html#a9">TunnelMaxEntries</a> = 0;
00444     }
00445 
00446     <span class="comment">//</span>
00447     <span class="comment">//  Convert from seconds to 10ths of msecs, the internal resolution</span>
00448     <span class="comment">//</span>
00449 
00450     <a class="code" href="../../d1/d7/tunnel_8c.html#a10">TunnelMaxAge</a> *= 10000000;
00451 
00452     <span class="comment">//</span>
00453     <span class="comment">//  Build the lookaside list for common node allocation</span>
00454     <span class="comment">//</span>
00455 
00456     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d7/tunnel_8c.html#a9">TunnelMaxEntries</a> &gt; MAXUSHORT) {
00457 
00458         <span class="comment">//</span>
00459         <span class="comment">//  User is hinting a big need to us</span>
00460         <span class="comment">//</span>
00461 
00462         LookasideDepth = <a class="code" href="../../d1/d7/tunnel_8c.html#a5">MAX_LOOKASIDE_DEPTH</a>;
00463 
00464     } <span class="keywordflow">else</span> {
00465 
00466         LookasideDepth = ((<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)<a class="code" href="../../d1/d7/tunnel_8c.html#a9">TunnelMaxEntries</a>)/16;
00467     }
00468 
00469     <span class="keywordflow">if</span> (LookasideDepth == 0 &amp;&amp; <a class="code" href="../../d1/d7/tunnel_8c.html#a9">TunnelMaxEntries</a>) {
00470 
00471         <span class="comment">//</span>
00472         <span class="comment">//  Miniscule number of entries allowed. Lookaside 'em all.</span>
00473         <span class="comment">//</span>
00474 
00475         LookasideDepth = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)<a class="code" href="../../d1/d7/tunnel_8c.html#a9">TunnelMaxEntries</a> + 1;
00476     }
00477 
00478     <span class="keywordflow">if</span> (LookasideDepth &gt; <a class="code" href="../../d1/d7/tunnel_8c.html#a5">MAX_LOOKASIDE_DEPTH</a>) {
00479 
00480         <span class="comment">//</span>
00481         <span class="comment">//  Finally, restrict the depth to something reasonable.</span>
00482         <span class="comment">//</span>
00483 
00484         LookasideDepth = <a class="code" href="../../d1/d7/tunnel_8c.html#a5">MAX_LOOKASIDE_DEPTH</a>;
00485     }
00486 
00487     <a class="code" href="../../d5/d8/ex_8h.html#a250">ExInitializePagedLookasideList</a>( &amp;<a class="code" href="../../d1/d7/tunnel_8c.html#a11">TunnelLookasideList</a>,
00488                                     <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00489                                     <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00490                                     0,
00491                                     <a class="code" href="../../d1/d7/tunnel_8c.html#a6">LOOKASIDE_NODE_SIZE</a>,
00492                                     'LnuT',
00493                                     LookasideDepth );
00494 
00495     <span class="keywordflow">return</span>;
00496 }
00497 
00498 
00499 <span class="comment">//</span>
00500 <span class="comment">//  *** SPEC</span>
00501 <span class="comment">//</span>
00502 <span class="comment">//    FsRtlInitializeTunnelCache - Initialize a tunneling cache for a volume</span>
00503 <span class="comment">//</span>
00504 <span class="comment">//    FsRtlInitializeTunnelCache will allocate a default cache (resizing policy is common</span>
00505 <span class="comment">//    to all file systems) and initialize it to be empty.  File systems will store a pointer to</span>
00506 <span class="comment">//    this cache in their per-volume structures.</span>
00507 <span class="comment">//</span>
00508 <span class="comment">//    Information is retained in the tunnel cache for a fixed period of time.  MarkZ would</span>
00509 <span class="comment">//    assume that a value of 10 seconds would satisfy the vast majority of situations.  This</span>
00510 <span class="comment">//    could be controlled by the registry or could be a compilation constant.</span>
00511 <span class="comment">//</span>
00512 <span class="comment">//  Change: W95 times out at 15 seconds. Would be a registry value initialized at tunnel</span>
00513 <span class="comment">//  creation time, with a proposed default of 15 seconds.</span>
00514 <span class="comment">//</span>
00515 
00516 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00517"></a><a class="code" href="../../d1/d7/tunnel_8c.html#a20">00517</a> <a class="code" href="../../d1/d8/fsrtl_8h.html#a126">FsRtlInitializeTunnelCache</a> (
00518     IN PTUNNEL Cache
00519     )
00520 <span class="comment">/*++</span>
00521 <span class="comment"></span>
00522 <span class="comment">Routine Description:</span>
00523 <span class="comment"></span>
00524 <span class="comment">    Initialize a new tunnel cache.</span>
00525 <span class="comment"></span>
00526 <span class="comment">Arguments:</span>
00527 <span class="comment"></span>
00528 <span class="comment">    None</span>
00529 <span class="comment"></span>
00530 <span class="comment">Return Value:</span>
00531 <span class="comment"></span>
00532 <span class="comment">    None</span>
00533 <span class="comment"></span>
00534 <span class="comment">--*/</span>
00535 {
00536     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00537 
00538     <a class="code" href="../../d5/d8/ex_8h.html#a8">ExInitializeFastMutex</a>(&amp;Cache-&gt;Mutex);
00539 
00540     Cache-&gt;Cache = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00541     InitializeListHead(&amp;Cache-&gt;TimerQueue);
00542     Cache-&gt;NumEntries = 0;
00543 
00544     <span class="keywordflow">return</span>;
00545 }
00546 
00547 
00548 <span class="comment">//</span>
00549 <span class="comment">//  *** SPEC</span>
00550 <span class="comment">//</span>
00551 <span class="comment">//    FsRtlAddToTunnelCache - add information to a tunnel cache</span>
00552 <span class="comment">//</span>
00553 <span class="comment">//    FsRtlAddToTunnelCache is called by file systems when a name disappears from a</span>
00554 <span class="comment">//    directory.  This typically occurs in both the delete and the rename paths.  When</span>
00555 <span class="comment">//    a name is deleted, all information needed to be cached is extracted from the file</span>
00556 <span class="comment">//    and passed in a single buffer.  This information is stored keyed by the directory key</span>
00557 <span class="comment">//    (a ULONG that is unique to the directory) and the short-name of the file.</span>
00558 <span class="comment">//</span>
00559 <span class="comment">//    The caller is required to synchronize this call against FsRtlDeleteTunnelCache.</span>
00560 <span class="comment">//</span>
00561 <span class="comment">//    Arguments:</span>
00562 <span class="comment">//        Cache        pointer to cache initialized by FsRtlInitializeTunnelCache</span>
00563 <span class="comment">//        DirectoryKey    ULONG unique ID of the directory containing the deleted file</span>
00564 <span class="comment">//        ShortName    UNICODE_STRING* short (8.3) name of the file</span>
00565 <span class="comment">//        LongName    UNICODE_STRING* full name of the file</span>
00566 <span class="comment">//        DataLength    ULONG length of data to be cached with these names</span>
00567 <span class="comment">//        Data        VOID* data that will be cached.</span>
00568 <span class="comment">//</span>
00569 <span class="comment">//    It is acceptable for the Cache to ignore this request based upon memory constraints.</span>
00570 <span class="comment">//</span>
00571 <span class="comment">//  Change: W95 maintains 10 items in the tunnel cache. Since we are a potential server</span>
00572 <span class="comment">//  this should be much higher. The max count would be initialized from the registry with</span>
00573 <span class="comment">//  a proposed default of 1024. Adds which run into the limit would cause least recently</span>
00574 <span class="comment">//  inserted recycling (i.e., off of the top of the timer queue).</span>
00575 <span class="comment">//</span>
00576 <span class="comment">//  Change: Key should be by the name removed, not neccesarily the short name. If a long name</span>
00577 <span class="comment">//  is removed, it would be incorrect to miss the tunnel. Use KeyByShortName boolean to specify</span>
00578 <span class="comment">//  which.</span>
00579 <span class="comment">//</span>
00580 <span class="comment">//  Change: Specify that Data, ShortName, and LongName are copied for storage.</span>
00581 <span class="comment">//</span>
00582 
00583 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00584"></a><a class="code" href="../../d1/d7/tunnel_8c.html#a21">00584</a> <a class="code" href="../../d1/d8/fsrtl_8h.html#a127">FsRtlAddToTunnelCache</a> (
00585     IN PTUNNEL Cache,
00586     IN ULONGLONG DirKey,
00587     IN PUNICODE_STRING ShortName,
00588     IN PUNICODE_STRING LongName,
00589     IN BOOLEAN KeyByShortName,
00590     IN ULONG DataLength,
00591     IN PVOID Data
00592     )
00593 <span class="comment">/*++</span>
00594 <span class="comment"></span>
00595 <span class="comment">Routine Description:</span>
00596 <span class="comment"></span>
00597 <span class="comment">    Adds an entry to the tunnel cache keyed by</span>
00598 <span class="comment"></span>
00599 <span class="comment">        DirectoryKey ## (KeyByShortName ? ShortName : LongName)</span>
00600 <span class="comment"></span>
00601 <span class="comment">    ShortName, LongName, and Data are copied and stored in the tunnel. As a side</span>
00602 <span class="comment">    effect, if there are too many entries in the tunnel cache, this routine will</span>
00603 <span class="comment">    initiate expiration in the tunnel cache.</span>
00604 <span class="comment"></span>
00605 <span class="comment">Arguments:</span>
00606 <span class="comment"></span>
00607 <span class="comment">    Cache - a tunnel cache initialized by FsRtlInitializeTunnelCache()</span>
00608 <span class="comment"></span>
00609 <span class="comment">    DirKey - the key value of the directory the name appeared in</span>
00610 <span class="comment"></span>
00611 <span class="comment">    ShortName - (optional if !KeyByShortName) the 8.3 name of the file</span>
00612 <span class="comment"></span>
00613 <span class="comment">    LongName - (optional if KeyByShortName) the long name of the file</span>
00614 <span class="comment"></span>
00615 <span class="comment">    KeyByShortName - specifies which name is keyed in the tunnel cache</span>
00616 <span class="comment"></span>
00617 <span class="comment">    DataLength - specifies the length of the opaque data segment (file</span>
00618 <span class="comment">    system specific) which contains the tunnelling information for this</span>
00619 <span class="comment">    file</span>
00620 <span class="comment"></span>
00621 <span class="comment">    Data - pointer to the opaque tunneling data segment</span>
00622 <span class="comment"></span>
00623 <span class="comment">Return Value:</span>
00624 <span class="comment"></span>
00625 <span class="comment">    None</span>
00626 <span class="comment"></span>
00627 <span class="comment">--*/</span>
00628 {
00629     LONG <a class="code" href="../../d9/d1/lboxctl2_8c.html#a38">Compare</a>;
00630     ULONG NodeSize;
00631     PUNICODE_STRING NameKey;
00632     PRTL_SPLAY_LINKS *Links;
00633     LIST_ENTRY FreePoolList;
00634 
00635     <a class="code" href="../../d1/d7/tunnel_8c.html#a12">PTUNNEL_NODE</a> Node = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00636     <a class="code" href="../../d1/d7/tunnel_8c.html#a12">PTUNNEL_NODE</a> NewNode = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00637     BOOLEAN FreeOldNode = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00638     BOOLEAN AllocatedFromPool = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00639 
00640     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00641 
00642     <span class="comment">//</span>
00643     <span class="comment">//  If MaxEntries is 0 then tunneling is disabled.</span>
00644     <span class="comment">//</span>
00645 
00646     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d7/tunnel_8c.html#a9">TunnelMaxEntries</a> == 0) <span class="keywordflow">return</span>;
00647 
00648     InitializeListHead(&amp;FreePoolList);
00649 
00650     <span class="comment">//</span>
00651     <span class="comment">//  Grab a new node for this data</span>
00652     <span class="comment">//</span>
00653 
00654     NodeSize = <span class="keyword">sizeof</span>(<a class="code" href="../../d5/d1/structTUNNEL__NODE.html">TUNNEL_NODE</a>) + ShortName-&gt;Length + LongName-&gt;Length + DataLength;
00655 
00656     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d7/tunnel_8c.html#a6">LOOKASIDE_NODE_SIZE</a> &gt;= NodeSize) {
00657 
00658         NewNode = <a class="code" href="../../d5/d8/ex_8h.html#a252">ExAllocateFromPagedLookasideList</a>(&amp;<a class="code" href="../../d1/d7/tunnel_8c.html#a11">TunnelLookasideList</a>);
00659     }
00660 
00661     <span class="keywordflow">if</span> (NewNode == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00662 
00663         <span class="comment">//</span>
00664         <span class="comment">//  Data doesn't fit in lookaside nodes</span>
00665         <span class="comment">//</span>
00666 
00667         NewNode = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>(<a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>, NodeSize, 'PnuT');
00668 
00669         <span class="keywordflow">if</span> (NewNode == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00670 
00671             <span class="comment">//</span>
00672             <span class="comment">//  Give up tunneling this entry</span>
00673             <span class="comment">//</span>
00674 
00675             <span class="keywordflow">return</span>;
00676         }
00677 
00678         AllocatedFromPool = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00679     }
00680 
00681     <span class="comment">//</span>
00682     <span class="comment">//  Traverse the cache to find our insertion point</span>
00683     <span class="comment">//</span>
00684 
00685     NameKey = (KeyByShortName ? ShortName : LongName);
00686 
00687     ExAcquireFastMutex(&amp;Cache-&gt;Mutex);
00688 
00689     Links = &amp;Cache-&gt;Cache;
00690 
00691     <span class="keywordflow">while</span> (*Links) {
00692 
00693         Node = CONTAINING_RECORD(*Links, <a class="code" href="../../d5/d1/structTUNNEL__NODE.html">TUNNEL_NODE</a>, CacheLinks);
00694 
00695         <a class="code" href="../../d9/d1/lboxctl2_8c.html#a38">Compare</a> = <a class="code" href="../../d1/d7/tunnel_8c.html#a15">FsRtlCompareNodeAndKey</a>(Node, DirKey, NameKey);
00696 
00697         <span class="keywordflow">if</span> (<a class="code" href="../../d9/d1/lboxctl2_8c.html#a38">Compare</a> &gt; 0) {
00698 
00699             Links = &amp;RtlLeftChild(&amp;Node-&gt;CacheLinks);
00700 
00701         } <span class="keywordflow">else</span> {
00702 
00703             <span class="keywordflow">if</span> (<a class="code" href="../../d9/d1/lboxctl2_8c.html#a38">Compare</a> &lt; 0) {
00704 
00705                 Links = &amp;RtlRightChild(&amp;Node-&gt;CacheLinks);
00706 
00707             } <span class="keywordflow">else</span> {
00708 
00709                 <span class="keywordflow">break</span>;
00710             }
00711         }
00712     }
00713 
00714     <span class="comment">//</span>
00715     <span class="comment">//  Thread new data into the splay tree</span>
00716     <span class="comment">//</span>
00717 
00718     RtlInitializeSplayLinks(&amp;NewNode-&gt;CacheLinks);
00719 
00720     <span class="keywordflow">if</span> (Node) {
00721 
00722         <span class="comment">//</span>
00723         <span class="comment">//  Not inserting first node in tree</span>
00724         <span class="comment">//</span>
00725 
00726         <span class="keywordflow">if</span> (*Links) {
00727 
00728             <span class="comment">//</span>
00729             <span class="comment">//  Entry exists in the cache, so replace by swapping all splay links</span>
00730             <span class="comment">//</span>
00731 
00732             RtlRightChild(&amp;NewNode-&gt;CacheLinks) = RtlRightChild(*Links);
00733             RtlLeftChild(&amp;NewNode-&gt;CacheLinks) = RtlLeftChild(*Links);
00734 
00735             <span class="keywordflow">if</span> (RtlRightChild(*Links)) RtlParent(RtlRightChild(*Links)) = &amp;NewNode-&gt;CacheLinks;
00736             <span class="keywordflow">if</span> (RtlLeftChild(*Links)) RtlParent(RtlLeftChild(*Links)) = &amp;NewNode-&gt;CacheLinks;
00737 
00738             <span class="keywordflow">if</span> (!RtlIsRoot(*Links)) {
00739 
00740                 <span class="comment">//</span>
00741                 <span class="comment">//  Change over the parent links. Note that we've messed with *Links now</span>
00742                 <span class="comment">//  since it is pointing at the parent member.</span>
00743                 <span class="comment">//</span>
00744 
00745                 RtlParent(&amp;NewNode-&gt;CacheLinks) = RtlParent(*Links);
00746 
00747                 <span class="keywordflow">if</span> (RtlIsLeftChild(*Links)) {
00748 
00749                     RtlLeftChild(RtlParent(*Links)) = &amp;NewNode-&gt;CacheLinks;
00750 
00751                 } <span class="keywordflow">else</span> {
00752 
00753                     RtlRightChild(RtlParent(*Links)) = &amp;NewNode-&gt;CacheLinks;
00754                 }
00755 
00756             } <span class="keywordflow">else</span> {
00757 
00758                 <span class="comment">//</span>
00759                 <span class="comment">//  Set root of the cache</span>
00760                 <span class="comment">//</span>
00761 
00762                 Cache-&gt;Cache = &amp;NewNode-&gt;CacheLinks;
00763             }
00764 
00765             <span class="comment">//</span>
00766             <span class="comment">//  Free old node</span>
00767             <span class="comment">//</span>
00768 
00769             RemoveEntryList(&amp;Node-&gt;ListLinks);
00770 
00771             <a class="code" href="../../d1/d7/tunnel_8c.html#a16">FsRtlFreeTunnelNode</a>(Node, &amp;FreePoolList);
00772 
00773             Cache-&gt;NumEntries--;
00774 
00775         } <span class="keywordflow">else</span> {
00776 
00777             <span class="comment">//</span>
00778             <span class="comment">//  Simple insertion as a leaf</span>
00779             <span class="comment">//</span>
00780 
00781             NewNode-&gt;CacheLinks.Parent = &amp;Node-&gt;CacheLinks;
00782             *Links = &amp;NewNode-&gt;CacheLinks;
00783         }
00784 
00785     } <span class="keywordflow">else</span> {
00786 
00787         Cache-&gt;Cache = &amp;NewNode-&gt;CacheLinks;
00788     }
00789 
00790     <span class="comment">//</span>
00791     <span class="comment">//  Thread onto the timer list</span>
00792     <span class="comment">//</span>
00793 
00794     <a class="code" href="../../d7/d0/ke_2miscc_8c.html#a3">KeQuerySystemTime</a>(&amp;NewNode-&gt;CreateTime);
00795     InsertTailList(&amp;Cache-&gt;TimerQueue, &amp;NewNode-&gt;ListLinks);
00796 
00797     Cache-&gt;NumEntries++;
00798 
00799     <span class="comment">//</span>
00800     <span class="comment">//  Stash tunneling information</span>
00801     <span class="comment">//</span>
00802 
00803     NewNode-&gt;DirKey = DirKey;
00804 
00805     <span class="keywordflow">if</span> (KeyByShortName) {
00806 
00807         NewNode-&gt;Flags = <a class="code" href="../../d1/d7/tunnel_8c.html#a8">TUNNEL_FLAG_KEY_SHORT</a>;
00808 
00809     } <span class="keywordflow">else</span> {
00810 
00811         NewNode-&gt;Flags = 0;
00812     }
00813 
00814     <span class="comment">//</span>
00815     <span class="comment">//  Initialize the internal UNICODE_STRINGS to point at the buffer segments. For various</span>
00816     <span class="comment">//  reasons (UNICODE APIs are incomplete, we're avoiding calling any allocate routine more</span>
00817     <span class="comment">//  than once, UNICODE strings are not guaranteed to be null terminated) we have to do a lot</span>
00818     <span class="comment">//  of this by hand.</span>
00819     <span class="comment">//</span>
00820     <span class="comment">//  The data is layed out like this in the allocated block:</span>
00821     <span class="comment">//</span>
00822     <span class="comment">//  -----------------------------------------------------------------------------------</span>
00823     <span class="comment">//  | TUNNEL_NODE | Node-&gt;ShortName.Buffer | Node-&gt;LongName.Buffer | Node-&gt;TunnelData |</span>
00824     <span class="comment">//  -----------------------------------------------------------------------------------</span>
00825     <span class="comment">//</span>
00826 
00827     NewNode-&gt;ShortName.Buffer = (PWCHAR)((PCHAR)NewNode + <span class="keyword">sizeof</span>(<a class="code" href="../../d5/d1/structTUNNEL__NODE.html">TUNNEL_NODE</a>));
00828     NewNode-&gt;LongName.Buffer = (PWCHAR)((PCHAR)NewNode + <span class="keyword">sizeof</span>(<a class="code" href="../../d5/d1/structTUNNEL__NODE.html">TUNNEL_NODE</a>) + ShortName-&gt;Length);
00829 
00830     NewNode-&gt;ShortName.Length = NewNode-&gt;ShortName.MaximumLength = ShortName-&gt;Length;
00831     NewNode-&gt;LongName.Length = NewNode-&gt;LongName.MaximumLength = LongName-&gt;Length;
00832 
00833     <span class="keywordflow">if</span> (ShortName-&gt;Length) {
00834 
00835         RtlCopyMemory(NewNode-&gt;ShortName.Buffer, ShortName-&gt;Buffer, ShortName-&gt;Length);
00836     }
00837 
00838     <span class="keywordflow">if</span> (LongName-&gt;Length) {
00839 
00840         RtlCopyMemory(NewNode-&gt;LongName.Buffer, LongName-&gt;Buffer, LongName-&gt;Length);
00841     }
00842 
00843     NewNode-&gt;TunnelData = (PVOID)((PCHAR)NewNode + <span class="keyword">sizeof</span>(<a class="code" href="../../d5/d1/structTUNNEL__NODE.html">TUNNEL_NODE</a>) + ShortName-&gt;Length + LongName-&gt;Length);
00844 
00845     NewNode-&gt;TunnelDataLength = DataLength;
00846 
00847     RtlCopyMemory(NewNode-&gt;TunnelData, Data, DataLength);
00848 
00849     <span class="keywordflow">if</span> (AllocatedFromPool) {
00850 
00851         <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>(NewNode-&gt;Flags, <a class="code" href="../../d1/d7/tunnel_8c.html#a7">TUNNEL_FLAG_NON_LOOKASIDE</a>);
00852     }
00853 
00854 <span class="preprocessor">#if defined(TUNNELTEST) || defined (KEYVIEW)</span>
00855 <span class="preprocessor"></span>    <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"FsRtlAddToTunnelCache:\n"</span>);
00856     DumpNode(NewNode, 1);
00857 <span class="preprocessor">#ifndef KEYVIEW</span>
00858 <span class="preprocessor"></span>    DumpTunnel(Cache);
00859 <span class="preprocessor">#endif</span>
00860 <span class="preprocessor"></span><span class="preprocessor">#endif // TUNNELTEST</span>
00861 <span class="preprocessor"></span>
00862     <span class="comment">//</span>
00863     <span class="comment">//  Clean out the cache, release, and then drop any pool memory we need to</span>
00864     <span class="comment">//</span>
00865 
00866     <a class="code" href="../../d1/d7/tunnel_8c.html#a14">FsRtlPruneTunnelCache</a>(Cache, &amp;FreePoolList);
00867 
00868     ExReleaseFastMutex(&amp;Cache-&gt;Mutex);
00869 
00870     <a class="code" href="../../d1/d7/tunnel_8c.html#a17">FsRtlEmptyFreePoolList</a>(&amp;FreePoolList);
00871 
00872     <span class="keywordflow">return</span>;
00873 }
00874 
00875 
00876 <span class="comment">//</span>
00877 <span class="comment">//  *** SPEC</span>
00878 <span class="comment">//</span>
00879 <span class="comment">//    FsRtlFindInTunnelCache - retrieve information from tunnel cache</span>
00880 <span class="comment">//</span>
00881 <span class="comment">//    FsRtlFindInTunnelCache consults the cache to see if an entry with the same</span>
00882 <span class="comment">//    DirectoryKey and ShortName exist.  If so, it returns the data associated with the</span>
00883 <span class="comment">//    cache entry.  The entry may or may not be freed from the cache.  Information that is</span>
00884 <span class="comment">//    stale but not yet purged (older than the retention threshold but not yet cleaned out)</span>
00885 <span class="comment">//    may be returned.</span>
00886 <span class="comment">//</span>
00887 <span class="comment">//    File systems call FsRtlFindInTunnel cache in the create path when a new file is</span>
00888 <span class="comment">//    being created and in the rename path when a new name is appearing in a directory.</span>
00889 <span class="comment">//</span>
00890 <span class="comment">//    The caller is required to synchronize this call against FsRtlDeleteTunnelCache.</span>
00891 <span class="comment">//</span>
00892 <span class="comment">//    Arguments:</span>
00893 <span class="comment">//        Cache        a tunnel cache initialized by FsRtlInitializeTunnelCache()</span>
00894 <span class="comment">//        DirectoryKey    ULONG unique ID of the directory where a name is appearing</span>
00895 <span class="comment">//        Name        UNICODE_STRING* name that is being created</span>
00896 <span class="comment">//        DataLength     in length of buffer, out returned length of data found</span>
00897 <span class="comment">//        Data        pointer to buffer</span>
00898 <span class="comment">//</span>
00899 <span class="comment">//    Returns:</span>
00900 <span class="comment">//        TRUE iff a matching DirectoryKey/Name pair are found, FALSE otherwise</span>
00901 <span class="comment">//</span>
00902 <span class="comment">//  Change: Add out parameters ShortName and LongName to capture the file naming information.</span>
00903 <span class="comment">//  Plus: this avoids the need for marshalling/unmarshalling steps for the current desired use of</span>
00904 <span class="comment">//  this code since otherwise we'd have variable length unaligned structures to contain the</span>
00905 <span class="comment">//  strings along with the other meta-info.</span>
00906 <span class="comment">//  Minus: Possibly a bad precedent.</span>
00907 <span class="comment">//</span>
00908 <span class="comment">//  Change: spec reads "may or may not be freed from cache" on a hit. This complicates unwinding</span>
00909 <span class="comment">//  from aborted operations. Data will not be freed on a hit, but will expire like normal entries.</span>
00910 <span class="comment">//</span>
00911 
00912 BOOLEAN
<a name="l00913"></a><a class="code" href="../../d1/d7/tunnel_8c.html#a22">00913</a> <a class="code" href="../../d1/d8/fsrtl_8h.html#a128">FsRtlFindInTunnelCache</a> (
00914     IN PTUNNEL Cache,
00915     IN ULONGLONG DirKey,
00916     IN PUNICODE_STRING Name,
00917     OUT PUNICODE_STRING ShortName,
00918     OUT PUNICODE_STRING LongName,
00919     IN OUT PULONG  DataLength,
00920     OUT PVOID Data
00921     )
00922 <span class="comment">/*++</span>
00923 <span class="comment"></span>
00924 <span class="comment">Routine Description:</span>
00925 <span class="comment"></span>
00926 <span class="comment">    Looks up the key</span>
00927 <span class="comment"></span>
00928 <span class="comment">        DirKey ## Name</span>
00929 <span class="comment"></span>
00930 <span class="comment">    in the tunnel cache and removes it. As a side effect, this routine will initiate</span>
00931 <span class="comment">    expiration of the aged entries in the tunnel cache.</span>
00932 <span class="comment"></span>
00933 <span class="comment">Arguments:</span>
00934 <span class="comment"></span>
00935 <span class="comment">    Cache - a tunnel cache initialized by FsRtlInitializeTunnelCache()</span>
00936 <span class="comment"></span>
00937 <span class="comment">    DirKey - the key value of the directory the name will appear in</span>
00938 <span class="comment"></span>
00939 <span class="comment">    Name - the name of the entry</span>
00940 <span class="comment"></span>
00941 <span class="comment">    ShortName - return string to hold the short name of the tunneled file. Must</span>
00942 <span class="comment">        already be allocated and large enough for max 8.3 name</span>
00943 <span class="comment"></span>
00944 <span class="comment">    LongName -  return string to hold the long name of the tunneled file. If</span>
00945 <span class="comment">        already allocated, may be grown if not large enough. Caller is</span>
00946 <span class="comment">        responsible for noticing this and freeing data regardless of return value.</span>
00947 <span class="comment"></span>
00948 <span class="comment">    DataLength - provides the length of the buffer avaliable to hold the</span>
00949 <span class="comment">        tunneling information, returns the size of the tunneled information</span>
00950 <span class="comment">        read out</span>
00951 <span class="comment"></span>
00952 <span class="comment">Return Value:</span>
00953 <span class="comment"></span>
00954 <span class="comment">    Boolean true if found, false otherwise</span>
00955 <span class="comment"></span>
00956 <span class="comment">--*/</span>
00957 {
00958     PRTL_SPLAY_LINKS Links;
00959     <a class="code" href="../../d1/d7/tunnel_8c.html#a12">PTUNNEL_NODE</a> Node;
00960     LONG <a class="code" href="../../d9/d1/lboxctl2_8c.html#a38">Compare</a>;
00961     LIST_ENTRY FreePoolList;
00962 
00963     BOOLEAN <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00964 
00965     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00966 
00967     <span class="comment">//</span>
00968     <span class="comment">//  If MaxEntries is 0 then tunneling is disabled.</span>
00969     <span class="comment">//</span>
00970 
00971     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d7/tunnel_8c.html#a9">TunnelMaxEntries</a> == 0) <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00972 
00973     InitializeListHead(&amp;FreePoolList);
00974 
00975 <span class="preprocessor">#ifdef KEYVIEW</span>
00976 <span class="preprocessor"></span>    <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"++\nSearching for %wZ , %08x%08x\n--\n"</span>, <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>, DblHex64(DirKey));
00977 <span class="preprocessor">#endif</span>
00978 <span class="preprocessor"></span>
00979     ExAcquireFastMutex(&amp;Cache-&gt;Mutex);
00980 
00981     <span class="comment">//</span>
00982     <span class="comment">//  Expire aged entries first so we don't grab old data</span>
00983     <span class="comment">//</span>
00984 
00985     <a class="code" href="../../d1/d7/tunnel_8c.html#a14">FsRtlPruneTunnelCache</a>(Cache, &amp;FreePoolList);
00986 
00987     Links = Cache-&gt;Cache;
00988 
00989     <span class="keywordflow">while</span> (Links) {
00990 
00991         Node = CONTAINING_RECORD(Links, <a class="code" href="../../d5/d1/structTUNNEL__NODE.html">TUNNEL_NODE</a>, CacheLinks);
00992 
00993         <a class="code" href="../../d9/d1/lboxctl2_8c.html#a38">Compare</a> = <a class="code" href="../../d1/d7/tunnel_8c.html#a15">FsRtlCompareNodeAndKey</a>(Node, DirKey, <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>);
00994 
00995         <span class="keywordflow">if</span> (<a class="code" href="../../d9/d1/lboxctl2_8c.html#a38">Compare</a> &gt; 0) {
00996 
00997             Links = RtlLeftChild(&amp;Node-&gt;CacheLinks);
00998 
00999         } <span class="keywordflow">else</span> {
01000 
01001             <span class="keywordflow">if</span> (<a class="code" href="../../d9/d1/lboxctl2_8c.html#a38">Compare</a> &lt; 0) {
01002 
01003                 Links = RtlRightChild(&amp;Node-&gt;CacheLinks);
01004 
01005             } <span class="keywordflow">else</span> {
01006 
01007                 <span class="comment">//</span>
01008                 <span class="comment">//  Found tunneling information</span>
01009                 <span class="comment">//</span>
01010 
01011 <span class="preprocessor">#if defined(TUNNELTEST) || defined(KEYVIEW)</span>
01012 <span class="preprocessor"></span>                <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"FsRtlFindInTunnelCache:\n"</span>);
01013                 DumpNode(Node, 1);
01014 <span class="preprocessor">#ifndef KEYVIEW</span>
01015 <span class="preprocessor"></span>                DumpTunnel(Cache);
01016 <span class="preprocessor">#endif</span>
01017 <span class="preprocessor"></span><span class="preprocessor">#endif // TUNNELTEST</span>
01018 <span class="preprocessor"></span>
01019                 <span class="keywordflow">break</span>;
01020             }
01021         }
01022     }
01023 
01024     <span class="keywordflow">try</span> {
01025 
01026         <span class="keywordflow">if</span> (Links) {
01027     
01028             <span class="comment">//</span>
01029             <span class="comment">//  Copy node data into caller's area</span>
01030             <span class="comment">//</span>
01031     
01032             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(ShortName-&gt;MaximumLength &gt;= (8+1+3)*<span class="keyword">sizeof</span>(WCHAR));
01033             <a class="code" href="../../d6/d6/nls_8c.html#a44">RtlCopyUnicodeString</a>(ShortName, &amp;Node-&gt;ShortName);
01034     
01035             <span class="keywordflow">if</span> (LongName-&gt;MaximumLength &gt;= Node-&gt;LongName.Length) {
01036     
01037                 <a class="code" href="../../d6/d6/nls_8c.html#a44">RtlCopyUnicodeString</a>(LongName, &amp;Node-&gt;LongName);
01038     
01039             } <span class="keywordflow">else</span> {
01040     
01041                 <span class="comment">//</span>
01042                 <span class="comment">//  Need to allocate more memory for the long name</span>
01043                 <span class="comment">//</span>
01044     
01045                 LongName-&gt;Buffer = <a class="code" href="../../d1/d8/fsrtl_8h.html#a37">FsRtlAllocatePoolWithTag</a>(<a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>, Node-&gt;LongName.Length, '4nuT');
01046                 LongName-&gt;Length = LongName-&gt;MaximumLength = Node-&gt;LongName.Length;
01047     
01048                 RtlCopyMemory(LongName-&gt;Buffer, Node-&gt;LongName.Buffer, Node-&gt;LongName.Length);
01049             }
01050     
01051             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(*DataLength &gt;= Node-&gt;TunnelDataLength);
01052             RtlCopyMemory(Data, Node-&gt;TunnelData, Node-&gt;TunnelDataLength);
01053             *DataLength = Node-&gt;TunnelDataLength;
01054     
01055             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01056         }
01057 
01058     } finally {
01059 
01060         ExReleaseFastMutex(&amp;Cache-&gt;Mutex);
01061     
01062         <a class="code" href="../../d1/d7/tunnel_8c.html#a17">FsRtlEmptyFreePoolList</a>(&amp;FreePoolList);
01063     }
01064     
01065     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01066 }
01067 
01068 
01069 <span class="comment">//</span>
01070 <span class="comment">//  *** SPEC</span>
01071 <span class="comment">//</span>
01072 <span class="comment">//    FsRtlDeleteKeyFromTunnelCache - delete all cached information associated with</span>
01073 <span class="comment">//    a DirectoryKey</span>
01074 <span class="comment">//</span>
01075 <span class="comment">//    When file systems delete a directory, all cached information relating to that directory</span>
01076 <span class="comment">//    must be purged.  File systems call FsRtlDeleteKeyFromTunnelCache in the rmdir path.</span>
01077 <span class="comment">//</span>
01078 <span class="comment">//    The caller is required to synchronize this call against FsRtlDeleteTunnelCache.</span>
01079 <span class="comment">//</span>
01080 <span class="comment">//    Arguments:</span>
01081 <span class="comment">//        Cache        a tunnel cache initialized by FsRtlInitializeTunnelCache()</span>
01082 <span class="comment">//        DirectoryKey    ULONGLONG unique ID of the directory that is being deleted</span>
01083 <span class="comment">//</span>
01084 
01085 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01086"></a><a class="code" href="../../d1/d7/tunnel_8c.html#a23">01086</a> <a class="code" href="../../d1/d8/fsrtl_8h.html#a129">FsRtlDeleteKeyFromTunnelCache</a> (
01087     IN PTUNNEL Cache,
01088     IN ULONGLONG DirKey
01089     )
01090 <span class="comment">/*++</span>
01091 <span class="comment"></span>
01092 <span class="comment">Routine Description:</span>
01093 <span class="comment"></span>
01094 <span class="comment">    Deletes all entries in the cache associated with a specific directory</span>
01095 <span class="comment"></span>
01096 <span class="comment">Arguments:</span>
01097 <span class="comment"></span>
01098 <span class="comment">    Cache - a tunnel cache initialized by FsRtlInitializeTunnelCache()</span>
01099 <span class="comment"></span>
01100 <span class="comment">    DirKey - the key value of the directory (presumeably being removed)</span>
01101 <span class="comment"></span>
01102 <span class="comment">Return Value:</span>
01103 <span class="comment"></span>
01104 <span class="comment">    None</span>
01105 <span class="comment"></span>
01106 <span class="comment">--*/</span>
01107 {
01108     PRTL_SPLAY_LINKS Links;
01109     PRTL_SPLAY_LINKS SuccessorLinks;
01110     <a class="code" href="../../d1/d7/tunnel_8c.html#a12">PTUNNEL_NODE</a> Node;
01111     LIST_ENTRY FreePoolList;
01112 
01113     PRTL_SPLAY_LINKS LastLinks = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01114     BOOLEAN Splay = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01115 
01116     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01117 
01118     <span class="comment">//</span>
01119     <span class="comment">//  If MaxEntries is 0 then tunneling is disabled.</span>
01120     <span class="comment">//</span>
01121 
01122     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d7/tunnel_8c.html#a9">TunnelMaxEntries</a> == 0) <span class="keywordflow">return</span>;
01123 
01124     InitializeListHead(&amp;FreePoolList);
01125 
01126 <span class="preprocessor">#ifdef KEYVIEW</span>
01127 <span class="preprocessor"></span>    <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"++\nDeleting key %08x%08x\n--\n"</span>, DblHex64(DirKey));
01128 <span class="preprocessor">#endif</span>
01129 <span class="preprocessor"></span>
01130     ExAcquireFastMutex(&amp;Cache-&gt;Mutex);
01131 
01132     Links = Cache-&gt;Cache;
01133 
01134     <span class="keywordflow">while</span> (Links) {
01135 
01136         Node = CONTAINING_RECORD(Links, <a class="code" href="../../d5/d1/structTUNNEL__NODE.html">TUNNEL_NODE</a>, CacheLinks);
01137 
01138         <span class="keywordflow">if</span> (Node-&gt;DirKey &gt; DirKey) {
01139 
01140             <span class="comment">//</span>
01141             <span class="comment">//  All nodes to the right are bigger, go left</span>
01142             <span class="comment">//</span>
01143 
01144             Links = RtlLeftChild(&amp;Node-&gt;CacheLinks);
01145 
01146         } <span class="keywordflow">else</span> {
01147 
01148             <span class="keywordflow">if</span> (Node-&gt;DirKey &lt; DirKey) {
01149 
01150                 <span class="keywordflow">if</span> (LastLinks) {
01151 
01152                     <span class="comment">//</span>
01153                     <span class="comment">//  If we have previously seen a candidate node to delete</span>
01154                     <span class="comment">//  and we have now gone too far left - we know where to start.</span>
01155                     <span class="comment">//</span>
01156 
01157                     <span class="keywordflow">break</span>;
01158                 }
01159 
01160                 Links = RtlRightChild(&amp;Node-&gt;CacheLinks);
01161 
01162             } <span class="keywordflow">else</span> {
01163 
01164                 <span class="comment">//</span>
01165                 <span class="comment">//  Node is a candidate to be deleted, but we might have more nodes</span>
01166                 <span class="comment">//  to the left in the tree. Note this location and go on.</span>
01167                 <span class="comment">//</span>
01168 
01169                 LastLinks = Links;
01170                 Links = RtlLeftChild(&amp;Node-&gt;CacheLinks);
01171             }
01172         }
01173     }
01174 
01175     <span class="keywordflow">for</span> (Links = LastLinks;
01176          Links;
01177          Links = SuccessorLinks) {
01178 
01179         SuccessorLinks = <a class="code" href="../../d3/d4/splay_8c.html#a8">RtlRealSuccessor</a>(Links);
01180         Node = CONTAINING_RECORD(Links, <a class="code" href="../../d5/d1/structTUNNEL__NODE.html">TUNNEL_NODE</a>, CacheLinks);
01181 
01182         <span class="keywordflow">if</span> (Node-&gt;DirKey != DirKey) {
01183 
01184             <span class="comment">//</span>
01185             <span class="comment">//  Reached nodes which have a different key, so we're done</span>
01186             <span class="comment">//</span>
01187 
01188             <span class="keywordflow">break</span>;
01189         }
01190 
01191         <a class="code" href="../../d1/d7/tunnel_8c.html#a18">FsRtlRemoveNodeFromTunnel</a>(Cache, Node, &amp;FreePoolList, &amp;Splay);
01192     }
01193 
01194 <span class="preprocessor">#ifdef TUNNELTEST</span>
01195 <span class="preprocessor"></span>    <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"FsRtlDeleteKeyFromTunnelCache:\n"</span>);
01196 <span class="preprocessor">#ifndef KEYVIEW</span>
01197 <span class="preprocessor"></span>    DumpTunnel(Cache);
01198 <span class="preprocessor">#endif</span>
01199 <span class="preprocessor"></span><span class="preprocessor">#endif // TUNNELTEST</span>
01200 <span class="preprocessor"></span>
01201     ExReleaseFastMutex(&amp;Cache-&gt;Mutex);
01202 
01203     <span class="comment">//</span>
01204     <span class="comment">//  Free delayed pool</span>
01205     <span class="comment">//</span>
01206 
01207     <a class="code" href="../../d1/d7/tunnel_8c.html#a17">FsRtlEmptyFreePoolList</a>(&amp;FreePoolList);
01208 
01209     <span class="keywordflow">return</span>;
01210 }
01211 
01212 
01213 <span class="comment">//</span>
01214 <span class="comment">//  *** SPEC</span>
01215 <span class="comment">//</span>
01216 <span class="comment">//    FsRtlDeleteTunnelCache - free a tunnel cache</span>
01217 <span class="comment">//</span>
01218 <span class="comment">//    FsRtlDeleteTunnelCache deletes all cached information.  The Cache is no longer</span>
01219 <span class="comment">//    valid.</span>
01220 <span class="comment">//</span>
01221 <span class="comment">//    Arguments:</span>
01222 <span class="comment">//        Cache        a tunnel cache initialized by FsRtlInitializeTunnelCache()</span>
01223 <span class="comment">//</span>
01224 
01225 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01226"></a><a class="code" href="../../d1/d7/tunnel_8c.html#a24">01226</a> <a class="code" href="../../d1/d8/fsrtl_8h.html#a130">FsRtlDeleteTunnelCache</a> (
01227     IN PTUNNEL Cache
01228     )
01229 <span class="comment">/*++</span>
01230 <span class="comment"></span>
01231 <span class="comment">Routine Description:</span>
01232 <span class="comment"></span>
01233 <span class="comment">    Deletes a tunnel cache</span>
01234 <span class="comment"></span>
01235 <span class="comment">Arguments:</span>
01236 <span class="comment"></span>
01237 <span class="comment">    Cache - the cache to delete, initialized by FsRtlInitializeTunnelCache()</span>
01238 <span class="comment"></span>
01239 <span class="comment">Return Value:</span>
01240 <span class="comment"></span>
01241 <span class="comment">    None</span>
01242 <span class="comment"></span>
01243 <span class="comment">--*/</span>
01244 {
01245     <a class="code" href="../../d1/d7/tunnel_8c.html#a12">PTUNNEL_NODE</a> Node;
01246     PLIST_ENTRY Link, Next;
01247 
01248     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01249 
01250     <span class="comment">//</span>
01251     <span class="comment">//  If MaxEntries is 0 then tunneling is disabled.</span>
01252     <span class="comment">//</span>
01253 
01254     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d7/tunnel_8c.html#a9">TunnelMaxEntries</a> == 0) <span class="keywordflow">return</span>;
01255 
01256     <span class="comment">//</span>
01257     <span class="comment">//  Zero out the cache and delete everything on the timer list</span>
01258     <span class="comment">//</span>
01259 
01260     Cache-&gt;Cache = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01261     Cache-&gt;NumEntries = 0;
01262 
01263     <span class="keywordflow">for</span> (Link = Cache-&gt;TimerQueue.Flink;
01264          Link != &amp;Cache-&gt;TimerQueue;
01265          Link = Next) {
01266 
01267         Next = Link-&gt;Flink;
01268 
01269         Node = CONTAINING_RECORD(Link, <a class="code" href="../../d5/d1/structTUNNEL__NODE.html">TUNNEL_NODE</a>, ListLinks);
01270 
01271         <a class="code" href="../../d1/d7/tunnel_8c.html#a16">FsRtlFreeTunnelNode</a>(Node, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
01272     }
01273 
01274     InitializeListHead(&amp;Cache-&gt;TimerQueue);
01275 
01276     <span class="keywordflow">return</span>;
01277 }
01278 
01279 
01280 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01281"></a><a class="code" href="../../d1/d7/tunnel_8c.html#a14">01281</a> <a class="code" href="../../d1/d7/tunnel_8c.html#a14">FsRtlPruneTunnelCache</a> (
01282     IN PTUNNEL Cache,
01283     IN OUT PLIST_ENTRY FreePoolList
01284     )
01285 <span class="comment">/*++</span>
01286 <span class="comment"></span>
01287 <span class="comment">Routine Description:</span>
01288 <span class="comment"></span>
01289 <span class="comment">    Removes deadwood entries from the tunnel cache as defined by TunnelMaxAge and TunnelMaxEntries.</span>
01290 <span class="comment">    Pool memory is returned on a list for deletion by the calling routine at a time of</span>
01291 <span class="comment">    its choosing.</span>
01292 <span class="comment"></span>
01293 <span class="comment">    For performance reasons we don't want to force freeing of memory inside a mutex.</span>
01294 <span class="comment"></span>
01295 <span class="comment">Arguments:</span>
01296 <span class="comment"></span>
01297 <span class="comment">    Cache - the tunnel cache to prune</span>
01298 <span class="comment"></span>
01299 <span class="comment">    FreePoolList - a list to queue pool memory on to</span>
01300 <span class="comment"></span>
01301 <span class="comment">Return Value:</span>
01302 <span class="comment"></span>
01303 <span class="comment">    None</span>
01304 <span class="comment">--*/</span>
01305 {
01306     <a class="code" href="../../d1/d7/tunnel_8c.html#a12">PTUNNEL_NODE</a> Node;
01307     LARGE_INTEGER ExpireTime;
01308     LARGE_INTEGER CurrentTime;
01309     BOOLEAN Splay = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01310 
01311     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01312 
01313     <span class="comment">//</span>
01314     <span class="comment">//  Calculate the age of the oldest entry we want to keep</span>
01315     <span class="comment">//</span>
01316 
01317     <a class="code" href="../../d7/d0/ke_2miscc_8c.html#a3">KeQuerySystemTime</a>(&amp;CurrentTime);
01318     ExpireTime.QuadPart = CurrentTime.QuadPart - <a class="code" href="../../d1/d7/tunnel_8c.html#a10">TunnelMaxAge</a>;
01319 
01320     <span class="comment">//</span>
01321     <span class="comment">//  Expire old entries off of the timer queue.  We have to check</span>
01322     <span class="comment">//  for future time because the clock may jump as a result of</span>
01323     <span class="comment">//  hard clock change.  If we did not do this, a rogue entry</span>
01324     <span class="comment">//  with a future time could sit at the top of the queue and</span>
01325     <span class="comment">//  prevent entries from going away.</span>
01326     <span class="comment">//</span>
01327 
01328     <span class="keywordflow">while</span> (!IsListEmpty(&amp;Cache-&gt;TimerQueue)) {
01329 
01330         Node = CONTAINING_RECORD(Cache-&gt;TimerQueue.Flink, <a class="code" href="../../d5/d1/structTUNNEL__NODE.html">TUNNEL_NODE</a>, ListLinks);
01331 
01332         <span class="keywordflow">if</span> (Node-&gt;CreateTime.QuadPart &lt; ExpireTime.QuadPart ||
01333             Node-&gt;CreateTime.QuadPart &gt; CurrentTime.QuadPart) {
01334 
01335 <span class="preprocessor">#if defined(TUNNELTEST) || defined(KEYVIEW)</span>
01336 <span class="preprocessor"></span>            <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"Expiring node %x (%ud%ud 1/10 msec too old)\n"</span>, Node, DblHex64(ExpireTime.QuadPart - Node-&gt;CreateTime.QuadPart));
01337 <span class="preprocessor">#endif // TUNNELTEST</span>
01338 <span class="preprocessor"></span>
01339             <a class="code" href="../../d1/d7/tunnel_8c.html#a18">FsRtlRemoveNodeFromTunnel</a>(Cache, Node, FreePoolList, &amp;Splay);
01340 
01341         } <span class="keywordflow">else</span> {
01342 
01343             <span class="comment">//</span>
01344             <span class="comment">//  No more nodes to be expired</span>
01345             <span class="comment">//</span>
01346 
01347             <span class="keywordflow">break</span>;
01348         }
01349     }
01350 
01351     <span class="comment">//</span>
01352     <span class="comment">//  Remove entries until we're under the TunnelMaxEntries limit</span>
01353     <span class="comment">//</span>
01354 
01355     <span class="keywordflow">while</span> (Cache-&gt;NumEntries &gt; <a class="code" href="../../d1/d7/tunnel_8c.html#a9">TunnelMaxEntries</a>) {
01356 
01357         Node = CONTAINING_RECORD(Cache-&gt;TimerQueue.Flink, <a class="code" href="../../d5/d1/structTUNNEL__NODE.html">TUNNEL_NODE</a>, ListLinks);
01358 
01359 <span class="preprocessor">#if defined(TUNNELTEST) || defined(KEYVIEW)</span>
01360 <span class="preprocessor"></span>            <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"Dumping node %x (%d &gt; %d)\n"</span>, Node, Cache-&gt;NumEntries, <a class="code" href="../../d1/d7/tunnel_8c.html#a9">TunnelMaxEntries</a>);
01361 <span class="preprocessor">#endif // TUNNELTEST</span>
01362 <span class="preprocessor"></span>
01363         <a class="code" href="../../d1/d7/tunnel_8c.html#a18">FsRtlRemoveNodeFromTunnel</a>(Cache, Node, FreePoolList, &amp;Splay);
01364     }
01365 
01366     <span class="keywordflow">return</span>;
01367 }
01368 
01369 
01370 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l01371"></a><a class="code" href="../../d1/d7/tunnel_8c.html#a13">01371</a> <a class="code" href="../../d1/d7/tunnel_8c.html#a13">FsRtlGetTunnelParameterValue</a> (
01372     IN PUNICODE_STRING ValueName,
01373     IN OUT PULONG Value
01374     )
01375 
01376 <span class="comment">/*++</span>
01377 <span class="comment"></span>
01378 <span class="comment">Routine Description:</span>
01379 <span class="comment"></span>
01380 <span class="comment">    Given a unicode value name this routine will go into the registry</span>
01381 <span class="comment">    location for the Tunnel parameter information and get the</span>
01382 <span class="comment">    value.</span>
01383 <span class="comment"></span>
01384 <span class="comment">Arguments:</span>
01385 <span class="comment"></span>
01386 <span class="comment">    ValueName - the unicode name for the registry value located in the</span>
01387 <span class="comment">                double space configuration location of the registry.</span>
01388 <span class="comment">    Value   - a pointer to the ULONG for the result.</span>
01389 <span class="comment"></span>
01390 <span class="comment">Return Value:</span>
01391 <span class="comment"></span>
01392 <span class="comment">    NTSTATUS</span>
01393 <span class="comment"></span>
01394 <span class="comment">    If STATUS_SUCCESSFUL is returned, the location *Value will be</span>
01395 <span class="comment">    updated with the DWORD value from the registry.  If any failing</span>
01396 <span class="comment">    status is returned, this value is untouched.</span>
01397 <span class="comment"></span>
01398 <span class="comment">--*/</span>
01399 
01400 {
01401     HANDLE <a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a>;
01402     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01403     ULONG RequestLength;
01404     ULONG ResultLength;
01405     UCHAR <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>[<a class="code" href="../../d4/d8/fsrtlpc_8c.html#a2">KEY_WORK_AREA</a>];
01406     UNICODE_STRING <a class="code" href="../../d8/d0/rtbatcr_8c.html#a3">KeyName</a>;
01407     OBJECT_ATTRIBUTES <a class="code" href="../../d7/d0/ctlnpqos_8c.html#a4">ObjectAttributes</a>;
01408     PKEY_VALUE_FULL_INFORMATION KeyValueInformation;
01409 
01410     <a class="code" href="../../d8/d0/rtbatcr_8c.html#a3">KeyName</a>.Buffer = <a class="code" href="../../d1/d7/tunnel_8c.html#a1">TUNNEL_KEY_NAME</a>;
01411     <a class="code" href="../../d8/d0/rtbatcr_8c.html#a3">KeyName</a>.Length = <span class="keyword">sizeof</span>(<a class="code" href="../../d1/d7/tunnel_8c.html#a1">TUNNEL_KEY_NAME</a>) - <span class="keyword">sizeof</span>(WCHAR);
01412     <a class="code" href="../../d8/d0/rtbatcr_8c.html#a3">KeyName</a>.MaximumLength = <span class="keyword">sizeof</span>(<a class="code" href="../../d1/d7/tunnel_8c.html#a1">TUNNEL_KEY_NAME</a>);
01413 
01414     InitializeObjectAttributes(&amp;<a class="code" href="../../d7/d0/ctlnpqos_8c.html#a4">ObjectAttributes</a>,
01415                                &amp;<a class="code" href="../../d8/d0/rtbatcr_8c.html#a3">KeyName</a>,
01416                                OBJ_CASE_INSENSITIVE,
01417                                <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
01418                                <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
01419 
01420     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwOpenKey(&amp;<a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a>,
01421                        KEY_READ,
01422                        &amp;<a class="code" href="../../d7/d0/ctlnpqos_8c.html#a4">ObjectAttributes</a>);
01423 
01424     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
01425 
01426         <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01427     }
01428 
01429     RequestLength = <a class="code" href="../../d4/d8/fsrtlpc_8c.html#a2">KEY_WORK_AREA</a>;
01430 
01431     KeyValueInformation = (PKEY_VALUE_FULL_INFORMATION)<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>;
01432 
01433     <span class="keywordflow">while</span> (1) {
01434 
01435         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwQueryValueKey(<a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a>,
01436                                  <a class="code" href="../../d1/d1/rtdelval_8c.html#a3">ValueName</a>,
01437                                  KeyValueFullInformation,
01438                                  KeyValueInformation,
01439                                  RequestLength,
01440                                  &amp;ResultLength);
01441 
01442         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> != STATUS_BUFFER_OVERFLOW );
01443 
01444         <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_BUFFER_OVERFLOW) {
01445 
01446             <span class="comment">//</span>
01447             <span class="comment">// Try to get a buffer big enough.</span>
01448             <span class="comment">//</span>
01449 
01450             <span class="keywordflow">if</span> (KeyValueInformation != (PKEY_VALUE_FULL_INFORMATION)<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>) {
01451 
01452                 <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(KeyValueInformation);
01453             }
01454 
01455             RequestLength += 256;
01456 
01457             KeyValueInformation = (PKEY_VALUE_FULL_INFORMATION)
01458                                   <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>(<a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>,
01459                                                         RequestLength,
01460                                                         'KnuT');
01461 
01462             <span class="keywordflow">if</span> (!KeyValueInformation) {
01463                 <span class="keywordflow">return</span> STATUS_NO_MEMORY;
01464             }
01465 
01466         } <span class="keywordflow">else</span> {
01467 
01468             <span class="keywordflow">break</span>;
01469         }
01470     }
01471 
01472     ZwClose(<a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a>);
01473 
01474     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
01475 
01476         <span class="keywordflow">if</span> (KeyValueInformation-&gt;DataLength != 0) {
01477 
01478             PULONG DataPtr;
01479 
01480             <span class="comment">//</span>
01481             <span class="comment">// Return contents to the caller.</span>
01482             <span class="comment">//</span>
01483 
01484             DataPtr = (PULONG)
01485               ((PUCHAR)KeyValueInformation + KeyValueInformation-&gt;DataOffset);
01486             *Value = *DataPtr;
01487 
01488         } <span class="keywordflow">else</span> {
01489 
01490             <span class="comment">//</span>
01491             <span class="comment">// Treat as if no value was found</span>
01492             <span class="comment">//</span>
01493 
01494             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_OBJECT_NAME_NOT_FOUND;
01495         }
01496     }
01497 
01498     <span class="keywordflow">if</span> (KeyValueInformation != (PKEY_VALUE_FULL_INFORMATION)<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>) {
01499 
01500         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(KeyValueInformation);
01501     }
01502 
01503     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01504 }
01505 
01506 
01507 <span class="preprocessor">#if defined(TUNNELTEST) || defined(KEYVIEW)</span>
01508 <span class="preprocessor"></span>
01509 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01510 DumpTunnel (
01511     PTUNNEL Tunnel
01512     )
01513 {
01514     PRTL_SPLAY_LINKS SplayLinks, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a28">Ptr</a>;
01515     <a class="code" href="../../d1/d7/tunnel_8c.html#a12">PTUNNEL_NODE</a> Node;
01516     PLIST_ENTRY Link;
01517     ULONG Indent = 1, i;
01518     ULONG EntryCount = 0;
01519     BOOLEAN CountOff = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01520 
01521     <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n"</span>);
01522 
01523     <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"NumEntries = %d\n"</span>, Tunnel-&gt;NumEntries);
01524     <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"****** Cache Tree\n"</span>);
01525 
01526     SplayLinks = Tunnel-&gt;Cache;
01527 
01528     <span class="keywordflow">if</span> (SplayLinks == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01529 
01530         <span class="keywordflow">goto</span> end;
01531     }
01532 
01533     <span class="keywordflow">while</span> (RtlLeftChild(SplayLinks) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01534 
01535         SplayLinks = RtlLeftChild(SplayLinks);
01536         Indent++;
01537     }
01538 
01539     <span class="keywordflow">while</span> (SplayLinks) {
01540 
01541         Node = CONTAINING_RECORD( SplayLinks, <a class="code" href="../../d5/d1/structTUNNEL__NODE.html">TUNNEL_NODE</a>, CacheLinks );
01542 
01543         EntryCount++;
01544 
01545         DumpNode(Node, Indent);
01546 
01547         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a28">Ptr</a> = SplayLinks;
01548 
01549         <span class="comment">/*</span>
01550 <span class="comment">          first check to see if there is a right subtree to the input link</span>
01551 <span class="comment">          if there is then the real successor is the left most node in</span>
01552 <span class="comment">          the right subtree.  That is find and return P in the following diagram</span>
01553 <span class="comment"></span>
01554 <span class="comment">                      Links</span>
01555 <span class="comment">                         \</span>
01556 <span class="comment">                          .</span>
01557 <span class="comment">                         .</span>
01558 <span class="comment">                        .</span>
01559 <span class="comment">                       /</span>
01560 <span class="comment">                      P</span>
01561 <span class="comment">                       \</span>
01562 <span class="comment">        */</span>
01563 
01564         <span class="keywordflow">if</span> ((<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a28">Ptr</a> = RtlRightChild(SplayLinks)) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01565 
01566             Indent++;
01567             <span class="keywordflow">while</span> (RtlLeftChild(Ptr) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01568 
01569                 Indent++;
01570                 <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a28">Ptr</a> = RtlLeftChild(Ptr);
01571             }
01572 
01573             SplayLinks = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a28">Ptr</a>;
01574 
01575         } <span class="keywordflow">else</span> {
01576             <span class="comment">/*</span>
01577 <span class="comment">              we do not have a right child so check to see if have a parent and if</span>
01578 <span class="comment">              so find the first ancestor that we are a left decendent of. That</span>
01579 <span class="comment">              is find and return P in the following diagram</span>
01580 <span class="comment"></span>
01581 <span class="comment">                               P</span>
01582 <span class="comment">                              /</span>
01583 <span class="comment">                             .</span>
01584 <span class="comment">                              .</span>
01585 <span class="comment">                               .</span>
01586 <span class="comment">                              Links</span>
01587 <span class="comment">            */</span>
01588 
01589             <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a28">Ptr</a> = SplayLinks;
01590             <span class="keywordflow">while</span> (RtlIsRightChild(Ptr)) {
01591 
01592                 Indent--;
01593                 <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a28">Ptr</a> = RtlParent(Ptr);
01594             }
01595 
01596             <span class="keywordflow">if</span> (!RtlIsLeftChild(Ptr)) {
01597 
01598                 <span class="comment">//</span>
01599                 <span class="comment">//  we do not have a real successor so we simply return</span>
01600                 <span class="comment">//  NULL</span>
01601                 <span class="comment">//</span>
01602                 SplayLinks = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01603 
01604             } <span class="keywordflow">else</span> {
01605 
01606                 Indent--;
01607                 SplayLinks = RtlParent(Ptr);
01608             }
01609         }
01610     }
01611 
01612     end:
01613 
01614     <span class="keywordflow">if</span> (CountOff = (EntryCount != Tunnel-&gt;NumEntries)) {
01615 
01616         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"!!!!!!!!!! Splay Tree Count Mismatch (%d != %d)\n"</span>, EntryCount, Tunnel-&gt;NumEntries);
01617     }
01618 
01619     EntryCount = 0;
01620 
01621     <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"****** Timer Queue\n"</span>);
01622 
01623     <span class="keywordflow">for</span> (Link = Tunnel-&gt;TimerQueue.Flink;
01624          Link != &amp;Tunnel-&gt;TimerQueue;
01625          Link = Link-&gt;Flink) {
01626 
01627         Node = CONTAINING_RECORD( Link, <a class="code" href="../../d5/d1/structTUNNEL__NODE.html">TUNNEL_NODE</a>, ListLinks );
01628 
01629         EntryCount++;
01630 
01631         DumpNode(Node, 1);
01632     }
01633 
01634     <span class="keywordflow">if</span> (CountOff |= (EntryCount != Tunnel-&gt;NumEntries)) {
01635 
01636         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"!!!!!!!!!! Timer Queue Count Mismatch (%d != %d)\n"</span>, EntryCount, Tunnel-&gt;NumEntries);
01637     }
01638 
01639     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(!CountOff);
01640 
01641     <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"------------------------------------------------------------------\n"</span>);
01642 }
01643 
01644 <span class="preprocessor">#define MAXINDENT  128</span>
01645 <span class="preprocessor"></span><span class="preprocessor">#define INDENTSTEP 3</span>
01646 <span class="preprocessor"></span>
01647 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01648 DumpNode (
01649     PTUNNEL_NODE Node,
01650     ULONG Indent
01651     )
01652 {
01653     ULONG i;
01654     <a class="code" href="../../d1/d1/bench_8c.html#a16">CHAR</a>  SpaceBuf[MAXINDENT*INDENTSTEP + 1];
01655 
01656     Indent--;
01657     <span class="keywordflow">if</span> (Indent &gt; MAXINDENT) {
01658         Indent = MAXINDENT;
01659     }
01660 
01661     <span class="comment">//</span>
01662     <span class="comment">//  DbgPrint is really expensive to iteratively call to do the indenting,</span>
01663     <span class="comment">//  so just build up the indentation all at once on the stack.</span>
01664     <span class="comment">//</span>
01665 
01666     RtlFillMemory(SpaceBuf, Indent*INDENTSTEP, <span class="charliteral">' '</span>);
01667     SpaceBuf[Indent*INDENTSTEP] = <span class="charliteral">'\0'</span>;
01668 
01669     <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"%sNode 0x%x  CreateTime = %08x%08x, DirKey = %08x%08x, Flags = %d\n"</span>,
01670              SpaceBuf,
01671              Node,
01672              DblHex64(Node-&gt;CreateTime.QuadPart),
01673              DblHex64(Node-&gt;DirKey),
01674              Node-&gt;Flags );
01675 
01676     <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"%sShort = %wZ, Long = %wZ\n"</span>, SpaceBuf,
01677                                             &amp;Node-&gt;ShortName,
01678                                             &amp;Node-&gt;LongName );
01679 
01680     <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"%sP = %x, R = %x, L = %x\n"</span>, SpaceBuf,
01681                                            RtlParent(&amp;Node-&gt;CacheLinks),
01682                                            RtlRightChild(&amp;Node-&gt;CacheLinks),
01683                                            RtlLeftChild(&amp;Node-&gt;CacheLinks) );
01684 }
01685 <span class="preprocessor">#endif // TUNNELTEST</span>
01686 <span class="preprocessor"></span>
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:42:10 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
