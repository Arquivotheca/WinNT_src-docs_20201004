<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: wait.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>wait.c</h1><a href="../../d1/d7/wait_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1989  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    wait.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module implements the generic kernel wait routines. Functions</span>
00012 <span class="comment">    are provided to wait for a single object, wait for multiple objects,</span>
00013 <span class="comment">    wait for event pair low, wait for event pair high, release and wait</span>
00014 <span class="comment">    for semaphore, and to delay thread execution.</span>
00015 <span class="comment"></span>
00016 <span class="comment">    N.B. This module is written to be a fast as possible and not as small</span>
00017 <span class="comment">        as possible. Therefore some code sequences are duplicated to avoid</span>
00018 <span class="comment">        procedure calls. It would also be possible to combine wait for</span>
00019 <span class="comment">        single object into wait for multiple objects at the cost of some</span>
00020 <span class="comment">        speed. Since wait for single object is the most common case, the</span>
00021 <span class="comment">        two routines have been separated.</span>
00022 <span class="comment"></span>
00023 <span class="comment">Author:</span>
00024 <span class="comment"></span>
00025 <span class="comment">    David N. Cutler (davec) 23-Mar-89</span>
00026 <span class="comment"></span>
00027 <span class="comment">Environment:</span>
00028 <span class="comment"></span>
00029 <span class="comment">    Kernel mode only.</span>
00030 <span class="comment"></span>
00031 <span class="comment">Revision History:</span>
00032 <span class="comment"></span>
00033 <span class="comment">--*/</span>
00034 
00035 <span class="preprocessor">#include "<a class="code" href="../../d0/d0/ki_8h.html">ki.h</a>"</span>
00036 
00037 <span class="comment">//</span>
00038 <span class="comment">// Test for alertable condition.</span>
00039 <span class="comment">//</span>
00040 <span class="comment">// If alertable is TRUE and the thread is alerted for a processor</span>
00041 <span class="comment">// mode that is equal to the wait mode, then return immediately</span>
00042 <span class="comment">// with a wait completion status of ALERTED.</span>
00043 <span class="comment">//</span>
00044 <span class="comment">// Else if alertable is TRUE, the wait mode is user, and the user APC</span>
00045 <span class="comment">// queue is not empty, then set user APC pending, and return immediately</span>
00046 <span class="comment">// with a wait completion status of USER_APC.</span>
00047 <span class="comment">//</span>
00048 <span class="comment">// Else if alertable is TRUE and the thread is alerted for kernel</span>
00049 <span class="comment">// mode, then return immediately with a wait completion status of</span>
00050 <span class="comment">// ALERTED.</span>
00051 <span class="comment">//</span>
00052 <span class="comment">// Else if alertable is FALSE and the wait mode is user and there is a</span>
00053 <span class="comment">// user APC pending, then return immediately with a wait completion</span>
00054 <span class="comment">// status of USER_APC.</span>
00055 <span class="comment">//</span>
00056 
<a name="l00057"></a><a class="code" href="../../d1/d7/wait_8c.html#a0">00057</a> <span class="preprocessor">#define TestForAlertPending(Alertable) \</span>
00058 <span class="preprocessor">    if (Alertable) { \</span>
00059 <span class="preprocessor">        if (Thread-&gt;Alerted[WaitMode] != FALSE) { \</span>
00060 <span class="preprocessor">            Thread-&gt;Alerted[WaitMode] = FALSE; \</span>
00061 <span class="preprocessor">            WaitStatus = STATUS_ALERTED; \</span>
00062 <span class="preprocessor">            break; \</span>
00063 <span class="preprocessor">        } else if ((WaitMode != KernelMode) &amp;&amp; \</span>
00064 <span class="preprocessor">                  (IsListEmpty(&amp;Thread-&gt;ApcState.ApcListHead[UserMode])) == FALSE) { \</span>
00065 <span class="preprocessor">            Thread-&gt;ApcState.UserApcPending = TRUE; \</span>
00066 <span class="preprocessor">            WaitStatus = STATUS_USER_APC; \</span>
00067 <span class="preprocessor">            break; \</span>
00068 <span class="preprocessor">        } else if (Thread-&gt;Alerted[KernelMode] != FALSE) { \</span>
00069 <span class="preprocessor">            Thread-&gt;Alerted[KernelMode] = FALSE; \</span>
00070 <span class="preprocessor">            WaitStatus = STATUS_ALERTED; \</span>
00071 <span class="preprocessor">            break; \</span>
00072 <span class="preprocessor">        } \</span>
00073 <span class="preprocessor">    } else if ((WaitMode != KernelMode) &amp;&amp; (Thread-&gt;ApcState.UserApcPending)) { \</span>
00074 <span class="preprocessor">        WaitStatus = STATUS_USER_APC; \</span>
00075 <span class="preprocessor">        break; \</span>
00076 <span class="preprocessor">    }</span>
00077 <span class="preprocessor"></span>
00078 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00079"></a><a class="code" href="../../d1/d7/wait_8c.html#a1">00079</a> <a class="code" href="../../d1/d7/wait_8c.html#a1">KiAdjustQuantumThread</a> (
00080     IN <a class="code" href="../../d1/d8/struct__KTHREAD.html">PKTHREAD</a> Thread
00081     )
00082 
00083 <span class="comment">/*++</span>
00084 <span class="comment"></span>
00085 <span class="comment">Routine Description:</span>
00086 <span class="comment"></span>
00087 <span class="comment">    If the current thread is not a time critical or realtime thread, then</span>
00088 <span class="comment">    adjust its quantum in accordance with the adjustment that would have</span>
00089 <span class="comment">    occured if the thread had actually waited.</span>
00090 <span class="comment"></span>
00091 <span class="comment">Arguments:</span>
00092 <span class="comment"></span>
00093 <span class="comment">    Thread - Supplies a pointer to the current thread.</span>
00094 <span class="comment"></span>
00095 <span class="comment">Return Value:</span>
00096 <span class="comment"></span>
00097 <span class="comment">    None.</span>
00098 <span class="comment"></span>
00099 <span class="comment">--*/</span>
00100 
00101 {
00102     PKPRCB Prcb;
00103     <a class="code" href="../../d5/d7/struct__KPROCESS.html">PKPROCESS</a> Process;
00104     <a class="code" href="../../d1/d8/struct__KTHREAD.html">PKTHREAD</a> NewThread;
00105     SCHAR ThreadPriority;
00106 
00107     <span class="keywordflow">if</span> ((Thread-&gt;Priority &lt; LOW_REALTIME_PRIORITY) &amp;&amp;
00108         (Thread-&gt;BasePriority &lt; <a class="code" href="../../d0/d0/ki_8h.html#a4">TIME_CRITICAL_PRIORITY_BOUND</a>)) {
00109         Thread-&gt;Quantum -= <a class="code" href="../../d4/d9/ke_8h.html#a1">WAIT_QUANTUM_DECREMENT</a>;
00110         <span class="keywordflow">if</span> (Thread-&gt;Quantum &lt;= 0) {
00111             Process = Thread-&gt;ApcState.Process;
00112             Thread-&gt;Quantum = Process-&gt;<a class="code" href="../../d5/d7/struct__KPROCESS.html#o13">ThreadQuantum</a>;
00113             ThreadPriority = Thread-&gt;Priority - (Thread-&gt;PriorityDecrement + 1);
00114             <span class="keywordflow">if</span> (ThreadPriority &lt; Thread-&gt;BasePriority) {
00115                 ThreadPriority = Thread-&gt;BasePriority;
00116             }
00117 
00118             Thread-&gt;PriorityDecrement = 0;
00119             <span class="keywordflow">if</span> (ThreadPriority != Thread-&gt;Priority) {
00120                 <a class="code" href="../../d0/d2/thredsup_8c.html#a5">KiSetPriorityThread</a>(Thread, ThreadPriority);
00121 
00122             } <span class="keywordflow">else</span> {
00123                 Prcb = <a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a2">KeGetCurrentPrcb</a>();
00124                 <span class="keywordflow">if</span> (Prcb-&gt;NextThread == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00125                     NewThread = <a class="code" href="../../d0/d2/thredsup_8c.html#a2">KiFindReadyThread</a>(Thread-&gt;NextProcessor,
00126                                                   ThreadPriority);
00127                     <span class="keywordflow">if</span> (NewThread != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00128                         Prcb-&gt;NextThread = NewThread;
00129                         NewThread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o8">State</a> = <a class="code" href="../../d4/d9/ke_8h.html#a406a194">Standby</a>;
00130                     }
00131                 }
00132             }
00133         }
00134     }
00135 
00136     <span class="keywordflow">return</span>;
00137 }
00138 
00139 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00140"></a><a class="code" href="../../d1/d7/wait_8c.html#a2">00140</a> <a class="code" href="../../d1/d7/wait_8c.html#a2">KeDelayExecutionThread</a> (
00141     IN KPROCESSOR_MODE WaitMode,
00142     IN BOOLEAN Alertable,
00143     IN PLARGE_INTEGER Interval
00144     )
00145 
00146 <span class="comment">/*++</span>
00147 <span class="comment"></span>
00148 <span class="comment">Routine Description:</span>
00149 <span class="comment"></span>
00150 <span class="comment">    This function delays the execution of the current thread for the specified</span>
00151 <span class="comment">    interval of time.</span>
00152 <span class="comment"></span>
00153 <span class="comment">Arguments:</span>
00154 <span class="comment"></span>
00155 <span class="comment">    WaitMode  - Supplies the processor mode in which the delay is to occur.</span>
00156 <span class="comment"></span>
00157 <span class="comment">    Alertable - Supplies a boolean value that specifies whether the delay</span>
00158 <span class="comment">        is alertable.</span>
00159 <span class="comment"></span>
00160 <span class="comment">    Interval - Supplies a pointer to the absolute or relative time over which</span>
00161 <span class="comment">        the delay is to occur.</span>
00162 <span class="comment"></span>
00163 <span class="comment">Return Value:</span>
00164 <span class="comment"></span>
00165 <span class="comment">    The wait completion status. A value of STATUS_SUCCESS is returned if</span>
00166 <span class="comment">    the delay occurred. A value of STATUS_ALERTED is returned if the wait</span>
00167 <span class="comment">    was aborted to deliver an alert to the current thread. A value of</span>
00168 <span class="comment">    STATUS_USER_APC is returned if the wait was aborted to deliver a user</span>
00169 <span class="comment">    APC to the current thread.</span>
00170 <span class="comment"></span>
00171 <span class="comment">--*/</span>
00172 
00173 {
00174 
00175     LARGE_INTEGER DueTime;
00176     LARGE_INTEGER NewTime;
00177     PLARGE_INTEGER OriginalTime;
00178     PKPRCB Prcb;
00179     KPRIORITY Priority;
00180     <a class="code" href="../../d7/d7/struct__KQUEUE.html">PRKQUEUE</a> Queue;
00181     <a class="code" href="../../d1/d8/struct__KTHREAD.html">PRKTHREAD</a> Thread;
00182     <a class="code" href="../../d3/d8/struct__KTIMER.html">PRKTIMER</a> Timer;
00183     <a class="code" href="../../d4/d8/struct__KWAIT__BLOCK.html">PKWAIT_BLOCK</a> WaitBlock;
00184     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> WaitStatus;
00185 
00186     <span class="comment">//</span>
00187     <span class="comment">// If the dispatcher database lock is not already held, then set the wait</span>
00188     <span class="comment">// IRQL and lock the dispatcher database. Else set boolean wait variable</span>
00189     <span class="comment">// to FALSE.</span>
00190     <span class="comment">//</span>
00191 
00192     Thread = <a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a3">KeGetCurrentThread</a>();
00193     <span class="keywordflow">if</span> (Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o19">WaitNext</a>) {
00194         Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o19">WaitNext</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00195 
00196     } <span class="keywordflow">else</span> {
00197         <a class="code" href="../../d4/d9/ke_8h.html#a36">KiLockDispatcherDatabase</a>(&amp;Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o17">WaitIrql</a>);
00198     }
00199 
00200     <span class="comment">//</span>
00201     <span class="comment">// Start of delay loop.</span>
00202     <span class="comment">//</span>
00203     <span class="comment">// Note this loop is repeated if a kernel APC is delivered in the middle</span>
00204     <span class="comment">// of the delay or a kernel APC is pending on the first attempt through</span>
00205     <span class="comment">// the loop.</span>
00206     <span class="comment">//</span>
00207 
00208     OriginalTime = Interval;
00209     WaitBlock = &amp;Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o28">WaitBlock</a>[<a class="code" href="../../d4/d9/ke_8h.html#a9">TIMER_WAIT_BLOCK</a>];
00210     <span class="keywordflow">do</span> {
00211 
00212         <span class="comment">//</span>
00213         <span class="comment">// Test to determine if a kernel APC is pending.</span>
00214         <span class="comment">//</span>
00215         <span class="comment">// If a kernel APC is pending and the previous IRQL was less than</span>
00216         <span class="comment">// APC_LEVEL, then a kernel APC was queued by another processor just</span>
00217         <span class="comment">// after IRQL was raised to DISPATCH_LEVEL, but before the dispatcher</span>
00218         <span class="comment">// database was locked.</span>
00219         <span class="comment">//</span>
00220         <span class="comment">// N.B. that this can only happen in a multiprocessor system.</span>
00221         <span class="comment">//</span>
00222 
00223         <span class="keywordflow">if</span> (Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o14">ApcState</a>.<a class="code" href="../../d3/d5/struct__KAPC__STATE.html#o3">KernelApcPending</a> &amp;&amp; (Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o17">WaitIrql</a> &lt; <a class="code" href="../../d6/d7/halmips_8h.html#a52">APC_LEVEL</a>)) {
00224 
00225             <span class="comment">//</span>
00226             <span class="comment">// Unlock the dispatcher database and lower IRQL to its previous</span>
00227             <span class="comment">// value. An APC interrupt will immediately occur which will result</span>
00228             <span class="comment">// in the delivery of the kernel APC if possible.</span>
00229             <span class="comment">//</span>
00230 
00231             <a class="code" href="../../d0/d0/ki_8h.html#a84">KiUnlockDispatcherDatabase</a>(Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o17">WaitIrql</a>);
00232 
00233         } <span class="keywordflow">else</span> {
00234 
00235             <span class="comment">//</span>
00236             <span class="comment">// Test for alert pending.</span>
00237             <span class="comment">//</span>
00238 
00239             <a class="code" href="../../d1/d7/wait_8c.html#a0">TestForAlertPending</a>(Alertable);
00240 
00241             <span class="comment">//</span>
00242             <span class="comment">// Initialize wait block, insert wait block in timer wait list,</span>
00243             <span class="comment">// insert timer in timer queue, put thread in wait state, select</span>
00244             <span class="comment">// next thread to execute, and context switch to next thread.</span>
00245             <span class="comment">//</span>
00246             <span class="comment">// N.B. The timer wait block is initialized when the respective</span>
00247             <span class="comment">//      thread is initialized. Thus the constant fields are not</span>
00248             <span class="comment">//      reinitialized. These include the wait object, wait key,</span>
00249             <span class="comment">//      wait type, and the wait list entry link pointers.</span>
00250             <span class="comment">//</span>
00251 
00252             Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o21">WaitBlockList</a> = WaitBlock;
00253             Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o16">WaitStatus</a> = (<a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>)0;
00254             Timer = &amp;Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o39">Timer</a>;
00255             WaitBlock-&gt;<a class="code" href="../../d4/d8/struct__KWAIT__BLOCK.html#o3">NextWaitBlock</a> = WaitBlock;
00256             Timer-&gt;<a class="code" href="../../d3/d8/struct__KTIMER.html#o0">Header</a>.<a class="code" href="../../d1/d6/struct__DISPATCHER__HEADER.html#o5">WaitListHead</a>.Flink = &amp;WaitBlock-&gt;<a class="code" href="../../d4/d8/struct__KWAIT__BLOCK.html#o0">WaitListEntry</a>;
00257             Timer-&gt;<a class="code" href="../../d3/d8/struct__KTIMER.html#o0">Header</a>.<a class="code" href="../../d1/d6/struct__DISPATCHER__HEADER.html#o5">WaitListHead</a>.Blink = &amp;WaitBlock-&gt;<a class="code" href="../../d4/d8/struct__KWAIT__BLOCK.html#o0">WaitListEntry</a>;
00258 
00259             <span class="comment">//</span>
00260             <span class="comment">// If the timer is inserted in the timer tree, then place the</span>
00261             <span class="comment">// current thread in a wait state. Otherwise, attempt to force</span>
00262             <span class="comment">// the current thread to yield the processor to another thread.</span>
00263             <span class="comment">//</span>
00264 
00265             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d2/timersup_8c.html#a1">KiInsertTreeTimer</a>(Timer, *Interval) == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
00266 
00267                 <span class="comment">//</span>
00268                 <span class="comment">// If the thread is not a realtime thread, then drop the</span>
00269                 <span class="comment">// thread priority to the base priority.</span>
00270                 <span class="comment">//</span>
00271 
00272                 Prcb = <a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a2">KeGetCurrentPrcb</a>();
00273                 Priority = Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o13">Priority</a>;
00274                 <span class="keywordflow">if</span> (Priority &lt; LOW_REALTIME_PRIORITY) {
00275                     <span class="keywordflow">if</span> (Priority != Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o24">BasePriority</a>) {
00276                         Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o26">PriorityDecrement</a> = 0;
00277                         <a class="code" href="../../d0/d2/thredsup_8c.html#a5">KiSetPriorityThread</a>(Thread, Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o24">BasePriority</a>);
00278                     }
00279                 }
00280 
00281                 <span class="comment">//</span>
00282                 <span class="comment">// If a new thread has not been selected, the attempt to round</span>
00283                 <span class="comment">// robin the thread with other threads at the same priority.</span>
00284                 <span class="comment">//</span>
00285 
00286                 <span class="keywordflow">if</span> (Prcb-&gt;NextThread == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00287                     Prcb-&gt;NextThread = <a class="code" href="../../d0/d2/thredsup_8c.html#a2">KiFindReadyThread</a>(Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o45">NextProcessor</a>,
00288                                                          Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o13">Priority</a>);
00289                 }
00290 
00291                 <span class="comment">//</span>
00292                 <span class="comment">// If a new thread has been selected for execution, then</span>
00293                 <span class="comment">// switch immediately to the selected thread.</span>
00294                 <span class="comment">//</span>
00295 
00296                 <span class="keywordflow">if</span> (Prcb-&gt;NextThread != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00297 
00298                     <span class="comment">//</span>
00299                     <span class="comment">// Give the current thread a new qunatum and switch</span>
00300                     <span class="comment">// context to selected thread.</span>
00301                     <span class="comment">//</span>
00302                     <span class="comment">// N.B. Control is returned at the original IRQL.</span>
00303                     <span class="comment">//</span>
00304 
00305                     Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o42">Preempted</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00306                     Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o27">Quantum</a> = Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o14">ApcState</a>.<a class="code" href="../../d3/d5/struct__KAPC__STATE.html#o1">Process</a>-&gt;<a class="code" href="../../d5/d7/struct__KPROCESS.html#o13">ThreadQuantum</a>;
00307 
00308                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o17">WaitIrql</a> &lt;= <a class="code" href="../../d6/d7/halmips_8h.html#a53">DISPATCH_LEVEL</a>);
00309 
00310                     <a class="code" href="../../d0/d2/thredsup_8c.html#a3">KiReadyThread</a>(Thread);
00311                     WaitStatus = (<a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>)<a class="code" href="../../d0/d0/ki_8h.html#a138">KiSwapThread</a>();
00312                     <span class="keywordflow">goto</span> WaitComplete;
00313 
00314                 } <span class="keywordflow">else</span> {
00315                     WaitStatus = (<a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>)STATUS_SUCCESS;
00316                     <span class="keywordflow">break</span>;
00317                 }
00318             }
00319 
00320             DueTime.QuadPart = Timer-&gt;<a class="code" href="../../d3/d8/struct__KTIMER.html#o1">DueTime</a>.QuadPart;
00321 
00322             <span class="comment">//</span>
00323             <span class="comment">// If the current thread is processing a queue entry, then attempt</span>
00324             <span class="comment">// to activate another thread that is blocked on the queue object.</span>
00325             <span class="comment">//</span>
00326 
00327             Queue = Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o37">Queue</a>;
00328             <span class="keywordflow">if</span> (Queue != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00329                 <a class="code" href="../../d8/d3/queueobj_8c.html#a7">KiActivateWaiterQueue</a>(Queue);
00330             }
00331 
00332             <span class="comment">//</span>
00333             <span class="comment">// Set the thread wait parameters, set the thread dispatcher state</span>
00334             <span class="comment">// to Waiting, and insert the thread in the wait list.</span>
00335             <span class="comment">//</span>
00336 
00337             Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o57">Alertable</a> = Alertable;
00338             Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o18">WaitMode</a> = WaitMode;
00339             Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o20">WaitReason</a> = <a class="code" href="../../d4/d9/ke_8h.html#a407a202">DelayExecution</a>;
00340             Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o23">WaitTime</a>= KiQueryLowTickCount();
00341             Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o8">State</a> = <a class="code" href="../../d4/d9/ke_8h.html#a406a196">Waiting</a>;
00342             <a class="code" href="../../d0/d0/ki_8h.html#a15">KiInsertWaitList</a>(WaitMode, Thread);
00343 
00344             <span class="comment">//</span>
00345             <span class="comment">// Switch context to selected thread.</span>
00346             <span class="comment">//</span>
00347             <span class="comment">// N.B. Control is returned at the original IRQL.</span>
00348             <span class="comment">//</span>
00349 
00350             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o17">WaitIrql</a> &lt;= <a class="code" href="../../d6/d7/halmips_8h.html#a53">DISPATCH_LEVEL</a>);
00351 
00352             WaitStatus = (<a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>)<a class="code" href="../../d0/d0/ki_8h.html#a138">KiSwapThread</a>();
00353 
00354             <span class="comment">//</span>
00355             <span class="comment">// If the thread was not awakened to deliver a kernel mode APC,</span>
00356             <span class="comment">// then return the wait status.</span>
00357             <span class="comment">//</span>
00358 
00359         WaitComplete:
00360             <span class="keywordflow">if</span> (WaitStatus != STATUS_KERNEL_APC) {
00361                 <span class="keywordflow">if</span> (WaitStatus == STATUS_TIMEOUT) {
00362                     WaitStatus = STATUS_SUCCESS;
00363                 }
00364 
00365                 <span class="keywordflow">return</span> WaitStatus;
00366             }
00367 
00368             <span class="comment">//</span>
00369             <span class="comment">// Reduce the time remaining before the time delay expires.</span>
00370             <span class="comment">//</span>
00371 
00372             Interval = <a class="code" href="../../d1/d7/wait_8c.html#a6">KiComputeWaitInterval</a>(OriginalTime,
00373                                              &amp;DueTime,
00374                                              &amp;NewTime);
00375         }
00376 
00377         <span class="comment">//</span>
00378         <span class="comment">// Raise IRQL to DISPATCH_LEVEL and lock the dispatcher database.</span>
00379         <span class="comment">//</span>
00380 
00381         <a class="code" href="../../d4/d9/ke_8h.html#a36">KiLockDispatcherDatabase</a>(&amp;Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o17">WaitIrql</a>);
00382     } <span class="keywordflow">while</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
00383 
00384     <span class="comment">//</span>
00385     <span class="comment">// The thread is alerted or a user APC should be delivered. Unlock the</span>
00386     <span class="comment">// dispatcher database, lower IRQL to its previous value, and return the</span>
00387     <span class="comment">// wait status.</span>
00388     <span class="comment">//</span>
00389 
00390     <a class="code" href="../../d0/d0/ki_8h.html#a84">KiUnlockDispatcherDatabase</a>(Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o17">WaitIrql</a>);
00391     <span class="keywordflow">return</span> WaitStatus;
00392 }
00393 
00394 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00395"></a><a class="code" href="../../d1/d7/wait_8c.html#a3">00395</a> <a class="code" href="../../d1/d7/wait_8c.html#a3">KeWaitForMultipleObjects</a> (
00396     IN ULONG Count,
00397     IN PVOID Object[],
00398     IN WAIT_TYPE WaitType,
00399     IN <a class="code" href="../../d4/d9/ke_8h.html#a53">KWAIT_REASON</a> WaitReason,
00400     IN KPROCESSOR_MODE WaitMode,
00401     IN BOOLEAN Alertable,
00402     IN PLARGE_INTEGER Timeout OPTIONAL,
00403     IN <a class="code" href="../../d4/d8/struct__KWAIT__BLOCK.html">PKWAIT_BLOCK</a> WaitBlockArray OPTIONAL
00404     )
00405 
00406 <span class="comment">/*++</span>
00407 <span class="comment"></span>
00408 <span class="comment">Routine Description:</span>
00409 <span class="comment"></span>
00410 <span class="comment">    This function waits until the specified objects attain a state of</span>
00411 <span class="comment">    Signaled. The wait can be specified to wait until all of the objects</span>
00412 <span class="comment">    attain a state of Signaled or until one of the objects attains a state</span>
00413 <span class="comment">    of Signaled. An optional timeout can also be specified. If a timeout</span>
00414 <span class="comment">    is not specified, then the wait will not be satisfied until the objects</span>
00415 <span class="comment">    attain a state of Signaled. If a timeout is specified, and the objects</span>
00416 <span class="comment">    have not attained a state of Signaled when the timeout expires, then</span>
00417 <span class="comment">    the wait is automatically satisfied. If an explicit timeout value of</span>
00418 <span class="comment">    zero is specified, then no wait will occur if the wait cannot be satisfied</span>
00419 <span class="comment">    immediately. The wait can also be specified as alertable.</span>
00420 <span class="comment"></span>
00421 <span class="comment">Arguments:</span>
00422 <span class="comment"></span>
00423 <span class="comment">    Count - Supplies a count of the number of objects that are to be waited</span>
00424 <span class="comment">        on.</span>
00425 <span class="comment"></span>
00426 <span class="comment">    Object[] - Supplies an array of pointers to dispatcher objects.</span>
00427 <span class="comment"></span>
00428 <span class="comment">    WaitType - Supplies the type of wait to perform (WaitAll, WaitAny).</span>
00429 <span class="comment"></span>
00430 <span class="comment">    WaitReason - Supplies the reason for the wait.</span>
00431 <span class="comment"></span>
00432 <span class="comment">    WaitMode  - Supplies the processor mode in which the wait is to occur.</span>
00433 <span class="comment"></span>
00434 <span class="comment">    Alertable - Supplies a boolean value that specifies whether the wait is</span>
00435 <span class="comment">        alertable.</span>
00436 <span class="comment"></span>
00437 <span class="comment">    Timeout - Supplies a pointer to an optional absolute of relative time over</span>
00438 <span class="comment">        which the wait is to occur.</span>
00439 <span class="comment"></span>
00440 <span class="comment">    WaitBlockArray - Supplies an optional pointer to an array of wait blocks</span>
00441 <span class="comment">        that are to used to describe the wait operation.</span>
00442 <span class="comment"></span>
00443 <span class="comment">Return Value:</span>
00444 <span class="comment"></span>
00445 <span class="comment">    The wait completion status. A value of STATUS_TIMEOUT is returned if a</span>
00446 <span class="comment">    timeout occurred. The index of the object (zero based) in the object</span>
00447 <span class="comment">    pointer array is returned if an object satisfied the wait. A value of</span>
00448 <span class="comment">    STATUS_ALERTED is returned if the wait was aborted to deliver an alert</span>
00449 <span class="comment">    to the current thread. A value of STATUS_USER_APC is returned if the</span>
00450 <span class="comment">    wait was aborted to deliver a user APC to the current thread.</span>
00451 <span class="comment"></span>
00452 <span class="comment">--*/</span>
00453 
00454 {
00455 
00456     LARGE_INTEGER DueTime;
00457     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
00458     LARGE_INTEGER NewTime;
00459     <a class="code" href="../../d1/d8/struct__KTHREAD.html">PRKTHREAD</a> NextThread;
00460     <a class="code" href="../../d3/d7/struct__KMUTANT.html">PKMUTANT</a> Objectx;
00461     PLARGE_INTEGER OriginalTime;
00462     <a class="code" href="../../d7/d7/struct__KQUEUE.html">PRKQUEUE</a> Queue;
00463     <a class="code" href="../../d1/d8/struct__KTHREAD.html">PRKTHREAD</a> Thread;
00464     <a class="code" href="../../d3/d8/struct__KTIMER.html">PRKTIMER</a> Timer;
00465     <a class="code" href="../../d4/d8/struct__KWAIT__BLOCK.html">PRKWAIT_BLOCK</a> WaitBlock;
00466     BOOLEAN WaitSatisfied;
00467     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> WaitStatus;
00468     <a class="code" href="../../d4/d8/struct__KWAIT__BLOCK.html">PKWAIT_BLOCK</a> WaitTimer;
00469 
00470     <span class="comment">//</span>
00471     <span class="comment">// If the dispatcher database lock is not already held, then set the wait</span>
00472     <span class="comment">// IRQL and lock the dispatcher database. Else set boolean wait variable</span>
00473     <span class="comment">// to FALSE.</span>
00474     <span class="comment">//</span>
00475 
00476     Thread = <a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a3">KeGetCurrentThread</a>();
00477     <span class="keywordflow">if</span> (Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o19">WaitNext</a>) {
00478         Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o19">WaitNext</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00479 
00480     } <span class="keywordflow">else</span> {
00481         <a class="code" href="../../d4/d9/ke_8h.html#a36">KiLockDispatcherDatabase</a>(&amp;Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o17">WaitIrql</a>);
00482     }
00483 
00484     <span class="comment">//</span>
00485     <span class="comment">// If a wait block array has been specified, then the maximum number of</span>
00486     <span class="comment">// objects that can be waited on is specified by MAXIMUM_WAIT_OBJECTS.</span>
00487     <span class="comment">// Otherwise the builtin wait blocks in the thread object are used and</span>
00488     <span class="comment">// the maximum number of objects that can be waited on is specified by</span>
00489     <span class="comment">// THREAD_WAIT_OBJECTS. If the specified number of objects is not within</span>
00490     <span class="comment">// limits, then bug check.</span>
00491     <span class="comment">//</span>
00492 
00493     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(WaitBlockArray)) {
00494         <span class="keywordflow">if</span> (<a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> &gt; MAXIMUM_WAIT_OBJECTS) {
00495             <a class="code" href="../../d9/d1/bugcheck_8c.html#a13">KeBugCheck</a>(MAXIMUM_WAIT_OBJECTS_EXCEEDED);
00496         }
00497 
00498     } <span class="keywordflow">else</span> {
00499         <span class="keywordflow">if</span> (<a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> &gt; <a class="code" href="../../d4/d9/ke_8h.html#a6">THREAD_WAIT_OBJECTS</a>) {
00500             <a class="code" href="../../d9/d1/bugcheck_8c.html#a13">KeBugCheck</a>(MAXIMUM_WAIT_OBJECTS_EXCEEDED);
00501         }
00502 
00503         WaitBlockArray = &amp;Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o28">WaitBlock</a>[0];
00504     }
00505 
00506     <span class="comment">//</span>
00507     <span class="comment">// Start of wait loop.</span>
00508     <span class="comment">//</span>
00509     <span class="comment">// Note this loop is repeated if a kernel APC is delivered in the middle</span>
00510     <span class="comment">// of the wait or a kernel APC is pending on the first attempt through</span>
00511     <span class="comment">// the loop.</span>
00512     <span class="comment">//</span>
00513 
00514     OriginalTime = Timeout;
00515     <span class="keywordflow">do</span> {
00516 
00517         <span class="comment">//</span>
00518         <span class="comment">// Set address of wait block list in thread object.</span>
00519         <span class="comment">//</span>
00520 
00521         Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o21">WaitBlockList</a> = WaitBlockArray;
00522 
00523         <span class="comment">//</span>
00524         <span class="comment">// Test to determine if a kernel APC is pending.</span>
00525         <span class="comment">//</span>
00526         <span class="comment">// If a kernel APC is pending and the previous IRQL was less than</span>
00527         <span class="comment">// APC_LEVEL, then a kernel APC was queued by another processor just</span>
00528         <span class="comment">// after IRQL was raised to DISPATCH_LEVEL, but before the dispatcher</span>
00529         <span class="comment">// database was locked.</span>
00530         <span class="comment">//</span>
00531         <span class="comment">// N.B. that this can only happen in a multiprocessor system.</span>
00532         <span class="comment">//</span>
00533 
00534         <span class="keywordflow">if</span> (Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o14">ApcState</a>.<a class="code" href="../../d3/d5/struct__KAPC__STATE.html#o3">KernelApcPending</a> &amp;&amp; (Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o17">WaitIrql</a> &lt; <a class="code" href="../../d6/d7/halmips_8h.html#a52">APC_LEVEL</a>)) {
00535 
00536             <span class="comment">//</span>
00537             <span class="comment">// Unlock the dispatcher database and lower IRQL to its previous</span>
00538             <span class="comment">// value. An APC interrupt will immediately occur which will result</span>
00539             <span class="comment">// in the delivery of the kernel APC if possible.</span>
00540             <span class="comment">//</span>
00541 
00542             <a class="code" href="../../d0/d0/ki_8h.html#a84">KiUnlockDispatcherDatabase</a>(Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o17">WaitIrql</a>);
00543 
00544         } <span class="keywordflow">else</span> {
00545 
00546             <span class="comment">//</span>
00547             <span class="comment">// Construct wait blocks and check to determine if the wait is</span>
00548             <span class="comment">// already satisfied. If the wait is satisfied, then perform</span>
00549             <span class="comment">// wait completion and return. Else put current thread in a wait</span>
00550             <span class="comment">// state if an explicit timeout value of zero is not specified.</span>
00551             <span class="comment">//</span>
00552 
00553             Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o16">WaitStatus</a> = (<a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>)0;
00554             WaitSatisfied = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00555             <span class="keywordflow">for</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = 0; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &lt; <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a>; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> += 1) {
00556 
00557                 <span class="comment">//</span>
00558                 <span class="comment">// Test if wait can be satisfied immediately.</span>
00559                 <span class="comment">//</span>
00560 
00561                 Objectx = (<a class="code" href="../../d3/d7/struct__KMUTANT.html">PKMUTANT</a>)Object[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>];
00562 
00563                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(Objectx-&gt;<a class="code" href="../../d3/d7/struct__KMUTANT.html#o0">Header</a>.<a class="code" href="../../d1/d6/struct__DISPATCHER__HEADER.html#o0">Type</a> != <a class="code" href="../../d4/d9/ke_8h.html#a402a161">QueueObject</a>);
00564 
00565                 <span class="keywordflow">if</span> (WaitType == WaitAny) {
00566 
00567                     <span class="comment">//</span>
00568                     <span class="comment">// If the object is a mutant object and the mutant object</span>
00569                     <span class="comment">// has been recursively acquired MINLONG times, then raise</span>
00570                     <span class="comment">// an exception. Otherwise if the signal state of the mutant</span>
00571                     <span class="comment">// object is greater than zero, or the current thread is</span>
00572                     <span class="comment">// the owner of the mutant object, then satisfy the wait.</span>
00573                     <span class="comment">//</span>
00574 
00575                     <span class="keywordflow">if</span> (Objectx-&gt;<a class="code" href="../../d3/d7/struct__KMUTANT.html#o0">Header</a>.<a class="code" href="../../d1/d6/struct__DISPATCHER__HEADER.html#o0">Type</a> == <a class="code" href="../../d4/d9/ke_8h.html#a402a159">MutantObject</a>) {
00576                         <span class="keywordflow">if</span> ((Objectx-&gt;<a class="code" href="../../d3/d7/struct__KMUTANT.html#o0">Header</a>.<a class="code" href="../../d1/d6/struct__DISPATCHER__HEADER.html#o4">SignalState</a> &gt; 0) ||
00577                             (Thread == Objectx-&gt;<a class="code" href="../../d3/d7/struct__KMUTANT.html#o2">OwnerThread</a>)) {
00578                             <span class="keywordflow">if</span> (Objectx-&gt;<a class="code" href="../../d3/d7/struct__KMUTANT.html#o0">Header</a>.<a class="code" href="../../d1/d6/struct__DISPATCHER__HEADER.html#o4">SignalState</a> != MINLONG) {
00579                                 <a class="code" href="../../d0/d0/ki_8h.html#a26">KiWaitSatisfyMutant</a>(Objectx, Thread);
00580                                 WaitStatus = (<a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>)(<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> | Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o16">WaitStatus</a>);
00581                                 <span class="keywordflow">goto</span> NoWait;
00582 
00583                             } <span class="keywordflow">else</span> {
00584                                 <a class="code" href="../../d0/d0/ki_8h.html#a84">KiUnlockDispatcherDatabase</a>(Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o17">WaitIrql</a>);
00585                                 <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>(STATUS_MUTANT_LIMIT_EXCEEDED);
00586                             }
00587                         }
00588 
00589                     <span class="comment">//</span>
00590                     <span class="comment">// If the signal state is greater than zero, then satisfy</span>
00591                     <span class="comment">// the wait.</span>
00592                     <span class="comment">//</span>
00593 
00594                     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Objectx-&gt;<a class="code" href="../../d3/d7/struct__KMUTANT.html#o0">Header</a>.<a class="code" href="../../d1/d6/struct__DISPATCHER__HEADER.html#o4">SignalState</a> &gt; 0) {
00595                         <a class="code" href="../../d0/d0/ki_8h.html#a27">KiWaitSatisfyOther</a>(Objectx);
00596                         WaitStatus = (<a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>)(<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>);
00597                         <span class="keywordflow">goto</span> NoWait;
00598                     }
00599 
00600                 } <span class="keywordflow">else</span> {
00601 
00602                     <span class="comment">//</span>
00603                     <span class="comment">// If the object is a mutant object and the mutant object</span>
00604                     <span class="comment">// has been recursively acquired MAXLONG times, then raise</span>
00605                     <span class="comment">// an exception. Otherwise if the signal state of the mutant</span>
00606                     <span class="comment">// object is less than or equal to zero and the current</span>
00607                     <span class="comment">// thread is not the  owner of the mutant object, then the</span>
00608                     <span class="comment">// wait cannot be satisfied.</span>
00609                     <span class="comment">//</span>
00610 
00611                     <span class="keywordflow">if</span> (Objectx-&gt;<a class="code" href="../../d3/d7/struct__KMUTANT.html#o0">Header</a>.<a class="code" href="../../d1/d6/struct__DISPATCHER__HEADER.html#o0">Type</a> == <a class="code" href="../../d4/d9/ke_8h.html#a402a159">MutantObject</a>) {
00612                         <span class="keywordflow">if</span> ((Thread == Objectx-&gt;<a class="code" href="../../d3/d7/struct__KMUTANT.html#o2">OwnerThread</a>) &amp;&amp;
00613                             (Objectx-&gt;<a class="code" href="../../d3/d7/struct__KMUTANT.html#o0">Header</a>.<a class="code" href="../../d1/d6/struct__DISPATCHER__HEADER.html#o4">SignalState</a> == MINLONG)) {
00614                             <a class="code" href="../../d0/d0/ki_8h.html#a84">KiUnlockDispatcherDatabase</a>(Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o17">WaitIrql</a>);
00615                             <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>(STATUS_MUTANT_LIMIT_EXCEEDED);
00616 
00617                         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((Objectx-&gt;<a class="code" href="../../d3/d7/struct__KMUTANT.html#o0">Header</a>.<a class="code" href="../../d1/d6/struct__DISPATCHER__HEADER.html#o4">SignalState</a> &lt;= 0) &amp;&amp;
00618                                   (Thread != Objectx-&gt;<a class="code" href="../../d3/d7/struct__KMUTANT.html#o2">OwnerThread</a>)) {
00619                             WaitSatisfied = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00620                         }
00621 
00622                     <span class="comment">//</span>
00623                     <span class="comment">// If the signal state is less than or equal to zero, then</span>
00624                     <span class="comment">// the wait cannot be satisfied.</span>
00625                     <span class="comment">//</span>
00626 
00627                     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Objectx-&gt;<a class="code" href="../../d3/d7/struct__KMUTANT.html#o0">Header</a>.<a class="code" href="../../d1/d6/struct__DISPATCHER__HEADER.html#o4">SignalState</a> &lt;= 0) {
00628                         WaitSatisfied = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00629                     }
00630                 }
00631 
00632                 <span class="comment">//</span>
00633                 <span class="comment">// Construct wait block for the current object.</span>
00634                 <span class="comment">//</span>
00635 
00636                 WaitBlock = &amp;WaitBlockArray[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>];
00637                 WaitBlock-&gt;<a class="code" href="../../d4/d8/struct__KWAIT__BLOCK.html#o2">Object</a> = (PVOID)Objectx;
00638                 WaitBlock-&gt;<a class="code" href="../../d4/d8/struct__KWAIT__BLOCK.html#o4">WaitKey</a> = (CSHORT)(<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>);
00639                 WaitBlock-&gt;<a class="code" href="../../d4/d8/struct__KWAIT__BLOCK.html#o5">WaitType</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)WaitType;
00640                 WaitBlock-&gt;<a class="code" href="../../d4/d8/struct__KWAIT__BLOCK.html#o1">Thread</a> = Thread;
00641                 WaitBlock-&gt;<a class="code" href="../../d4/d8/struct__KWAIT__BLOCK.html#o3">NextWaitBlock</a> = &amp;WaitBlockArray[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> + 1];
00642             }
00643 
00644             <span class="comment">//</span>
00645             <span class="comment">// If the wait type is wait all, then check to determine if the</span>
00646             <span class="comment">// wait can be satisfied immediately.</span>
00647             <span class="comment">//</span>
00648 
00649             <span class="keywordflow">if</span> ((WaitType == WaitAll) &amp;&amp; (WaitSatisfied)) {
00650                 WaitBlock-&gt;<a class="code" href="../../d4/d8/struct__KWAIT__BLOCK.html#o3">NextWaitBlock</a> = &amp;WaitBlockArray[0];
00651                 <a class="code" href="../../d2/d7/waitsup_8c.html#a2">KiWaitSatisfyAll</a>(WaitBlock);
00652                 WaitStatus = (<a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>)Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o16">WaitStatus</a>;
00653                 <span class="keywordflow">goto</span> NoWait;
00654             }
00655 
00656             <span class="comment">//</span>
00657             <span class="comment">// Test for alert pending.</span>
00658             <span class="comment">//</span>
00659 
00660             <a class="code" href="../../d1/d7/wait_8c.html#a0">TestForAlertPending</a>(Alertable);
00661 
00662             <span class="comment">//</span>
00663             <span class="comment">// The wait cannot be satisifed immediately. Check to determine if</span>
00664             <span class="comment">// a timeout value is specified.</span>
00665             <span class="comment">//</span>
00666 
00667             <span class="keywordflow">if</span> (ARGUMENT_PRESENT(Timeout)) {
00668 
00669                 <span class="comment">//</span>
00670                 <span class="comment">// If the timeout value is zero, then return immediately without</span>
00671                 <span class="comment">// waiting.</span>
00672                 <span class="comment">//</span>
00673 
00674                 <span class="keywordflow">if</span> (!(Timeout-&gt;LowPart | Timeout-&gt;HighPart)) {
00675                     WaitStatus = (<a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>)(STATUS_TIMEOUT);
00676                     <span class="keywordflow">goto</span> NoWait;
00677                 }
00678 
00679                 <span class="comment">//</span>
00680                 <span class="comment">// Initialize a wait block for the thread specific timer,</span>
00681                 <span class="comment">// initialize timer wait list head, insert the timer in the</span>
00682                 <span class="comment">// timer tree, and increment the number of wait objects.</span>
00683                 <span class="comment">//</span>
00684                 <span class="comment">// N.B. The timer wait block is initialized when the respective</span>
00685                 <span class="comment">//      thread is initialized. Thus the constant fields are not</span>
00686                 <span class="comment">//      reinitialized. These include the wait object, wait key,</span>
00687                 <span class="comment">//      wait type, and the wait list entry link pointers.</span>
00688                 <span class="comment">//</span>
00689 
00690                 WaitTimer = &amp;Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o28">WaitBlock</a>[<a class="code" href="../../d4/d9/ke_8h.html#a9">TIMER_WAIT_BLOCK</a>];
00691                 WaitBlock-&gt;<a class="code" href="../../d4/d8/struct__KWAIT__BLOCK.html#o3">NextWaitBlock</a> = WaitTimer;
00692                 WaitBlock = WaitTimer;
00693                 Timer = &amp;Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o39">Timer</a>;
00694                 InitializeListHead(&amp;Timer-&gt;<a class="code" href="../../d3/d8/struct__KTIMER.html#o0">Header</a>.<a class="code" href="../../d1/d6/struct__DISPATCHER__HEADER.html#o5">WaitListHead</a>);
00695                 <span class="keywordflow">if</span> (<a class="code" href="../../d5/d2/timersup_8c.html#a1">KiInsertTreeTimer</a>(Timer, *Timeout) == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
00696                     WaitStatus = (<a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>)STATUS_TIMEOUT;
00697                     <span class="keywordflow">goto</span> NoWait;
00698                 }
00699 
00700                 DueTime.QuadPart = Timer-&gt;<a class="code" href="../../d3/d8/struct__KTIMER.html#o1">DueTime</a>.QuadPart;
00701             }
00702 
00703             <span class="comment">//</span>
00704             <span class="comment">// Close up the circular list of wait control blocks.</span>
00705             <span class="comment">//</span>
00706 
00707             WaitBlock-&gt;<a class="code" href="../../d4/d8/struct__KWAIT__BLOCK.html#o3">NextWaitBlock</a> = &amp;WaitBlockArray[0];
00708 
00709             <span class="comment">//</span>
00710             <span class="comment">// Insert wait blocks in object wait lists.</span>
00711             <span class="comment">//</span>
00712 
00713             WaitBlock = &amp;WaitBlockArray[0];
00714             <span class="keywordflow">do</span> {
00715                 Objectx = (<a class="code" href="../../d3/d7/struct__KMUTANT.html">PKMUTANT</a>)WaitBlock-&gt;<a class="code" href="../../d4/d8/struct__KWAIT__BLOCK.html#o2">Object</a>;
00716                 InsertTailList(&amp;Objectx-&gt;<a class="code" href="../../d3/d7/struct__KMUTANT.html#o0">Header</a>.<a class="code" href="../../d1/d6/struct__DISPATCHER__HEADER.html#o5">WaitListHead</a>, &amp;WaitBlock-&gt;<a class="code" href="../../d4/d8/struct__KWAIT__BLOCK.html#o0">WaitListEntry</a>);
00717                 WaitBlock = WaitBlock-&gt;<a class="code" href="../../d4/d8/struct__KWAIT__BLOCK.html#o3">NextWaitBlock</a>;
00718             } <span class="keywordflow">while</span> (WaitBlock != &amp;WaitBlockArray[0]);
00719 
00720             <span class="comment">//</span>
00721             <span class="comment">// If the current thread is processing a queue entry, then attempt</span>
00722             <span class="comment">// to activate another thread that is blocked on the queue object.</span>
00723             <span class="comment">//</span>
00724 
00725             Queue = Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o37">Queue</a>;
00726             <span class="keywordflow">if</span> (Queue != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00727                 <a class="code" href="../../d8/d3/queueobj_8c.html#a7">KiActivateWaiterQueue</a>(Queue);
00728             }
00729 
00730             <span class="comment">//</span>
00731             <span class="comment">// Set the thread wait parameters, set the thread dispatcher state</span>
00732             <span class="comment">// to Waiting, and insert the thread in the wait list.</span>
00733             <span class="comment">//</span>
00734 
00735             Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o57">Alertable</a> = Alertable;
00736             Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o18">WaitMode</a> = WaitMode;
00737             Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o20">WaitReason</a> = (UCHAR)WaitReason;
00738             Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o23">WaitTime</a>= KiQueryLowTickCount();
00739             Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o8">State</a> = <a class="code" href="../../d4/d9/ke_8h.html#a406a196">Waiting</a>;
00740             <a class="code" href="../../d0/d0/ki_8h.html#a15">KiInsertWaitList</a>(WaitMode, Thread);
00741 
00742             <span class="comment">//</span>
00743             <span class="comment">// Switch context to selected thread.</span>
00744             <span class="comment">//</span>
00745             <span class="comment">// Control is returned at the original IRQL.</span>
00746             <span class="comment">//</span>
00747 
00748             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o17">WaitIrql</a> &lt;= <a class="code" href="../../d6/d7/halmips_8h.html#a53">DISPATCH_LEVEL</a>);
00749 
00750             WaitStatus = (<a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>)<a class="code" href="../../d0/d0/ki_8h.html#a138">KiSwapThread</a>();
00751 
00752             <span class="comment">//</span>
00753             <span class="comment">// If the thread was not awakened to deliver a kernel mode APC,</span>
00754             <span class="comment">// then the wait status.</span>
00755             <span class="comment">//</span>
00756 
00757             <span class="keywordflow">if</span> (WaitStatus != STATUS_KERNEL_APC) {
00758                 <span class="keywordflow">return</span> WaitStatus;
00759             }
00760 
00761             <span class="keywordflow">if</span> (ARGUMENT_PRESENT(Timeout)) {
00762 
00763                 <span class="comment">//</span>
00764                 <span class="comment">// Reduce the amount of time remaining before timeout occurs.</span>
00765                 <span class="comment">//</span>
00766 
00767                 Timeout = <a class="code" href="../../d1/d7/wait_8c.html#a6">KiComputeWaitInterval</a>(OriginalTime,
00768                                                 &amp;DueTime,
00769                                                 &amp;NewTime);
00770             }
00771         }
00772 
00773         <span class="comment">//</span>
00774         <span class="comment">// Raise IRQL to DISPATCH_LEVEL and lock the dispatcher database.</span>
00775         <span class="comment">//</span>
00776 
00777         <a class="code" href="../../d4/d9/ke_8h.html#a36">KiLockDispatcherDatabase</a>(&amp;Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o17">WaitIrql</a>);
00778     } <span class="keywordflow">while</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
00779 
00780     <span class="comment">//</span>
00781     <span class="comment">// The thread is alerted or a user APC should be delivered. Unlock the</span>
00782     <span class="comment">// dispatcher database, lower IRQL to its previous value, and return</span>
00783     <span class="comment">// the wait status.</span>
00784     <span class="comment">//</span>
00785 
00786     <a class="code" href="../../d0/d0/ki_8h.html#a84">KiUnlockDispatcherDatabase</a>(Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o17">WaitIrql</a>);
00787     <span class="keywordflow">return</span> WaitStatus;
00788 
00789     <span class="comment">//</span>
00790     <span class="comment">// The wait has been satisfied without actually waiting.</span>
00791     <span class="comment">//</span>
00792     <span class="comment">// If the thread priority that is less than time critical, then reduce</span>
00793     <span class="comment">// the thread quantum. If a quantum end occurs, then reduce the thread</span>
00794     <span class="comment">// priority.</span>
00795     <span class="comment">//</span>
00796 
00797 NoWait:
00798     <a class="code" href="../../d1/d7/wait_8c.html#a1">KiAdjustQuantumThread</a>(Thread);
00799 
00800     <span class="comment">//</span>
00801     <span class="comment">// Unlock the dispatcher database, lower IRQL to its previous value, and</span>
00802     <span class="comment">// return the wait status.</span>
00803     <span class="comment">//</span>
00804 
00805     <a class="code" href="../../d0/d0/ki_8h.html#a84">KiUnlockDispatcherDatabase</a>(Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o17">WaitIrql</a>);
00806     <span class="keywordflow">return</span> WaitStatus;
00807 }
00808 
00809 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00810"></a><a class="code" href="../../d1/d7/wait_8c.html#a4">00810</a> <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a> (
00811     IN PVOID Object,
00812     IN KWAIT_REASON WaitReason,
00813     IN KPROCESSOR_MODE WaitMode,
00814     IN BOOLEAN Alertable,
00815     IN PLARGE_INTEGER Timeout OPTIONAL
00816     )
00817 
00818 <span class="comment">/*++</span>
00819 <span class="comment"></span>
00820 <span class="comment">Routine Description:</span>
00821 <span class="comment"></span>
00822 <span class="comment">    This function waits until the specified object attains a state of</span>
00823 <span class="comment">    Signaled. An optional timeout can also be specified. If a timeout</span>
00824 <span class="comment">    is not specified, then the wait will not be satisfied until the object</span>
00825 <span class="comment">    attains a state of Signaled. If a timeout is specified, and the object</span>
00826 <span class="comment">    has not attained a state of Signaled when the timeout expires, then</span>
00827 <span class="comment">    the wait is automatically satisfied. If an explicit timeout value of</span>
00828 <span class="comment">    zero is specified, then no wait will occur if the wait cannot be satisfied</span>
00829 <span class="comment">    immediately. The wait can also be specified as alertable.</span>
00830 <span class="comment"></span>
00831 <span class="comment">Arguments:</span>
00832 <span class="comment"></span>
00833 <span class="comment">    Object - Supplies a pointer to a dispatcher object.</span>
00834 <span class="comment"></span>
00835 <span class="comment">    WaitReason - Supplies the reason for the wait.</span>
00836 <span class="comment"></span>
00837 <span class="comment">    WaitMode  - Supplies the processor mode in which the wait is to occur.</span>
00838 <span class="comment"></span>
00839 <span class="comment">    Alertable - Supplies a boolean value that specifies whether the wait is</span>
00840 <span class="comment">        alertable.</span>
00841 <span class="comment"></span>
00842 <span class="comment">    Timeout - Supplies a pointer to an optional absolute of relative time over</span>
00843 <span class="comment">        which the wait is to occur.</span>
00844 <span class="comment"></span>
00845 <span class="comment">Return Value:</span>
00846 <span class="comment"></span>
00847 <span class="comment">    The wait completion status. A value of STATUS_TIMEOUT is returned if a</span>
00848 <span class="comment">    timeout occurred. A value of STATUS_SUCCESS is returned if the specified</span>
00849 <span class="comment">    object satisfied the wait. A value of STATUS_ALERTED is returned if the</span>
00850 <span class="comment">    wait was aborted to deliver an alert to the current thread. A value of</span>
00851 <span class="comment">    STATUS_USER_APC is returned if the wait was aborted to deliver a user</span>
00852 <span class="comment">    APC to the current thread.</span>
00853 <span class="comment"></span>
00854 <span class="comment">--*/</span>
00855 
00856 {
00857 
00858     LARGE_INTEGER DueTime;
00859     LARGE_INTEGER NewTime;
00860     <a class="code" href="../../d1/d8/struct__KTHREAD.html">PRKTHREAD</a> NextThread;
00861     <a class="code" href="../../d3/d7/struct__KMUTANT.html">PKMUTANT</a> Objectx;
00862     PLARGE_INTEGER OriginalTime;
00863     <a class="code" href="../../d7/d7/struct__KQUEUE.html">PRKQUEUE</a> Queue;
00864     <a class="code" href="../../d1/d8/struct__KTHREAD.html">PRKTHREAD</a> Thread;
00865     <a class="code" href="../../d3/d8/struct__KTIMER.html">PRKTIMER</a> Timer;
00866     <a class="code" href="../../d4/d8/struct__KWAIT__BLOCK.html">PKWAIT_BLOCK</a> WaitBlock;
00867     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> WaitStatus;
00868     <a class="code" href="../../d4/d8/struct__KWAIT__BLOCK.html">PKWAIT_BLOCK</a> WaitTimer;
00869 
00870     <span class="comment">//</span>
00871     <span class="comment">// Collect call data.</span>
00872     <span class="comment">//</span>
00873 
00874 <span class="preprocessor">#if defined(_COLLECT_WAIT_SINGLE_CALLDATA_)</span>
00875 <span class="preprocessor"></span>
00876     <a class="code" href="../../d5/d8/ex_8h.html#a1">RECORD_CALL_DATA</a>(&amp;<a class="code" href="../../d0/d0/ki_8h.html#a79">KiWaitSingleCallData</a>);
00877 
00878 <span class="preprocessor">#endif</span>
00879 <span class="preprocessor"></span>
00880     <span class="comment">//</span>
00881     <span class="comment">// If the dispatcher database lock is not already held, then set the wait</span>
00882     <span class="comment">// IRQL and lock the dispatcher database. Else set boolean wait variable</span>
00883     <span class="comment">// to FALSE.</span>
00884     <span class="comment">//</span>
00885 
00886     Thread = <a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a3">KeGetCurrentThread</a>();
00887     <span class="keywordflow">if</span> (Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o19">WaitNext</a>) {
00888         Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o19">WaitNext</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00889 
00890     } <span class="keywordflow">else</span> {
00891         <a class="code" href="../../d4/d9/ke_8h.html#a36">KiLockDispatcherDatabase</a>(&amp;Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o17">WaitIrql</a>);
00892     }
00893 
00894     <span class="comment">//</span>
00895     <span class="comment">// Start of wait loop.</span>
00896     <span class="comment">//</span>
00897     <span class="comment">// Note this loop is repeated if a kernel APC is delivered in the middle</span>
00898     <span class="comment">// of the wait or a kernel APC is pending on the first attempt through</span>
00899     <span class="comment">// the loop.</span>
00900     <span class="comment">//</span>
00901 
00902     OriginalTime = Timeout;
00903     WaitBlock = &amp;Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o28">WaitBlock</a>[0];
00904     <span class="keywordflow">do</span> {
00905 
00906         <span class="comment">//</span>
00907         <span class="comment">// Test to determine if a kernel APC is pending.</span>
00908         <span class="comment">//</span>
00909         <span class="comment">// If a kernel APC is pending and the previous IRQL was less than</span>
00910         <span class="comment">// APC_LEVEL, then a kernel APC was queued by another processor just</span>
00911         <span class="comment">// after IRQL was raised to DISPATCH_LEVEL, but before the dispatcher</span>
00912         <span class="comment">// database was locked.</span>
00913         <span class="comment">//</span>
00914         <span class="comment">// N.B. that this can only happen in a multiprocessor system.</span>
00915         <span class="comment">//</span>
00916 
00917         <span class="keywordflow">if</span> (Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o14">ApcState</a>.<a class="code" href="../../d3/d5/struct__KAPC__STATE.html#o3">KernelApcPending</a> &amp;&amp; (Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o17">WaitIrql</a> &lt; <a class="code" href="../../d6/d7/halmips_8h.html#a52">APC_LEVEL</a>)) {
00918 
00919             <span class="comment">//</span>
00920             <span class="comment">// Unlock the dispatcher database and lower IRQL to its previous</span>
00921             <span class="comment">// value. An APC interrupt will immediately occur which will result</span>
00922             <span class="comment">// in the delivery of the kernel APC if possible.</span>
00923             <span class="comment">//</span>
00924 
00925             <a class="code" href="../../d0/d0/ki_8h.html#a84">KiUnlockDispatcherDatabase</a>(Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o17">WaitIrql</a>);
00926 
00927         } <span class="keywordflow">else</span> {
00928 
00929             <span class="comment">//</span>
00930             <span class="comment">// Test if the wait can be immediately satisfied.</span>
00931             <span class="comment">//</span>
00932 
00933             Objectx = (<a class="code" href="../../d3/d7/struct__KMUTANT.html">PKMUTANT</a>)Object;
00934             Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o16">WaitStatus</a> = (<a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>)0;
00935 
00936             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(Objectx-&gt;<a class="code" href="../../d3/d7/struct__KMUTANT.html#o0">Header</a>.<a class="code" href="../../d1/d6/struct__DISPATCHER__HEADER.html#o0">Type</a> != <a class="code" href="../../d4/d9/ke_8h.html#a402a161">QueueObject</a>);
00937 
00938             <span class="comment">//</span>
00939             <span class="comment">// If the object is a mutant object and the mutant object has been</span>
00940             <span class="comment">// recursively acquired MINLONG times, then raise an exception.</span>
00941             <span class="comment">// Otherwise if the signal state of the mutant object is greater</span>
00942             <span class="comment">// than zero, or the current thread is the owner of the mutant</span>
00943             <span class="comment">// object, then satisfy the wait.</span>
00944             <span class="comment">//</span>
00945 
00946             <span class="keywordflow">if</span> (Objectx-&gt;<a class="code" href="../../d3/d7/struct__KMUTANT.html#o0">Header</a>.<a class="code" href="../../d1/d6/struct__DISPATCHER__HEADER.html#o0">Type</a> == <a class="code" href="../../d4/d9/ke_8h.html#a402a159">MutantObject</a>) {
00947                 <span class="keywordflow">if</span> ((Objectx-&gt;<a class="code" href="../../d3/d7/struct__KMUTANT.html#o0">Header</a>.<a class="code" href="../../d1/d6/struct__DISPATCHER__HEADER.html#o4">SignalState</a> &gt; 0) ||
00948                     (Thread == Objectx-&gt;<a class="code" href="../../d3/d7/struct__KMUTANT.html#o2">OwnerThread</a>)) {
00949                     <span class="keywordflow">if</span> (Objectx-&gt;<a class="code" href="../../d3/d7/struct__KMUTANT.html#o0">Header</a>.<a class="code" href="../../d1/d6/struct__DISPATCHER__HEADER.html#o4">SignalState</a> != MINLONG) {
00950                         <a class="code" href="../../d0/d0/ki_8h.html#a26">KiWaitSatisfyMutant</a>(Objectx, Thread);
00951                         WaitStatus = (<a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>)(Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o16">WaitStatus</a>);
00952                         <span class="keywordflow">goto</span> NoWait;
00953 
00954                     } <span class="keywordflow">else</span> {
00955                         <a class="code" href="../../d0/d0/ki_8h.html#a84">KiUnlockDispatcherDatabase</a>(Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o17">WaitIrql</a>);
00956                         <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>(STATUS_MUTANT_LIMIT_EXCEEDED);
00957                     }
00958                 }
00959 
00960             <span class="comment">//</span>
00961             <span class="comment">// If the signal state is greater than zero, then satisfy the wait.</span>
00962             <span class="comment">//</span>
00963 
00964             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Objectx-&gt;<a class="code" href="../../d3/d7/struct__KMUTANT.html#o0">Header</a>.<a class="code" href="../../d1/d6/struct__DISPATCHER__HEADER.html#o4">SignalState</a> &gt; 0) {
00965                 <a class="code" href="../../d0/d0/ki_8h.html#a27">KiWaitSatisfyOther</a>(Objectx);
00966                 WaitStatus = (<a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>)(0);
00967                 <span class="keywordflow">goto</span> NoWait;
00968             }
00969 
00970             <span class="comment">//</span>
00971             <span class="comment">// Construct a wait block for the object.</span>
00972             <span class="comment">//</span>
00973 
00974             Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o21">WaitBlockList</a> = WaitBlock;
00975             WaitBlock-&gt;<a class="code" href="../../d4/d8/struct__KWAIT__BLOCK.html#o2">Object</a> = Object;
00976             WaitBlock-&gt;<a class="code" href="../../d4/d8/struct__KWAIT__BLOCK.html#o4">WaitKey</a> = (CSHORT)(STATUS_SUCCESS);
00977             WaitBlock-&gt;<a class="code" href="../../d4/d8/struct__KWAIT__BLOCK.html#o5">WaitType</a> = WaitAny;
00978 
00979             <span class="comment">//</span>
00980             <span class="comment">// Test for alert pending.</span>
00981             <span class="comment">//</span>
00982 
00983             <a class="code" href="../../d1/d7/wait_8c.html#a0">TestForAlertPending</a>(Alertable);
00984 
00985             <span class="comment">//</span>
00986             <span class="comment">// The wait cannot be satisifed immediately. Check to determine if</span>
00987             <span class="comment">// a timeout value is specified.</span>
00988             <span class="comment">//</span>
00989 
00990             <span class="keywordflow">if</span> (ARGUMENT_PRESENT(Timeout)) {
00991 
00992                 <span class="comment">//</span>
00993                 <span class="comment">// If the timeout value is zero, then return immediately without</span>
00994                 <span class="comment">// waiting.</span>
00995                 <span class="comment">//</span>
00996 
00997                 <span class="keywordflow">if</span> (!(Timeout-&gt;LowPart | Timeout-&gt;HighPart)) {
00998                     WaitStatus = (<a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>)(STATUS_TIMEOUT);
00999                     <span class="keywordflow">goto</span> NoWait;
01000                 }
01001 
01002                 <span class="comment">//</span>
01003                 <span class="comment">// Initialize a wait block for the thread specific timer, insert</span>
01004                 <span class="comment">// wait block in timer wait list, insert the timer in the timer</span>
01005                 <span class="comment">// tree.</span>
01006                 <span class="comment">//</span>
01007                 <span class="comment">// N.B. The timer wait block is initialized when the respective</span>
01008                 <span class="comment">//      thread is initialized. Thus the constant fields are not</span>
01009                 <span class="comment">//      reinitialized. These include the wait object, wait key,</span>
01010                 <span class="comment">//      wait type, and the wait list entry link pointers.</span>
01011                 <span class="comment">//</span>
01012 
01013                 Timer = &amp;Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o39">Timer</a>;
01014                 WaitTimer = &amp;Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o28">WaitBlock</a>[<a class="code" href="../../d4/d9/ke_8h.html#a9">TIMER_WAIT_BLOCK</a>];
01015                 WaitBlock-&gt;<a class="code" href="../../d4/d8/struct__KWAIT__BLOCK.html#o3">NextWaitBlock</a> = WaitTimer;
01016                 Timer-&gt;<a class="code" href="../../d3/d8/struct__KTIMER.html#o0">Header</a>.<a class="code" href="../../d1/d6/struct__DISPATCHER__HEADER.html#o5">WaitListHead</a>.Flink = &amp;WaitTimer-&gt;<a class="code" href="../../d4/d8/struct__KWAIT__BLOCK.html#o0">WaitListEntry</a>;
01017                 Timer-&gt;<a class="code" href="../../d3/d8/struct__KTIMER.html#o0">Header</a>.<a class="code" href="../../d1/d6/struct__DISPATCHER__HEADER.html#o5">WaitListHead</a>.Blink = &amp;WaitTimer-&gt;<a class="code" href="../../d4/d8/struct__KWAIT__BLOCK.html#o0">WaitListEntry</a>;
01018                 WaitTimer-&gt;<a class="code" href="../../d4/d8/struct__KWAIT__BLOCK.html#o3">NextWaitBlock</a> = WaitBlock;
01019                 <span class="keywordflow">if</span> (<a class="code" href="../../d5/d2/timersup_8c.html#a1">KiInsertTreeTimer</a>(Timer, *Timeout) == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01020                     WaitStatus = (<a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>)STATUS_TIMEOUT;
01021                     <span class="keywordflow">goto</span> NoWait;
01022                 }
01023 
01024                 DueTime.QuadPart = Timer-&gt;<a class="code" href="../../d3/d8/struct__KTIMER.html#o1">DueTime</a>.QuadPart;
01025 
01026             } <span class="keywordflow">else</span> {
01027                 WaitBlock-&gt;<a class="code" href="../../d4/d8/struct__KWAIT__BLOCK.html#o3">NextWaitBlock</a> = WaitBlock;
01028             }
01029 
01030             <span class="comment">//</span>
01031             <span class="comment">// Insert wait block in object wait list.</span>
01032             <span class="comment">//</span>
01033 
01034             InsertTailList(&amp;Objectx-&gt;<a class="code" href="../../d3/d7/struct__KMUTANT.html#o0">Header</a>.<a class="code" href="../../d1/d6/struct__DISPATCHER__HEADER.html#o5">WaitListHead</a>, &amp;WaitBlock-&gt;<a class="code" href="../../d4/d8/struct__KWAIT__BLOCK.html#o0">WaitListEntry</a>);
01035 
01036             <span class="comment">//</span>
01037             <span class="comment">// If the current thread is processing a queue entry, then attempt</span>
01038             <span class="comment">// to activate another thread that is blocked on the queue object.</span>
01039             <span class="comment">//</span>
01040 
01041             Queue = Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o37">Queue</a>;
01042             <span class="keywordflow">if</span> (Queue != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01043                 <a class="code" href="../../d8/d3/queueobj_8c.html#a7">KiActivateWaiterQueue</a>(Queue);
01044             }
01045 
01046             <span class="comment">//</span>
01047             <span class="comment">// Set the thread wait parameters, set the thread dispatcher state</span>
01048             <span class="comment">// to Waiting, and insert the thread in the wait list.</span>
01049             <span class="comment">//</span>
01050 
01051             Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o57">Alertable</a> = Alertable;
01052             Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o18">WaitMode</a> = WaitMode;
01053             Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o20">WaitReason</a> = (UCHAR)WaitReason;
01054             Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o23">WaitTime</a>= KiQueryLowTickCount();
01055             Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o8">State</a> = <a class="code" href="../../d4/d9/ke_8h.html#a406a196">Waiting</a>;
01056             <a class="code" href="../../d0/d0/ki_8h.html#a15">KiInsertWaitList</a>(WaitMode, Thread);
01057 
01058             <span class="comment">//</span>
01059             <span class="comment">// Switch context to selected thread.</span>
01060             <span class="comment">//</span>
01061             <span class="comment">// Control is returned at the original IRQL.</span>
01062             <span class="comment">//</span>
01063 
01064             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o17">WaitIrql</a> &lt;= <a class="code" href="../../d6/d7/halmips_8h.html#a53">DISPATCH_LEVEL</a>);
01065 
01066             WaitStatus = (<a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>)<a class="code" href="../../d0/d0/ki_8h.html#a138">KiSwapThread</a>();
01067 
01068             <span class="comment">//</span>
01069             <span class="comment">// If the thread was not awakened to deliver a kernel mode APC,</span>
01070             <span class="comment">// then return wait status.</span>
01071             <span class="comment">//</span>
01072 
01073             <span class="keywordflow">if</span> (WaitStatus != STATUS_KERNEL_APC) {
01074                 <span class="keywordflow">return</span> WaitStatus;
01075             }
01076 
01077             <span class="keywordflow">if</span> (ARGUMENT_PRESENT(Timeout)) {
01078 
01079                 <span class="comment">//</span>
01080                 <span class="comment">// Reduce the amount of time remaining before timeout occurs.</span>
01081                 <span class="comment">//</span>
01082 
01083                 Timeout = <a class="code" href="../../d1/d7/wait_8c.html#a6">KiComputeWaitInterval</a>(OriginalTime,
01084                                                 &amp;DueTime,
01085                                                 &amp;NewTime);
01086             }
01087         }
01088 
01089         <span class="comment">//</span>
01090         <span class="comment">// Raise IRQL to DISPATCH_LEVEL and lock the dispatcher database.</span>
01091         <span class="comment">//</span>
01092 
01093         <a class="code" href="../../d4/d9/ke_8h.html#a36">KiLockDispatcherDatabase</a>(&amp;Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o17">WaitIrql</a>);
01094     } <span class="keywordflow">while</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
01095 
01096     <span class="comment">//</span>
01097     <span class="comment">// The thread is alerted or a user APC should be delivered. Unlock the</span>
01098     <span class="comment">// dispatcher database, lower IRQL to its previous value, and return</span>
01099     <span class="comment">// the wait status.</span>
01100     <span class="comment">//</span>
01101 
01102     <a class="code" href="../../d0/d0/ki_8h.html#a84">KiUnlockDispatcherDatabase</a>(Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o17">WaitIrql</a>);
01103     <span class="keywordflow">return</span> WaitStatus;
01104 
01105     <span class="comment">//</span>
01106     <span class="comment">// The wait has been satisfied without actually waiting.</span>
01107     <span class="comment">//</span>
01108     <span class="comment">// If the thread priority that is less than time critical, then reduce</span>
01109     <span class="comment">// the thread quantum. If a quantum end occurs, then reduce the thread</span>
01110     <span class="comment">// priority.</span>
01111     <span class="comment">//</span>
01112 
01113 NoWait:
01114     <a class="code" href="../../d1/d7/wait_8c.html#a1">KiAdjustQuantumThread</a>(Thread);
01115 
01116     <span class="comment">//</span>
01117     <span class="comment">// Unlock the dispatcher database, lower IRQL to its previous value, and</span>
01118     <span class="comment">// return the wait status.</span>
01119     <span class="comment">//</span>
01120 
01121     <a class="code" href="../../d0/d0/ki_8h.html#a84">KiUnlockDispatcherDatabase</a>(Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o17">WaitIrql</a>);
01122     <span class="keywordflow">return</span> WaitStatus;
01123 }
01124 
01125 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l01126"></a><a class="code" href="../../d1/d7/wait_8c.html#a5">01126</a> <a class="code" href="../../d1/d7/wait_8c.html#a5">KiSetServerWaitClientEvent</a> (
01127     IN <a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a> ServerEvent,
01128     IN <a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a> ClientEvent,
01129     IN ULONG WaitMode
01130     )
01131 
01132 <span class="comment">/*++</span>
01133 <span class="comment"></span>
01134 <span class="comment">Routine Description:</span>
01135 <span class="comment"></span>
01136 <span class="comment">    This function sets the specified server event and waits on specified</span>
01137 <span class="comment">    client event. The wait is performed such that an optimal switch to</span>
01138 <span class="comment">    the waiting thread occurs if possible. No timeout is associated with</span>
01139 <span class="comment">    the wait, and thus, the issuing thread will wait until the client event</span>
01140 <span class="comment">    is signaled or an APC is delivered.</span>
01141 <span class="comment"></span>
01142 <span class="comment">Arguments:</span>
01143 <span class="comment"></span>
01144 <span class="comment">    ServerEvent - Supplies a pointer to a dispatcher object of type event.</span>
01145 <span class="comment"></span>
01146 <span class="comment">    ClientEvent - Supplies a pointer to a dispatcher object of type event.</span>
01147 <span class="comment"></span>
01148 <span class="comment">    WaitMode  - Supplies the processor mode in which the wait is to occur.</span>
01149 <span class="comment"></span>
01150 <span class="comment">Return Value:</span>
01151 <span class="comment"></span>
01152 <span class="comment">    The wait completion status. A value of STATUS_SUCCESS is returned if</span>
01153 <span class="comment">    the specified object satisfied the wait. A value of STATUS_USER_APC is</span>
01154 <span class="comment">    returned if the wait was aborted to deliver a user APC to the current</span>
01155 <span class="comment">    thread.</span>
01156 <span class="comment"></span>
01157 <span class="comment">--*/</span>
01158 
01159 {
01160 
01161     <span class="comment">//</span>
01162     <span class="comment">// Set sever event and wait on client event atomically.</span>
01163     <span class="comment">//</span>
01164 
01165     <a class="code" href="../../d2/d8/eventobj_8c.html#a8">KeSetEvent</a>(ServerEvent, <a class="code" href="../../d7/d8/exboosts_8h.html#a0">EVENT_INCREMENT</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
01166     <span class="keywordflow">return</span> <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>(ClientEvent,
01167                                  <a class="code" href="../../d4/d9/ke_8h.html#a407a212">WrEventPair</a>,
01168                                  (<a class="code" href="../../d0/d9/ntosdef_8h.html#a39">KPROCESSOR_MODE</a>)WaitMode,
01169                                  <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
01170                                  <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
01171 }
01172 
01173 PLARGE_INTEGER
01174 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l01175"></a><a class="code" href="../../d1/d7/wait_8c.html#a6">01175</a> <a class="code" href="../../d1/d7/wait_8c.html#a6">KiComputeWaitInterval</a> (
01176     IN PLARGE_INTEGER OriginalTime,
01177     IN PLARGE_INTEGER DueTime,
01178     IN OUT PLARGE_INTEGER NewTime
01179     )
01180 
01181 <span class="comment">/*++</span>
01182 <span class="comment"></span>
01183 <span class="comment">Routine Description:</span>
01184 <span class="comment"></span>
01185 <span class="comment">    This function recomputes the wait interval after a thread has been</span>
01186 <span class="comment">    awakened to deliver a kernel APC.</span>
01187 <span class="comment"></span>
01188 <span class="comment">Arguments:</span>
01189 <span class="comment"></span>
01190 <span class="comment">    OriginalTime - Supplies a pointer to the original timeout value.</span>
01191 <span class="comment"></span>
01192 <span class="comment">    DueTime - Supplies a pointer to the previous due time.</span>
01193 <span class="comment"></span>
01194 <span class="comment">    NewTime - Supplies a pointer to a variable that receives the</span>
01195 <span class="comment">        recomputed wait interval.</span>
01196 <span class="comment"></span>
01197 <span class="comment">Return Value:</span>
01198 <span class="comment"></span>
01199 <span class="comment">    A pointer to the new time is returned as the function value.</span>
01200 <span class="comment"></span>
01201 <span class="comment">--*/</span>
01202 
01203 {
01204 
01205     <span class="comment">//</span>
01206     <span class="comment">// If the original wait time was absolute, then return the same</span>
01207     <span class="comment">// absolute time. Otherwise, reduce the wait time remaining before</span>
01208     <span class="comment">// the time delay expires.</span>
01209     <span class="comment">//</span>
01210 
01211     <span class="keywordflow">if</span> (OriginalTime-&gt;QuadPart &gt;= 0) {
01212         <span class="keywordflow">return</span> OriginalTime;
01213 
01214     } <span class="keywordflow">else</span> {
01215         KiQueryInterruptTime(NewTime);
01216         NewTime-&gt;QuadPart -= DueTime-&gt;QuadPart;
01217         <span class="keywordflow">return</span> NewTime;
01218     }
01219 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:42:24 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
