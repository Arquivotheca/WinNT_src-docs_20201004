<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: lock.c File Reference</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>lock.c File Reference</h1><code>#include "<a class="el" href="../../d1/d5/iop_8h-source.html">iop.h</a>"</code><br>

<p>
<a href="../../d2/d4/lock_8c-source.html">Go to the source code of this file.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d1/d5/lock_8c.html#a0">NtLockFile</a> (IN HANDLE FileHandle, IN HANDLE Event OPTIONAL, IN PIO_APC_ROUTINE ApcRoutine OPTIONAL, IN PVOID ApcContext OPTIONAL, OUT PIO_STATUS_BLOCK IoStatusBlock, IN PLARGE_INTEGER ByteOffset, IN PLARGE_INTEGER Length, IN ULONG <a class="el" href="../../d3/d0/user32_8def.html#a52">Key</a>, IN BOOLEAN FailImmediately, IN BOOLEAN ExclusiveLock)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d1/d5/lock_8c.html#a1">NtUnlockFile</a> (IN HANDLE FileHandle, OUT PIO_STATUS_BLOCK IoStatusBlock, IN PLARGE_INTEGER ByteOffset, IN PLARGE_INTEGER Length, IN ULONG <a class="el" href="../../d3/d0/user32_8def.html#a52">Key</a>)</td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a0" doxytag="lock.c::NtLockFile" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS NtLockFile           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN HANDLE&nbsp;</td>
          <td class="mdname" nowrap> <em>FileHandle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN HANDLE Event&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PIO_APC_ROUTINE ApcRoutine&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID ApcContext&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PIO_STATUS_BLOCK&nbsp;</td>
          <td class="mdname" nowrap> <em>IoStatusBlock</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PLARGE_INTEGER&nbsp;</td>
          <td class="mdname" nowrap> <em>ByteOffset</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PLARGE_INTEGER&nbsp;</td>
          <td class="mdname" nowrap> <em>Length</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Key</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN BOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>FailImmediately</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN BOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>ExclusiveLock</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d2/d4/lock_8c-source.html#l00035">35</a> of file <a class="el" href="../../d2/d4/lock_8c-source.html">lock.c</a>.
<p>
References <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01179">_DEVICE_OBJECT::DriverObject</a>, <a class="el" href="../../d9/d8/client_2ntstubs_8c-source.html#l00086">Event()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00127">ExAllocatePoolWithQuota</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00055">EXCEPTION_EXECUTE_HANDLER</a>, <a class="el" href="../../d8/d6/ntapi_8c-source.html#l00030">ExEventObjectType</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01403">_DRIVER_OBJECT::FastIoDispatch</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l00948">_FAST_IO_DISPATCH::FastIoLock</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02494">_IO_STACK_LOCATION::FileObject</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02030">_IO_STACK_LOCATION::Flags</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01492">FO_ALERTABLE_IO</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01491">FO_SYNCHRONOUS_IO</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00057">_OBJECT_HANDLE_INFORMATION::GrantedAccess</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l00652">IoAllocateIrp()</a>, <a class="el" href="../../d6/d7/fssup_8c-source.html#l00044">IoFileObjectType</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l03398">IoGetNextIrpStackLocation</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l07247">IoGetRelatedDeviceObject()</a>, <a class="el" href="../../d1/d5/iop_8h-source.html#l00595">IopAcquireFastLock</a>, <a class="el" href="../../d3/d3/internal_8c-source.html#l00181">IopAcquireFileObjectLock()</a>, <a class="el" href="../../d3/d3/internal_8c-source.html#l00284">IopAllocateIrpCleanup()</a>, <a class="el" href="../../d1/d5/iop_8h-source.html#l00768">IopApcRoutinePresent</a>, <a class="el" href="../../d3/d3/internal_8c-source.html#l01934">IopExceptionCleanup()</a>, <a class="el" href="../../d3/d3/internal_8c-source.html#l07030">IopSynchronousServiceTail()</a>, <a class="el" href="../../d6/d3/complete_8c-source.html#l00671">IoSetIoCompletion()</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l00072">IRP_MJ_LOCK_CONTROL</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l00123">IRP_MN_LOCK</a>, <a class="el" href="../../d5/d8/ke_8h-source.html#l01072">KeClearEvent</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00624">KernelMode</a>, <a class="el" href="../../d3/d7/eventobj_8c-source.html#l00343">KeSetEvent()</a>, <a class="el" href="../../d3/d9/nt6_2user32_8def-source.html#l00417">Key</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00174">KPROCESSOR_MODE</a>, <a class="el" href="../../d3/d9/aw_8h-source.html#l00031">L</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02028">_IO_STACK_LOCATION::MajorFunction</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02029">_IO_STACK_LOCATION::MinorFunction</a>, <a class="el" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00494">ObDereferenceObject</a>, <a class="el" href="../../d8/d0/obref_8c-source.html#l00542">ObReferenceObjectByHandle()</a>, <a class="el" href="../../d0/d6/iop_8h.html#a240a140">OtherTransfer</a>, <a class="el" href="../../d0/d2/struct__IRP.html#o24">_IRP::Overlay</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02069">_IO_STACK_LOCATION::Parameters</a>, <a class="el" href="../../d6/d7/ex_8h-source.html#l01209">ProbeForRead</a>, <a class="el" href="../../d6/d7/ex_8h-source.html#l01518">ProbeForWriteIoStatusEx</a>, <a class="el" href="../../d2/d8/ps_8h-source.html#l00643">PsGetCurrentProcess</a>, <a class="el" href="../../d2/d8/ps_8h-source.html#l00645">PsGetCurrentThread</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01641">_IRP::RequestorMode</a>, <a class="el" href="../../d1/d4/se_8h-source.html#l00515">SeComputeGrantedAccesses</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01890">SL_EXCLUSIVE_LOCK</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01889">SL_FAIL_IMMEDIATELY</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01189">_DEVICE_OBJECT::StackSize</a>, <a class="el" href="../../d0/d2/struct__IRP.html#o38">_IRP::Tail</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01687">_IRP::UserEvent</a>, and <a class="el" href="../../d1/d4/io_8h-source.html#l01686">_IRP::UserIosb</a>.
<p>
<pre class="fragment"><div>00050                    :
00051 
00052     This service locks a specified range of bytes on <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> specified by
00053     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> FileHandle parameter.  The lock may either be an exclusive lock or
00054     a shared lock.  Furthermore, <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller has <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> option of specifying
00055     whether or not <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> service should <span class="keywordflow">return</span> immediately <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> lock cannot
00056     be acquired without waiting.
00057 
00058 Arguments:
00059 
00060     FileHandle - Supplies a handle to an open <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a>.
00061 
00062     <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a> - Supplies an optional event to be set to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Signaled state when
00063         <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> operation <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> complete.
00064 
00065     ApcRoutine - Supplies an optional APC routine to be executed when <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
00066         operation <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> complete.
00067 
00068     ApcContext - Supplies a context parameter to be passed to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> ApcRoutine,
00069         <span class="keywordflow">if</span> an ApcRoutine was specified.
00070 
00071     IoStatusBlock - Address of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller's I/O status block.
00072 
00073     ByteOffset - Specifies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> starting byte offset of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> range to lock.
00074 
00075     Length - Specifies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> length of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> byte range to be locked.
00076 
00077     <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a51">Key</a> - Specifies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> key to be associated with <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> lock.
00078 
00079     FailImmediately - Specifies that <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> lock cannot immediately be
00080         acquired that <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> service should <span class="keywordflow">return</span> to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller.
00081 
00082     ExclusiveLock - Specifies, <span class="keywordflow">if</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, that <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> lock should be an exclusive
00083         lock;  otherwise <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> lock <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> a shared lock.
00084 
00085 Return Value:
00086 
00087     The status returned <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> success <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> operation was properly queued to
00088     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> I/O system.  Once <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> operation completes, <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> status can be
00089     determined by examining <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> field of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> I/O status block.
00090 
00091 --*/
00092 
00093 {
00094     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
00095     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
00096     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> fileObject;
00097     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> deviceObject;
00098     <a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html">PFAST_IO_DISPATCH</a> fastIoDispatch;
00099     <a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a> eventObject = (<a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00100     <a class="code" href="../../d0/d9/ntosdef_8h.html#a39">KPROCESSOR_MODE</a> requestorMode;
00101     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpSp;
00102     LARGE_INTEGER fileOffset;
00103     LARGE_INTEGER length;
00104     ACCESS_MASK grantedAccess;
00105     <a class="code" href="../../d3/d5/struct__OBJECT__HANDLE__INFORMATION.html">OBJECT_HANDLE_INFORMATION</a> handleInformation;
00106     BOOLEAN synchronousIo;
00107 
00108     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00109 
00110     <span class="comment">//</span>
00111     <span class="comment">// Get the previous mode;  i.e., the mode of the caller.</span>
00112     <span class="comment">//</span>
00113 
00114     requestorMode = KeGetPreviousMode();
00115 
00116     <span class="comment">//</span>
00117     <span class="comment">// Reference the file object so the target device can be found and the</span>
00118     <span class="comment">// access rights mask can be used in the following checks for callers</span>
00119     <span class="comment">// in user mode.  Note that if the handle does not refer to a file</span>
00120     <span class="comment">// object, then it will fail.</span>
00121     <span class="comment">//</span>
00122 
00123     status = <a class="code" href="../../d7/d1/obref_8c.html#a4">ObReferenceObjectByHandle</a>( FileHandle,
00124                                         0L,
00125                                         IoFileObjectType,
00126                                         requestorMode,
00127                                         (PVOID *) &amp;fileObject,
00128                                         &amp;handleInformation);
00129     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
00130         <span class="keywordflow">return</span> status;
00131     }
00132 
00133     grantedAccess = handleInformation.<a class="code" href="../../d3/d5/struct__OBJECT__HANDLE__INFORMATION.html#o1">GrantedAccess</a>;
00134 
00135     <span class="keywordflow">if</span> (requestorMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
00136 
00137         <span class="comment">//</span>
00138         <span class="comment">// The caller's access mode is not kernel so probe each of the arguments</span>
00139         <span class="comment">// and capture them as necessary.  If any failures occur, the condition</span>
00140         <span class="comment">// handler will be invoked to handle them.  It will simply cleanup and</span>
00141         <span class="comment">// return an access violation status code back to the system service</span>
00142         <span class="comment">// dispatcher.</span>
00143         <span class="comment">//</span>
00144 
00145         <span class="comment">//</span>
00146         <span class="comment">// Check to ensure that the caller has either READ or WRITE access to</span>
00147         <span class="comment">// the file.  If not, cleanup and return an error.</span>
00148         <span class="comment">//</span>
00149 
00150         <span class="keywordflow">if</span> (!<a class="code" href="../../d0/d5/se_8h.html#a9">SeComputeGrantedAccesses</a>( grantedAccess, FILE_READ_DATA | FILE_WRITE_DATA )) {
00151             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
00152             <span class="keywordflow">return</span> STATUS_ACCESS_DENIED;
00153         }
00154 
00155         <span class="keywordflow">try</span> {
00156 
00157             <span class="comment">//</span>
00158             <span class="comment">// The IoStatusBlock parameter must be writeable by the caller.</span>
00159             <span class="comment">//</span>
00160 
00161             <a class="code" href="../../d5/d8/ex_8h.html#a32">ProbeForWriteIoStatusEx</a>( IoStatusBlock , ApcRoutine);
00162 
00163             <span class="comment">//</span>
00164             <span class="comment">// The ByteOffset parameter must be readable by the caller.  Probe</span>
00165             <span class="comment">// and capture it.</span>
00166             <span class="comment">//</span>
00167 
00168             <a class="code" href="../../d5/d8/ex_8h.html#a11">ProbeForRead</a>( ByteOffset,
00169                           <span class="keyword">sizeof</span>( LARGE_INTEGER ),
00170                           <span class="keyword">sizeof</span>( ULONG ) );
00171             fileOffset = *ByteOffset;
00172 
00173             <span class="comment">//</span>
00174             <span class="comment">// Likewise, the Length parameter must also be readable by the</span>
00175             <span class="comment">// caller.  Probe and capture it as well.</span>
00176             <span class="comment">//</span>
00177 
00178             <a class="code" href="../../d5/d8/ex_8h.html#a11">ProbeForRead</a>( Length,
00179                           <span class="keyword">sizeof</span>( LARGE_INTEGER ),
00180                           <span class="keyword">sizeof</span>( ULONG ) );
00181             length = *Length;
00182 
00183             <span class="comment">//</span>
00184             <span class="comment">// If this file has an I/O completion port associated w/it, then</span>
00185             <span class="comment">// ensure that the caller did not supply an APC routine, as the</span>
00186             <span class="comment">// two are mutually exclusive methods for I/O completion</span>
00187             <span class="comment">// notification.</span>
00188             <span class="comment">//</span>
00189 
00190             <span class="keywordflow">if</span> (fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o26">CompletionContext</a> &amp;&amp; <a class="code" href="../../d0/d6/iop_8h.html#a19">IopApcRoutinePresent</a>( ApcRoutine )) {
00191                 <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
00192                 <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
00193             }
00194 
00195         } except(EXCEPTION_EXECUTE_HANDLER) {
00196 
00197             <span class="comment">//</span>
00198             <span class="comment">// An exception was incurred attempting to probe the caller's</span>
00199             <span class="comment">// parameters.  Dereference the file object and return an</span>
00200             <span class="comment">// appropriate error status code.</span>
00201             <span class="comment">//</span>
00202 
00203             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
00204             <span class="keywordflow">return</span> GetExceptionCode();
00205         }
00206 
00207     } <span class="keywordflow">else</span> {
00208 
00209         <span class="comment">//</span>
00210         <span class="comment">// The caller's mode was kernel.  Get the ByteOffset and Length</span>
00211         <span class="comment">// parameter 's to the expected locations.</span>
00212         <span class="comment">//</span>
00213 
00214         fileOffset = *ByteOffset;
00215         length = *Length;
00216     }
00217 
00218     <span class="comment">//</span>
00219     <span class="comment">// Get the address of the event object and set the event to the Not-</span>
00220     <span class="comment">// Signaled state, if an event was specified.  Note here, too, that if</span>
00221     <span class="comment">// the handle does not refer to an event, or if the event cannot be</span>
00222     <span class="comment">// written, then the reference will fail.  Since certain legacy</span>
00223     <span class="comment">// applications rely on an old bug in Win32's LockFileEx, we must</span>
00224     <span class="comment">// tolerate bad event handles.</span>
00225     <span class="comment">//</span>
00226 
00227     <span class="keywordflow">if</span> (ARGUMENT_PRESENT( Event )) {
00228         status = <a class="code" href="../../d7/d1/obref_8c.html#a4">ObReferenceObjectByHandle</a>( Event,
00229                                             EVENT_MODIFY_STATE,
00230                                             ExEventObjectType,
00231                                             requestorMode,
00232                                             (PVOID *) &amp;eventObject,
00233                                             NULL );
00234         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
00235             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( !eventObject );
00236         } <span class="keywordflow">else</span> {
00237             <a class="code" href="../../d4/d9/ke_8h.html#a21">KeClearEvent</a>( eventObject );
00238         }
00239     }
00240 
00241     <span class="comment">//</span>
00242     <span class="comment">// Get the address of the target device object and the fast Io dispatch</span>
00243     <span class="comment">// structure.</span>
00244     <span class="comment">//</span>
00245 
00246     deviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a76">IoGetRelatedDeviceObject</a>( fileObject );
00247     fastIoDispatch = deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o3">DriverObject</a>-&gt;<a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html#o10">FastIoDispatch</a>;
00248 
00249     <span class="comment">//</span>
00250     <span class="comment">// Turbo lock support.  If the fast Io Dispatch specifies a fast lock</span>
00251     <span class="comment">// routine then we'll first try and calling it with the specified lock</span>
00252     <span class="comment">// parameters.</span>
00253     <span class="comment">//</span>
00254 
00255     <span class="keywordflow">if</span> (fastIoDispatch &amp;&amp; fastIoDispatch-&gt;<a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html#o6">FastIoLock</a>) {
00256 
00257         IO_STATUS_BLOCK localIoStatus;
00258 
00259         <span class="keywordflow">if</span> (fastIoDispatch-&gt;<a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html#o6">FastIoLock</a>( fileObject,
00260                                         &amp;fileOffset,
00261                                         &amp;length,
00262                                         <a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a>(),
00263                                         Key,
00264                                         FailImmediately,
00265                                         ExclusiveLock,
00266                                         &amp;localIoStatus,
00267                                         deviceObject )) {
00268 
00269             <span class="comment">//</span>
00270             <span class="comment">// Carefully return the I/O status.</span>
00271             <span class="comment">//</span>
00272 
00273             <span class="keywordflow">try</span> {
00274                 *IoStatusBlock = localIoStatus;
00275             } except( EXCEPTION_EXECUTE_HANDLER ) {
00276                 localIoStatus.Status = GetExceptionCode();
00277                 localIoStatus.Information = 0;
00278             }
00279 
00280             <span class="comment">//</span>
00281             <span class="comment">// If a valid event was specified, set it.</span>
00282             <span class="comment">//</span>
00283 
00284             <span class="keywordflow">if</span> (eventObject) {
00285                 <a class="code" href="../../d2/d8/eventobj_8c.html#a8">KeSetEvent</a>( eventObject, 0, FALSE );
00286                 <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( eventObject );
00287             }
00288 
00289             <span class="comment">//</span>
00290             <span class="comment">// Note that the file object event need not be set to the</span>
00291             <span class="comment">// Signaled state, as it is already set.</span>
00292             <span class="comment">//</span>
00293 
00294             <span class="comment">//</span>
00295             <span class="comment">// If this file object has a completion port associated with it</span>
00296             <span class="comment">// and this request has a non-NULL APC context then a completion</span>
00297             <span class="comment">// message needs to be queued.</span>
00298             <span class="comment">//</span>
00299 
00300             <span class="keywordflow">if</span> (fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o26">CompletionContext</a> &amp;&amp; ARGUMENT_PRESENT( ApcContext )) {
00301                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d5/d4/complete_8c.html#a6">IoSetIoCompletion</a>( fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o26">CompletionContext</a>-&gt;<a class="code" href="../../d2/d4/struct__IO__COMPLETION__CONTEXT.html#o0">Port</a>,
00302                                                    fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o26">CompletionContext</a>-&gt;<a class="code" href="../../d2/d4/struct__IO__COMPLETION__CONTEXT.html#o1">Key</a>,
00303                                                    ApcContext,
00304                                                    localIoStatus.Status,
00305                                                    localIoStatus.Information,
00306                                                    TRUE ))) {
00307                     localIoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
00308                 }
00309             }
00310 
00311             <span class="comment">//</span>
00312             <span class="comment">// Cleanup and return.</span>
00313             <span class="comment">//</span>
00314 
00315             fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o10">LockOperation</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00316             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
00317             <span class="keywordflow">return</span> localIoStatus.Status;
00318         }
00319     }
00320 
00321     <span class="comment">//</span>
00322     <span class="comment">// Make a special check here to determine whether this is a synchronous</span>
00323     <span class="comment">// I/O operation.  If it is, then wait here until the file is owned by</span>
00324     <span class="comment">// the current thread.</span>
00325     <span class="comment">//</span>
00326 
00327     <span class="keywordflow">if</span> (fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a151">FO_SYNCHRONOUS_IO</a>) {
00328 
00329         BOOLEAN interrupted;
00330 
00331         <span class="keywordflow">if</span> (!<a class="code" href="../../d0/d6/iop_8h.html#a13">IopAcquireFastLock</a>( fileObject )) {
00332             status = <a class="code" href="../../d0/d6/iop_8h.html#a147">IopAcquireFileObjectLock</a>( fileObject,
00333                                                requestorMode,
00334                                                (BOOLEAN) ((fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> &amp; FO_ALERTABLE_IO) != 0),
00335                                                &amp;interrupted );
00336             <span class="keywordflow">if</span> (interrupted) {
00337                 <span class="keywordflow">if</span> (eventObject) {
00338                     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( eventObject );
00339                 }
00340                 <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
00341                 <span class="keywordflow">return</span> status;
00342             }
00343         }
00344         synchronousIo = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00345     } <span class="keywordflow">else</span> {
00346         synchronousIo = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00347     }
00348 
00349     <span class="comment">//</span>
00350     <span class="comment">// Set the file object to the Not-Signaled state and mark it as having had</span>
00351     <span class="comment">// a lock operation performed on it.</span>
00352     <span class="comment">//</span>
00353 
00354     <a class="code" href="../../d4/d9/ke_8h.html#a21">KeClearEvent</a>( &amp;fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o25">Event</a> );
00355     fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o10">LockOperation</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00356 
00357     <span class="comment">//</span>
00358     <span class="comment">// Allocate and initialize the I/O Request Packet (IRP) for this operation.</span>
00359     <span class="comment">// The allocation is performed with an exception handler in case the</span>
00360     <span class="comment">// caller does not have enough quota to allocate the packet.</span>
00361 
00362     irp = <a class="code" href="../../d4/d6/iosubs_8c.html#a17">IoAllocateIrp</a>( deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o13">StackSize</a>, TRUE );
00363     <span class="keywordflow">if</span> (!irp) {
00364 
00365         <span class="comment">//</span>
00366         <span class="comment">// An IRP could not be allocated.  Cleanup and return an appropriate</span>
00367         <span class="comment">// error status code.</span>
00368         <span class="comment">//</span>
00369 
00370         <a class="code" href="../../d0/d6/iop_8h.html#a148">IopAllocateIrpCleanup</a>( fileObject, eventObject );
00371 
00372         <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
00373     }
00374     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.OriginalFileObject = fileObject;
00375     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.Thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
00376     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o10">RequestorMode</a> = requestorMode;
00377 
00378     <span class="comment">//</span>
00379     <span class="comment">// Fill in the service independent parameters in the IRP.</span>
00380     <span class="comment">//</span>
00381 
00382     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o19">UserEvent</a> = eventObject;
00383     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o18">UserIosb</a> = IoStatusBlock;
00384     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o24">Overlay</a>.AsynchronousParameters.UserApcRoutine = ApcRoutine;
00385     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o24">Overlay</a>.AsynchronousParameters.UserApcContext = ApcContext;
00386 
00387     <span class="comment">//</span>
00388     <span class="comment">// Get a pointer to the stack location for the first driver.  This will be</span>
00389     <span class="comment">// used to pass the original function codes and parameters.</span>
00390     <span class="comment">//</span>
00391 
00392     irpSp = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>( irp );
00393     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a> = <a class="code" href="../../d0/d5/io_8h.html#a30">IRP_MJ_LOCK_CONTROL</a>;
00394     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o1">MinorFunction</a> = <a class="code" href="../../d0/d5/io_8h.html#a52">IRP_MN_LOCK</a>;
00395     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a> = fileObject;
00396 
00397     <span class="comment">//</span>
00398     <span class="comment">// Copy the caller's parameters to the service-specific portion of the</span>
00399     <span class="comment">// IRP.</span>
00400     <span class="comment">//</span>
00401 
00402     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o2">Flags</a> = 0;
00403     <span class="keywordflow">if</span> (FailImmediately) {
00404         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o2">Flags</a> = <a class="code" href="../../d0/d5/io_8h.html#a206">SL_FAIL_IMMEDIATELY</a>;
00405     }
00406     <span class="keywordflow">if</span> (ExclusiveLock) {
00407         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o2">Flags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a207">SL_EXCLUSIVE_LOCK</a>;
00408     }
00409     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.LockControl.Key = <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a51">Key</a>;
00410     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.LockControl.ByteOffset = fileOffset;
00411 
00412     <span class="keywordflow">try</span> {
00413         PLARGE_INTEGER lengthBuffer;
00414 
00415         <span class="comment">//</span>
00416         <span class="comment">// Attempt to allocate an intermediary buffer to hold the length of</span>
00417         <span class="comment">// this lock operation.  If it fails, either because there is no</span>
00418         <span class="comment">// more quota, or because there are no more resources, then the</span>
00419         <span class="comment">// exception handler will be invoked to cleanup and exit.</span>
00420         <span class="comment">//</span>
00421 
00422         lengthBuffer = <a class="code" href="../../d5/d5/cc_8h.html#a11">ExAllocatePoolWithQuota</a>( NonPagedPool,
00423                                                 <span class="keyword">sizeof</span>( LARGE_INTEGER ) );
00424 
00425         *lengthBuffer = length;
00426         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.AuxiliaryBuffer = (PCHAR) lengthBuffer;
00427         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.LockControl.Length = lengthBuffer;
00428     } except(EXCEPTION_EXECUTE_HANDLER) {
00429 
00430         <span class="comment">//</span>
00431         <span class="comment">// An exception was incurred.  Simply clean everything up and</span>
00432         <span class="comment">// return an appropriate error status code.</span>
00433         <span class="comment">//</span>
00434 
00435         <a class="code" href="../../d0/d6/iop_8h.html#a170">IopExceptionCleanup</a>( fileObject,
00436                              irp,
00437                              eventObject,
00438                              (<a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>) NULL );
00439 
00440         <span class="keywordflow">return</span> GetExceptionCode();
00441     }
00442 
00443     <span class="comment">//</span>
00444     <span class="comment">// Queue the packet, call the driver, and synchronize appopriately with</span>
00445     <span class="comment">// I/O completion.</span>
00446     <span class="comment">//</span>
00447 
00448     <span class="keywordflow">return</span> <a class="code" href="../../d0/d6/iop_8h.html#a212">IopSynchronousServiceTail</a>( deviceObject,
00449                                       irp,
00450                                       fileObject,
00451                                       FALSE,
00452                                       requestorMode,
00453                                       synchronousIo,
00454                                       OtherTransfer );
00455 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a1" doxytag="lock.c::NtUnlockFile" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS NtUnlockFile           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN HANDLE&nbsp;</td>
          <td class="mdname" nowrap> <em>FileHandle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PIO_STATUS_BLOCK&nbsp;</td>
          <td class="mdname" nowrap> <em>IoStatusBlock</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PLARGE_INTEGER&nbsp;</td>
          <td class="mdname" nowrap> <em>ByteOffset</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PLARGE_INTEGER&nbsp;</td>
          <td class="mdname" nowrap> <em>Length</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Key</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d2/d4/lock_8c-source.html#l00458">458</a> of file <a class="el" href="../../d2/d4/lock_8c-source.html">lock.c</a>.
<p>
References <a class="el" href="../../d1/d4/io_8h-source.html#l01179">_DEVICE_OBJECT::DriverObject</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00126">ExAllocatePool</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00127">ExAllocatePoolWithQuota</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00055">EXCEPTION_EXECUTE_HANDLER</a>, <a class="el" href="../../d7/d2/cmwraper_8c-source.html#l00304">ExFreePool()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01403">_DRIVER_OBJECT::FastIoDispatch</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l00949">_FAST_IO_DISPATCH::FastIoUnlockSingle</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02494">_IO_STACK_LOCATION::FileObject</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01602">_IRP::Flags</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01492">FO_ALERTABLE_IO</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01501">FO_DIRECT_DEVICE_OPEN</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01491">FO_SYNCHRONOUS_IO</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00057">_OBJECT_HANDLE_INFORMATION::GrantedAccess</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l00652">IoAllocateIrp()</a>, <a class="el" href="../../d6/d7/fssup_8c-source.html#l00044">IoFileObjectType</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l06786">IoGetAttachedDevice()</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l03398">IoGetNextIrpStackLocation</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l07247">IoGetRelatedDeviceObject()</a>, <a class="el" href="../../d1/d5/iop_8h-source.html#l00595">IopAcquireFastLock</a>, <a class="el" href="../../d3/d3/internal_8c-source.html#l00181">IopAcquireFileObjectLock()</a>, <a class="el" href="../../d3/d3/internal_8c-source.html#l00284">IopAllocateIrpCleanup()</a>, <a class="el" href="../../d3/d3/internal_8c-source.html#l01934">IopExceptionCleanup()</a>, <a class="el" href="../../d3/d3/internal_8c-source.html#l06926">IopSynchronousApiServiceTail()</a>, <a class="el" href="../../d3/d3/internal_8c-source.html#l07030">IopSynchronousServiceTail()</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l00072">IRP_MJ_LOCK_CONTROL</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l00124">IRP_MN_UNLOCK_SINGLE</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01552">IRP_SYNCHRONOUS_API</a>, <a class="el" href="../../d5/d8/ke_8h-source.html#l01072">KeClearEvent</a>, <a class="el" href="../../d5/d8/ke_8h-source.html#l01066">KeInitializeEvent</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00624">KernelMode</a>, <a class="el" href="../../d3/d9/nt6_2user32_8def-source.html#l00417">Key</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00174">KPROCESSOR_MODE</a>, <a class="el" href="../../d3/d9/aw_8h-source.html#l00031">L</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02028">_IO_STACK_LOCATION::MajorFunction</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02029">_IO_STACK_LOCATION::MinorFunction</a>, <a class="el" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00494">ObDereferenceObject</a>, <a class="el" href="../../d8/d0/obref_8c-source.html#l00542">ObReferenceObjectByHandle()</a>, <a class="el" href="../../d0/d6/iop_8h.html#a240a140">OtherTransfer</a>, <a class="el" href="../../d0/d2/struct__IRP.html#o24">_IRP::Overlay</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02069">_IO_STACK_LOCATION::Parameters</a>, <a class="el" href="../../d6/d7/ex_8h-source.html#l01209">ProbeForRead</a>, <a class="el" href="../../d6/d7/ex_8h-source.html#l01498">ProbeForWriteIoStatus</a>, <a class="el" href="../../d2/d8/ps_8h-source.html#l00643">PsGetCurrentProcess</a>, <a class="el" href="../../d2/d8/ps_8h-source.html#l00645">PsGetCurrentThread</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01641">_IRP::RequestorMode</a>, <a class="el" href="../../d1/d4/se_8h-source.html#l00515">SeComputeGrantedAccesses</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01189">_DEVICE_OBJECT::StackSize</a>, <a class="el" href="../../d0/d2/struct__IRP.html#o38">_IRP::Tail</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01687">_IRP::UserEvent</a>, and <a class="el" href="../../d1/d4/io_8h-source.html#l01686">_IRP::UserIosb</a>.
<p>
<pre class="fragment"><div>00468                    :
00469 
00470     This service releases <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> lock associated with <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified byte range
00471     <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> specified by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> FileHandle parameter.
00472 
00473 Arguments:
00474 
00475     FileHandle - Supplies a handle to an open <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a>.
00476 
00477     IoStatusBlock - Address of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller's I/O status block.
00478 
00479     ByteOffset - Specifies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> byte offset of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> range to unlock.
00480 
00481     Length - Specifies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> length of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> byte range to unlock.
00482 
00483     <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a51">Key</a> - Specifies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> key associated with <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> locked range.
00484 
00485 Return Value:
00486 
00487     The status returned <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <span class="keyword">final</span> completion status of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> operation.
00488 
00489 --*/
00490 
00491 {
00492     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
00493     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
00494     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> fileObject;
00495     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> deviceObject;
00496     <a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html">PFAST_IO_DISPATCH</a> fastIoDispatch;
00497     <a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a> event;
00498     <a class="code" href="../../d0/d9/ntosdef_8h.html#a39">KPROCESSOR_MODE</a> requestorMode;
00499     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpSp;
00500     IO_STATUS_BLOCK localIoStatus;
00501     LARGE_INTEGER fileOffset;
00502     LARGE_INTEGER length;
00503     ACCESS_MASK grantedAccess;
00504     <a class="code" href="../../d3/d5/struct__OBJECT__HANDLE__INFORMATION.html">OBJECT_HANDLE_INFORMATION</a> handleInformation;
00505     BOOLEAN synchronousIo;
00506 
00507     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00508 
00509     <span class="comment">//</span>
00510     <span class="comment">// Get the previous mode;  i.e., the mode of the caller.</span>
00511     <span class="comment">//</span>
00512 
00513     requestorMode = KeGetPreviousMode();
00514 
00515     <span class="comment">//</span>
00516     <span class="comment">// Reference the file object so the target device can be found and the</span>
00517     <span class="comment">// access rights mask can be used in the following checks for callers</span>
00518     <span class="comment">// in user mode.  Note that if the handle does not refer to a file</span>
00519     <span class="comment">// object, then it will fail.</span>
00520     <span class="comment">//</span>
00521 
00522     status = <a class="code" href="../../d7/d1/obref_8c.html#a4">ObReferenceObjectByHandle</a>( FileHandle,
00523                                         0L,
00524                                         IoFileObjectType,
00525                                         requestorMode,
00526                                         (PVOID *) &amp;fileObject,
00527                                         &amp;handleInformation);
00528     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
00529         <span class="keywordflow">return</span> status;
00530     }
00531 
00532     grantedAccess = handleInformation.<a class="code" href="../../d3/d5/struct__OBJECT__HANDLE__INFORMATION.html#o1">GrantedAccess</a>;
00533 
00534     <span class="comment">//</span>
00535     <span class="comment">// Check to see if the requestor mode was user.  If so, perform a bunch</span>
00536     <span class="comment">// of extra checks.</span>
00537     <span class="comment">//</span>
00538 
00539     <span class="keywordflow">if</span> (requestorMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
00540 
00541         <span class="comment">//</span>
00542         <span class="comment">// The caller's access mode is not kernel so probe each of the arguments</span>
00543         <span class="comment">// and capture them as necessary.  If any failures occur, the condition</span>
00544         <span class="comment">// handler will be invoked to handle them.  It will simply cleanup and</span>
00545         <span class="comment">// return an access violation status code back to the system service</span>
00546         <span class="comment">// dispatcher.</span>
00547         <span class="comment">//</span>
00548 
00549         <span class="comment">//</span>
00550         <span class="comment">// Check to ensure that the caller has either READ or WRITE access</span>
00551         <span class="comment">// to the file.  If not, cleanup and return an error.</span>
00552         <span class="comment">//</span>
00553 
00554         <span class="keywordflow">if</span> (!<a class="code" href="../../d0/d5/se_8h.html#a9">SeComputeGrantedAccesses</a>( grantedAccess, FILE_READ_DATA | FILE_WRITE_DATA )) {
00555             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
00556             <span class="keywordflow">return</span> STATUS_ACCESS_DENIED;
00557         }
00558 
00559         <span class="keywordflow">try</span> {
00560 
00561             <span class="comment">//</span>
00562             <span class="comment">// The IoStatusBlock parameter must be writeable by the caller.</span>
00563             <span class="comment">//</span>
00564 
00565             <a class="code" href="../../d5/d8/ex_8h.html#a31">ProbeForWriteIoStatus</a>( IoStatusBlock );
00566 
00567             <span class="comment">//</span>
00568             <span class="comment">// The ByteOffset parameter must be readable by the caller.  Probe</span>
00569             <span class="comment">// and capture it.</span>
00570             <span class="comment">//</span>
00571 
00572             <a class="code" href="../../d5/d8/ex_8h.html#a11">ProbeForRead</a>( ByteOffset,
00573                           <span class="keyword">sizeof</span>( LARGE_INTEGER ),
00574                           <span class="keyword">sizeof</span>( ULONG ) );
00575             fileOffset = *ByteOffset;
00576 
00577             <span class="comment">//</span>
00578             <span class="comment">// Likewise, the Length parameter must also be readable by the</span>
00579             <span class="comment">// caller.  Probe and capture it as well.</span>
00580             <span class="comment">//</span>
00581 
00582             <a class="code" href="../../d5/d8/ex_8h.html#a11">ProbeForRead</a>( Length,
00583                           <span class="keyword">sizeof</span>( LARGE_INTEGER ),
00584                           <span class="keyword">sizeof</span>( ULONG ) );
00585             length = *Length;
00586 
00587         } except(EXCEPTION_EXECUTE_HANDLER) {
00588 
00589             <span class="comment">//</span>
00590             <span class="comment">// An exception was incurred while attempting to probe the</span>
00591             <span class="comment">// caller's parameters.  Dereference the file object and return</span>
00592             <span class="comment">// an appropriate error status code.</span>
00593             <span class="comment">//</span>
00594 
00595             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
00596             <span class="keywordflow">return</span> GetExceptionCode();
00597 
00598         }
00599 
00600     } <span class="keywordflow">else</span> {
00601 
00602         <span class="comment">//</span>
00603         <span class="comment">// The caller's mode was kernel.  Get the ByteOffset and Length</span>
00604         <span class="comment">// parameter 's to the expected locations.</span>
00605         <span class="comment">//</span>
00606 
00607         fileOffset = *ByteOffset;
00608         length = *Length;
00609     }
00610 
00611     <span class="comment">//</span>
00612     <span class="comment">// Get the address of the target device object.  If this file represents</span>
00613     <span class="comment">// a device that was opened directly, then simply use the device or its</span>
00614     <span class="comment">// attached device(s) directly.  Also get the fast I/O dispatch address.</span>
00615     <span class="comment">//</span>
00616 
00617     <span class="keywordflow">if</span> (!(fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a161">FO_DIRECT_DEVICE_OPEN</a>)) {
00618         deviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a76">IoGetRelatedDeviceObject</a>( fileObject );
00619     } <span class="keywordflow">else</span> {
00620         deviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a66">IoGetAttachedDevice</a>( fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o2">DeviceObject</a> );
00621     }
00622     fastIoDispatch = deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o3">DriverObject</a>-&gt;<a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html#o10">FastIoDispatch</a>;
00623 
00624     <span class="comment">//</span>
00625     <span class="comment">// Turbo lock support.  If the fast Io Dispatch specifies a fast lock</span>
00626     <span class="comment">// routine then we'll first try and calling it with the specified lock</span>
00627     <span class="comment">// parameters.</span>
00628     <span class="comment">//</span>
00629 
00630     <span class="keywordflow">if</span> (fastIoDispatch &amp;&amp; fastIoDispatch-&gt;<a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html#o7">FastIoUnlockSingle</a>) {
00631 
00632         IO_STATUS_BLOCK localIoStatus;
00633 
00634         <span class="keywordflow">if</span> (fastIoDispatch-&gt;<a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html#o7">FastIoUnlockSingle</a>( fileObject,
00635                                                 &amp;fileOffset,
00636                                                 &amp;length,
00637                                                 <a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a>(),
00638                                                 Key,
00639                                                 &amp;localIoStatus,
00640                                                 deviceObject )) {
00641 
00642             <span class="comment">//</span>
00643             <span class="comment">// Carefully return the I/O status.</span>
00644             <span class="comment">//</span>
00645 
00646             <span class="keywordflow">try</span> {
00647                 *IoStatusBlock = localIoStatus;
00648             } except( EXCEPTION_EXECUTE_HANDLER ) {
00649                 localIoStatus.Status = GetExceptionCode();
00650                 localIoStatus.Information = 0;
00651             }
00652 
00653             <span class="comment">//</span>
00654             <span class="comment">// Cleanup and return.</span>
00655             <span class="comment">//</span>
00656 
00657             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
00658             <span class="keywordflow">return</span> localIoStatus.Status;
00659         }
00660     }
00661 
00662     <span class="comment">//</span>
00663     <span class="comment">// Make a special check here to determine whether this is a synchronous</span>
00664     <span class="comment">// I/O operation.  If it is, then wait here until the file is owned by</span>
00665     <span class="comment">// the current thread.  If this is not a (serialized) synchronous I/O</span>
00666     <span class="comment">// operation, then allocate and initialize the local event.</span>
00667     <span class="comment">//</span>
00668 
00669     <span class="keywordflow">if</span> (fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a151">FO_SYNCHRONOUS_IO</a>) {
00670 
00671         BOOLEAN interrupted;
00672 
00673         <span class="keywordflow">if</span> (!<a class="code" href="../../d0/d6/iop_8h.html#a13">IopAcquireFastLock</a>( fileObject )) {
00674             status = <a class="code" href="../../d0/d6/iop_8h.html#a147">IopAcquireFileObjectLock</a>( fileObject,
00675                                                requestorMode,
00676                                                (BOOLEAN) ((fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> &amp; FO_ALERTABLE_IO) != 0),
00677                                                &amp;interrupted );
00678             <span class="keywordflow">if</span> (interrupted) {
00679                 <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
00680                 <span class="keywordflow">return</span> status;
00681             }
00682         }
00683         synchronousIo = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00684     } <span class="keywordflow">else</span> {
00685 
00686         <span class="comment">//</span>
00687         <span class="comment">// This is a synchronous API being invoked for a file that is opened</span>
00688         <span class="comment">// for asynchronous I/O.  This means that this system service is</span>
00689         <span class="comment">// to synchronize the completion of the operation before returning</span>
00690         <span class="comment">// to the caller.  A local event is used to do this.</span>
00691         <span class="comment">//</span>
00692 
00693         event = <a class="code" href="../../d5/d5/cc_8h.html#a10">ExAllocatePool</a>( NonPagedPool, <span class="keyword">sizeof</span>( <a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a> ) );
00694         <span class="keywordflow">if</span> (event == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00695             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
00696             <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
00697         }
00698         <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( event, SynchronizationEvent, FALSE );
00699         synchronousIo = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00700     }
00701 
00702     <span class="comment">//</span>
00703     <span class="comment">// Set the file object to the Not-Signaled state.</span>
00704     <span class="comment">//</span>
00705 
00706     <a class="code" href="../../d4/d9/ke_8h.html#a21">KeClearEvent</a>( &amp;fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o25">Event</a> );
00707 
00708     <span class="comment">//</span>
00709     <span class="comment">// Allocate and initialize the I/O Request Packet (IRP) for this operation.</span>
00710     <span class="comment">// The allocation is performed with an exception handler in case the</span>
00711     <span class="comment">// caller does not have enough quota to allocate the packet.</span>
00712     <span class="comment">//</span>
00713 
00714     irp = <a class="code" href="../../d4/d6/iosubs_8c.html#a17">IoAllocateIrp</a>( deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o13">StackSize</a>, TRUE );
00715     <span class="keywordflow">if</span> (!irp) {
00716 
00717         <span class="comment">//</span>
00718         <span class="comment">// An IRP could not be allocated.  Cleanup and return an appropriate</span>
00719         <span class="comment">// error status code.</span>
00720         <span class="comment">//</span>
00721 
00722         <span class="keywordflow">if</span> (!(fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a151">FO_SYNCHRONOUS_IO</a>)) {
00723             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( event );
00724         }
00725 
00726         <a class="code" href="../../d0/d6/iop_8h.html#a148">IopAllocateIrpCleanup</a>( fileObject, (<a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>) NULL );
00727 
00728         <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
00729     }
00730     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.OriginalFileObject = fileObject;
00731     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.Thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
00732     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o10">RequestorMode</a> = requestorMode;
00733 
00734     <span class="comment">//</span>
00735     <span class="comment">// Fill in the service independent parameters in the IRP.</span>
00736     <span class="comment">//</span>
00737 
00738     <span class="keywordflow">if</span> (synchronousIo) {
00739         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o19">UserEvent</a> = (<a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00740         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o18">UserIosb</a> = IoStatusBlock;
00741     } <span class="keywordflow">else</span> {
00742         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o19">UserEvent</a> = event;
00743         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o18">UserIosb</a> = &amp;localIoStatus;
00744         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> = <a class="code" href="../../d0/d5/io_8h.html#a176">IRP_SYNCHRONOUS_API</a>;
00745     }
00746     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o24">Overlay</a>.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00747 
00748     <span class="comment">//</span>
00749     <span class="comment">// Get a pointer to the stack location for the first driver.  This will</span>
00750     <span class="comment">// be used to pass the original function codes and parameters.</span>
00751     <span class="comment">//</span>
00752 
00753     irpSp = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>( irp );
00754     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a> = <a class="code" href="../../d0/d5/io_8h.html#a30">IRP_MJ_LOCK_CONTROL</a>;
00755     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o1">MinorFunction</a> = <a class="code" href="../../d0/d5/io_8h.html#a53">IRP_MN_UNLOCK_SINGLE</a>;
00756     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a> = fileObject;
00757 
00758     <span class="keywordflow">try</span> {
00759         PLARGE_INTEGER lengthBuffer;
00760 
00761         <span class="comment">//</span>
00762         <span class="comment">// Attempt to allocate an intermediary buffer to hold the length of</span>
00763         <span class="comment">// this lock operation.  If it fails, either because there is no</span>
00764         <span class="comment">// more quota, or because there are no more resources, then the</span>
00765         <span class="comment">// exception handler will be invoked to cleanup and exit.</span>
00766         <span class="comment">//</span>
00767 
00768         lengthBuffer = <a class="code" href="../../d5/d5/cc_8h.html#a11">ExAllocatePoolWithQuota</a>( NonPagedPool,
00769                                                 <span class="keyword">sizeof</span>( LARGE_INTEGER ) );
00770 
00771         *lengthBuffer = length;
00772         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.AuxiliaryBuffer = (PCHAR) lengthBuffer;
00773         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.LockControl.Length = lengthBuffer;
00774     } except(EXCEPTION_EXECUTE_HANDLER) {
00775 
00776         <span class="comment">//</span>
00777         <span class="comment">// An exception was incurred.  Simply clean everything up and</span>
00778         <span class="comment">// return an appropriate error status code.</span>
00779         <span class="comment">//</span>
00780 
00781         <span class="keywordflow">if</span> (!(fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a151">FO_SYNCHRONOUS_IO</a>)) {
00782             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( event );
00783         }
00784   
00785         <a class="code" href="../../d0/d6/iop_8h.html#a170">IopExceptionCleanup</a>( fileObject,
00786                              irp,
00787                              NULL,
00788                              (<a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>) NULL );
00789 
00790         <span class="keywordflow">return</span> GetExceptionCode();
00791     }
00792 
00793     <span class="comment">//</span>
00794     <span class="comment">// Copy the caller's parameters to the service-specific portion of the</span>
00795     <span class="comment">// IRP.</span>
00796     <span class="comment">//</span>
00797 
00798     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.LockControl.Key = <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a51">Key</a>;
00799     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.LockControl.ByteOffset = fileOffset;
00800 
00801     <span class="comment">//</span>
00802     <span class="comment">// Queue the packet, call the driver, and synchronize appopriately with</span>
00803     <span class="comment">// I/O completion.</span>
00804     <span class="comment">//</span>
00805 
00806     status = <a class="code" href="../../d0/d6/iop_8h.html#a212">IopSynchronousServiceTail</a>( deviceObject,
00807                                         irp,
00808                                         fileObject,
00809                                         FALSE,
00810                                         requestorMode,
00811                                         synchronousIo,
00812                                         OtherTransfer );
00813 
00814     <span class="comment">//</span>
00815     <span class="comment">// If the file for this operation was not opened for synchronous I/O, then</span>
00816     <span class="comment">// synchronization of completion of the I/O operation has not yet occurred</span>
00817     <span class="comment">// since the allocated event must be used for synchronous APIs on files</span>
00818     <span class="comment">// opened for asynchronous I/O.  Synchronize the completion of the I/O</span>
00819     <span class="comment">// operation now.</span>
00820     <span class="comment">//</span>
00821 
00822     <span class="keywordflow">if</span> (!synchronousIo) {
00823 
00824         status = <a class="code" href="../../d0/d6/iop_8h.html#a211">IopSynchronousApiServiceTail</a>( status,
00825                                                event,
00826                                                irp,
00827                                                requestorMode,
00828                                                &amp;localIoStatus,
00829                                                IoStatusBlock );
00830     }
00831 
00832     <span class="keywordflow">return</span> status;
00833 }
}
</div></pre>    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:44:33 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
