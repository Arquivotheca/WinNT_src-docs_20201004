<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: emulx86.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>emulx86.c</h1><a href="../../d0/d6/emulx86_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1989  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    emulx86.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module implements all of the x86 opcode handling regardles of which</span>
00012 <span class="comment">    mode the trap occured in (V86, protected, etc.). It is basically</span>
00013 <span class="comment">    a combination of instemul.asm and emv86.asm from the .../ke/i386</span>
00014 <span class="comment">    directory</span>
00015 <span class="comment"></span>
00016 <span class="comment">Author:</span>
00017 <span class="comment"></span>
00018 <span class="comment">    Charles Spirakis (intel) 1 Feb 1996</span>
00019 <span class="comment"></span>
00020 <span class="comment">Environment:</span>
00021 <span class="comment"></span>
00022 <span class="comment">    Kernel mode only.</span>
00023 <span class="comment"></span>
00024 <span class="comment">Revision History:</span>
00025 <span class="comment"></span>
00026 <span class="comment"></span>
00027 <span class="comment">--*/</span>
00028 
00029 <span class="preprocessor">#include "<a class="code" href="../../d0/d0/ki_8h.html">ki.h</a>"</span>
00030 <span class="preprocessor">#include "<a class="code" href="../../d8/d3/ia32def_8h.html">ia32def.h</a>"</span>
00031 <span class="preprocessor">#include "<a class="code" href="../../d1/d5/vdmntos_8h.html">vdmntos.h</a>"</span>
00032 
00033 <span class="preprocessor">#if DEVL</span>
00034 <span class="preprocessor"></span>ULONG ExVdmOpcodeDispatchCounts[MAX_VDM_INDEX];
00035 ULONG ExVdmSegmentNotPresent;
00036 <span class="preprocessor">#endif</span>
00037 <span class="preprocessor"></span>
<a name="l00038"></a><a class="code" href="../../d0/d6/emulx86_8c.html#a0">00038</a> <span class="keyword">extern</span> ULONG <a class="code" href="../../d0/d6/emulx86_8c.html#a0">KeIA32EFlagsAndMaskV86</a>;
<a name="l00039"></a><a class="code" href="../../d0/d6/emulx86_8c.html#a1">00039</a> <span class="keyword">extern</span> ULONG <a class="code" href="../../d0/d6/emulx86_8c.html#a1">KeIA32EFlagsOrMaskV86</a>;
<a name="l00040"></a><a class="code" href="../../d0/d6/emulx86_8c.html#a2">00040</a> <span class="keyword">extern</span> BOOLEAN <a class="code" href="../../d0/d6/emulx86_8c.html#a2">KeIA32VdmIoplAllowed</a>;
<a name="l00041"></a><a class="code" href="../../d0/d6/emulx86_8c.html#a3">00041</a> <span class="keyword">extern</span> ULONG <a class="code" href="../../d0/d6/emulx86_8c.html#a3">KeIA32VirtualIntExtensions</a>;
00042 
00043 <span class="preprocessor">#if defined(WX86) &amp;&amp; defined(TRY_NTVDM)</span>
00044 <span class="preprocessor"></span><span class="comment">//</span>
00045 <span class="comment">// These are external functions....</span>
00046 <span class="comment">//</span>
00047 
00048 BOOLEAN
00049 KiIA32VdmDispatchIo(
00050     IN ULONG PortNumber,
00051     IN ULONG Size,
00052     IN BOOLEAN Read,
00053     IN UCHAR InstructionSize,
00054     IN PKIA32_FRAME TrapFrame
00055     );
00056 
00057 BOOLEAN
00058 KiIA32VdmDispatchStringIo(
00059     IN ULONG PortNumber,
00060     IN ULONG Size,
00061     IN BOOLEAN Rep,
00062     IN BOOLEAN Read,
00063     IN ULONG Count,
00064     IN ULONG Address,
00065     IN UCHAR InstructionSize,
00066     IN PKIA32_FRAME TrapFrame
00067     );
00068 
00069 
00070 <span class="comment">//</span>
00071 <span class="comment">// Declare non-ke and non-ki function prototypes</span>
00072 <span class="comment">//</span>
00073 BOOLEAN
00074 PushInt(
00075     IN ULONG InterruptNumber,
00076     IN OUT PREGINFO Regs
00077     );
00078 
00079 BOOLEAN
00080 PushException(
00081     IN ULONG ExceptionNumber,
00082     IN OUT PREGINFO Regs
00083     );
00084 
00085 BOOLEAN
00086 CsToLinear(
00087     IN OUT PREGINFO Regs,
00088     IN BOOLEAN IsV86
00089     );
00090 
00091 BOOLEAN
00092 SsToLinear(
00093     IN OUT PREGINFO Regs,
00094     IN BOOLEAN IsV86
00095     );
00096 
00097 BOOLEAN
00098 CheckEip(
00099     IN PREGINFO Regs
00100     );
00101 
00102 BOOLEAN
00103 CheckEsp(
00104     IN PREGINFO Regs,
00105     IN ULONG StackNeeded
00106     );
00107 
00108 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00109 GetVirtualBits(
00110     IN OUT PULONG PFlags,
00111     IN PKIA32_FRAME Frame
00112     );
00113 
00114 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00115 SetVirtualBits(
00116     IN ULONG Flags,
00117     IN PREGINFO PRegs
00118     );
00119 
00120 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00121 VdmDispatchIntAck(
00122     IN PKIA32_FRAME Frame
00123     );
00124 
00125 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00126 CheckVdmFlags(
00127     IN OUT PREGINFO Regs
00128     );
00129 
00130 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00131 KeIA32AndOrVdmLock(
00132     IN ULONG AndMask,
00133     IN ULONG OrMask
00134     );
00135 
00136 BOOLEAN
00137 KeIA32UnscrambleLdtEntry(
00138     IN ULONG Selector,
00139     OUT PKXDESCRIPTOR XDescriptor
00140     );
00141 
00142 ULONGLONG
00143 KeIA32Unscramble(
00144     IN PLDT_ENTRY Descriptor
00145     );
00146 
00147 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00148 <a class="code" href="../../d8/d1/psp_8h.html#a88">PspQueryDescriptorThread</a> (
00149     <a class="code" href="../../d5/d6/struct__ETHREAD.html">PETHREAD</a> Thread,
00150     PVOID ThreadInformation,
00151     ULONG ThreadInformationLength,
00152     PULONG ReturnLength
00153     );
00154 
00155 
00156 
00157 
00158 BOOLEAN
00159 <a class="code" href="../../d0/d6/emulx86_8c.html#a5">KiIA32DispatchOpcode</a>(
00160     IN PKIA32_FRAME Frame
00161     )
00162 
00163 <span class="comment">/*++</span>
00164 <span class="comment"></span>
00165 <span class="comment">Routine Description:</span>
00166 <span class="comment"></span>
00167 <span class="comment">    This routine dispatches to the opcode of the specific emulation routine.</span>
00168 <span class="comment">    based on the first byte of the opcode. It is a combination of the</span>
00169 <span class="comment">    original x86 emulation routines written in assembly (i386/instemul.asm</span>
00170 <span class="comment">    and i386/emv86.asm).</span>
00171 <span class="comment"></span>
00172 <span class="comment">Arguments:</span>
00173 <span class="comment"></span>
00174 <span class="comment">    Frame - pointer to the ia32 trap frame.</span>
00175 <span class="comment"></span>
00176 <span class="comment">Return Value:</span>
00177 <span class="comment"></span>
00178 <span class="comment">    Returns true if the opcode was handled, otherwise false</span>
00179 <span class="comment"></span>
00180 <span class="comment">--*/</span>
00181 
00182 {
00183     REGINFO Regs;
00184     ULONG IOPort;
00185     ULONG IOCount;
00186     ULONG IOAddress;
00187     ULONG flags;
00188     KXDESCRIPTOR NewXDescriptor;
00189 
00190     <span class="comment">//</span>
00191     <span class="comment">// Temporary variables that are needed to access memory in</span>
00192     <span class="comment">// different sizes...</span>
00193     <span class="comment">//</span>
00194     PULONG longPtr;
00195     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a> shortPtr;
00196     PUCHAR charPtr;
00197 
00198     <span class="comment">//</span>
00199     <span class="comment">// Set up the valules that are always needed</span>
00200     <span class="comment">//</span>
00201     Regs.RiInstLength = 1;
00202     Regs.RiPrefixFlags = 0;
00203     Regs.RiTrapFrame = Frame;
00204     Regs.RiSegCs = Frame-&gt;SegCs;
00205     Regs.RiEip = Frame-&gt;Eip;
00206 
00207     <span class="comment">//</span>
00208     <span class="comment">// Convert and verify the linear address is legal</span>
00209     <span class="comment">//</span>
00210     <span class="keywordflow">if</span> (! CsToLinear(&amp;Regs, VM86USER(Frame))) {
00211         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00212     }
00213 
00214     <span class="comment">//</span>
00215     <span class="comment">// The ASM files used an arbitrary maximum length of 128 prefixes...</span>
00216     <span class="comment">// This constant comes from MI.INC (but is not 128)</span>
00217     <span class="comment">//</span>
00218     <span class="keywordflow">while</span> (Regs.RiInstLength &lt;= <a class="code" href="../../d8/d3/ia32def_8h.html#a68">MAX_INSTRUCTION_LENGTH</a>) {
00219 
00220         <span class="comment">// Should there be a Probe or a try/except block?</span>
00221         Regs.RiOpcode = *Regs.RiLinearAddr;
00222 
00223         <span class="keywordflow">switch</span>(Regs.RiOpcode) {
00224             <span class="keywordflow">case</span> 0x0f:
00225                 <span class="comment">// Handle the 0x0f series of opcodes</span>
00226 <span class="preprocessor">#if DEVL</span>
00227 <span class="preprocessor"></span>                ExVdmOpcodeDispatchCounts[VDM_INDEX_0F]++;
00228 <span class="preprocessor">#endif</span>
00229 <span class="preprocessor"></span><span class="preprocessor">#if VDMDBG</span>
00230 <span class="preprocessor"></span>                DbgPrintf(<span class="stringliteral">"Saw 0x0f opcode (0x%02x) at linear address 0x%08lx\n"</span>, (<span class="keywordtype">int</span>) Regs.RiOpcode, (<span class="keywordtype">long</span>) Regs.RiLinearAddr);
00231 <span class="preprocessor">#endif</span>
00232 <span class="preprocessor"></span>                <span class="keywordflow">return</span>(VdmOpcode0F(&amp;Regs));
00233 
00234             <span class="keywordflow">case</span> 0x26:
00235 <span class="preprocessor">#if DEVL</span>
00236 <span class="preprocessor"></span>                ExVdmOpcodeDispatchCounts[VDM_INDEX_ESPrefix]++;
00237 <span class="preprocessor">#endif</span>
00238 <span class="preprocessor"></span><span class="preprocessor">#if VDMDBG</span>
00239 <span class="preprocessor"></span>                DbgPrintf(<span class="stringliteral">"Saw ES Prefix opcode (0x%02x) at linear address 0x%08lx\n"</span>, (<span class="keywordtype">int</span>) Regs.RiOpcode, (<span class="keywordtype">long</span>) Regs.RiLinearAddr);
00240 <span class="preprocessor">#endif</span>
00241 <span class="preprocessor"></span>                Regs.RiPrefixFlags |= PREFIX_ES;
00242                 <span class="keywordflow">break</span>;
00243 
00244             <span class="keywordflow">case</span> 0x2e:
00245 <span class="preprocessor">#if DEVL</span>
00246 <span class="preprocessor"></span>                ExVdmOpcodeDispatchCounts[VDM_INDEX_CSPrefix]++;
00247 <span class="preprocessor">#endif</span>
00248 <span class="preprocessor"></span><span class="preprocessor">#if VDMDBG</span>
00249 <span class="preprocessor"></span>                DbgPrintf(<span class="stringliteral">"Saw CS Prefix opcode (0x%02x) at linear address 0x%08lx\n"</span>, (<span class="keywordtype">int</span>) Regs.RiOpcode, (<span class="keywordtype">long</span>) Regs.RiLinearAddr);
00250 <span class="preprocessor">#endif</span>
00251 <span class="preprocessor"></span>                Regs.RiPrefixFlags |= PREFIX_CS;
00252                 <span class="keywordflow">break</span>;
00253 
00254             <span class="keywordflow">case</span> 0x36:
00255 <span class="preprocessor">#if DEVL</span>
00256 <span class="preprocessor"></span>                ExVdmOpcodeDispatchCounts[VDM_INDEX_SSPrefix]++;
00257 <span class="preprocessor">#endif</span>
00258 <span class="preprocessor"></span><span class="preprocessor">#if VDMDBG</span>
00259 <span class="preprocessor"></span>                DbgPrintf(<span class="stringliteral">"Saw SS Prefix opcode (0x%02x) at linear address 0x%08lx\n"</span>, (<span class="keywordtype">int</span>) Regs.RiOpcode, (<span class="keywordtype">long</span>) Regs.RiLinearAddr);
00260 <span class="preprocessor">#endif</span>
00261 <span class="preprocessor"></span>                Regs.RiPrefixFlags |= PREFIX_SS;
00262                 <span class="keywordflow">break</span>;
00263 
00264             <span class="keywordflow">case</span> 0x3e:
00265 <span class="preprocessor">#if DEVL</span>
00266 <span class="preprocessor"></span>                ExVdmOpcodeDispatchCounts[VDM_INDEX_DSPrefix]++;
00267 <span class="preprocessor">#endif</span>
00268 <span class="preprocessor"></span><span class="preprocessor">#if VDMDBG</span>
00269 <span class="preprocessor"></span>                DbgPrintf(<span class="stringliteral">"Saw DS Prefix opcode (0x%02x) at linear address 0x%08lx\n"</span>, (<span class="keywordtype">int</span>) Regs.RiOpcode, (<span class="keywordtype">long</span>) Regs.RiLinearAddr);
00270 <span class="preprocessor">#endif</span>
00271 <span class="preprocessor"></span>                Regs.RiPrefixFlags |= PREFIX_DS;
00272                 <span class="keywordflow">break</span>;
00273 
00274             <span class="keywordflow">case</span> 0x64:
00275 <span class="preprocessor">#if DEVL</span>
00276 <span class="preprocessor"></span>                ExVdmOpcodeDispatchCounts[VDM_INDEX_FSPrefix]++;
00277 <span class="preprocessor">#endif</span>
00278 <span class="preprocessor"></span><span class="preprocessor">#if VDMDBG</span>
00279 <span class="preprocessor"></span>                DbgPrintf(<span class="stringliteral">"Saw FS Prefix opcode (0x%02x) at linear address 0x%08lx\n"</span>, (<span class="keywordtype">int</span>) Regs.RiOpcode, (<span class="keywordtype">long</span>) Regs.RiLinearAddr);
00280 <span class="preprocessor">#endif</span>
00281 <span class="preprocessor"></span>                Regs.RiPrefixFlags |= PREFIX_FS;
00282                 <span class="keywordflow">break</span>;
00283 
00284             <span class="keywordflow">case</span> 0x65:
00285 <span class="preprocessor">#if DEVL</span>
00286 <span class="preprocessor"></span>                ExVdmOpcodeDispatchCounts[VDM_INDEX_GSPrefix]++;
00287 <span class="preprocessor">#endif</span>
00288 <span class="preprocessor"></span><span class="preprocessor">#if VDMDBG</span>
00289 <span class="preprocessor"></span>                DbgPrintf(<span class="stringliteral">"Saw GS Prefix opcode (0x%02x) at linear address 0x%08lx\n"</span>, (<span class="keywordtype">int</span>) Regs.RiOpcode, (<span class="keywordtype">long</span>) Regs.RiLinearAddr);
00290 <span class="preprocessor">#endif</span>
00291 <span class="preprocessor"></span>                Regs.RiPrefixFlags |= PREFIX_GS;
00292                 <span class="keywordflow">break</span>;
00293 
00294             <span class="keywordflow">case</span> 0x66:
00295 <span class="preprocessor">#if DEVL</span>
00296 <span class="preprocessor"></span>                ExVdmOpcodeDispatchCounts[VDM_INDEX_OPER32Prefix]++;
00297 <span class="preprocessor">#endif</span>
00298 <span class="preprocessor"></span><span class="preprocessor">#if VDMDBG</span>
00299 <span class="preprocessor"></span>                DbgPrintf(<span class="stringliteral">"Saw Operand 32 Prefix opcode (0x%02x) at linear address 0x%08lx\n"</span>, (<span class="keywordtype">int</span>) Regs.RiOpcode, (<span class="keywordtype">long</span>) Regs.RiLinearAddr);
00300 <span class="preprocessor">#endif</span>
00301 <span class="preprocessor"></span>                Regs.RiPrefixFlags |= PREFIX_OPER32;
00302                 <span class="keywordflow">break</span>;
00303 
00304             <span class="keywordflow">case</span> 0x67:
00305 <span class="preprocessor">#if DEVL</span>
00306 <span class="preprocessor"></span>                ExVdmOpcodeDispatchCounts[VDM_INDEX_ADDR32Prefix]++;
00307 <span class="preprocessor">#endif</span>
00308 <span class="preprocessor"></span><span class="preprocessor">#if VDMDBG</span>
00309 <span class="preprocessor"></span>                DbgPrintf(<span class="stringliteral">"Saw Address 32 Prefix opcode (0x%02x) at linear address 0x%08lx\n"</span>, (<span class="keywordtype">int</span>) Regs.RiOpcode, (<span class="keywordtype">long</span>) Regs.RiLinearAddr);
00310 <span class="preprocessor">#endif</span>
00311 <span class="preprocessor"></span>                Regs.RiPrefixFlags |= PREFIX_ADDR32;
00312                 <span class="keywordflow">break</span>;
00313 
00314             <span class="comment">//</span>
00315             <span class="comment">// The next four instructions (INSB, INSW, OUTSB, and OUTSW)</span>
00316             <span class="comment">// could be optimized to pass fewer parameters to </span>
00317             <span class="comment">// KiIA32VdmDispatchStringIo(). But, in an attempt to change as</span>
00318             <span class="comment">// little as possible, this will be left alone for the moment.</span>
00319             <span class="comment">// Really only need to pass &amp;regs structure, size info (byte/word)</span>
00320             <span class="comment">// and read/write info. All else is contained in &amp;Regs...</span>
00321             <span class="comment">//</span>
00322             <span class="keywordflow">case</span> 0x6c:
00323                 <span class="comment">// The INSB instruction</span>
00324 <span class="preprocessor">#if DEVL</span>
00325 <span class="preprocessor"></span>                ExVdmOpcodeDispatchCounts[VDM_INDEX_INSB]++;
00326 <span class="preprocessor">#endif</span>
00327 <span class="preprocessor"></span><span class="preprocessor">#if VDMDBG</span>
00328 <span class="preprocessor"></span>                DbgPrintf(<span class="stringliteral">"Saw INSB opcode (0x%02x) at linear address 0x%08lx\n"</span>, (<span class="keywordtype">int</span>) Regs.RiOpcode, (<span class="keywordtype">long</span>) Regs.RiLinearAddr);
00329 <span class="preprocessor">#endif</span>
00330 <span class="preprocessor"></span>                IOAddress = ( Frame-&gt;SegEs &lt;&lt; 16 ) + Frame-&gt;Edi;
00331 
00332                 <span class="keywordflow">if</span> (Regs.RiPrefixFlags &amp; PREFIX_REP) {
00333                     IOCount = Frame-&gt;Ecx;
00334                 }
00335                 <span class="keywordflow">else</span> {
00336                     IOCount = 1;
00337                 }
00338                 IOPort = Frame-&gt;Edx;
00339 
00340                 <span class="keywordflow">return</span>(KiIA32VdmDispatchStringIo(IOPort, 1, Regs.RiPrefixFlags &amp; PREFIX_REP, TRUE, IOCount, IOAddress, Regs.RiInstLength, Frame));
00341 
00342             <span class="keywordflow">case</span> 0x6d:
00343                 <span class="comment">// The INSW instruction</span>
00344 <span class="preprocessor">#if DEVL</span>
00345 <span class="preprocessor"></span>                ExVdmOpcodeDispatchCounts[VDM_INDEX_INSW]++;
00346 <span class="preprocessor">#endif</span>
00347 <span class="preprocessor"></span><span class="preprocessor">#if VDMDBG</span>
00348 <span class="preprocessor"></span>                DbgPrintf(<span class="stringliteral">"Saw INSW opcode (0x%02x) at linear address 0x%08lx\n"</span>, (<span class="keywordtype">int</span>) Regs.RiOpcode, (<span class="keywordtype">long</span>) Regs.RiLinearAddr);
00349 <span class="preprocessor">#endif</span>
00350 <span class="preprocessor"></span>                IOAddress = ( Frame-&gt;SegEs &lt;&lt; 16 ) + Frame-&gt;Edi;
00351 
00352                 <span class="keywordflow">if</span> (Regs.RiPrefixFlags &amp; PREFIX_REP) {
00353                     IOCount = Frame-&gt;Ecx;
00354                 }
00355                 <span class="keywordflow">else</span> {
00356                     IOCount = 1;
00357                 }
00358                 IOPort = Frame-&gt;Edx;
00359 
00360                 <span class="keywordflow">return</span>(KiIA32VdmDispatchStringIo(IOPort, 2, Regs.RiPrefixFlags &amp; PREFIX_REP, TRUE, IOCount, IOAddress, Regs.RiInstLength, Frame));
00361 
00362             <span class="keywordflow">case</span> 0x6e:
00363                 <span class="comment">// The OUTSB instruction</span>
00364 <span class="preprocessor">#if DEVL</span>
00365 <span class="preprocessor"></span>                ExVdmOpcodeDispatchCounts[VDM_INDEX_OUTSB]++;
00366 <span class="preprocessor">#endif</span>
00367 <span class="preprocessor"></span><span class="preprocessor">#if VDMDBG</span>
00368 <span class="preprocessor"></span>                DbgPrintf(<span class="stringliteral">"Saw OUTSB opcode (0x%02x) at linear address 0x%08lx\n"</span>, (<span class="keywordtype">int</span>) Regs.RiOpcode, (<span class="keywordtype">long</span>) Regs.RiLinearAddr);
00369 <span class="preprocessor">#endif</span>
00370 <span class="preprocessor"></span>                IOAddress = ( Frame-&gt;SegEs &lt;&lt; 16 ) + Frame-&gt;Edi;
00371 
00372                 <span class="keywordflow">if</span> (Regs.RiPrefixFlags &amp; PREFIX_REP) {
00373                     IOCount = Frame-&gt;Ecx;
00374                 }
00375                 <span class="keywordflow">else</span> {
00376                     IOCount = 1;
00377                 }
00378                 IOPort = Frame-&gt;Edx;
00379 
00380                 <span class="keywordflow">return</span>(KiIA32VdmDispatchStringIo(IOPort, 1, Regs.RiPrefixFlags &amp; PREFIX_REP, FALSE, IOCount, IOAddress, Regs.RiInstLength, Frame));
00381 
00382             <span class="keywordflow">case</span> 0x6f:
00383                 <span class="comment">// The OUTSW instruction</span>
00384 <span class="preprocessor">#if DEVL</span>
00385 <span class="preprocessor"></span>                ExVdmOpcodeDispatchCounts[VDM_INDEX_OUTSW]++;
00386 <span class="preprocessor">#endif</span>
00387 <span class="preprocessor"></span><span class="preprocessor">#if VDMDBG</span>
00388 <span class="preprocessor"></span>                DbgPrintf(<span class="stringliteral">"Saw OUTSW opcode (0x%02x) at linear address 0x%08lx\n"</span>, (<span class="keywordtype">int</span>) Regs.RiOpcode, (<span class="keywordtype">long</span>) Regs.RiLinearAddr);
00389 <span class="preprocessor">#endif</span>
00390 <span class="preprocessor"></span>                IOAddress = ( Frame-&gt;SegEs &lt;&lt; 16 ) + Frame-&gt;Edi;
00391 
00392                 <span class="keywordflow">if</span> (Regs.RiPrefixFlags &amp; PREFIX_REP) {
00393                     IOCount = Frame-&gt;Ecx;
00394                 }
00395                 <span class="keywordflow">else</span> {
00396                     IOCount = 1;
00397                 }
00398                 IOPort = Frame-&gt;Edx;
00399 
00400                 <span class="keywordflow">return</span>(KiIA32VdmDispatchStringIo(IOPort, 2, Regs.RiPrefixFlags &amp; PREFIX_REP, FALSE, IOCount, IOAddress, Regs.RiInstLength, Frame));
00401 
00402             <span class="keywordflow">case</span> 0x9b:
00403             <span class="keywordflow">case</span> 0x0d8:
00404             <span class="keywordflow">case</span> 0x0d9:
00405             <span class="keywordflow">case</span> 0x0da:
00406             <span class="keywordflow">case</span> 0x0db:
00407             <span class="keywordflow">case</span> 0x0dc:
00408             <span class="keywordflow">case</span> 0x0dd:
00409             <span class="keywordflow">case</span> 0x0de:
00410             <span class="keywordflow">case</span> 0x0df:
00411 <span class="preprocessor">#if DEVL</span>
00412 <span class="preprocessor"></span>                ExVdmOpcodeDispatchCounts[VDM_INDEX_NPX]++;
00413 <span class="preprocessor">#endif</span>
00414 <span class="preprocessor"></span><span class="preprocessor">#if VDMDBG</span>
00415 <span class="preprocessor"></span>                DbgPrintf(<span class="stringliteral">"Saw NPX opcode (0x%02x) at linear address 0x%08lx\n"</span>, (<span class="keywordtype">int</span>) Regs.RiOpcode, (<span class="keywordtype">long</span>) Regs.RiLinearAddr);
00416 <span class="preprocessor">#endif</span>
00417 <span class="preprocessor"></span>                <span class="keywordflow">break</span>;
00418 
00419             <span class="keywordflow">case</span> 0x09c:
00420 <span class="preprocessor">#if DEVL</span>
00421 <span class="preprocessor"></span>                ExVdmOpcodeDispatchCounts[VDM_INDEX_PUSHF]++;
00422 <span class="preprocessor">#endif</span>
00423 <span class="preprocessor"></span><span class="preprocessor">#if VDMDBG</span>
00424 <span class="preprocessor"></span>                DbgPrintf(<span class="stringliteral">"Saw PUSHF opcode (0x%02x) at linear address 0x%08lx\n"</span>, (<span class="keywordtype">int</span>) Regs.RiOpcode, (<span class="keywordtype">long</span>) Regs.RiLinearAddr);
00425 <span class="preprocessor">#endif</span>
00426 <span class="preprocessor"></span>                <span class="comment">// This one should only happen in V86 mode</span>
00427                 <span class="keywordflow">if</span> (! VM86USER(Frame)) {
00428                     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00429                 }
00430 
00431                 flags = Frame-&gt;EFlags &amp; (~EFLAGS_INTERRUPT_MASK);
00432                 flags |= EFLAGS_IOPL_MASK;
00433                 flags |= (*<a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a3">VdmFixedStateLinear</a> &amp; (<a class="code" href="../../d2/d5/ke_2i386_2vdmp_8h.html#a3">VDM_VIRTUAL_INTERRUPTS</a> | EFLAGS_ALIGN_CHECK | EFLAGS_NT_MASK));
00434 
00435                 <span class="keywordflow">if</span> (Regs.RiPrefixFlags &amp; PREFIX_OPER32) {
00436                     Frame-&gt;HardwareEsp = (Frame-&gt;HardwareEsp - 4) &amp; 0xffff;
00437                     longPtr = (PULONG) (Frame-&gt;SegSs &lt;&lt; 4) + Frame-&gt;HardwareEsp;
00438                     *longPtr = flags;
00439                 }
00440                 <span class="keywordflow">else</span> {
00441                     Frame-&gt;HardwareEsp = (Frame-&gt;HardwareEsp - 2) &amp; 0xffff;
00442                     shortPtr = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>) (Frame-&gt;SegSs &lt;&lt; 4) + Frame-&gt;HardwareEsp;
00443                     *shortPtr = flags &amp; 0xffff;
00444                 }
00445 
00446                 Frame-&gt;Eip += Regs.RiInstLength;
00447 
00448                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00449 
00450             <span class="keywordflow">case</span> 0x9d:
00451 <span class="preprocessor">#if DEVL</span>
00452 <span class="preprocessor"></span>                ExVdmOpcodeDispatchCounts[VDM_INDEX_POPF]++;
00453 <span class="preprocessor">#endif</span>
00454 <span class="preprocessor"></span><span class="preprocessor">#if VDMDBG</span>
00455 <span class="preprocessor"></span>                DbgPrintf(<span class="stringliteral">"Saw POPF opcode (0x%02x) at linear address 0x%08lx\n"</span>, (<span class="keywordtype">int</span>) Regs.RiOpcode, (<span class="keywordtype">long</span>) Regs.RiLinearAddr);
00456 <span class="preprocessor">#endif</span>
00457 <span class="preprocessor"></span>                <span class="comment">// This one should only happen in V86 mode</span>
00458                 <span class="keywordflow">if</span> (! VM86USER(Frame)) {
00459                     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00460                 }
00461 
00462                 <span class="keywordflow">if</span> (Regs.RiPrefixFlags &amp; PREFIX_OPER32) {
00463                     longPtr = (PULONG) ((Frame-&gt;SegSs &lt;&lt; 4) + Frame-&gt;HardwareEsp);
00464                     flags = *longPtr;
00465                     Frame-&gt;HardwareEsp = (Frame-&gt;HardwareEsp + 4) &amp; 0xffff;
00466                 }
00467                 <span class="keywordflow">else</span> {
00468                     shortPtr = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>) ((Frame-&gt;SegSs &lt;&lt; 4) + Frame-&gt;HardwareEsp);
00469                     flags = *shortPtr;
00470                     Frame-&gt;HardwareEsp = (Frame-&gt;HardwareEsp + 2) &amp; 0xffff;
00471                 }
00472 
00473                 flags &amp;= ~EFLAGS_IOPL_MASK;
00474 
00475                 KeIA32AndOrVdmLock(~(EFLAGS_INTERRUPT_MASK | EFLAGS_ALIGN_CHECK | EFLAGS_NT_MASK), (flags &amp; (EFLAGS_INTERRUPT_MASK | EFLAGS_ALIGN_CHECK | EFLAGS_NT_MASK)));
00476 
00477                 flags &amp;= ~EFLAGS_NT_MASK;
00478 
00479                 <span class="comment">//</span>
00480                 <span class="comment">// Original x86 code checked for virtual extensions.. </span>
00481                 <span class="comment">// Still being decided if these are worth the trouble...</span>
00482                 <span class="comment">//</span>
00483                 <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/emulx86_8c.html#a3">KeIA32VirtualIntExtensions</a> &amp; V86_VIRTUAL_INT_EXTENSIONS) {
00484                     flags |= EFLAGS_VIF;
00485                     <span class="keywordflow">if</span> (! (flags &amp; EFLAGS_INTERRUPT_MASK)) {
00486                         flags &amp;= ~EFLAGS_VIF;
00487                     }
00488                 }
00489                 flags |= (EFLAGS_INTERRUPT_MASK | EFLAGS_V86_MASK);
00490                 Frame-&gt;EFlags = flags;
00491 
00492                 Frame-&gt;Eip += Regs.RiInstLength;
00493 
00494                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00495 
00496             <span class="keywordflow">case</span> 0x0cd:
00497 <span class="preprocessor">#if DEVL</span>
00498 <span class="preprocessor"></span>                ExVdmOpcodeDispatchCounts[VDM_INDEX_INTnn]++;
00499 <span class="preprocessor">#endif</span>
00500 <span class="preprocessor"></span><span class="preprocessor">#if VDMDBG</span>
00501 <span class="preprocessor"></span>                DbgPrintf(<span class="stringliteral">"Saw INTnn opcode (0x%02x) at linear address 0x%08lx\n"</span>, (<span class="keywordtype">int</span>) Regs.RiOpcode, (<span class="keywordtype">long</span>) Regs.RiLinearAddr);
00502 <span class="preprocessor">#endif</span>
00503 <span class="preprocessor"></span>                <span class="keywordflow">if</span> (VM86USER(Frame)) {
00504                     <span class="comment">//</span>
00505                     <span class="comment">// V86 mode int XX</span>
00506                     <span class="comment">//</span>
00507 
00508                     <span class="comment">//</span>
00509                     <span class="comment">// Two EFLAGS to handle - one put in the trap frame</span>
00510                     <span class="comment">// and one that is pushed on the stack... First handle</span>
00511                     <span class="comment">// the one pushed on the stack</span>
00512                     <span class="comment">//</span>
00513 
00514                     Frame-&gt;HardwareEsp = (Frame-&gt;HardwareEsp - 2) &amp; 0xffff;
00515                     shortPtr = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>) ((Frame-&gt;SegSs &lt;&lt; 4) + Frame-&gt;HardwareEsp);
00516                     flags = Frame-&gt;EFlags;
00517 
00518                     <span class="keywordflow">if</span> (! <a class="code" href="../../d0/d6/emulx86_8c.html#a2">KeIA32VdmIoplAllowed</a>) {
00519                         flags = (flags &amp; ~EFLAGS_INTERRUPT_MASK) | (*<a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a3">VdmFixedStateLinear</a> &amp; (<a class="code" href="../../d2/d5/ke_2i386_2vdmp_8h.html#a1">VDM_INTERRUPT_PENDING</a> | EFLAGS_ALIGN_CHECK));
00520                     }
00521 
00522                     flags |= EFLAGS_IOPL_MASK;
00523                     *shortPtr = flags;
00524 
00525                     <span class="comment">//</span>
00526                     <span class="comment">// Now handle the one on the trap frame...</span>
00527                     <span class="comment">//</span>
00528                     flags = Frame-&gt;EFlags;
00529 
00530                     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/emulx86_8c.html#a2">KeIA32VdmIoplAllowed</a>) {
00531                         flags &amp;= ~EFLAGS_INTERRUPT_MASK;
00532                     }
00533                     <span class="keywordflow">else</span> {
00534                         KeIA32AndOrVdmLock(~VDM_VIRTUAL_INTERRUPTS, 0);
00535                         flags |= EFLAGS_INTERRUPT_MASK;
00536                     }
00537 
00538                     flags &amp;= ~(EFLAGS_NT_MASK | EFLAGS_TF_MASK);
00539                     Frame-&gt;EFlags = flags;
00540 
00541                     <span class="comment">// Now push CS on the stack</span>
00542                     Frame-&gt;HardwareEsp = (Frame-&gt;HardwareEsp - 2) &amp; 0xffff;
00543                     shortPtr = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>) ((Frame-&gt;SegSs &lt;&lt; 4) + Frame-&gt;HardwareEsp);
00544                     *shortPtr = Frame-&gt;SegCs;
00545 
00546                     <span class="comment">// And push IP on the stack</span>
00547                     Frame-&gt;HardwareEsp = (Frame-&gt;HardwareEsp - 2) &amp; 0xffff;
00548                     shortPtr = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>) ((Frame-&gt;SegSs &lt;&lt; 4) + Frame-&gt;HardwareEsp);
00549                     *shortPtr = Frame-&gt;Eip;
00550 
00551                     <span class="comment">//</span>
00552                     <span class="comment">// get the interrupt number and the address in memeory</span>
00553                     <span class="comment">// that it points to...</span>
00554                     <span class="comment">//</span>
00555                     Regs.RiLinearAddr++;
00556                     longPtr = (PULONG) (*(Regs.RiLinearAddr) * 4);
00557 
00558                     <span class="comment">//</span>
00559                     <span class="comment">// And set up the proper CS and IP based on the int number</span>
00560                     <span class="comment">// from above...</span>
00561                     <span class="comment">//</span>
00562                     Frame-&gt;Eip = *longPtr &amp; 0xffff;
00563                     Frame-&gt;SegCs = *longPtr &gt;&gt; 16;
00564                 }
00565                 <span class="keywordflow">else</span> {
00566                     <span class="comment">//</span>
00567                     <span class="comment">// protected mode intXX</span>
00568                     <span class="comment">//</span>
00569 
00570                     <span class="comment">//</span>
00571                     <span class="comment">// Get the eflags</span>
00572                     <span class="comment">//</span>
00573                     flags = Frame-&gt;EFlags;
00574                     GetVirtualBits(&amp;flags, Frame);
00575                     Regs.RiEFlags = flags;
00576 
00577                     <span class="comment">//</span>
00578                     <span class="comment">// And get the stack</span>
00579                     <span class="comment">//</span>
00580                     Regs.RiSegSs = Frame-&gt;SegSs;
00581                     Regs.RiEsp = Frame-&gt;HardwareEsp;
00582                     <span class="keywordflow">if</span> (! SsToLinear(&amp;Regs, VM86USER(Frame))) { 
00583                         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00584                     }
00585 
00586                     <span class="comment">//</span>
00587                     <span class="comment">// Make sure that the nn part of INTnn</span>
00588                     <span class="comment">// can be accessed legitimately</span>
00589                     <span class="comment">//</span>
00590                     Regs.RiEip++;
00591                     Regs.RiLinearAddr++;
00592                     <span class="keywordflow">if</span> (! CheckEip(&amp;Regs)) {
00593                         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00594                     }
00595 
00596                     <span class="comment">//</span>
00597                     <span class="comment">// Point to the next instruction after the INTnn</span>
00598                     <span class="comment">//</span>
00599                     Regs.RiEip++;
00600                     Regs.RiLinearAddr++;
00601 
00602 
00603                     <span class="comment">//</span>
00604                     <span class="comment">// And put the right things on the stack...</span>
00605                     <span class="comment">//</span>
00606                     <span class="keywordflow">if</span> (! PushInt(*(Regs.RiLinearAddr - 1), &amp;Regs)) {
00607                         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00608                     }
00609 
00610                     <span class="comment">//</span>
00611                     <span class="comment">// If all went well, update the trap frame</span>
00612                     <span class="comment">//</span>
00613 <span class="comment">// QUESTION</span>
00614                     <span class="keywordflow">if</span> (! KeIA32UnscrambleLdtEntry(Regs.RiSegCs, &amp;NewXDescriptor)) {
00615                         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00616                     }
00617 
00618                     Frame-&gt;HardwareEsp = Regs.RiEsp;
00619                     Frame-&gt;EFlags = Regs.RiEFlags;
00620                     Frame-&gt;SegCs = Regs.RiSegCs;
00621                     Frame-&gt;Eip = Regs.RiEip;
00622                 }
00623 
00624                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00625 
00626             <span class="keywordflow">case</span> 0x0ce:
00627 <span class="preprocessor">#if DEVL</span>
00628 <span class="preprocessor"></span>                ExVdmOpcodeDispatchCounts[VDM_INDEX_INTO]++;
00629 <span class="preprocessor">#endif</span>
00630 <span class="preprocessor"></span><span class="preprocessor">#if VDMDBG</span>
00631 <span class="preprocessor"></span>                DbgPrintf(<span class="stringliteral">"Saw INTO opcode (0x%02x) at linear address 0x%08lx\n"</span>, (<span class="keywordtype">int</span>) Regs.RiOpcode, (<span class="keywordtype">long</span>) Regs.RiLinearAddr);
00632 <span class="preprocessor">#endif</span>
00633 <span class="preprocessor"></span>
00634                 <span class="comment">//</span>
00635                 <span class="comment">// Both v86 and protected mode don't want to </span>
00636                 <span class="comment">// deal with into...</span>
00637                 <span class="comment">//</span>
00638                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00639                 
00640                 <span class="keywordflow">break</span>;
00641 
00642             <span class="keywordflow">case</span> 0x0cf:
00643 <span class="preprocessor">#if DEVL</span>
00644 <span class="preprocessor"></span>                ExVdmOpcodeDispatchCounts[VDM_INDEX_IRET]++;
00645 <span class="preprocessor">#endif</span>
00646 <span class="preprocessor"></span><span class="preprocessor">#if VDMDBG</span>
00647 <span class="preprocessor"></span>                DbgPrintf(<span class="stringliteral">"Saw IRET opcode (0x%02x) at linear address 0x%08lx\n"</span>, (<span class="keywordtype">int</span>) Regs.RiOpcode, (<span class="keywordtype">long</span>) Regs.RiLinearAddr);
00648 <span class="preprocessor">#endif</span>
00649 <span class="preprocessor"></span>                <span class="comment">//</span>
00650                 <span class="comment">// This one should only happen in V86 mode</span>
00651                 <span class="comment">//</span>
00652 
00653                 <span class="keywordflow">if</span> (! VM86USER(Frame)) {
00654                     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00655                 }
00656 
00657 
00658                 <span class="comment">//</span>
00659                 <span class="comment">// update the Trap frame with the iret values (CS, IP, flags)</span>
00660                 <span class="comment">// based on size of iret (16 vs. 32 bits)</span>
00661                 <span class="comment">//</span>
00662                 <span class="keywordflow">if</span> (Regs.RiPrefixFlags &amp; PREFIX_OPER32) {
00663                     longPtr = (PULONG) ((Frame-&gt;SegSs &lt;&lt; 4) + Frame-&gt;HardwareEsp);
00664 
00665                     Frame-&gt;Eip = *longPtr++;
00666                     Frame-&gt;SegCs = *longPtr++;
00667                     flags = *longPtr;
00668 
00669                     Frame-&gt;HardwareEsp = (Frame-&gt;HardwareEsp + 12) &amp; 0xffff;
00670                 }
00671                 <span class="keywordflow">else</span> {
00672                     shortPtr = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>) ((Frame-&gt;SegSs &lt;&lt; 4) + Frame-&gt;HardwareEsp);
00673 
00674                     Frame-&gt;Eip  = *shortPtr++ &amp; 0xffff;
00675                     Frame-&gt;SegCs = *shortPtr++ &amp; 0xffff;
00676                     flags = *shortPtr &amp; 0xffff;
00677 
00678                     Frame-&gt;HardwareEsp = (Frame-&gt;HardwareEsp + 6) &amp; 0xffff;
00679                 }
00680 
00681                 flags &amp;= ~(EFLAGS_IOPL_MASK | EFLAGS_NT_MASK);
00682 
00683                 KeIA32AndOrVdmLock(~VDM_VIRTUAL_INTERRUPTS, flags &amp; EFLAGS_INTERRUPT_MASK );
00684 
00685                 <span class="comment">//</span>
00686                 <span class="comment">// Original x86 code checked for virtual extensions.. </span>
00687                 <span class="comment">// We haven't decided if they are worth the effort yet...</span>
00688                 <span class="comment">//</span>
00689                 <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/emulx86_8c.html#a3">KeIA32VirtualIntExtensions</a> &amp; V86_VIRTUAL_INT_EXTENSIONS) {
00690                     <span class="keywordflow">if</span> (flags &amp; EFLAGS_INTERRUPT_MASK) {
00691                         flags |= EFLAGS_VIF;
00692                     }
00693                     <span class="keywordflow">else</span> {
00694                         flags &amp;= ~EFLAGS_VIF;
00695                     }
00696                 }
00697 
00698                 flags |= (EFLAGS_INTERRUPT_MASK | EFLAGS_V86_MASK);
00699                 Frame-&gt;EFlags = flags;
00700 
00701                 <span class="comment">// Before we return, check for a BOP or a virtual interrupt</span>
00702                 shortPtr = (Frame-&gt;SegCs &lt;&lt; 4) + Frame-&gt;Eip;
00703 
00704                 <span class="keywordflow">if</span> ((*shortPtr &amp; 0xffff) == BOP_OPCODE) {
00705                     VdmDispatchBop(Frame);
00706                 }
00707                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((*<a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a3">VdmFixedStateLinear</a> &amp; <a class="code" href="../../d2/d5/ke_2i386_2vdmp_8h.html#a1">VDM_INTERRUPT_PENDING</a>) &amp;&amp;
00708                                 (*<a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a3">VdmFixedStateLinear</a> &amp; <a class="code" href="../../d2/d5/ke_2i386_2vdmp_8h.html#a3">VDM_VIRTUAL_INTERRUPTS</a>)) {
00709                     VdmDispatchIntAck(Frame);
00710                 }
00711 
00712                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00713 
00714             <span class="keywordflow">case</span> 0x0e4:
00715 <span class="preprocessor">#if DEVL</span>
00716 <span class="preprocessor"></span>                ExVdmOpcodeDispatchCounts[VDM_INDEX_INBimm]++;
00717 <span class="preprocessor">#endif</span>
00718 <span class="preprocessor"></span><span class="preprocessor">#if VDMDBG</span>
00719 <span class="preprocessor"></span>                DbgPrintf(<span class="stringliteral">"Saw INB immediate opcode (0x%02x) at linear address 0x%08lx\n"</span>, (<span class="keywordtype">int</span>) Regs.RiOpcode, (<span class="keywordtype">long</span>) Regs.RiLinearAddr);
00720 <span class="preprocessor">#endif</span>
00721 <span class="preprocessor"></span>                <span class="comment">// The immediate byte means the instruction is one byte longer</span>
00722                 Regs.RiInstLength++;
00723 
00724                 <span class="comment">// Check that the immediate byte address is legit</span>
00725                 charPtr = Regs.RiLinearAddr + 1;
00726                 <span class="keywordflow">if</span> ((charPtr - Regs.RiCsBase) &gt; Regs.RiCsLimit) {
00727                     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00728                 }
00729 
00730                 IOPort = *charPtr;
00731 
00732                 <span class="keywordflow">return</span>(KiIA32VdmDispatchIo(IOPort, 1, TRUE, Regs.RiInstLength, Frame));
00733 
00734             <span class="keywordflow">case</span> 0x0e5:
00735 <span class="preprocessor">#if DEVL</span>
00736 <span class="preprocessor"></span>                ExVdmOpcodeDispatchCounts[VDM_INDEX_INWimm]++;
00737 <span class="preprocessor">#endif</span>
00738 <span class="preprocessor"></span><span class="preprocessor">#if VDMDBG</span>
00739 <span class="preprocessor"></span>                DbgPrintf(<span class="stringliteral">"Saw INW immediate opcode (0x%02x) at linear address 0x%08lx\n"</span>, (<span class="keywordtype">int</span>) Regs.RiOpcode, (<span class="keywordtype">long</span>) Regs.RiLinearAddr);
00740 <span class="preprocessor">#endif</span>
00741 <span class="preprocessor"></span>                <span class="comment">// The immediate byte means the instruction is one byte longer</span>
00742                 Regs.RiInstLength++;
00743 
00744                 <span class="comment">// Check that the immediate byte address is legit</span>
00745                 charPtr = Regs.RiLinearAddr + 1;
00746                 <span class="keywordflow">if</span> ((charPtr - Regs.RiCsBase) &gt; Regs.RiCsLimit) {
00747                     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00748                 }
00749 
00750                 IOPort = *charPtr;
00751 
00752                 <span class="keywordflow">return</span>(KiIA32VdmDispatchIo(IOPort, 2, TRUE, Regs.RiInstLength, Frame));
00753             <span class="keywordflow">case</span> 0x0e6:
00754 <span class="preprocessor">#if DEVL</span>
00755 <span class="preprocessor"></span>                ExVdmOpcodeDispatchCounts[VDM_INDEX_OUTBimm]++;
00756 <span class="preprocessor">#endif</span>
00757 <span class="preprocessor"></span><span class="preprocessor">#if VDMDBG</span>
00758 <span class="preprocessor"></span>                DbgPrintf(<span class="stringliteral">"Saw OUTB immediate opcode (0x%02x) at linear address 0x%08lx\n"</span>, (<span class="keywordtype">int</span>) Regs.RiOpcode, (<span class="keywordtype">long</span>) Regs.RiLinearAddr);
00759 <span class="preprocessor">#endif</span>
00760 <span class="preprocessor"></span>                <span class="comment">// The immediate byte means the instruction is one byte longer</span>
00761                 Regs.RiInstLength++;
00762 
00763                 <span class="comment">// Check that the immediate byte address is legit</span>
00764                 charPtr = Regs.RiLinearAddr + 1;
00765                 <span class="keywordflow">if</span> ((charPtr - Regs.RiCsBase) &gt; Regs.RiCsLimit) {
00766                     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00767                 }
00768 
00769                 IOPort = *charPtr;
00770 
00771                 <span class="keywordflow">return</span>(KiIA32VdmDispatchIo(IOPort, 1, FALSE, Regs.RiInstLength, Frame));
00772             <span class="keywordflow">case</span> 0x0e7:
00773 <span class="preprocessor">#if DEVL</span>
00774 <span class="preprocessor"></span>                ExVdmOpcodeDispatchCounts[VDM_INDEX_OUTWimm]++;
00775 <span class="preprocessor">#endif</span>
00776 <span class="preprocessor"></span><span class="preprocessor">#if VDMDBG</span>
00777 <span class="preprocessor"></span>                DbgPrintf(<span class="stringliteral">"Saw OUTW immediate opcode (0x%02x) at linear address 0x%08lx\n"</span>, (<span class="keywordtype">int</span>) Regs.RiOpcode, (<span class="keywordtype">long</span>) Regs.RiLinearAddr);
00778 <span class="preprocessor">#endif</span>
00779 <span class="preprocessor"></span>                <span class="comment">// The immediate byte means the instruction is one byte longer</span>
00780                 Regs.RiInstLength++;
00781 
00782                 <span class="comment">// Check that the immediate byte address is legit</span>
00783                 charPtr = Regs.RiLinearAddr + 1;
00784                 <span class="keywordflow">if</span> ((charPtr - Regs.RiCsBase) &gt; Regs.RiCsLimit) {
00785                     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00786                 }
00787 
00788                 IOPort = *charPtr;
00789 
00790                 <span class="keywordflow">return</span>(KiIA32VdmDispatchIo(IOPort, 2, FALSE, Regs.RiInstLength, Frame));
00791 
00792             <span class="keywordflow">case</span> 0x0ec:
00793 <span class="preprocessor">#if DEVL</span>
00794 <span class="preprocessor"></span>                ExVdmOpcodeDispatchCounts[VDM_INDEX_INB]++;
00795 <span class="preprocessor">#endif</span>
00796 <span class="preprocessor"></span><span class="preprocessor">#if VDMDBG</span>
00797 <span class="preprocessor"></span>                DbgPrintf(<span class="stringliteral">"Saw INB opcode (0x%02x) at linear address 0x%08lx\n"</span>, (<span class="keywordtype">int</span>) Regs.RiOpcode, (<span class="keywordtype">long</span>) Regs.RiLinearAddr);
00798 <span class="preprocessor">#endif</span>
00799 <span class="preprocessor"></span>                IOPort = Frame-&gt;Edx;
00800 
00801                 <span class="comment">//</span>
00802                 <span class="comment">// In V86 mode, handle Japan support for non PC/AT compatible machines</span>
00803                 <span class="comment">//</span>
00804 <span class="preprocessor">#ifdef NON_PCAT</span>
00805 <span class="preprocessor"></span>                <span class="keywordflow">if</span> (VM86USER(Frame)) {
00806                     <span class="keywordflow">if</span> (KeIA32MachineType &amp; MACHINE_TYPE_MASK) {
00807                         <span class="keywordflow">return</span>(KiIA32VdmDispatchIo(IOPort, 1, TRUE, Regs.RiInstLength, Frame));
00808                     }
00809                 }
00810 <span class="preprocessor">#endif</span>
00811 <span class="preprocessor"></span>                <span class="comment">// Check for printer status request...</span>
00812                 <span class="keywordflow">switch</span> (IOPort) {
00813                     <span class="keywordflow">case</span> 0x03bd:
00814                     <span class="keywordflow">case</span> 0x0379:
00815                     <span class="keywordflow">case</span> 0x0279:
00816                     <span class="keywordflow">if</span> (<a class="code" href="../../d4/d5/vdmprint_8c.html#a0">VdmPrinterStatus</a>(IOPort, Regs.RiInstLength, Frame)) {
00817                         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00818                     }
00819                     <span class="comment">// Fall through</span>
00820                     <span class="keywordflow">default</span>:
00821                         <span class="keywordflow">return</span>(KiIA32VdmDispatchIo(IOPort, 1, TRUE, Regs.RiInstLength, Frame));
00822                 }
00823                 <span class="comment">// Should never get here...</span>
00824                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00825 
00826             <span class="keywordflow">case</span> 0x0ed:
00827 <span class="preprocessor">#if DEVL</span>
00828 <span class="preprocessor"></span>                ExVdmOpcodeDispatchCounts[VDM_INDEX_INW]++;
00829 <span class="preprocessor">#endif</span>
00830 <span class="preprocessor"></span><span class="preprocessor">#if VDMDBG</span>
00831 <span class="preprocessor"></span>                DbgPrintf(<span class="stringliteral">"Saw INW opcode (0x%02x) at linear address 0x%08lx\n"</span>, (<span class="keywordtype">int</span>) Regs.RiOpcode, (<span class="keywordtype">long</span>) Regs.RiLinearAddr);
00832 <span class="preprocessor">#endif</span>
00833 <span class="preprocessor"></span>                IOPort = Frame-&gt;Edx;
00834                 <span class="keywordflow">return</span>(KiIA32VdmDispatchIo(IOPort, 2, TRUE, Regs.RiInstLength, Frame));
00835 
00836             <span class="keywordflow">case</span> 0x0ee:
00837 <span class="preprocessor">#if DEVL</span>
00838 <span class="preprocessor"></span>                ExVdmOpcodeDispatchCounts[VDM_INDEX_OUTB]++;
00839 <span class="preprocessor">#endif</span>
00840 <span class="preprocessor"></span><span class="preprocessor">#if VDMDBG</span>
00841 <span class="preprocessor"></span>                DbgPrintf(<span class="stringliteral">"Saw OUTB opcode (0x%02x) at linear address 0x%08lx\n"</span>, (<span class="keywordtype">int</span>) Regs.RiOpcode, (<span class="keywordtype">long</span>) Regs.RiLinearAddr);
00842 <span class="preprocessor">#endif</span>
00843 <span class="preprocessor"></span>                IOPort = Frame-&gt;Edx;
00844 
00845                 <span class="comment">// Check for printer status request...</span>
00846                 <span class="keywordflow">switch</span> (IOPort) {
00847                     <span class="keywordflow">case</span> 0x03bc:
00848                     <span class="keywordflow">case</span> 0x0378:
00849                     <span class="keywordflow">case</span> 0x0278:
00850                         <span class="keywordflow">if</span> (<a class="code" href="../../d4/d5/vdmprint_8c.html#a1">VdmPrinterWriteData</a>(IOPort, Regs.RiInstLength, Frame)) {
00851                             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00852                         }
00853                         <span class="comment">//</span>
00854                         <span class="comment">// Fall through to dispatch if VdmPrinterWriteData() fails</span>
00855                         <span class="comment">//</span>
00856                     <span class="keywordflow">default</span>:
00857                         <span class="keywordflow">return</span>(KiIA32VdmDispatchIo(IOPort, 1, FALSE, Regs.RiInstLength, Frame));
00858                 }
00859                 <span class="comment">// Should never get here...</span>
00860                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00861 
00862             <span class="keywordflow">case</span> 0x0ef:
00863 <span class="preprocessor">#if DEVL</span>
00864 <span class="preprocessor"></span>                ExVdmOpcodeDispatchCounts[VDM_INDEX_OUTW]++;
00865 <span class="preprocessor">#endif</span>
00866 <span class="preprocessor"></span><span class="preprocessor">#if VDMDBG</span>
00867 <span class="preprocessor"></span>                DbgPrintf(<span class="stringliteral">"Saw OUTW opcode (0x%02x) at linear address 0x%08lx\n"</span>, (<span class="keywordtype">int</span>) Regs.RiOpcode, (<span class="keywordtype">long</span>) Regs.RiLinearAddr);
00868 <span class="preprocessor">#endif</span>
00869 <span class="preprocessor"></span>                IOPort = Frame-&gt;Edx;
00870                 <span class="keywordflow">return</span>(KiIA32VdmDispatchIo(IOPort, 2, FALSE, Regs.RiInstLength, Frame));
00871 
00872             <span class="keywordflow">case</span> 0x0f0:
00873 <span class="preprocessor">#if DEVL</span>
00874 <span class="preprocessor"></span>                ExVdmOpcodeDispatchCounts[VDM_INDEX_LOCKPrefix]++;
00875 <span class="preprocessor">#endif</span>
00876 <span class="preprocessor"></span><span class="preprocessor">#if VDMDBG</span>
00877 <span class="preprocessor"></span>                DbgPrintf(<span class="stringliteral">"Saw LOCK Prefix (0x%02x) at linear address 0x%08lx\n"</span>, (<span class="keywordtype">int</span>) Regs.RiOpcode, (<span class="keywordtype">long</span>) Regs.RiLinearAddr);
00878 <span class="preprocessor">#endif</span>
00879 <span class="preprocessor"></span>                Regs.RiPrefixFlags |= PREFIX_LOCK;
00880                 <span class="keywordflow">break</span>;
00881 
00882             <span class="keywordflow">case</span> 0x0f2:
00883 <span class="preprocessor">#if DEVL</span>
00884 <span class="preprocessor"></span>                ExVdmOpcodeDispatchCounts[VDM_INDEX_REPNEPrefix]++;
00885 <span class="preprocessor">#endif</span>
00886 <span class="preprocessor"></span><span class="preprocessor">#if VDMDBG</span>
00887 <span class="preprocessor"></span>                DbgPrintf(<span class="stringliteral">"Saw REPNE Prefix (0x%02x) at linear address 0x%08lx\n"</span>, (<span class="keywordtype">int</span>) Regs.RiOpcode, (<span class="keywordtype">long</span>) Regs.RiLinearAddr);
00888 <span class="preprocessor">#endif</span>
00889 <span class="preprocessor"></span>                Regs.RiPrefixFlags |= PREFIX_REPNE;
00890                 <span class="keywordflow">break</span>;
00891 
00892             <span class="keywordflow">case</span> 0x0f3:
00893 <span class="preprocessor">#if DEVL</span>
00894 <span class="preprocessor"></span>                ExVdmOpcodeDispatchCounts[VDM_INDEX_REPPrefix]++;
00895 <span class="preprocessor">#endif</span>
00896 <span class="preprocessor"></span><span class="preprocessor">#if VDMDBG</span>
00897 <span class="preprocessor"></span>                DbgPrintf(<span class="stringliteral">"Saw REP Prefix (0x%02x) at linear address 0x%08lx\n"</span>, (<span class="keywordtype">int</span>) Regs.RiOpcode, (<span class="keywordtype">long</span>) Regs.RiLinearAddr);
00898 <span class="preprocessor">#endif</span>
00899 <span class="preprocessor"></span>                Regs.RiPrefixFlags |= PREFIX_REP;
00900                 <span class="keywordflow">break</span>;
00901 
00902             <span class="keywordflow">case</span> 0x0f4:
00903 <span class="preprocessor">#if DEVL</span>
00904 <span class="preprocessor"></span>                ExVdmOpcodeDispatchCounts[VDM_INDEX_HLT]++;
00905 <span class="preprocessor">#endif</span>
00906 <span class="preprocessor"></span><span class="preprocessor">#if VDMDBG</span>
00907 <span class="preprocessor"></span>                DbgPrintf(<span class="stringliteral">"Saw HLT opcode (0x%02x) at linear address 0x%08lx\n"</span>, (<span class="keywordtype">int</span>) Regs.RiOpcode, (<span class="keywordtype">long</span>) Regs.RiLinearAddr);
00908 <span class="preprocessor">#endif</span>
00909 <span class="preprocessor"></span>                <span class="comment">// This one should only happen in V86 mode</span>
00910 
00911                 <span class="keywordflow">if</span> (! VM86USER(Frame)) {
00912                     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00913                 }
00914 
00915                 <span class="comment">// We are in V86 mode...</span>
00916 
00917                 <span class="comment">//</span>
00918                 <span class="comment">// Skip over the instruction</span>
00919                 <span class="comment">//</span>
00920 
00921                 Frame-&gt;Eip = (Frame-&gt;Eip + Regs.RiInstLength) &amp; 0xffff;
00922 
00923                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00924 
00925                 <span class="keywordflow">break</span>;
00926 
00927             <span class="keywordflow">case</span> 0x0fa:
00928 <span class="preprocessor">#if DEVL</span>
00929 <span class="preprocessor"></span>                ExVdmOpcodeDispatchCounts[VDM_INDEX_CLI]++;
00930 <span class="preprocessor">#endif</span>
00931 <span class="preprocessor"></span><span class="preprocessor">#if VDMDBG</span>
00932 <span class="preprocessor"></span>                DbgPrintf(<span class="stringliteral">"Saw CLI opcode (0x%02x) at linear address 0x%08lx\n"</span>, (<span class="keywordtype">int</span>) Regs.RiOpcode, (<span class="keywordtype">long</span>) Regs.RiLinearAddr);
00933 <span class="preprocessor">#endif</span>
00934 <span class="preprocessor"></span>                <span class="keywordflow">if</span> (! VM86USER(Frame)) {
00935                     flags = Frame-&gt;EFlags &amp; ~EFLAGS_INTERRUPT_MASK;
00936                     SetVirtualBits(flags, &amp;Regs);
00937                 }
00938                 <span class="keywordflow">else</span> {
00939                     KeIA32AndOrVdmLock(~VDM_VIRTUAL_INTERRUPTS, 0);
00940                 }
00941                 
00942                 <span class="comment">// Skip over the instruction</span>
00943                 Frame-&gt;Eip += Regs.RiInstLength;
00944 
00945                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00946 
00947             <span class="keywordflow">case</span> 0x0fb:
00948 <span class="preprocessor">#if DEVL</span>
00949 <span class="preprocessor"></span>                ExVdmOpcodeDispatchCounts[VDM_INDEX_STI]++;
00950 <span class="preprocessor">#endif</span>
00951 <span class="preprocessor"></span><span class="preprocessor">#if VDMDBG</span>
00952 <span class="preprocessor"></span>                DbgPrintf(<span class="stringliteral">"Saw STI opcode (0x%02x) at linear address 0x%08lx\n"</span>, (<span class="keywordtype">int</span>) Regs.RiOpcode, (<span class="keywordtype">long</span>) Regs.RiLinearAddr);
00953 <span class="preprocessor">#endif</span>
00954 <span class="preprocessor"></span>                <span class="keywordflow">if</span> (! VM86USER(Frame)) {
00955                     flags = Frame-&gt;EFlags | EFLAGS_INTERRUPT_MASK;
00956                     SetVirtualBits(flags, &amp;Regs);
00957                 }
00958                 <span class="keywordflow">else</span> {
00959                     <span class="comment">// Original x86 code checked for virtual extensions.. </span>
00960                     <span class="comment">// We haven't decided if they're worth it or not...</span>
00961                     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/emulx86_8c.html#a3">KeIA32VirtualIntExtensions</a> &amp; V86_VIRTUAL_INT_EXTENSIONS) {
00962                         Frame-&gt;EFlags |= EFLAGS_VIF;
00963                     }
00964                         
00965                     KeIA32AndOrVdmLock(0xffffffff, EFLAGS_INTERRUPT_MASK);
00966                 }
00967 
00968                 <span class="comment">// Skip over the instruction</span>
00969                 Frame-&gt;Eip += Regs.RiInstLength;
00970 
00971                 <span class="comment">// Interrupts are now "enabled", so handle any</span>
00972                 <span class="comment">// that are pending</span>
00973                 <span class="keywordflow">if</span> (*<a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a3">VdmFixedStateLinear</a> &amp; <a class="code" href="../../d2/d5/ke_2i386_2vdmp_8h.html#a1">VDM_INTERRUPT_PENDING</a>) {
00974                     VdmDispatchIntAck(Frame);
00975                 }
00976                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00977 
00978             <span class="keywordflow">default</span>:
00979                 <span class="comment">// Opcode Invalid</span>
00980 <span class="preprocessor">#if VDMDBG</span>
00981 <span class="preprocessor"></span>                DbgPrintf(<span class="stringliteral">"Saw unexpected opcode (0x%02x) at linear address 0x%08lx\n"</span>, (<span class="keywordtype">int</span>) Regs.RiOpcode, (<span class="keywordtype">long</span>) Regs.RiLinearAddr);
00982 <span class="preprocessor">#endif</span>
00983 <span class="preprocessor"></span>                <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00984 
00985         }
00986 
00987         <span class="comment">// If we get here, it was a prefix instruction</span>
00988 
00989         Regs.RiLinearAddr++;
00990         Regs.RiInstLength++;
00991     }
00992 
00993     <span class="comment">// Prefix was too long, so allow a GP fault</span>
00994 
00995     <span class="keywordflow">return</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
00996 }
00997 
00998 
00999 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01000 VdmDispatchIntAck(
01001     IN PKIA32_FRAME Frame
01002     )
01003 
01004 <span class="comment">/*++</span>
01005 <span class="comment"></span>
01006 <span class="comment">Routine Description: </span>
01007 <span class="comment"></span>
01008 <span class="comment">    Pushes stack arguments for VdmDispatchInterrupts</span>
01009 <span class="comment">    and invokes VdmDispatchInterrupts</span>
01010 <span class="comment"></span>
01011 <span class="comment">    Expects VDM_INTERRUPT_PENDING, and VDM_VIRTUAL_INTERRUPTS</span>
01012 <span class="comment"></span>
01013 <span class="comment">Arguments:</span>
01014 <span class="comment"></span>
01015 <span class="comment">   Frame - pointer to the ia32 trap frame</span>
01016 <span class="comment"></span>
01017 <span class="comment">Returns:</span>
01018 <span class="comment"></span>
01019 <span class="comment">  nothing</span>
01020 <span class="comment"></span>
01021 <span class="comment">--*/</span>
01022 {
01023     <a class="code" href="../../d0/d6/struct__Vdm__Tib.html">PVDM_TIB</a> VdmTib;
01024 
01025     VdmTib = (<a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>()-&gt;Tcb.Teb)-&gt;Vdm;
01026     
01027     <span class="keywordflow">if</span> (*<a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a3">VdmFixedStateLinear</a> &amp; VDM_INT_HARDWARE) {
01028         <span class="comment">// Dispatch interrupt directly from kernel</span>
01029 
01030         <a class="code" href="../../d9/d4/vdmints_8c.html#a16">VdmDispatchInterrupts</a>(Frame, VdmTib);
01031     }
01032     <span class="keywordflow">else</span> {
01033         <span class="comment">// Dispatch interrupt via monitor</span>
01034 
01035         VdmTib-&gt;<a class="code" href="../../d0/d6/struct__Vdm__Tib.html#o5">EventInfo</a>.<a class="code" href="../../d1/d6/struct__VdmEventInfo.html#o1">Event</a> = <a class="code" href="../../d2/d5/ke_2i386_2vdmp_8h.html#a33a28">VdmIntAck</a>;
01036         VdmTib-&gt;<a class="code" href="../../d0/d6/struct__Vdm__Tib.html#o5">EventInfo</a>.<a class="code" href="../../d1/d6/struct__VdmEventInfo.html#o0">Size</a> = 0;
01037         VdmTib-&gt;<a class="code" href="../../d0/d6/struct__Vdm__Tib.html#o5">EventInfo</a>.IntAckInfo = 0;
01038         <a class="code" href="../../d7/d7/strtexec_8c.html#a1">VdmEndExecution</a>(Frame, VdmTib);
01039     }
01040 }
01041 
01042 <span class="comment">//</span>
01043 <span class="comment">// These are only used by the GetVirtualBits() routine</span>
01044 <span class="comment">//</span>
01045 <span class="preprocessor">#define _VDM_EXTOFF_FUNC(x) (x = (x &amp; ~EFLAGS_INTERRUPT_MASK) | (*VdmFixedStateLinear &amp; (VDM_VIRTUAL_INTERRUPTS | EFLAGS_ALIGN_CHECK)) | EFLAGS_IOPL_MASK)</span>
01046 <span class="preprocessor"></span><span class="preprocessor">#define _VDM_EXTON_FUNC(x)  (x = (x &amp; ~EFLAGS_INTERRUPT_MASK) | (*VdmFixedStateLinear &amp; (VDM_VIRTUAL_INTERRUPTS | EFLAGS_ALIGN_CHECK)) | EFLAGS_IOPL_MASK)</span>
01047 <span class="preprocessor"></span><span class="preprocessor">#define _VDM_IOPL_FUNC(x)   (x = (x &amp; ~EFLAGS_ALIGN_CHECK) | (*VdmFixedStateLinear &amp; EFLAGS_ALIGN_CHECK) | EFLAGS_IOPL_MASK)</span>
01048 <span class="preprocessor"></span>
01049 
01050 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01051 GetVirtualBits(
01052     IN OUT PULONG PFlags,
01053     IN PKIA32_FRAME Frame
01054     )
01055 
01056 <span class="comment">/*++</span>
01057 <span class="comment"></span>
01058 <span class="comment">Routine Description: </span>
01059 <span class="comment"></span>
01060 <span class="comment">    This routine correctly gets the VDMs virtual interrupt flag</span>
01061 <span class="comment">    and puts it into an EFlags image</span>
01062 <span class="comment"></span>
01063 <span class="comment">Arguments:</span>
01064 <span class="comment"></span>
01065 <span class="comment">   PFlags - pointer to the Eflags</span>
01066 <span class="comment">   Frame - pointer to the ia32 trap frame</span>
01067 <span class="comment"></span>
01068 <span class="comment">Returns:</span>
01069 <span class="comment"></span>
01070 <span class="comment">  nothing</span>
01071 <span class="comment"></span>
01072 <span class="comment">--*/</span>
01073 {
01074     <span class="comment">// We need to decide if we want this or not...</span>
01075     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/emulx86_8c.html#a2">KeIA32VdmIoplAllowed</a>) {
01076         <span class="keywordflow">if</span> (*PFlags &amp; EFLAGS_V86_MASK) {
01077             _VDM_IOPL_FUNC(*PFlags);
01078         }
01079         <span class="keywordflow">else</span> {
01080             _VDM_EXTOFF_FUNC(*PFlags);
01081         }
01082     }
01083     <span class="keywordflow">else</span> {
01084 
01085         <span class="comment">//</span>
01086         <span class="comment">// A check was made for virtual extensions. We don't know if</span>
01087         <span class="comment">// we want to implement those extensions or not, so...</span>
01088         <span class="comment">//</span>
01089 
01090         <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/emulx86_8c.html#a3">KeIA32VirtualIntExtensions</a> &amp; (V86_VIRTUAL_INT_EXTENSIONS | PM_VIRTUAL_INT_EXTENSIONS)) {
01091             <span class="keywordflow">if</span> (*PFlags &amp; EFLAGS_V86_MASK) {
01092                 <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/emulx86_8c.html#a3">KeIA32VirtualIntExtensions</a> &amp; V86_VIRTUAL_INT_EXTENSIONS) {
01093                     _VDM_EXTON_FUNC(*PFlags);
01094                 }
01095                 <span class="keywordflow">else</span> {
01096                     _VDM_EXTOFF_FUNC(*PFlags);
01097                 }
01098             }
01099             <span class="keywordflow">else</span> {
01100                 <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/emulx86_8c.html#a3">KeIA32VirtualIntExtensions</a> &amp; PM_VIRTUAL_INT_EXTENSIONS) {
01101                     _VDM_EXTON_FUNC(*PFlags);
01102                 }
01103                 <span class="keywordflow">else</span> {
01104                     _VDM_EXTOFF_FUNC(*PFlags);
01105                 }
01106             }
01107         }
01108         <span class="keywordflow">else</span> {
01109             _VDM_EXTOFF_FUNC(*PFlags);
01110         }
01111     }
01112 }
01113 
01114 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01115 SetVirtualBits(
01116     IN ULONG Flags,
01117     IN PREGINFO PRegs
01118     )
01119 
01120 <span class="comment">/*++</span>
01121 <span class="comment"></span>
01122 <span class="comment">Routine Description: </span>
01123 <span class="comment"></span>
01124 <span class="comment">    This routine correctly sets the VDMs virtual interrupt flag</span>
01125 <span class="comment"></span>
01126 <span class="comment">Arguments:</span>
01127 <span class="comment"></span>
01128 <span class="comment">   Flags - the EFlags value </span>
01129 <span class="comment">   PRegs - pointer to instruction information (prefix, inst length, etc.)</span>
01130 <span class="comment"></span>
01131 <span class="comment">Returns:</span>
01132 <span class="comment"></span>
01133 <span class="comment">  nothing</span>
01134 <span class="comment"></span>
01135 <span class="comment">--*/</span>
01136 {
01137     KeIA32AndOrVdmLock(~VDM_VIRTUAL_INTERRUPTS, Flags &amp; EFLAGS_INTERRUPT_MASK);
01138 
01139     <span class="comment">//</span>
01140     <span class="comment">// There was a lot of code here to check for Virtual Extensions...</span>
01141     <span class="comment">// Depending on if they existed or not, a value in eax was changed</span>
01142     <span class="comment">// (in ../i386/instemul.asm - at label svb50: ) but it is never used</span>
01143     <span class="comment">// (not even as a return value...)</span>
01144     <span class="comment">// So, rather than repeat all that silly code that doesn't do anything,</span>
01145     <span class="comment">// I only show the code that is actually executed...  Enjoy...</span>
01146     <span class="comment">//</span>
01147   
01148 <span class="preprocessor">#if 0</span>
01149 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/emulx86_8c.html#a3">KeIA32VirtualIntExtensions</a> &amp; (V86_VIRTUAL_INT_EXTENSIONS | PM_VIRTUAL_INT_EXTENSIONS)) {
01150         <span class="keywordflow">if</span> (Flags &amp; EFLAGS_V86_MASK) {
01151             <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/emulx86_8c.html#a3">KeIA32VirtualIntExtensions</a> &amp; V86_VIRTUAL_INT_EXTENSIONS) {
01152             }
01153             <span class="keywordflow">else</span> {
01154             }
01155         }
01156         <span class="keywordflow">else</span> {
01157             <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/emulx86_8c.html#a3">KeIA32VirtualIntExtensions</a> &amp; PM_VIRTUAL_INT_EXTENSIONS) {
01158             }
01159             <span class="keywordflow">else</span> {
01160             }
01161         }
01162     }
01163     <span class="keywordflow">else</span> {
01164     }
01165 <span class="preprocessor">#endif</span>
01166 <span class="preprocessor"></span>
01167     <span class="keywordflow">if</span> (PRegs-&gt;RiPrefixFlags &amp; PREFIX_OPER32) {
01168         KeIA32AndOrVdmLock(~EFLAGS_ALIGN_CHECK, Flags &amp; EFLAGS_ALIGN_CHECK);
01169     }
01170 }
01171 
01172 
01173 BOOLEAN
01174 <a class="code" href="../../d0/d6/emulx86_8c.html#a4">KiIA32VdmReflectException</a>(
01175     IN OUT PKIA32_FRAME Frame,
01176     IN ULONG Code
01177     )
01178 <span class="comment">/*++</span>
01179 <span class="comment"></span>
01180 <span class="comment">Routine Description:</span>
01181 <span class="comment"></span>
01182 <span class="comment">    This routine reflects an exception to a VDM.  It uses the information</span>
01183 <span class="comment">    in the trap frame to determine what exception to reflect, and updates</span>
01184 <span class="comment">    the trap frame with the new CS, EIP, SS, and SP values</span>
01185 <span class="comment"></span>
01186 <span class="comment">Arguments:</span>
01187 <span class="comment"></span>
01188 <span class="comment">   Frame - Pointer to the IA32 trap frame</span>
01189 <span class="comment">   Code - The trap number that brought us here</span>
01190 <span class="comment"></span>
01191 <span class="comment">Returns</span>
01192 <span class="comment"></span>
01193 <span class="comment">    Nothing</span>
01194 <span class="comment"></span>
01195 <span class="comment">Notes:</span>
01196 <span class="comment">    Interrupts  are enable upon entry, Irql is at APC level</span>
01197 <span class="comment">    This routine may not preserve all of the non-volatile registers if</span>
01198 <span class="comment">    a fault occurs.</span>
01199 <span class="comment">--*/</span>
01200 {
01201     REGINFO Regs;
01202     KXDESCRIPTOR NewXCsDescriptor, NewXSsDescriptor;
01203 
01204     <span class="comment">//</span>
01205     <span class="comment">// First see if it is a GP fault and if we are set up to catch them</span>
01206     <span class="comment">//</span>
01207     <span class="keywordflow">if</span> ((Code == <a class="code" href="../../d8/d3/ia32def_8h.html#a13">EXCEPTION_GP_FAULT</a>) &amp;&amp; (*<a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a3">VdmFixedStateLinear</a> &amp; VDM_BREAK_EXCEPTIONS)) {
01208         VdmDispatchException(Frame, STATUS_ACCESS_VIOLATION, Frame-&gt;Eip, 2, 0, -1,  0);
01209         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01210     }
01211 
01212     <span class="comment">//</span>
01213     <span class="comment">// Then see if this is a debug exception</span>
01214     <span class="comment">//</span>
01215     <span class="keywordflow">if</span> (*<a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a3">VdmFixedStateLinear</a> &amp; VDM_BREAK_DEBUGGER) {
01216         <span class="keywordflow">if</span> (Code == <a class="code" href="../../d8/d3/ia32def_8h.html#a2">EXCEPTION_DEBUG</a>) {
01217             <span class="comment">//</span>
01218             <span class="comment">// BUGBUG: iVE doesn't respond to TF, so need to reset</span>
01219             <span class="comment">// it elsewhere as well</span>
01220             <span class="comment">// </span>
01221             Frame-&gt;EFlags &amp;= ~EFLAGS_TF_MASK;
01222             VdmDispatchException(Frame, STATUS_SINGLE_STEP, Frame-&gt;Eip, 0, 0, 0,  0);
01223             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01224         }
01225         <span class="keywordflow">if</span> (Code == <a class="code" href="../../d8/d3/ia32def_8h.html#a4">EXCEPTION_INT3</a>) {
01226             VdmDispatchException(Frame, STATUS_BREAKPOINT, Frame-&gt;Eip - 1, 3, USER_BREAKPOINT, 0,  0);
01227 
01228             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01229         }
01230     }
01231 
01232     <span class="comment">//</span>
01233     <span class="comment">// Don't really know why this is here... But it is...</span>
01234     <span class="comment">//</span>
01235     <span class="keywordflow">if</span> (FLATUSER(Frame)) {
01236         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01237     }
01238 
01239 
01240 <span class="preprocessor">#if DEVL</span>
01241 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (Code == <a class="code" href="../../d8/d3/ia32def_8h.html#a11">EXCEPTION_SEGMENT_NOT_PRESENT</a>) {
01242         ExVdmSegmentNotPresent++;
01243     }
01244 <span class="preprocessor">#endif</span>
01245 <span class="preprocessor"></span>
01246     <span class="comment">//</span>
01247     <span class="comment">// Allow for fiddling of the stack frame later</span>
01248     <span class="comment">//</span>
01249 
01250     Regs.RiTrapFrame = Frame;
01251     Regs.RiSegSs = Frame-&gt;SegSs;
01252     Regs.RiEsp = Frame-&gt;HardwareEsp;
01253     Regs.RiEFlags = Frame-&gt;EFlags;
01254     Regs.RiEip = Frame-&gt;Eip;
01255     Regs.RiSegCs = Frame-&gt;SegCs;
01256 
01257     <span class="keywordflow">if</span> (! CsToLinear(&amp;Regs, VM86USER(Frame))) {
01258         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01259     }
01260 
01261     <span class="keywordflow">if</span> (! SsToLinear(&amp;Regs, VM86USER(Frame))) {
01262         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01263     }
01264 
01265     <span class="keywordflow">if</span> (! PushException(Code, &amp;Regs)) {
01266         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01267     }
01268 
01269     <span class="comment">//</span>
01270     <span class="comment">// For EM, when we change any segment register, we</span>
01271     <span class="comment">// need to change the descriptor as well.. PushException()</span>
01272     <span class="comment">// may have changed CS and SS, so need to update their descriptors</span>
01273     <span class="comment">//</span>
01274     <span class="keywordflow">if</span> (Regs.RiEFlags &amp; EFLAGS_V86_MASK) {
01275 <span class="comment">// QUESTION</span>
01276         NewXCsDescriptor.DescriptorWords = (ULONGLONG) (Regs.RiSegCs &lt;&lt; 4);
01277         NewXSsDescriptor.DescriptorWords = (ULONGLONG) (Regs.RiSegSs &lt;&lt; 4);
01278     }
01279     <span class="keywordflow">else</span> {
01280         <span class="keywordflow">if</span> (! KeIA32UnscrambleLdtEntry(Regs.RiSegCs, &amp;NewXCsDescriptor)) {
01281             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01282         }
01283 
01284         <span class="keywordflow">if</span> (! KeIA32UnscrambleLdtEntry(Regs.RiSegSs, &amp;NewXSsDescriptor)) {
01285             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01286         }
01287     }
01288 
01289     Frame-&gt;HardwareEsp = Regs.RiEsp;
01290 
01291     <span class="comment">//</span>
01292     <span class="comment">// Ss touched in PushException()...</span>
01293     <span class="comment">//</span>
01294     Frame-&gt;SegSs = Regs.RiSegSs;
01295     Frame-&gt;EFlags = Regs.RiEFlags;
01296 
01297     <span class="comment">//</span>
01298     <span class="comment">// Cs touched in PushException()...</span>
01299     <span class="comment">//</span>
01300     Frame-&gt;SegCs = Regs.RiSegCs;
01301     Frame-&gt;Eip = Regs.RiEip;
01302 
01303     <span class="keywordflow">if</span> (Code == <a class="code" href="../../d8/d3/ia32def_8h.html#a2">EXCEPTION_DEBUG</a>) {
01304         <span class="comment">//</span>
01305         <span class="comment">// BUGBUG: iVE doesn't respond to TF, so need to reset</span>
01306         <span class="comment">// it elsewhere as well</span>
01307         <span class="comment">// </span>
01308         Frame-&gt;EFlags &amp;= ~EFLAGS_TF_MASK;
01309     }
01310 
01311     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01312 }
01313 
01314 
01315 BOOLEAN
01316 <a class="code" href="../../d0/d6/emulx86_8c.html#a6">KiIA32VdmSegmentNotPresent</a>(
01317     IN OUT PKIA32_FRAME Frame
01318     )
01319 <span class="comment">/*++</span>
01320 <span class="comment"></span>
01321 <span class="comment">Routine Description:</span>
01322 <span class="comment"></span>
01323 <span class="comment">    This routine reflects a TRAP 0x0B to a VDM. It uses information</span>
01324 <span class="comment">    in the trap frame to determine what exception to reflect</span>
01325 <span class="comment">    and updates the trap frame with the new CS, EIP, SS, and ESP values</span>
01326 <span class="comment"></span>
01327 <span class="comment">Arguments:</span>
01328 <span class="comment"></span>
01329 <span class="comment">    Frame - Pointer to the IA32 trap frame</span>
01330 <span class="comment"></span>
01331 <span class="comment">Returns</span>
01332 <span class="comment"></span>
01333 <span class="comment">    True if the reflection was successful, false otherwise</span>
01334 <span class="comment"></span>
01335 <span class="comment">Notes:</span>
01336 <span class="comment">    none</span>
01337 <span class="comment">--*/</span>
01338 {
01339     <a class="code" href="../../d0/d6/struct__Vdm__Tib.html">PVDM_TIB</a> VdmTib;
01340     PVDM_FAULTHANDLER NoSegFault;
01341     ULONG Flags;
01342     KXDESCRIPTOR NewXCsDescriptor;
01343     KXDESCRIPTOR NewXSsDescriptor;
01344     ULONG <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>;
01345 
01346     <span class="comment">//</span>
01347     <span class="comment">// Get the Segment Not Present handler information</span>
01348     <span class="comment">//</span>
01349     VdmTib = (<a class="code" href="../../d0/d6/struct__Vdm__Tib.html">PVDM_TIB</a>) (<a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>()-&gt;Tcb.Teb)-&gt;Vdm;
01350 
01351     <span class="comment">//</span>
01352     <span class="comment">// If not switching stacks, let regular reflection code handle this...</span>
01353     <span class="comment">//</span>
01354     <span class="keywordflow">if</span> (VdmTib-&gt;PmStackInfo.LockCount != 0) {
01355         <span class="keywordflow">return</span>(<a class="code" href="../../d0/d6/emulx86_8c.html#a4">KiIA32VdmReflectException</a>(Frame, EXCEPTION_SEGMENT_NOT_PRESENT));
01356     }
01357 
01358     NoSegFault = &amp;(VdmTib-&gt;VdmFaultHandlers[<a class="code" href="../../d8/d3/ia32def_8h.html#a11">EXCEPTION_SEGMENT_NOT_PRESENT</a>]);
01359 
01360 <span class="preprocessor">#if DEVL</span>
01361 <span class="preprocessor"></span>    ExVdmSegmentNotPresent++;
01362 <span class="preprocessor">#endif</span>
01363 <span class="preprocessor"></span>
01364     <span class="comment">//</span>
01365     <span class="comment">// Just like SwitchToStack() if there had been one...</span>
01366     <span class="comment">//</span>
01367     VdmTib-&gt;PmStackInfo.LockCount++;
01368     VdmTib-&gt;PmStackInfo.SaveEip = Frame-&gt;Eip;
01369     VdmTib-&gt;PmStackInfo.SaveEsp = Frame-&gt;HardwareEsp;
01370     VdmTib-&gt;PmStackInfo.SaveSsSelector = Frame-&gt;SegSs;
01371 
01372     <span class="comment">//</span>
01373     <span class="comment">// We'll need to update the Frame with the proper descriptors,</span>
01374     <span class="comment">// so get them and unscramble them now...</span>
01375     <span class="comment">//</span>
01376     <span class="keywordflow">if</span> (! KeIA32UnscrambleLdtEntry(NoSegFault-&gt;CsSelector, &amp;NewXCsDescriptor)) {
01377         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01378     }
01379 
01380     <span class="keywordflow">if</span> (! KeIA32UnscrambleLdtEntry(VdmTib-&gt;PmStackInfo.SsSelector, &amp;NewXSsDescriptor)) {
01381         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01382     }
01383 
01384     <span class="comment">//</span>
01385     <span class="comment">// Regardless of 16/32 bit handler, still need the flags</span>
01386     <span class="comment">//</span>
01387     Flags = Frame-&gt;EFlags;
01388     GetVirtualBits(&amp;Flags, Frame);
01389 
01390     <span class="comment">//</span>
01391     <span class="comment">// See if this is a 32-bit handler</span>
01392     <span class="comment">//</span>
01393     <span class="keywordflow">if</span> (VdmTib-&gt;PmStackInfo.<a class="code" href="../../d0/d6/struct__Vdm__Tib.html#o1">Flags</a> &amp; 1) {
01394         PULONG ExcptStack32;
01395 
01396         <span class="comment">//</span>
01397         <span class="comment">// Now make ExcptStack points to the actual stack space...</span>
01398         <span class="comment">//</span>
01399         ExcptStack32 = (PULONG) (NewXSsDescriptor.Words.Bits.Base + DPMISTACK_OFFSET);
01400 
01401         <span class="comment">//</span>
01402         <span class="comment">// And put normal fault arguments on the stack...</span>
01403         <span class="comment">//</span>
01404 <span class="comment">// QUESTION</span>
01405         *--ExcptStack32 = Frame-&gt;SegSs;
01406         *--ExcptStack32 = Frame-&gt;HardwareEsp;
01407         *--ExcptStack32 = Flags;
01408 
01409         *--ExcptStack32 = Frame-&gt;SegCs;
01410         *--ExcptStack32 = Frame-&gt;Eip;
01411         *--ExcptStack32 = Frame-&gt;ISRCode;
01412 
01413         <span class="comment">//</span>
01414         <span class="comment">// And push dosx iret segment and offset</span>
01415         <span class="comment">//</span>
01416         *--ExcptStack32 = VdmTib-&gt;PmStackInfo.DosxFaultIretD &gt;&gt; 16;
01417         *--ExcptStack32 = VdmTib-&gt;PmStackInfo.DosxFaultIretD &amp;  0x0ffff;
01418 
01419         <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> = ((PUCHAR) ExcptStack32) - NewXSsDescriptor.Words.Bits.Base;
01420     }
01421     <span class="keywordflow">else</span> {
01422         <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a> ExcptStack16;
01423 
01424         <span class="comment">//</span>
01425         <span class="comment">// Now make ExcptStack points to the actual stack space...</span>
01426         <span class="comment">//</span>
01427         ExcptStack16 = NewXSsDescriptor.Words.Bits.Base + DPMISTACK_OFFSET;
01428 
01429         <span class="comment">//</span>
01430         <span class="comment">// And put normal fault arguments on the stack...</span>
01431         <span class="comment">//</span>
01432         *--ExcptStack16 = Frame-&gt;SegSs;
01433         *--ExcptStack16 = Frame-&gt;HardwareEsp;
01434         *--ExcptStack16 = Flags;
01435 
01436         *--ExcptStack16 = Frame-&gt;SegCs;
01437         *--ExcptStack16 = Frame-&gt;Eip;
01438         *--ExcptStack16 = Frame-&gt;ISRCode;
01439 
01440         <span class="comment">//</span>
01441         <span class="comment">// And push dosx iret segment and offset</span>
01442         <span class="comment">//</span>
01443         *--ExcptStack16 = VdmTib-&gt;PmStackInfo.DosxFaultIretD &gt;&gt; 16;
01444         *--ExcptStack16 = VdmTib-&gt;PmStackInfo.DosxFaultIretD &amp;  0x0ffff;
01445         <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> = ((PUCHAR) ExcptStack16) - NewXSsDescriptor.Words.Bits.Base;
01446     }
01447 
01448     <span class="keywordflow">if</span> (NoSegFault-&gt;Flags &amp; VDM_INT_INT_GATE) {
01449         KeIA32AndOrVdmLock(~VDM_VIRTUAL_INTERRUPTS, 0);
01450         Frame-&gt;EFlags &amp;= ~EFLAGS_VIF;
01451     }
01452 
01453     Frame-&gt;SegCs = NoSegFault-&gt;CsSelector;
01454     Frame-&gt;Eip = NoSegFault-&gt;Eip;
01455     Frame-&gt;SegSs = VdmTib-&gt;PmStackInfo.SsSelector;
01456     Frame-&gt;HardwareEsp = <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>;
01457 
01458     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01459 }
01460 
01461 
01462 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01463 VdmDispatchException(
01464     IN PKIA32_FRAME Frame,
01465     IN NTSTATUS ExcepCode,
01466     IN PVOID ExcepAddr,
01467     IN ULONG NumParms,
01468     IN ULONG Parm1,
01469     IN ULONG Parm2,
01470     IN ULONG Parm3
01471     )
01472 
01473 <span class="comment">/*++</span>
01474 <span class="comment"></span>
01475 <span class="comment">Routine Description: </span>
01476 <span class="comment"></span>
01477 <span class="comment">    Dispatches an exception for the VDM to the kernel by invoking the</span>
01478 <span class="comment">    KiIA32DispatchException() routine.</span>
01479 <span class="comment"></span>
01480 <span class="comment">Arguments:</span>
01481 <span class="comment"></span>
01482 <span class="comment">    See KiIA32DispatchException()</span>
01483 <span class="comment"></span>
01484 <span class="comment">Returns:</span>
01485 <span class="comment"></span>
01486 <span class="comment">    nothing</span>
01487 <span class="comment"></span>
01488 <span class="comment">--*/</span>
01489 {
01490     <span class="comment">//</span>
01491     <span class="comment">// Lower the IRQL to 0 and give any APC's and Debuggers a chance</span>
01492     <span class="comment">//</span>
01493 <span class="comment">// QUESTION</span>
01494     <a class="code" href="../../d9/d5/verifier_8c.html#a117">KeLowerIrql</a>(0);
01495 
01496     <span class="comment">//</span>
01497         <span class="comment">// Might as well make sure things are legal...</span>
01498     <span class="comment">//</span>
01499     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(NumParms &lt;= 3);
01500 
01501     <span class="comment">//</span>
01502     <span class="comment">// This was a call to CommonDispatchException() but that routine</span>
01503     <span class="comment">// doesn't exist in EM, so trying to call the nearest available...</span>
01504     <span class="comment">//</span>
01505     KiIA32ExceptionDispatch(Frame, ExcepCode, ExcepAddr, NumParms, Parm1, Parm2, Parm3);
01506 
01507         <span class="comment">//</span>
01508     <span class="comment">// Should Never get here... KiIA32ExceptionDispatch() never returns...</span>
01509         <span class="comment">//</span>
01510 }
01511 
01512 
01513 BOOLEAN
01514 PushInt(IN ULONG InterruptNumber,
01515         IN OUT PREGINFO Regs
01516         )
01517 <span class="comment">/*++</span>
01518 <span class="comment"></span>
01519 <span class="comment">Routine Description:</span>
01520 <span class="comment"></span>
01521 <span class="comment">    This routine pushes an interrupt frame on the user stack</span>
01522 <span class="comment"></span>
01523 <span class="comment">Arguments:</span>
01524 <span class="comment"></span>
01525 <span class="comment">   InterruptNumber - self explanitory...</span>
01526 <span class="comment">   Regs - Pointer to a REGINFO structure</span>
01527 <span class="comment"></span>
01528 <span class="comment">Returns:</span>
01529 <span class="comment"></span>
01530 <span class="comment">    True if stack successfully modified and Regs updated, otherwise false</span>
01531 <span class="comment"></span>
01532 <span class="comment">Notes:</span>
01533 <span class="comment"></span>
01534 <span class="comment">    None</span>
01535 <span class="comment">--*/</span>
01536 {
01537     <a class="code" href="../../d0/d6/struct__Vdm__Tib.html">PVDM_TIB</a> VdmTib;
01538     <a class="code" href="../../d9/d5/struct__Vdm__InterruptHandler.html">PVDM_INTERRUPTHANDLER</a> IntHandler;
01539     PULONG ExcptStack32;
01540     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a> ExcptStack16;
01541     ULONG Flags;
01542 
01543     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(InterruptNumber &lt; 256);
01544 
01545     VdmTib = (<a class="code" href="../../d0/d6/struct__Vdm__Tib.html">PVDM_TIB</a>) (<a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>()-&gt;Tcb.Teb)-&gt;Vdm;
01546 
01547     IntHandler = &amp;(VdmTib-&gt;<a class="code" href="../../d0/d6/struct__Vdm__Tib.html#o2">VdmInterruptHandlers</a>[InterruptNumber]);
01548 
01549         <span class="comment">//</span>
01550         <span class="comment">// If we are a small segment, make sure the ESP is 16 bits.</span>
01551         <span class="comment">//</span>
01552         <span class="keywordflow">if</span> (! Regs-&gt;RiSsDescriptor.Words.Bits.Default_Big) {
01553                 Regs-&gt;RiEsp &amp;= 0xffff;
01554         }
01555 
01556         <span class="comment">//</span>
01557         <span class="comment">// Make sure there is space on the stack</span>
01558         <span class="comment">//</span>
01559         <span class="keywordflow">if</span> (IntHandler-&gt;Flags &amp; VDM_INT_32) {
01560                 <span class="keywordflow">if</span> (Regs-&gt;RiEsp &lt;= (3 * <span class="keyword">sizeof</span>(PVOID))) {
01561                         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01562                 }
01563 
01564                 Regs-&gt;RiEsp -= 3 * <span class="keyword">sizeof</span>(PVOID);
01565         }
01566         <span class="keywordflow">else</span> {
01567                 <span class="keywordflow">if</span> (Regs-&gt;RiEsp &lt;= (3 * <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a13">SHORT</a>))) {
01568                         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01569                 }
01570 
01571                 Regs-&gt;RiEsp -= 3 * <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a13">SHORT</a>);
01572         }
01573 
01574         <span class="comment">//</span>
01575         <span class="comment">// Check that esp is still OK</span>
01576         <span class="comment">//</span>
01577         <span class="keywordflow">if</span> (Regs-&gt;RiSsDescriptor.Words.Bits.Type &amp; DESCRIPTOR_EXPAND_DOWN) {
01578                 <span class="keywordflow">if</span> (Regs-&gt;RiEsp &lt;= Regs-&gt;RiSsLimit) {
01579                         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01580                 }
01581         }
01582         <span class="keywordflow">else</span> {
01583                 <span class="keywordflow">if</span> (Regs-&gt;RiEsp &gt;= Regs-&gt;RiSsLimit) {
01584                         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01585                 }
01586         }
01587 
01588         <span class="comment">//</span>
01589         <span class="comment">// Push the iret frame</span>
01590         <span class="comment">//</span>
01591 
01592         <span class="comment">//</span>
01593         <span class="comment">// Get the modified EFlags</span>
01594         <span class="comment">//</span>
01595         Flags = Regs-&gt;RiEFlags;
01596         GetVirtualBits(&amp;Flags, Regs-&gt;RiTrapFrame);
01597 
01598         <span class="keywordflow">if</span> (IntHandler-&gt;Flags &amp; VDM_INT_32) {
01599                 ExcptStack32 = Regs-&gt;RiSsBase + Regs-&gt;RiEsp;
01600 
01601                 <span class="comment">//</span>
01602                 <span class="comment">// And put arguments on the stack...</span>
01603                 <span class="comment">//</span>
01604                 *ExcptStack32++ = Regs-&gt;RiEip;
01605                 *ExcptStack32++ = Regs-&gt;RiSegCs;
01606                 *ExcptStack32 = Flags;
01607         }
01608         <span class="keywordflow">else</span> {
01609                 ExcptStack16 = Regs-&gt;RiSsBase + Regs-&gt;RiEsp;
01610 
01611                 <span class="comment">//</span>
01612                 <span class="comment">// And put arguments on the stack...</span>
01613                 <span class="comment">//</span>
01614                 *ExcptStack16++ = Regs-&gt;RiEip;
01615                 *ExcptStack16++ = Regs-&gt;RiSegCs;
01616                 *ExcptStack16 = Flags;
01617         }
01618 
01619         <span class="comment">//</span>
01620         <span class="comment">// Make sure the address pointed to by CS exists</span>
01621         <span class="comment">//</span>
01622         Regs.RiSegCs = IntHandler-&gt;<a class="code" href="../../d9/d5/struct__Vdm__InterruptHandler.html#o0">CsSelector</a>;
01623         Regs.RiEip = IntHandler-&gt;<a class="code" href="../../d9/d5/struct__Vdm__InterruptHandler.html#o1">Eip</a>;
01624 
01625         <span class="keywordflow">if</span> (CsToLinear(&amp;Regs, ! (IntHandler-&gt;Flags &amp; VDM_INT_32))) {
01626                 <span class="keywordflow">if</span> (! Regs-&gt;RiCsDescriptor.Words.Bits.Pres) {
01627                         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01628                 }
01629         }
01630         <span class="keywordflow">else</span> {
01631                 <span class="comment">//</span>
01632                 <span class="comment">// This is a little strange... CsToLinear fails if either the</span>
01633                 <span class="comment">// type of the descriptor is wrong, or if the limit is bad...</span>
01634                 <span class="comment">// Only reject the INT handler if the limit is bad...</span>
01635                 <span class="comment">//</span>
01636 
01637                 <span class="keywordflow">if</span> (Regs.RiEip &gt;= Regs.RiCsLimit) {
01638                         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01639                 }
01640         }
01641 
01642         Regs.RiEFlags &amp;= ~EFLAGS_TF_MASK;
01643 
01644         <span class="keywordflow">if</span> (IntHandler-&gt;Flags &amp; VDM_INT_INT_GATE) {
01645                 <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/emulx86_8c.html#a3">KeIA32VirtualIntExtensions</a> &amp; PM_VIRTUAL_INT_EXTENSIONS) {
01646                         Regs-&gt;RiEFlags &amp;= ~EFLAGS_VIF;
01647                 }
01648                 KeIA32AndOrVdmLock(~EFLAGS_INTERRUPT_MASK, 0);
01649         }
01650 
01651         Regs.RiEFlags &amp;= ~(EFLAGS_IOPL_MASK | EFLAGS_NT_MASK | EFLAGS_V86_MASK);
01652         Regs.RiEFlags |= EFLAGS_INTERRUPT_MASK;
01653 
01654         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01655 }
01656 
01657 
01658 BOOLEAN
01659 PushException(
01660         IN ULONG ExceptionNumber,
01661         IN OUT PREGINFO Regs
01662         )
01663 <span class="comment">/*++</span>
01664 <span class="comment"></span>
01665 <span class="comment">Routine Description:</span>
01666 <span class="comment"></span>
01667 <span class="comment">    This routine pushes an exception onto the user stack</span>
01668 <span class="comment"></span>
01669 <span class="comment">Arguments:</span>
01670 <span class="comment"></span>
01671 <span class="comment">   ExceptionNumber - self explanitory...</span>
01672 <span class="comment">   Regs - Pointer to a REGINFO structure</span>
01673 <span class="comment"></span>
01674 <span class="comment">Returns:</span>
01675 <span class="comment"></span>
01676 <span class="comment">    True if stack successfully modified and Regs updated, otherwise false</span>
01677 <span class="comment"></span>
01678 <span class="comment">Notes:</span>
01679 <span class="comment"></span>
01680 <span class="comment">    None</span>
01681 <span class="comment">--*/</span>
01682 {
01683     <a class="code" href="../../d0/d6/struct__Vdm__Tib.html">PVDM_TIB</a> VdmTib;
01684     PVDM_FAULTHANDLER ExceptHandler;
01685     ULONG Flags;
01686 
01687     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(ExceptionNumber &lt; 32);
01688 
01689     VdmTib = (<a class="code" href="../../d0/d6/struct__Vdm__Tib.html">PVDM_TIB</a>) (<a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>()-&gt;Tcb.Teb)-&gt;Vdm;
01690     ExceptHandler = &amp;(VdmTib-&gt;VdmFaultHandlers[ExceptionNumber]);
01691 
01692     <span class="keywordflow">if</span> (Regs-&gt;RiEFlags &amp; EFLAGS_V86_MASK) {
01693         <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a> ExcptStack16;
01694 
01695         <span class="comment">// We were in V86 mode when exception happened...</span>
01696 
01697         <span class="comment">//</span>
01698         <span class="comment">// device not available fault... Per win3.1, no exceptions</span>
01699         <span class="comment">// above 7 for v86 mode</span>
01700         <span class="comment">//</span>
01701         <span class="keywordflow">if</span> (ExceptionNumber &gt; 7) {
01702             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01703         }
01704 
01705         <span class="comment">//</span>
01706         <span class="comment">// And push things on the stack for V86 mode</span>
01707         <span class="comment">// making sure to handle wrap-around each time...</span>
01708         <span class="comment">//</span>
01709         Regs-&gt;RiEsp = ((Regs-&gt;RiEsp - 2) &amp; 0xffff);
01710         ExcptStack16 = Regs-&gt;RiSsBase + Regs-&gt;RiEsp;
01711         Flags = Regs-&gt;RiEFlags;
01712         GetVirtualBits(&amp;Flags, Regs-&gt;RiTrapFrame);
01713         *ExcptStack16 = Flags;
01714 
01715         Regs-&gt;RiEsp = ((Regs-&gt;RiEsp - 2) &amp; 0xffff);
01716         ExcptStack16 = Regs-&gt;RiSsBase + Regs-&gt;RiEsp;
01717         *ExcptStack16 = Regs-&gt;RiSegCs;
01718 
01719         Regs-&gt;RiEsp = ((Regs-&gt;RiEsp - 2) &amp; 0xffff);
01720         ExcptStack16 = Regs-&gt;RiSsBase + Regs-&gt;RiEsp;
01721         *ExcptStack16 = Regs-&gt;RiEip;
01722     }
01723     <span class="keywordflow">else</span> {
01724         <span class="comment">// We were in protected mode when the exception happened...</span>
01725 
01726         <span class="comment">//</span>
01727         <span class="comment">// This was originally part of a seperate routine</span>
01728         <span class="comment">// called SwitchToHandlerStack(), but it was never called</span>
01729         <span class="comment">// anywhere else, so now it's inline...</span>
01730         <span class="comment">//</span>
01731 
01732         <span class="comment">//</span>
01733         <span class="comment">// Have we already switched stacks?</span>
01734         <span class="comment">//</span>
01735         <span class="keywordflow">if</span> (VdmTib-&gt;PmStackInfo.LockCount == 0) {
01736             VdmTib-&gt;PmStackInfo.SaveEip = Regs.RiEip;
01737             VdmTib-&gt;PmStackInfo.SaveEsp = Regs.RiEsp;
01738             VdmTib-&gt;PmStackInfo.SaveSsSelector = Regs.RiSegSs;
01739 
01740             Regs-&gt;RiSegSs = VdmTib-&gt;PmStackInfo.SsSelector;
01741             Regs-&gt;RiEsp = DPMISTACK_EXCEPTION_OFFSET;
01742 
01743             <span class="comment">//</span>
01744             <span class="comment">// And update and verify the Regs structure</span>
01745             <span class="comment">//</span>
01746             <span class="keywordflow">if</span> (! SsToLinear(Regs, FALSE)) {
01747                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01748             }
01749 
01750             VdmTib-&gt;PmStackInfo.LockCount++;
01751         }
01752 
01753         <span class="comment">//</span>
01754         <span class="comment">// Windows 3.1 undocumented feature</span>
01755         <span class="comment">//</span>
01756         Regs-&gt;RiEsp -= 0x20;
01757 
01758         <span class="keywordflow">if</span> (! Regs-&gt;RiSsDescriptor.Words.Bits.Default_Big) {
01759             <span class="comment">//</span>
01760             <span class="comment">// If we are not "big" then the ESP should stay 16 bit</span>
01761             <span class="comment">//</span>
01762             Regs-&gt;RiEsp &amp;= 0xffff;
01763         }
01764 
01765         Flags = Regs-&gt;RiEFlags;
01766         GetVirtualBits(&amp;Flags, Regs-&gt;RiTrapFrame);
01767 
01768         <span class="keywordflow">if</span> (VdmTib-&gt;PmStackInfo.<a class="code" href="../../d0/d6/struct__Vdm__Tib.html#o1">Flags</a>) {
01769             PULONG ExcptStack32;
01770 
01771             <span class="comment">//</span>
01772             <span class="comment">// This is a 32-bit handler</span>
01773             <span class="comment">//</span>
01774 
01775             <span class="keywordflow">if</span> (! CheckEsp(Regs, 32)) {
01776                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01777             }
01778 
01779             ExcptStack32 = Regs.RiSsBase + Regs.RiEsp;
01780             *--ExcptStack32 = VdmTib-&gt;PmStackInfo.SaveSsSelector;
01781             *--ExcptStack32 = VdmTib-&gt;PmStackInfo.SaveEsp;
01782             *--ExcptStack32 = Flags;
01783             *--ExcptStack32 = Regs-&gt;RiSegCs;
01784             *--ExcptStack32 = VdmTib-&gt;PmStackInfo.SaveEip;
01785             *--ExcptStack32 = Regs-&gt;RiTrapFrame-&gt;ISRCode;
01786 
01787             <span class="comment">//</span>
01788             <span class="comment">// And push dosx iret segment and offset</span>
01789             <span class="comment">//</span>
01790             *--ExcptStack32 = VdmTib-&gt;PmStackInfo.DosxFaultIretD &gt;&gt; 16;
01791             *--ExcptStack32 = VdmTib-&gt;PmStackInfo.DosxFaultIretD &amp;  0x0ffff;
01792 
01793 <span class="comment">// QUESTION</span>
01794             Regs.RiEsp = ExcptStack32 - Regs.RiSsBase;
01795 
01796         }
01797         <span class="keywordflow">else</span> {
01798             <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a> ExcptStack16;
01799 
01800             <span class="comment">//</span>
01801             <span class="comment">// Do the 16 bit handler thing...</span>
01802             <span class="comment">//</span>
01803 
01804             <span class="keywordflow">if</span> (! CheckEsp(Regs, 16)) {
01805                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01806             }
01807 
01808             ExcptStack16 = Regs.RiSsBase + Regs.RiEsp;
01809             *--ExcptStack16 = VdmTib-&gt;PmStackInfo.SaveSsSelector;
01810             *--ExcptStack16 = VdmTib-&gt;PmStackInfo.SaveEsp;
01811             *--ExcptStack16 = Flags;
01812             *--ExcptStack16 = Regs-&gt;RiSegCs;
01813             *--ExcptStack16 = VdmTib-&gt;PmStackInfo.SaveEip;
01814             *--ExcptStack16 = Regs-&gt;RiTrapFrame-&gt;ISRCode;
01815 
01816             <span class="comment">//</span>
01817             <span class="comment">// And push dosx iret segment and offset</span>
01818             <span class="comment">//</span>
01819             *--ExcptStack16 = VdmTib-&gt;PmStackInfo.DosxFaultIretD &gt;&gt; 16;
01820             *--ExcptStack16 = VdmTib-&gt;PmStackInfo.DosxFaultIretD &amp;  0x0ffff;
01821 
01822             Regs-&gt;RiEsp = ExcptStack16 - Regs.RiSsBase;
01823         }
01824     }
01825 
01826     <span class="comment">//</span>
01827     <span class="comment">// Make sure the address pointed to by CS exists</span>
01828     <span class="comment">//</span>
01829     Regs.RiSegCs = ExceptHandler-&gt;CsSelector;
01830     Regs.RiEip = ExceptHandler-&gt;Eip;
01831 
01832     <span class="keywordflow">if</span> (! CsToLinear(&amp;Regs, Regs-&gt;RiEFlags &amp; EFLAGS_V86_MASK)) {
01833         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01834     }
01835 
01836     <span class="comment">//</span>
01837     <span class="comment">// Strange, they do this test twice  - it is part of CsToLinear()</span>
01838     <span class="comment">//</span>
01839     <span class="comment">// if (Regs.RiEip &gt; Regs.RiCsLimit) {</span>
01840     <span class="comment">//      return FALSE;</span>
01841     <span class="comment">// }</span>
01842 
01843     <span class="keywordflow">if</span> (ExceptHandler-&gt;Flags &amp; VDM_INT_INT_GATE) {
01844         SetVirtualBits(Regs-&gt;RiEFlags &amp; ~(EFLAGS_INTERRUPT_MASK | EFLAGS_TF_MASK), &amp;Regs);
01845     }
01846 
01847     CheckVdmFlags(&amp;Regs);
01848 
01849     Regs.RiEFlags &amp;= ~EFLAGS_TF_MASK;
01850 
01851     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01852 }
01853 
01854 
01855 BOOLEAN
01856 CsToLinear(
01857         IN OUT PREGINFO Regs,
01858         IN BOOLEAN IsV86
01859         )
01860 <span class="comment">/*++</span>
01861 <span class="comment"></span>
01862 <span class="comment">Routine Description:</span>
01863 <span class="comment"></span>
01864 <span class="comment">    This routine converts the address shown in CS and IP into a linear</span>
01865 <span class="comment">    address based on the mode (V86 vs. protected)</span>
01866 <span class="comment"></span>
01867 <span class="comment">Arguments:</span>
01868 <span class="comment"></span>
01869 <span class="comment">    Regs - Pointer to a REGINFO structure</span>
01870 <span class="comment">    IsV86 - True if the CS and IP should be checked against V86 constraints</span>
01871 <span class="comment"></span>
01872 <span class="comment">Returns:</span>
01873 <span class="comment"></span>
01874 <span class="comment">    True if Regs-&gt;RiLinearAddr is valid, otherwise false</span>
01875 <span class="comment"></span>
01876 <span class="comment">Notes:</span>
01877 <span class="comment"></span>
01878 <span class="comment">    None</span>
01879 <span class="comment">--*/</span>
01880 {
01881     <span class="keywordflow">if</span> (IsV86) {
01882         <span class="comment">//</span>
01883         <span class="comment">// Don't need the Descriptor in V86 mode</span>
01884         <span class="comment">//</span>
01885         Regs-&gt;RiCsBase = Regs-&gt;RiSegCs &lt;&lt; 4;
01886 <span class="comment">// QUESTION</span>
01887         Regs-&gt;RiCsDescriptor.DescriptorWords = (ULONGLONG) Regs-&gt;RiCsBase;
01888         Regs-&gt;RiCsLimit = 0xffff;
01889     }
01890     <span class="keywordflow">else</span> {
01891 
01892         <span class="keywordflow">if</span> (! KeIA32UnscrambleLdtEntry(Regs-&gt;RiSegCs, &amp;Regs-&gt;RiCsDescriptor)) {
01893             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01894         }
01895 
01896         <span class="comment">//</span>
01897         <span class="comment">// Need to fill in the cs stuff to make translation to linear</span>
01898         <span class="comment">// addresses easier</span>
01899         <span class="comment">//</span>
01900         Regs-&gt;RiCsBase = (ULONG) Regs-&gt;RiCsDescriptor.Words.Bits.Base;
01901         Regs-&gt;RiCsLimit = (ULONG) Regs-&gt;RiCsDescriptor.Words.Bits.Limit;
01902 
01903         <span class="comment">//</span>
01904         <span class="comment">// Check for the big limits</span>
01905         <span class="comment">//</span>
01906         <span class="keywordflow">if</span> (Regs-&gt;RiCsDescriptor.Words.Bits.Granularity) {
01907                 Regs-&gt;RiCsLimit &lt;&lt;= 12;
01908                 Regs-&gt;RiCsLimit |= 0xfff;
01909         }
01910 
01911         <span class="comment">//</span>
01912         <span class="comment">// Make sure the cs segment is executable code...</span>
01913         <span class="comment">// (see Ki386GetSelectorParameters()...)</span>
01914         <span class="comment">//</span>
01915         <span class="comment">// Check is done here because the other stuff should be done even</span>
01916         <span class="comment">// if this check fails</span>
01917         <span class="comment">//</span>
01918         <span class="keywordflow">if</span> ((Regs-&gt;RiCsDescriptor.Words.Bits.Type &amp; TYPE_CODE_USER ) != 
01919              TYPE_CODE_USER) {
01920              <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01921         }
01922     }
01923 
01924     <span class="comment">//</span>
01925     <span class="comment">// Now make sure the ip is in the correct range</span>
01926     <span class="comment">//</span>
01927     <span class="keywordflow">if</span> (Regs-&gt;RiEip &gt; Regs-&gt;RiCsLimit) {
01928         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01929     }
01930 
01931     <span class="comment">//</span>
01932     <span class="comment">// Finally, generate the linear address</span>
01933     <span class="comment">//</span>
01934     Regs-&gt;RiLinearAddr = Regs-&gt;RiEip + Regs-&gt;RiCsBase;
01935 
01936     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01937 }
01938 
01939 
01940 BOOLEAN
01941 CheckEip(
01942         IN PREGINFO Regs
01943         )
01944 <span class="comment">/*++</span>
01945 <span class="comment"></span>
01946 <span class="comment">Routine Description:</span>
01947 <span class="comment"></span>
01948 <span class="comment">    This routine verifies the EIP is legal before putting it back into</span>
01949 <span class="comment">    a trap frame.</span>
01950 <span class="comment"></span>
01951 <span class="comment">Arguments:</span>
01952 <span class="comment"></span>
01953 <span class="comment">   Regs - Pointer to a REGINFO structure</span>
01954 <span class="comment"></span>
01955 <span class="comment">Returns:</span>
01956 <span class="comment"></span>
01957 <span class="comment">    True if the EIP is legal, false otherwise</span>
01958 <span class="comment"></span>
01959 <span class="comment">Notes:</span>
01960 <span class="comment"></span>
01961 <span class="comment">--*/</span>
01962 {
01963     <span class="keywordflow">if</span> (Regs-&gt;RiEFlags &amp; EFLAGS_V86_MASK) {
01964         Regs-&gt;RiEip &amp;= Regs-&gt;RiCsLimit;
01965     }
01966     <span class="keywordflow">else</span> {
01967         <span class="keywordflow">if</span> (Regs-&gt;RiEip &gt; Regs-&gt;RiCsLimit) {
01968             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01969         }
01970     }
01971 
01972     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01973 }
01974 
01975 
01976 BOOLEAN
01977 SsToLinear(
01978         IN OUT PREGINFO Regs,
01979         IN BOOLEAN IsV86
01980         )
01981 <span class="comment">/*++</span>
01982 <span class="comment"></span>
01983 <span class="comment">Routine Description:</span>
01984 <span class="comment"></span>
01985 <span class="comment">    This routine converts the SS selector given in the regs structure</span>
01986 <span class="comment">    into a base and limit based on the mode (V86 vs. protected)</span>
01987 <span class="comment"></span>
01988 <span class="comment"></span>
01989 <span class="comment">Arguments:</span>
01990 <span class="comment"></span>
01991 <span class="comment">    Regs - Pointer to a REGINFO structure</span>
01992 <span class="comment">    IsV86 - True if the Base and Limit should be set using V86 constraints</span>
01993 <span class="comment"></span>
01994 <span class="comment">Returns:</span>
01995 <span class="comment"></span>
01996 <span class="comment">    True if Regs-&gt;RiSsBase and Regs-&gt;RiSsLimit are valid, false otherwise</span>
01997 <span class="comment"></span>
01998 <span class="comment">Notes:</span>
01999 <span class="comment"></span>
02000 <span class="comment">    Unlike FastCsToLinear(), this routine does not verify that the user of</span>
02001 <span class="comment">    the segment (in this case, ESP) is actually within the proper limits</span>
02002 <span class="comment">--*/</span>
02003 {
02004     <span class="keywordflow">if</span> (IsV86) {
02005         <span class="comment">//</span>
02006         <span class="comment">// Don't need the descriptor in this case</span>
02007         <span class="comment">//</span>
02008         Regs-&gt;RiSsBase = Regs-&gt;RiSegSs &lt;&lt; 4;
02009         Regs-&gt;RiSsDescriptor.DescriptorWords = (ULONGLONG) Regs-&gt;RiSsBase;
02010         Regs-&gt;RiSsLimit = 0xffff;
02011     }
02012     <span class="keywordflow">else</span> {
02013         <span class="keywordflow">if</span> (! KeIA32UnscrambleLdtEntry(Regs-&gt;RiSegSs, &amp;Regs-&gt;RiSsDescriptor)) {
02014             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02015         }
02016 
02017         <span class="comment">//</span>
02018         <span class="comment">// Make sure the ss segment is not executable code but is read/write</span>
02019         <span class="comment">// (see Ki386GetSelectorParameters()...)</span>
02020         <span class="comment">//</span>
02021         <span class="keywordflow">if</span> ((Regs-&gt;RiSsDescriptor.Words.Bits.Type &amp; DESCRIPTOR_DATA_READWRITE) !=
02022             DESCRIPTOR_DATA_READWRITE ) {
02023             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02024         }
02025 
02026         <span class="comment">//</span>
02027         <span class="comment">// Now fill in the ss stuff...</span>
02028         <span class="comment">//</span>
02029         Regs-&gt;RiSsBase = (ULONG) (Regs-&gt;RiSsDescriptor.Words.Bits.Base);
02030         Regs-&gt;RiSsLimit = (ULONG) (Regs-&gt;RiSsDescriptor.Words.Bits.Limit);
02031 
02032         <span class="comment">//</span>
02033         <span class="comment">// Check for the big limits...</span>
02034         <span class="comment">//</span>
02035         <span class="keywordflow">if</span> (Regs-&gt;RiSsDescriptor.Words.Bits.Default_Big) {
02036                 Regs-&gt;RiSsLimit &lt;&lt;= 12;
02037                 Regs-&gt;RiSsLimit |= 0xfff;
02038         }
02039     }
02040 
02041     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02042 }
02043 
02044 
02045 BOOLEAN
02046 CheckEsp(
02047         IN PREGINFO Regs,
02048         IN ULONG StackNeeded
02049         )
02050 <span class="comment">/*++</span>
02051 <span class="comment"></span>
02052 <span class="comment">Routine Description:</span>
02053 <span class="comment"></span>
02054 <span class="comment">    This routine verifies the ESP is legal before putting it back into</span>
02055 <span class="comment">    a trap frame.</span>
02056 <span class="comment"></span>
02057 <span class="comment">Arguments:</span>
02058 <span class="comment"></span>
02059 <span class="comment">   Regs - Pointer to a REGINFO structure</span>
02060 <span class="comment">   StackNeeded - Need to be this far away from stack limit</span>
02061 <span class="comment"></span>
02062 <span class="comment">Returns:</span>
02063 <span class="comment"></span>
02064 <span class="comment">    True if the ESP is legal (and there is available space on the stack),</span>
02065 <span class="comment">    false otherwise</span>
02066 <span class="comment"></span>
02067 <span class="comment">Notes:</span>
02068 <span class="comment"></span>
02069 <span class="comment">--*/</span>
02070 {
02071     <span class="keywordflow">if</span> (Regs-&gt;RiEFlags &amp; EFLAGS_V86_MASK) {
02072         Regs-&gt;RiEsp &amp;= Regs-&gt;RiSsLimit;
02073     }
02074     <span class="keywordflow">else</span> {
02075         <span class="keywordflow">if</span> (! Regs-&gt;RiSsDescriptor.Words.Bits.Default_Big) {
02076             <span class="comment">//</span>
02077             <span class="comment">// If we are not "big" then the ESP should stay 16 bit</span>
02078             <span class="comment">//</span>
02079             Regs-&gt;RiEsp &amp;= 0xffff;
02080         }
02081 
02082         <span class="comment">//</span>
02083         <span class="comment">// If we are expand up or expand down, this is a problem...</span>
02084         <span class="comment">//</span>
02085         <span class="keywordflow">if</span> (StackNeeded &gt; Regs-&gt;RiEsp) {
02086             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02087         }
02088 
02089         <span class="keywordflow">if</span> ((Regs-&gt;RiSsDescriptor.Words.Bits.Type &amp; DESCRIPTOR_EXPAND_DOWN) ==
02090             DESCRIPTOR_EXPAND_DOWN ) {
02091             <span class="keywordflow">if</span> (Regs-&gt;RiEsp - StackNeeded - 1 &lt; Regs-&gt;RiSsLimit) {
02092                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02093             }
02094         }
02095         <span class="keywordflow">else</span> { 
02096             <span class="keywordflow">if</span> (Regs-&gt;RiEsp &gt;= Regs-&gt;RiSsLimit) {
02097                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02098             }
02099         }
02100     }
02101 
02102     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02103 }
02104 
02105 
02106 BOOLEAN
02107 KeIA32UnscrambleLdtEntry(
02108         IN ULONG Selector,
02109         OUT PKXDESCRIPTOR XDescriptor
02110         )
02111 <span class="comment">/*++</span>
02112 <span class="comment"></span>
02113 <span class="comment">Routine Description:</span>
02114 <span class="comment"></span>
02115 <span class="comment">    This routine gets the requested LDT entry and converts it into</span>
02116 <span class="comment">    the unscrambled format needed by the EM descriptor registers</span>
02117 <span class="comment"></span>
02118 <span class="comment">Arguments:</span>
02119 <span class="comment"></span>
02120 <span class="comment">   Selector - selector number to use</span>
02121 <span class="comment">   XDescriptor - unscrambled descriptor</span>
02122 <span class="comment"></span>
02123 <span class="comment">Returns:</span>
02124 <span class="comment"></span>
02125 <span class="comment">    True if the the selector was found, false otherwise</span>
02126 <span class="comment"></span>
02127 <span class="comment">Notes:</span>
02128 <span class="comment"></span>
02129 <span class="comment">--*/</span>
02130 {
02131     <a class="code" href="../../d5/d6/struct__ETHREAD.html">PETHREAD</a> Thread;
02132     DESCRIPTOR_TABLE_ENTRY DescriptorEntry;
02133     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
02134 
02135     <span class="comment">//</span>
02136     <span class="comment">// We only deal with LDT, so make sure that's what we got...</span>
02137     <span class="comment">//</span>
02138     <span class="keywordflow">if</span> ((Selector &amp; (SELECTOR_TABLE_INDEX | DPL_USER)) != (SELECTOR_TABLE_INDEX | DPL_USER)) {
02139     
02140         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02141     }
02142 
02143     Thread = <a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a3">KeGetCurrentThread</a>();
02144     DescriptorEntry.Selector = Selector;
02145 
02146     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d8/d1/psp_8h.html#a88">PspQueryDescriptorThread</a>(Thread, &amp;DescriptorEntry, <span class="keyword">sizeof</span>(DescriptorEntry), NULL);
02147     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(Status)) {
02148         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02149     }
02150 
02151     XDescriptor-&gt;Words.DescriptorWords = KeIA32Unscramble(&amp;DescriptorEntry.Descriptor);
02152 
02153     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02154 }
02155 
02156 
02157 ULONGLONG
02158 KeIA32Unscramble(
02159         IN PLDT_ENTRY Descriptor
02160         )
02161 <span class="comment">/*++</span>
02162 <span class="comment"></span>
02163 <span class="comment">Routine Description:</span>
02164 <span class="comment"></span>
02165 <span class="comment">    This routine converts from the scrambled format used by memory</span>
02166 <span class="comment">    into the unscrambled format used by the iVE. Assumes that the following</span>
02167 <span class="comment">    flags are a constant:</span>
02168 <span class="comment">         the DPL is always 3,</span>
02169 <span class="comment">         the accessed bit is always 1,</span>
02170 <span class="comment">         and the system bit is always 0</span>
02171 <span class="comment"></span>
02172 <span class="comment">Arguments:</span>
02173 <span class="comment"></span>
02174 <span class="comment">   Descriptor - scrambled descriptor</span>
02175 <span class="comment"></span>
02176 <span class="comment">Returns:</span>
02177 <span class="comment"></span>
02178 <span class="comment">    An unscrambled descriptor</span>
02179 <span class="comment"></span>
02180 <span class="comment">Notes:</span>
02181 <span class="comment"></span>
02182 <span class="comment">--*/</span>
02183 {
02184     KXDESCRIPTOR Result;
02185 
02186     <span class="comment">//</span>
02187     <span class="comment">// Fill in the base</span>
02188     <span class="comment">//</span>
02189     Result.Words.Bits.Base = Descriptor-&gt;BaseLow | (Descriptor-&gt;HighWord.Bytes.BaseMid &lt;&lt; 16) | (Descriptor-&gt;HighWord.Bytes.BaseHi &lt;&lt; 24);
02190 
02191     <span class="comment">//</span>
02192     <span class="comment">// Fill in the limit</span>
02193     <span class="comment">//</span>
02194     Result.Words.Bits.Limit = (Descriptor-&gt;LimitLow | (Descriptor-&gt;HighWord.Bits.LimitHi &lt;&lt; 16)) &lt;&lt; UNSCRAM_LIMIT_OFFSET;
02195 
02196     <span class="comment">//</span>
02197     <span class="comment">// Fill in the flags - since the DPL is always 3, the accessed bit</span>
02198     <span class="comment">// is always 1, and the system bit is always 0, use a constant for</span>
02199     <span class="comment">// those values (0x61)...</span>
02200     <span class="comment">//</span>
02201     Result.Words.Bits.Type = Descriptor-&gt;HighWord.Bits.Type;
02202     Result.Words.Bits.Dpl = Descriptor-&gt;HighWord.Bits.Dpl;
02203     Result.Words.Bits.Pres = Descriptor-&gt;HighWord.Bits.Pres;
02204     Result.Words.Bits.Sys = Descriptor-&gt;HighWord.Bits.Sys;
02205     Result.Words.Bits.Reserved_0 = Descriptor-&gt;HighWord.Bits.Reserved_0;
02206     Result.Words.Bits.Default_Big = Descriptor-&gt;HighWord.Bits.Default_Big;
02207     Result.Words.Bits.Granularity = Descriptor-&gt;HighWord.Bits.Granularity;
02208 
02209     <span class="keywordflow">return</span> Result.Words.DescriptorWords;
02210 }
02211 
02212 <span class="comment">//</span>
02213 <span class="comment">// These definitions are only used in the CheckVdmFlags()</span>
02214 <span class="comment">// routine below.</span>
02215 <span class="comment">//</span>
02216 <span class="preprocessor">#define _VDM_CHECK_OR_FUNC(x) ((x) |= EFLAGS_INTERRUPT_MASK)</span>
02217 <span class="preprocessor"></span><span class="preprocessor">#define _VDM_CHECK_AND_FUNC(x) ((x) &amp;= ~(EFLAGS_IOPL_MASK | EFLAGS_NT_MASK | EFLAGS_VIF | EFLAGS_VIP))</span>
02218 <span class="preprocessor"></span>
02219 
02220 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
02221 CheckVdmFlags(
02222     IN OUT PREGINFO Regs
02223     )
02224 
02225 <span class="comment">/*++</span>
02226 <span class="comment"></span>
02227 <span class="comment">Routine Description: </span>
02228 <span class="comment"></span>
02229 <span class="comment">    This routine checks the flags that are going to be used for the</span>
02230 <span class="comment">    dos or windows application</span>
02231 <span class="comment"></span>
02232 <span class="comment">Arguments:</span>
02233 <span class="comment"></span>
02234 <span class="comment">   Regs - Pointer to REGINFO structure...</span>
02235 <span class="comment"></span>
02236 <span class="comment">Returns:</span>
02237 <span class="comment"></span>
02238 <span class="comment">   Nothing. But modifies EFlags field in Regs to an acceptable value</span>
02239 <span class="comment"></span>
02240 <span class="comment">--*/</span>
02241 {
02242     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/emulx86_8c.html#a2">KeIA32VdmIoplAllowed</a>) {
02243         <span class="keywordflow">if</span> (! (Regs-&gt;RiEFlags &amp; EFLAGS_V86_MASK)) {
02244             _VDM_CHECK_OR_FUNC(Regs-&gt;RiEFlags);
02245         }
02246         _VDM_CHECK_AND_FUNC(Regs-&gt;RiEFlags);
02247         <span class="keywordflow">return</span>;
02248     }
02249 
02250     <span class="comment">//</span>
02251     <span class="comment">// There was a lot of code here to check for Virtual Extensions...</span>
02252     <span class="comment">// Depending on if they existed or not, a value in eax was changed</span>
02253     <span class="comment">// (in ../i386/instemul.asm - at label cvf50: ) but it is never used</span>
02254     <span class="comment">// (not even as a return value...)</span>
02255     <span class="comment">// So, rather than repeat all that silly code that doesn't do anything,</span>
02256     <span class="comment">// I only show the code that is actually executed...  Enjoy...</span>
02257     <span class="comment">//</span>
02258 
02259 <span class="preprocessor">#if 0</span>
02260 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/emulx86_8c.html#a3">KeIA32VirtualIntExtensions</a> &amp; (V86_VIRTUAL_INT_EXTENSIONS | PM_VIRTUAL_INT_EXTENSIONS)) {
02261         <span class="keywordflow">if</span> (Regs-&gt;RiEflags &amp; EFLAGS_V86_MASK) {
02262             <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/emulx86_8c.html#a3">KeIA32VirtualIntExtensions</a> &amp; V86_VIRTUAL_INT_EXTENSIONS) {
02263             }
02264             <span class="keywordflow">else</span> {
02265             }
02266         }
02267         <span class="keywordflow">else</span> {
02268             <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/emulx86_8c.html#a3">KeIA32VirtualIntExtensions</a> &amp; PM_VIRTUAL_INT_EXTENSIONS) {
02269             }
02270             <span class="keywordflow">else</span> {
02271             }
02272         }
02273     }
02274 <span class="preprocessor">#endif</span>
02275 <span class="preprocessor"></span>
02276     _VDM_CHECK_OR_FUNC(Regs-&gt;RiEFlags);
02277     _VDM_CHECK_AND_FUNC(Regs-&gt;RiEFlags);
02278 }
02279 
02280 
02281 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
02282 KeIA32AndOrVdmLock(
02283     IN ULONG AndMask,
02284     IN ULONG OrMask
02285     )
02286 
02287 <span class="comment">/*++</span>
02288 <span class="comment"></span>
02289 <span class="comment">Routine Description: </span>
02290 <span class="comment"></span>
02291 <span class="comment">    This routine modifies the VdmFixedStateLinear location in an MP</span>
02292 <span class="comment">    safe way. In the original IA code, they used the LOCK prefix.</span>
02293 <span class="comment"></span>
02294 <span class="comment">Arguments:</span>
02295 <span class="comment"></span>
02296 <span class="comment">   AndMask - The value to use as the AND mask</span>
02297 <span class="comment">   OrMask - The value to use as the OR mask</span>
02298 <span class="comment"></span>
02299 <span class="comment">Returns:</span>
02300 <span class="comment"></span>
02301 <span class="comment">  nothing</span>
02302 <span class="comment"></span>
02303 <span class="comment">--*/</span>
02304 {
02305 <span class="preprocessor">#ifdef NT_UP</span>
02306 <span class="preprocessor"></span>    *<a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a3">VdmFixedStateLinear</a> = (*<a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a3">VdmFixedStateLinear</a> &amp; AndMask) | OrMask;
02307 <span class="preprocessor">#else</span>
02308 <span class="preprocessor"></span>    VdmGenericAndOrLock(VdmFixedStateLinear, AndMask, OrMask);
02309 <span class="preprocessor">#endif</span>
02310 <span class="preprocessor"></span>}
02311 
02312 <span class="preprocessor">#else   // defined(WX86) &amp;&amp; defined(TRY_NTVDM)</span>
02313 <span class="preprocessor"></span>
02314 
02315 BOOLEAN
<a name="l02316"></a><a class="code" href="../../d0/d6/emulx86_8c.html#a4">02316</a> <a class="code" href="../../d0/d6/emulx86_8c.html#a4">KiIA32VdmReflectException</a>(
02317     IN OUT PKIA32_FRAME Frame,
02318     IN ULONG Code
02319     )
02320 <span class="comment">/*++</span>
02321 <span class="comment"></span>
02322 <span class="comment">Routine Description:</span>
02323 <span class="comment"></span>
02324 <span class="comment">    This routine reflects an exception to a VDM.  It uses the information</span>
02325 <span class="comment">    in the trap frame to determine what exception to reflect, and updates</span>
02326 <span class="comment">    the trap frame with the new CS, EIP, SS, and SP values</span>
02327 <span class="comment"></span>
02328 <span class="comment">Arguments:</span>
02329 <span class="comment"></span>
02330 <span class="comment">   Frame - Pointer to the IA32 trap frame</span>
02331 <span class="comment">   Code - The trap number that brought us here</span>
02332 <span class="comment"></span>
02333 <span class="comment">Returns</span>
02334 <span class="comment"></span>
02335 <span class="comment">    Nothing</span>
02336 <span class="comment"></span>
02337 <span class="comment">Notes:</span>
02338 <span class="comment">    Interrupts  are enable upon entry, Irql is at APC level</span>
02339 <span class="comment">    This routine may not preserve all of the non-volatile registers if</span>
02340 <span class="comment">    a fault occurs.</span>
02341 <span class="comment">--*/</span>
02342 {
02343     <span class="comment">//</span>
02344     <span class="comment">// Not yet implemented...</span>
02345     <span class="comment">//</span>
02346     <span class="keywordflow">return</span>(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
02347 }
02348 
02349 
02350 BOOLEAN
<a name="l02351"></a><a class="code" href="../../d0/d6/emulx86_8c.html#a5">02351</a> <a class="code" href="../../d0/d6/emulx86_8c.html#a5">KiIA32DispatchOpcode</a>(
02352     IN PKIA32_FRAME Frame
02353     )
02354 
02355 <span class="comment">/*++</span>
02356 <span class="comment"></span>
02357 <span class="comment">Routine Description:</span>
02358 <span class="comment"></span>
02359 <span class="comment">    This routine dispatches to the opcode of the specific emulation routine.</span>
02360 <span class="comment">    based on the first byte of the opcode. It is a combination of the</span>
02361 <span class="comment">    original x86 emulation routines written in assembly (i386/instemul.asm</span>
02362 <span class="comment">    and i386/emv86.asm).</span>
02363 <span class="comment"></span>
02364 <span class="comment">Arguments:</span>
02365 <span class="comment"></span>
02366 <span class="comment">    Frame - pointer to the ia32 trap frame.</span>
02367 <span class="comment"></span>
02368 <span class="comment">Return Value:</span>
02369 <span class="comment"></span>
02370 <span class="comment">    Returns true if the opcode was handled, otherwise false</span>
02371 <span class="comment"></span>
02372 <span class="comment">--*/</span>
02373 
02374 {
02375     <span class="comment">//</span>
02376     <span class="comment">// Not yet implemented</span>
02377     <span class="comment">//</span>
02378 
02379     <span class="keywordflow">return</span>(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
02380 }
02381 
02382 
02383 BOOLEAN
<a name="l02384"></a><a class="code" href="../../d0/d6/emulx86_8c.html#a6">02384</a> <a class="code" href="../../d0/d6/emulx86_8c.html#a6">KiIA32VdmSegmentNotPresent</a>(
02385     IN OUT PKIA32_FRAME Frame
02386     )
02387 <span class="comment">/*++</span>
02388 <span class="comment"></span>
02389 <span class="comment">Routine Description:</span>
02390 <span class="comment"></span>
02391 <span class="comment">    This routine reflects a TRAP 0x0B to a VDM. It uses information</span>
02392 <span class="comment">    in the trap frame to determine what exception to reflect</span>
02393 <span class="comment">    and updates the trap frame with the new CS, EIP, SS, and ESP values</span>
02394 <span class="comment"></span>
02395 <span class="comment">Arguments:</span>
02396 <span class="comment"></span>
02397 <span class="comment">    Frame - Pointer to the IA32 trap frame</span>
02398 <span class="comment"></span>
02399 <span class="comment">Returns</span>
02400 <span class="comment"></span>
02401 <span class="comment">    True if the reflection was successful, false otherwise</span>
02402 <span class="comment"></span>
02403 <span class="comment">Notes:</span>
02404 <span class="comment">    none</span>
02405 <span class="comment">--*/</span>
02406 {
02407     <span class="comment">//</span>
02408     <span class="comment">// Not yet implemented</span>
02409     <span class="comment">//</span>
02410 
02411     <span class="keywordflow">return</span>(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
02412 }
02413 
02414 <span class="preprocessor">#endif  // defined(WX86) &amp;&amp; defined(TRY_NTVDM)</span>
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:39:49 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
