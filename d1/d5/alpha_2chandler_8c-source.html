<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: chandler.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>chandler.c</h1><a href="../../d0/d6/alpha_2chandler_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1990  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    chandler.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module implements the C specific exception handler that provides</span>
00012 <span class="comment">    structured condition handling for the C language.</span>
00013 <span class="comment"></span>
00014 <span class="comment">Author:</span>
00015 <span class="comment"></span>
00016 <span class="comment">    David N. Cutler (davec) 11-Sep-1990</span>
00017 <span class="comment"></span>
00018 <span class="comment">Environment:</span>
00019 <span class="comment"></span>
00020 <span class="comment">    Any mode.</span>
00021 <span class="comment"></span>
00022 <span class="comment">Revision History:</span>
00023 <span class="comment"></span>
00024 <span class="comment">    Thomas Van Baak (tvb) 29-Apr-1992</span>
00025 <span class="comment"></span>
00026 <span class="comment">        Adapted for Alpha AXP.</span>
00027 <span class="comment"></span>
00028 <span class="comment">--*/</span>
00029 
00030 <span class="preprocessor">#include "nt.h"</span>
00031 
00032 <span class="comment">//</span>
00033 <span class="comment">// Define procedure prototypes for exception filter and termination handler</span>
00034 <span class="comment">// execution routines defined in jmpuwind.s.</span>
00035 <span class="comment">//</span>
00036 
00037 LONG
00038 <a class="code" href="../../d3/d6/ppc_2chandler_8c.html#a0">__C_ExecuteExceptionFilter</a> (
00039     PEXCEPTION_POINTERS ExceptionPointers,
00040     EXCEPTION_FILTER ExceptionFilter,
00041     ULONG_PTR EstablisherFrame
00042     );
00043 
00044 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00045 <a class="code" href="../../d3/d6/ppc_2chandler_8c.html#a1">__C_ExecuteTerminationHandler</a> (
00046     BOOLEAN AbnormalTermination,
00047     TERMINATION_HANDLER TerminationHandler,
00048     ULONG_PTR EstablisherFrame
00049     );
00050 
00051 EXCEPTION_DISPOSITION
<a name="l00052"></a><a class="code" href="../../d0/d6/alpha_2chandler_8c.html#a2">00052</a> <a class="code" href="../../d3/d6/ppc_2chandler_8c.html#a2">__C_specific_handler</a> (
00053     IN <span class="keyword">struct</span> _EXCEPTION_RECORD *ExceptionRecord,
00054     IN <span class="keywordtype">void</span> *EstablisherFrame,
00055     IN OUT <span class="keyword">struct</span> _CONTEXT *ContextRecord,
00056     IN OUT <span class="keyword">struct</span> <a class="code" href="../../d0/d6/struct__DISPATCHER__CONTEXT.html">_DISPATCHER_CONTEXT</a> *DispatcherContext
00057     )
00058 
00059 <span class="comment">/*++</span>
00060 <span class="comment"></span>
00061 <span class="comment">Routine Description:</span>
00062 <span class="comment"></span>
00063 <span class="comment">    This function scans the scope tables associated with the specified</span>
00064 <span class="comment">    procedure and calls exception and termination handlers as necessary.</span>
00065 <span class="comment"></span>
00066 <span class="comment">    This language specific exception handler function is called on a</span>
00067 <span class="comment">    per-frame basis and in two different cases:</span>
00068 <span class="comment"></span>
00069 <span class="comment">    First, the IS_DISPATCHING case, it is called by the exception</span>
00070 <span class="comment">    dispatcher, RtlDispatchException, via the short assembler routine,</span>
00071 <span class="comment">    __C_ExecuteHandlerForException, when trying to locate exception</span>
00072 <span class="comment">    filters within the given frame.</span>
00073 <span class="comment"></span>
00074 <span class="comment">    Second, the IS_UNWINDING case, it is called by the frame unwinder,</span>
00075 <span class="comment">    RtlUnwind, via the short assembler routine, __C_ExecuteHandlerForUnwind,</span>
00076 <span class="comment">    when unwinding the stack and trying to locate termination handlers</span>
00077 <span class="comment">    within the given frame.</span>
00078 <span class="comment"></span>
00079 <span class="comment">Arguments:</span>
00080 <span class="comment"></span>
00081 <span class="comment">    ExceptionRecord - Supplies a pointer to an exception record.</span>
00082 <span class="comment"></span>
00083 <span class="comment">    EstablisherFrame - Supplies a pointer to frame of the establisher function.</span>
00084 <span class="comment"></span>
00085 <span class="comment">    ContextRecord - Supplies a pointer to a context record.</span>
00086 <span class="comment"></span>
00087 <span class="comment">    DispatcherContext - Supplies a pointer to the exception dispatcher or</span>
00088 <span class="comment">        unwind dispatcher context.</span>
00089 <span class="comment"></span>
00090 <span class="comment">Return Value:</span>
00091 <span class="comment"></span>
00092 <span class="comment">    If the exception is handled by one of the exception filter routines, then</span>
00093 <span class="comment">    there is no return from this routine and RtlUnwind is called. Otherwise,</span>
00094 <span class="comment">    an exception disposition value of continue execution or continue search is</span>
00095 <span class="comment">    returned.</span>
00096 <span class="comment"></span>
00097 <span class="comment">--*/</span>
00098 
00099 {
00100 
00101     ULONG_PTR ControlPc;
00102     EXCEPTION_FILTER ExceptionFilter;
00103     EXCEPTION_POINTERS ExceptionPointers;
00104     PRUNTIME_FUNCTION FunctionEntry;
00105     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
00106     PSCOPE_TABLE ScopeTable;
00107     ULONG_PTR TargetPc;
00108     TERMINATION_HANDLER TerminationHandler;
00109     LONG Value;
00110 
00111     <span class="comment">//</span>
00112     <span class="comment">// Get the address of where control left the establisher, the address of</span>
00113     <span class="comment">// the function table entry that describes the function, and the address of</span>
00114     <span class="comment">// the scope table.</span>
00115     <span class="comment">//</span>
00116 
00117     ControlPc = DispatcherContext-&gt;ControlPc;
00118     FunctionEntry = DispatcherContext-&gt;FunctionEntry;
00119     ScopeTable = (PSCOPE_TABLE)(FunctionEntry-&gt;HandlerData);
00120 
00121     <span class="comment">//</span>
00122     <span class="comment">// The scope table HandlerAddress is either the address of an exception</span>
00123     <span class="comment">// filter or a termination handler. The C compiler wraps the code in the</span>
00124     <span class="comment">// exception filter expression or the termination handler clause within</span>
00125     <span class="comment">// an internal C function. The value of the scope table JumpTarget field</span>
00126     <span class="comment">// is used to distinguish an exception filter function (JumpTarget non zero)</span>
00127     <span class="comment">// from a termination handler function (JumpTarget is zero).</span>
00128     <span class="comment">//</span>
00129 
00130     <span class="comment">//</span>
00131     <span class="comment">// If an unwind is not in progress, then scan the scope table and call</span>
00132     <span class="comment">// the appropriate exception filter routines. Otherwise, scan the scope</span>
00133     <span class="comment">// table and call the appropriate termination handlers using the target</span>
00134     <span class="comment">// PC obtained from the context record.</span>
00135     <span class="comment">//</span>
00136 
00137     <span class="keywordflow">if</span> (IS_DISPATCHING(ExceptionRecord-&gt;ExceptionFlags)) {
00138 
00139         <span class="comment">//</span>
00140         <span class="comment">// Set up the ExceptionPointers structure that is passed as the argument</span>
00141         <span class="comment">// to the exception filter. It is used by the compiler to implement the</span>
00142         <span class="comment">// intrinsic functions exception_code() and exception_info().</span>
00143         <span class="comment">//</span>
00144 
00145         ExceptionPointers.ExceptionRecord = ExceptionRecord;
00146         ExceptionPointers.ContextRecord = ContextRecord;
00147 
00148         <span class="comment">//</span>
00149         <span class="comment">// Scan the scope table and call the appropriate exception filter</span>
00150         <span class="comment">// routines. The scope table entries are known to be sorted by</span>
00151         <span class="comment">// increasing EndAddress order. Thus a linear scan will naturally</span>
00152         <span class="comment">// hit inner scope exception clauses before outer scope clauses.</span>
00153         <span class="comment">//</span>
00154 
00155         <span class="keywordflow">for</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = 0; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &lt; ScopeTable-&gt;Count; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> += 1) {
00156             <span class="keywordflow">if</span> ((ControlPc &gt;= ScopeTable-&gt;ScopeRecord[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].BeginAddress) &amp;&amp;
00157                 (ControlPc &lt; ScopeTable-&gt;ScopeRecord[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].EndAddress) &amp;&amp;
00158                 (ScopeTable-&gt;ScopeRecord[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].JumpTarget != 0)) {
00159 
00160                 <span class="comment">//</span>
00161                 <span class="comment">// Call the exception filter routine.</span>
00162                 <span class="comment">//</span>
00163 
00164                 ExceptionFilter =
00165                     (EXCEPTION_FILTER)ScopeTable-&gt;ScopeRecord[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].HandlerAddress;
00166                 Value = <a class="code" href="../../d3/d6/ppc_2chandler_8c.html#a0">__C_ExecuteExceptionFilter</a>(&amp;ExceptionPointers,
00167                                                    ExceptionFilter,
00168                                                    (ULONG_PTR)EstablisherFrame);
00169 
00170                 <span class="comment">//</span>
00171                 <span class="comment">// If the return value is less than zero, then dismiss the</span>
00172                 <span class="comment">// exception. Otherwise, if the value is greater than zero,</span>
00173                 <span class="comment">// then unwind to the target exception handler corresponding</span>
00174                 <span class="comment">// to the exception filter. Otherwise, continue the search for</span>
00175                 <span class="comment">// an exception filter.</span>
00176                 <span class="comment">//</span>
00177 
00178                 <span class="comment">//</span>
00179                 <span class="comment">// Exception filters will usually return one of the following</span>
00180                 <span class="comment">// defines, although the decision below is made only by sign:</span>
00181                 <span class="comment">//</span>
00182                 <span class="comment">//  #define EXCEPTION_EXECUTE_HANDLER     1</span>
00183                 <span class="comment">//  #define EXCEPTION_CONTINUE_SEARCH     0</span>
00184                 <span class="comment">//  #define EXCEPTION_CONTINUE_EXECUTION -1</span>
00185                 <span class="comment">//</span>
00186 
00187                 <span class="keywordflow">if</span> (Value &lt; 0) {
00188                     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a36">ExceptionContinueExecution</a>;
00189 
00190                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Value &gt; 0) {
00191 
00192                     <span class="comment">//</span>
00193                     <span class="comment">// Set the return value for the unwind to the exception</span>
00194                     <span class="comment">// code so the exception handler clause can retrieve it</span>
00195                     <span class="comment">// from v0. This is how GetExceptionCode() is implemented</span>
00196                     <span class="comment">// in exception handler clauses.</span>
00197                     <span class="comment">//</span>
00198 
00199                     <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a12">RtlUnwind2</a>(EstablisherFrame,
00200                                (PVOID)ScopeTable-&gt;ScopeRecord[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].JumpTarget,
00201                                ExceptionRecord,
00202                                ULongToPtr( ExceptionRecord-&gt;ExceptionCode ),
00203                                ContextRecord);
00204                 }
00205             }
00206         }
00207 
00208     } <span class="keywordflow">else</span> {
00209 
00210         <span class="comment">//</span>
00211         <span class="comment">// Scan the scope table and call the appropriate termination handler</span>
00212         <span class="comment">// routines.</span>
00213         <span class="comment">//</span>
00214 
00215         TargetPc = (ULONG_PTR)ContextRecord-&gt;Fir;
00216         <span class="keywordflow">for</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = 0; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &lt; ScopeTable-&gt;Count; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> += 1) {
00217             <span class="keywordflow">if</span> ((ControlPc &gt;= ScopeTable-&gt;ScopeRecord[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].BeginAddress) &amp;&amp;
00218                 (ControlPc &lt; ScopeTable-&gt;ScopeRecord[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].EndAddress)) {
00219 
00220                 <span class="comment">//</span>
00221                 <span class="comment">// If the target PC is within the same scope the control PC</span>
00222                 <span class="comment">// is within, then this is an uplevel goto out of an inner try</span>
00223                 <span class="comment">// scope or a long jump back into a try scope. Terminate the</span>
00224                 <span class="comment">// scan for termination handlers - because any other handlers</span>
00225                 <span class="comment">// will be outside the scope of both the goto and its label.</span>
00226                 <span class="comment">//</span>
00227                 <span class="comment">// N.B. The target PC can be just beyond the end of the scope,</span>
00228                 <span class="comment">//      in which case it is a leave from the scope.</span>
00229                 <span class="comment">//</span>
00230 
00231                 <span class="keywordflow">if</span> ((TargetPc &gt;= ScopeTable-&gt;ScopeRecord[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].BeginAddress) &amp;&amp;
00232                     (TargetPc &lt;= ScopeTable-&gt;ScopeRecord[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].EndAddress)) {
00233                     <span class="keywordflow">break</span>;
00234 
00235                 } <span class="keywordflow">else</span> {
00236 
00237                     <span class="comment">//</span>
00238                     <span class="comment">// If the scope table entry describes an exception filter</span>
00239                     <span class="comment">// and the associated exception handler is the target of</span>
00240                     <span class="comment">// the unwind, then terminate the scan for termination</span>
00241                     <span class="comment">// handlers. Otherwise, if the scope table entry describes</span>
00242                     <span class="comment">// a termination handler, then record the address of the</span>
00243                     <span class="comment">// end of the scope as the new control PC address and call</span>
00244                     <span class="comment">// the termination handler.</span>
00245                     <span class="comment">//</span>
00246                     <span class="comment">// Recording a new control PC is necessary to ensure that</span>
00247                     <span class="comment">// termination handlers are called only once even when a</span>
00248                     <span class="comment">// collided unwind occurs.</span>
00249                     <span class="comment">//</span>
00250 
00251                     <span class="keywordflow">if</span> (ScopeTable-&gt;ScopeRecord[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].JumpTarget != 0) {
00252 
00253                         <span class="comment">//</span>
00254                         <span class="comment">// try/except - exception filter (JumpTarget != 0).</span>
00255                         <span class="comment">// After the exception filter is called, the exception</span>
00256                         <span class="comment">// handler clause is executed by the call to unwind</span>
00257                         <span class="comment">// above. Having reached this point in the scan of the</span>
00258                         <span class="comment">// scope tables, any other termination handlers will</span>
00259                         <span class="comment">// be outside the scope of the try/except.</span>
00260                         <span class="comment">//</span>
00261 
00262                         <span class="keywordflow">if</span> (TargetPc == ScopeTable-&gt;ScopeRecord[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].JumpTarget) {
00263                             <span class="keywordflow">break</span>;
00264                         }
00265 
00266                     } <span class="keywordflow">else</span> {
00267 
00268                         <span class="comment">//</span>
00269                         <span class="comment">// try/finally - termination handler (JumpTarget == 0).</span>
00270                         <span class="comment">//</span>
00271 
00272                         <span class="comment">//</span>
00273                         <span class="comment">// Unless the termination handler results in a long</span>
00274                         <span class="comment">// jump, execution will resume at the instruction after</span>
00275                         <span class="comment">// the exception handler clause.</span>
00276                         <span class="comment">//</span>
00277                         <span class="comment">// ## tvb - I'm still suspicious of the +4 below.</span>
00278 
00279                         DispatcherContext-&gt;ControlPc =
00280                                 ScopeTable-&gt;ScopeRecord[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].EndAddress + 4;
00281                         TerminationHandler =
00282                             (TERMINATION_HANDLER)ScopeTable-&gt;ScopeRecord[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].HandlerAddress;
00283                         <a class="code" href="../../d3/d6/ppc_2chandler_8c.html#a1">__C_ExecuteTerminationHandler</a>(<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
00284                                                       TerminationHandler,
00285                                                       (ULONG_PTR)EstablisherFrame);
00286                     }
00287                 }
00288             }
00289         }
00290     }
00291 
00292     <span class="comment">//</span>
00293     <span class="comment">// Continue search for exception filters or termination handlers.</span>
00294     <span class="comment">//</span>
00295 
00296     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a37">ExceptionContinueSearch</a>;
00297 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:39:23 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
