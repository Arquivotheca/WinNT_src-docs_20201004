<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: dir.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>dir.c</h1><a href="../../d0/d8/dir_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1989  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    dir.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module contains the code to implement the NtQueryDirectoryFile,</span>
00012 <span class="comment">    and the NtNotifyChangeDirectoryFile system services for the NT I/O system.</span>
00013 <span class="comment"></span>
00014 <span class="comment">Author:</span>
00015 <span class="comment"></span>
00016 <span class="comment">    Darryl E. Havens (darrylh) 21-Jun-1989</span>
00017 <span class="comment"></span>
00018 <span class="comment">Environment:</span>
00019 <span class="comment"></span>
00020 <span class="comment">    Kernel mode only</span>
00021 <span class="comment"></span>
00022 <span class="comment">Revision History:</span>
00023 <span class="comment"></span>
00024 <span class="comment"></span>
00025 <span class="comment">--*/</span>
00026 
00027 <span class="preprocessor">#include "<a class="code" href="../../d0/d6/iop_8h.html">iop.h</a>"</span>
00028 
00029 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00030 <a class="code" href="../../d0/d8/dir_8c.html#a0">BuildQueryDirectoryIrp</a>(
00031     IN HANDLE FileHandle,
00032     IN HANDLE Event OPTIONAL,
00033     IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
00034     IN PVOID ApcContext OPTIONAL,
00035     OUT PIO_STATUS_BLOCK IoStatusBlock,
00036     OUT PVOID FileInformation,
00037     IN ULONG Length,
00038     IN FILE_INFORMATION_CLASS FileInformationClass,
00039     IN BOOLEAN ReturnSingleEntry,
00040     IN PUNICODE_STRING FileName OPTIONAL,
00041     IN BOOLEAN RestartScan,
00042     IN UCHAR MinorFunction,
00043     OUT BOOLEAN *SynchronousIo,
00044     OUT <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> *DeviceObject,
00045     OUT <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> *Irp,
00046     OUT <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> *FileObject,
00047     OUT KPROCESSOR_MODE *RequestorMode
00048     );
00049 
00050 <span class="preprocessor">#ifdef ALLOC_PRAGMA</span>
00051 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, BuildQueryDirectoryIrp)</span>
00052 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, NtQueryDirectoryFile)</span>
00053 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, NtNotifyChangeDirectoryFile)</span>
00054 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00055 <span class="preprocessor"></span>
00056 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00057"></a><a class="code" href="../../d0/d8/dir_8c.html#a0">00057</a> <a class="code" href="../../d0/d8/dir_8c.html#a0">BuildQueryDirectoryIrp</a>(
00058     IN HANDLE FileHandle,
00059     IN HANDLE Event OPTIONAL,
00060     IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
00061     IN PVOID ApcContext OPTIONAL,
00062     OUT PIO_STATUS_BLOCK IoStatusBlock,
00063     OUT PVOID FileInformation,
00064     IN ULONG Length,
00065     IN FILE_INFORMATION_CLASS FileInformationClass,
00066     IN BOOLEAN ReturnSingleEntry,
00067     IN PUNICODE_STRING FileName OPTIONAL,
00068     IN BOOLEAN RestartScan,
00069     IN UCHAR MinorFunction,
00070     OUT BOOLEAN *SynchronousIo,
00071     OUT <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> *DeviceObject,
00072     OUT <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> *Irp,
00073     OUT <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> *FileObject,
00074     OUT KPROCESSOR_MODE *RequestorMode
00075     )
00076 
00077 <span class="comment">/*++</span>
00078 <span class="comment"></span>
00079 <span class="comment">Routine Description:</span>
00080 <span class="comment"></span>
00081 <span class="comment">    This service operates on a directory file or OLE container specified by the</span>
00082 <span class="comment">    FileHandle parameter.  The service returns information about files in the</span>
00083 <span class="comment">    directory or embeddings and streams in the container specified by the file</span>
00084 <span class="comment">    handle.  The ReturnSingleEntry parameter specifies that only a single entry</span>
00085 <span class="comment">    should be returned rather than filling the buffer.  The actual number of</span>
00086 <span class="comment">    files whose information is returned, is the smallest of the following:</span>
00087 <span class="comment"></span>
00088 <span class="comment">        o  One entry, if the ReturnSingleEntry parameter is TRUE.</span>
00089 <span class="comment"></span>
00090 <span class="comment">        o  The number of entries whose information fits into the specified</span>
00091 <span class="comment">           buffer.</span>
00092 <span class="comment"></span>
00093 <span class="comment">        o  The number of entries that exist.</span>
00094 <span class="comment"></span>
00095 <span class="comment">        o  One entry if the optional FileName parameter is specified.</span>
00096 <span class="comment"></span>
00097 <span class="comment">    If the optional FileName parameter is specified, then the only information</span>
00098 <span class="comment">    that is returned is for that single entries, if it exists.  Note that the</span>
00099 <span class="comment">    file name may not specify any wildcard characters according to the naming</span>
00100 <span class="comment">    conventions of the target file system.  The ReturnSingleEntry parameter is</span>
00101 <span class="comment">    simply ignored.</span>
00102 <span class="comment"></span>
00103 <span class="comment">    The information that is obtained about the entries in the directory or OLE</span>
00104 <span class="comment">    container is based on the FileInformationClass parameter.  Legal values are</span>
00105 <span class="comment">    hard coded based on the MinorFunction.</span>
00106 <span class="comment"></span>
00107 <span class="comment">Arguments:</span>
00108 <span class="comment"></span>
00109 <span class="comment">    FileHandle - Supplies a handle to the directory file or OLE container for</span>
00110 <span class="comment">        which information should be returned.</span>
00111 <span class="comment"></span>
00112 <span class="comment">    Event - Supplies an optional event to be set to the Signaled state when</span>
00113 <span class="comment">        the query is complete.</span>
00114 <span class="comment"></span>
00115 <span class="comment">    ApcRoutine - Supplies an optional APC routine to be executed when the</span>
00116 <span class="comment">        query is complete.</span>
00117 <span class="comment"></span>
00118 <span class="comment">    ApcContext - Supplies a context parameter to be passed to the ApcRoutine,</span>
00119 <span class="comment">        if an ApcRoutine was specified.</span>
00120 <span class="comment"></span>
00121 <span class="comment">    IoStatusBlock - Address of the caller's I/O status block.</span>
00122 <span class="comment"></span>
00123 <span class="comment">    FileInformation - Supplies a buffer to receive the requested information</span>
00124 <span class="comment">        returned about the contents of the directory.</span>
00125 <span class="comment"></span>
00126 <span class="comment">    Length - Supplies the length, in bytes, of the FileInformation buffer.</span>
00127 <span class="comment"></span>
00128 <span class="comment">    FileInformationClass - Specfies the type of information that is to be</span>
00129 <span class="comment">        returned about the files in the specified directory or OLE container.</span>
00130 <span class="comment"></span>
00131 <span class="comment">    ReturnSingleEntry - Supplies a BOOLEAN value that, if TRUE, indicates that</span>
00132 <span class="comment">        only a single entry should be returned.</span>
00133 <span class="comment"></span>
00134 <span class="comment">    FileName - Optionally supplies a file name within the specified directory</span>
00135 <span class="comment">        or OLE container.</span>
00136 <span class="comment"></span>
00137 <span class="comment">    RestartScan - Supplies a BOOLEAN value that, if TRUE, indicates that the</span>
00138 <span class="comment">        scan should be restarted from the beginning.  This parameter must be</span>
00139 <span class="comment">        set to TRUE by the caller the first time the service is invoked.</span>
00140 <span class="comment"></span>
00141 <span class="comment">    MinorFunction - IRP_MN_QUERY_DIRECTORY or IRP_MN_QUERY_OLE_DIRECTORY</span>
00142 <span class="comment"></span>
00143 <span class="comment">    SynchronousIo - pointer to returned BOOLEAN; TRUE if synchronous I/O</span>
00144 <span class="comment"></span>
00145 <span class="comment">    DeviceObject - pointer to returned pointer to device object</span>
00146 <span class="comment"></span>
00147 <span class="comment">    Irp - pointer to returned pointer to device object</span>
00148 <span class="comment"></span>
00149 <span class="comment">    FileObject - pointer to returned pointer to file object</span>
00150 <span class="comment"></span>
00151 <span class="comment">    RequestorMode - pointer to returned requestor mode</span>
00152 <span class="comment"></span>
00153 <span class="comment">Return Value:</span>
00154 <span class="comment"></span>
00155 <span class="comment">    The status returned is STATUS_SUCCESS if a valid irp was created for the</span>
00156 <span class="comment">    query operation.</span>
00157 <span class="comment"></span>
00158 <span class="comment">--*/</span>
00159 
00160 {
00161     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
00162     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
00163     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> fileObject;
00164     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> deviceObject;
00165     <a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a> eventObject = (<a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00166     <a class="code" href="../../d0/d9/ntosdef_8h.html#a39">KPROCESSOR_MODE</a> requestorMode;
00167     PCHAR auxiliaryBuffer = (PCHAR) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00168     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpSp;
00169     <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> mdl;
00170 
00171     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00172 
00173     <span class="comment">//</span>
00174     <span class="comment">// Get the previous mode;  i.e., the mode of the caller.</span>
00175     <span class="comment">//</span>
00176 
00177     requestorMode = KeGetPreviousMode();
00178     *RequestorMode = requestorMode;
00179 
00180     <span class="keywordflow">try</span> {
00181 
00182         <span class="keywordflow">if</span> (requestorMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
00183 
00184             ULONG operationlength = 0;  <span class="comment">// assume invalid</span>
00185 
00186             <span class="comment">//</span>
00187             <span class="comment">// The caller's access mode is not kernel so probe and validate</span>
00188             <span class="comment">// each of the arguments as necessary.  If any failures occur,</span>
00189             <span class="comment">// the condition handler will be invoked to handle them.  It</span>
00190             <span class="comment">// will simply cleanup and return an access violation status</span>
00191             <span class="comment">// code back to the system service dispatcher.</span>
00192             <span class="comment">//</span>
00193 
00194             <span class="comment">//</span>
00195             <span class="comment">// The IoStatusBlock parameter must be writeable by the caller.</span>
00196             <span class="comment">//</span>
00197 
00198             <a class="code" href="../../d5/d8/ex_8h.html#a32">ProbeForWriteIoStatusEx</a>( IoStatusBlock, ApcRoutine);
00199 
00200             <span class="comment">//</span>
00201             <span class="comment">// Ensure that the FileInformationClass parameter is legal for</span>
00202             <span class="comment">// querying information about files in the directory or object.</span>
00203             <span class="comment">//</span>
00204 
00205             <span class="keywordflow">if</span> (FileInformationClass == FileDirectoryInformation) {
00206                 operationlength = <span class="keyword">sizeof</span>(FILE_DIRECTORY_INFORMATION);
00207             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (MinorFunction == <a class="code" href="../../d0/d5/io_8h.html#a44">IRP_MN_QUERY_DIRECTORY</a>) {
00208                 <span class="keywordflow">switch</span> (FileInformationClass)
00209                 {
00210                 <span class="keywordflow">case</span> FileFullDirectoryInformation:
00211                     operationlength = <span class="keyword">sizeof</span>(FILE_FULL_DIR_INFORMATION);
00212                     <span class="keywordflow">break</span>;
00213 
00214                 <span class="keywordflow">case</span> FileBothDirectoryInformation:
00215                     operationlength = <span class="keyword">sizeof</span>(FILE_BOTH_DIR_INFORMATION);
00216                     <span class="keywordflow">break</span>;
00217 
00218                 <span class="keywordflow">case</span> FileNamesInformation:
00219                     operationlength = <span class="keyword">sizeof</span>(FILE_NAMES_INFORMATION);
00220                     <span class="keywordflow">break</span>;
00221 
00222                 <span class="keywordflow">case</span> FileObjectIdInformation:
00223                     operationlength = <span class="keyword">sizeof</span>(FILE_OBJECTID_INFORMATION);
00224                     <span class="keywordflow">break</span>;
00225 
00226                 <span class="keywordflow">case</span> FileQuotaInformation:
00227                     operationlength = <span class="keyword">sizeof</span>(FILE_QUOTA_INFORMATION);
00228                     <span class="keywordflow">break</span>;
00229 
00230                 <span class="keywordflow">case</span> FileReparsePointInformation:
00231                     operationlength = <span class="keyword">sizeof</span>(FILE_REPARSE_POINT_INFORMATION);
00232                     <span class="keywordflow">break</span>;                    
00233                 }
00234             }
00235 
00236             <span class="comment">//</span>
00237             <span class="comment">// If the FileInformationClass parameter is illegal, fail now.</span>
00238             <span class="comment">//</span>
00239 
00240             <span class="keywordflow">if</span> (operationlength == 0) {
00241                 <span class="keywordflow">return</span> STATUS_INVALID_INFO_CLASS;
00242             }
00243 
00244             <span class="comment">//</span>
00245             <span class="comment">// Ensure that the caller's supplied buffer is at least large enough</span>
00246             <span class="comment">// to contain the fixed part of the structure required for this</span>
00247             <span class="comment">// query.</span>
00248             <span class="comment">//</span>
00249 
00250             <span class="keywordflow">if</span> (Length &lt; operationlength) {
00251                 <span class="keywordflow">return</span> STATUS_INFO_LENGTH_MISMATCH;
00252             }
00253 
00254 
00255             <span class="comment">//</span>
00256             <span class="comment">// The FileInformation buffer must be writeable by the caller.</span>
00257             <span class="comment">//</span>
00258 
00259 <span class="preprocessor">#if defined(_X86_)</span>
00260 <span class="preprocessor"></span>            <a class="code" href="../../d5/d8/ex_8h.html#a259">ProbeForWrite</a>( FileInformation, Length, <span class="keyword">sizeof</span>( ULONG ) );
00261 <span class="preprocessor">#elif defined(_WIN64)</span>
00262 <span class="preprocessor"></span>
00263             <span class="comment">//</span>
00264             <span class="comment">// If we are a wow64 process, follow the X86 rules</span>
00265             <span class="comment">//</span>
00266 
00267             <span class="keywordflow">if</span> (<a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a>()-&gt;Wow64Process) {
00268                 <a class="code" href="../../d5/d8/ex_8h.html#a259">ProbeForWrite</a>( FileInformation, Length, <span class="keyword">sizeof</span>( ULONG ) );
00269             } <span class="keywordflow">else</span> {
00270                 <a class="code" href="../../d5/d8/ex_8h.html#a259">ProbeForWrite</a>( FileInformation,
00271                                Length,
00272                                <a class="code" href="../../d3/d5/iodata_8c.html#a65">IopQuerySetAlignmentRequirement</a>[FileInformationClass] );
00273             }
00274             
00275 <span class="preprocessor">#else</span>
00276 <span class="preprocessor"></span>            <a class="code" href="../../d5/d8/ex_8h.html#a259">ProbeForWrite</a>( FileInformation,
00277                            Length,
00278                            <a class="code" href="../../d3/d5/iodata_8c.html#a65">IopQuerySetAlignmentRequirement</a>[FileInformationClass] );
00279 <span class="preprocessor">#endif</span>
00280 <span class="preprocessor"></span>        }
00281 
00282         <span class="comment">//</span>
00283         <span class="comment">// If the optional FileName parameter was specified, then it must be</span>
00284         <span class="comment">// readable by the caller.  Capture the file name string in a pool</span>
00285         <span class="comment">// block.  Note that if an error occurs during the copy, the cleanup</span>
00286         <span class="comment">// code in the exception handler will deallocate the pool before</span>
00287         <span class="comment">// returning an access violation status.</span>
00288         <span class="comment">//</span>
00289 
00290         <span class="keywordflow">if</span> (ARGUMENT_PRESENT( <a class="code" href="../../d2/d2/rtload_8c.html#a3">FileName</a> )) {
00291 
00292             UNICODE_STRING fileName;
00293             PUNICODE_STRING nameBuffer;
00294 
00295             <span class="comment">//</span>
00296             <span class="comment">// Capture the string descriptor itself to ensure that the</span>
00297             <span class="comment">// string is readable by the caller without the caller being</span>
00298             <span class="comment">// able to change the memory while its being checked.</span>
00299             <span class="comment">//</span>
00300 
00301             <span class="keywordflow">if</span> (requestorMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
00302                 fileName = <a class="code" href="../../d5/d8/ex_8h.html#a26">ProbeAndReadUnicodeString</a>( <a class="code" href="../../d2/d2/rtload_8c.html#a3">FileName</a> );
00303             } <span class="keywordflow">else</span> {
00304                 fileName = *<a class="code" href="../../d2/d2/rtload_8c.html#a3">FileName</a>;
00305             }
00306 
00307             <span class="keywordflow">if</span> (fileName.Length) {
00308 
00309                 <span class="comment">//</span>
00310                 <span class="comment">// The length of the string is non-zero, so probe the</span>
00311                 <span class="comment">// buffer described by the descriptor if the caller was</span>
00312                 <span class="comment">// not kernel mode.  Likewise, if the caller's mode was</span>
00313                 <span class="comment">// not kernel, then check the length of the name string</span>
00314                 <span class="comment">// to ensure that it is not too long.</span>
00315                 <span class="comment">//</span>
00316 
00317                 <span class="keywordflow">if</span> (requestorMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
00318                     <a class="code" href="../../d5/d8/ex_8h.html#a11">ProbeForRead</a>( fileName.Buffer,
00319                                   fileName.Length,
00320                                   <span class="keyword">sizeof</span>( UCHAR ) );
00321                     <span class="comment">//</span>
00322                     <span class="comment">// account for unicode</span>
00323                     <span class="comment">//</span>
00324 
00325                     <span class="keywordflow">if</span> (fileName.Length &gt; MAXIMUM_FILENAME_LENGTH&lt;&lt;1) {
00326                         <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INVALID_PARAMETER );
00327                     }
00328                 }
00329 
00330                 <span class="comment">//</span>
00331                 <span class="comment">// Allocate an auxiliary buffer large enough to contain</span>
00332                 <span class="comment">// a file name descriptor and to hold the entire file</span>
00333                 <span class="comment">// name itself.  Copy the body of the string into the</span>
00334                 <span class="comment">// buffer.</span>
00335                 <span class="comment">//</span>
00336 
00337                 auxiliaryBuffer = <a class="code" href="../../d5/d5/cc_8h.html#a11">ExAllocatePoolWithQuota</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>,
00338                                                            fileName.Length + <span class="keyword">sizeof</span>( UNICODE_STRING ) );
00339                 RtlCopyMemory( auxiliaryBuffer + <span class="keyword">sizeof</span>( UNICODE_STRING ),
00340                                fileName.Buffer,
00341                                fileName.Length );
00342 
00343                 <span class="comment">//</span>
00344                 <span class="comment">// Finally, build the Unicode string descriptor in the</span>
00345                 <span class="comment">// auxiliary buffer.</span>
00346                 <span class="comment">//</span>
00347 
00348                 nameBuffer = (PUNICODE_STRING) auxiliaryBuffer;
00349                 nameBuffer-&gt;Length = fileName.Length;
00350                 nameBuffer-&gt;MaximumLength = fileName.Length;
00351                 nameBuffer-&gt;Buffer = (PWSTR) (auxiliaryBuffer + <span class="keyword">sizeof</span>( UNICODE_STRING ) );
00352             }
00353         }
00354 
00355     } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
00356 
00357         <span class="comment">//</span>
00358         <span class="comment">// An exception was incurred while probing the caller's buffers,</span>
00359         <span class="comment">// attempting to allocate a pool buffer, or while trying to copy</span>
00360         <span class="comment">// the caller's data.  Determine what happened, clean everything</span>
00361         <span class="comment">// up, and return an appropriate error status code.</span>
00362         <span class="comment">//</span>
00363 
00364         <span class="keywordflow">if</span> (auxiliaryBuffer) {
00365             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( auxiliaryBuffer );
00366         }
00367 
00368 <span class="preprocessor">#if DBG</span>
00369 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (GetExceptionCode() == STATUS_DATATYPE_MISALIGNMENT) {
00370             DbgBreakPoint();
00371         }
00372 <span class="preprocessor">#endif // DBG</span>
00373 <span class="preprocessor"></span>
00374         <span class="keywordflow">return</span> GetExceptionCode();
00375     }
00376 
00377     <span class="comment">//</span>
00378     <span class="comment">// There were no blatant errors so far, so reference the file object so</span>
00379     <span class="comment">// the target device object can be found.  Note that if the handle does</span>
00380     <span class="comment">// not refer to a file object, or if the caller does not have the required</span>
00381     <span class="comment">// access to the file, then it will fail.</span>
00382     <span class="comment">//</span>
00383 
00384     status = <a class="code" href="../../d7/d1/obref_8c.html#a4">ObReferenceObjectByHandle</a>( FileHandle,
00385                                         FILE_LIST_DIRECTORY,
00386                                         <a class="code" href="../../d5/d8/fssup_8c.html#a3">IoFileObjectType</a>,
00387                                         requestorMode,
00388                                         (PVOID *) &amp;fileObject,
00389                                         (<a class="code" href="../../d3/d5/struct__OBJECT__HANDLE__INFORMATION.html">POBJECT_HANDLE_INFORMATION</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00390     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
00391         <span class="keywordflow">if</span> (auxiliaryBuffer) {
00392             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( auxiliaryBuffer );
00393         }
00394         <span class="keywordflow">return</span> status;
00395     }
00396     *FileObject = fileObject;
00397 
00398     <span class="comment">//</span>
00399     <span class="comment">// If this file has an I/O completion port associated w/it, then ensure</span>
00400     <span class="comment">// that the caller did not supply an APC routine, as the two are mutually</span>
00401     <span class="comment">// exclusive methods for I/O completion notification.</span>
00402     <span class="comment">//</span>
00403 
00404     <span class="keywordflow">if</span> (fileObject-&gt;CompletionContext &amp;&amp; <a class="code" href="../../d0/d6/iop_8h.html#a19">IopApcRoutinePresent</a>( ApcRoutine )) {
00405         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
00406         <span class="keywordflow">if</span> (auxiliaryBuffer) {
00407             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( auxiliaryBuffer );
00408         }
00409         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
00410 
00411     }
00412 
00413     <span class="comment">//</span>
00414     <span class="comment">// Get the address of the event object and set the event to the Not-</span>
00415     <span class="comment">// Signaled state, if an event was specified.  Note here, too, that if</span>
00416     <span class="comment">// the handle does not refer to an event, or if the event cannot be</span>
00417     <span class="comment">// written, then the reference will fail.</span>
00418     <span class="comment">//</span>
00419 
00420     <span class="keywordflow">if</span> (ARGUMENT_PRESENT( <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a> )) {
00421         status = <a class="code" href="../../d7/d1/obref_8c.html#a4">ObReferenceObjectByHandle</a>( <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>,
00422                                             EVENT_MODIFY_STATE,
00423                                             <a class="code" href="../../d7/d7/ntapi_8c.html#a3">ExEventObjectType</a>,
00424                                             requestorMode,
00425                                             (PVOID *) &amp;eventObject,
00426                                             (<a class="code" href="../../d3/d5/struct__OBJECT__HANDLE__INFORMATION.html">POBJECT_HANDLE_INFORMATION</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00427         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
00428             <span class="keywordflow">if</span> (auxiliaryBuffer) {
00429                 <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( auxiliaryBuffer );
00430             }
00431             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
00432             <span class="keywordflow">return</span> status;
00433         } <span class="keywordflow">else</span> {
00434             <a class="code" href="../../d4/d9/ke_8h.html#a21">KeClearEvent</a>( eventObject );
00435         }
00436     }
00437 
00438     <span class="comment">//</span>
00439     <span class="comment">// Make a special check here to determine whether this is a synchronous</span>
00440     <span class="comment">// I/O operation.  If it is, then wait here until the file is owned by</span>
00441     <span class="comment">// the current thread.</span>
00442     <span class="comment">//</span>
00443 
00444     <span class="keywordflow">if</span> (fileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a151">FO_SYNCHRONOUS_IO</a>) {
00445 
00446         BOOLEAN interrupted;
00447 
00448         <span class="keywordflow">if</span> (!<a class="code" href="../../d0/d6/iop_8h.html#a13">IopAcquireFastLock</a>( fileObject )) {
00449             status = <a class="code" href="../../d0/d6/iop_8h.html#a147">IopAcquireFileObjectLock</a>( fileObject,
00450                                                requestorMode,
00451                                                (BOOLEAN) ((fileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a152">FO_ALERTABLE_IO</a>) != 0),
00452                                                &amp;interrupted );
00453             <span class="keywordflow">if</span> (interrupted) {
00454                 <span class="keywordflow">if</span> (auxiliaryBuffer != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00455                     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( auxiliaryBuffer );
00456                 }
00457                 <span class="keywordflow">if</span> (eventObject != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00458                     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( eventObject );
00459                 }
00460                 <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
00461                 <span class="keywordflow">return</span> status;
00462             }
00463         }
00464         *<a class="code" href="../../d2/d4/internal_8c.html#a2">SynchronousIo</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00465     } <span class="keywordflow">else</span> {
00466         *<a class="code" href="../../d2/d4/internal_8c.html#a2">SynchronousIo</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00467     }
00468 
00469     <span class="comment">//</span>
00470     <span class="comment">// Set the file object to the Not-Signaled state.</span>
00471     <span class="comment">//</span>
00472 
00473     <a class="code" href="../../d4/d9/ke_8h.html#a21">KeClearEvent</a>( &amp;fileObject-&gt;Event );
00474 
00475     <span class="comment">//</span>
00476     <span class="comment">// Get the address of the target device object.</span>
00477     <span class="comment">//</span>
00478 
00479     deviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a76">IoGetRelatedDeviceObject</a>( fileObject );
00480     *DeviceObject = deviceObject;
00481 
00482     <span class="comment">//</span>
00483     <span class="comment">// Allocate and initialize the I/O Request Packet (IRP) for this operation.</span>
00484     <span class="comment">// The allocation is performed with an exception handler in case the</span>
00485     <span class="comment">// caller does not have enough quota to allocate the packet.</span>
00486 
00487     irp = <a class="code" href="../../d4/d6/iosubs_8c.html#a17">IoAllocateIrp</a>( deviceObject-&gt;StackSize, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
00488     <span class="keywordflow">if</span> (!irp) {
00489 
00490         <span class="comment">//</span>
00491         <span class="comment">// An IRP could not be allocated.  Cleanup and return an appropriate</span>
00492         <span class="comment">// error status code.</span>
00493         <span class="comment">//</span>
00494 
00495         <a class="code" href="../../d0/d6/iop_8h.html#a148">IopAllocateIrpCleanup</a>( fileObject, eventObject );
00496         <span class="keywordflow">if</span> (auxiliaryBuffer) {
00497             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( auxiliaryBuffer );
00498         }
00499 
00500         <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
00501     }
00502     *<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> = irp;
00503 
00504     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.OriginalFileObject = fileObject;
00505     irp-&gt;Tail.Overlay.Thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
00506     irp-&gt;RequestorMode = requestorMode;
00507 
00508     <span class="comment">//</span>
00509     <span class="comment">// Fill in the service independent parameters in the IRP.</span>
00510     <span class="comment">//</span>
00511 
00512     irp-&gt;UserEvent = eventObject;
00513     irp-&gt;UserIosb = IoStatusBlock;
00514     irp-&gt;Overlay.AsynchronousParameters.UserApcRoutine = ApcRoutine;
00515     irp-&gt;Overlay.AsynchronousParameters.UserApcContext = ApcContext;
00516 
00517     <span class="comment">//</span>
00518     <span class="comment">// Get a pointer to the stack location for the first driver.  This will be</span>
00519     <span class="comment">// used to pass the original function codes and parameters.</span>
00520     <span class="comment">//</span>
00521 
00522     irpSp = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>( irp );
00523     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a> = <a class="code" href="../../d0/d5/io_8h.html#a25">IRP_MJ_DIRECTORY_CONTROL</a>;
00524     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o1">MinorFunction</a> = MinorFunction;
00525     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a> = fileObject;
00526 
00527     <span class="comment">// Also, copy the caller's parameters to the service-specific portion of</span>
00528     <span class="comment">// the IRP.</span>
00529     <span class="comment">//</span>
00530 
00531     irp-&gt;Tail.Overlay.AuxiliaryBuffer = auxiliaryBuffer;
00532     irp-&gt;AssociatedIrp.SystemBuffer = (PVOID) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00533     irp-&gt;MdlAddress = (<a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00534 
00535     <span class="comment">//</span>
00536     <span class="comment">// Now determine whether this driver expects to have data buffered to it</span>
00537     <span class="comment">// or whether it performs direct I/O.  This is based on the DO_BUFFERED_IO</span>
00538     <span class="comment">// flag in the device object.  If the flag is set, then a system buffer is</span>
00539     <span class="comment">// allocated and the driver's data will be copied into it.  Otherwise, a</span>
00540     <span class="comment">// Memory Descriptor List (MDL) is allocated and the caller's buffer is</span>
00541     <span class="comment">// locked down using it.</span>
00542     <span class="comment">//</span>
00543 
00544     <span class="keywordflow">if</span> (deviceObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a123">DO_BUFFERED_IO</a>) {
00545 
00546         <span class="comment">//</span>
00547         <span class="comment">// The device does not support direct I/O.  Allocate a system buffer</span>
00548         <span class="comment">// and specify that it should be deallocated on completion.  Also</span>
00549         <span class="comment">// indicate that this is an input operation so the data will be copied</span>
00550         <span class="comment">// into the caller's buffer.  This is done using an exception handler</span>
00551         <span class="comment">// that will perform cleanup if the operation fails.</span>
00552         <span class="comment">//</span>
00553 
00554         <span class="keywordflow">try</span> {
00555 
00556             <span class="comment">//</span>
00557             <span class="comment">// Allocate the intermediary system buffer from nonpaged pool and</span>
00558             <span class="comment">// charge quota for it.</span>
00559             <span class="comment">//</span>
00560 
00561             irp-&gt;AssociatedIrp.SystemBuffer =
00562                 <a class="code" href="../../d5/d5/cc_8h.html#a11">ExAllocatePoolWithQuota</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, Length );
00563 
00564         } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
00565 
00566             <span class="comment">//</span>
00567             <span class="comment">// An exception was incurred while either probing the caller's</span>
00568             <span class="comment">// buffer or allocate the system buffer.  Determine what actually</span>
00569             <span class="comment">// happened, clean everything up, and return an appropriate error</span>
00570             <span class="comment">// status code.</span>
00571             <span class="comment">//</span>
00572 
00573             <a class="code" href="../../d0/d6/iop_8h.html#a170">IopExceptionCleanup</a>( fileObject,
00574                                  irp,
00575                                  eventObject,
00576                                  (<a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00577 
00578             <span class="keywordflow">if</span> (auxiliaryBuffer != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00579                 <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( auxiliaryBuffer );
00580             }
00581 
00582             <span class="keywordflow">return</span> GetExceptionCode();
00583 
00584         }
00585 
00586         <span class="comment">//</span>
00587         <span class="comment">// Remember the address of the caller's buffer so the copy can take</span>
00588         <span class="comment">// place during I/O completion.  Also, set the flags so that the</span>
00589         <span class="comment">// completion code knows to do the copy and to deallocate the buffer.</span>
00590         <span class="comment">//</span>
00591 
00592         irp-&gt;UserBuffer = FileInformation;
00593         irp-&gt;Flags = (ULONG) (<a class="code" href="../../d0/d5/io_8h.html#a178">IRP_BUFFERED_IO</a> |
00594                               <a class="code" href="../../d0/d5/io_8h.html#a179">IRP_DEALLOCATE_BUFFER</a> |
00595                               <a class="code" href="../../d0/d5/io_8h.html#a180">IRP_INPUT_OPERATION</a>);
00596 
00597     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (deviceObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a125">DO_DIRECT_IO</a>) {
00598 
00599         <span class="comment">//</span>
00600         <span class="comment">// This is a direct I/O operation.  Allocate an MDL and invoke the</span>
00601         <span class="comment">// memory management routine to lock the buffer into memory.  This is</span>
00602         <span class="comment">// done using an exception handler that will perform cleanup if the</span>
00603         <span class="comment">// operation fails.</span>
00604         <span class="comment">//</span>
00605 
00606         mdl = (<a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00607 
00608         <span class="keywordflow">try</span> {
00609 
00610             <span class="comment">//</span>
00611             <span class="comment">// Allocate an MDL, charging quota for it, and hang it off of the</span>
00612             <span class="comment">// IRP.  Probe and lock the pages associated with the caller's</span>
00613             <span class="comment">// buffer for write access and fill in the MDL with the PFNs of</span>
00614             <span class="comment">// those pages.</span>
00615             <span class="comment">//</span>
00616 
00617             mdl = <a class="code" href="../../d4/d6/iosubs_8c.html#a19">IoAllocateMdl</a>( FileInformation, Length, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, irp );
00618             <span class="keywordflow">if</span> (mdl == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00619                 <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INSUFFICIENT_RESOURCES );
00620             }
00621             <a class="code" href="../../d5/d6/iosup_8c.html#a41">MmProbeAndLockPages</a>( mdl, requestorMode, <a class="code" href="../../d2/d1/mm_8h.html#a344a169">IoWriteAccess</a> );
00622 
00623         } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
00624 
00625             <span class="comment">//</span>
00626             <span class="comment">// An exception was incurred while either probing the caller's</span>
00627             <span class="comment">// buffer or allocating the MDL.  Determine what actually happened,</span>
00628             <span class="comment">// clean everything up, and return an appropriate error status code.</span>
00629             <span class="comment">//</span>
00630 
00631             <a class="code" href="../../d0/d6/iop_8h.html#a170">IopExceptionCleanup</a>( fileObject,
00632                                  irp,
00633                                  eventObject,
00634                                  (<a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00635 
00636             <span class="keywordflow">if</span> (auxiliaryBuffer != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00637                 <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( auxiliaryBuffer );
00638             }
00639 
00640             <span class="keywordflow">return</span> GetExceptionCode();
00641 
00642         }
00643 
00644     } <span class="keywordflow">else</span> {
00645 
00646         <span class="comment">//</span>
00647         <span class="comment">// Pass the address of the user's buffer so the driver has access to</span>
00648         <span class="comment">// it.  It is now the driver's responsibility to do everything.</span>
00649         <span class="comment">//</span>
00650 
00651         irp-&gt;UserBuffer = FileInformation;
00652 
00653     }
00654 
00655     <span class="comment">//</span>
00656     <span class="comment">// Copy the caller's parameters to the service-specific portion of the</span>
00657     <span class="comment">// IRP.</span>
00658     <span class="comment">//</span>
00659 
00660     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.QueryDirectory.Length = Length;
00661     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.QueryDirectory.FileInformationClass = FileInformationClass;
00662     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.QueryDirectory.FileIndex = 0;
00663     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.QueryDirectory.FileName = (PSTRING) auxiliaryBuffer;
00664     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o2">Flags</a> = 0;
00665     <span class="keywordflow">if</span> (RestartScan) {
00666         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o2">Flags</a> = <a class="code" href="../../d0/d5/io_8h.html#a208">SL_RESTART_SCAN</a>;
00667     }
00668     <span class="keywordflow">if</span> (ReturnSingleEntry) {
00669         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o2">Flags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a209">SL_RETURN_SINGLE_ENTRY</a>;
00670     }
00671 
00672     irp-&gt;Flags |= <a class="code" href="../../d0/d5/io_8h.html#a186">IRP_DEFER_IO_COMPLETION</a>;
00673 
00674     <span class="comment">//</span>
00675     <span class="comment">// Return with everything set up for the caller to complete the I/O.</span>
00676     <span class="comment">//</span>
00677 
00678     <span class="keywordflow">return</span> STATUS_SUCCESS;
00679 }
00680 
00681 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00682"></a><a class="code" href="../../d0/d8/dir_8c.html#a1">00682</a> <a class="code" href="../../d0/d8/dir_8c.html#a1">NtQueryDirectoryFile</a>(
00683     IN HANDLE FileHandle,
00684     IN HANDLE Event OPTIONAL,
00685     IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
00686     IN PVOID ApcContext OPTIONAL,
00687     OUT PIO_STATUS_BLOCK IoStatusBlock,
00688     OUT PVOID FileInformation,
00689     IN ULONG Length,
00690     IN FILE_INFORMATION_CLASS FileInformationClass,
00691     IN BOOLEAN ReturnSingleEntry,
00692     IN PUNICODE_STRING FileName OPTIONAL,
00693     IN BOOLEAN RestartScan
00694     )
00695 
00696 <span class="comment">/*++</span>
00697 <span class="comment"></span>
00698 <span class="comment">Routine Description:</span>
00699 <span class="comment"></span>
00700 <span class="comment">    This service operates on a directory file specified by the FileHandle</span>
00701 <span class="comment">    parameter.  The service returns information about files in the directory</span>
00702 <span class="comment">    specified by the file handle.  The ReturnSingleEntry parameter specifies</span>
00703 <span class="comment">    that only a single entry should be returned rather than filling the buffer.</span>
00704 <span class="comment">    The actual number of files whose information is returned, is the smallest</span>
00705 <span class="comment">    of the following:</span>
00706 <span class="comment"></span>
00707 <span class="comment">        o  One entry, if the ReturnSingleEntry parameter is TRUE.</span>
00708 <span class="comment"></span>
00709 <span class="comment">        o  The number of files whose information fits into the specified</span>
00710 <span class="comment">           buffer.</span>
00711 <span class="comment"></span>
00712 <span class="comment">        o  The number of files that exist.</span>
00713 <span class="comment"></span>
00714 <span class="comment">        o  One entry if the optional FileName parameter is specified.</span>
00715 <span class="comment"></span>
00716 <span class="comment">    If the optional FileName parameter is specified, then the only information</span>
00717 <span class="comment">    that is returned is for that single file, if it exists.  Note that the</span>
00718 <span class="comment">    file name may not specify any wildcard characters according to the naming</span>
00719 <span class="comment">    conventions of the target file system.  The ReturnSingleEntry parameter is</span>
00720 <span class="comment">    simply ignored.</span>
00721 <span class="comment"></span>
00722 <span class="comment">    The information that is obtained about the files in the directory is based</span>
00723 <span class="comment">    on the FileInformationClass parameter.  The legal values are as follows:</span>
00724 <span class="comment"></span>
00725 <span class="comment">        o  FileNamesInformation</span>
00726 <span class="comment"></span>
00727 <span class="comment">        o  FileDirectoryInformation</span>
00728 <span class="comment"></span>
00729 <span class="comment">        o  FileFullDirectoryInformation</span>
00730 <span class="comment"></span>
00731 <span class="comment">Arguments:</span>
00732 <span class="comment"></span>
00733 <span class="comment">    FileHandle - Supplies a handle to the directory file for which information</span>
00734 <span class="comment">        should be returned.</span>
00735 <span class="comment"></span>
00736 <span class="comment">    Event - Supplies an optional event to be set to the Signaled state when</span>
00737 <span class="comment">        the query is complete.</span>
00738 <span class="comment"></span>
00739 <span class="comment">    ApcRoutine - Supplies an optional APC routine to be executed when the</span>
00740 <span class="comment">        query is complete.</span>
00741 <span class="comment"></span>
00742 <span class="comment">    ApcContext - Supplies a context parameter to be passed to the ApcRoutine,</span>
00743 <span class="comment">        if an ApcRoutine was specified.</span>
00744 <span class="comment"></span>
00745 <span class="comment">    IoStatusBlock - Address of the caller's I/O status block.</span>
00746 <span class="comment"></span>
00747 <span class="comment">    FileInformation - Supplies a buffer to receive the requested information</span>
00748 <span class="comment">        returned about the contents of the directory.</span>
00749 <span class="comment"></span>
00750 <span class="comment">    Length - Supplies the length, in bytes, of the FileInformation buffer.</span>
00751 <span class="comment"></span>
00752 <span class="comment">    FileInformationClass - Specfies the type of information that is to be</span>
00753 <span class="comment">        returned about the files in the specified directory.</span>
00754 <span class="comment"></span>
00755 <span class="comment">    ReturnSingleEntry - Supplies a BOOLEAN value that, if TRUE, indicates that</span>
00756 <span class="comment">        only a single entry should be returned.</span>
00757 <span class="comment"></span>
00758 <span class="comment">    FileName - Optionally supplies a file name within the specified directory.</span>
00759 <span class="comment"></span>
00760 <span class="comment">    RestartScan - Supplies a BOOLEAN value that, if TRUE, indicates that the</span>
00761 <span class="comment">        scan should be restarted from the beginning.  This parameter must be</span>
00762 <span class="comment">        set to TRUE by the caller the first time the service is invoked.</span>
00763 <span class="comment"></span>
00764 <span class="comment">Return Value:</span>
00765 <span class="comment"></span>
00766 <span class="comment">    The status returned is success if the query operation was properly queued</span>
00767 <span class="comment">    to the I/O system.  Once the operation completes, the status of the query</span>
00768 <span class="comment">    can be determined by examining the Status field of the I/O status block.</span>
00769 <span class="comment"></span>
00770 <span class="comment">--*/</span>
00771 
00772 {
00773     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
00774     BOOLEAN synchronousIo;
00775     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> deviceObject;
00776     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
00777     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> fileObject;
00778     <a class="code" href="../../d0/d9/ntosdef_8h.html#a39">KPROCESSOR_MODE</a> requestorMode;
00779 
00780     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00781 
00782     <span class="comment">//</span>
00783     <span class="comment">// Build the irp with the appropriate minor function &amp; allowed info levels.</span>
00784     <span class="comment">//</span>
00785 
00786     status = <a class="code" href="../../d0/d8/dir_8c.html#a0">BuildQueryDirectoryIrp</a>( FileHandle,
00787                                      <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>,
00788                                      ApcRoutine,
00789                                      ApcContext,
00790                                      IoStatusBlock,
00791                                      FileInformation,
00792                                      Length,
00793                                      FileInformationClass,
00794                                      ReturnSingleEntry,
00795                                      <a class="code" href="../../d2/d2/rtload_8c.html#a3">FileName</a>,
00796                                      RestartScan,
00797                                      <a class="code" href="../../d0/d5/io_8h.html#a44">IRP_MN_QUERY_DIRECTORY</a>,
00798                                      &amp;synchronousIo,
00799                                      &amp;deviceObject,
00800                                      &amp;irp,
00801                                      &amp;fileObject,
00802                                      &amp;requestorMode);
00803     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
00804 
00805         <span class="comment">//</span>
00806         <span class="comment">// Queue the packet, call the driver, and synchronize appopriately with</span>
00807         <span class="comment">// I/O completion.</span>
00808         <span class="comment">//</span>
00809         status = <a class="code" href="../../d0/d6/iop_8h.html#a212">IopSynchronousServiceTail</a>( deviceObject,
00810                                             irp,
00811                                             fileObject,
00812                                             <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
00813                                             requestorMode,
00814                                             synchronousIo,
00815                                             <a class="code" href="../../d0/d6/iop_8h.html#a240a140">OtherTransfer</a> );
00816     }
00817     <span class="keywordflow">return</span> status;
00818 }
00819 
00820 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00821"></a><a class="code" href="../../d0/d8/dir_8c.html#a2">00821</a> <a class="code" href="../../d0/d8/dir_8c.html#a2">NtNotifyChangeDirectoryFile</a>(
00822     IN HANDLE FileHandle,
00823     IN HANDLE Event OPTIONAL,
00824     IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
00825     IN PVOID ApcContext OPTIONAL,
00826     OUT PIO_STATUS_BLOCK IoStatusBlock,
00827     OUT PVOID Buffer,
00828     IN ULONG Length,
00829     IN ULONG CompletionFilter,
00830     IN BOOLEAN WatchTree
00831     )
00832 
00833 <span class="comment">/*++</span>
00834 <span class="comment"></span>
00835 <span class="comment">Routine Description:</span>
00836 <span class="comment"></span>
00837 <span class="comment">    This service monitors a directory file for changes.  Once a change is</span>
00838 <span class="comment">    made to the directory specified by the FileHandle parameter, the I/O</span>
00839 <span class="comment">    operation is completed.</span>
00840 <span class="comment"></span>
00841 <span class="comment">Arguments:</span>
00842 <span class="comment"></span>
00843 <span class="comment">    FileHandle - Supplies a handle to the file whose EAs should be changed.</span>
00844 <span class="comment"></span>
00845 <span class="comment">    Event - Supplies an optional event to be set to the Signaled state when the</span>
00846 <span class="comment">        change is complete.</span>
00847 <span class="comment"></span>
00848 <span class="comment">    ApcRoutine - Supplies an optional APC routine to be executed when the change</span>
00849 <span class="comment">        is complete.</span>
00850 <span class="comment"></span>
00851 <span class="comment">    ApcContext - Supplies a context parameter to be passed to the ApcRoutine,</span>
00852 <span class="comment">        if an ApcRoutine was specified.</span>
00853 <span class="comment"></span>
00854 <span class="comment">    IoStatusBlock - Address of the caller's I/O status block.</span>
00855 <span class="comment"></span>
00856 <span class="comment">    Buffer - Address of variable to receive the names of the files or</span>
00857 <span class="comment">        directories that have changed since the last time that the service</span>
00858 <span class="comment">        was invoked.</span>
00859 <span class="comment"></span>
00860 <span class="comment">    Length - Length of the output buffer.  On the first call, this parameter</span>
00861 <span class="comment">        also serves as a guideline for how large to make the system's</span>
00862 <span class="comment">        internal buffer.  Specifying a buffer length of zero causes the request</span>
00863 <span class="comment">        to complete when changes are made, but no information about the</span>
00864 <span class="comment">        changes are returned.</span>
00865 <span class="comment"></span>
00866 <span class="comment">    CompletionFilter - Indicates the types of changes to files or directories</span>
00867 <span class="comment">        within the directory that will complete the I/O operation.</span>
00868 <span class="comment"></span>
00869 <span class="comment">    WatchTree - A BOOLEAN value that indicates whether or not changes to</span>
00870 <span class="comment">        directories below the directory referred to by the FileHandle</span>
00871 <span class="comment">        parameter cause the operation to complete.</span>
00872 <span class="comment"></span>
00873 <span class="comment">Return Value:</span>
00874 <span class="comment"></span>
00875 <span class="comment">    The status returned is success if the operation was properly queued to the</span>
00876 <span class="comment">    I/O system.  Once the operation completes, the status of the operation can</span>
00877 <span class="comment">    be determined by examining the Status field of the I/O status block.</span>
00878 <span class="comment"></span>
00879 <span class="comment">--*/</span>
00880 
00881 {
00882     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
00883     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
00884     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> fileObject;
00885     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> deviceObject;
00886     <a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a> eventObject = (<a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00887     <a class="code" href="../../d0/d9/ntosdef_8h.html#a39">KPROCESSOR_MODE</a> requestorMode;
00888     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpSp;
00889     BOOLEAN synchronousIo;
00890 
00891     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00892 
00893     <span class="comment">//</span>
00894     <span class="comment">// Get the previous mode;  i.e., the mode of the caller.</span>
00895     <span class="comment">//</span>
00896 
00897     requestorMode = KeGetPreviousMode();
00898 
00899     <span class="keywordflow">if</span> (requestorMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
00900 
00901         <span class="comment">//</span>
00902         <span class="comment">// The caller's access mode is user, so probe each of the arguments</span>
00903         <span class="comment">// and capture them as necessary.  If any failures occur, the condition</span>
00904         <span class="comment">// handler will be invoked to handle them.  It will simply cleanup and</span>
00905         <span class="comment">// return an access violation status code back to the system service</span>
00906         <span class="comment">// dispatcher.</span>
00907         <span class="comment">//</span>
00908 
00909         <span class="keywordflow">try</span> {
00910 
00911             <span class="comment">//</span>
00912             <span class="comment">// The IoStatusBlock parameter must be writeable by the caller.</span>
00913             <span class="comment">//</span>
00914 
00915             <a class="code" href="../../d5/d8/ex_8h.html#a32">ProbeForWriteIoStatusEx</a>( IoStatusBlock , ApcRoutine);
00916 
00917             <span class="comment">//</span>
00918             <span class="comment">// The Buffer parameter must be writeable by the caller.</span>
00919             <span class="comment">//</span>
00920 
00921             <span class="keywordflow">if</span> (Length != 0) {
00922                 <a class="code" href="../../d5/d8/ex_8h.html#a259">ProbeForWrite</a>( <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>,
00923                                Length,
00924                                <span class="keyword">sizeof</span>( ULONG ) );
00925             }
00926 
00927         } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
00928 
00929             <span class="comment">//</span>
00930             <span class="comment">// An exception was incurred probing the caller's I/O status</span>
00931             <span class="comment">// block.  Simply return the appropriate error status code.</span>
00932             <span class="comment">//</span>
00933 
00934             <span class="keywordflow">return</span> GetExceptionCode();
00935 
00936         }
00937 
00938         <span class="comment">//</span>
00939         <span class="comment">// The CompletionFilter parameter must not contain any values which</span>
00940         <span class="comment">// are illegal, nor may it not specifiy anything at all.  Likewise,</span>
00941         <span class="comment">// the caller must supply a non-null buffer.</span>
00942         <span class="comment">//</span>
00943 
00944         <span class="keywordflow">if</span> (((CompletionFilter &amp; ~FILE_NOTIFY_VALID_MASK) ||
00945             !CompletionFilter)) {
00946             <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
00947         }
00948 
00949     }
00950 
00951     <span class="comment">//</span>
00952     <span class="comment">// There were no blatant errors so far, so reference the file object so</span>
00953     <span class="comment">// the target device object can be found.  Note that if the handle does</span>
00954     <span class="comment">// not refer to a file object, or if the caller does not have the required</span>
00955     <span class="comment">// access to the file, then it will fail.</span>
00956     <span class="comment">//</span>
00957 
00958     status = <a class="code" href="../../d7/d1/obref_8c.html#a4">ObReferenceObjectByHandle</a>( FileHandle,
00959                                         FILE_LIST_DIRECTORY,
00960                                         <a class="code" href="../../d5/d8/fssup_8c.html#a3">IoFileObjectType</a>,
00961                                         requestorMode,
00962                                         (PVOID *) &amp;fileObject,
00963                                         (<a class="code" href="../../d3/d5/struct__OBJECT__HANDLE__INFORMATION.html">POBJECT_HANDLE_INFORMATION</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00964     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
00965         <span class="keywordflow">return</span> status;
00966     }
00967 
00968     <span class="comment">//</span>
00969     <span class="comment">// If this file has an I/O completion port associated w/it, then ensure</span>
00970     <span class="comment">// that the caller did not supply an APC routine, as the two are mutually</span>
00971     <span class="comment">// exclusive methods for I/O completion notification.</span>
00972     <span class="comment">//</span>
00973 
00974     <span class="keywordflow">if</span> (fileObject-&gt;CompletionContext &amp;&amp; <a class="code" href="../../d0/d6/iop_8h.html#a19">IopApcRoutinePresent</a>( ApcRoutine )) {
00975         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
00976         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
00977     }
00978 
00979     <span class="comment">//</span>
00980     <span class="comment">// Get the address of the event object and set the event to the Not-</span>
00981     <span class="comment">// Signaled state, if an event was specified.  Note here too, that if</span>
00982     <span class="comment">// the handle does not refer to an event, or if the event cannot be</span>
00983     <span class="comment">// written, then the reference will fail.</span>
00984     <span class="comment">//</span>
00985 
00986     <span class="keywordflow">if</span> (ARGUMENT_PRESENT( <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a> )) {
00987         status = <a class="code" href="../../d7/d1/obref_8c.html#a4">ObReferenceObjectByHandle</a>( <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>,
00988                                             EVENT_MODIFY_STATE,
00989                                             <a class="code" href="../../d7/d7/ntapi_8c.html#a3">ExEventObjectType</a>,
00990                                             requestorMode,
00991                                             (PVOID *) &amp;eventObject,
00992                                             (<a class="code" href="../../d3/d5/struct__OBJECT__HANDLE__INFORMATION.html">POBJECT_HANDLE_INFORMATION</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00993         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
00994             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
00995             <span class="keywordflow">return</span> status;
00996         } <span class="keywordflow">else</span> {
00997             <a class="code" href="../../d4/d9/ke_8h.html#a21">KeClearEvent</a>( eventObject );
00998         }
00999     }
01000 
01001     <span class="comment">//</span>
01002     <span class="comment">// Make a special check here to determine whether this is a synchronous</span>
01003     <span class="comment">// I/O operation.  If it is, then wait here until the file is owned by</span>
01004     <span class="comment">// the current thread.</span>
01005     <span class="comment">//</span>
01006 
01007     <span class="keywordflow">if</span> (fileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a151">FO_SYNCHRONOUS_IO</a>) {
01008 
01009         BOOLEAN interrupted;
01010 
01011         <span class="keywordflow">if</span> (!<a class="code" href="../../d0/d6/iop_8h.html#a13">IopAcquireFastLock</a>( fileObject )) {
01012             status = <a class="code" href="../../d0/d6/iop_8h.html#a147">IopAcquireFileObjectLock</a>( fileObject,
01013                                                requestorMode,
01014                                                (BOOLEAN) ((fileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a152">FO_ALERTABLE_IO</a>) != 0),
01015                                                &amp;interrupted );
01016             <span class="keywordflow">if</span> (interrupted) {
01017                 <span class="keywordflow">if</span> (eventObject != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01018                     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( eventObject );
01019                 }
01020                 <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
01021                 <span class="keywordflow">return</span> status;
01022             }
01023         }
01024         synchronousIo = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01025     } <span class="keywordflow">else</span> {
01026         synchronousIo = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01027     }
01028 
01029     <span class="comment">//</span>
01030     <span class="comment">// Set the file object to the Not-Signaled state.</span>
01031     <span class="comment">//</span>
01032 
01033     <a class="code" href="../../d4/d9/ke_8h.html#a21">KeClearEvent</a>( &amp;fileObject-&gt;Event );
01034 
01035     <span class="comment">//</span>
01036     <span class="comment">// Get the address of the target device object.</span>
01037     <span class="comment">//</span>
01038 
01039     deviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a76">IoGetRelatedDeviceObject</a>( fileObject );
01040 
01041     <span class="comment">//</span>
01042     <span class="comment">// Allocate and initialize the I/O Request Packet (IRP) for this operation.</span>
01043     <span class="comment">// The allocation is performed with an exception handler in case the</span>
01044     <span class="comment">// caller does not have enough quota to allocate the packet.</span>
01045 
01046     irp = <a class="code" href="../../d4/d6/iosubs_8c.html#a17">IoAllocateIrp</a>( deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o13">StackSize</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
01047     <span class="keywordflow">if</span> (!irp) {
01048 
01049         <span class="comment">//</span>
01050         <span class="comment">// An IRP could not be allocated.  Cleanup and return an appropriate</span>
01051         <span class="comment">// error status code.</span>
01052         <span class="comment">//</span>
01053 
01054         <a class="code" href="../../d0/d6/iop_8h.html#a148">IopAllocateIrpCleanup</a>( fileObject, eventObject );
01055 
01056         <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
01057     }
01058     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.OriginalFileObject = fileObject;
01059     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.Thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
01060     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o10">RequestorMode</a> = requestorMode;
01061 
01062     <span class="comment">//</span>
01063     <span class="comment">// Fill in the service independent parameters in the IRP.</span>
01064     <span class="comment">//</span>
01065 
01066     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o19">UserEvent</a> = eventObject;
01067     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o18">UserIosb</a> = IoStatusBlock;
01068     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o24">Overlay</a>.AsynchronousParameters.UserApcRoutine = ApcRoutine;
01069     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o24">Overlay</a>.AsynchronousParameters.UserApcContext = ApcContext;
01070 
01071     <span class="comment">//</span>
01072     <span class="comment">// Get a pointer to the stack location for the first driver.  This will be</span>
01073     <span class="comment">// used to pass the original function codes and the parameters.</span>
01074     <span class="comment">//</span>
01075 
01076     irpSp = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>( irp );
01077     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a> = <a class="code" href="../../d0/d5/io_8h.html#a25">IRP_MJ_DIRECTORY_CONTROL</a>;
01078     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o1">MinorFunction</a> = <a class="code" href="../../d0/d5/io_8h.html#a45">IRP_MN_NOTIFY_CHANGE_DIRECTORY</a>;
01079     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a> = fileObject;
01080 
01081     <span class="comment">//</span>
01082     <span class="comment">// Now determine whether this device expects to have data buffered to it</span>
01083     <span class="comment">// or whether it performs direct I/O.  This is based on the DO_BUFFERED_IO</span>
01084     <span class="comment">// flag in the device object.  If the flag is set, then a system buffer is</span>
01085     <span class="comment">// allocated and the driver's data will be copied into it.  Otherwise, a</span>
01086     <span class="comment">// Memory Descriptor List (MDL) is allocated and the caller's buffer is</span>
01087     <span class="comment">// locked down using it.</span>
01088     <span class="comment">//</span>
01089 
01090     <span class="keywordflow">if</span> (Length != 0) {
01091 
01092         <span class="keywordflow">if</span> (deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o8">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a123">DO_BUFFERED_IO</a>) {
01093 
01094             <span class="comment">//</span>
01095             <span class="comment">// The device does not support direct I/O.  Allocate a system</span>
01096             <span class="comment">// buffer and specify that it should be deallocated on completion.</span>
01097             <span class="comment">// Also indicate that this is an input operation so the data will</span>
01098             <span class="comment">// be copied into the caller's buffer.  This is done using an</span>
01099             <span class="comment">// exception handler that will perform cleanup if the operation</span>
01100             <span class="comment">// fails.</span>
01101             <span class="comment">//</span>
01102 
01103             <span class="keywordflow">try</span> {
01104 
01105                 <span class="comment">//</span>
01106                 <span class="comment">// Allocate the intermediary system buffer from nonpaged pool</span>
01107                 <span class="comment">// and charge quota for it.</span>
01108                 <span class="comment">//</span>
01109 
01110                 irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.SystemBuffer =
01111                      <a class="code" href="../../d5/d5/cc_8h.html#a11">ExAllocatePoolWithQuota</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, Length );
01112 
01113             } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
01114 
01115                 <span class="comment">//</span>
01116                 <span class="comment">// An exception was incurred while attempting to allocate the</span>
01117                 <span class="comment">// intermediary system buffer.  Clean everything up and return</span>
01118                 <span class="comment">// an appropriate error status code.</span>
01119                 <span class="comment">//</span>
01120 
01121                 <a class="code" href="../../d0/d6/iop_8h.html#a170">IopExceptionCleanup</a>( fileObject,
01122                                      irp,
01123                                      eventObject,
01124                                      (<a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
01125 
01126                 <span class="keywordflow">return</span> GetExceptionCode();
01127 
01128             }
01129 
01130             <span class="comment">//</span>
01131             <span class="comment">// Remember the address of the caller's buffer so the copy can take</span>
01132             <span class="comment">// place during I/O completion.  Also, set the flags so that the</span>
01133             <span class="comment">// completion code knows to do the copy and to deallocate the</span>
01134             <span class="comment">// buffer.</span>
01135             <span class="comment">//</span>
01136 
01137             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o26">UserBuffer</a> = <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>;
01138             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> = <a class="code" href="../../d0/d5/io_8h.html#a178">IRP_BUFFERED_IO</a> |
01139                          <a class="code" href="../../d0/d5/io_8h.html#a179">IRP_DEALLOCATE_BUFFER</a> |
01140                          <a class="code" href="../../d0/d5/io_8h.html#a180">IRP_INPUT_OPERATION</a>;
01141 
01142         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o8">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a125">DO_DIRECT_IO</a>) {
01143 
01144             <span class="comment">//</span>
01145             <span class="comment">// This is a direct I/O operation.  Allocate an MDL and invoke the</span>
01146             <span class="comment">// memory management routine to lock the buffer into memory.  This</span>
01147             <span class="comment">// is done using an exception handler that will perform cleanup if</span>
01148             <span class="comment">// the operation fails.</span>
01149             <span class="comment">//</span>
01150 
01151             <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> mdl;
01152 
01153             mdl = (<a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01154 
01155             <span class="keywordflow">try</span> {
01156 
01157                 <span class="comment">//</span>
01158                 <span class="comment">// Allocate an MDL, charging quota for it, and hang it off of</span>
01159                 <span class="comment">// the IRP.  Probe and lock the pages associated with the</span>
01160                 <span class="comment">// caller's buffer for write access and fill in the MDL with</span>
01161                 <span class="comment">// the PFNs of those pages.</span>
01162                 <span class="comment">//</span>
01163 
01164                 mdl = <a class="code" href="../../d4/d6/iosubs_8c.html#a19">IoAllocateMdl</a>( <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>, Length, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, irp );
01165                 <span class="keywordflow">if</span> (mdl == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01166                     <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INSUFFICIENT_RESOURCES );
01167                 }
01168                 <a class="code" href="../../d5/d6/iosup_8c.html#a41">MmProbeAndLockPages</a>( mdl, requestorMode, <a class="code" href="../../d2/d1/mm_8h.html#a344a169">IoWriteAccess</a> );
01169 
01170             } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
01171 
01172                 <span class="comment">//</span>
01173                 <span class="comment">// An exception was incurred while either probing the caller's</span>
01174                 <span class="comment">// buffer of allocating the MDL.  Determine what actually</span>
01175                 <span class="comment">// happened, clean everything up, and return an appropriate</span>
01176                 <span class="comment">// error status code.</span>
01177                 <span class="comment">//</span>
01178 
01179                 <a class="code" href="../../d0/d6/iop_8h.html#a170">IopExceptionCleanup</a>( fileObject,
01180                                      irp,
01181                                      eventObject,
01182                                      (<a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
01183 
01184                 <span class="keywordflow">return</span> GetExceptionCode();
01185 
01186             }
01187 
01188         } <span class="keywordflow">else</span> {
01189 
01190             <span class="comment">//</span>
01191             <span class="comment">// Pass the address of the user's buffer so the driver has access</span>
01192             <span class="comment">// to it.  It is now the driver's responsibility to do everything.</span>
01193             <span class="comment">//</span>
01194 
01195             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o26">UserBuffer</a> = <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>;
01196 
01197         }
01198     }
01199 
01200     <span class="comment">//</span>
01201     <span class="comment">// Copy the caller's parameters to the service-specific portion of the</span>
01202     <span class="comment">// IRP.</span>
01203     <span class="comment">//</span>
01204 
01205     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.NotifyDirectory.Length = Length;
01206     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.NotifyDirectory.CompletionFilter = CompletionFilter;
01207     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d2/rtnotify_8c.html#a4">WatchTree</a>) {
01208         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o2">Flags</a> = <a class="code" href="../../d0/d5/io_8h.html#a211">SL_WATCH_TREE</a>;
01209     }
01210 
01211     <span class="comment">//</span>
01212     <span class="comment">// Queue the packet, call the driver, and synchronize appopriately with</span>
01213     <span class="comment">// I/O completion.</span>
01214     <span class="comment">//</span>
01215 
01216     <span class="keywordflow">return</span> <a class="code" href="../../d0/d6/iop_8h.html#a212">IopSynchronousServiceTail</a>( deviceObject,
01217                                       irp,
01218                                       fileObject,
01219                                       <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
01220                                       requestorMode,
01221                                       synchronousIo,
01222                                       <a class="code" href="../../d0/d6/iop_8h.html#a240a140">OtherTransfer</a> );
01223 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:39:44 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
