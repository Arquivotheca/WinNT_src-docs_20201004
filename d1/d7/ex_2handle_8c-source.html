<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: handle.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>handle.c</h1><a href="../../d0/d8/ex_2handle_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1989-1995  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    handle.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module implements a set of functions for supporting handles.</span>
00012 <span class="comment"></span>
00013 <span class="comment">Author:</span>
00014 <span class="comment"></span>
00015 <span class="comment">    Steve Wood (stevewo) 25-Apr-1989</span>
00016 <span class="comment">    David N. Cutler (davec) 17-May-1995 (rewrite)</span>
00017 <span class="comment">    Gary Kimura (GaryKi) 9-Dec-1997 (rerewrite)</span>
00018 <span class="comment"></span>
00019 <span class="comment">Revision History:</span>
00020 <span class="comment"></span>
00021 <span class="comment">--*/</span>
00022 
00023 <span class="preprocessor">#include "<a class="code" href="../../d4/d0/exp_8h.html">exp.h</a>"</span>
00024 <span class="preprocessor">#pragma hdrstop</span>
00025 <span class="preprocessor"></span>
00026 
00027 <span class="comment">//</span>
00028 <span class="comment">//  Local constants and support routines</span>
00029 <span class="comment">//</span>
00030 
00031 <span class="comment">//</span>
00032 <span class="comment">//  Define global structures that link all handle tables together except the</span>
00033 <span class="comment">//  ones where the user has called RemoveHandleTable</span>
00034 <span class="comment">//</span>
00035 
<a name="l00036"></a><a class="code" href="../../d0/d8/ex_2handle_8c.html#a1">00036</a> <a class="code" href="../../d6/d4/struct__ERESOURCE.html">ERESOURCE</a> <a class="code" href="../../d0/d8/ex_2handle_8c.html#a1">HandleTableListLock</a>;
<a name="l00037"></a><a class="code" href="../../d0/d8/ex_2handle_8c.html#a2">00037</a> LIST_ENTRY <a class="code" href="../../d0/d8/ex_2handle_8c.html#a2">HandleTableListHead</a>;
00038 
00039 
00040 <span class="comment">//</span>
00041 <span class="comment">//  This is the sign bit used to lock handle table entries</span>
00042 <span class="comment">//</span>
00043 
<a name="l00044"></a><a class="code" href="../../d0/d8/ex_2handle_8c.html#a0">00044</a> <span class="preprocessor">#define EXHANDLE_TABLE_ENTRY_LOCK_BIT    ((ULONG_PTR)1 &lt;&lt; ((sizeof(ULONG_PTR) * 8) - 1))</span>
00045 <span class="preprocessor"></span>
00046 <span class="comment">//</span>
00047 <span class="comment">//  This is the delay we willing to do to try and get a handle table</span>
00048 <span class="comment">//  entry lock</span>
00049 <span class="comment">//</span>
00050 
<a name="l00051"></a><a class="code" href="../../d0/d8/ex_2handle_8c.html#a3">00051</a> LARGE_INTEGER <a class="code" href="../../d0/d8/ex_2handle_8c.html#a3">Ex10Milliseconds</a> = {(ULONG)(-10 * 1000 * 10), -1};
00052 
00053 <span class="comment">//</span>
00054 <span class="comment">//  Local support routines</span>
00055 <span class="comment">//</span>
00056 
00057 <a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html">PHANDLE_TABLE</a>
00058 <a class="code" href="../../d0/d8/ex_2handle_8c.html#a4">ExpAllocateHandleTable</a> (
00059     IN <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> Process OPTIONAL
00060     );
00061 
00062 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00063 <a class="code" href="../../d0/d8/ex_2handle_8c.html#a5">ExpFreeHandleTable</a> (
00064     IN <a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html">PHANDLE_TABLE</a> HandleTable
00065     );
00066 
00067 <a class="code" href="../../d7/d3/struct__HANDLE__TABLE__ENTRY.html">PHANDLE_TABLE_ENTRY</a>
00068 <a class="code" href="../../d0/d8/ex_2handle_8c.html#a6">ExpAllocateHandleTableEntry</a> (
00069     IN <a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html">PHANDLE_TABLE</a> HandleTable,
00070     OUT <a class="code" href="../../d7/d8/struct__EXHANDLE.html">PEXHANDLE</a> Handle
00071     );
00072 
00073 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00074 <a class="code" href="../../d0/d8/ex_2handle_8c.html#a7">ExpFreeHandleTableEntry</a> (
00075     IN <a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html">PHANDLE_TABLE</a> HandleTable,
00076     IN <a class="code" href="../../d7/d8/struct__EXHANDLE.html">EXHANDLE</a> Handle,
00077     IN <a class="code" href="../../d7/d3/struct__HANDLE__TABLE__ENTRY.html">PHANDLE_TABLE_ENTRY</a> HandleTableEntry
00078     );
00079 
00080 <a class="code" href="../../d7/d3/struct__HANDLE__TABLE__ENTRY.html">PHANDLE_TABLE_ENTRY</a>
00081 <a class="code" href="../../d0/d8/ex_2handle_8c.html#a8">ExpLookupHandleTableEntry</a> (
00082     IN <a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html">PHANDLE_TABLE</a> HandleTable,
00083     IN <a class="code" href="../../d7/d8/struct__EXHANDLE.html">EXHANDLE</a> Handle
00084     );
00085 
00086 <span class="preprocessor">#ifdef ALLOC_PRAGMA</span>
00087 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(INIT, ExInitializeHandleTablePackage)</span>
00088 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, ExLockHandleTableShared)</span>
00089 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, ExLockHandleTableExclusive)</span>
00090 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, ExUnlockHandleTableShared)</span>
00091 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, ExUnlockHandleTableExclusive)</span>
00092 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, ExLockHandleTableEntry)</span>
00093 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, ExUnlockHandleTableEntry)</span>
00094 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, ExCreateHandleTable)</span>
00095 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, ExRemoveHandleTable)</span>
00096 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, ExDestroyHandleTable)</span>
00097 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, ExEnumHandleTable)</span>
00098 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, ExDupHandleTable)</span>
00099 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, ExSnapShotHandleTables)</span>
00100 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, ExCreateHandle)</span>
00101 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, ExDestroyHandle)</span>
00102 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, ExChangeHandle)</span>
00103 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, ExMapHandleToPointer)</span>
00104 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, ExpAllocateHandleTable)</span>
00105 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, ExpFreeHandleTable)</span>
00106 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, ExpAllocateHandleTableEntry)</span>
00107 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, ExpFreeHandleTableEntry)</span>
00108 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, ExpLookupHandleTableEntry)</span>
00109 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00110 <span class="preprocessor"></span>
00111 
00112 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00113 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00114"></a><a class="code" href="../../d5/d8/ex_8h.html#a283">00114</a> <a class="code" href="../../d5/d8/ex_8h.html#a283">ExLockHandleTableShared</a> (
00115     <a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html">PHANDLE_TABLE</a> HandleTable
00116     )
00117 
00118 <span class="comment">/*++</span>
00119 <span class="comment"></span>
00120 <span class="comment">Routine Description:</span>
00121 <span class="comment"></span>
00122 <span class="comment">    This routine locks the specified handle table for shared access.  Once</span>
00123 <span class="comment">    locked new entries cannot be added to deleted from the handle table.</span>
00124 <span class="comment"></span>
00125 <span class="comment">Arguments:</span>
00126 <span class="comment"></span>
00127 <span class="comment">    HandleTable - Supplies the handle table being locked.</span>
00128 <span class="comment"></span>
00129 <span class="comment">Return Value:</span>
00130 <span class="comment"></span>
00131 <span class="comment">    None.</span>
00132 <span class="comment"></span>
00133 <span class="comment">--*/</span>
00134 
00135 {
00136     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00137 
00138     (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>)<a class="code" href="../../d5/d8/ex_8h.html#a69">ExAcquireResourceShared</a>( &amp;HandleTable-&gt;<a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html#o7">HandleTableLock</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
00139 
00140     <span class="keywordflow">return</span>;
00141 }
00142 
00143 
00144 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00145 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00146"></a><a class="code" href="../../d5/d8/ex_8h.html#a284">00146</a> <a class="code" href="../../d5/d8/ex_8h.html#a284">ExLockHandleTableExclusive</a> (
00147     <a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html">PHANDLE_TABLE</a> HandleTable
00148     )
00149 
00150 <span class="comment">/*++</span>
00151 <span class="comment"></span>
00152 <span class="comment">Routine Description:</span>
00153 <span class="comment"></span>
00154 <span class="comment">    This routine locks the specified handle table for exclusive access.  Once</span>
00155 <span class="comment">    locked the onwer can add or delete entries from the handle table.</span>
00156 <span class="comment"></span>
00157 <span class="comment">Arguments:</span>
00158 <span class="comment"></span>
00159 <span class="comment">    HandleTable - Supplies the handle table being locked.</span>
00160 <span class="comment"></span>
00161 <span class="comment">Return Value:</span>
00162 <span class="comment"></span>
00163 <span class="comment">    None.</span>
00164 <span class="comment"></span>
00165 <span class="comment">--*/</span>
00166 
00167 {
00168     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00169 
00170     (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>)<a class="code" href="../../d5/d8/ex_8h.html#a70">ExAcquireResourceExclusive</a>( &amp;HandleTable-&gt;<a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html#o7">HandleTableLock</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
00171 
00172     <span class="keywordflow">return</span>;
00173 }
00174 
00175 
00176 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00177 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00178"></a><a class="code" href="../../d5/d8/ex_8h.html#a285">00178</a> <a class="code" href="../../d5/d8/ex_8h.html#a285">ExUnlockHandleTableShared</a> (
00179     <a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html">PHANDLE_TABLE</a> HandleTable
00180     )
00181 
00182 <span class="comment">/*++</span>
00183 <span class="comment"></span>
00184 <span class="comment">Routine Description:</span>
00185 <span class="comment"></span>
00186 <span class="comment">    This routine unlocks the specified handle table from shared access.</span>
00187 <span class="comment"></span>
00188 <span class="comment">Arguments:</span>
00189 <span class="comment"></span>
00190 <span class="comment">    HandleTable - Supplies the handle table being unlocked.</span>
00191 <span class="comment"></span>
00192 <span class="comment">Return Value:</span>
00193 <span class="comment"></span>
00194 <span class="comment">    None.</span>
00195 <span class="comment"></span>
00196 <span class="comment">--*/</span>
00197 
00198 {
00199     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00200 
00201     (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>)<a class="code" href="../../d5/d8/ex_8h.html#a66">ExReleaseResource</a>( &amp;HandleTable-&gt;<a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html#o7">HandleTableLock</a> );
00202 
00203     <span class="keywordflow">return</span>;
00204 }
00205 
00206 
00207 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00208 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00209"></a><a class="code" href="../../d5/d8/ex_8h.html#a286">00209</a> <a class="code" href="../../d5/d8/ex_8h.html#a286">ExUnlockHandleTableExclusive</a> (
00210     <a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html">PHANDLE_TABLE</a> HandleTable
00211     )
00212 
00213 <span class="comment">/*++</span>
00214 <span class="comment"></span>
00215 <span class="comment">Routine Description:</span>
00216 <span class="comment"></span>
00217 <span class="comment">    This routine unlocks the specified handle table from exclusive access.</span>
00218 <span class="comment"></span>
00219 <span class="comment">Arguments:</span>
00220 <span class="comment"></span>
00221 <span class="comment">    HandleTable - Supplies the handle table being unlocked.</span>
00222 <span class="comment"></span>
00223 <span class="comment">Return Value:</span>
00224 <span class="comment"></span>
00225 <span class="comment">    None.</span>
00226 <span class="comment"></span>
00227 <span class="comment">--*/</span>
00228 
00229 {
00230     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00231 
00232     (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>)<a class="code" href="../../d5/d8/ex_8h.html#a66">ExReleaseResource</a>( &amp;HandleTable-&gt;<a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html#o7">HandleTableLock</a> );
00233 
00234     <span class="keywordflow">return</span>;
00235 }
00236 
00237 
00238 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00239 BOOLEAN
<a name="l00240"></a><a class="code" href="../../d5/d8/ex_8h.html#a287">00240</a> <a class="code" href="../../d5/d8/ex_8h.html#a287">ExLockHandleTableEntry</a> (
00241     <a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html">PHANDLE_TABLE</a> HandleTable,
00242     <a class="code" href="../../d7/d3/struct__HANDLE__TABLE__ENTRY.html">PHANDLE_TABLE_ENTRY</a> HandleTableEntry
00243     )
00244 
00245 <span class="comment">/*++</span>
00246 <span class="comment"></span>
00247 <span class="comment">Routine Description:</span>
00248 <span class="comment"></span>
00249 <span class="comment">    This routine locks the specified handle table entry.  After the entry is</span>
00250 <span class="comment">    locked the sign bit will be set.</span>
00251 <span class="comment"></span>
00252 <span class="comment">Arguments:</span>
00253 <span class="comment"></span>
00254 <span class="comment">    HandleTable - Supplies the handle table containing the entry being locked.</span>
00255 <span class="comment"></span>
00256 <span class="comment">    HandleTableEntry - Supplies the handle table entry being locked.</span>
00257 <span class="comment"></span>
00258 <span class="comment">Return Value:</span>
00259 <span class="comment"></span>
00260 <span class="comment">    TRUE if the entry is valid and locked, and FALSE if the entry is</span>
00261 <span class="comment">    marked free.</span>
00262 <span class="comment"></span>
00263 <span class="comment">--*/</span>
00264 
00265 {
00266     LONG_PTR NewValue;
00267     LONG_PTR CurrentValue;
00268     ULONG LoopCount = 0;
00269 
00270     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00271 
00272     <span class="comment">//</span>
00273     <span class="comment">//  We'll keep on looping reading in the value, making sure it is not null,</span>
00274     <span class="comment">//  and if it is not currently locked we'll try for the lock and return</span>
00275     <span class="comment">//  true if we get it.  Otherwise we'll pause a bit and then try again.</span>
00276     <span class="comment">//</span>
00277 
00278     <span class="keywordflow">while</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
00279 
00280         NewValue =
00281         CurrentValue = *((<span class="keyword">volatile</span> LONG_PTR *)&amp;HandleTableEntry-&gt;<a class="code" href="../../d7/d3/struct__HANDLE__TABLE__ENTRY.html#o0">Object</a>);
00282 
00283         <span class="comment">//</span>
00284         <span class="comment">//  Make sure the handle table entry is not freed</span>
00285         <span class="comment">//</span>
00286 
00287         <span class="keywordflow">if</span> (CurrentValue == 0) {
00288 
00289             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00290         }
00291 
00292         <span class="comment">//</span>
00293         <span class="comment">//  If the handle value is greater than zero then it is not currently</span>
00294         <span class="comment">//  locked and we should try for the lock, but setting the lock bit and</span>
00295         <span class="comment">//  doing an interlocked exchange.</span>
00296         <span class="comment">//</span>
00297 
00298         <span class="keywordflow">if</span> (CurrentValue &gt; 0) {
00299 
00300             NewValue |= <a class="code" href="../../d0/d8/ex_2handle_8c.html#a0">EXHANDLE_TABLE_ENTRY_LOCK_BIT</a>;
00301 
00302             <span class="keywordflow">if</span> ((LONG_PTR)(InterlockedCompareExchangePointer( &amp;HandleTableEntry-&gt;<a class="code" href="../../d7/d3/struct__HANDLE__TABLE__ENTRY.html#o0">Object</a>,
00303                                                              (PVOID)NewValue,
00304                                                              (PVOID)CurrentValue )) == CurrentValue) {
00305 
00306                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00307             }
00308         }
00309 
00310         <span class="comment">//</span>
00311         <span class="comment">//  Either someone already has the entry locked or the value changed</span>
00312         <span class="comment">//  somehow, either way we'll wait a bit and try again.  The first</span>
00313         <span class="comment">//  time we'll wait by spinning for 10us and if that doesn't work</span>
00314         <span class="comment">//  then we'll wait for the handle contention event to go off or</span>
00315         <span class="comment">//  for 10ms, whichever comes first.</span>
00316         <span class="comment">//</span>
00317 
00318         <span class="keywordflow">if</span> (LoopCount++ &lt; 1) {
00319 
00320             <a class="code" href="../../d2/d7/hal_8h.html#a206">KeStallExecutionProcessor</a>( 10 );
00321 
00322         } <span class="keywordflow">else</span> {
00323 
00324             <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;HandleTable-&gt;<a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html#o9">HandleContentionEvent</a>,
00325                                    <a class="code" href="../../d6/d7/halmips_8h.html#a455">Executive</a>,
00326                                    <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
00327                                    <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00328                                    &amp;<a class="code" href="../../d0/d8/ex_2handle_8c.html#a3">Ex10Milliseconds</a> );
00329         }
00330     }
00331 }
00332 
00333 
00334 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00335 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00336"></a><a class="code" href="../../d5/d8/ex_8h.html#a288">00336</a> <a class="code" href="../../d5/d8/ex_8h.html#a288">ExUnlockHandleTableEntry</a> (
00337     <a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html">PHANDLE_TABLE</a> HandleTable,
00338     <a class="code" href="../../d7/d3/struct__HANDLE__TABLE__ENTRY.html">PHANDLE_TABLE_ENTRY</a> HandleTableEntry
00339     )
00340 
00341 <span class="comment">/*++</span>
00342 <span class="comment"></span>
00343 <span class="comment">Routine Description:</span>
00344 <span class="comment"></span>
00345 <span class="comment">    This routine unlocks the specified handle table entry.  After the entry is</span>
00346 <span class="comment">    unlocked the sign bit will be clear.</span>
00347 <span class="comment"></span>
00348 <span class="comment">Arguments:</span>
00349 <span class="comment"></span>
00350 <span class="comment">    HandleTable - Supplies the handle table containing the entry being unlocked.</span>
00351 <span class="comment"></span>
00352 <span class="comment">    HandleTableEntry - Supplies the handle table entry being unlocked.</span>
00353 <span class="comment"></span>
00354 <span class="comment">Return Value:</span>
00355 <span class="comment"></span>
00356 <span class="comment">    None.</span>
00357 <span class="comment"></span>
00358 <span class="comment">--*/</span>
00359 
00360 {
00361     LONG_PTR NewValue;
00362     LONG_PTR CurrentValue;
00363 
00364     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00365 
00366     <span class="comment">//</span>
00367     <span class="comment">//  This routine does not need to loop and attempt the unlock opeation more</span>
00368     <span class="comment">//  than once because by defintion the caller has the entry already locked</span>
00369     <span class="comment">//  and no one can be changing the value without the lock.</span>
00370     <span class="comment">//</span>
00371     <span class="comment">//  So we'll read in the current value, check that the entry is really</span>
00372     <span class="comment">//  locked, clear the lock bit and make sure the compare exchange worked.</span>
00373     <span class="comment">//</span>
00374 
00375     NewValue = CurrentValue = *((<span class="keyword">volatile</span> LONG_PTR *)&amp;HandleTableEntry-&gt;<a class="code" href="../../d7/d3/struct__HANDLE__TABLE__ENTRY.html#o0">Object</a>);
00376 
00377     <span class="keywordflow">if</span> (CurrentValue &gt;= 0) {
00378 
00379         <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a>( BAD_EXHANDLE, __LINE__, (LONG_PTR)HandleTableEntry, NewValue, CurrentValue );
00380     }
00381 
00382     NewValue &amp;= ~<a class="code" href="../../d0/d8/ex_2handle_8c.html#a0">EXHANDLE_TABLE_ENTRY_LOCK_BIT</a>;
00383 
00384     <span class="keywordflow">if</span> ((LONG_PTR)(InterlockedCompareExchangePointer( &amp;HandleTableEntry-&gt;<a class="code" href="../../d7/d3/struct__HANDLE__TABLE__ENTRY.html#o0">Object</a>,
00385                                                      (PVOID)NewValue,
00386                                                      (PVOID)CurrentValue )) != CurrentValue) {
00387 
00388         <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a>( BAD_EXHANDLE, __LINE__, (LONG_PTR)HandleTableEntry, NewValue, CurrentValue );
00389     }
00390 
00391     <span class="comment">//</span>
00392     <span class="comment">//  Now that we've unlocked the event we'll see if there are any waiters</span>
00393     <span class="comment">//  for handle table entries in this table.  If there are any waiters</span>
00394     <span class="comment">//  we'll wake them up and let them try for their lock again.</span>
00395     <span class="comment">//</span>
00396     <span class="comment">//  Note that this will wake up all the waiters for all locks in a given</span>
00397     <span class="comment">//  handle table.   Each waiter also has a short time out so the worse</span>
00398     <span class="comment">//  that can happen is that we might wake someone too early.  It can also</span>
00399     <span class="comment">//  be that no one is waiting for this exact lock, or the one waiting for</span>
00400     <span class="comment">//  it has already gone off, but these are all benign.</span>
00401     <span class="comment">//</span>
00402     <span class="comment">//  **** Note that we're testing for a non empty event header wait list</span>
00403     <span class="comment">//       head.  This is sort of behind the back and a better design</span>
00404     <span class="comment">//       would get a macro from ke.h to do the test, but this will</span>
00405     <span class="comment">//       suffice for now.  This is actually an unsafe test in that it</span>
00406     <span class="comment">//       might return the wrong answer, but even then we are willing to</span>
00407     <span class="comment">//       live with it because any waiters will wake up in 10ms anyway and</span>
00408     <span class="comment">//       any extra call to pulse the event without waiters is benign.</span>
00409     <span class="comment">//</span>
00410 
00411     <span class="keywordflow">if</span> (!IsListEmpty( &amp;HandleTable-&gt;<a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html#o9">HandleContentionEvent</a>.<a class="code" href="../../d2/d6/struct__KEVENT.html#o0">Header</a>.<a class="code" href="../../d1/d6/struct__DISPATCHER__HEADER.html#o5">WaitListHead</a> )) {
00412 
00413         <a class="code" href="../../d2/d8/eventobj_8c.html#a5">KePulseEvent</a>( &amp;HandleTable-&gt;<a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html#o9">HandleContentionEvent</a>, <a class="code" href="../../d7/d8/exboosts_8h.html#a0">EVENT_INCREMENT</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00414     }
00415 
00416     <span class="keywordflow">return</span>;
00417 }
00418 
00419 
00420 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00421 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00422"></a><a class="code" href="../../d5/d8/ex_8h.html#a289">00422</a> <a class="code" href="../../d5/d8/ex_8h.html#a289">ExInitializeHandleTablePackage</a> (
00423     VOID
00424     )
00425 
00426 <span class="comment">/*++</span>
00427 <span class="comment"></span>
00428 <span class="comment">Routine Description:</span>
00429 <span class="comment"></span>
00430 <span class="comment">    This routine is called once at system initialization to setup the ex handle</span>
00431 <span class="comment">    table package</span>
00432 <span class="comment"></span>
00433 <span class="comment">Arguments:</span>
00434 <span class="comment"></span>
00435 <span class="comment">    None.</span>
00436 <span class="comment"></span>
00437 <span class="comment">Return Value:</span>
00438 <span class="comment"></span>
00439 <span class="comment">    None.</span>
00440 <span class="comment"></span>
00441 <span class="comment">--*/</span>
00442 
00443 {
00444     <span class="comment">//</span>
00445     <span class="comment">//  Initialize the handle table synchronization resource and list head</span>
00446     <span class="comment">//</span>
00447 
00448     InitializeListHead( &amp;<a class="code" href="../../d0/d8/ex_2handle_8c.html#a2">HandleTableListHead</a> );
00449     <a class="code" href="../../d5/d8/ex_8h.html#a68">ExInitializeResource</a>( &amp;<a class="code" href="../../d0/d8/ex_2handle_8c.html#a1">HandleTableListLock</a> );
00450 
00451     <span class="keywordflow">return</span>;
00452 }
00453 
00454 
00455 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00456 <a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html">PHANDLE_TABLE</a>
<a name="l00457"></a><a class="code" href="../../d5/d8/ex_8h.html#a290">00457</a> <a class="code" href="../../d5/d8/ex_8h.html#a290">ExCreateHandleTable</a> (
00458     IN <span class="keyword">struct</span> <a class="code" href="../../d0/d4/struct__EPROCESS.html">_EPROCESS</a> *Process OPTIONAL
00459     )
00460 
00461 <span class="comment">/*++</span>
00462 <span class="comment"></span>
00463 <span class="comment">Routine Description:</span>
00464 <span class="comment"></span>
00465 <span class="comment">    This function allocate and initialize a new new handle table</span>
00466 <span class="comment"></span>
00467 <span class="comment">Arguments:</span>
00468 <span class="comment"></span>
00469 <span class="comment">    Process - Supplies an optional pointer to the process against which quota</span>
00470 <span class="comment">        will be charged.</span>
00471 <span class="comment"></span>
00472 <span class="comment">Return Value:</span>
00473 <span class="comment"></span>
00474 <span class="comment">    If a handle table is successfully created, then the address of the</span>
00475 <span class="comment">    handle table is returned as the function value. Otherwize, a value</span>
00476 <span class="comment">    NULL is returned.</span>
00477 <span class="comment"></span>
00478 <span class="comment">--*/</span>
00479 
00480 {
00481     <a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html">PHANDLE_TABLE</a> HandleTable;
00482 
00483     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00484 
00485     <span class="comment">//</span>
00486     <span class="comment">//  Allocate and initialize a handle table descriptor</span>
00487     <span class="comment">//</span>
00488 
00489     HandleTable = <a class="code" href="../../d0/d8/ex_2handle_8c.html#a4">ExpAllocateHandleTable</a>( Process );
00490 
00491     <span class="comment">//</span>
00492     <span class="comment">//  And return to our caller</span>
00493     <span class="comment">//</span>
00494 
00495     <span class="keywordflow">return</span> HandleTable;
00496 }
00497 
00498 
00499 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00500 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00501"></a><a class="code" href="../../d5/d8/ex_8h.html#a291">00501</a> <a class="code" href="../../d5/d8/ex_8h.html#a291">ExRemoveHandleTable</a> (
00502     IN <a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html">PHANDLE_TABLE</a> HandleTable
00503     )
00504 
00505 <span class="comment">/*++</span>
00506 <span class="comment"></span>
00507 <span class="comment">Routine Description:</span>
00508 <span class="comment"></span>
00509 <span class="comment">    This function removes the specified exhandle table from the list of</span>
00510 <span class="comment">    exhandle tables.  Used by PS and ATOM packages to make sure their handle</span>
00511 <span class="comment">    tables are not in the list enumerated by the ExSnapShotHandleTables</span>
00512 <span class="comment">    routine and the !handle debugger extension.</span>
00513 <span class="comment"></span>
00514 <span class="comment">Arguments:</span>
00515 <span class="comment"></span>
00516 <span class="comment">    HandleTable - Supplies a pointer to a handle table</span>
00517 <span class="comment"></span>
00518 <span class="comment">Return Value:</span>
00519 <span class="comment"></span>
00520 <span class="comment">    None.</span>
00521 <span class="comment"></span>
00522 <span class="comment">--*/</span>
00523 
00524 {
00525     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00526 
00527     <span class="comment">//</span>
00528     <span class="comment">//  First, acquire the global handle table lock</span>
00529     <span class="comment">//</span>
00530 
00531     <a class="code" href="../../d4/d9/ke_8h.html#a28">KeEnterCriticalRegion</a>();
00532     <a class="code" href="../../d5/d8/ex_8h.html#a70">ExAcquireResourceExclusive</a>( &amp;<a class="code" href="../../d0/d8/ex_2handle_8c.html#a1">HandleTableListLock</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
00533 
00534     <span class="comment">//</span>
00535     <span class="comment">//  Remove the handle table from the handle table list.  This routine is</span>
00536     <span class="comment">//  written so that multiple calls to remove a handle table will not</span>
00537     <span class="comment">//  corrupt the system.</span>
00538     <span class="comment">//</span>
00539 
00540     <span class="keywordflow">if</span> (!IsListEmpty( &amp;HandleTable-&gt;HandleTableList )) {
00541 
00542         RemoveEntryList( &amp;HandleTable-&gt;HandleTableList );
00543 
00544         InitializeListHead( &amp;HandleTable-&gt;HandleTableList );
00545     }
00546 
00547     <span class="comment">//</span>
00548     <span class="comment">//  Now release the global lock and return to our caller</span>
00549     <span class="comment">//</span>
00550 
00551     <a class="code" href="../../d5/d8/ex_8h.html#a66">ExReleaseResource</a>( &amp;<a class="code" href="../../d0/d8/ex_2handle_8c.html#a1">HandleTableListLock</a> );
00552     <a class="code" href="../../d4/d9/ke_8h.html#a29">KeLeaveCriticalRegion</a>();
00553 
00554     <span class="keywordflow">return</span>;
00555 }
00556 
00557 
00558 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00559 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00560"></a><a class="code" href="../../d5/d8/ex_8h.html#a292">00560</a> <a class="code" href="../../d5/d8/ex_8h.html#a292">ExDestroyHandleTable</a> (
00561     IN <a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html">PHANDLE_TABLE</a> HandleTable,
00562     IN EX_DESTROY_HANDLE_ROUTINE DestroyHandleProcedure OPTIONAL
00563     )
00564 
00565 <span class="comment">/*++</span>
00566 <span class="comment"></span>
00567 <span class="comment">Routine Description:</span>
00568 <span class="comment"></span>
00569 <span class="comment">    This function destroys the specified handle table.</span>
00570 <span class="comment"></span>
00571 <span class="comment">Arguments:</span>
00572 <span class="comment"></span>
00573 <span class="comment">    HandleTable - Supplies a pointer to a handle table</span>
00574 <span class="comment"></span>
00575 <span class="comment">    DestroyHandleProcedure - Supplies a pointer to a function to call for each</span>
00576 <span class="comment">        valid handle entry in the handle table.</span>
00577 <span class="comment"></span>
00578 <span class="comment">Return Value:</span>
00579 <span class="comment"></span>
00580 <span class="comment">    None.</span>
00581 <span class="comment"></span>
00582 <span class="comment">--*/</span>
00583 
00584 {
00585     <a class="code" href="../../d7/d8/struct__EXHANDLE.html">EXHANDLE</a> <a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a>;
00586     <a class="code" href="../../d7/d3/struct__HANDLE__TABLE__ENTRY.html">PHANDLE_TABLE_ENTRY</a> HandleTableEntry;
00587 
00588     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00589 
00590     <span class="comment">//</span>
00591     <span class="comment">//  Remove the handle table from the handle table list</span>
00592     <span class="comment">//</span>
00593 
00594     <a class="code" href="../../d5/d8/ex_8h.html#a291">ExRemoveHandleTable</a>( HandleTable );
00595 
00596     <span class="comment">//</span>
00597     <span class="comment">//  Iterate through the handle table and for each handle that is allocated</span>
00598     <span class="comment">//  we'll invoke the call back.  Note that this loop exits when we get a</span>
00599     <span class="comment">//  null handle table entry.  We know there will be no more possible</span>
00600     <span class="comment">//  entries after the first null one is encountered because we allocate</span>
00601     <span class="comment">//  memory of the handles in a dense fashion.  But first test that we have</span>
00602     <span class="comment">//  call back to use</span>
00603     <span class="comment">//</span>
00604 
00605     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(DestroyHandleProcedure)) {
00606 
00607         <span class="keywordflow">for</span> (<a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a>.GenericHandleOverlay = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>; <span class="comment">// does essentially the following "Handle.Index = 0, Handle.TagBits = 0;"</span>
00608              (HandleTableEntry = <a class="code" href="../../d0/d8/ex_2handle_8c.html#a8">ExpLookupHandleTableEntry</a>( HandleTable, <a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a> )) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00609              <a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a>.Index += 1) {
00610 
00611             <span class="comment">//</span>
00612             <span class="comment">//  Only do the callback if the entry is not free</span>
00613             <span class="comment">//</span>
00614 
00615             <span class="keywordflow">if</span> (HandleTableEntry-&gt;<a class="code" href="../../d7/d3/struct__HANDLE__TABLE__ENTRY.html#o0">Object</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00616 
00617                 (*DestroyHandleProcedure)( <a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a>.GenericHandleOverlay );
00618             }
00619         }
00620     }
00621 
00622     <span class="comment">//</span>
00623     <span class="comment">//  Now free up the handle table memory and return to our caller</span>
00624     <span class="comment">//</span>
00625 
00626     <a class="code" href="../../d0/d8/ex_2handle_8c.html#a5">ExpFreeHandleTable</a>( HandleTable );
00627 
00628     <span class="keywordflow">return</span>;
00629 }
00630 
00631 
00632 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00633 BOOLEAN
<a name="l00634"></a><a class="code" href="../../d5/d8/ex_8h.html#a293">00634</a> <a class="code" href="../../d5/d8/ex_8h.html#a293">ExEnumHandleTable</a> (
00635     IN <a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html">PHANDLE_TABLE</a> HandleTable,
00636     IN EX_ENUMERATE_HANDLE_ROUTINE EnumHandleProcedure,
00637     IN PVOID EnumParameter,
00638     OUT PHANDLE Handle OPTIONAL
00639     )
00640 
00641 <span class="comment">/*++</span>
00642 <span class="comment"></span>
00643 <span class="comment">Routine Description:</span>
00644 <span class="comment"></span>
00645 <span class="comment">    This function enumerates all the valid handles in a handle table.</span>
00646 <span class="comment">    For each valid handle in the handle table, the specified eumeration</span>
00647 <span class="comment">    function is called. If the enumeration function returns TRUE, then</span>
00648 <span class="comment">    the enumeration is stopped, the current handle is returned to the</span>
00649 <span class="comment">    caller via the optional Handle parameter, and this function returns</span>
00650 <span class="comment">    TRUE to indicated that the enumeration stopped at a specific handle.</span>
00651 <span class="comment"></span>
00652 <span class="comment">Arguments:</span>
00653 <span class="comment"></span>
00654 <span class="comment">    HandleTable - Supplies a pointer to a handle table.</span>
00655 <span class="comment"></span>
00656 <span class="comment">    EnumHandleProcedure - Supplies a pointer to a fucntion to call for</span>
00657 <span class="comment">        each valid handle in the enumerated handle table.</span>
00658 <span class="comment"></span>
00659 <span class="comment">    EnumParameter - Supplies an uninterpreted 32-bit value that is passed</span>
00660 <span class="comment">        to the EnumHandleProcedure each time it is called.</span>
00661 <span class="comment"></span>
00662 <span class="comment">    Handle - Supplies an optional pointer a variable that receives the</span>
00663 <span class="comment">        Handle value that the enumeration stopped at. Contents of the</span>
00664 <span class="comment">        variable only valid if this function returns TRUE.</span>
00665 <span class="comment"></span>
00666 <span class="comment">Return Value:</span>
00667 <span class="comment"></span>
00668 <span class="comment">    If the enumeration stopped at a specific handle, then a value of TRUE</span>
00669 <span class="comment">    is returned. Otherwise, a value of FALSE is returned.</span>
00670 <span class="comment"></span>
00671 <span class="comment">--*/</span>
00672 
00673 {
00674     BOOLEAN ResultValue;
00675     <a class="code" href="../../d7/d8/struct__EXHANDLE.html">EXHANDLE</a> LocalHandle;
00676     <a class="code" href="../../d7/d3/struct__HANDLE__TABLE__ENTRY.html">PHANDLE_TABLE_ENTRY</a> HandleTableEntry;
00677 
00678     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00679 
00680     <span class="comment">//</span>
00681     <span class="comment">//  First lock the handle table shared to stop anyone from creating or</span>
00682     <span class="comment">//  destroying new handles.  We need to do this because out iteration</span>
00683     <span class="comment">//  function doesn't want the handles to be closed while we're doing</span>
00684     <span class="comment">//  our work</span>
00685     <span class="comment">//</span>
00686 
00687     <a class="code" href="../../d4/d9/ke_8h.html#a28">KeEnterCriticalRegion</a>();
00688     <a class="code" href="../../d5/d8/ex_8h.html#a283">ExLockHandleTableShared</a>( HandleTable );
00689 
00690     <span class="keywordflow">try</span> {
00691 
00692         <span class="comment">//</span>
00693         <span class="comment">//  Our initial return value is false until the enumeration callback</span>
00694         <span class="comment">//  function tells us otherwise</span>
00695         <span class="comment">//</span>
00696 
00697         ResultValue = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00698 
00699         <span class="comment">//</span>
00700         <span class="comment">//  Iterate through the handle table and for each handle that is</span>
00701         <span class="comment">//  allocated we'll invoke the call back.  Note that this loop exits</span>
00702         <span class="comment">//  when we get a null handle table entry.  We know there will be no</span>
00703         <span class="comment">//  more possible entries after the first null one is encountered</span>
00704         <span class="comment">//  because we allocate memory of the handles in a dense fashion</span>
00705         <span class="comment">//</span>
00706 
00707         <span class="keywordflow">for</span> (LocalHandle.<a class="code" href="../../d7/d8/struct__EXHANDLE.html#o2">GenericHandleOverlay</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>; <span class="comment">// does essentially the following "LocalHandle.Index = 0, LocalHandle.TagBits = 0;"</span>
00708              (HandleTableEntry = <a class="code" href="../../d0/d8/ex_2handle_8c.html#a8">ExpLookupHandleTableEntry</a>( HandleTable, LocalHandle )) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00709              LocalHandle.<a class="code" href="../../d7/d8/struct__EXHANDLE.html#o1">Index</a> += 1) {
00710 
00711             <span class="comment">//</span>
00712             <span class="comment">//  Only do the callback if the entry is not free</span>
00713             <span class="comment">//</span>
00714 
00715             <span class="keywordflow">if</span> (HandleTableEntry-&gt;<a class="code" href="../../d7/d3/struct__HANDLE__TABLE__ENTRY.html#o0">Object</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00716 
00717                 <span class="comment">//</span>
00718                 <span class="comment">//  Lock the handle table entry because we're about to give</span>
00719                 <span class="comment">//  it to the callback function, then release the entry</span>
00720                 <span class="comment">//  right after the call back.</span>
00721                 <span class="comment">//</span>
00722 
00723                 <span class="keywordflow">if</span> (<a class="code" href="../../d5/d8/ex_8h.html#a287">ExLockHandleTableEntry</a>( HandleTable, HandleTableEntry )) {
00724 
00725                     <span class="keywordflow">try</span> {
00726 
00727                         <span class="comment">//</span>
00728                         <span class="comment">//  Invoke the callback, and if it returns true then set</span>
00729                         <span class="comment">//  the proper output values and break out of the loop.</span>
00730                         <span class="comment">//</span>
00731 
00732                         <span class="keywordflow">if</span> ((*EnumHandleProcedure)( HandleTableEntry,
00733                                                     LocalHandle.<a class="code" href="../../d7/d8/struct__EXHANDLE.html#o2">GenericHandleOverlay</a>,
00734                                                     EnumParameter )) {
00735 
00736                             <span class="keywordflow">if</span> (ARGUMENT_PRESENT( <a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a> )) {
00737 
00738                                 *<a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a> = LocalHandle.<a class="code" href="../../d7/d8/struct__EXHANDLE.html#o2">GenericHandleOverlay</a>;
00739                             }
00740 
00741                             ResultValue = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00742                             <span class="keywordflow">break</span>;
00743                         }
00744 
00745                     } finally {
00746 
00747                         <a class="code" href="../../d5/d8/ex_8h.html#a288">ExUnlockHandleTableEntry</a>( HandleTable, HandleTableEntry );
00748                     }
00749                 }
00750             }
00751         }
00752 
00753     } finally {
00754 
00755         <a class="code" href="../../d5/d8/ex_8h.html#a285">ExUnlockHandleTableShared</a>( HandleTable );
00756         <a class="code" href="../../d4/d9/ke_8h.html#a29">KeLeaveCriticalRegion</a>();
00757     }
00758 
00759     <span class="keywordflow">return</span> ResultValue;
00760 }
00761 
00762 
00763 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00764 <a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html">PHANDLE_TABLE</a>
<a name="l00765"></a><a class="code" href="../../d5/d8/ex_8h.html#a294">00765</a> <a class="code" href="../../d5/d8/ex_8h.html#a294">ExDupHandleTable</a> (
00766     IN <span class="keyword">struct</span> <a class="code" href="../../d0/d4/struct__EPROCESS.html">_EPROCESS</a> *Process OPTIONAL,
00767     IN <a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html">PHANDLE_TABLE</a> OldHandleTable,
00768     IN EX_DUPLICATE_HANDLE_ROUTINE DupHandleProcedure OPTIONAL
00769     )
00770 
00771 <span class="comment">/*++</span>
00772 <span class="comment"></span>
00773 <span class="comment">Routine Description:</span>
00774 <span class="comment"></span>
00775 <span class="comment">    This function creates a duplicate copy of the specified handle table.</span>
00776 <span class="comment"></span>
00777 <span class="comment">Arguments:</span>
00778 <span class="comment"></span>
00779 <span class="comment">    Process - Supplies an optional to the process to charge quota to.</span>
00780 <span class="comment"></span>
00781 <span class="comment">    OldHandleTable - Supplies a pointer to a handle table.</span>
00782 <span class="comment"></span>
00783 <span class="comment">    DupHandleProcedure - Supplies an optional pointer to a function to call</span>
00784 <span class="comment">        for each valid handle in the duplicated handle table.</span>
00785 <span class="comment"></span>
00786 <span class="comment">Return Value:</span>
00787 <span class="comment"></span>
00788 <span class="comment">    If the specified handle table is successfully duplicated, then the</span>
00789 <span class="comment">    address of the new handle table is returned as the function value.</span>
00790 <span class="comment">    Otherwize, a value NULL is returned.</span>
00791 <span class="comment"></span>
00792 <span class="comment">--*/</span>
00793 
00794 {
00795     <a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html">PHANDLE_TABLE</a> NewHandleTable;
00796 
00797     <a class="code" href="../../d7/d3/struct__HANDLE__TABLE__ENTRY.html">PHANDLE_TABLE_ENTRY</a> AdditionalFreeEntries;
00798 
00799     <a class="code" href="../../d7/d8/struct__EXHANDLE.html">EXHANDLE</a> <a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a>;
00800 
00801     <a class="code" href="../../d7/d3/struct__HANDLE__TABLE__ENTRY.html">PHANDLE_TABLE_ENTRY</a> OldHandleTableEntry;
00802     <a class="code" href="../../d7/d3/struct__HANDLE__TABLE__ENTRY.html">PHANDLE_TABLE_ENTRY</a> NewHandleTableEntry;
00803 
00804     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00805 
00806     <span class="comment">//</span>
00807     <span class="comment">//  First allocate a new handle table.  If this fails then</span>
00808     <span class="comment">//  return immediately to our caller</span>
00809     <span class="comment">//</span>
00810 
00811     NewHandleTable = <a class="code" href="../../d0/d8/ex_2handle_8c.html#a4">ExpAllocateHandleTable</a>( Process );
00812 
00813     <span class="keywordflow">if</span> (NewHandleTable == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00814 
00815         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00816     }
00817 
00818     <span class="comment">//</span>
00819     <span class="comment">//  Now lock down the old handle table.  We will release it</span>
00820     <span class="comment">//  right after enumerating through the table</span>
00821     <span class="comment">//</span>
00822 
00823     <a class="code" href="../../d4/d9/ke_8h.html#a28">KeEnterCriticalRegion</a>();
00824     <a class="code" href="../../d5/d8/ex_8h.html#a283">ExLockHandleTableShared</a>( OldHandleTable );
00825 
00826     AdditionalFreeEntries = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00827 
00828     <span class="keywordflow">try</span> {
00829 
00830         <span class="comment">//</span>
00831         <span class="comment">//  Now we'll build up the new handle table. We do this by calling</span>
00832         <span class="comment">//  allocating new handle table entries, and "fooling" the worker</span>
00833         <span class="comment">//  routine to allocate keep on allocating until the next free</span>
00834         <span class="comment">//  index needing pool are equal</span>
00835         <span class="comment">//</span>
00836 
00837         <span class="keywordflow">while</span> (NewHandleTable-&gt;<a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html#o6">NextIndexNeedingPool</a> &lt; OldHandleTable-&gt;NextIndexNeedingPool) {
00838 
00839             <span class="comment">//</span>
00840             <span class="comment">//  If we set the first free table entry to -1 then the worker</span>
00841             <span class="comment">//  routine will allocate another buffer</span>
00842             <span class="comment">//</span>
00843 
00844             NewHandleTable-&gt;<a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html#o5">FirstFreeTableEntry</a> = -1;
00845 
00846             <span class="comment">//</span>
00847             <span class="comment">//  Call the worker routine to grow the new handle table.  If</span>
00848             <span class="comment">//  not successful then free the new table as far as we got,</span>
00849             <span class="comment">//  set out output variable and exit out here</span>
00850             <span class="comment">//</span>
00851 
00852             <span class="keywordflow">if</span> (<a class="code" href="../../d0/d8/ex_2handle_8c.html#a6">ExpAllocateHandleTableEntry</a>( NewHandleTable, &amp;<a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a> ) == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00853 
00854                 <a class="code" href="../../d0/d8/ex_2handle_8c.html#a5">ExpFreeHandleTable</a>( NewHandleTable );
00855 
00856                 NewHandleTable = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00857 
00858                 leave;
00859             }
00860         }
00861 
00862         <span class="comment">//</span>
00863         <span class="comment">//  Now modify the new handle table to think it has zero handles</span>
00864         <span class="comment">//  and set its free list to start on the same index as the old</span>
00865         <span class="comment">//  free list</span>
00866         <span class="comment">//</span>
00867 
00868         NewHandleTable-&gt;<a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html#o1">HandleCount</a> = 0;
00869         NewHandleTable-&gt;<a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html#o5">FirstFreeTableEntry</a> = OldHandleTable-&gt;FirstFreeTableEntry;
00870 
00871         <span class="comment">//</span>
00872         <span class="comment">//  Now for every valid index value we'll copy over the old entry into</span>
00873         <span class="comment">//  the new entry</span>
00874         <span class="comment">//</span>
00875 
00876         <span class="keywordflow">for</span> (<a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a>.GenericHandleOverlay = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>; <span class="comment">// does essentially the following "Handle.Index = 0, Handle.TagBits = 0;"</span>
00877              (OldHandleTableEntry = <a class="code" href="../../d0/d8/ex_2handle_8c.html#a8">ExpLookupHandleTableEntry</a>( OldHandleTable, <a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a> )) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00878              <a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a>.Index += 1) {
00879 
00880             <span class="comment">//</span>
00881             <span class="comment">//  The conditinal in the loop gives up the old handle table</span>
00882             <span class="comment">//  entry, by definition there must exist a corresponding new</span>
00883             <span class="comment">//  handle table entry, so now look it up</span>
00884             <span class="comment">//</span>
00885 
00886             NewHandleTableEntry = <a class="code" href="../../d0/d8/ex_2handle_8c.html#a8">ExpLookupHandleTableEntry</a>( NewHandleTable,
00887                                                              <a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a> );
00888 
00889             <span class="comment">//</span>
00890             <span class="comment">//  If the old entry is free then simply copy over the entire</span>
00891             <span class="comment">//  old entry to the new entry.  The lock command will tell us</span>
00892             <span class="comment">//  it entry is free.</span>
00893             <span class="comment">//</span>
00894 
00895             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d8/ex_8h.html#a287">ExLockHandleTableEntry</a>( OldHandleTable, OldHandleTableEntry )) {
00896 
00897                 *NewHandleTableEntry = *OldHandleTableEntry;
00898 
00899             } <span class="keywordflow">else</span> {
00900 
00901                 <span class="comment">//</span>
00902                 <span class="comment">//  Otherwise we have a non empty entry.  So now copy it</span>
00903                 <span class="comment">//  over, and unlock the old entry.  In both cases we bump</span>
00904                 <span class="comment">//  the handle count because either the entry is going into</span>
00905                 <span class="comment">//  the new table or we're going to remove it with Exp Free</span>
00906                 <span class="comment">//  Handle Table Entry which will decrement the handle count</span>
00907                 <span class="comment">//</span>
00908 
00909                 *NewHandleTableEntry = *OldHandleTableEntry;
00910                 NewHandleTable-&gt;<a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html#o1">HandleCount</a> += 1;
00911 
00912                 <a class="code" href="../../d5/d8/ex_8h.html#a288">ExUnlockHandleTableEntry</a>( OldHandleTable, OldHandleTableEntry );
00913 
00914                 <span class="comment">//</span>
00915                 <span class="comment">//  Invoke the callback and if it returns true then we</span>
00916                 <span class="comment">//  unlock the new entry</span>
00917                 <span class="comment">//</span>
00918 
00919                 <span class="keywordflow">if</span> ((*DupHandleProcedure)( Process, NewHandleTableEntry )) {
00920 
00921                     <a class="code" href="../../d5/d8/ex_8h.html#a288">ExUnlockHandleTableEntry</a>( NewHandleTable, NewHandleTableEntry );
00922 
00923                 } <span class="keywordflow">else</span> {
00924 
00925                     <span class="comment">//</span>
00926                     <span class="comment">//  Otherwise this entry is going to be freed in the</span>
00927                     <span class="comment">//  new handle table.  So add it to the stack list of</span>
00928                     <span class="comment">//  additional freed entries</span>
00929                     <span class="comment">//</span>
00930 
00931                     NewHandleTableEntry-&gt;<a class="code" href="../../d7/d3/struct__HANDLE__TABLE__ENTRY.html#o0">Object</a> = AdditionalFreeEntries;
00932                     NewHandleTableEntry-&gt;<a class="code" href="../../d7/d3/struct__HANDLE__TABLE__ENTRY.html#o5">NextFreeTableEntry</a> = <a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a>.Index;
00933 
00934                     AdditionalFreeEntries = NewHandleTableEntry;
00935                 }
00936             }
00937         }
00938 
00939     } finally {
00940 
00941         <a class="code" href="../../d5/d8/ex_8h.html#a285">ExUnlockHandleTableShared</a>( OldHandleTable );
00942         <a class="code" href="../../d4/d9/ke_8h.html#a29">KeLeaveCriticalRegion</a>();
00943     }
00944 
00945     <span class="comment">//</span>
00946     <span class="comment">//  At this point we are through with the old handle table,</span>
00947     <span class="comment">//  and if present the new handle table is done with except</span>
00948     <span class="comment">//  for adding back the newly freed entrires.  The only time</span>
00949     <span class="comment">//  the additionalFreeEntries variable will not be null is if</span>
00950     <span class="comment">//  we successfully built the new table and the dup routine</span>
00951     <span class="comment">//  came back false.</span>
00952     <span class="comment">//</span>
00953     <span class="comment">//  While there are additional entries to add to the free list</span>
00954     <span class="comment">//  pop the entry off the stack and add it to the table</span>
00955     <span class="comment">//</span>
00956 
00957     <a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a>.GenericHandleOverlay = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00958     <span class="keywordflow">while</span> (AdditionalFreeEntries != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00959 
00960         PVOID Next;
00961 
00962         Next = AdditionalFreeEntries-&gt;<a class="code" href="../../d7/d3/struct__HANDLE__TABLE__ENTRY.html#o0">Object</a>;
00963         <a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a>.Index = AdditionalFreeEntries-&gt;<a class="code" href="../../d7/d3/struct__HANDLE__TABLE__ENTRY.html#o5">NextFreeTableEntry</a>;
00964 
00965         AdditionalFreeEntries-&gt;<a class="code" href="../../d7/d3/struct__HANDLE__TABLE__ENTRY.html#o0">Object</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00966 
00967         <a class="code" href="../../d0/d8/ex_2handle_8c.html#a7">ExpFreeHandleTableEntry</a>( NewHandleTable,
00968                                  <a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a>,
00969                                  AdditionalFreeEntries );
00970 
00971         AdditionalFreeEntries = Next;
00972     }
00973 
00974     <span class="comment">//</span>
00975     <span class="comment">//  lastly return the new handle table to our caller</span>
00976     <span class="comment">//</span>
00977 
00978     <span class="keywordflow">return</span> NewHandleTable;
00979 }
00980 
00981 
00982 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00983 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00984"></a><a class="code" href="../../d5/d8/ex_8h.html#a295">00984</a> <a class="code" href="../../d5/d8/ex_8h.html#a295">ExSnapShotHandleTables</a> (
00985     IN PEX_SNAPSHOT_HANDLE_ENTRY SnapShotHandleEntry,
00986     IN OUT PSYSTEM_HANDLE_INFORMATION HandleInformation,
00987     IN ULONG Length,
00988     IN OUT PULONG RequiredLength
00989     )
00990 
00991 <span class="comment">/*++</span>
00992 <span class="comment"></span>
00993 <span class="comment">Routine Description:</span>
00994 <span class="comment"></span>
00995 <span class="comment">    This function visits and invokes the specified callback for every valid</span>
00996 <span class="comment">    handle that it can find off of the handle table.</span>
00997 <span class="comment"></span>
00998 <span class="comment">Arguments:</span>
00999 <span class="comment"></span>
01000 <span class="comment">    SnapShotHandleEntry - Supplies a pointer to a function to call for</span>
01001 <span class="comment">        each valid handle we encounter.</span>
01002 <span class="comment"></span>
01003 <span class="comment">    HandleInformation - Supplies a handle information structure to</span>
01004 <span class="comment">        be filled in for each handle table we encounter.  This routine</span>
01005 <span class="comment">        fills in the handle count, but relies on a callback to fill in</span>
01006 <span class="comment">        entry info fields.</span>
01007 <span class="comment"></span>
01008 <span class="comment">    Length - Supplies a parameter for the callback.  In reality this is</span>
01009 <span class="comment">        the total size, in bytes, of the Handle Information buffer.</span>
01010 <span class="comment"></span>
01011 <span class="comment">    RequiredLength - Supplies a parameter for the callback.  In reality</span>
01012 <span class="comment">        this is a final size in bytes used to store the requested</span>
01013 <span class="comment">        information.</span>
01014 <span class="comment"></span>
01015 <span class="comment">Return Value:</span>
01016 <span class="comment"></span>
01017 <span class="comment">    The last return status of the callback</span>
01018 <span class="comment"></span>
01019 <span class="comment">--*/</span>
01020 
01021 {
01022     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01023     PSYSTEM_HANDLE_TABLE_ENTRY_INFO HandleEntryInfo;
01024     PLIST_ENTRY NextEntry;
01025     <a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html">PHANDLE_TABLE</a> HandleTable;
01026     <a class="code" href="../../d7/d8/struct__EXHANDLE.html">EXHANDLE</a> <a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a>;
01027     <a class="code" href="../../d7/d3/struct__HANDLE__TABLE__ENTRY.html">PHANDLE_TABLE_ENTRY</a> HandleTableEntry;
01028 
01029     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01030 
01031     <span class="comment">//</span>
01032     <span class="comment">//  Lock the handle table list exclusive and traverse the list of handle</span>
01033     <span class="comment">//  tables.</span>
01034     <span class="comment">//</span>
01035 
01036     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
01037 
01038     <a class="code" href="../../d4/d9/ke_8h.html#a28">KeEnterCriticalRegion</a>();
01039     <a class="code" href="../../d5/d8/ex_8h.html#a70">ExAcquireResourceExclusive</a>( &amp;<a class="code" href="../../d0/d8/ex_2handle_8c.html#a1">HandleTableListLock</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
01040 
01041     <span class="keywordflow">try</span> {
01042 
01043         <span class="comment">//</span>
01044         <span class="comment">//  Setup the output buffer pointer that the callback will maintain</span>
01045         <span class="comment">//</span>
01046 
01047         HandleEntryInfo = &amp;HandleInformation-&gt;Handles[0];
01048 
01049         <span class="comment">//</span>
01050         <span class="comment">//  Zero out the handle count</span>
01051         <span class="comment">//</span>
01052 
01053         HandleInformation-&gt;NumberOfHandles = 0;
01054 
01055         <span class="comment">//</span>
01056         <span class="comment">//  Iterate through all the handle tables in the system.</span>
01057         <span class="comment">//</span>
01058 
01059         <span class="keywordflow">for</span> (NextEntry = <a class="code" href="../../d0/d8/ex_2handle_8c.html#a2">HandleTableListHead</a>.Flink;
01060              NextEntry != &amp;<a class="code" href="../../d0/d8/ex_2handle_8c.html#a2">HandleTableListHead</a>;
01061              NextEntry = NextEntry-&gt;Flink) {
01062 
01063             <span class="comment">//</span>
01064             <span class="comment">//  Get the address of the next handle table, lock the handle</span>
01065             <span class="comment">//  table exclusive, and scan the list of handle entries.</span>
01066             <span class="comment">//</span>
01067 
01068             HandleTable = CONTAINING_RECORD( NextEntry,
01069                                              <a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html">HANDLE_TABLE</a>,
01070                                              HandleTableList );
01071 
01072             <a class="code" href="../../d5/d8/ex_8h.html#a284">ExLockHandleTableExclusive</a>( HandleTable );
01073 
01074             <span class="keywordflow">try</span> {
01075 
01076                 <span class="comment">//  Iterate through the handle table and for each handle that</span>
01077                 <span class="comment">//  is allocated we'll invoke the call back.  Note that this</span>
01078                 <span class="comment">//  loop exits when we get a null handle table entry.  We know</span>
01079                 <span class="comment">//  there will be no more possible entries after the first null</span>
01080                 <span class="comment">//  one is encountered because we allocate memory of the</span>
01081                 <span class="comment">//  handles in a dense fashion</span>
01082                 <span class="comment">//</span>
01083 
01084                 <span class="keywordflow">for</span> (<a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a>.Index = 0, <a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a>.TagBits = 0;
01085                      (HandleTableEntry = <a class="code" href="../../d0/d8/ex_2handle_8c.html#a8">ExpLookupHandleTableEntry</a>( HandleTable, <a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a> )) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01086                      <a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a>.Index += 1) {
01087 
01088                     <span class="comment">//</span>
01089                     <span class="comment">//  Only do the callback if the entry is not free</span>
01090                     <span class="comment">//</span>
01091 
01092                     <span class="keywordflow">if</span> (HandleTableEntry-&gt;<a class="code" href="../../d7/d3/struct__HANDLE__TABLE__ENTRY.html#o0">Object</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01093 
01094                         <span class="comment">//</span>
01095                         <span class="comment">//  Increment the handle count information in the</span>
01096                         <span class="comment">//  information buffer</span>
01097                         <span class="comment">//</span>
01098 
01099                         HandleInformation-&gt;NumberOfHandles += 1;
01100 
01101                         <span class="comment">//</span>
01102                         <span class="comment">//  Lock the handle table entry because we're about to</span>
01103                         <span class="comment">//  give it to the callback function, then release the</span>
01104                         <span class="comment">//  entry right after the call back.</span>
01105                         <span class="comment">//</span>
01106 
01107                         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d8/ex_8h.html#a287">ExLockHandleTableEntry</a>( HandleTable, HandleTableEntry )) {
01108 
01109                             <span class="keywordflow">try</span> {
01110 
01111                                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = (*SnapShotHandleEntry)( &amp;HandleEntryInfo,
01112                                                                  HandleTable-&gt;<a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html#o4">UniqueProcessId</a>,
01113                                                                  HandleTableEntry,
01114                                                                  <a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a>.GenericHandleOverlay,
01115                                                                  Length,
01116                                                                  RequiredLength );
01117 
01118                             } finally {
01119 
01120                                 <a class="code" href="../../d5/d8/ex_8h.html#a288">ExUnlockHandleTableEntry</a>( HandleTable, HandleTableEntry );
01121                             }
01122                         }
01123                     }
01124                 }
01125 
01126             } finally {
01127 
01128                 <a class="code" href="../../d5/d8/ex_8h.html#a286">ExUnlockHandleTableExclusive</a>( HandleTable );
01129             }
01130         }
01131 
01132     } finally {
01133 
01134         <a class="code" href="../../d5/d8/ex_8h.html#a66">ExReleaseResource</a>( &amp;<a class="code" href="../../d0/d8/ex_2handle_8c.html#a1">HandleTableListLock</a> );
01135         <a class="code" href="../../d4/d9/ke_8h.html#a29">KeLeaveCriticalRegion</a>();
01136     }
01137 
01138     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01139 }
01140 
01141 
01142 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01143 HANDLE
<a name="l01144"></a><a class="code" href="../../d5/d8/ex_8h.html#a296">01144</a> <a class="code" href="../../d5/d8/ex_8h.html#a296">ExCreateHandle</a> (
01145     IN <a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html">PHANDLE_TABLE</a> HandleTable,
01146     IN <a class="code" href="../../d7/d3/struct__HANDLE__TABLE__ENTRY.html">PHANDLE_TABLE_ENTRY</a> HandleTableEntry
01147     )
01148 
01149 <span class="comment">/*++</span>
01150 <span class="comment"></span>
01151 <span class="comment">Routine Description:</span>
01152 <span class="comment"></span>
01153 <span class="comment">    This function creates a handle entry in the specified handle table and</span>
01154 <span class="comment">    returns a handle for the entry.</span>
01155 <span class="comment"></span>
01156 <span class="comment">Arguments:</span>
01157 <span class="comment"></span>
01158 <span class="comment">    HandleTable - Supplies a pointer to a handle table</span>
01159 <span class="comment"></span>
01160 <span class="comment">    HandleEntry - Supplies a poiner to the handle entry for which a</span>
01161 <span class="comment">        handle entry is created.</span>
01162 <span class="comment"></span>
01163 <span class="comment">Return Value:</span>
01164 <span class="comment"></span>
01165 <span class="comment">    If the handle entry is successfully created, then value of the created</span>
01166 <span class="comment">    handle is returned as the function value.  Otherwise, a value of zero is</span>
01167 <span class="comment">    returned.</span>
01168 <span class="comment"></span>
01169 <span class="comment">--*/</span>
01170 
01171 {
01172     <a class="code" href="../../d7/d8/struct__EXHANDLE.html">EXHANDLE</a> <a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a>;
01173     <a class="code" href="../../d7/d3/struct__HANDLE__TABLE__ENTRY.html">PHANDLE_TABLE_ENTRY</a> NewHandleTableEntry;
01174 
01175     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01176 
01177     <span class="comment">//</span>
01178     <span class="comment">//  Set out output variable to zero (i.e., null) before going on</span>
01179     <span class="comment">//</span>
01180 
01181     <span class="comment">//</span>
01182     <span class="comment">// Clears Handle.Index and Handle.TagBits</span>
01183     <span class="comment">//</span>
01184 
01185     <a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a>.GenericHandleOverlay = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01186 
01187     <span class="comment">//</span>
01188     <span class="comment">//  Lock the handle table for exclusive access</span>
01189     <span class="comment">//</span>
01190 
01191     <a class="code" href="../../d4/d9/ke_8h.html#a28">KeEnterCriticalRegion</a>();
01192     <a class="code" href="../../d5/d8/ex_8h.html#a284">ExLockHandleTableExclusive</a>( HandleTable );
01193 
01194     <span class="keywordflow">try</span> {
01195 
01196         <span class="comment">//</span>
01197         <span class="comment">//  Allocate a new handle table entry, and get the handle value</span>
01198         <span class="comment">//</span>
01199 
01200         NewHandleTableEntry = <a class="code" href="../../d0/d8/ex_2handle_8c.html#a6">ExpAllocateHandleTableEntry</a>( HandleTable,
01201                                                            &amp;<a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a> );
01202 
01203         <span class="comment">//</span>
01204         <span class="comment">//  If we really got a handle then copy over the template and unlock</span>
01205         <span class="comment">//  the entry</span>
01206         <span class="comment">//</span>
01207 
01208         <span class="keywordflow">if</span> (NewHandleTableEntry != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01209 
01210             *NewHandleTableEntry = *HandleTableEntry;
01211 
01212             <a class="code" href="../../d5/d8/ex_8h.html#a288">ExUnlockHandleTableEntry</a>( HandleTable, NewHandleTableEntry );
01213         }
01214 
01215     } finally {
01216 
01217         <a class="code" href="../../d5/d8/ex_8h.html#a286">ExUnlockHandleTableExclusive</a>( HandleTable );
01218         <a class="code" href="../../d4/d9/ke_8h.html#a29">KeLeaveCriticalRegion</a>();
01219     }
01220 
01221     <span class="keywordflow">return</span> <a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a>.GenericHandleOverlay;
01222 }
01223 
01224 
01225 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01226 BOOLEAN
<a name="l01227"></a><a class="code" href="../../d5/d8/ex_8h.html#a297">01227</a> <a class="code" href="../../d5/d8/ex_8h.html#a297">ExDestroyHandle</a> (
01228     IN <a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html">PHANDLE_TABLE</a> HandleTable,
01229     IN HANDLE Handle,
01230     IN <a class="code" href="../../d7/d3/struct__HANDLE__TABLE__ENTRY.html">PHANDLE_TABLE_ENTRY</a> HandleTableEntry OPTIONAL
01231     )
01232 
01233 <span class="comment">/*++</span>
01234 <span class="comment"></span>
01235 <span class="comment">Routine Description:</span>
01236 <span class="comment"></span>
01237 <span class="comment">    This function removes a handle from a handle table.</span>
01238 <span class="comment"></span>
01239 <span class="comment">Arguments:</span>
01240 <span class="comment"></span>
01241 <span class="comment">    HandleTable - Supplies a pointer to a handle table</span>
01242 <span class="comment"></span>
01243 <span class="comment">    Handle - Supplies the handle value of the entry to remove.</span>
01244 <span class="comment"></span>
01245 <span class="comment">    HandleTableEntry - Optionally supplies a pointer to the handle</span>
01246 <span class="comment">        table entry being destroyed.  If supplied the entry is</span>
01247 <span class="comment">        assume to be locked.</span>
01248 <span class="comment"></span>
01249 <span class="comment">Return Value:</span>
01250 <span class="comment"></span>
01251 <span class="comment">    If the specified handle is successfully removed, then a value of</span>
01252 <span class="comment">    TRUE is returned. Otherwise, a value of FALSE is returned.</span>
01253 <span class="comment"></span>
01254 <span class="comment">--*/</span>
01255 
01256 {
01257     <a class="code" href="../../d7/d8/struct__EXHANDLE.html">EXHANDLE</a> LocalHandle;
01258 
01259     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01260 
01261     LocalHandle.<a class="code" href="../../d7/d8/struct__EXHANDLE.html#o2">GenericHandleOverlay</a> = <a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a>;
01262 
01263     <span class="comment">//</span>
01264     <span class="comment">//  If the caller did not supply the optional handle table entry then</span>
01265     <span class="comment">//  locate the entry via the supplied handle, make sure it is real, and</span>
01266     <span class="comment">//  then lock the entry.</span>
01267     <span class="comment">//</span>
01268 
01269     <span class="keywordflow">if</span> (HandleTableEntry == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01270 
01271         HandleTableEntry = <a class="code" href="../../d0/d8/ex_2handle_8c.html#a8">ExpLookupHandleTableEntry</a>( HandleTable,
01272                                                       LocalHandle );
01273 
01274         <span class="keywordflow">if</span> (HandleTableEntry == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01275 
01276             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01277         }
01278 
01279         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d8/ex_8h.html#a287">ExLockHandleTableEntry</a>( HandleTable, HandleTableEntry )) {
01280 
01281             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01282         }
01283     }
01284 
01285     <span class="comment">//</span>
01286     <span class="comment">//  At this point we have a locked handle table entry.  Now mark it free</span>
01287     <span class="comment">//  which does the implicit unlock.  The system will not allocate it</span>
01288     <span class="comment">//  again until we add it to the free list which we will do right after</span>
01289     <span class="comment">//  we take out the lock</span>
01290     <span class="comment">//</span>
01291 
01292     HandleTableEntry-&gt;Object = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01293 
01294     <a class="code" href="../../d4/d9/ke_8h.html#a28">KeEnterCriticalRegion</a>();
01295     <a class="code" href="../../d5/d8/ex_8h.html#a284">ExLockHandleTableExclusive</a>( HandleTable );
01296 
01297     <span class="keywordflow">try</span> {
01298 
01299         <a class="code" href="../../d0/d8/ex_2handle_8c.html#a7">ExpFreeHandleTableEntry</a>( HandleTable,
01300                                  LocalHandle,
01301                                  HandleTableEntry );
01302 
01303     } finally {
01304 
01305         <a class="code" href="../../d5/d8/ex_8h.html#a286">ExUnlockHandleTableExclusive</a>( HandleTable );
01306         <a class="code" href="../../d4/d9/ke_8h.html#a29">KeLeaveCriticalRegion</a>();
01307     }
01308 
01309     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01310 }
01311 
01312 
01313 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01314 BOOLEAN
<a name="l01315"></a><a class="code" href="../../d5/d8/ex_8h.html#a298">01315</a> <a class="code" href="../../d5/d8/ex_8h.html#a298">ExChangeHandle</a> (
01316     IN <a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html">PHANDLE_TABLE</a> HandleTable,
01317     IN HANDLE Handle,
01318     IN PEX_CHANGE_HANDLE_ROUTINE ChangeRoutine,
01319     IN ULONG_PTR Parameter
01320     )
01321 
01322 <span class="comment">/*++</span>
01323 <span class="comment"></span>
01324 <span class="comment">Routine Description:</span>
01325 <span class="comment"></span>
01326 <span class="comment">    This function provides the capability to change the contents of the</span>
01327 <span class="comment">    handle entry corrsponding to the specified handle.</span>
01328 <span class="comment"></span>
01329 <span class="comment">Arguments:</span>
01330 <span class="comment"></span>
01331 <span class="comment">    HandleTable - Supplies a pointer to a handle table.</span>
01332 <span class="comment"></span>
01333 <span class="comment">    Handle - Supplies the handle for the handle entry that is changed.</span>
01334 <span class="comment"></span>
01335 <span class="comment">    ChangeRoutine - Supplies a pointer to a function that is called to</span>
01336 <span class="comment">        perform the change.</span>
01337 <span class="comment"></span>
01338 <span class="comment">    Parameter - Supplies an uninterpreted parameter that is passed to</span>
01339 <span class="comment">        the change routine.</span>
01340 <span class="comment"></span>
01341 <span class="comment">Return Value:</span>
01342 <span class="comment"></span>
01343 <span class="comment">    If the operation was successfully performed, then a value of TRUE</span>
01344 <span class="comment">    is returned. Otherwise, a value of FALSE is returned.</span>
01345 <span class="comment"></span>
01346 <span class="comment">--*/</span>
01347 
01348 {
01349     <a class="code" href="../../d7/d8/struct__EXHANDLE.html">EXHANDLE</a> LocalHandle;
01350 
01351     <a class="code" href="../../d7/d3/struct__HANDLE__TABLE__ENTRY.html">PHANDLE_TABLE_ENTRY</a> HandleTableEntry;
01352     BOOLEAN ReturnValue;
01353 
01354     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01355 
01356     LocalHandle.<a class="code" href="../../d7/d8/struct__EXHANDLE.html#o2">GenericHandleOverlay</a> = <a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a>;
01357 
01358     <span class="comment">//</span>
01359     <span class="comment">//  Translate the input handle to a handle table entry and make</span>
01360     <span class="comment">//  sure it is a valid handle.</span>
01361     <span class="comment">//</span>
01362 
01363     HandleTableEntry = <a class="code" href="../../d0/d8/ex_2handle_8c.html#a8">ExpLookupHandleTableEntry</a>( HandleTable,
01364                                                   LocalHandle );
01365 
01366     <span class="keywordflow">if</span> (HandleTableEntry == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01367 
01368         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01369     }
01370 
01371     <span class="comment">//</span>
01372     <span class="comment">//  Try and lock the handle table entry,  If this fails then that's</span>
01373     <span class="comment">//  because someone freed the handle</span>
01374     <span class="comment">//</span>
01375 
01376     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d8/ex_8h.html#a287">ExLockHandleTableEntry</a>( HandleTable, HandleTableEntry )) {
01377 
01378         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01379     }
01380 
01381     <span class="comment">//</span>
01382     <span class="comment">//  Make sure we can't get suspended and then invoke the callback</span>
01383     <span class="comment">//</span>
01384 
01385     <a class="code" href="../../d4/d9/ke_8h.html#a28">KeEnterCriticalRegion</a>();
01386 
01387     <span class="keywordflow">try</span> {
01388 
01389         ReturnValue = (*ChangeRoutine)( HandleTableEntry, Parameter );
01390 
01391     } finally {
01392 
01393         <a class="code" href="../../d5/d8/ex_8h.html#a288">ExUnlockHandleTableEntry</a>( HandleTable, HandleTableEntry );
01394         <a class="code" href="../../d4/d9/ke_8h.html#a29">KeLeaveCriticalRegion</a>();
01395     }
01396 
01397     <span class="keywordflow">return</span> ReturnValue;
01398 }
01399 
01400 
01401 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01402 <a class="code" href="../../d7/d3/struct__HANDLE__TABLE__ENTRY.html">PHANDLE_TABLE_ENTRY</a>
<a name="l01403"></a><a class="code" href="../../d5/d8/ex_8h.html#a299">01403</a> <a class="code" href="../../d5/d8/ex_8h.html#a299">ExMapHandleToPointer</a> (
01404     IN <a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html">PHANDLE_TABLE</a> HandleTable,
01405     IN HANDLE Handle
01406     )
01407 
01408 <span class="comment">/*++</span>
01409 <span class="comment"></span>
01410 <span class="comment">Routine Description:</span>
01411 <span class="comment"></span>
01412 <span class="comment">    This function maps a handle to a pointer to a handle table entry. If the</span>
01413 <span class="comment">    map operation is successful then the handle table entry is locked when</span>
01414 <span class="comment">    we return.</span>
01415 <span class="comment"></span>
01416 <span class="comment">Arguments:</span>
01417 <span class="comment"></span>
01418 <span class="comment">    HandleTable - Supplies a pointer to a handle table.</span>
01419 <span class="comment"></span>
01420 <span class="comment">    Handle - Supplies the handle to be mapped to a handle entry.</span>
01421 <span class="comment"></span>
01422 <span class="comment">Return Value:</span>
01423 <span class="comment"></span>
01424 <span class="comment">    If the handle was successfully mapped to a pointer to a handle entry,</span>
01425 <span class="comment">    then the address of the handle table entry is returned as the function</span>
01426 <span class="comment">    value with the entry locked. Otherwise, a value of NULL is returned.</span>
01427 <span class="comment"></span>
01428 <span class="comment">--*/</span>
01429 
01430 {
01431     <a class="code" href="../../d7/d8/struct__EXHANDLE.html">EXHANDLE</a> LocalHandle;
01432 
01433     <a class="code" href="../../d7/d3/struct__HANDLE__TABLE__ENTRY.html">PHANDLE_TABLE_ENTRY</a> HandleTableEntry;
01434 
01435     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01436 
01437     LocalHandle.<a class="code" href="../../d7/d8/struct__EXHANDLE.html#o2">GenericHandleOverlay</a> = <a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a>;
01438 
01439     <span class="comment">//</span>
01440     <span class="comment">//  Translate the input handle to a handle table entry and make</span>
01441     <span class="comment">//  sure it is a valid handle.</span>
01442     <span class="comment">//</span>
01443 
01444     HandleTableEntry = <a class="code" href="../../d0/d8/ex_2handle_8c.html#a8">ExpLookupHandleTableEntry</a>( HandleTable,
01445                                                   LocalHandle );
01446 
01447     <span class="keywordflow">if</span> (HandleTableEntry == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01448 
01449         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01450     }
01451 
01452     <span class="comment">//</span>
01453     <span class="comment">//  Try and lock the handle table entry,  If this fails then that's</span>
01454     <span class="comment">//  because someone freed the handle</span>
01455     <span class="comment">//</span>
01456 
01457     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d8/ex_8h.html#a287">ExLockHandleTableEntry</a>( HandleTable, HandleTableEntry )) {
01458 
01459         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01460     }
01461 
01462     <span class="comment">//</span>
01463     <span class="comment">//  Return the locked valid handle table entry</span>
01464     <span class="comment">//</span>
01465 
01466     <span class="keywordflow">return</span> HandleTableEntry;
01467 }
01468 
01469 
01470 <span class="comment">//</span>
01471 <span class="comment">//  Local Support Routine</span>
01472 <span class="comment">//</span>
01473 
01474 <a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html">PHANDLE_TABLE</a>
<a name="l01475"></a><a class="code" href="../../d0/d8/ex_2handle_8c.html#a4">01475</a> <a class="code" href="../../d0/d8/ex_2handle_8c.html#a4">ExpAllocateHandleTable</a> (
01476     IN <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> Process OPTIONAL
01477     )
01478 
01479 <span class="comment">/*++</span>
01480 <span class="comment"></span>
01481 <span class="comment">Routine Description:</span>
01482 <span class="comment"></span>
01483 <span class="comment">    This worker routine will allocate and initialize a new handle table</span>
01484 <span class="comment">    structure.  The new structure consists of the basic handle table</span>
01485 <span class="comment">    struct plus the first allocation needed to store handles.  This is</span>
01486 <span class="comment">    really one page divided up into the top level node, the first mid</span>
01487 <span class="comment">    level node, and one bottom level node.</span>
01488 <span class="comment"></span>
01489 <span class="comment">Arguments:</span>
01490 <span class="comment"></span>
01491 <span class="comment">    Process - Optionally supplies the process to charge quota for the</span>
01492 <span class="comment">        handle table</span>
01493 <span class="comment"></span>
01494 <span class="comment">Return Value:</span>
01495 <span class="comment"></span>
01496 <span class="comment">    A pointer to the new handle table or NULL if unsuccessful at getting</span>
01497 <span class="comment">    pool.</span>
01498 <span class="comment"></span>
01499 <span class="comment">--*/</span>
01500 
01501 {
01502     <a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html">PHANDLE_TABLE</a> HandleTable;
01503     BOOLEAN HandleTableQuotaCharged;
01504 
01505     PVOID HandleTableTable;
01506     BOOLEAN HandleTableTableQuotaCharged;
01507 
01508     ULONG i;
01509 
01510     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01511 
01512     HandleTable = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01513     HandleTableQuotaCharged = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01514 
01515     HandleTableTable = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01516     HandleTableTableQuotaCharged = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01517 
01518     <span class="comment">//</span>
01519     <span class="comment">//  If any alloation or quota failures happen we will catch it in the</span>
01520     <span class="comment">//  following try-except clause and cleanup after outselves before</span>
01521     <span class="comment">//  we return null</span>
01522     <span class="comment">//</span>
01523 
01524     <span class="keywordflow">try</span> {
01525 
01526         <span class="comment">//</span>
01527         <span class="comment">//  First allocate the handle table, make sure we got one, charge quota</span>
01528         <span class="comment">//  for it and then zero it out</span>
01529         <span class="comment">//</span>
01530 
01531         HandleTable = (<a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html">PHANDLE_TABLE</a>)<a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a> | <a class="code" href="../../d5/d8/ex_8h.html#a3">POOL_RAISE_IF_ALLOCATION_FAILURE</a>,
01532                                                             <span class="keyword">sizeof</span>(<a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html">HANDLE_TABLE</a>),
01533                                                             'btbO' );
01534 
01535         <span class="keywordflow">if</span> (ARGUMENT_PRESENT(Process)) {
01536 
01537             <a class="code" href="../../d0/d2/psquota_8c.html#a2">PsChargePoolQuota</a>( Process,
01538                                <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>,
01539                                <span class="keyword">sizeof</span>(<a class="code" href="../../d5/d8/ex_8h.html#a137">HANDLE_TABLE</a>));
01540 
01541             HandleTableQuotaCharged = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01542         }
01543 
01544         RtlZeroMemory( HandleTable, <span class="keyword">sizeof</span>(<a class="code" href="../../d5/d8/ex_8h.html#a137">HANDLE_TABLE</a>) );
01545 
01546         <span class="comment">//</span>
01547         <span class="comment">//  Now allocate space of the top level, one mid level and one bottom</span>
01548         <span class="comment">//  level table structure.  This will all fit on a page, maybe two.</span>
01549         <span class="comment">//</span>
01550 
01551         HandleTableTable =
01552         HandleTable-&gt;<a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html#o2">Table</a> = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a> | <a class="code" href="../../d5/d8/ex_8h.html#a3">POOL_RAISE_IF_ALLOCATION_FAILURE</a>,
01553                                                     (2 * <span class="keyword">sizeof</span>(ULONG_PTR) * 256) + (<span class="keyword">sizeof</span>(<a class="code" href="../../d7/d3/struct__HANDLE__TABLE__ENTRY.html">HANDLE_TABLE_ENTRY</a>) * 256),
01554                                                     'btbO' );
01555 
01556         <span class="keywordflow">if</span> (ARGUMENT_PRESENT(Process)) {
01557 
01558             <a class="code" href="../../d0/d2/psquota_8c.html#a2">PsChargePoolQuota</a>( Process,
01559                                <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>,
01560                                (2 * <span class="keyword">sizeof</span>(ULONG_PTR) * 256) + (<span class="keyword">sizeof</span>(<a class="code" href="../../d5/d8/ex_8h.html#a135">HANDLE_TABLE_ENTRY</a>) * 256) );
01561 
01562             HandleTableTableQuotaCharged = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01563 
01564         }
01565 
01566         RtlZeroMemory( HandleTable-&gt;<a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html#o2">Table</a>,
01567                        (2 * <span class="keyword">sizeof</span>(ULONG_PTR) * 256) + (<span class="keyword">sizeof</span>(<a class="code" href="../../d5/d8/ex_8h.html#a135">HANDLE_TABLE_ENTRY</a>) * 256) );
01568 
01569     } except (<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
01570 
01571         <span class="keywordflow">if</span> (HandleTable != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01572 
01573             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( HandleTable );
01574 
01575             <span class="keywordflow">if</span> (HandleTableQuotaCharged) {
01576 
01577                 <a class="code" href="../../d0/d2/psquota_8c.html#a3">PsReturnPoolQuota</a>( Process,
01578                                    <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>,
01579                                    <span class="keyword">sizeof</span>(<a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html">HANDLE_TABLE</a>));
01580             }
01581         }
01582 
01583         <span class="keywordflow">if</span> (HandleTableTable != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01584 
01585             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( HandleTableTable );
01586 
01587             <span class="keywordflow">if</span> (HandleTableTableQuotaCharged) {
01588 
01589                 <a class="code" href="../../d0/d2/psquota_8c.html#a3">PsReturnPoolQuota</a>( Process,
01590                                    <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>,
01591                                    (2 * <span class="keyword">sizeof</span>(ULONG_PTR) * 256) + (<span class="keyword">sizeof</span>(<a class="code" href="../../d7/d3/struct__HANDLE__TABLE__ENTRY.html">HANDLE_TABLE_ENTRY</a>) * 256) );
01592             }
01593         }
01594 
01595         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01596     }
01597 
01598     <span class="comment">//</span>
01599     <span class="comment">//  Now setup the pointers for the initial handle table tree</span>
01600     <span class="comment">//</span>
01601 
01602     HandleTable-&gt;<a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html#o2">Table</a>[0]    = (PVOID)(((PCHAR)(HandleTable-&gt;<a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html#o2">Table</a>)) + 1 * (<span class="keyword">sizeof</span>(ULONG_PTR) * 256));
01603     HandleTable-&gt;<a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html#o2">Table</a>[0][0] = (PVOID)(((PCHAR)(HandleTable-&gt;<a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html#o2">Table</a>)) + 2 * (<span class="keyword">sizeof</span>(ULONG_PTR) * 256));
01604 
01605     <span class="comment">//</span>
01606     <span class="comment">//  Now setup the free list.  We do this by chaining together the free</span>
01607     <span class="comment">//  entries such that each free entry give the next free index (i.e.,</span>
01608     <span class="comment">//  like a fat chain).  The chain is terminated with a -1.  Note that</span>
01609     <span class="comment">//  we'll skip handle zero because our callers will get that value</span>
01610     <span class="comment">//  confused with null.</span>
01611     <span class="comment">//</span>
01612 
01613     <span class="keywordflow">for</span> (i = 0; i &lt; 255; i += 1) {
01614 
01615         (HandleTable-&gt;<a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html#o2">Table</a>[0][0])[i].<a class="code" href="../../d7/d3/struct__HANDLE__TABLE__ENTRY.html#o5">NextFreeTableEntry</a> = i+1;
01616     }
01617 
01618     (HandleTable-&gt;<a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html#o2">Table</a>[0][0])[255].NextFreeTableEntry = -1;
01619 
01620     HandleTable-&gt;<a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html#o5">FirstFreeTableEntry</a> = 1;
01621     HandleTable-&gt;<a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html#o6">NextIndexNeedingPool</a> = 256;
01622 
01623     <span class="comment">//</span>
01624     <span class="comment">//  Setup the necessary process information</span>
01625     <span class="comment">//</span>
01626 
01627     HandleTable-&gt;<a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html#o3">QuotaProcess</a> = Process;
01628     HandleTable-&gt;<a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html#o4">UniqueProcessId</a> = <a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a>()-&gt;UniqueProcessId;
01629 
01630     <span class="comment">//</span>
01631     <span class="comment">//  Initialize the lock handle table resource</span>
01632     <span class="comment">//</span>
01633 
01634     <a class="code" href="../../d5/d8/ex_8h.html#a68">ExInitializeResource</a>( &amp;HandleTable-&gt;<a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html#o7">HandleTableLock</a> );
01635 
01636     <span class="comment">//</span>
01637     <span class="comment">//  Initialize the notification event for handle table entry contention</span>
01638     <span class="comment">//</span>
01639 
01640     <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( &amp;HandleTable-&gt;<a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html#o9">HandleContentionEvent</a>, NotificationEvent, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
01641 
01642     <span class="comment">//</span>
01643     <span class="comment">//  Insert the handle table in the handle table list.</span>
01644     <span class="comment">//</span>
01645 
01646     <a class="code" href="../../d4/d9/ke_8h.html#a28">KeEnterCriticalRegion</a>();
01647     <a class="code" href="../../d5/d8/ex_8h.html#a70">ExAcquireResourceExclusive</a>( &amp;<a class="code" href="../../d0/d8/ex_2handle_8c.html#a1">HandleTableListLock</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
01648 
01649     InsertTailList( &amp;<a class="code" href="../../d0/d8/ex_2handle_8c.html#a2">HandleTableListHead</a>, &amp;HandleTable-&gt;<a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html#o8">HandleTableList</a> );
01650 
01651     <a class="code" href="../../d5/d8/ex_8h.html#a66">ExReleaseResource</a>( &amp;<a class="code" href="../../d0/d8/ex_2handle_8c.html#a1">HandleTableListLock</a> );
01652     <a class="code" href="../../d4/d9/ke_8h.html#a29">KeLeaveCriticalRegion</a>();
01653 
01654     <span class="comment">//</span>
01655     <span class="comment">//  And return to our caller</span>
01656     <span class="comment">//</span>
01657 
01658     <span class="keywordflow">return</span> HandleTable;
01659 }
01660 
01661 
01662 <span class="comment">//</span>
01663 <span class="comment">//  Local Support Routine</span>
01664 <span class="comment">//</span>
01665 
01666 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01667"></a><a class="code" href="../../d0/d8/ex_2handle_8c.html#a5">01667</a> <a class="code" href="../../d0/d8/ex_2handle_8c.html#a5">ExpFreeHandleTable</a> (
01668     IN <a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html">PHANDLE_TABLE</a> HandleTable
01669     )
01670 
01671 <span class="comment">/*++</span>
01672 <span class="comment"></span>
01673 <span class="comment">Routine Description:</span>
01674 <span class="comment"></span>
01675 <span class="comment">    This worker routine tearsdown and frees the specified handle table.</span>
01676 <span class="comment"></span>
01677 <span class="comment">Arguments:</span>
01678 <span class="comment"></span>
01679 <span class="comment">    HandleTable - Supplies the handle table being freed</span>
01680 <span class="comment"></span>
01681 <span class="comment">Return Value:</span>
01682 <span class="comment"></span>
01683 <span class="comment">    None.</span>
01684 <span class="comment"></span>
01685 <span class="comment">--*/</span>
01686 
01687 {
01688     <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> Process;
01689     ULONG i,j;
01690 
01691     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01692 
01693     Process = HandleTable-&gt;QuotaProcess;
01694 
01695     <span class="comment">//</span>
01696     <span class="comment">//  First free the lock for the local handle table</span>
01697     <span class="comment">//</span>
01698 
01699     <a class="code" href="../../d5/d8/ex_8h.html#a73">ExDeleteResource</a>( &amp;HandleTable-&gt;HandleTableLock );
01700 
01701     <span class="comment">//</span>
01702     <span class="comment">//  We first return all of the additional exhandle table entry buffers</span>
01703     <span class="comment">//  that we allocated.  Note that each pool buffer we allocated is for</span>
01704     <span class="comment">//  two subindex buffers in the table, and note also that we have to</span>
01705     <span class="comment">//  start a little funny to compensate for the first that really contains</span>
01706     <span class="comment">//  the top level and first mid level, and first entry buffer</span>
01707     <span class="comment">//</span>
01708     <span class="comment">//  Take care of the special case where the [0][0] index is really</span>
01709     <span class="comment">//  allocated up front, and we only need to examine [0][1] to see if</span>
01710     <span class="comment">//  anything special needs to be deallocated, followed by [0][3], [0][5],</span>
01711     <span class="comment">//  up to and including [0][255]</span>
01712     <span class="comment">//</span>
01713 
01714     <span class="keywordflow">for</span> (j = 1; j &lt; 256; j += 2) {
01715 
01716         <span class="keywordflow">if</span> (HandleTable-&gt;Table[0][j] == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01717 
01718             <span class="keywordflow">break</span>;
01719         }
01720 
01721         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( HandleTable-&gt;Table[0][j] );
01722 
01723         <span class="keywordflow">if</span> (Process != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01724 
01725             <a class="code" href="../../d0/d2/psquota_8c.html#a3">PsReturnPoolQuota</a>( Process,
01726                                <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>,
01727                                2 * <span class="keyword">sizeof</span>(<a class="code" href="../../d7/d3/struct__HANDLE__TABLE__ENTRY.html">HANDLE_TABLE_ENTRY</a>) * 256 );
01728         }
01729     }
01730 
01731     <span class="comment">//</span>
01732     <span class="comment">//  Now that we've handle the special case we can do the rest of the table</span>
01733     <span class="comment">//  starting with index [1][0], [1][2], ... [1][254], [2][0], [2][2] ...</span>
01734     <span class="comment">//  up to and including [255][254]</span>
01735     <span class="comment">//</span>
01736 
01737     <span class="keywordflow">for</span> (i = 1; i &lt; 256; i += 1) {
01738 
01739         <span class="keywordflow">if</span> (HandleTable-&gt;Table[i] == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01740 
01741             <span class="keywordflow">break</span>;
01742         }
01743 
01744         <span class="keywordflow">for</span> (j = 0; j &lt; 256; j += 2) {
01745 
01746             <span class="keywordflow">if</span> (HandleTable-&gt;Table[i][j] == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01747 
01748                 <span class="keywordflow">break</span>;
01749             }
01750 
01751             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( HandleTable-&gt;Table[i][j] );
01752 
01753             <span class="keywordflow">if</span> (Process != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01754 
01755                 <a class="code" href="../../d0/d2/psquota_8c.html#a3">PsReturnPoolQuota</a>( Process,
01756                                    <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>,
01757                                    2 * <span class="keyword">sizeof</span>(<a class="code" href="../../d7/d3/struct__HANDLE__TABLE__ENTRY.html">HANDLE_TABLE_ENTRY</a>) * 256 );
01758             }
01759         }
01760     }
01761 
01762     <span class="comment">//</span>
01763     <span class="comment">//  Now that we've deallocated the handle table entry buffer we can</span>
01764     <span class="comment">//  deallocate the additional mid level buffers.  Note that that these</span>
01765     <span class="comment">//  start at index [0][1] and were allocated four a time from pool.</span>
01766     <span class="comment">//</span>
01767 
01768     <span class="keywordflow">for</span> (i = 1; i &lt; 256; i += 4) {
01769 
01770         <span class="keywordflow">if</span> (HandleTable-&gt;Table[i] == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01771 
01772             <span class="keywordflow">break</span>;
01773         }
01774 
01775         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( HandleTable-&gt;Table[i] );
01776 
01777         <span class="keywordflow">if</span> (Process != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01778 
01779             <a class="code" href="../../d0/d2/psquota_8c.html#a3">PsReturnPoolQuota</a>( Process,
01780                                <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>,
01781                                4 * <span class="keyword">sizeof</span>(ULONG_PTR) * 256 );
01782         }
01783     }
01784 
01785     <span class="comment">//</span>
01786     <span class="comment">//  Now deallocate the original handle table buffer used to store</span>
01787     <span class="comment">//  the top level, first mid level, and first table entry buffer</span>
01788     <span class="comment">//</span>
01789 
01790     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( HandleTable-&gt;Table );
01791 
01792     <span class="keywordflow">if</span> (Process != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01793 
01794         <a class="code" href="../../d0/d2/psquota_8c.html#a3">PsReturnPoolQuota</a>( Process,
01795                            <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>,
01796                            (2 * <span class="keyword">sizeof</span>(ULONG_PTR) * 256) + (<span class="keyword">sizeof</span>(<a class="code" href="../../d7/d3/struct__HANDLE__TABLE__ENTRY.html">HANDLE_TABLE_ENTRY</a>) * 256) );
01797     }
01798 
01799     <span class="comment">//</span>
01800     <span class="comment">//  Finally deallocate the handle table itself</span>
01801     <span class="comment">//</span>
01802 
01803     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( HandleTable );
01804 
01805     <span class="keywordflow">if</span> (Process != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01806 
01807         <a class="code" href="../../d0/d2/psquota_8c.html#a3">PsReturnPoolQuota</a>( Process,
01808                            <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>,
01809                            <span class="keyword">sizeof</span>(<a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html">HANDLE_TABLE</a>) );
01810     }
01811 
01812     <span class="comment">//</span>
01813     <span class="comment">//  And return to our caller</span>
01814     <span class="comment">//</span>
01815 
01816     <span class="keywordflow">return</span>;
01817 }
01818 
01819 
01820 <span class="comment">//</span>
01821 <span class="comment">//  Local Support Routine</span>
01822 <span class="comment">//</span>
01823 
01824 <a class="code" href="../../d7/d3/struct__HANDLE__TABLE__ENTRY.html">PHANDLE_TABLE_ENTRY</a>
<a name="l01825"></a><a class="code" href="../../d0/d8/ex_2handle_8c.html#a6">01825</a> <a class="code" href="../../d0/d8/ex_2handle_8c.html#a6">ExpAllocateHandleTableEntry</a> (
01826     IN <a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html">PHANDLE_TABLE</a> HandleTable,
01827     OUT <a class="code" href="../../d7/d8/struct__EXHANDLE.html">PEXHANDLE</a> Handle
01828     )
01829 
01830 <span class="comment">/*++</span>
01831 <span class="comment"></span>
01832 <span class="comment">Routine Description:</span>
01833 <span class="comment"></span>
01834 <span class="comment">    This worker routine allocates a new handle table entry for the specified</span>
01835 <span class="comment">    handle table.</span>
01836 <span class="comment"></span>
01837 <span class="comment">    Note: The caller must have already locked the handle table</span>
01838 <span class="comment"></span>
01839 <span class="comment">Arguments:</span>
01840 <span class="comment"></span>
01841 <span class="comment">    HandleTable - Supplies the handle table being used</span>
01842 <span class="comment"></span>
01843 <span class="comment">    Handle - Returns the handle of the new entry if the allocation is</span>
01844 <span class="comment">        successful otherwise the value is null</span>
01845 <span class="comment"></span>
01846 <span class="comment">Return Value:</span>
01847 <span class="comment"></span>
01848 <span class="comment">    Returns a pointer to the new handle table entry is the allocation is</span>
01849 <span class="comment">        successful otherwise the return value is null.</span>
01850 <span class="comment"></span>
01851 <span class="comment">--*/</span>
01852 
01853 {
01854     ULONG i,j,k;
01855 
01856     PUCHAR NewMidLevel;
01857     BOOLEAN MidTableQuotaCharged;
01858 
01859     PUCHAR NewLowLevel;
01860     BOOLEAN LowTableQuotaCharged;
01861 
01862     <a class="code" href="../../d7/d3/struct__HANDLE__TABLE__ENTRY.html">PHANDLE_TABLE_ENTRY</a> HandleTableEntry;
01863 
01864     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01865 
01866     <a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a>-&gt;GenericHandleOverlay = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01867 
01868     <span class="comment">//</span>
01869     <span class="comment">//  First see if the free stack is emtpy and if so then we need</span>
01870     <span class="comment">//  to add some more entries to it</span>
01871     <span class="comment">//</span>
01872 
01873     <span class="keywordflow">if</span> (HandleTable-&gt;FirstFreeTableEntry == -1) {
01874 
01875         <span class="comment">//</span>
01876         <span class="comment">//  We need to allocate some more pool.  We start by seeing</span>
01877         <span class="comment">//  if the next index is too large to allocate.  We only have</span>
01878         <span class="comment">//  24 bits of handle values to use</span>
01879         <span class="comment">//</span>
01880 
01881         <span class="keywordflow">if</span> (HandleTable-&gt;NextIndexNeedingPool &gt;= (1 &lt;&lt; 24)) {
01882 
01883             <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01884         }
01885 
01886         <span class="comment">//  Now find the next index to allocate a buffer for</span>
01887         <span class="comment">//</span>
01888 
01889         i = (HandleTable-&gt;NextIndexNeedingPool &gt;&gt; 16) &amp; 255;
01890         j = (HandleTable-&gt;NextIndexNeedingPool &gt;&gt; 8)  &amp; 255;
01891 
01892         <span class="comment">//</span>
01893         <span class="comment">//  Within the following try body we'll be allocating and initializing</span>
01894         <span class="comment">//  a low level buffer and possibly a new mid level buffer.  The</span>
01895         <span class="comment">//  might seem a little odd but is necessary to handle the situation</span>
01896         <span class="comment">//  where our first buffer is allocated off a little bit (i.e., the</span>
01897         <span class="comment">//  next buffer index starts are [0][1]).  By the time we reach</span>
01898         <span class="comment">//  [0][255] we add only one new buffer.  Then start with even numbers</span>
01899         <span class="comment">//  at [1][0] and work our way to completion</span>
01900         <span class="comment">//</span>
01901 
01902         NewMidLevel = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01903         MidTableQuotaCharged = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01904 
01905         NewLowLevel = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01906         LowTableQuotaCharged = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01907 
01908         <span class="keywordflow">try</span> {
01909 
01910             <span class="comment">//</span>
01911             <span class="comment">//  Check if we need to allocate a new mid level buffer,  We do</span>
01912             <span class="comment">//  these allocations four at a time</span>
01913             <span class="comment">//</span>
01914 
01915             <span class="keywordflow">if</span> (HandleTable-&gt;Table[i] == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01916 
01917                 NewMidLevel = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a> | <a class="code" href="../../d5/d8/ex_8h.html#a3">POOL_RAISE_IF_ALLOCATION_FAILURE</a>,
01918                                                      4 * <span class="keyword">sizeof</span>(ULONG_PTR) * 256,
01919                                                      'btbO' );
01920 
01921                 RtlZeroMemory( NewMidLevel, 4 * <span class="keyword">sizeof</span>(ULONG_PTR) * 256 );
01922 
01923                 <span class="keywordflow">if</span> (HandleTable-&gt;QuotaProcess != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01924 
01925                     <a class="code" href="../../d0/d2/psquota_8c.html#a2">PsChargePoolQuota</a>( HandleTable-&gt;QuotaProcess,
01926                                        <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>,
01927                                        (4 * <span class="keyword">sizeof</span>(ULONG_PTR) * 256) );
01928 
01929                     MidTableQuotaCharged = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01930                 }
01931             }
01932 
01933             <span class="comment">//</span>
01934             <span class="comment">//  Now Allocate two new table entry buffers</span>
01935             <span class="comment">//</span>
01936 
01937             NewLowLevel = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a> | <a class="code" href="../../d5/d8/ex_8h.html#a3">POOL_RAISE_IF_ALLOCATION_FAILURE</a>,
01938                                                  2 * <span class="keyword">sizeof</span>(<a class="code" href="../../d7/d3/struct__HANDLE__TABLE__ENTRY.html">HANDLE_TABLE_ENTRY</a>) * 256,
01939                                                  'btbO' );
01940 
01941             RtlZeroMemory( NewLowLevel, 2 * <span class="keyword">sizeof</span>(<a class="code" href="../../d5/d8/ex_8h.html#a135">HANDLE_TABLE_ENTRY</a>) * 256 );
01942 
01943             <span class="keywordflow">if</span> (HandleTable-&gt;QuotaProcess != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01944 
01945                 <a class="code" href="../../d0/d2/psquota_8c.html#a2">PsChargePoolQuota</a>( HandleTable-&gt;QuotaProcess,
01946                                    <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>,
01947                                    (2 * <span class="keyword">sizeof</span>(<a class="code" href="../../d5/d8/ex_8h.html#a135">HANDLE_TABLE_ENTRY</a>) * 256) );
01948 
01949                 LowTableQuotaCharged = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01950             }
01951 
01952             <span class="comment">//</span>
01953             <span class="comment">//  Now to guard against reordering of code we need to do</span>
01954             <span class="comment">//  something to ensure that the last zero memory really has</span>
01955             <span class="comment">//  happened before setting up the rest of our work.  An</span>
01956             <span class="comment">//  interlocked exchance will do the trick.</span>
01957             <span class="comment">//</span>
01958 
01959             InterlockedExchangePointer( (PVOID *) NewLowLevel, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
01960 
01961             <span class="comment">//</span>
01962             <span class="comment">//  Now if we've allocated a new mid level buffer we need to</span>
01963             <span class="comment">//  update the pointers from our handle table.  The if's are</span>
01964             <span class="comment">//  needed when we get near the end of the table</span>
01965             <span class="comment">//</span>
01966 
01967             <span class="keywordflow">if</span> (NewMidLevel != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01968 
01969                 <span class="keywordflow">if</span> (i+0 &lt; 256) { HandleTable-&gt;Table[i+0] = (PVOID)(NewMidLevel + 0 * <span class="keyword">sizeof</span>(ULONG_PTR) * 256); }
01970                 <span class="keywordflow">if</span> (i+1 &lt; 256) { HandleTable-&gt;Table[i+1] = (PVOID)(NewMidLevel + 1 * <span class="keyword">sizeof</span>(ULONG_PTR) * 256); }
01971                 <span class="keywordflow">if</span> (i+2 &lt; 256) { HandleTable-&gt;Table[i+2] = (PVOID)(NewMidLevel + 2 * <span class="keyword">sizeof</span>(ULONG_PTR) * 256); }
01972                 <span class="keywordflow">if</span> (i+3 &lt; 256) { HandleTable-&gt;Table[i+3] = (PVOID)(NewMidLevel + 3 * <span class="keyword">sizeof</span>(ULONG_PTR) * 256); }
01973             }
01974 
01975             <span class="comment">//</span>
01976             <span class="comment">//  Now fix up the low level buffers.  We are actually guaranteed</span>
01977             <span class="comment">//  that the first buffer will fit, because j starts out from a</span>
01978             <span class="comment">//  byte.</span>
01979             <span class="comment">//</span>
01980 
01981                            { HandleTable-&gt;Table[i][j+0] = (PVOID)(NewLowLevel + 0 * <span class="keyword">sizeof</span>(<a class="code" href="../../d5/d8/ex_8h.html#a135">HANDLE_TABLE_ENTRY</a>) * 256); }
01982             <span class="keywordflow">if</span> (j+1 &lt; 256) { HandleTable-&gt;Table[i][j+1] = (PVOID)(NewLowLevel + 1 * <span class="keyword">sizeof</span>(<a class="code" href="../../d5/d8/ex_8h.html#a135">HANDLE_TABLE_ENTRY</a>) * 256); }
01983 
01984             <span class="comment">//</span>
01985             <span class="comment">//  Now add the new entries to the free list.  To do this we</span>
01986             <span class="comment">//  chain the new free entries together.  We are guaranteed to</span>
01987             <span class="comment">//  have at least one new buffer.  The second buffer we need</span>
01988             <span class="comment">//  to check for.</span>
01989             <span class="comment">//</span>
01990             <span class="comment">//  Start by starting our stack top</span>
01991             <span class="comment">//</span>
01992 
01993             HandleTable-&gt;FirstFreeTableEntry = HandleTable-&gt;NextIndexNeedingPool;
01994 
01995             <span class="comment">//</span>
01996             <span class="comment">//  Do the guaranteed first buffer</span>
01997             <span class="comment">//</span>
01998 
01999             <span class="keywordflow">for</span> (k = 0; k &lt; 256; k += 1) {
02000 
02001                 HandleTable-&gt;Table[i][j+0][k].NextFreeTableEntry = HandleTable-&gt;NextIndexNeedingPool + k + 1;
02002             }
02003 
02004             <span class="comment">//</span>
02005             <span class="comment">//  Check if there is a second buffer</span>
02006             <span class="comment">//</span>
02007 
02008             <span class="keywordflow">if</span> ((j+1 &lt; 256) &amp;&amp; (HandleTable-&gt;Table[i][j+1] != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
02009 
02010                 <span class="comment">//</span>
02011                 <span class="comment">//  Do the second buffer</span>
02012                 <span class="comment">//</span>
02013 
02014                 <span class="keywordflow">for</span> (k = 0; k &lt; 255; k += 1) {
02015 
02016                     HandleTable-&gt;Table[i][j+1][k].NextFreeTableEntry = HandleTable-&gt;NextIndexNeedingPool + k + 1 + 256;
02017                 }
02018 
02019                 <span class="comment">//</span>
02020                 <span class="comment">//  Fixup the last entry and update the next index needing</span>
02021                 <span class="comment">//  pool.</span>
02022                 <span class="comment">//</span>
02023 
02024                 HandleTable-&gt;Table[i][j+1][255].NextFreeTableEntry = -1;
02025 
02026                 HandleTable-&gt;NextIndexNeedingPool += 512;
02027 
02028             } <span class="keywordflow">else</span> {
02029 
02030                 <span class="comment">//</span>
02031                 <span class="comment">//  Fixup the last entry and update the next index needing</span>
02032                 <span class="comment">//  pool.</span>
02033                 <span class="comment">//</span>
02034 
02035                 HandleTable-&gt;Table[i][j+0][255].NextFreeTableEntry = -1;
02036 
02037                 HandleTable-&gt;NextIndexNeedingPool += 256;
02038             }
02039 
02040         } except (<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
02041 
02042             <span class="comment">//</span>
02043             <span class="comment">//  We only execute this exception handler if the pool allocation</span>
02044             <span class="comment">//  raises or if the quota request fails.  In these cases we need</span>
02045             <span class="comment">//  to cleanup after ourselves and return null to our caller</span>
02046             <span class="comment">//</span>
02047 
02048             <span class="keywordflow">if</span> (NewMidLevel != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02049 
02050                 <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( NewMidLevel );
02051 
02052                 <span class="keywordflow">if</span> (MidTableQuotaCharged) {
02053 
02054                     <a class="code" href="../../d0/d2/psquota_8c.html#a3">PsReturnPoolQuota</a>( HandleTable-&gt;QuotaProcess,
02055                                        <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>,
02056                                        (4 * <span class="keyword">sizeof</span>(ULONG_PTR) * 256) );
02057                 }
02058             }
02059 
02060             <span class="keywordflow">if</span> (NewLowLevel != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02061 
02062                 <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( NewLowLevel );
02063 
02064                 <span class="keywordflow">if</span> (LowTableQuotaCharged) {
02065 
02066                     <a class="code" href="../../d0/d2/psquota_8c.html#a3">PsReturnPoolQuota</a>( HandleTable-&gt;QuotaProcess,
02067                                        <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>,
02068                                        (2 * <span class="keyword">sizeof</span>(<a class="code" href="../../d7/d3/struct__HANDLE__TABLE__ENTRY.html">HANDLE_TABLE_ENTRY</a>) * 256) );
02069                 }
02070             }
02071 
02072             <a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a>-&gt;Index = 0;
02073 
02074             <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02075         }
02076     }
02077 
02078     <span class="comment">//</span>
02079     <span class="comment">//  At this point the free stack has some elements in it.  So we</span>
02080     <span class="comment">//  only need to pop off the first entry.</span>
02081     <span class="comment">//</span>
02082     <span class="comment">//  Get the top of the stack, both the index and table entry</span>
02083     <span class="comment">//</span>
02084 
02085     <a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a>-&gt;Index = HandleTable-&gt;FirstFreeTableEntry;
02086 
02087     HandleTableEntry = <a class="code" href="../../d0/d8/ex_2handle_8c.html#a8">ExpLookupHandleTableEntry</a>( HandleTable,
02088                                                   *<a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a> );
02089 
02090     <span class="comment">//</span>
02091     <span class="comment">//  Do the pop</span>
02092     <span class="comment">//</span>
02093 
02094     HandleTable-&gt;FirstFreeTableEntry = HandleTableEntry-&gt;<a class="code" href="../../d7/d3/struct__HANDLE__TABLE__ENTRY.html#o5">NextFreeTableEntry</a>;
02095 
02096     <span class="comment">//</span>
02097     <span class="comment">//  Zero out the new table entry</span>
02098     <span class="comment">//</span>
02099 
02100     RtlZeroMemory( HandleTableEntry, <span class="keyword">sizeof</span>(<a class="code" href="../../d7/d3/struct__HANDLE__TABLE__ENTRY.html">HANDLE_TABLE_ENTRY</a> ));
02101 
02102     <span class="comment">//</span>
02103     <span class="comment">//  Update our bookkeeping counters and return the entry to our</span>
02104     <span class="comment">//  caller</span>
02105     <span class="comment">//</span>
02106 
02107     HandleTable-&gt;HandleCount += 1;
02108 
02109     <span class="keywordflow">return</span> HandleTableEntry;
02110 }
02111 
02112 
02113 <span class="comment">//</span>
02114 <span class="comment">//  Local Support Routine</span>
02115 <span class="comment">//</span>
02116 
02117 <span class="comment">//</span>
02118 <span class="comment">//  The following is a global variable only present in the checked builds</span>
02119 <span class="comment">//  to help catch apps that reuse handles values after they're closed.</span>
02120 <span class="comment">//</span>
02121 
02122 <span class="preprocessor">#if DBG</span>
02123 <span class="preprocessor"></span>BOOLEAN ExReuseHandles = 1;
02124 <span class="preprocessor">#endif //DBG</span>
02125 <span class="preprocessor"></span>
02126 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l02127"></a><a class="code" href="../../d0/d8/ex_2handle_8c.html#a7">02127</a> <a class="code" href="../../d0/d8/ex_2handle_8c.html#a7">ExpFreeHandleTableEntry</a> (
02128     IN <a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html">PHANDLE_TABLE</a> HandleTable,
02129     IN <a class="code" href="../../d7/d8/struct__EXHANDLE.html">EXHANDLE</a> Handle,
02130     IN <a class="code" href="../../d7/d3/struct__HANDLE__TABLE__ENTRY.html">PHANDLE_TABLE_ENTRY</a> HandleTableEntry
02131     IN
02132     )
02133 
02134 <span class="comment">/*++</span>
02135 <span class="comment"></span>
02136 <span class="comment">Routine Description:</span>
02137 <span class="comment"></span>
02138 <span class="comment">    This worker routine returns the specified handle table entry to the free</span>
02139 <span class="comment">    list for the handle table.</span>
02140 <span class="comment"></span>
02141 <span class="comment">    Note: The caller must have already locked the handle table</span>
02142 <span class="comment"></span>
02143 <span class="comment">Arguments:</span>
02144 <span class="comment"></span>
02145 <span class="comment">    HandleTable - Supplies the parent handle table being modified</span>
02146 <span class="comment"></span>
02147 <span class="comment">    Handle - Supplies the handle of the entry being freed</span>
02148 <span class="comment"></span>
02149 <span class="comment">    HandleTableEntry - Supplies the table entry being freed</span>
02150 <span class="comment"></span>
02151 <span class="comment">Return Value:</span>
02152 <span class="comment"></span>
02153 <span class="comment">    None.</span>
02154 <span class="comment"></span>
02155 <span class="comment">--*/</span>
02156 
02157 {
02158     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
02159 
02160     <span class="comment">//</span>
02161     <span class="comment">//  A free is simply a push onto the free table entry stack, or in the</span>
02162     <span class="comment">//  debug case we'll sometimes just float the entry to catch apps who</span>
02163     <span class="comment">//  reuse a recycled handle value.</span>
02164     <span class="comment">//</span>
02165 
02166 <span class="preprocessor">#if DBG</span>
02167 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (ExReuseHandles) {
02168 <span class="preprocessor">#endif //DBG</span>
02169 <span class="preprocessor"></span>
02170         HandleTableEntry-&gt;NextFreeTableEntry = HandleTable-&gt;FirstFreeTableEntry;
02171         HandleTable-&gt;FirstFreeTableEntry = <a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a>.Index;
02172 
02173 <span class="preprocessor">#if DBG</span>
02174 <span class="preprocessor"></span>    } <span class="keywordflow">else</span> {
02175 
02176         HandleTableEntry-&gt;NextFreeTableEntry = 0;
02177     }
02178 <span class="preprocessor">#endif //DBG</span>
02179 <span class="preprocessor"></span>
02180     <span class="comment">//</span>
02181     <span class="comment">//  And then update our handle count before returning to our caller</span>
02182     <span class="comment">//</span>
02183 
02184     HandleTable-&gt;HandleCount -= 1;
02185 
02186     <span class="keywordflow">return</span>;
02187 }
02188 
02189 
02190 <span class="comment">//</span>
02191 <span class="comment">//  Local Support Routine</span>
02192 <span class="comment">//</span>
02193 
02194 <a class="code" href="../../d7/d3/struct__HANDLE__TABLE__ENTRY.html">PHANDLE_TABLE_ENTRY</a>
<a name="l02195"></a><a class="code" href="../../d0/d8/ex_2handle_8c.html#a8">02195</a> <a class="code" href="../../d0/d8/ex_2handle_8c.html#a8">ExpLookupHandleTableEntry</a> (
02196     IN <a class="code" href="../../d6/d3/struct__HANDLE__TABLE.html">PHANDLE_TABLE</a> HandleTable,
02197     IN <a class="code" href="../../d7/d8/struct__EXHANDLE.html">EXHANDLE</a> Handle
02198     )
02199 
02200 <span class="comment">/*++</span>
02201 <span class="comment"></span>
02202 <span class="comment">Routine Description:</span>
02203 <span class="comment"></span>
02204 <span class="comment">    This routine looks up and returns the table entry for the</span>
02205 <span class="comment">    specified handle value.</span>
02206 <span class="comment"></span>
02207 <span class="comment">Arguments:</span>
02208 <span class="comment"></span>
02209 <span class="comment">    HandleTable - Supplies the handle table being queried</span>
02210 <span class="comment"></span>
02211 <span class="comment">    Handle - Supplies the handle value being queried</span>
02212 <span class="comment"></span>
02213 <span class="comment">Return Value:</span>
02214 <span class="comment"></span>
02215 <span class="comment">    Returns a pointer to the corresponding table entry for the input</span>
02216 <span class="comment">        handle.  Or NULL if the handle value is invalid (i.e., too large</span>
02217 <span class="comment">        for the tables current allocation.</span>
02218 <span class="comment"></span>
02219 <span class="comment">--*/</span>
02220 
02221 {
02222     ULONG i,j,k,l;
02223 
02224     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
02225 
02226     <span class="comment">//</span>
02227     <span class="comment">//  Decode the handle index into its separate table indicies</span>
02228     <span class="comment">//</span>
02229 
02230     l = (<a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a>.Index &gt;&gt; 24) &amp; 255;
02231     i = (<a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a>.Index &gt;&gt; 16) &amp; 255;
02232     j = (<a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a>.Index &gt;&gt; 8)  &amp; 255;
02233     k = (<a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a>.Index)       &amp; 255;
02234 
02235     <span class="comment">//</span>
02236     <span class="comment">//  The last bits should be 0 into a valid handle. If a function calls</span>
02237     <span class="comment">//  ExpLookupHandleTableEntry for a kernel handle, it should decode the handle</span>
02238     <span class="comment">//  before.</span>
02239     <span class="comment">//</span>
02240 
02241     <span class="keywordflow">if</span> ( l != 0 ) {
02242         
02243         <span class="comment">//</span>
02244         <span class="comment">//  Invalid handle. Return a NULL table entry.</span>
02245         <span class="comment">//</span>
02246 
02247         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02248     }
02249 
02250     <span class="comment">//</span>
02251     <span class="comment">//  Check that the top level table is present</span>
02252     <span class="comment">//</span>
02253 
02254     <span class="keywordflow">if</span> (HandleTable-&gt;Table[i] == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02255 
02256         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02257     }
02258 
02259     <span class="comment">//</span>
02260     <span class="comment">//  Check that the mid level table is present</span>
02261     <span class="comment">//</span>
02262 
02263     <span class="keywordflow">if</span> (HandleTable-&gt;Table[i][j] == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02264 
02265         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02266     }
02267 
02268     <span class="comment">//</span>
02269     <span class="comment">//  Return a pointer to the table entry</span>
02270     <span class="comment">//</span>
02271 
02272     <span class="keywordflow">return</span> &amp;(HandleTable-&gt;Table[i][j][k]);
02273 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:40:14 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
