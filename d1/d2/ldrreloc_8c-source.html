<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: ldrreloc.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>ldrreloc.c</h1><a href="../../d0/d3/ldrreloc_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1991  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">   ldrreloc.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module contains the code to relocate an image when</span>
00012 <span class="comment">    the preferred base isn't available. This is called by the</span>
00013 <span class="comment">    boot loader, device driver loader, and system loader.</span>
00014 <span class="comment"></span>
00015 <span class="comment">Author:</span>
00016 <span class="comment"></span>
00017 <span class="comment">    Mike O'Leary (mikeol) 03-Feb-1992</span>
00018 <span class="comment"></span>
00019 <span class="comment">Revision History:</span>
00020 <span class="comment"></span>
00021 <span class="comment">--*/</span>
00022 
00023 <span class="preprocessor">#include "<a class="code" href="../../d5/d9/ntrtlp_8h.html">ntrtlp.h</a>"</span>
00024 
00025 <span class="comment">//</span>
00026 <span class="comment">// byte swapping macros (LE/BE) used for IA64 relocations</span>
00027 <span class="comment">// source != destination</span>
00028 <span class="comment">//</span>
00029 
<a name="l00030"></a><a class="code" href="../../d0/d3/ldrreloc_8c.html#a0">00030</a> <span class="preprocessor">#define SWAP_SHORT(_dst,_src)                                                  \</span>
00031 <span class="preprocessor">   ((((unsigned char *)_dst)[1] = ((unsigned char *)_src)[0]),                 \</span>
00032 <span class="preprocessor">    (((unsigned char *)_dst)[0] = ((unsigned char *)_src)[1]))</span>
00033 <span class="preprocessor"></span>
<a name="l00034"></a><a class="code" href="../../d0/d3/ldrreloc_8c.html#a1">00034</a> <span class="preprocessor">#define SWAP_INT(_dst,_src)                                                    \</span>
00035 <span class="preprocessor">   ((((unsigned char *)_dst)[3] = ((unsigned char *)_src)[0]),                 \</span>
00036 <span class="preprocessor">    (((unsigned char *)_dst)[2] = ((unsigned char *)_src)[1]),                 \</span>
00037 <span class="preprocessor">    (((unsigned char *)_dst)[1] = ((unsigned char *)_src)[2]),                 \</span>
00038 <span class="preprocessor">    (((unsigned char *)_dst)[0] = ((unsigned char *)_src)[3]))</span>
00039 <span class="preprocessor"></span>
<a name="l00040"></a><a class="code" href="../../d0/d3/ldrreloc_8c.html#a2">00040</a> <span class="preprocessor">#define SWAP_LONG_LONG(_dst,_src)                                              \</span>
00041 <span class="preprocessor">   ((((unsigned char *)_dst)[7] = ((unsigned char *)_src)[0]),                 \</span>
00042 <span class="preprocessor">    (((unsigned char *)_dst)[6] = ((unsigned char *)_src)[1]),                 \</span>
00043 <span class="preprocessor">    (((unsigned char *)_dst)[5] = ((unsigned char *)_src)[2]),                 \</span>
00044 <span class="preprocessor">    (((unsigned char *)_dst)[4] = ((unsigned char *)_src)[3]),                 \</span>
00045 <span class="preprocessor">    (((unsigned char *)_dst)[3] = ((unsigned char *)_src)[4]),                 \</span>
00046 <span class="preprocessor">    (((unsigned char *)_dst)[2] = ((unsigned char *)_src)[5]),                 \</span>
00047 <span class="preprocessor">    (((unsigned char *)_dst)[1] = ((unsigned char *)_src)[6]),                 \</span>
00048 <span class="preprocessor">    (((unsigned char *)_dst)[0] = ((unsigned char *)_src)[7]))</span>
00049 <span class="preprocessor"></span>
00050 <span class="comment">//</span>
00051 <span class="comment">// Mark a HIGHADJ entry as needing an increment if reprocessing.</span>
00052 <span class="comment">//</span>
<a name="l00053"></a><a class="code" href="../../d0/d3/ldrreloc_8c.html#a3">00053</a> <span class="preprocessor">#define LDRP_RELOCATION_INCREMENT   0x1</span>
00054 <span class="preprocessor"></span>
00055 <span class="comment">//</span>
00056 <span class="comment">// Mark a HIGHADJ entry as not suitable for reprocessing.</span>
00057 <span class="comment">//</span>
<a name="l00058"></a><a class="code" href="../../d0/d3/ldrreloc_8c.html#a4">00058</a> <span class="preprocessor">#define LDRP_RELOCATION_FINAL       0x2</span>
00059 <span class="preprocessor"></span>
00060 <span class="preprocessor">#if defined(NTOS_KERNEL_RUNTIME)</span>
00061 <span class="preprocessor"></span><span class="preprocessor">#if defined(ALLOC_PRAGMA)</span>
00062 <span class="preprocessor"></span>
00063 ULONG
00064 <a class="code" href="../../d8/d8/sysload_8c.html#a29">LdrDoubleRelocateImage</a> (
00065     IN PVOID NewBase,
00066     IN PVOID CurrentBase,
00067     IN PUCHAR LoaderName,
00068     IN ULONG Success,
00069     IN ULONG Conflict,
00070     IN ULONG Invalid
00071     );
00072 
00073 PIMAGE_BASE_RELOCATION
00074 LdrpProcessVolatileRelocationBlock(
00075     IN ULONG_PTR VA,
00076     IN ULONG SizeOfBlock,
00077     IN PUSHORT NextOffset,
00078     IN LONG_PTR Diff,
00079     IN LONG_PTR OldDiff,
00080     IN ULONG_PTR OldBase
00081     );
00082 
00083 <span class="preprocessor">#pragma alloc_text(PAGE,LdrRelocateImage)</span>
00084 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,LdrProcessRelocationBlock)</span>
00085 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(INIT,LdrDoubleRelocateImage)</span>
00086 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(INIT,LdrpProcessVolatileRelocationBlock)</span>
00087 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00088 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00089 <span class="preprocessor"></span>
00090 ULONG
<a name="l00091"></a><a class="code" href="../../d0/d3/ldrreloc_8c.html#a5">00091</a> <a class="code" href="../../d0/d3/ldrreloc_8c.html#a5">LdrRelocateImage</a> (
00092     IN PVOID NewBase,
00093     IN PUCHAR LoaderName,
00094     IN ULONG Success,
00095     IN ULONG Conflict,
00096     IN ULONG Invalid
00097     )
00098 
00099 <span class="comment">/*++</span>
00100 <span class="comment"></span>
00101 <span class="comment">Routine Description:</span>
00102 <span class="comment"></span>
00103 <span class="comment">    This routine relocates an image file that was not loaded into memory</span>
00104 <span class="comment">    at the preferred address.</span>
00105 <span class="comment"></span>
00106 <span class="comment">Arguments:</span>
00107 <span class="comment"></span>
00108 <span class="comment">    NewBase - Supplies a pointer to the image base.</span>
00109 <span class="comment"></span>
00110 <span class="comment">    LoaderName - Indicates which loader routine is being called from.</span>
00111 <span class="comment"></span>
00112 <span class="comment">    Success - Value to return if relocation successful.</span>
00113 <span class="comment"></span>
00114 <span class="comment">    Conflict - Value to return if can't relocate.</span>
00115 <span class="comment"></span>
00116 <span class="comment">    Invalid - Value to return if relocations are invalid.</span>
00117 <span class="comment"></span>
00118 <span class="comment">Return Value:</span>
00119 <span class="comment"></span>
00120 <span class="comment">    Success if image is relocated.</span>
00121 <span class="comment">    Conflict if image can't be relocated.</span>
00122 <span class="comment">    Invalid if image contains invalid fixups.</span>
00123 <span class="comment"></span>
00124 <span class="comment">--*/</span>
00125 
00126 {
00127     LONG_PTR Diff;
00128     ULONG TotalCountBytes;
00129     ULONG_PTR VA;
00130     ULONG_PTR OldBase;
00131     ULONG SizeOfBlock;
00132     PUCHAR FixupVA;
00133     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>;
00134     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a> NextOffset;
00135     PIMAGE_NT_HEADERS NtHeaders;
00136     PIMAGE_BASE_RELOCATION NextBlock;
00137 
00138     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
00139 
00140     NtHeaders = <a class="code" href="../../d8/d9/imagedir_8c.html#a0">RtlImageNtHeader</a>( NewBase );
00141     <span class="keywordflow">if</span> ( NtHeaders ) {
00142         OldBase = NtHeaders-&gt;OptionalHeader.ImageBase;
00143         }
00144     <span class="keywordflow">else</span> {
00145         <span class="keywordflow">return</span> Invalid;
00146         }
00147 
00148     <span class="comment">//</span>
00149     <span class="comment">// Locate the relocation section.</span>
00150     <span class="comment">//</span>
00151 
00152     NextBlock = (PIMAGE_BASE_RELOCATION)<a class="code" href="../../d8/d9/imagedir_8c.html#a5">RtlImageDirectoryEntryToData</a>(
00153             NewBase, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, IMAGE_DIRECTORY_ENTRY_BASERELOC, &amp;TotalCountBytes);
00154 
00155     <span class="keywordflow">if</span> (!NextBlock || !TotalCountBytes) {
00156 
00157         <span class="comment">//</span>
00158         <span class="comment">// The image does not contain a relocation table, and therefore</span>
00159         <span class="comment">// cannot be relocated.</span>
00160         <span class="comment">//</span>
00161 <span class="preprocessor">#if DBG</span>
00162 <span class="preprocessor"></span>        <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"%s: Image can't be relocated, no fixup information.\n"</span>, LoaderName);
00163 <span class="preprocessor">#endif // DBG</span>
00164 <span class="preprocessor"></span>        <span class="keywordflow">return</span> Conflict;
00165     }
00166 
00167     <span class="comment">//</span>
00168     <span class="comment">// If the image has a relocation table, then apply the specified fixup</span>
00169     <span class="comment">// information to the image.</span>
00170     <span class="comment">//</span>
00171 
00172     <span class="keywordflow">while</span> (TotalCountBytes) {
00173         SizeOfBlock = NextBlock-&gt;SizeOfBlock;
00174         TotalCountBytes -= SizeOfBlock;
00175         SizeOfBlock -= <span class="keyword">sizeof</span>(IMAGE_BASE_RELOCATION);
00176         SizeOfBlock /= <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>);
00177         NextOffset = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>)((PCHAR)NextBlock + <span class="keyword">sizeof</span>(IMAGE_BASE_RELOCATION));
00178 
00179         VA = (ULONG_PTR)NewBase + NextBlock-&gt;VirtualAddress;
00180         Diff = (PCHAR)NewBase - (PCHAR)OldBase;
00181 
00182         <span class="keywordflow">if</span> ( !(NextBlock = <a class="code" href="../../d0/d3/ldrreloc_8c.html#a6">LdrProcessRelocationBlock</a>(VA,SizeOfBlock,NextOffset,Diff)) ) {
00183 <span class="preprocessor">#if DBG</span>
00184 <span class="preprocessor"></span>            <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"%s: Unknown base relocation type\n"</span>, LoaderName);
00185 <span class="preprocessor">#endif</span>
00186 <span class="preprocessor"></span>            <span class="keywordflow">return</span> Invalid;
00187         }
00188     }
00189 
00190     <span class="keywordflow">return</span> Success;
00191 }
00192 
00193 PIMAGE_BASE_RELOCATION
<a name="l00194"></a><a class="code" href="../../d0/d3/ldrreloc_8c.html#a6">00194</a> <a class="code" href="../../d0/d3/ldrreloc_8c.html#a6">LdrProcessRelocationBlock</a>(
00195     IN ULONG_PTR VA,
00196     IN ULONG SizeOfBlock,
00197     IN PUSHORT NextOffset,
00198     IN LONG_PTR Diff
00199     )
00200 {
00201     PUCHAR FixupVA;
00202     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>;
00203     LONG Temp;
00204     LONG TempOrig;
00205     ULONG Temp32;
00206     ULONGLONG Value64;
00207     LONGLONG Temp64;
00208     LONG_PTR ActualDiff;
00209 
00210     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
00211 
00212     <span class="keywordflow">while</span> (SizeOfBlock--) {
00213 
00214        <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> = *NextOffset &amp; (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)0xfff;
00215        FixupVA = (PUCHAR)(VA + <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>);
00216 
00217        <span class="comment">//</span>
00218        <span class="comment">// Apply the fixups.</span>
00219        <span class="comment">//</span>
00220 
00221        <span class="keywordflow">switch</span> ((*NextOffset) &gt;&gt; 12) {
00222 
00223             <span class="keywordflow">case</span> IMAGE_REL_BASED_HIGHLOW :
00224                 <span class="comment">//</span>
00225                 <span class="comment">// HighLow - (32-bits) relocate the high and low half</span>
00226                 <span class="comment">//      of an address.</span>
00227                 <span class="comment">//</span>
00228                 *(LONG UNALIGNED *)FixupVA += (ULONG) Diff;
00229                 <span class="keywordflow">break</span>;
00230 
00231             <span class="keywordflow">case</span> IMAGE_REL_BASED_HIGH :
00232                 <span class="comment">//</span>
00233                 <span class="comment">// High - (16-bits) relocate the high half of an address.</span>
00234                 <span class="comment">//</span>
00235                 Temp = *(<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>)FixupVA &lt;&lt; 16;
00236                 Temp += (ULONG) Diff;
00237                 *(<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>)FixupVA = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(Temp &gt;&gt; 16);
00238                 <span class="keywordflow">break</span>;
00239 
00240             <span class="keywordflow">case</span> IMAGE_REL_BASED_HIGHADJ :
00241                 <span class="comment">//</span>
00242                 <span class="comment">// Adjust high - (16-bits) relocate the high half of an</span>
00243                 <span class="comment">//      address and adjust for sign extension of low half.</span>
00244                 <span class="comment">//</span>
00245 
00246 <span class="preprocessor">#if defined(NTOS_KERNEL_RUNTIME)</span>
00247 <span class="preprocessor"></span>                <span class="comment">//</span>
00248                 <span class="comment">// If the address has already been relocated then don't</span>
00249                 <span class="comment">// process it again now or information will be lost.</span>
00250                 <span class="comment">//</span>
00251                 <span class="keywordflow">if</span> (<a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> &amp; <a class="code" href="../../d0/d3/ldrreloc_8c.html#a4">LDRP_RELOCATION_FINAL</a>) {
00252                     ++NextOffset;
00253                     --SizeOfBlock;
00254                     <span class="keywordflow">break</span>;
00255                 }
00256 <span class="preprocessor">#endif</span>
00257 <span class="preprocessor"></span>
00258                 Temp = *(<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>)FixupVA &lt;&lt; 16;
00259 <span class="preprocessor">#if defined(BLDR_KERNEL_RUNTIME)</span>
00260 <span class="preprocessor"></span>                TempOrig = Temp;
00261 <span class="preprocessor">#endif</span>
00262 <span class="preprocessor"></span>                ++NextOffset;
00263                 --SizeOfBlock;
00264                 Temp += (LONG)(*(<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a21">PSHORT</a>)NextOffset);
00265                 Temp += (ULONG) Diff;
00266                 Temp += 0x8000;
00267                 *(<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>)FixupVA = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(Temp &gt;&gt; 16);
00268 
00269 <span class="preprocessor">#if defined(BLDR_KERNEL_RUNTIME)</span>
00270 <span class="preprocessor"></span>                ActualDiff = ((((ULONG_PTR)(Temp - TempOrig)) &gt;&gt; 16) -
00271                               (((ULONG_PTR)Diff) &gt;&gt; 16 ));
00272 
00273                 <span class="keywordflow">if</span> (ActualDiff == 1) {
00274                     <span class="comment">//</span>
00275                     <span class="comment">// Mark the relocation as needing an increment if it is</span>
00276                     <span class="comment">// relocated again.</span>
00277                     <span class="comment">//</span>
00278                     *(NextOffset - 1) |= <a class="code" href="../../d0/d3/ldrreloc_8c.html#a3">LDRP_RELOCATION_INCREMENT</a>;
00279                 }
00280                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ActualDiff != 0) {
00281                     <span class="comment">//</span>
00282                     <span class="comment">// Mark the relocation as cannot be reprocessed.</span>
00283                     <span class="comment">//</span>
00284                     *(NextOffset - 1) |= <a class="code" href="../../d0/d3/ldrreloc_8c.html#a4">LDRP_RELOCATION_FINAL</a>;
00285                 }
00286 <span class="preprocessor">#endif</span>
00287 <span class="preprocessor"></span>
00288                 <span class="keywordflow">break</span>;
00289 
00290             <span class="keywordflow">case</span> IMAGE_REL_BASED_LOW :
00291                 <span class="comment">//</span>
00292                 <span class="comment">// Low - (16-bit) relocate the low half of an address.</span>
00293                 <span class="comment">//</span>
00294                 Temp = *(<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a21">PSHORT</a>)FixupVA;
00295                 Temp += (ULONG) Diff;
00296                 *(<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>)FixupVA = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)Temp;
00297                 <span class="keywordflow">break</span>;
00298 
00299             <span class="keywordflow">case</span> IMAGE_REL_BASED_IA64_IMM64:
00300 
00301                 <span class="comment">//</span>
00302                 <span class="comment">// Align it to bundle address before fixing up the</span>
00303                 <span class="comment">// 64-bit immediate value of the movl instruction.</span>
00304                 <span class="comment">//</span>
00305 
00306                 FixupVA = (PUCHAR)((ULONG_PTR)FixupVA &amp; ~(15));
00307                 Value64 = (ULONGLONG)0;
00308 
00309                 <span class="comment">//</span>
00310                 <span class="comment">// Extract the lower 32 bits of IMM64 from bundle</span>
00311                 <span class="comment">//</span>
00312 
00313 
00314                 EXT_IMM64(Value64,
00315                         (PULONG)FixupVA + EMARCH_ENC_I17_IMM7B_INST_WORD_X,
00316                         EMARCH_ENC_I17_IMM7B_SIZE_X,
00317                         EMARCH_ENC_I17_IMM7B_INST_WORD_POS_X,
00318                         EMARCH_ENC_I17_IMM7B_VAL_POS_X);
00319                 EXT_IMM64(Value64,
00320                         (PULONG)FixupVA + EMARCH_ENC_I17_IMM9D_INST_WORD_X,
00321                         EMARCH_ENC_I17_IMM9D_SIZE_X,
00322                         EMARCH_ENC_I17_IMM9D_INST_WORD_POS_X,
00323                         EMARCH_ENC_I17_IMM9D_VAL_POS_X);
00324                 EXT_IMM64(Value64,
00325                         (PULONG)FixupVA + EMARCH_ENC_I17_IMM5C_INST_WORD_X,
00326                         EMARCH_ENC_I17_IMM5C_SIZE_X,
00327                         EMARCH_ENC_I17_IMM5C_INST_WORD_POS_X,
00328                         EMARCH_ENC_I17_IMM5C_VAL_POS_X);
00329                 EXT_IMM64(Value64,
00330                         (PULONG)FixupVA + EMARCH_ENC_I17_IC_INST_WORD_X,
00331                         EMARCH_ENC_I17_IC_SIZE_X,
00332                         EMARCH_ENC_I17_IC_INST_WORD_POS_X,
00333                         EMARCH_ENC_I17_IC_VAL_POS_X);
00334                 EXT_IMM64(Value64,
00335                         (PULONG)FixupVA + EMARCH_ENC_I17_IMM41a_INST_WORD_X,
00336                         EMARCH_ENC_I17_IMM41a_SIZE_X,
00337                         EMARCH_ENC_I17_IMM41a_INST_WORD_POS_X,
00338                         EMARCH_ENC_I17_IMM41a_VAL_POS_X);
00339 
00340                 <span class="comment">//</span>
00341                 <span class="comment">// Update 64-bit address</span>
00342                 <span class="comment">//</span>
00343 
00344                 Value64+=Diff;
00345 
00346                 <span class="comment">//</span>
00347                 <span class="comment">// Insert IMM64 into bundle</span>
00348                 <span class="comment">//</span>
00349 
00350                 INS_IMM64(Value64,
00351                         ((PULONG)FixupVA + EMARCH_ENC_I17_IMM7B_INST_WORD_X),
00352                         EMARCH_ENC_I17_IMM7B_SIZE_X,
00353                         EMARCH_ENC_I17_IMM7B_INST_WORD_POS_X,
00354                         EMARCH_ENC_I17_IMM7B_VAL_POS_X);
00355                 INS_IMM64(Value64,
00356                         ((PULONG)FixupVA + EMARCH_ENC_I17_IMM9D_INST_WORD_X),
00357                         EMARCH_ENC_I17_IMM9D_SIZE_X,
00358                         EMARCH_ENC_I17_IMM9D_INST_WORD_POS_X,
00359                         EMARCH_ENC_I17_IMM9D_VAL_POS_X);
00360                 INS_IMM64(Value64,
00361                         ((PULONG)FixupVA + EMARCH_ENC_I17_IMM5C_INST_WORD_X),
00362                         EMARCH_ENC_I17_IMM5C_SIZE_X,
00363                         EMARCH_ENC_I17_IMM5C_INST_WORD_POS_X,
00364                         EMARCH_ENC_I17_IMM5C_VAL_POS_X);
00365                 INS_IMM64(Value64,
00366                         ((PULONG)FixupVA + EMARCH_ENC_I17_IC_INST_WORD_X),
00367                         EMARCH_ENC_I17_IC_SIZE_X,
00368                         EMARCH_ENC_I17_IC_INST_WORD_POS_X,
00369                         EMARCH_ENC_I17_IC_VAL_POS_X);
00370                 INS_IMM64(Value64,
00371                         ((PULONG)FixupVA + EMARCH_ENC_I17_IMM41a_INST_WORD_X),
00372                         EMARCH_ENC_I17_IMM41a_SIZE_X,
00373                         EMARCH_ENC_I17_IMM41a_INST_WORD_POS_X,
00374                         EMARCH_ENC_I17_IMM41a_VAL_POS_X);
00375                 INS_IMM64(Value64,
00376                         ((PULONG)FixupVA + EMARCH_ENC_I17_IMM41b_INST_WORD_X),
00377                         EMARCH_ENC_I17_IMM41b_SIZE_X,
00378                         EMARCH_ENC_I17_IMM41b_INST_WORD_POS_X,
00379                         EMARCH_ENC_I17_IMM41b_VAL_POS_X);
00380                 INS_IMM64(Value64,
00381                         ((PULONG)FixupVA + EMARCH_ENC_I17_IMM41c_INST_WORD_X),
00382                         EMARCH_ENC_I17_IMM41c_SIZE_X,
00383                         EMARCH_ENC_I17_IMM41c_INST_WORD_POS_X,
00384                         EMARCH_ENC_I17_IMM41c_VAL_POS_X);
00385                 INS_IMM64(Value64,
00386                         ((PULONG)FixupVA + EMARCH_ENC_I17_SIGN_INST_WORD_X),
00387                         EMARCH_ENC_I17_SIGN_SIZE_X,
00388                         EMARCH_ENC_I17_SIGN_INST_WORD_POS_X,
00389                         EMARCH_ENC_I17_SIGN_VAL_POS_X);
00390                 <span class="keywordflow">break</span>;
00391 
00392             <span class="keywordflow">case</span> IMAGE_REL_BASED_DIR64:
00393 
00394                 *(ULONG_PTR UNALIGNED *)FixupVA += Diff;
00395 
00396                 <span class="keywordflow">break</span>;
00397 
00398             <span class="keywordflow">case</span> IMAGE_REL_BASED_MIPS_JMPADDR :
00399                 <span class="comment">//</span>
00400                 <span class="comment">// JumpAddress - (32-bits) relocate a MIPS jump address.</span>
00401                 <span class="comment">//</span>
00402                 Temp = (*(PULONG)FixupVA &amp; 0x3ffffff) &lt;&lt; 2;
00403                 Temp += (ULONG) Diff;
00404                 *(PULONG)FixupVA = (*(PULONG)FixupVA &amp; ~0x3ffffff) |
00405                                                 ((Temp &gt;&gt; 2) &amp; 0x3ffffff);
00406 
00407                 <span class="keywordflow">break</span>;
00408 
00409             <span class="keywordflow">case</span> IMAGE_REL_BASED_ABSOLUTE :
00410                 <span class="comment">//</span>
00411                 <span class="comment">// Absolute - no fixup required.</span>
00412                 <span class="comment">//</span>
00413                 <span class="keywordflow">break</span>;
00414 
00415             <span class="keywordflow">case</span> IMAGE_REL_BASED_SECTION :
00416                 <span class="comment">//</span>
00417                 <span class="comment">// Section Relative reloc.  Ignore for now.</span>
00418                 <span class="comment">//</span>
00419                 <span class="keywordflow">break</span>;
00420 
00421             <span class="keywordflow">case</span> IMAGE_REL_BASED_REL32 :
00422                 <span class="comment">//</span>
00423                 <span class="comment">// Relative intrasection. Ignore for now.</span>
00424                 <span class="comment">//</span>
00425                 <span class="keywordflow">break</span>;
00426 
00427            <span class="keywordflow">case</span> IMAGE_REL_BASED_HIGH3ADJ :
00428                <span class="comment">//</span>
00429                <span class="comment">// Similar to HIGHADJ except this is the third word.</span>
00430                <span class="comment">//  Adjust low half of high dword of an address and adjust for</span>
00431                <span class="comment">//   sign extension of the low dword.</span>
00432                <span class="comment">//</span>
00433 
00434                Temp64 = *(<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>)FixupVA &lt;&lt; 16;
00435                ++NextOffset;
00436                --SizeOfBlock;
00437                Temp64 += (LONG)((<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a13">SHORT</a>)NextOffset[1]);
00438                Temp64 &lt;&lt;= 16;
00439                Temp64 += (LONG)((<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)NextOffset[0]);
00440                Temp64 += Diff;
00441                Temp64 += 0x8000;
00442                Temp64 &gt;&gt;=16;
00443                Temp64 += 0x8000;
00444                *(<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>)FixupVA = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(Temp64 &gt;&gt; 16);
00445                ++NextOffset;
00446                --SizeOfBlock;
00447                <span class="keywordflow">break</span>;
00448 
00449             <span class="keywordflow">default</span> :
00450                 <span class="comment">//</span>
00451                 <span class="comment">// Illegal - illegal relocation type.</span>
00452                 <span class="comment">//</span>
00453 
00454                 <span class="keywordflow">return</span> (PIMAGE_BASE_RELOCATION)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00455        }
00456        ++NextOffset;
00457     }
00458     <span class="keywordflow">return</span> (PIMAGE_BASE_RELOCATION)NextOffset;
00459 }
00460 
00461 <span class="preprocessor">#if defined(NTOS_KERNEL_RUNTIME)</span>
00462 <span class="preprocessor"></span>
00463 ULONG
00464 <a class="code" href="../../d8/d8/sysload_8c.html#a29">LdrDoubleRelocateImage</a> (
00465     IN PVOID NewBase,
00466     IN PVOID CurrentBase,
00467     IN PUCHAR LoaderName,
00468     IN ULONG Success,
00469     IN ULONG Conflict,
00470     IN ULONG Invalid
00471     )
00472 
00473 <span class="comment">/*++</span>
00474 <span class="comment"></span>
00475 <span class="comment">Routine Description:</span>
00476 <span class="comment"></span>
00477 <span class="comment">    This routine handles the volatile relocations that cannot be easily repeated</span>
00478 <span class="comment">    on an image file that has already been relocated at least once.</span>
00479 <span class="comment"></span>
00480 <span class="comment">    Since this only needs to be done once (at kernel startup time), the</span>
00481 <span class="comment">    decision was made to split this into a separate routine so as not to</span>
00482 <span class="comment">    impact the mainline code.</span>
00483 <span class="comment"></span>
00484 <span class="comment">    N.B. This function is for use by memory management ONLY.</span>
00485 <span class="comment"></span>
00486 <span class="comment">Arguments:</span>
00487 <span class="comment"></span>
00488 <span class="comment">    NewBase - Supplies a pointer to the new (second relocated) image base.</span>
00489 <span class="comment"></span>
00490 <span class="comment">    CurrentBase - Supplies a pointer to the first relocated image base.</span>
00491 <span class="comment"></span>
00492 <span class="comment">    LoaderName - Indicates which loader routine is being called from.</span>
00493 <span class="comment"></span>
00494 <span class="comment">    Success - Value to return if relocation successful.</span>
00495 <span class="comment"></span>
00496 <span class="comment">    Conflict - Value to return if can't relocate.</span>
00497 <span class="comment"></span>
00498 <span class="comment">    Invalid - Value to return if relocations are invalid.</span>
00499 <span class="comment"></span>
00500 <span class="comment">Return Value:</span>
00501 <span class="comment"></span>
00502 <span class="comment">    Success if image is relocated.</span>
00503 <span class="comment">    Conflict if image can't be relocated.</span>
00504 <span class="comment">    Invalid if image contains invalid fixups.</span>
00505 <span class="comment"></span>
00506 <span class="comment">--*/</span>
00507 
00508 {
00509     LONG_PTR Diff;
00510     LONG_PTR OldDiff;
00511     ULONG TotalCountBytes;
00512     ULONG_PTR VA;
00513     ULONG_PTR OldBase;
00514     ULONG SizeOfBlock;
00515     PUCHAR FixupVA;
00516     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>;
00517     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a> NextOffset;
00518     PIMAGE_NT_HEADERS NtHeaders;
00519     PIMAGE_BASE_RELOCATION NextBlock;
00520 
00521     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
00522 
00523     NtHeaders = <a class="code" href="../../d8/d9/imagedir_8c.html#a0">RtlImageNtHeader</a>( NewBase );
00524 
00525     OldBase = NtHeaders-&gt;OptionalHeader.ImageBase;
00526     OldDiff = (PCHAR)CurrentBase - (PCHAR)OldBase;
00527 
00528     <span class="comment">//</span>
00529     <span class="comment">// Locate the relocation section.</span>
00530     <span class="comment">//</span>
00531 
00532     NextBlock = (PIMAGE_BASE_RELOCATION)<a class="code" href="../../d8/d9/imagedir_8c.html#a5">RtlImageDirectoryEntryToData</a>(
00533             NewBase, TRUE, IMAGE_DIRECTORY_ENTRY_BASERELOC, &amp;TotalCountBytes);
00534 
00535     <span class="keywordflow">if</span> (!NextBlock || !TotalCountBytes) {
00536 
00537         <span class="comment">//</span>
00538         <span class="comment">// The image does not contain a relocation table, and therefore</span>
00539         <span class="comment">// cannot be relocated.</span>
00540         <span class="comment">//</span>
00541 <span class="preprocessor">#if DBG</span>
00542 <span class="preprocessor"></span>        <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"%s: Image can't be relocated, no fixup information.\n"</span>, LoaderName);
00543 <span class="preprocessor">#endif // DBG</span>
00544 <span class="preprocessor"></span>        <span class="keywordflow">return</span> Conflict;
00545     }
00546 
00547     <span class="comment">//</span>
00548     <span class="comment">// If the image has a relocation table, then apply the specified fixup</span>
00549     <span class="comment">// information to the image.</span>
00550     <span class="comment">//</span>
00551 
00552     Diff = (PCHAR)NewBase - (PCHAR)OldBase;
00553 
00554     <span class="keywordflow">while</span> (TotalCountBytes) {
00555         SizeOfBlock = NextBlock-&gt;SizeOfBlock;
00556         TotalCountBytes -= SizeOfBlock;
00557         SizeOfBlock -= <span class="keyword">sizeof</span>(IMAGE_BASE_RELOCATION);
00558         SizeOfBlock /= <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>);
00559         NextOffset = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>)((PCHAR)NextBlock + <span class="keyword">sizeof</span>(IMAGE_BASE_RELOCATION));
00560 
00561         VA = (ULONG_PTR)NewBase + NextBlock-&gt;VirtualAddress;
00562 
00563         <span class="keywordflow">if</span> ( !(NextBlock = LdrpProcessVolatileRelocationBlock(VA,SizeOfBlock,NextOffset,Diff, OldDiff, OldBase)) ) {
00564 <span class="preprocessor">#if DBG</span>
00565 <span class="preprocessor"></span>            <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"%s: Unknown base relocation type\n"</span>, LoaderName);
00566 <span class="preprocessor">#endif</span>
00567 <span class="preprocessor"></span>            <span class="keywordflow">return</span> Invalid;
00568         }
00569     }
00570 
00571     <span class="keywordflow">return</span> Success;
00572 }
00573 
00574 PIMAGE_BASE_RELOCATION
00575 LdrpProcessVolatileRelocationBlock(
00576     IN ULONG_PTR VA,
00577     IN ULONG SizeOfBlock,
00578     IN PUSHORT NextOffset,
00579     IN LONG_PTR Diff,
00580     IN LONG_PTR OldDiff,
00581     IN ULONG_PTR OldBase
00582     )
00583 
00584 <span class="comment">/*++</span>
00585 <span class="comment"></span>
00586 <span class="comment">Routine Description:</span>
00587 <span class="comment"></span>
00588 <span class="comment">    This routine handles the volatile relocations that cannot be easily repeated</span>
00589 <span class="comment">    on an image file that has already been relocated at least once.</span>
00590 <span class="comment"></span>
00591 <span class="comment">    Since this only needs to be done once (at kernel startup time), the</span>
00592 <span class="comment">    decision was made to split this into a separate routine so as not to</span>
00593 <span class="comment">    impact the mainline code.</span>
00594 <span class="comment"></span>
00595 <span class="comment">    N.B. This function is for use by memory management ONLY.</span>
00596 <span class="comment"></span>
00597 <span class="comment">Arguments:</span>
00598 <span class="comment"></span>
00599 <span class="comment">    TBD.</span>
00600 <span class="comment"></span>
00601 <span class="comment">Return Value:</span>
00602 <span class="comment"></span>
00603 <span class="comment">    Next relocation entry to process.</span>
00604 <span class="comment"></span>
00605 <span class="comment">--*/</span>
00606 
00607 {
00608     PUCHAR FixupVA;
00609     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>;
00610     LONG Temp;
00611     ULONG Temp32;
00612     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> TempShort1;
00613     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> TempShort2;
00614     ULONGLONG Value64;
00615     LONGLONG Temp64;
00616     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> RelocationType;
00617     IN PVOID CurrentBase;
00618 
00619     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
00620 
00621     CurrentBase = (PVOID)((ULONG_PTR)OldDiff + OldBase);
00622 
00623     <span class="keywordflow">while</span> (SizeOfBlock--) {
00624 
00625        <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> = *NextOffset &amp; (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)0xfff;
00626        FixupVA = (PUCHAR)(VA + <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>);
00627 
00628        <span class="comment">//</span>
00629        <span class="comment">// Apply the fixups.</span>
00630        <span class="comment">//</span>
00631 
00632        <span class="keywordflow">switch</span> ((*NextOffset) &gt;&gt; 12) {
00633 
00634             <span class="keywordflow">case</span> IMAGE_REL_BASED_HIGHADJ :
00635                 <span class="comment">//</span>
00636                 <span class="comment">// Adjust high - (16-bits) relocate the high half of an</span>
00637                 <span class="comment">//      address and adjust for sign extension of low half.</span>
00638                 <span class="comment">//</span>
00639 
00640                 <span class="comment">//</span>
00641                 <span class="comment">// Return the relocation to its original state, checking for</span>
00642                 <span class="comment">// whether the entry was sign extended the 1st time it was</span>
00643                 <span class="comment">// relocated.</span>
00644                 <span class="comment">//</span>
00645                 FixupVA = (PUCHAR)((LONG_PTR)FixupVA &amp; (LONG_PTR)~(<a class="code" href="../../d0/d3/ldrreloc_8c.html#a4">LDRP_RELOCATION_FINAL</a> | <a class="code" href="../../d0/d3/ldrreloc_8c.html#a3">LDRP_RELOCATION_INCREMENT</a>));
00646                 Temp = *(<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>)(FixupVA) &lt;&lt; 16;
00647 
00648                 ++NextOffset;
00649                 --SizeOfBlock;
00650 
00651                 <span class="comment">// remove the carry bit from the low word</span>
00652                 Temp -= ((LONG)(*(<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a21">PSHORT</a>)NextOffset) + (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)OldDiff + 0x8000) &amp; ~0xFFFF;
00653 
00654                 Temp -= (LONG)(OldDiff &amp; ~0xffff);
00655 
00656                 Temp += (LONG)(*(<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a21">PSHORT</a>)NextOffset);
00657                 Temp += (ULONG) Diff;
00658                 Temp += 0x8000;
00659                 *(<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>)FixupVA = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(Temp &gt;&gt; 16);
00660 
00661                 <span class="comment">//</span>
00662                 <span class="comment">// Mark the relocation as needing no further reprocessing.</span>
00663                 <span class="comment">//</span>
00664                 *(NextOffset - 1) |= <a class="code" href="../../d0/d3/ldrreloc_8c.html#a4">LDRP_RELOCATION_FINAL</a>;
00665                 <span class="keywordflow">break</span>;
00666 
00667            <span class="keywordflow">case</span> IMAGE_REL_BASED_HIGH3ADJ :
00668                <span class="comment">//</span>
00669                <span class="comment">// This type of relocation always results in a no-op when</span>
00670                <span class="comment">// done by the osloader for kernelmode drivers.  But the</span>
00671                <span class="comment">// subsequent relocation must be done very carefully.</span>
00672                <span class="comment">//</span>
00673                TempShort1 = *(NextOffset + 1);
00674                TempShort2 = *(NextOffset + 2);
00675 
00676                Temp64 = (LONGLONG)((TempShort2 &lt;&lt; 16) + TempShort1);
00677                Temp64 -= (LONGLONG)OldBase;
00678                Temp64 += (LONGLONG)CurrentBase;
00679 
00680                TempShort1 = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)Temp64;
00681                TempShort2 = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(Temp64 &gt;&gt; 16);
00682 
00683                *(NextOffset + 1) = TempShort1;
00684                *(NextOffset + 2) = TempShort2;
00685 
00686                ++NextOffset;
00687                --SizeOfBlock;
00688                ++NextOffset;
00689                --SizeOfBlock;
00690 
00691                <span class="keywordflow">break</span>;
00692 
00693             <span class="keywordflow">default</span> :
00694                <span class="keywordflow">break</span>;
00695        }
00696        ++NextOffset;
00697     }
00698     <span class="keywordflow">return</span> (PIMAGE_BASE_RELOCATION)NextOffset;
00699 }
00700 
00701 <span class="preprocessor">#endif</span>
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:40:37 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
