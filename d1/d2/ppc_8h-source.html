<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: ppc.h Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>ppc.h</h1><a href="../../d0/d3/ppc_8h.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++ BUILD Version: 0018    // Increment this if a change has global effects</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1993  IBM Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    ppc.h</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module contains the PowerPC hardware specific header file.</span>
00012 <span class="comment"></span>
00013 <span class="comment">Author:</span>
00014 <span class="comment"></span>
00015 <span class="comment">    Rick Simpson   9-Jul-1993</span>
00016 <span class="comment"></span>
00017 <span class="comment">    Based on mips.h, by David N. Cutler (davec) 31-Mar-1990</span>
00018 <span class="comment"></span>
00019 <span class="comment">Revision History:</span>
00020 <span class="comment"></span>
00021 <span class="comment">--*/</span>
00022 
00023 <span class="preprocessor">#ifndef _PPCH_</span>
00024 <span class="preprocessor"></span><span class="preprocessor">#define _PPCH_</span>
00025 <span class="preprocessor"></span>
00026 <span class="comment">// begin_ntddk begin_wdm begin_nthal begin_ntndis</span>
00027 
00028 <span class="preprocessor">#if defined(_PPC_)</span>
00029 <span class="preprocessor"></span>
00030 <span class="comment">//</span>
00031 <span class="comment">// Define maximum size of flush multple TB request.</span>
00032 <span class="comment">//</span>
00033 
00034 <span class="preprocessor">#define FLUSH_MULTIPLE_MAXIMUM 48</span>
00035 <span class="preprocessor"></span>
00036 <span class="comment">//</span>
00037 <span class="comment">// Indicate that the compiler (with MIPS front-end) supports</span>
00038 <span class="comment">// the pragma textout construct.</span>
00039 <span class="comment">//</span>
00040 
00041 <span class="preprocessor">#define ALLOC_PRAGMA 1</span>
00042 <span class="preprocessor"></span>
00043 <span class="comment">//</span>
00044 <span class="comment">// Define function decoration depending on whether a driver, a file system,</span>
00045 <span class="comment">// or a kernel component is being built.</span>
00046 <span class="comment">//</span>
00047 
00048 <span class="comment">//  end_wdm</span>
00049 
00050 <span class="preprocessor">#if defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_)</span>
00051 <span class="preprocessor"></span>
00052 <span class="preprocessor">#define NTKERNELAPI DECLSPEC_IMPORT             // wdm</span>
00053 <span class="preprocessor"></span>
00054 <span class="preprocessor">#else</span>
00055 <span class="preprocessor"></span>
00056 <span class="preprocessor">#define NTKERNELAPI</span>
00057 <span class="preprocessor"></span>
00058 <span class="preprocessor">#endif</span>
00059 <span class="preprocessor"></span>
00060 <span class="comment">//</span>
00061 <span class="comment">// Define function decoration depending on whether the HAL or other kernel</span>
00062 <span class="comment">// component is being build.</span>
00063 <span class="comment">//</span>
00064 
00065 <span class="preprocessor">#if !defined(_NTHAL_)</span>
00066 <span class="preprocessor"></span>
00067 <span class="preprocessor">#define NTHALAPI DECLSPEC_IMPORT                // wdm</span>
00068 <span class="preprocessor"></span>
00069 <span class="preprocessor">#else</span>
00070 <span class="preprocessor"></span>
00071 <span class="preprocessor">#define NTHALAPI</span>
00072 <span class="preprocessor"></span>
00073 <span class="preprocessor">#endif</span>
00074 <span class="preprocessor"></span>
00075 <span class="comment">// end_ntndis</span>
00076 <span class="comment">//</span>
00077 <span class="comment">// Define macro to generate import names.</span>
00078 <span class="comment">//</span>
00079 
00080 <span class="preprocessor">#define IMPORT_NAME(name) __imp_##name</span>
00081 <span class="preprocessor"></span>
00082 <span class="comment">//</span>
00083 <span class="comment">// PowerPC specific interlocked operation result values.</span>
00084 <span class="comment">//</span>
00085 <span class="comment">// These are the values used on MIPS; there appears to be no</span>
00086 <span class="comment">// need to change them for PowerPC.</span>
00087 <span class="comment">//</span>
00088 
00089 <span class="preprocessor">#define RESULT_ZERO      0</span>
00090 <span class="preprocessor"></span><span class="preprocessor">#define RESULT_NEGATIVE -2</span>
00091 <span class="preprocessor"></span><span class="preprocessor">#define RESULT_POSITIVE -1</span>
00092 <span class="preprocessor"></span>
00093 <span class="comment">//</span>
00094 <span class="comment">// Interlocked result type is portable, but its values are machine specific.</span>
00095 <span class="comment">// Constants for value are in i386.h, mips.h, ppc.h, etc.</span>
00096 <span class="comment">//</span>
00097 
00098 <span class="keyword">typedef</span> <span class="keyword">enum</span> _INTERLOCKED_RESULT {
00099     ResultNegative = RESULT_NEGATIVE,
00100     ResultZero     = RESULT_ZERO,
00101     ResultPositive = RESULT_POSITIVE
00102 } INTERLOCKED_RESULT;
00103 
00104 
00105 <span class="comment">//</span>
00106 <span class="comment">// Convert portable interlock interfaces to architecure specific interfaces.</span>
00107 <span class="comment">//</span>
00108 
00109 <span class="preprocessor">#define ExInterlockedIncrementLong(Addend, Lock) \</span>
00110 <span class="preprocessor">    ExPpcInterlockedIncrementLong(Addend)</span>
00111 <span class="preprocessor"></span>
00112 <span class="preprocessor">#define ExInterlockedDecrementLong(Addend, Lock) \</span>
00113 <span class="preprocessor">    ExPpcInterlockedDecrementLong(Addend)</span>
00114 <span class="preprocessor"></span>
00115 <span class="preprocessor">#define ExInterlockedExchangeUlong(Target, Value, Lock) \</span>
00116 <span class="preprocessor">    ExPpcInterlockedExchangeUlong(Target, Value)</span>
00117 <span class="preprocessor"></span>
00118 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00119 INTERLOCKED_RESULT
00120 ExPpcInterlockedIncrementLong (
00121     IN PLONG Addend
00122     );
00123 
00124 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00125 INTERLOCKED_RESULT
00126 ExPpcInterlockedDecrementLong (
00127     IN PLONG Addend
00128     );
00129 
00130 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00131 LARGE_INTEGER
00132 ExInterlockedExchangeAddLargeInteger (
00133     IN PLARGE_INTEGER Addend,
00134     IN LARGE_INTEGER Increment,
00135     IN PKSPIN_LOCK Lock
00136     );
00137 
00138 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00139 ULONG
00140 ExPpcInterlockedExchangeUlong (
00141     IN PULONG Target,
00142     IN ULONG Value
00143     );
00144 
00145 <span class="comment">//  begin_wdm</span>
00146 
00147 <span class="comment">//</span>
00148 <span class="comment">// Intrinsic interlocked functions</span>
00149 <span class="comment">//</span>
00150 
00151 <span class="preprocessor">#if defined(_M_PPC) &amp;&amp; defined(_MSC_VER) &amp;&amp; (_MSC_VER&gt;=1000) &amp;&amp; !defined(RC_INVOKED)</span>
00152 <span class="preprocessor"></span>
00153 <span class="preprocessor">#define InterlockedIncrement _InterlockedIncrement</span>
00154 <span class="preprocessor"></span><span class="preprocessor">#define InterlockedDecrement _InterlockedDecrement</span>
00155 <span class="preprocessor"></span><span class="preprocessor">#define InterlockedExchange _InterlockedExchange</span>
00156 <span class="preprocessor"></span><span class="preprocessor">#define InterlockedExchangeAdd _InterlockedExchangeAdd</span>
00157 <span class="preprocessor"></span><span class="preprocessor">#define InterlockedCompareExchange _InterlockedCompareExchange</span>
00158 <span class="preprocessor"></span>
00159 LONG
00160 InterlockedIncrement(
00161     IN OUT PLONG Addend
00162     );
00163 
00164 LONG
00165 InterlockedDecrement(
00166     IN OUT PLONG Addend
00167     );
00168 
00169 LONG
00170 InterlockedExchange(
00171     IN OUT PLONG Target,
00172     IN LONG Increment
00173     );
00174 
00175 LONG
00176 InterlockedExchangeAdd(
00177     IN OUT PLONG Addend,
00178     IN LONG Value
00179     );
00180 
00181 PVOID
00182 InterlockedCompareExchange (
00183     IN OUT PVOID *Destination,
00184     IN PVOID Exchange,
00185     IN PVOID Comperand
00186     );
00187 
00188 <span class="preprocessor">#pragma intrinsic(_InterlockedIncrement)</span>
00189 <span class="preprocessor"></span><span class="preprocessor">#pragma intrinsic(_InterlockedDecrement)</span>
00190 <span class="preprocessor"></span><span class="preprocessor">#pragma intrinsic(_InterlockedExchange)</span>
00191 <span class="preprocessor"></span><span class="preprocessor">#pragma intrinsic(_InterlockedExchangeAdd)</span>
00192 <span class="preprocessor"></span><span class="preprocessor">#pragma intrinsic(_InterlockedCompareExchange)</span>
00193 <span class="preprocessor"></span>
00194 <span class="preprocessor">#else</span>
00195 <span class="preprocessor"></span>
00196 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00197 LONG
00198 InterlockedIncrement(
00199     IN OUT PLONG Addend
00200     );
00201 
00202 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00203 LONG
00204 InterlockedDecrement(
00205     IN OUT PLONG Addend
00206     );
00207 
00208 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00209 LONG
00210 InterlockedExchange(
00211     IN OUT PLONG Target,
00212     IN LONG Increment
00213     );
00214 
00215 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00216 LONG
00217 InterlockedExchangeAdd(
00218     IN OUT PLONG Addend,
00219     IN LONG Value
00220     );
00221 
00222 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00223 PVOID
00224 InterlockedCompareExchange (
00225     IN OUT PVOID *Destination,
00226     IN PVOID Exchange,
00227     IN PVOID Comperand
00228     );
00229 
00230 <span class="preprocessor">#endif</span>
00231 <span class="preprocessor"></span>
00232 <span class="comment">//</span>
00233 <span class="comment">// PowerPC Interrupt Definitions.</span>
00234 <span class="comment">//</span>
00235 <span class="comment">// Define length of interupt object dispatch code in 32-bit words.</span>
00236 <span class="comment">//</span>
00237 
00238 <span class="preprocessor">#define DISPATCH_LENGTH 4               // Length of dispatch code in instructions</span>
00239 <span class="preprocessor"></span>
00240 <span class="comment">//</span>
00241 <span class="comment">// Define Interrupt Request Levels.</span>
00242 <span class="comment">//</span>
00243 
00244 <span class="preprocessor">#define PASSIVE_LEVEL   0               // Passive release level</span>
00245 <span class="preprocessor"></span><span class="preprocessor">#define LOW_LEVEL       0               // Lowest interrupt level</span>
00246 <span class="preprocessor"></span><span class="preprocessor">#define APC_LEVEL       1               // APC interrupt level</span>
00247 <span class="preprocessor"></span><span class="preprocessor">#define DISPATCH_LEVEL  2               // Dispatcher level</span>
00248 <span class="preprocessor"></span><span class="preprocessor">#define PROFILE_LEVEL   27              // Profiling level</span>
00249 <span class="preprocessor"></span><span class="preprocessor">#define IPI_LEVEL       29              // Interprocessor interrupt level</span>
00250 <span class="preprocessor"></span><span class="preprocessor">#define POWER_LEVEL     30              // Power failure level</span>
00251 <span class="preprocessor"></span><span class="preprocessor">#define FLOAT_LEVEL     31              // Floating interrupt level</span>
00252 <span class="preprocessor"></span><span class="preprocessor">#define HIGH_LEVEL      31              // Highest interrupt level</span>
00253 <span class="preprocessor"></span><span class="preprocessor">#define SYNCH_LEVEL     DISPATCH_LEVEL  // Synchronization level</span>
00254 <span class="preprocessor"></span>
00255 <span class="comment">//</span>
00256 <span class="comment">// Define profile intervals.</span>
00257 <span class="comment">//</span>
00258 <span class="comment">// **FINISH**  These are the MIPS R4000 values; investigate for PPC</span>
00259 
00260 <span class="preprocessor">#define DEFAULT_PROFILE_COUNT 0x40000000             // ~= 20 seconds @50mhz</span>
00261 <span class="preprocessor"></span><span class="preprocessor">#define DEFAULT_PROFILE_INTERVAL (10 * 500)          // 500 microseconds</span>
00262 <span class="preprocessor"></span><span class="preprocessor">#define MAXIMUM_PROFILE_INTERVAL (10 * 1000 * 1000)  // 1 second</span>
00263 <span class="preprocessor"></span><span class="preprocessor">#define MINIMUM_PROFILE_INTERVAL (10 * 40)           // 40 microseconds</span>
00264 <span class="preprocessor"></span>
00265 <span class="comment">// end_ntddk end_wdm end_nthal</span>
00266 
00267 <span class="preprocessor">#define KiSynchIrql SYNCH_LEVEL         // enable portable code</span>
00268 <span class="preprocessor"></span><span class="preprocessor">#define KiProfileIrql PROFILE_LEVEL     // enable portable code</span>
00269 <span class="preprocessor"></span>
00270 <span class="comment">//</span>
00271 <span class="comment">// Define machine specific external references.</span>
00272 <span class="comment">//</span>
00273 
00274 <span class="comment">// **FINISH**  On MIPS, this is defined in ...\ntos\ke\mips\xxintsup.s</span>
00275 <span class="comment">//             For PPC, ensure that there is a C-referencable label</span>
00276 <span class="comment">//             on the list of instructions (the ordinary entry point</span>
00277 <span class="comment">//             name won't be, because it will start with '.').</span>
00278 <span class="keyword">extern</span> ULONG KiInterruptTemplate[];
00279 
00280 <span class="comment">//</span>
00281 <span class="comment">// Sanitize FPSCR and MSR based on processor mode.</span>
00282 <span class="comment">//    By analogy with MIPS "Sanitize FSR" and "Sanitize PSR"</span>
00283 <span class="comment">//</span>
00284 <span class="comment">//    General form:  #define SANTIZE_&lt;reg&gt;(reg, mode)</span>
00285 <span class="comment">//                      ((mode) == KernelMode ?</span>
00286 <span class="comment">//                          ((0x00000000L) | ((reg) &amp; 0xFFFFFFFF)) :</span>
00287 <span class="comment">//                          ((0x00000000L) | ((reg) &amp; 0xFFFFFFFF)))</span>
00288 <span class="comment">//    Where 0x00000000L represents bits that are forced on, and</span>
00289 <span class="comment">//    0xFFFFFFFF represents bits that are forced off.</span>
00290 <span class="comment">//</span>
00291 <span class="comment">//    We will optimize this expression right here in the macro, because</span>
00292 <span class="comment">//    the initial PPC compiler cannot be expected to do so itself.</span>
00293 <span class="comment">//</span>
00294 <span class="comment">//  FPSCR -- Floating Point Status and Control Register</span>
00295 <span class="comment">//</span>
00296 <span class="comment">//     We turn off the various exception enable bits so that loading</span>
00297 <span class="comment">//     the FPSCR cannot cause an exception.</span>
00298 <span class="comment">//         Force to 0:  VE (24), OE (25), UE (26), ZE (27), XE (28)</span>
00299 <span class="comment">//         Force to 1:  -none-</span>
00300 <span class="comment">//         Let caller specify:  All others</span>
00301 
00302 <span class="comment">// **FINISH** -- Set this macro back to do something; leave as a no-op for now</span>
00303 
00304 <span class="preprocessor">#define SANITIZE_FPSCR(fpscr, mode) (fpscr)</span>
00305 <span class="preprocessor"></span><span class="comment">//#define SANITIZE_FPSCR(fpscr, mode) (fpscr &amp; 0xFFFFFF07L)</span>
00306 
00307 <span class="comment">//</span>
00308 <span class="comment">//  MSR -- Machine State Register</span>
00309 <span class="comment">//</span>
00310 <span class="comment">//     If kernel mode, then</span>
00311 <span class="comment">//         Force to 0:  reserved (0..12, 24, 28)</span>
00312 <span class="comment">//         Force to 1:  ILE (15), LE (31)</span>
00313 <span class="comment">//         Let caller specify:</span>
00314 <span class="comment">//                      POW (13), implementation-dependent (14),</span>
00315 <span class="comment">//                      EE (16), PR (17), FP (18), ME (19),</span>
00316 <span class="comment">//                      FE0 (20), SE (21), BE (22), FE1 (23),</span>
00317 <span class="comment">//                      IP (25), IR (26), DR (27), PM (29), RI (30)</span>
00318 <span class="comment">//</span>
00319 <span class="comment">//     If user mode, then</span>
00320 <span class="comment">//         Force to 0:  POW (13), implementation-dependent (14), IP (25),</span>
00321 <span class="comment">//                      reserved (0..12, 24, 28)</span>
00322 <span class="comment">//         Force to 1:  ILE (15), EE (16), PR (17), FPE (18), ME (19),</span>
00323 <span class="comment">//                      IR (26), DR (27), RI (30), LE (31)</span>
00324 <span class="comment">//         Let caller specify:</span>
00325 <span class="comment">//                      FE0 (20), SE (21), BE (22), FE1 (23), PM (29)</span>
00326 <span class="comment">//</span>
00327 
00328 <span class="preprocessor">#define SANITIZE_MSR(msr, mode) \</span>
00329 <span class="preprocessor">    ((mode) == KernelMode ? \</span>
00330 <span class="preprocessor">        ((0x00010001L) | ((msr) &amp; 0x0007FF77L)) : \</span>
00331 <span class="preprocessor">        ((0x0001F033L) | ((msr) &amp; 0x0001FF37L)))</span>
00332 <span class="preprocessor"></span>
00333 <span class="comment">// begin_ntddk begin_wdm begin_nthal</span>
00334 <span class="comment">//</span>
00335 <span class="comment">// Define length of interrupt vector table.</span>
00336 <span class="comment">//</span>
00337 
00338 <span class="preprocessor">#define MAXIMUM_VECTOR 256</span>
00339 <span class="preprocessor"></span>
00340 <span class="comment">//</span>
00341 <span class="comment">// Processor Control Region</span>
00342 <span class="comment">//</span>
00343 <span class="comment">//   On PowerPC, this cannot be at a fixed virtual address;</span>
00344 <span class="comment">//   it must be at a different address on each processor of an MP.</span>
00345 <span class="comment">//</span>
00346 
00347 <span class="preprocessor">#define PCR_MINOR_VERSION 1</span>
00348 <span class="preprocessor"></span><span class="preprocessor">#define PCR_MAJOR_VERSION 1</span>
00349 <span class="preprocessor"></span>
00350 <span class="keyword">typedef</span> <span class="keyword">struct </span>_KPCR {
00351 
00352 <span class="comment">//</span>
00353 <span class="comment">// Major and minor version numbers of the PCR.</span>
00354 <span class="comment">//</span>
00355 
00356     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> MinorVersion;
00357     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> MajorVersion;
00358 
00359 <span class="comment">//</span>
00360 <span class="comment">// Start of the architecturally defined section of the PCR. This section</span>
00361 <span class="comment">// may be directly addressed by vendor/platform specific HAL code and will</span>
00362 <span class="comment">// not change from version to version of NT.</span>
00363 <span class="comment">//</span>
00364 <span class="comment">// Interrupt and error exception vectors.</span>
00365 <span class="comment">//</span>
00366 
00367     PKINTERRUPT_ROUTINE InterruptRoutine[MAXIMUM_VECTOR];
00368     ULONG PcrPage2;
00369     ULONG Kseg0Top;
00370     ULONG Spare7[30];
00371 
00372 <span class="comment">//</span>
00373 <span class="comment">// First and second level cache parameters.</span>
00374 <span class="comment">//</span>
00375 
00376     ULONG FirstLevelDcacheSize;
00377     ULONG FirstLevelDcacheFillSize;
00378     ULONG FirstLevelIcacheSize;
00379     ULONG FirstLevelIcacheFillSize;
00380     ULONG SecondLevelDcacheSize;
00381     ULONG SecondLevelDcacheFillSize;
00382     ULONG SecondLevelIcacheSize;
00383     ULONG SecondLevelIcacheFillSize;
00384 
00385 <span class="comment">//</span>
00386 <span class="comment">// Pointer to processor control block.</span>
00387 <span class="comment">//</span>
00388 
00389     <span class="keyword">struct </span>_KPRCB *Prcb;
00390 
00391 <span class="comment">//</span>
00392 <span class="comment">// Pointer to the thread environment block.  A fast-path system call</span>
00393 <span class="comment">// is provided that will return this value to user-mode code.</span>
00394 <span class="comment">//</span>
00395 
00396     PVOID Teb;
00397 
00398 <span class="comment">//</span>
00399 <span class="comment">// Data cache alignment and fill size used for cache flushing and alignment.</span>
00400 <span class="comment">// These fields are set to the larger of the first and second level data</span>
00401 <span class="comment">// cache fill sizes.</span>
00402 <span class="comment">//</span>
00403 
00404     ULONG DcacheAlignment;
00405     ULONG DcacheFillSize;
00406 
00407 <span class="comment">//</span>
00408 <span class="comment">// Instruction cache alignment and fill size used for cache flushing and</span>
00409 <span class="comment">// alignment. These fields are set to the larger of the first and second</span>
00410 <span class="comment">// level data cache fill sizes.</span>
00411 <span class="comment">//</span>
00412 
00413     ULONG IcacheAlignment;
00414     ULONG IcacheFillSize;
00415 
00416 <span class="comment">//</span>
00417 <span class="comment">// Processor identification information from PVR.</span>
00418 <span class="comment">//</span>
00419 
00420     ULONG ProcessorVersion;
00421     ULONG ProcessorRevision;
00422 
00423 <span class="comment">//</span>
00424 <span class="comment">// Profiling data.</span>
00425 <span class="comment">//</span>
00426 
00427     ULONG ProfileInterval;
00428     ULONG ProfileCount;
00429 
00430 <span class="comment">//</span>
00431 <span class="comment">// Stall execution count and scale factor.</span>
00432 <span class="comment">//</span>
00433 
00434     ULONG StallExecutionCount;
00435     ULONG StallScaleFactor;
00436 
00437 <span class="comment">//</span>
00438 <span class="comment">// Spare cell.</span>
00439 <span class="comment">//</span>
00440 
00441     ULONG Spare;
00442 
00443 <span class="comment">//</span>
00444 <span class="comment">// Cache policy, right justified, as read from the processor configuration</span>
00445 <span class="comment">// register at startup.</span>
00446 <span class="comment">//</span>
00447 
00448     <span class="keyword">union </span>{
00449         ULONG CachePolicy;
00450         <span class="keyword">struct </span>{
00451                 UCHAR IcacheMode;       <span class="comment">// Dynamic cache mode for PPC</span>
00452                 UCHAR DcacheMode;       <span class="comment">// Dynamic cache mode for PPC</span>
00453                 <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> ModeSpare;
00454         };
00455     };
00456 
00457 <span class="comment">//</span>
00458 <span class="comment">// IRQL mapping tables.</span>
00459 <span class="comment">//</span>
00460 
00461     UCHAR IrqlMask[32];
00462     UCHAR IrqlTable[9];
00463 
00464 <span class="comment">//</span>
00465 <span class="comment">// Current IRQL.</span>
00466 <span class="comment">//</span>
00467 
00468     UCHAR CurrentIrql;
00469 
00470 <span class="comment">//</span>
00471 <span class="comment">// Processor identification</span>
00472 <span class="comment">//</span>
00473     CCHAR Number;
00474     KAFFINITY <a class="code" href="../../d0/d0/ki_8h.html#a7">SetMember</a>;
00475 
00476 <span class="comment">//</span>
00477 <span class="comment">// Reserved interrupt vector mask.</span>
00478 <span class="comment">//</span>
00479 
00480     ULONG ReservedVectors;
00481 
00482 <span class="comment">//</span>
00483 <span class="comment">// Current state parameters.</span>
00484 <span class="comment">//</span>
00485 
00486     <span class="keyword">struct </span><a class="code" href="../../d1/d8/struct__KTHREAD.html">_KTHREAD</a> *CurrentThread;
00487 
00488 <span class="comment">//</span>
00489 <span class="comment">// Cache policy, PTE field aligned, as read from the processor configuration</span>
00490 <span class="comment">// register at startup.</span>
00491 <span class="comment">//</span>
00492 
00493     ULONG AlignedCachePolicy;
00494 
00495 <span class="comment">//</span>
00496 <span class="comment">// Flag for determining pending software interrupts</span>
00497 <span class="comment">//</span>
00498     <span class="keyword">union </span>{
00499         ULONG SoftwareInterrupt;        <span class="comment">// any bit 1 =&gt; some s/w interrupt pending</span>
00500         <span class="keyword">struct </span>{
00501             UCHAR ApcInterrupt;         <span class="comment">// 0x01 if APC int pending</span>
00502             UCHAR DispatchInterrupt;    <span class="comment">// 0x01 if dispatch int pending</span>
00503             UCHAR <a class="code" href="../../d4/d9/ke_8h.html#a407a221">Spare4</a>;
00504             UCHAR <a class="code" href="../../d4/d9/ke_8h.html#a407a222">Spare5</a>;
00505         };
00506     };
00507 
00508 <span class="comment">//</span>
00509 <span class="comment">// Complement of the processor affinity mask.</span>
00510 <span class="comment">//</span>
00511 
00512     KAFFINITY NotMember;
00513 
00514 <span class="comment">//</span>
00515 <span class="comment">// Space reserved for the system.</span>
00516 <span class="comment">//</span>
00517 
00518     ULONG   SystemReserved[16];
00519 
00520 <span class="comment">//</span>
00521 <span class="comment">// Space reserved for the HAL</span>
00522 <span class="comment">//</span>
00523 
00524     ULONG   HalReserved[16];
00525 
00526 <span class="comment">//</span>
00527 <span class="comment">// End of the architecturally defined section of the PCR. This section</span>
00528 <span class="comment">// may be directly addressed by vendor/platform specific HAL code and will</span>
00529 <span class="comment">// not change from version to version of NT.</span>
00530 <span class="comment">//</span>
00531 <span class="comment">// end_ntddk end_wdm end_nthal</span>
00532 
00533 <span class="comment">//</span>
00534 <span class="comment">// Start of the operating system release dependent section of the PCR.</span>
00535 <span class="comment">// This section may change from release to release and should not be</span>
00536 <span class="comment">// addressed by vendor/platform specific HAL code.</span>
00537 <span class="comment">//</span>
00538 <span class="comment">// Function active flags.</span>
00539 <span class="comment">//</span>
00540 
00541     ULONG FirstLevelActive;
00542 
00543 <span class="comment">//</span>
00544 <span class="comment">// System service dispatch start and end address used by get/set context.</span>
00545 <span class="comment">//</span>
00546 
00547     ULONG SystemServiceDispatchStart;
00548     ULONG SystemServiceDispatchEnd;
00549 
00550 <span class="comment">//</span>
00551 <span class="comment">// Interrupt stack.</span>
00552 <span class="comment">//</span>
00553 
00554     ULONG InterruptStack;
00555 
00556 <span class="comment">//</span>
00557 <span class="comment">// Quantum end flag.</span>
00558 <span class="comment">//</span>
00559 
00560     ULONG QuantumEnd;
00561 
00562 <span class="comment">//</span>
00563 <span class="comment">// Exception handler values.</span>
00564 <span class="comment">//</span>
00565 
00566     PVOID InitialStack;
00567     PVOID PanicStack;
00568     ULONG BadVaddr;
00569     PVOID StackLimit;
00570     PVOID SavedStackLimit;
00571     ULONG SavedV0;
00572     ULONG SavedV1;
00573     UCHAR DebugActive;
00574     UCHAR <a class="code" href="../../d4/d9/ke_8h.html#a407a223">Spare6</a>[3];
00575 
00576 <span class="comment">//</span>
00577 <span class="comment">// Save area for 6 GPRs on interrupt other than Storage interrupt.</span>
00578 <span class="comment">//</span>
00579     ULONG GprSave[6];
00580 
00581 <span class="comment">//</span>
00582 <span class="comment">// Save area for Instruction Storage and Data Storage interrupts.</span>
00583 <span class="comment">//</span>
00584 
00585     ULONG SiR0;
00586     ULONG SiR2;
00587     ULONG SiR3;
00588     ULONG SiR4;
00589     ULONG SiR5;
00590 
00591     ULONG Spare0;
00592     ULONG Spare8;
00593 
00594 <span class="comment">//</span>
00595 <span class="comment">// Real address of current process's Page Directory Page,</span>
00596 <span class="comment">// changed when process (address space) changes,</span>
00597 <span class="comment">// for use by Instruction Storage and Data Storage interrupts.</span>
00598 <span class="comment">//</span>
00599 
00600     ULONG PgDirRa;
00601 
00602 <span class="comment">//</span>
00603 <span class="comment">// On interrupt stack indicator and saved initial stack.</span>
00604 <span class="comment">//</span>
00605 
00606     ULONG OnInterruptStack;
00607     ULONG SavedInitialStack;
00608 
00609 } KPCR, *PKPCR;                     <span class="comment">// ntddk wdm nthal</span>
00610 
00611 <span class="comment">//</span>
00612 <span class="comment">// The PCR address on a particular processor is contained in</span>
00613 <span class="comment">//   SPRG 0 and 1.</span>
00614 <span class="comment">//        SPRG 0 -- Real address of PCR (used only by interrupt code)</span>
00615 <span class="comment">//        SPRG 1 -- Virtual address of PCR (used by kernel generally)</span>
00616 <span class="comment">//   These SPRGs are not accessable to user-mode code.</span>
00617 
00618 
00619 <span class="comment">//</span>
00620 <span class="comment">// Get Pointer to Processor Control Region</span>
00621 <span class="comment">//</span>
00622 <span class="comment">// KiGetPcr() is a two-instruction routine that just reads SPRG 1</span>
00623 <span class="comment">//   into reg 3 and returns.  Eventually this should be expanded in-line.</span>
00624 
00625 KPCR * KiGetPcr(VOID);
00626 
00627 <span class="comment">// begin_nthal</span>
00628 
00629 <span class="preprocessor">#define KIPCR2  0xffffe000              // kernel address of second PCR</span>
00630 <span class="preprocessor"></span><span class="preprocessor">#define KI_USER_SHARED_DATA KIPCR2</span>
00631 <span class="preprocessor"></span><span class="preprocessor">#define SharedUserData ((KUSER_SHARED_DATA * const)KIPCR2)</span>
00632 <span class="preprocessor"></span>
00633 <span class="comment">// begin_ntddk begin_wdm</span>
00634 
00635 <span class="preprocessor">#define KIPCR   0xffffd000              // kernel address of first PCR</span>
00636 <span class="preprocessor"></span>
00637 <span class="preprocessor">#define PCR ((volatile KPCR * const)KIPCR)</span>
00638 <span class="preprocessor"></span>
00639 <span class="preprocessor">#if defined(_M_PPC) &amp;&amp; defined(_MSC_VER) &amp;&amp; (_MSC_VER&gt;=1000)</span>
00640 <span class="preprocessor"></span><span class="keywordtype">unsigned</span> __sregister_get( <span class="keywordtype">unsigned</span> <span class="keyword">const</span> regnum );
00641 <span class="preprocessor">#define _PPC_SPRG1_ 273</span>
00642 <span class="preprocessor"></span><span class="preprocessor">#define PCRsprg1 ((volatile KPCR * volatile)__sregister_get(_PPC_SPRG1_))</span>
00643 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00644 <span class="preprocessor"></span>KPCR * __builtin_get_sprg1(VOID);
00645 <span class="preprocessor">#define PCRsprg1 ((volatile KPCR * volatile)__builtin_get_sprg1())</span>
00646 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00647 <span class="preprocessor"></span>
00648 <span class="comment">//</span>
00649 <span class="comment">// Macros for enabling and disabling system interrupts.</span>
00650 <span class="comment">//</span>
00651 <span class="comment">//BUGBUG - work around 603e/ev errata #15</span>
00652 <span class="comment">//  The instructions __emit'ed in these macros are "cror 0,0,0" instructions</span>
00653 <span class="comment">//  that force the mtmsr to complete before allowing any subsequent loads to</span>
00654 <span class="comment">//  issue.   The condition register no-op is executed in the system unit on</span>
00655 <span class="comment">//  the 603.  This will not dispatch until the mtmsr completes and will halt</span>
00656 <span class="comment">//  further dispatch.   On a 601 or 604 this instruction executes in the</span>
00657 <span class="comment">//  branch unit and will run in parallel (i.e., no performance penalty except</span>
00658 <span class="comment">//  for code bloat).</span>
00659 <span class="comment">//</span>
00660 
00661 <span class="preprocessor">#if defined(_M_PPC) &amp;&amp; defined(_MSC_VER) &amp;&amp; (_MSC_VER&gt;=1000)</span>
00662 <span class="preprocessor"></span>
00663 <span class="keywordtype">unsigned</span> __sregister_get( <span class="keywordtype">unsigned</span> <span class="keyword">const</span> regnum );
00664 <span class="keywordtype">void</span> __sregister_set( <span class="keywordtype">unsigned</span> <span class="keyword">const</span> regnum, <span class="keywordtype">unsigned</span> value );
00665 <span class="preprocessor">#define _PPC_MSR_ (unsigned)(~0x0)</span>
00666 <span class="preprocessor"></span><span class="preprocessor">#define _enable()  (__sregister_set(_PPC_MSR_, __sregister_get(_PPC_MSR_) | 0x00008000), __emit(0x4C000382))</span>
00667 <span class="preprocessor"></span><span class="preprocessor">#define _disable() (__sregister_set(_PPC_MSR_, __sregister_get(_PPC_MSR_) &amp; 0xffff7fff), __emit(0x4C000382))</span>
00668 <span class="preprocessor"></span><span class="preprocessor">#define __builtin_get_msr() __sregister_get(_PPC_MSR_)</span>
00669 <span class="preprocessor"></span>
00670 <span class="preprocessor">#else</span>
00671 <span class="preprocessor"></span>
00672 ULONG __builtin_get_msr(VOID);
00673 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>  __builtin_set_msr(ULONG);
00674 <span class="preprocessor">#define _enable()  (__builtin_set_msr(__builtin_get_msr() | 0x00008000), __builtin_isync())</span>
00675 <span class="preprocessor"></span><span class="preprocessor">#define _disable() (__builtin_set_msr(__builtin_get_msr() &amp; 0xffff7fff), __builtin_isync())</span>
00676 <span class="preprocessor"></span>
00677 <span class="preprocessor">#endif</span>
00678 <span class="preprocessor"></span>
00679 <span class="comment">//</span>
00680 <span class="comment">// Get current IRQL.</span>
00681 <span class="comment">//</span>
00682 
00683 <span class="preprocessor">#define KeGetCurrentIrql() PCR-&gt;CurrentIrql</span>
00684 <span class="preprocessor"></span>
00685 <span class="comment">//</span>
00686 <span class="comment">// Get address of current processor block.</span>
00687 <span class="comment">//</span>
00688 
00689 <span class="preprocessor">#define KeGetCurrentPrcb() PCR-&gt;Prcb</span>
00690 <span class="preprocessor"></span>
00691 <span class="comment">//</span>
00692 <span class="comment">// Get address of processor control region.</span>
00693 <span class="comment">//</span>
00694 
00695 <span class="preprocessor">#define KeGetPcr() PCR</span>
00696 <span class="preprocessor"></span>
00697 <span class="comment">//</span>
00698 <span class="comment">// Get address of current kernel thread object.</span>
00699 <span class="comment">//</span>
00700 
00701 <span class="preprocessor">#define KeGetCurrentThread() PCR-&gt;CurrentThread</span>
00702 <span class="preprocessor"></span>
00703 <span class="comment">//</span>
00704 <span class="comment">// Get Processor Version Register</span>
00705 <span class="comment">//</span>
00706 
00707 <span class="preprocessor">#if defined(_M_PPC) &amp;&amp; defined(_MSC_VER) &amp;&amp; (_MSC_VER&gt;=1000)</span>
00708 <span class="preprocessor"></span><span class="keywordtype">unsigned</span> __sregister_get( <span class="keywordtype">unsigned</span> <span class="keyword">const</span> regnum );
00709 <span class="preprocessor">#define _PPC_PVR_ 287</span>
00710 <span class="preprocessor"></span><span class="preprocessor">#define KeGetPvr() __sregister_get(_PPC_PVR_)</span>
00711 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00712 <span class="preprocessor"></span>ULONG __builtin_get_pvr(VOID);
00713 <span class="preprocessor">#define KeGetPvr() __builtin_get_pvr()</span>
00714 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00715 <span class="preprocessor"></span>
00716 <span class="comment">// end_wdm</span>
00717 <span class="comment">//</span>
00718 <span class="comment">// Get current processor number.</span>
00719 <span class="comment">//</span>
00720 
00721 <span class="preprocessor">#define KeGetCurrentProcessorNumber() PCR-&gt;Number</span>
00722 <span class="preprocessor"></span>
00723 <span class="comment">// begin_wdm</span>
00724 <span class="comment">//</span>
00725 <span class="comment">// Get data cache fill size.</span>
00726 <span class="comment">//</span>
00727 <span class="comment">// **FINISH**  See that proper PowerPC parameter is accessed here</span>
00728 
00729 <span class="preprocessor">#define KeGetDcacheFillSize() PCR-&gt;DcacheFillSize</span>
00730 <span class="preprocessor"></span>
00731 <span class="comment">// end_ntddk end_wdm end_nthal</span>
00732 
00733 <span class="comment">//</span>
00734 <span class="comment">// Get previous processor mode.</span>
00735 <span class="comment">//</span>
00736 
00737 <span class="preprocessor">#define KeGetPreviousMode() (KPROCESSOR_MODE)PCR-&gt;CurrentThread-&gt;PreviousMode</span>
00738 <span class="preprocessor"></span>
00739 <span class="comment">//</span>
00740 <span class="comment">// Test if executing a DPC.</span>
00741 <span class="comment">//</span>
00742 
00743 BOOLEAN
00744 KeIsExecutingDpc (
00745     VOID
00746     );
00747 
00748 <span class="comment">// begin_ntddk begin_wdm</span>
00749 <span class="comment">//</span>
00750 <span class="comment">// Save &amp; Restore floating point state</span>
00751 <span class="comment">//</span>
00752 
00753 <span class="preprocessor">#define KeSaveFloatingPointState(a)         STATUS_SUCCESS</span>
00754 <span class="preprocessor"></span><span class="preprocessor">#define KeRestoreFloatingPointState(a)      STATUS_SUCCESS</span>
00755 <span class="preprocessor"></span>
00756 <span class="comment">// end_ntddk end_wdm</span>
00757 
00758 <span class="comment">// begin_nthal</span>
00759 <span class="comment">//</span>
00760 <span class="comment">// Fill TB random entry</span>
00761 <span class="comment">//</span>
00762 
00763 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00764 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00765 KeFillEntryTb (
00766     IN HARDWARE_PTE Pte[2],
00767     IN PVOID Virtual,
00768     IN BOOLEAN Invalid
00769     );
00770 
00771 <span class="comment">//</span>
00772 <span class="comment">// Data cache, instruction cache, I/O buffer, and write buffer flush routine</span>
00773 <span class="comment">// prototypes.</span>
00774 <span class="comment">//</span>
00775 
00776 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00777 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00778 <a class="code" href="../../d3/d5/ppc_2flush_8c.html#a5">KeChangeColorPage</a> (
00779     IN PVOID NewColor,
00780     IN PVOID OldColor,
00781     IN ULONG PageFrame
00782     );
00783 
00784 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00785 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00786 <a class="code" href="../../d3/d5/ppc_2flush_8c.html#a6">KeSweepDcache</a> (
00787     IN BOOLEAN AllProcessors
00788     );
00789 
00790 <span class="preprocessor">#define KeSweepCurrentDcache() \</span>
00791 <span class="preprocessor">    HalSweepDcache();</span>
00792 <span class="preprocessor"></span>
00793 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00794 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00795 <a class="code" href="../../d3/d5/ppc_2flush_8c.html#a7">KeSweepIcache</a> (
00796     IN BOOLEAN AllProcessors
00797     );
00798 
00799 <span class="preprocessor">#define KeSweepCurrentIcache() \</span>
00800 <span class="preprocessor">    HalSweepIcache();          \</span>
00801 <span class="preprocessor">    HalSweepDcache();</span>
00802 <span class="preprocessor"></span>
00803 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00804 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00805 <a class="code" href="../../d3/d5/ppc_2flush_8c.html#a8">KeSweepIcacheRange</a> (
00806     IN BOOLEAN AllProcessors,
00807     IN PVOID BaseAddress,
00808     IN ULONG Length
00809     );
00810 
00811 <span class="comment">// begin_ntddk begin_wdm begin_ntndis</span>
00812 <span class="comment">//</span>
00813 <span class="comment">// Cache and write buffer flush functions.</span>
00814 <span class="comment">//</span>
00815 
00816 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00817 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00818 <a class="code" href="../../d3/d5/ppc_2flush_8c.html#a9">KeFlushIoBuffers</a> (
00819     IN <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> Mdl,
00820     IN BOOLEAN ReadOperation,
00821     IN BOOLEAN DmaOperation
00822     );
00823 
00824 <span class="comment">// end_ntddk end_wdm end_ntndis</span>
00825 
00826 <span class="comment">//</span>
00827 <span class="comment">// Clock, profile, and interprocessor interrupt functions.</span>
00828 <span class="comment">//</span>
00829 
00830 <span class="keyword">struct </span>_KEXCEPTION_FRAME;
00831 <span class="keyword">struct </span>_KTRAP_FRAME;
00832 
00833 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00834 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00835 KeIpiInterrupt (
00836     IN <span class="keyword">struct</span> _KTRAP_FRAME *TrapFrame
00837     );
00838 
00839 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00840 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00841 <a class="code" href="../../d1/d9/clock_8c.html#a5">KeProfileInterrupt</a> (
00842     IN <span class="keyword">struct</span> _KTRAP_FRAME *TrapFrame
00843     );
00844 
00845 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00846 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00847 <a class="code" href="../../d1/d9/clock_8c.html#a6">KeProfileInterruptWithSource</a> (
00848     IN <span class="keyword">struct</span> _KTRAP_FRAME *TrapFrame,
00849     IN KPROFILE_SOURCE ProfileSource
00850     );
00851 
00852 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00853 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00854 <a class="code" href="../../d1/d9/clock_8c.html#a3">KeUpdateRunTime</a> (
00855     IN <span class="keyword">struct</span> _KTRAP_FRAME *TrapFrame
00856     );
00857 
00858 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00859 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00860 <a class="code" href="../../d1/d9/clock_8c.html#a2">KeUpdateSystemTime</a> (
00861     IN <span class="keyword">struct</span> _KTRAP_FRAME *TrapFrame,
00862     IN ULONG TimeIncrement
00863     );
00864 
00865 <span class="comment">//</span>
00866 <span class="comment">// Spin lock function prototypes (empty for uniprocessor).</span>
00867 <span class="comment">// Exported for use in MP HALs.</span>
00868 <span class="comment">//</span>
00869 
00870 <span class="preprocessor">#if defined(NT_UP)</span>
00871 <span class="preprocessor"></span>
00872 <span class="preprocessor">#define KiAcquireSpinLock(SpinLock)</span>
00873 <span class="preprocessor"></span>
00874 <span class="preprocessor">#else</span>
00875 <span class="preprocessor"></span>
00876 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00877 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00878 KiAcquireSpinLock (
00879     IN PKSPIN_LOCK SpinLock
00880     );
00881 
00882 <span class="preprocessor">#endif</span>
00883 <span class="preprocessor"></span>
00884 <span class="preprocessor">#if defined(NT_UP)</span>
00885 <span class="preprocessor"></span>
00886 <span class="preprocessor">#define KiReleaseSpinLock(SpinLock)</span>
00887 <span class="preprocessor"></span>
00888 <span class="preprocessor">#else</span>
00889 <span class="preprocessor"></span>
00890 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00891 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00892 KiReleaseSpinLock (
00893     IN PKSPIN_LOCK SpinLock
00894     );
00895 
00896 <span class="preprocessor">#endif</span>
00897 <span class="preprocessor"></span><span class="comment">// end_nthal</span>
00898 
00899 
00900 <span class="comment">//</span>
00901 <span class="comment">// Define executive macros for acquiring and releasing executive spinlocks.</span>
00902 <span class="comment">// These macros can ONLY be used by executive components and NOT by drivers.</span>
00903 <span class="comment">// Drivers MUST use the kernel interfaces since they must be MP enabled on</span>
00904 <span class="comment">// all systems.</span>
00905 <span class="comment">//</span>
00906 <span class="comment">// On PPC, raise/lower IRQL are in the HAL, but KeRaiseIrqlToDpcLevel (raising to a</span>
00907 <span class="comment">// software level) is in the kernel.</span>
00908 <span class="comment">//</span>
00909 
00910 <span class="comment">// begin_ntddk begin_nthal</span>
00911 
00912 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00913 KIRQL
00914 KfRaiseIrqlToDpcLevel (
00915     VOID
00916     );
00917 
00918 <span class="preprocessor">#define KeRaiseIrqlToDpcLevel(OldIrql) (*(OldIrql) = KfRaiseIrqlToDpcLevel())</span>
00919 <span class="preprocessor"></span>
00920 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00921 KIRQL
00922 KeRaiseIrqlToSynchLevel (
00923     VOID
00924     );
00925 
00926 <span class="comment">// end_ntddk end_nthal</span>
00927 <span class="preprocessor">#if defined(NT_UP) &amp;&amp; !defined(_NTDDK_) &amp;&amp; !defined(_NTIFS_)</span>
00928 <span class="preprocessor"></span><span class="preprocessor">#define ExAcquireSpinLock(Lock, OldIrql) KeRaiseIrqlToDpcLevel((OldIrql))</span>
00929 <span class="preprocessor"></span><span class="preprocessor">#define ExReleaseSpinLock(Lock, OldIrql) KeLowerIrql((OldIrql))</span>
00930 <span class="preprocessor"></span><span class="preprocessor">#define ExAcquireSpinLockAtDpcLevel(Lock)</span>
00931 <span class="preprocessor"></span><span class="preprocessor">#define ExReleaseSpinLockFromDpcLevel(Lock)</span>
00932 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00933 <span class="preprocessor"></span>
00934 <span class="comment">// begin_wdm begin_ntddk</span>
00935 <span class="preprocessor">#define ExAcquireSpinLock(Lock, OldIrql) KeAcquireSpinLock((Lock), (OldIrql))</span>
00936 <span class="preprocessor"></span><span class="preprocessor">#define ExReleaseSpinLock(Lock, OldIrql) KeReleaseSpinLock((Lock), (OldIrql))</span>
00937 <span class="preprocessor"></span><span class="preprocessor">#define ExAcquireSpinLockAtDpcLevel(Lock) KeAcquireSpinLockAtDpcLevel(Lock)</span>
00938 <span class="preprocessor"></span><span class="preprocessor">#define ExReleaseSpinLockFromDpcLevel(Lock) KeReleaseSpinLockFromDpcLevel(Lock)</span>
00939 <span class="preprocessor"></span><span class="comment">// end_wdm end_ntddk</span>
00940 
00941 <span class="preprocessor">#endif</span>
00942 <span class="preprocessor"></span>
00943 <span class="comment">//</span>
00944 <span class="comment">// The acquire and release fast lock macros disable and enable interrupts</span>
00945 <span class="comment">// on UP nondebug systems. On MP or debug systems, the spinlock routines</span>
00946 <span class="comment">// are used.</span>
00947 <span class="comment">//</span>
00948 <span class="comment">// N.B. Extreme caution should be observed when using these routines.</span>
00949 <span class="comment">//</span>
00950 
00951 <span class="preprocessor">#if defined(NT_UP) &amp;&amp; !DBG</span>
00952 <span class="preprocessor"></span><span class="preprocessor">#define ExAcquireFastLock(Lock, OldIrql) _disable()</span>
00953 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00954 <span class="preprocessor"></span><span class="preprocessor">#define ExAcquireFastLock(Lock, OldIrql) \</span>
00955 <span class="preprocessor">    ExAcquireSpinLock(Lock, OldIrql)</span>
00956 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00957 <span class="preprocessor"></span>
00958 <span class="preprocessor">#if defined(NT_UP) &amp;&amp; !DBG</span>
00959 <span class="preprocessor"></span><span class="preprocessor">#define ExReleaseFastLock(Lock, OldIrql) _enable()</span>
00960 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00961 <span class="preprocessor"></span><span class="preprocessor">#define ExReleaseFastLock(Lock, OldIrql) \</span>
00962 <span class="preprocessor">    ExReleaseSpinLock(Lock, OldIrql)</span>
00963 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00964 <span class="preprocessor"></span>
00965 
00966 
00967 <span class="comment">//</span>
00968 <span class="comment">// Define query system time macro.</span>
00969 <span class="comment">//</span>
00970 
00971 <span class="preprocessor">#define KiQuerySystemTime(CurrentTime)                                  \</span>
00972 <span class="preprocessor">    do {                                                                \</span>
00973 <span class="preprocessor">        (CurrentTime)-&gt;HighPart = SharedUserData-&gt;SystemTime.High1Time; \</span>
00974 <span class="preprocessor">        (CurrentTime)-&gt;LowPart = SharedUserData-&gt;SystemTime.LowPart;    \</span>
00975 <span class="preprocessor">    } while ((CurrentTime)-&gt;HighPart != SharedUserData-&gt;SystemTime.High2Time)</span>
00976 <span class="preprocessor"></span>
00977 <span class="comment">//</span>
00978 <span class="comment">// Define query tick count macro.</span>
00979 <span class="comment">//</span>
00980 
00981 <span class="preprocessor">#if defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_)</span>
00982 <span class="preprocessor"></span>
00983 <span class="comment">//  begin_wdm begin_ntddk</span>
00984 
00985 <span class="preprocessor">#define KeQueryTickCount(CurrentCount) { \</span>
00986 <span class="preprocessor">    PKSYSTEM_TIME _TickCount = *((PKSYSTEM_TIME *)(&amp;KeTickCount)); \</span>
00987 <span class="preprocessor">    do {                                                           \</span>
00988 <span class="preprocessor">        (CurrentCount)-&gt;HighPart = _TickCount-&gt;High1Time;          \</span>
00989 <span class="preprocessor">        (CurrentCount)-&gt;LowPart = _TickCount-&gt;LowPart;             \</span>
00990 <span class="preprocessor">    } while ((CurrentCount)-&gt;HighPart != _TickCount-&gt;High2Time);    \</span>
00991 <span class="preprocessor">}</span>
00992 <span class="preprocessor"></span>
00993 <span class="comment">//  end_wdm end_ntddk</span>
00994 
00995 <span class="preprocessor">#else</span>
00996 <span class="preprocessor"></span>
00997 <span class="comment">// begin_nthal</span>
00998 <span class="preprocessor">#define KiQueryTickCount(CurrentCount) \</span>
00999 <span class="preprocessor">    do {                                                        \</span>
01000 <span class="preprocessor">        (CurrentCount)-&gt;HighPart = KeTickCount.High1Time;       \</span>
01001 <span class="preprocessor">        (CurrentCount)-&gt;LowPart = KeTickCount.LowPart;          \</span>
01002 <span class="preprocessor">    } while ((CurrentCount)-&gt;HighPart != KeTickCount.High2Time)</span>
01003 <span class="preprocessor"></span>
01004 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01005 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01006 <a class="code" href="../../d7/d0/ke_2miscc_8c.html#a4">KeQueryTickCount</a> (
01007     OUT PLARGE_INTEGER CurrentCount
01008     );
01009 
01010 <span class="comment">// end_nthal</span>
01011 <span class="preprocessor">#endif</span>
01012 <span class="preprocessor"></span>
01013 <span class="preprocessor">#define KiQueryLowTickCount() KeTickCount.LowPart</span>
01014 <span class="preprocessor"></span>
01015 <span class="comment">//</span>
01016 <span class="comment">// Define query interrupt time macro.</span>
01017 <span class="comment">//</span>
01018 
01019 <span class="preprocessor">#define KiQueryInterruptTime(CurrentTime)                                   \</span>
01020 <span class="preprocessor">    do {                                                                    \</span>
01021 <span class="preprocessor">        (CurrentTime)-&gt;HighPart = SharedUserData-&gt;InterruptTime.High1Time;  \</span>
01022 <span class="preprocessor">        (CurrentTime)-&gt;LowPart = SharedUserData-&gt;InterruptTime.LowPart;     \</span>
01023 <span class="preprocessor">    } while ((CurrentTime)-&gt;HighPart != SharedUserData-&gt;InterruptTime.High2Time)</span>
01024 <span class="preprocessor"></span>
01025 
01026 <span class="comment">//</span>
01027 <span class="comment">// The following function prototypes must be in the module since they are</span>
01028 <span class="comment">// machine dependent.</span>
01029 <span class="comment">//</span>
01030 
01031 <span class="comment">//</span>
01032 <span class="comment">// Raise and lower IRQL</span>
01033 <span class="comment">//</span>
01034 
01035 ULONG
01036 <a class="code" href="../../d7/d1/branchem_8c.html#a0">KiEmulateBranch</a> (
01037     IN <span class="keyword">struct</span> _KEXCEPTION_FRAME *ExceptionFrame,
01038     IN <span class="keyword">struct</span> _KTRAP_FRAME *TrapFrame
01039     );
01040 
01041 BOOLEAN
01042 <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a32">KiEmulateFloating</a> (
01043     IN OUT PEXCEPTION_RECORD ExceptionRecord,
01044     IN OUT <span class="keyword">struct</span> _KEXCEPTION_FRAME *ExceptionFrame,
01045     IN OUT <span class="keyword">struct</span> _KTRAP_FRAME *TrapFrame
01046     );
01047 
01048 BOOLEAN
01049 <a class="code" href="../../d7/d5/ppc_2alignem_8c.html#a18">KiEmulateReference</a> (
01050     IN OUT PEXCEPTION_RECORD ExceptionRecord,
01051     IN OUT <span class="keyword">struct</span> _KEXCEPTION_FRAME *ExceptionFrame,
01052     IN OUT <span class="keyword">struct</span> _KTRAP_FRAME *TrapFrame
01053     );
01054 
01055 ULONG
01056 <a class="code" href="../../d8/d5/ppc_2getsetrg_8c.html#a0">KiGetRegisterValue</a> (
01057     IN ULONG Register,
01058     IN <span class="keyword">struct</span> _KEXCEPTION_FRAME *ExceptionFrame,
01059     IN <span class="keyword">struct</span> _KTRAP_FRAME *TrapFrame
01060     );
01061 
01062 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01063 <a class="code" href="../../d8/d5/ppc_2getsetrg_8c.html#a1">KiSetRegisterValue</a> (
01064     IN ULONG Register,
01065     IN ULONG Value,
01066     OUT <span class="keyword">struct</span> _KEXCEPTION_FRAME *ExceptionFrame,
01067     OUT <span class="keyword">struct</span> _KTRAP_FRAME *TrapFrame
01068     );
01069 
01070 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01071 <a class="code" href="../../d9/d4/intsupc_8c.html#a3">KiRequestSoftwareInterrupt</a> (
01072     ULONG RequestIrql
01073     );
01074 
01075 
01076 
01077 
01078 <span class="comment">// begin_ntddk begin_wdm begin_nthal begin_ntndis</span>
01079 
01080 <span class="comment">//</span>
01081 <span class="comment">// I/O space read and write macros.</span>
01082 <span class="comment">//</span>
01083 <span class="comment">// **FINISH** Ensure that these are appropriate for PowerPC</span>
01084 
01085 <span class="preprocessor">#define READ_REGISTER_UCHAR(x) \</span>
01086 <span class="preprocessor">    *(volatile UCHAR * const)(x)</span>
01087 <span class="preprocessor"></span>
01088 <span class="preprocessor">#define READ_REGISTER_USHORT(x) \</span>
01089 <span class="preprocessor">    *(volatile USHORT * const)(x)</span>
01090 <span class="preprocessor"></span>
01091 <span class="preprocessor">#define READ_REGISTER_ULONG(x) \</span>
01092 <span class="preprocessor">    *(volatile ULONG * const)(x)</span>
01093 <span class="preprocessor"></span>
01094 <span class="preprocessor">#define READ_REGISTER_BUFFER_UCHAR(x, y, z) {                           \</span>
01095 <span class="preprocessor">    PUCHAR registerBuffer = x;                                          \</span>
01096 <span class="preprocessor">    PUCHAR readBuffer = y;                                              \</span>
01097 <span class="preprocessor">    ULONG readCount;                                                    \</span>
01098 <span class="preprocessor">    for (readCount = z; readCount--; readBuffer++, registerBuffer++) {  \</span>
01099 <span class="preprocessor">        *readBuffer = *(volatile UCHAR * const)(registerBuffer);        \</span>
01100 <span class="preprocessor">    }                                                                   \</span>
01101 <span class="preprocessor">}</span>
01102 <span class="preprocessor"></span>
01103 <span class="preprocessor">#define READ_REGISTER_BUFFER_USHORT(x, y, z) {                          \</span>
01104 <span class="preprocessor">    PUSHORT registerBuffer = x;                                         \</span>
01105 <span class="preprocessor">    PUSHORT readBuffer = y;                                             \</span>
01106 <span class="preprocessor">    ULONG readCount;                                                    \</span>
01107 <span class="preprocessor">    for (readCount = z; readCount--; readBuffer++, registerBuffer++) {  \</span>
01108 <span class="preprocessor">        *readBuffer = *(volatile USHORT * const)(registerBuffer);       \</span>
01109 <span class="preprocessor">    }                                                                   \</span>
01110 <span class="preprocessor">}</span>
01111 <span class="preprocessor"></span>
01112 <span class="preprocessor">#define READ_REGISTER_BUFFER_ULONG(x, y, z) {                           \</span>
01113 <span class="preprocessor">    PULONG registerBuffer = x;                                          \</span>
01114 <span class="preprocessor">    PULONG readBuffer = y;                                              \</span>
01115 <span class="preprocessor">    ULONG readCount;                                                    \</span>
01116 <span class="preprocessor">    for (readCount = z; readCount--; readBuffer++, registerBuffer++) {  \</span>
01117 <span class="preprocessor">        *readBuffer = *(volatile ULONG * const)(registerBuffer);        \</span>
01118 <span class="preprocessor">    }                                                                   \</span>
01119 <span class="preprocessor">}</span>
01120 <span class="preprocessor"></span>
01121 <span class="preprocessor">#define WRITE_REGISTER_UCHAR(x, y) {    \</span>
01122 <span class="preprocessor">    *(volatile UCHAR * const)(x) = y;   \</span>
01123 <span class="preprocessor">    KeFlushWriteBuffer();               \</span>
01124 <span class="preprocessor">}</span>
01125 <span class="preprocessor"></span>
01126 <span class="preprocessor">#define WRITE_REGISTER_USHORT(x, y) {   \</span>
01127 <span class="preprocessor">    *(volatile USHORT * const)(x) = y;  \</span>
01128 <span class="preprocessor">    KeFlushWriteBuffer();               \</span>
01129 <span class="preprocessor">}</span>
01130 <span class="preprocessor"></span>
01131 <span class="preprocessor">#define WRITE_REGISTER_ULONG(x, y) {    \</span>
01132 <span class="preprocessor">    *(volatile ULONG * const)(x) = y;   \</span>
01133 <span class="preprocessor">    KeFlushWriteBuffer();               \</span>
01134 <span class="preprocessor">}</span>
01135 <span class="preprocessor"></span>
01136 <span class="preprocessor">#define WRITE_REGISTER_BUFFER_UCHAR(x, y, z) {                            \</span>
01137 <span class="preprocessor">    PUCHAR registerBuffer = x;                                            \</span>
01138 <span class="preprocessor">    PUCHAR writeBuffer = y;                                               \</span>
01139 <span class="preprocessor">    ULONG writeCount;                                                     \</span>
01140 <span class="preprocessor">    for (writeCount = z; writeCount--; writeBuffer++, registerBuffer++) { \</span>
01141 <span class="preprocessor">        *(volatile UCHAR * const)(registerBuffer) = *writeBuffer;         \</span>
01142 <span class="preprocessor">    }                                                                     \</span>
01143 <span class="preprocessor">    KeFlushWriteBuffer();                                                 \</span>
01144 <span class="preprocessor">}</span>
01145 <span class="preprocessor"></span>
01146 <span class="preprocessor">#define WRITE_REGISTER_BUFFER_USHORT(x, y, z) {                           \</span>
01147 <span class="preprocessor">    PUSHORT registerBuffer = x;                                           \</span>
01148 <span class="preprocessor">    PUSHORT writeBuffer = y;                                              \</span>
01149 <span class="preprocessor">    ULONG writeCount;                                                     \</span>
01150 <span class="preprocessor">    for (writeCount = z; writeCount--; writeBuffer++, registerBuffer++) { \</span>
01151 <span class="preprocessor">        *(volatile USHORT * const)(registerBuffer) = *writeBuffer;        \</span>
01152 <span class="preprocessor">    }                                                                     \</span>
01153 <span class="preprocessor">    KeFlushWriteBuffer();                                                 \</span>
01154 <span class="preprocessor">}</span>
01155 <span class="preprocessor"></span>
01156 <span class="preprocessor">#define WRITE_REGISTER_BUFFER_ULONG(x, y, z) {                            \</span>
01157 <span class="preprocessor">    PULONG registerBuffer = x;                                            \</span>
01158 <span class="preprocessor">    PULONG writeBuffer = y;                                               \</span>
01159 <span class="preprocessor">    ULONG writeCount;                                                     \</span>
01160 <span class="preprocessor">    for (writeCount = z; writeCount--; writeBuffer++, registerBuffer++) { \</span>
01161 <span class="preprocessor">        *(volatile ULONG * const)(registerBuffer) = *writeBuffer;         \</span>
01162 <span class="preprocessor">    }                                                                     \</span>
01163 <span class="preprocessor">    KeFlushWriteBuffer();                                                 \</span>
01164 <span class="preprocessor">}</span>
01165 <span class="preprocessor"></span>
01166 
01167 <span class="preprocessor">#define READ_PORT_UCHAR(x) \</span>
01168 <span class="preprocessor">    *(volatile UCHAR * const)(x)</span>
01169 <span class="preprocessor"></span>
01170 <span class="preprocessor">#define READ_PORT_USHORT(x) \</span>
01171 <span class="preprocessor">    *(volatile USHORT * const)(x)</span>
01172 <span class="preprocessor"></span>
01173 <span class="preprocessor">#define READ_PORT_ULONG(x) \</span>
01174 <span class="preprocessor">    *(volatile ULONG * const)(x)</span>
01175 <span class="preprocessor"></span>
01176 <span class="preprocessor">#define READ_PORT_BUFFER_UCHAR(x, y, z) {                             \</span>
01177 <span class="preprocessor">    PUCHAR readBuffer = y;                                            \</span>
01178 <span class="preprocessor">    ULONG readCount;                                                  \</span>
01179 <span class="preprocessor">    for (readCount = 0; readCount &lt; z; readCount++, readBuffer++) {   \</span>
01180 <span class="preprocessor">        *readBuffer = *(volatile UCHAR * const)(x);                   \</span>
01181 <span class="preprocessor">    }                                                                 \</span>
01182 <span class="preprocessor">}</span>
01183 <span class="preprocessor"></span>
01184 <span class="preprocessor">#define READ_PORT_BUFFER_USHORT(x, y, z) {                            \</span>
01185 <span class="preprocessor">    PUSHORT readBuffer = y;                                            \</span>
01186 <span class="preprocessor">    ULONG readCount;                                                  \</span>
01187 <span class="preprocessor">    for (readCount = 0; readCount &lt; z; readCount++, readBuffer++) {   \</span>
01188 <span class="preprocessor">        *readBuffer = *(volatile USHORT * const)(x);                  \</span>
01189 <span class="preprocessor">    }                                                                 \</span>
01190 <span class="preprocessor">}</span>
01191 <span class="preprocessor"></span>
01192 <span class="preprocessor">#define READ_PORT_BUFFER_ULONG(x, y, z) {                             \</span>
01193 <span class="preprocessor">    PULONG readBuffer = y;                                            \</span>
01194 <span class="preprocessor">    ULONG readCount;                                                  \</span>
01195 <span class="preprocessor">    for (readCount = 0; readCount &lt; z; readCount++, readBuffer++) {   \</span>
01196 <span class="preprocessor">        *readBuffer = *(volatile ULONG * const)(x);                   \</span>
01197 <span class="preprocessor">    }                                                                 \</span>
01198 <span class="preprocessor">}</span>
01199 <span class="preprocessor"></span>
01200 <span class="preprocessor">#define WRITE_PORT_UCHAR(x, y) {        \</span>
01201 <span class="preprocessor">    *(volatile UCHAR * const)(x) = y;   \</span>
01202 <span class="preprocessor">    KeFlushWriteBuffer();               \</span>
01203 <span class="preprocessor">}</span>
01204 <span class="preprocessor"></span>
01205 <span class="preprocessor">#define WRITE_PORT_USHORT(x, y) {       \</span>
01206 <span class="preprocessor">    *(volatile USHORT * const)(x) = y;  \</span>
01207 <span class="preprocessor">    KeFlushWriteBuffer();               \</span>
01208 <span class="preprocessor">}</span>
01209 <span class="preprocessor"></span>
01210 <span class="preprocessor">#define WRITE_PORT_ULONG(x, y) {        \</span>
01211 <span class="preprocessor">    *(volatile ULONG * const)(x) = y;   \</span>
01212 <span class="preprocessor">    KeFlushWriteBuffer();               \</span>
01213 <span class="preprocessor">}</span>
01214 <span class="preprocessor"></span>
01215 <span class="preprocessor">#define WRITE_PORT_BUFFER_UCHAR(x, y, z) {                                \</span>
01216 <span class="preprocessor">    PUCHAR writeBuffer = y;                                               \</span>
01217 <span class="preprocessor">    ULONG writeCount;                                                     \</span>
01218 <span class="preprocessor">    for (writeCount = 0; writeCount &lt; z; writeCount++, writeBuffer++) {   \</span>
01219 <span class="preprocessor">        *(volatile UCHAR * const)(x) = *writeBuffer;                      \</span>
01220 <span class="preprocessor">        KeFlushWriteBuffer();                                             \</span>
01221 <span class="preprocessor">    }                                                                     \</span>
01222 <span class="preprocessor">}</span>
01223 <span class="preprocessor"></span>
01224 <span class="preprocessor">#define WRITE_PORT_BUFFER_USHORT(x, y, z) {                               \</span>
01225 <span class="preprocessor">    PUSHORT writeBuffer = y;                                              \</span>
01226 <span class="preprocessor">    ULONG writeCount;                                                     \</span>
01227 <span class="preprocessor">    for (writeCount = 0; writeCount &lt; z; writeCount++, writeBuffer++) {   \</span>
01228 <span class="preprocessor">        *(volatile USHORT * const)(x) = *writeBuffer;                     \</span>
01229 <span class="preprocessor">        KeFlushWriteBuffer();                                             \</span>
01230 <span class="preprocessor">    }                                                                     \</span>
01231 <span class="preprocessor">}</span>
01232 <span class="preprocessor"></span>
01233 <span class="preprocessor">#define WRITE_PORT_BUFFER_ULONG(x, y, z) {                                \</span>
01234 <span class="preprocessor">    PULONG writeBuffer = y;                                               \</span>
01235 <span class="preprocessor">    ULONG writeCount;                                                     \</span>
01236 <span class="preprocessor">    for (writeCount = 0; writeCount &lt; z; writeCount++, writeBuffer++) {   \</span>
01237 <span class="preprocessor">        *(volatile ULONG * const)(x) = *writeBuffer;                      \</span>
01238 <span class="preprocessor">        KeFlushWriteBuffer();                                             \</span>
01239 <span class="preprocessor">    }                                                                     \</span>
01240 <span class="preprocessor">}</span>
01241 <span class="preprocessor"></span>
01242 <span class="comment">// end_ntddk end_wdm end_nthal end_ntndis</span>
01243 
01244 
01245 <span class="comment">//</span>
01246 <span class="comment">// Masks for Dr7 and sanitize macros for various debug registers.</span>
01247 <span class="comment">//</span>
01248 <span class="preprocessor">#define DR6_LEGAL   0x0000e00f</span>
01249 <span class="preprocessor"></span>
01250 <span class="preprocessor">#define DR7_LEGAL   0xffff0155</span>
01251 <span class="preprocessor"></span>
01252 <span class="preprocessor">#define DR7_ACTIVE  0x00000055  // If any of these bits are set a debug</span>
01253 <span class="preprocessor"></span>                                <span class="comment">// register is active providing Dr6</span>
01254                                 <span class="comment">// indicates DR available</span>
01255 <span class="preprocessor">#define SANITIZE_DR6(Dr6, mode) ((Dr6 &amp; DR6_LEGAL));</span>
01256 <span class="preprocessor"></span>
01257 <span class="preprocessor">#define SANITIZE_DR7(Dr7, mode) ((Dr7 &amp; DR7_LEGAL));</span>
01258 <span class="preprocessor"></span>
01259 <span class="preprocessor">#define SANITIZE_DRADDR(DrReg, mode) (                \</span>
01260 <span class="preprocessor">    (mode) == KernelMode ?                            \</span>
01261 <span class="preprocessor">        (DrReg):                                      \</span>
01262 <span class="preprocessor">        (((PVOID)DrReg &lt;= MM_HIGHEST_USER_ADDRESS) ?  \</span>
01263 <span class="preprocessor">        (DrReg):                                      \</span>
01264 <span class="preprocessor">            (0)                                       \</span>
01265 <span class="preprocessor">        )                                             \</span>
01266 <span class="preprocessor">    )</span>
01267 <span class="preprocessor"></span>
01268 <span class="comment">// begin_nthal</span>
01269 <span class="comment">//</span>
01270 <span class="comment">// Trap Frame  --  Volatile state</span>
01271 <span class="comment">//</span>
01272 <span class="comment">//  N.B. This frame must be a multiple of 8 bytes in length, as the</span>
01273 <span class="comment">//       Stack Frame header (see ntppc.h), Trap Frame and Exception Frame</span>
01274 <span class="comment">//       together must make up a valid call stack frame.</span>
01275 <span class="comment">//</span>
01276 
01277 <span class="comment">//  CR fields 0, 1, 5..7 are volatile and appear here</span>
01278 <span class="comment">//  CR fields 2..4 are non-volatile and appear in the Exception Frame</span>
01279 
01280 <span class="preprocessor">#define CR_VOLATILE_FIELDS 0xFF000FFFL</span>
01281 <span class="preprocessor"></span>
01282 <span class="keyword">typedef</span> <span class="keyword">struct </span>_KTRAP_FRAME {
01283 
01284     PVOID TrapFrame;                    <span class="comment">// previous trap frame address</span>
01285 
01286     UCHAR OldIrql;
01287     UCHAR PreviousMode;
01288     UCHAR SavedApcStateIndex;
01289     UCHAR SavedKernelApcDisable;
01290 
01291 <span class="comment">// Exception Record embedded in the Trap Frame, on 8-byte boundary,</span>
01292 <span class="comment">// padded to multiple of 8 bytes</span>
01293 
01294     UCHAR ExceptionRecord[(<span class="keyword">sizeof</span>(EXCEPTION_RECORD) + 7) &amp; (~7)];
01295 
01296     ULONG FILL2;
01297 
01298 <span class="comment">// General registers 0 thru 12</span>
01299 
01300     ULONG  Gpr0;
01301     ULONG  Gpr1;
01302     ULONG  Gpr2;
01303     ULONG  Gpr3;
01304     ULONG  Gpr4;
01305     ULONG  Gpr5;
01306     ULONG  Gpr6;
01307     ULONG  Gpr7;
01308     ULONG  Gpr8;
01309     ULONG  Gpr9;
01310     ULONG  Gpr10;
01311     ULONG  Gpr11;
01312     ULONG  Gpr12;
01313 
01314 <span class="comment">// Floating point registers 0 thru 13</span>
01315 
01316     DOUBLE Fpr0;                <span class="comment">// 8-byte boundary required here</span>
01317     DOUBLE Fpr1;
01318     DOUBLE Fpr2;
01319     DOUBLE Fpr3;
01320     DOUBLE Fpr4;
01321     DOUBLE Fpr5;
01322     DOUBLE Fpr6;
01323     DOUBLE Fpr7;
01324     DOUBLE Fpr8;
01325     DOUBLE Fpr9;
01326     DOUBLE Fpr10;
01327     DOUBLE Fpr11;
01328     DOUBLE Fpr12;
01329     DOUBLE Fpr13;
01330 
01331 <span class="comment">// Floating Point Status and Control Register</span>
01332 
01333     DOUBLE Fpscr;
01334 
01335 <span class="comment">// Other volatile control registers</span>
01336 
01337     ULONG  Cr;     <span class="comment">// Only CR fields 0, 1, 5..7 are volatile, but the</span>
01338                    <span class="comment">// entire CR is saved here on interrupt</span>
01339     ULONG  Xer;
01340     ULONG  Msr;
01341     ULONG  Iar;
01342     ULONG  Lr;
01343     ULONG  Ctr;
01344 
01345 <span class="comment">// Debug Registers</span>
01346 
01347     ULONG  Dr0;
01348     ULONG  Dr1;
01349     ULONG  Dr2;
01350     ULONG  Dr3;
01351     ULONG  Dr4;
01352     ULONG  Dr5;
01353     ULONG  Dr6;
01354     ULONG  Dr7;
01355 
01356 } KTRAP_FRAME, *PKTRAP_FRAME;
01357 
01358 <span class="preprocessor">#define KTRAP_FRAME_LENGTH ((sizeof(KTRAP_FRAME) + 7) &amp; (~7))</span>
01359 <span class="preprocessor"></span><span class="preprocessor">#define KTRAP_FRAME_ALIGN (sizeof(DOUBLE))</span>
01360 <span class="preprocessor"></span><span class="preprocessor">#define KTRAP_FRAME_ROUND (KTRAP_FRAME_ALIGN - 1)</span>
01361 <span class="preprocessor"></span>
01362 <span class="comment">// end_nthal</span>
01363 <span class="comment">//</span>
01364 <span class="comment">// The frame saved by KiCallUserMode is defined here to allow</span>
01365 <span class="comment">// the kernel debugger to trace the entire kernel stack</span>
01366 <span class="comment">// when usermode callouts are pending.</span>
01367 <span class="comment">//</span>
01368 
01369 <span class="keyword">typedef</span> <span class="keyword">struct </span>_KCALLOUT_FRAME {
01370     STACK_FRAME_HEADER Frame;
01371     ULONG   CbStk;              <span class="comment">// saved callback stack address</span>
01372     ULONG   TrFr;               <span class="comment">// saved callback trap frame address</span>
01373     ULONG   InStk;              <span class="comment">// saved initial stack address</span>
01374     ULONG   <a class="code" href="../../d8/d7/halppc_8h.html#a332">TrIar</a>;              <span class="comment">// saved trap IAR</span>
01375     ULONG   TrToc;              <span class="comment">// saved trap TOC</span>
01376     ULONG   R3;                 <span class="comment">// saved R3 (OutputBuffer)</span>
01377     ULONG   R4;                 <span class="comment">// saved R4 (OutputLength)</span>
01378     ULONG   Lr;                 <span class="comment">// saved LR</span>
01379     ULONG   Gpr[18];            <span class="comment">// all nonvolatile GPRs</span>
01380     DOUBLE  Fpr[18];            <span class="comment">// all nonvolatile FPRs</span>
01381 } KCALLOUT_FRAME, *PKCALLOUT_FRAME;
01382 
01383 <span class="keyword">typedef</span> <span class="keyword">struct </span>_UCALLOUT_FRAME {
01384     STACK_FRAME_HEADER Frame;
01385     PVOID <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>;
01386     ULONG Length;
01387     ULONG ApiNumber;
01388     ULONG Lr;
01389     ULONG Toc;
01390     ULONG Pad;
01391 } UCALLOUT_FRAME, *PUCALLOUT_FRAME;
01392 
01393 
01394 <span class="comment">// begin_nthal</span>
01395 <span class="comment">//</span>
01396 <span class="comment">// Exception frame  --  NON-VOLATILE state</span>
01397 <span class="comment">//</span>
01398 <span class="comment">// This structure's layout matches that of the registers as saved</span>
01399 <span class="comment">// in a call/return stack frame, where the called program has saved</span>
01400 <span class="comment">// all the non-volatile registers.</span>
01401 <span class="comment">//</span>
01402 <span class="comment">// N.B. This frame must be a multiple of 8 bytes in length, as the</span>
01403 <span class="comment">//      Stack Frame header (see ntppc.h), Trap Frame and the Exception</span>
01404 <span class="comment">//      Frame together must make up a valid call stack frame.</span>
01405 <span class="comment">//</span>
01406 
01407 <span class="keyword">typedef</span> <span class="keyword">struct </span>_KEXCEPTION_FRAME {
01408 
01409     ULONG  Fill1;                       <span class="comment">// padding</span>
01410 
01411     ULONG  Gpr13;
01412     ULONG  Gpr14;
01413     ULONG  Gpr15;
01414     ULONG  Gpr16;
01415     ULONG  Gpr17;
01416     ULONG  Gpr18;
01417     ULONG  Gpr19;
01418     ULONG  Gpr20;
01419     ULONG  Gpr21;
01420     ULONG  Gpr22;
01421     ULONG  Gpr23;
01422     ULONG  Gpr24;
01423     ULONG  Gpr25;
01424     ULONG  Gpr26;
01425     ULONG  Gpr27;
01426     ULONG  Gpr28;
01427     ULONG  Gpr29;
01428     ULONG  Gpr30;
01429     ULONG  Gpr31;
01430 
01431     DOUBLE Fpr14;               <span class="comment">// 8-byte boundary required here</span>
01432     DOUBLE Fpr15;
01433     DOUBLE Fpr16;
01434     DOUBLE Fpr17;
01435     DOUBLE Fpr18;
01436     DOUBLE Fpr19;
01437     DOUBLE Fpr20;
01438     DOUBLE Fpr21;
01439     DOUBLE Fpr22;
01440     DOUBLE Fpr23;
01441     DOUBLE Fpr24;
01442     DOUBLE Fpr25;
01443     DOUBLE Fpr26;
01444     DOUBLE Fpr27;
01445     DOUBLE Fpr28;
01446     DOUBLE Fpr29;
01447     DOUBLE Fpr30;
01448     DOUBLE Fpr31;
01449 
01450 } KEXCEPTION_FRAME, *PKEXCEPTION_FRAME;
01451 
01452 <span class="comment">// end_nthal</span>
01453 <span class="comment">//</span>
01454 <span class="comment">// Special version of exception frame for use by SwapContext and</span>
01455 <span class="comment">// KiInitializeContextThread.</span>
01456 <span class="comment">//</span>
01457 
01458 <span class="keyword">typedef</span> <span class="keyword">struct </span>_KSWAP_FRAME {
01459     KEXCEPTION_FRAME ExceptionFrame;
01460     ULONG ConditionRegister;
01461     ULONG SwapReturn;
01462 } KSWAP_FRAME, *PKSWAP_FRAME;
01463 
01464 
01465 <span class="comment">// begin_ntddk begin_wdm</span>
01466 <span class="comment">//</span>
01467 <span class="comment">// Non-volatile floating point state</span>
01468 <span class="comment">//</span>
01469 
01470 <span class="keyword">typedef</span> <span class="keyword">struct </span>_KFLOATING_SAVE {
01471     ULONG   Reserved;
01472 } KFLOATING_SAVE, *PKFLOATING_SAVE;
01473 
01474 <span class="comment">// end_ntddk end_wdm</span>
01475 <span class="comment">//</span>
01476 <span class="comment">// Format of stack frame during exceptions.</span>
01477 <span class="comment">//</span>
01478 
01479 <span class="preprocessor">#define STK_SLACK_SPACE 232</span>
01480 <span class="preprocessor"></span>
01481 <span class="keyword">typedef</span> <span class="keyword">struct </span>_KEXCEPTION_STACK_FRAME {
01482     STACK_FRAME_HEADER <a class="code" href="../../d3/d3/dumpuser_8c.html#a17">Header</a>;
01483     ULONG AdditionalParameters[8];
01484     KTRAP_FRAME TrapFrame;
01485     KEXCEPTION_FRAME ExceptionFrame;
01486     PVOID Lr;
01487     PVOID Cr;
01488     UCHAR SlackSpace[STK_SLACK_SPACE];
01489 } KEXCEPTION_STACK_FRAME, *PKEXCEPTION_STACK_FRAME;
01490 
01491 <span class="comment">// begin_nthal</span>
01492 <span class="comment">// begin_windbgkd</span>
01493 
01494 <span class="preprocessor">#ifdef _PPC_</span>
01495 <span class="preprocessor"></span><span class="comment">//</span>
01496 <span class="comment">// Special Registers for PowerPC</span>
01497 <span class="comment">//</span>
01498 
01499 <span class="keyword">typedef</span> <span class="keyword">struct </span>_KSPECIAL_REGISTERS {
01500     ULONG  KernelDr0;
01501     ULONG  KernelDr1;
01502     ULONG  KernelDr2;
01503     ULONG  KernelDr3;
01504     ULONG  KernelDr4;
01505     ULONG  KernelDr5;
01506     ULONG  KernelDr6;
01507     ULONG  KernelDr7;
01508     ULONG  Sprg0;
01509     ULONG  Sprg1;
01510     ULONG  Sr0;
01511     ULONG  Sr1;
01512     ULONG  Sr2;
01513     ULONG  Sr3;
01514     ULONG  Sr4;
01515     ULONG  Sr5;
01516     ULONG  Sr6;
01517     ULONG  Sr7;
01518     ULONG  Sr8;
01519     ULONG  Sr9;
01520     ULONG  Sr10;
01521     ULONG  Sr11;
01522     ULONG  Sr12;
01523     ULONG  Sr13;
01524     ULONG  Sr14;
01525     ULONG  Sr15;
01526     ULONG  DBAT0L;
01527     ULONG  DBAT0U;
01528     ULONG  DBAT1L;
01529     ULONG  DBAT1U;
01530     ULONG  DBAT2L;
01531     ULONG  DBAT2U;
01532     ULONG  DBAT3L;
01533     ULONG  DBAT3U;
01534     ULONG  IBAT0L;
01535     ULONG  IBAT0U;
01536     ULONG  IBAT1L;
01537     ULONG  IBAT1U;
01538     ULONG  IBAT2L;
01539     ULONG  IBAT2U;
01540     ULONG  IBAT3L;
01541     ULONG  IBAT3U;
01542     ULONG  Sdr1;
01543     ULONG  Reserved[9];
01544 } KSPECIAL_REGISTERS, *PKSPECIAL_REGISTERS;
01545 
01546 <span class="comment">//</span>
01547 <span class="comment">// Processor State structure.</span>
01548 <span class="comment">//</span>
01549 
01550 <span class="keyword">typedef</span> <span class="keyword">struct </span>_KPROCESSOR_STATE {
01551     <span class="keyword">struct </span>_CONTEXT ContextFrame;
01552     <span class="keyword">struct </span>_KSPECIAL_REGISTERS SpecialRegisters;
01553 } KPROCESSOR_STATE, *PKPROCESSOR_STATE;
01554 
01555 <span class="preprocessor">#endif // _PPC_</span>
01556 <span class="preprocessor"></span><span class="comment">// end_windbgkd</span>
01557 
01558 <span class="comment">//</span>
01559 <span class="comment">// Processor Control Block (PRCB)</span>
01560 <span class="comment">//</span>
01561 
01562 <span class="preprocessor">#define PRCB_MINOR_VERSION 1</span>
01563 <span class="preprocessor"></span><span class="preprocessor">#define PRCB_MAJOR_VERSION 1</span>
01564 <span class="preprocessor"></span><span class="preprocessor">#define PRCB_BUILD_DEBUG        0x0001</span>
01565 <span class="preprocessor"></span><span class="preprocessor">#define PRCB_BUILD_UNIPROCESSOR 0x0002</span>
01566 <span class="preprocessor"></span>
01567 <span class="keyword">struct </span><a class="code" href="../../d5/d4/struct__RESTART__BLOCK.html">_RESTART_BLOCK</a>;
01568 
01569 <span class="keyword">typedef</span> <span class="keyword">struct </span>_KPRCB {
01570 
01571 <span class="comment">//</span>
01572 <span class="comment">// Major and minor version numbers of the PCR.</span>
01573 <span class="comment">//</span>
01574 
01575     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> MinorVersion;
01576     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> MajorVersion;
01577 
01578 <span class="comment">//</span>
01579 <span class="comment">// Start of the architecturally defined section of the PRCB. This section</span>
01580 <span class="comment">// may be directly addressed by vendor/platform specific HAL code and will</span>
01581 <span class="comment">// not change from version to version of NT.</span>
01582 <span class="comment">//</span>
01583 
01584     <span class="keyword">struct </span><a class="code" href="../../d1/d8/struct__KTHREAD.html">_KTHREAD</a> *CurrentThread;
01585     <span class="keyword">struct </span><a class="code" href="../../d1/d8/struct__KTHREAD.html">_KTHREAD</a> *RESTRICTED_POINTER NextThread;
01586     <span class="keyword">struct </span><a class="code" href="../../d1/d8/struct__KTHREAD.html">_KTHREAD</a> *IdleThread;
01587     CCHAR Number;
01588     CCHAR Reserved;
01589     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> BuildType;
01590     KAFFINITY <a class="code" href="../../d0/d0/ki_8h.html#a7">SetMember</a>;
01591     <span class="keyword">struct </span><a class="code" href="../../d5/d4/struct__RESTART__BLOCK.html">_RESTART_BLOCK</a> *RestartBlock;
01592     ULONG PcrPage;
01593     ULONG PcrPage2;
01594 
01595 <span class="comment">//</span>
01596 <span class="comment">// Space reserved for the system.</span>
01597 <span class="comment">//</span>
01598 
01599     ULONG SystemReserved[15];
01600 
01601 <span class="comment">//</span>
01602 <span class="comment">// Space reserved for the HAL.</span>
01603 <span class="comment">//</span>
01604 
01605     ULONG HalReserved[16];
01606 
01607 <span class="comment">// End of the architecturally defined section of the PRCB.</span>
01608 <span class="comment">// end_nthal</span>
01609 <span class="comment">//</span>
01610 
01611     ULONG DpcTime;
01612     ULONG InterruptTime;
01613     ULONG KernelTime;
01614     ULONG UserTime;
01615     ULONG AdjustDpcThreshold;
01616     ULONG InterruptCount;
01617     ULONG ApcBypassCount;
01618     ULONG DpcBypassCount;
01619     ULONG <a class="code" href="../../d4/d9/ke_8h.html#a407a223">Spare6</a>[5];
01620 
01621 <span class="comment">//</span>
01622 <span class="comment">// MP information.</span>
01623 <span class="comment">//</span>
01624 
01625     PVOID Spare1;
01626     PVOID <a class="code" href="../../d4/d9/ke_8h.html#a407a219">Spare2</a>;
01627     <span class="keyword">volatile</span> ULONG IpiFrozen;
01628     <span class="keyword">struct </span>_KPROCESSOR_STATE ProcessorState;
01629 
01630 <span class="comment">//</span>
01631 <span class="comment">//  Per-processor data for various hot code which resides in the</span>
01632 <span class="comment">//  kernel image. Each processor is given its own copy of the data</span>
01633 <span class="comment">//  to lessen the cache impact of sharing the data between multiple</span>
01634 <span class="comment">//  processors.</span>
01635 <span class="comment">//</span>
01636 
01637 <span class="comment">//</span>
01638 <span class="comment">//  Spares (formerly fsrtl filelock free lists)</span>
01639 <span class="comment">//</span>
01640 
01641     PVOID SpareHotData[2];
01642 
01643 <span class="comment">//</span>
01644 <span class="comment">//  Cache manager performance counters.</span>
01645 <span class="comment">//</span>
01646 
01647     ULONG <a class="code" href="../../d5/d2/cachedat_8c.html#a44">CcFastReadNoWait</a>;
01648     ULONG <a class="code" href="../../d5/d2/cachedat_8c.html#a45">CcFastReadWait</a>;
01649     ULONG <a class="code" href="../../d5/d2/cachedat_8c.html#a47">CcFastReadNotPossible</a>;
01650     ULONG <a class="code" href="../../d5/d2/cachedat_8c.html#a61">CcCopyReadNoWait</a>;
01651     ULONG <a class="code" href="../../d5/d2/cachedat_8c.html#a62">CcCopyReadWait</a>;
01652     ULONG <a class="code" href="../../d5/d2/cachedat_8c.html#a63">CcCopyReadNoWaitMiss</a>;
01653 
01654 <span class="comment">//</span>
01655 <span class="comment">// Kernel performance counters.</span>
01656 <span class="comment">//</span>
01657 
01658     ULONG KeAlignmentFixupCount;
01659     ULONG KeContextSwitches;
01660     ULONG <a class="code" href="../../d5/d9/kernldat_8c.html#a13">KeDcacheFlushCount</a>;
01661     ULONG KeExceptionDispatchCount;
01662     ULONG KeFirstLevelTbFills;
01663     ULONG KeFloatingEmulationCount;
01664     ULONG <a class="code" href="../../d5/d9/kernldat_8c.html#a14">KeIcacheFlushCount</a>;
01665     ULONG KeSecondLevelTbFills;
01666     ULONG KeSystemCalls;
01667 
01668     ULONG PagedPoolLookasideHits;
01669 
01670 <span class="comment">//</span>
01671 <span class="comment">//  Reserved for future counters.</span>
01672 <span class="comment">//</span>
01673 
01674     ULONG ReservedCounter[14];
01675 
01676 <span class="comment">//</span>
01677 <span class="comment">// Reserved pad.</span>
01678 <span class="comment">//</span>
01679 
01680     <span class="keyword">union </span>{
01681         ULONG ReservedPad[16 * 8];
01682         PVOID PagedFreeEntry[<a class="code" href="../../d0/d9/ntosdef_8h.html#a2">POOL_SMALL_LISTS</a>];
01683     };
01684 
01685 <span class="comment">//</span>
01686 <span class="comment">// MP interprocessor request packet and summary.</span>
01687 <span class="comment">//</span>
01688 <span class="comment">// N.B. This is carefully aligned to be on a cache line boundary.</span>
01689 <span class="comment">//</span>
01690 
01691     <span class="keyword">volatile</span> PVOID CurrentPacket[3];
01692     <span class="keyword">volatile</span> KAFFINITY TargetSet;
01693     <span class="keyword">volatile</span> <a class="code" href="../../d0/d9/ntosdef_8h.html#a55">PKIPI_WORKER</a> WorkerRoutine;
01694     ULONG CachePad1[3];
01695 
01696 <span class="comment">//</span>
01697 <span class="comment">// N.B. These two longwords must be on a quadword boundary and adjacent.</span>
01698 <span class="comment">//</span>
01699 
01700     <span class="keyword">volatile</span> ULONG RequestSummary;
01701     <span class="keyword">volatile</span> <span class="keyword">struct </span>_KPRCB *SignalDone;
01702     ULONG CachePad2[6];
01703 
01704 <span class="comment">//</span>
01705 <span class="comment">// DPC interrupt requested.</span>
01706 <span class="comment">//</span>
01707 
01708     ULONG DpcInterruptRequested;
01709     ULONG CachePad3[7];
01710 
01711 <span class="comment">//</span>
01712 <span class="comment">// DPC batching parameters.</span>
01713 <span class="comment">//</span>
01714 
01715     ULONG MaximumDpcQueueDepth;
01716     ULONG MinimumDpcRate;
01717 
01718 <span class="comment">//</span>
01719 <span class="comment">// Spare counters.</span>
01720 <span class="comment">//</span>
01721 
01722     ULONG <a class="code" href="../../d4/d9/ke_8h.html#a407a221">Spare4</a>[2];
01723 
01724 <span class="comment">//</span>
01725 <span class="comment">// I/O system per processor single entry lookaside lists.</span>
01726 <span class="comment">//</span>
01727 
01728     PVOID SmallIrpFreeEntry;
01729     PVOID LargeIrpFreeEntry;
01730     PVOID MdlFreeEntry;
01731 
01732 <span class="comment">//</span>
01733 <span class="comment">// Object manager per processor single entry lookaside lists.</span>
01734 <span class="comment">//</span>
01735 
01736     PVOID CreateInfoFreeEntry;
01737     PVOID NameBufferFreeEntry;
01738 
01739 <span class="comment">//</span>
01740 <span class="comment">// Cache manager per processor single entry lookaside lists.</span>
01741 <span class="comment">//</span>
01742 
01743     PVOID SharedCacheMapEntry;
01744 
01745 <span class="comment">//</span>
01746 <span class="comment">// Spares.</span>
01747 <span class="comment">//</span>
01748 
01749     ULONG <a class="code" href="../../d4/d9/ke_8h.html#a407a222">Spare5</a>[2];
01750 
01751 <span class="comment">//</span>
01752 <span class="comment">// Address of MP interprocessor operation counters.</span>
01753 <span class="comment">//</span>
01754 
01755     <a class="code" href="../../d1/d7/struct__KIPI__COUNTS.html">PKIPI_COUNTS</a> IpiCounts;
01756     LARGE_INTEGER StartCount;
01757 
01758 <span class="comment">//</span>
01759 <span class="comment">// DPC list head, spinlock, and count.</span>
01760 <span class="comment">//</span>
01761 
01762     KSPIN_LOCK DpcLock;
01763     LIST_ENTRY DpcListHead;
01764     ULONG DpcQueueDepth;
01765     ULONG DpcCount;
01766     ULONG DpcLastCount;
01767     ULONG DpcRequestRate;
01768     ULONG DpcRoutineActive;
01769     BOOLEAN SkipTick;
01770     ULONG CachePad4[5];
01771 
01772 <span class="comment">//</span>
01773 <span class="comment">// Processors power state</span>
01774 <span class="comment">//</span>
01775     PROCESSOR_POWER_STATE PowerState;
01776 
01777 
01778 } KPRCB, *PKPRCB, *RESTRICTED_POINTER PRKPRCB;  <span class="comment">// nthal</span>
01779 
01780 <span class="comment">// begin_ntddk begin_wdm begin_nthal begin_ntndis</span>
01781 <span class="comment">//</span>
01782 <span class="comment">// PowerPC page size = 4 KB</span>
01783 <span class="comment">//</span>
01784 
01785 <span class="preprocessor">#define PAGE_SIZE (ULONG)0x1000</span>
01786 <span class="preprocessor"></span>
01787 <span class="comment">//</span>
01788 <span class="comment">// Define the number of trailing zeroes in a page aligned virtual address.</span>
01789 <span class="comment">// This is used as the shift count when shifting virtual addresses to</span>
01790 <span class="comment">// virtual page numbers.</span>
01791 <span class="comment">//</span>
01792 
01793 <span class="preprocessor">#define PAGE_SHIFT 12L</span>
01794 <span class="preprocessor"></span>
01795 <span class="comment">// end_ntddk end_wdm end_ntndis</span>
01796 
01797 <span class="comment">//</span>
01798 <span class="comment">// Define the number of bits to shift to right justify the Page Directory Index</span>
01799 <span class="comment">// field of a PTE.</span>
01800 <span class="comment">//</span>
01801 
01802 <span class="preprocessor">#define PDI_SHIFT 22</span>
01803 <span class="preprocessor"></span>
01804 <span class="comment">//</span>
01805 <span class="comment">// Define the number of bits to shift to right justify the Page Table Index</span>
01806 <span class="comment">// field of a PTE.</span>
01807 <span class="comment">//</span>
01808 
01809 <span class="preprocessor">#define PTI_SHIFT 12</span>
01810 <span class="preprocessor"></span>
01811 <span class="comment">// begin_ntddk</span>
01812 <span class="comment">//</span>
01813 <span class="comment">// The highest user address reserves 64K bytes for a guard page. This</span>
01814 <span class="comment">// the probing of address from kernel mode to only have to check the</span>
01815 <span class="comment">// starting address for structures of 64k bytes or less.</span>
01816 <span class="comment">//</span>
01817 
01818 <span class="preprocessor">#define MM_HIGHEST_USER_ADDRESS (PVOID)0x7FFEFFFF // highest user address</span>
01819 <span class="preprocessor"></span><span class="preprocessor">#define MM_SYSTEM_RANGE_START (PVOID)KSEG0_BASE // start of system space</span>
01820 <span class="preprocessor"></span><span class="preprocessor">#define MM_USER_PROBE_ADDRESS 0x7FFF0000 // starting address of guard page</span>
01821 <span class="preprocessor"></span>
01822 <span class="comment">//</span>
01823 <span class="comment">// The following definitions are required for the debugger data block.</span>
01824 <span class="comment">//</span>
01825 
01826 <span class="keyword">extern</span> PVOID <a class="code" href="../../d0/d9/miglobal_8c.html#a0">MmHighestUserAddress</a>;
01827 <span class="keyword">extern</span> PVOID <a class="code" href="../../d0/d9/miglobal_8c.html#a1">MmSystemRangeStart</a>;
01828 <span class="keyword">extern</span> ULONG <a class="code" href="../../d0/d9/miglobal_8c.html#a2">MmUserProbeAddress</a>;
01829 
01830 <span class="comment">//</span>
01831 <span class="comment">// The lowest user address reserves the low 64k.</span>
01832 <span class="comment">//</span>
01833 
01834 <span class="preprocessor">#define MM_LOWEST_USER_ADDRESS  (PVOID)0x00010000</span>
01835 <span class="preprocessor"></span>
01836 <span class="comment">// begin_wdm</span>
01837 
01838 <span class="preprocessor">#define MmGetProcedureAddress(Address) *((PVOID *)(Address))</span>
01839 <span class="preprocessor"></span><span class="preprocessor">#define MmLockPagableCodeSection(Address) MmLockPagableDataSection(*((PVOID *)(Address)))</span>
01840 <span class="preprocessor"></span>
01841 <span class="comment">// end_ntddk end_wdm</span>
01842 <span class="comment">//</span>
01843 <span class="comment">// Define the page table and the page directory base for</span>
01844 <span class="comment">// memory management.</span>
01845 <span class="comment">//</span>
01846 
01847 <span class="preprocessor">#define PDE_BASE (ULONG)0xC0300000</span>
01848 <span class="preprocessor"></span><span class="preprocessor">#define PTE_BASE (ULONG)0xC0000000</span>
01849 <span class="preprocessor"></span>
01850 <span class="comment">// begin_ntddk begin_wdm</span>
01851 <span class="comment">//</span>
01852 <span class="comment">// The lowest address for system space.</span>
01853 <span class="comment">//</span>
01854 
01855 <span class="preprocessor">#define MM_LOWEST_SYSTEM_ADDRESS (PVOID)0x80000000</span>
01856 <span class="preprocessor"></span><span class="preprocessor">#define SYSTEM_BASE 0x80000000          // start of system space (no typecast)</span>
01857 <span class="preprocessor"></span>
01858 <span class="comment">// begin_ntndis</span>
01859 <span class="preprocessor">#endif // defined(_PPC_)</span>
01860 <span class="preprocessor"></span><span class="comment">// end_ntddk end_wdm end_nthal end_ntndis</span>
01861 <span class="comment">// Special comment moved for hal.h since mips.h defines UNCACHED_POLICY</span>
01862 <span class="comment">// in  unconditional code which is placed in the hal header file.</span>
01863 
01864 <span class="comment">//</span>
01865 <span class="comment">// Define uncache policies.</span>
01866 <span class="comment">//</span>
01867 <span class="comment">// **FINISH** Check that these values are even needed for PPC.</span>
01868 <span class="comment">//</span>
01869 
<a name="l01870"></a><a class="code" href="../../d0/d3/ppc_8h.html#a0">01870</a> <span class="preprocessor">#define UNCACHED_POLICY 2               // uncached</span>
01871 <span class="preprocessor"></span>
01872 <span class="comment">//</span>
01873 <span class="comment">// Registers visible only to the operating system</span>
01874 <span class="comment">//</span>
01875 
01876 <span class="comment">//</span>
01877 <span class="comment">// Define Data Storage Interrupt Status Register (DSISR)</span>
01878 <span class="comment">//</span>
01879 
<a name="l01880"></a><a class="code" href="../../d7/d9/struct__DSISR.html">01880</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d7/d9/struct__DSISR.html">_DSISR</a> {
<a name="l01881"></a><a class="code" href="../../d7/d9/struct__DSISR.html#o0">01881</a>     ULONG <a class="code" href="../../d7/d9/struct__DSISR.html#o0">UpdateReg</a> :  5;  <span class="comment">// RA field for update-form instrs</span>
<a name="l01882"></a><a class="code" href="../../d7/d9/struct__DSISR.html#o1">01882</a>     ULONG <a class="code" href="../../d7/d9/struct__DSISR.html#o1">DataReg</a>   :  5;  <span class="comment">// RA, RS, FRA, or FRT field of instr</span>
<a name="l01883"></a><a class="code" href="../../d7/d9/struct__DSISR.html#o2">01883</a>     ULONG <a class="code" href="../../d7/d9/struct__DSISR.html#o2">Index</a>     :  7;  <span class="comment">// Index into table to distinguish instrs</span>
<a name="l01884"></a><a class="code" href="../../d7/d9/struct__DSISR.html#o3">01884</a>     ULONG <a class="code" href="../../d7/d9/struct__DSISR.html#o3">Fill2</a>     :  1;
<a name="l01885"></a><a class="code" href="../../d7/d9/struct__DSISR.html#o4">01885</a>     ULONG <a class="code" href="../../d7/d9/struct__DSISR.html#o4">XO</a>        :  2;  <span class="comment">// Extended op-code for DS-form instrs</span>
<a name="l01886"></a><a class="code" href="../../d7/d9/struct__DSISR.html#o5">01886</a>     ULONG <a class="code" href="../../d7/d9/struct__DSISR.html#o5">Fill1</a>     : 12;
01887 } <a class="code" href="../../d7/d9/struct__DSISR.html">DSISR</a>, *<a class="code" href="../../d7/d9/struct__DSISR.html">PDSISR</a>;
01888 
01889 <a class="code" href="../../d7/d9/struct__DSISR.html">DSISR</a> <a class="code" href="../../d0/d3/ppc_8h.html#a19">KiGetDsisr</a> ();             <span class="comment">// Function to read the DSISR</span>
01890 <span class="keywordtype">void</span>  <a class="code" href="../../d0/d3/ppc_8h.html#a20">KiSetDsisr</a> (<a class="code" href="../../d7/d9/struct__DSISR.html">DSISR</a> Value);  <span class="comment">// Function to write the DSISR</span>
01891 
01892 <span class="comment">//</span>
01893 <span class="comment">// PowerPC function definitions</span>
01894 <span class="comment">//</span>
01895 
01896 <span class="comment">//++</span>
01897 <span class="comment">//</span>
01898 <span class="comment">// BOOLEAN</span>
01899 <span class="comment">// KiIsThreadNumericStateSaved(</span>
01900 <span class="comment">//     IN PKTHREAD Address</span>
01901 <span class="comment">//     )</span>
01902 <span class="comment">//</span>
01903 <span class="comment">//  This call is used on a not running thread to see if its numeric</span>
01904 <span class="comment">//  state has been saved in its context information.</span>
01905 <span class="comment">//</span>
01906 <span class="comment">//  **FINISH**  PowerPC is eventually to use lazy FP state-save,</span>
01907 <span class="comment">//              but for now we'll always save the FP state.</span>
01908 <span class="comment">//</span>
01909 <span class="comment">//--</span>
01910 
<a name="l01911"></a><a class="code" href="../../d0/d3/ppc_8h.html#a1">01911</a> <span class="preprocessor">#define KiIsThreadNumericStateSaved(a)      TRUE</span>
01912 <span class="preprocessor"></span>
01913 <span class="comment">//++</span>
01914 <span class="comment">//</span>
01915 <span class="comment">// VOID</span>
01916 <span class="comment">// KiRundownThread(</span>
01917 <span class="comment">//     IN PKTHREAD Address</span>
01918 <span class="comment">//     )</span>
01919 <span class="comment">//</span>
01920 <span class="comment">//--</span>
01921 
<a name="l01922"></a><a class="code" href="../../d0/d3/ppc_8h.html#a2">01922</a> <span class="preprocessor">#define KiRundownThread(a)</span>
01923 <span class="preprocessor"></span>
01924 <span class="comment">//</span>
01925 <span class="comment">// Define macro to test if x86 feature is present.</span>
01926 <span class="comment">//</span>
01927 <span class="comment">// N.B. All x86 features test TRUE on PPC systems.</span>
01928 <span class="comment">//</span>
01929 
<a name="l01930"></a><a class="code" href="../../d0/d3/ppc_8h.html#a3">01930</a> <span class="preprocessor">#define Isx86FeaturePresent(_f_) TRUE</span>
01931 <span class="preprocessor"></span>
01932 <span class="comment">//</span>
01933 <span class="comment">// Symbolic values for exception entry</span>
01934 <span class="comment">//</span>
<a name="l01935"></a><a class="code" href="../../d0/d3/ppc_8h.html#a4">01935</a> <span class="preprocessor">#define ppc_machine_check               1</span>
<a name="l01936"></a><a class="code" href="../../d0/d3/ppc_8h.html#a5">01936</a> <span class="preprocessor"></span><span class="preprocessor">#define ppc_data_storage                2</span>
<a name="l01937"></a><a class="code" href="../../d0/d3/ppc_8h.html#a6">01937</a> <span class="preprocessor"></span><span class="preprocessor">#define ppc_instruction_storage         3</span>
<a name="l01938"></a><a class="code" href="../../d0/d3/ppc_8h.html#a7">01938</a> <span class="preprocessor"></span><span class="preprocessor">#define ppc_external                    4</span>
<a name="l01939"></a><a class="code" href="../../d0/d3/ppc_8h.html#a8">01939</a> <span class="preprocessor"></span><span class="preprocessor">#define ppc_alignment                   5</span>
<a name="l01940"></a><a class="code" href="../../d0/d3/ppc_8h.html#a9">01940</a> <span class="preprocessor"></span><span class="preprocessor">#define ppc_program                     6</span>
<a name="l01941"></a><a class="code" href="../../d0/d3/ppc_8h.html#a10">01941</a> <span class="preprocessor"></span><span class="preprocessor">#define ppc_fp_unavailable              7</span>
<a name="l01942"></a><a class="code" href="../../d0/d3/ppc_8h.html#a11">01942</a> <span class="preprocessor"></span><span class="preprocessor">#define ppc_decrementer                 8</span>
<a name="l01943"></a><a class="code" href="../../d0/d3/ppc_8h.html#a12">01943</a> <span class="preprocessor"></span><span class="preprocessor">#define ppc_direct_store_error          9</span>
<a name="l01944"></a><a class="code" href="../../d0/d3/ppc_8h.html#a13">01944</a> <span class="preprocessor"></span><span class="preprocessor">#define ppc_syscall                     10</span>
<a name="l01945"></a><a class="code" href="../../d0/d3/ppc_8h.html#a14">01945</a> <span class="preprocessor"></span><span class="preprocessor">#define ppc_trace                       11</span>
<a name="l01946"></a><a class="code" href="../../d0/d3/ppc_8h.html#a15">01946</a> <span class="preprocessor"></span><span class="preprocessor">#define ppc_fp_assist                   12</span>
<a name="l01947"></a><a class="code" href="../../d0/d3/ppc_8h.html#a16">01947</a> <span class="preprocessor"></span><span class="preprocessor">#define ppc_run_mode                    13</span>
01948 <span class="preprocessor"></span>
01949 <span class="preprocessor">#endif // _PPCH_</span>
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:41:25 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
