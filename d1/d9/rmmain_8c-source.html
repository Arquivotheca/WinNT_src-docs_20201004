<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: rmmain.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>rmmain.c</h1><a href="../../d0/d0/rmmain_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1991  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    rmmain.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    Security Reference Monitor - Init, Control and State Change</span>
00012 <span class="comment"></span>
00013 <span class="comment">Author:</span>
00014 <span class="comment"></span>
00015 <span class="comment">    Scott Birrell       (ScottBi)       March 12, 1991</span>
00016 <span class="comment"></span>
00017 <span class="comment">Environment:</span>
00018 <span class="comment"></span>
00019 <span class="comment">Revision History:</span>
00020 <span class="comment"></span>
00021 <span class="comment">--*/</span>
00022 
00023 <span class="preprocessor">#include &lt;nt.h&gt;</span>
00024 <span class="preprocessor">#include &lt;ntlsa.h&gt;</span>
00025 <span class="preprocessor">#include "<a class="code" href="../../d6/d6/sep_8h.html">sep.h</a>"</span>
00026 <span class="preprocessor">#include &lt;zwapi.h&gt;</span>
00027 <span class="preprocessor">#include "<a class="code" href="../../d1/d0/rmp_8h.html">rmp.h</a>"</span>
00028 <span class="preprocessor">#include "<a class="code" href="../../d7/d4/adt_8h.html">adt.h</a>"</span>
00029 <span class="preprocessor">#include "<a class="code" href="../../d1/d5/adtp_8h.html">adtp.h</a>"</span>
00030 
00031 <span class="preprocessor">#ifdef ALLOC_PRAGMA</span>
00032 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(INIT,SepRmInitPhase0)</span>
00033 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(INIT,SeRmInitPhase1)</span>
00034 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,SepRmCommandServerThread)</span>
00035 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,SepRmCommandServerThreadInit)</span>
00036 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,SepRmComponentTestCommandWrkr)</span>
00037 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,SepRmSendCommandToLsaWrkr)</span>
00038 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,SepRmCallLsa)</span>
00039 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00040 <span class="preprocessor"></span>
00041 <span class="comment">//</span>
00042 <span class="comment">// Reference Monitor Command Worker Table</span>
00043 <span class="comment">//</span>
00044 
00045 <span class="comment">//</span>
00046 <span class="comment">// Keep this in sync with RM_COMMAND_NUMBER in ntrmlsa.h</span>
00047 <span class="comment">//</span>
00048 
<a name="l00049"></a><a class="code" href="../../d0/d0/rmmain_8c.html#a0">00049</a> <a class="code" href="../../d1/d0/rmp_8h.html#a13">SEP_RM_COMMAND_WORKER</a> <a class="code" href="../../d0/d0/rmmain_8c.html#a0">SepRmCommandDispatch</a>[] = {
00050                           <a class="code" href="../../d0/d0/rmmain_8c.html#a4">SepRmComponentTestCommandWrkr</a>,
00051                           <a class="code" href="../../d7/d9/rmaudit_8c.html#a1">SepRmSetAuditEventWrkr</a>,
00052                           <a class="code" href="../../d0/d0/rmmain_8c.html#a5">SepRmSendCommandToLsaWrkr</a>,
00053                           <a class="code" href="../../d0/d0/rmmain_8c.html#a4">SepRmComponentTestCommandWrkr</a>,
00054                           <a class="code" href="../../d9/d9/rmlogon_8c.html#a8">SepRmCreateLogonSessionWrkr</a>,
00055                           <a class="code" href="../../d9/d9/rmlogon_8c.html#a9">SepRmDeleteLogonSessionWrkr</a>
00056                           };
00057 
00058 
00059 BOOLEAN
<a name="l00060"></a><a class="code" href="../../d0/d0/rmmain_8c.html#a1">00060</a> <a class="code" href="../../d0/d5/se_8h.html#a176">SeRmInitPhase1</a>(
00061     )
00062 
00063 <span class="comment">/*++</span>
00064 <span class="comment"></span>
00065 <span class="comment">Routine Description:</span>
00066 <span class="comment"></span>
00067 <span class="comment">    This function is called by Phase 1 System Initialization to initialize</span>
00068 <span class="comment">    the Security Reference Monitor.  Note that initialization of the</span>
00069 <span class="comment">    Reference Monitor Global State has already been performed in Phase 0</span>
00070 <span class="comment">    initialization to allow access validation routines to operate without</span>
00071 <span class="comment">    having to check that Reference Monitor Initialization is complete.</span>
00072 <span class="comment"></span>
00073 <span class="comment">    The steps listed below are performed in this routine.  The remainder</span>
00074 <span class="comment">    of Reference Monitor initialization requires the LSA subsystem to have run,</span>
00075 <span class="comment">    so that initialization is performed in a separate thread (the RM Command</span>
00076 <span class="comment">    Server Thread, see below), so that the present thread can create the</span>
00077 <span class="comment">    Session Manager which execs the LSA.</span>
00078 <span class="comment"></span>
00079 <span class="comment">    o Create the Reference Monitor Command LPC port.  The LSA subsystem sends</span>
00080 <span class="comment">      commands (e.g. turn on auditing) which change the Reference Monitor</span>
00081 <span class="comment">      Global State.</span>
00082 <span class="comment">    o Create an Event for use in synchronizing with the LSA subsystem.  The</span>
00083 <span class="comment">      LSA will signal the event when the portion of LSA initialization upon</span>
00084 <span class="comment">      with the Reference Monitor depends is complete.  The Reference Monitor</span>
00085 <span class="comment">      uses another LPC port, called the LSA Command Port to send commands</span>
00086 <span class="comment">      to the LSA, so the RM must know that this port has been created before</span>
00087 <span class="comment">      trying to connect to it.</span>
00088 <span class="comment">    o Create the Reference Monitor Command Server Thread.  This thread is</span>
00089 <span class="comment">      a permanent thread of the System Init process that fields the Reference</span>
00090 <span class="comment">      Monitor State Change commands described above.</span>
00091 <span class="comment"></span>
00092 <span class="comment"></span>
00093 <span class="comment">Arguments:</span>
00094 <span class="comment"></span>
00095 <span class="comment">    None.</span>
00096 <span class="comment"></span>
00097 <span class="comment">Return Value:</span>
00098 <span class="comment"></span>
00099 <span class="comment">    BOOLEAN - TRUE if Rm Initialization (Phase 1) succeeded, else FALSE</span>
00100 <span class="comment"></span>
00101 <span class="comment">--*/</span>
00102 
00103 {
00104     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00105     STRING RmCommandPortName;
00106     UNICODE_STRING UnicodeRmCommandPortName;
00107     OBJECT_ATTRIBUTES <a class="code" href="../../d7/d0/ctlnpqos_8c.html#a4">ObjectAttributes</a>;
00108     STRING LsaInitEventName;
00109     UNICODE_STRING UnicodeLsaInitEventName;
00110     OBJECT_ATTRIBUTES LsaInitEventObjectAttributes;
00111     SECURITY_DESCRIPTOR LsaInitEventSecurityDescriptor;
00112     ULONG AclSize;
00113 
00114     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00115 
00116     <span class="comment">//</span>
00117     <span class="comment">// Create an LPC port called the Reference Monitor Command Port.</span>
00118     <span class="comment">// This will be used by the LSA to send commands to the Reference</span>
00119     <span class="comment">// Monitor to update its state data.</span>
00120     <span class="comment">//</span>
00121 
00122     <a class="code" href="../../d2/d7/string_8c.html#a5">RtlInitString</a>( &amp;RmCommandPortName, <span class="stringliteral">"\\SeRmCommandPort"</span> );
00123     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d6/d6/nls_8c.html#a21">RtlAnsiStringToUnicodeString</a>(
00124                  &amp;UnicodeRmCommandPortName,
00125                  &amp;RmCommandPortName,
00126                  <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );  <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>) );
00127     InitializeObjectAttributes(
00128         &amp;<a class="code" href="../../d7/d0/ctlnpqos_8c.html#a4">ObjectAttributes</a>,
00129         &amp;UnicodeRmCommandPortName,
00130         0,
00131         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00132         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>
00133         );
00134 
00135     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwCreatePort(
00136                  &amp;<a class="code" href="../../d1/d0/rmp_8h.html#a20">SepRmState</a>.<a class="code" href="../../d1/d2/struct__SEP__RM__STATE.html#o3">RmCommandPortHandle</a>,
00137                  &amp;<a class="code" href="../../d7/d0/ctlnpqos_8c.html#a4">ObjectAttributes</a>,
00138                  <span class="keyword">sizeof</span>(<a class="code" href="../../d0/d2/struct__SEP__RM__CONNECT__INFO.html">SEP_RM_CONNECT_INFO</a>),
00139                  <span class="keyword">sizeof</span>(RM_COMMAND_MESSAGE),
00140                  <span class="keyword">sizeof</span>(RM_COMMAND_MESSAGE) * 32
00141                  );
00142     <a class="code" href="../../d6/d6/nls_8c.html#a34">RtlFreeUnicodeString</a>( &amp;UnicodeRmCommandPortName );
00143 
00144     <span class="keywordflow">if</span>( !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>) ) {
00145 
00146         KdPrint((<span class="stringliteral">"Security: Rm Create Command Port failed 0x%lx\n"</span>, <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>));
00147         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00148     }
00149 
00150     <span class="comment">//</span>
00151     <span class="comment">// Prepare to create an event for synchronizing with the LSA.</span>
00152     <span class="comment">// First, build the Security Descriptor for the Init Event Object</span>
00153     <span class="comment">//</span>
00154 
00155     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d8/d6/sertl_8c.html#a53">RtlCreateSecurityDescriptor</a>(
00156                  &amp;LsaInitEventSecurityDescriptor,
00157                  SECURITY_DESCRIPTOR_REVISION
00158                  );
00159 
00160     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
00161 
00162         KdPrint((<span class="stringliteral">"Security:  Creating Lsa Init Event Desc failed 0x%lx\n"</span>,
00163                   <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>));
00164         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00165     }
00166 
00167     <span class="comment">//</span>
00168     <span class="comment">// Allocate a temporary buffer from the paged pool.  It is a fatal</span>
00169     <span class="comment">// system error if the allocation fails since security cannot be</span>
00170     <span class="comment">// enabled.</span>
00171     <span class="comment">//</span>
00172 
00173     AclSize = <span class="keyword">sizeof</span>(ACL) +
00174               <span class="keyword">sizeof</span>(ACCESS_ALLOWED_ACE) +
00175               <a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>(<a class="code" href="../../d0/d5/se_8h.html#a54">SeLocalSystemSid</a>);
00176     LsaInitEventSecurityDescriptor.Dacl =
00177         <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>(<a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>, AclSize, 'cAeS');
00178 
00179     <span class="keywordflow">if</span> (LsaInitEventSecurityDescriptor.Dacl == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00180 
00181         KdPrint((<span class="stringliteral">"Security LSA:  Insufficient resources to initialize\n"</span>));
00182         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00183     }
00184 
00185     <span class="comment">//</span>
00186     <span class="comment">// Now create the Discretionary ACL within the Security Descriptor</span>
00187     <span class="comment">//</span>
00188 
00189     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d2/d4/acledit_8c.html#a6">RtlCreateAcl</a>(
00190                  LsaInitEventSecurityDescriptor.Dacl,
00191                  AclSize,
00192                  ACL_REVISION2
00193                  );
00194 
00195     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
00196 
00197         KdPrint((<span class="stringliteral">"Security:  Creating Lsa Init Event Dacl failed 0x%lx\n"</span>,
00198                   <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>));
00199         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00200     }
00201 
00202     <span class="comment">//</span>
00203     <span class="comment">// Now add an ACE giving GENERIC_ALL access to the User ID</span>
00204     <span class="comment">//</span>
00205 
00206     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d2/d4/acledit_8c.html#a16">RtlAddAccessAllowedAce</a>(
00207                  LsaInitEventSecurityDescriptor.Dacl,
00208                  ACL_REVISION2,
00209                  GENERIC_ALL,
00210                  <a class="code" href="../../d0/d5/se_8h.html#a54">SeLocalSystemSid</a>
00211                  );
00212 
00213     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
00214 
00215         KdPrint((<span class="stringliteral">"Security:  Adding Lsa Init Event ACE failed 0x%lx\n"</span>,
00216                   <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>));
00217         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00218     }
00219 
00220     <span class="comment">//</span>
00221     <span class="comment">// Set up the Object Attributes for the Lsa Initialization Event</span>
00222     <span class="comment">//</span>
00223 
00224     <a class="code" href="../../d2/d7/string_8c.html#a5">RtlInitString</a>( &amp;LsaInitEventName, <span class="stringliteral">"\\SeLsaInitEvent"</span> );
00225     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d6/d6/nls_8c.html#a21">RtlAnsiStringToUnicodeString</a>(
00226                  &amp;UnicodeLsaInitEventName,
00227                  &amp;LsaInitEventName,
00228                  <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );  <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>) );
00229     InitializeObjectAttributes(
00230         &amp;LsaInitEventObjectAttributes,
00231         &amp;UnicodeLsaInitEventName,
00232         0,
00233         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00234         &amp;LsaInitEventSecurityDescriptor
00235         );
00236 
00237     <span class="comment">//</span>
00238     <span class="comment">// Create an event for use in synchronizing with the LSA.  The LSA will</span>
00239     <span class="comment">// signal this event when LSA initialization has reached the point</span>
00240     <span class="comment">// where the LSA's Reference Monitor Server Port has been created.</span>
00241     <span class="comment">//</span>
00242 
00243     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwCreateEvent(
00244                  &amp;(<a class="code" href="../../d1/d0/rmp_8h.html#a20">SepRmState</a>.<a class="code" href="../../d1/d2/struct__SEP__RM__STATE.html#o0">LsaInitEventHandle</a>),
00245                  EVENT_MODIFY_STATE,
00246                  &amp;LsaInitEventObjectAttributes,
00247                  NotificationEvent,
00248                  <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
00249 
00250     <a class="code" href="../../d6/d6/nls_8c.html#a34">RtlFreeUnicodeString</a>( &amp;UnicodeLsaInitEventName );
00251 
00252     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
00253 
00254         KdPrint((<span class="stringliteral">"Security: LSA init event creation failed.0x%xl\n"</span>,
00255             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>));
00256         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00257     }
00258 
00259     <span class="comment">//</span>
00260     <span class="comment">// Deallocate the pool memory used for the Init Event DACL</span>
00261     <span class="comment">//</span>
00262 
00263     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( LsaInitEventSecurityDescriptor.Dacl );
00264 
00265     <span class="comment">//</span>
00266     <span class="comment">// Create a permanent thread of the Sysinit Process, called the</span>
00267     <span class="comment">// Reference Monitor Server Thread.  This thread is dedicated to</span>
00268     <span class="comment">// receiving Reference Monitor commands and dispatching them.</span>
00269     <span class="comment">//</span>
00270 
00271     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d2/d8/ps_2create_8c.html#a11">PsCreateSystemThread</a>(
00272                  &amp;<a class="code" href="../../d1/d0/rmp_8h.html#a20">SepRmState</a>.<a class="code" href="../../d1/d2/struct__SEP__RM__STATE.html#o2">SepRmThreadHandle</a>,
00273                  THREAD_GET_CONTEXT |
00274                  THREAD_SET_CONTEXT |
00275                  THREAD_SET_INFORMATION,
00276                  <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00277                  <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00278                  <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00279                  <a class="code" href="../../d0/d0/rmmain_8c.html#a2">SepRmCommandServerThread</a>,
00280                  <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>
00281                  );
00282 
00283     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
00284 
00285         KdPrint((<span class="stringliteral">"Security: Rm Server Thread creation failed 0x%lx\n"</span>, <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>));
00286         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00287     }
00288 
00289     <span class="comment">//</span>
00290     <span class="comment">// Initialize data from the registry.  This must go here because all other</span>
00291     <span class="comment">// Se initialization takes place before the registry is initialized.</span>
00292     <span class="comment">//</span>
00293 
00294     <a class="code" href="../../d6/d6/sep_8h.html#a71">SepAdtInitializeCrashOnFail</a>();
00295     <a class="code" href="../../d6/d6/sep_8h.html#a72">SepAdtInitializePrivilegeAuditing</a>();
00296     <a class="code" href="../../d1/d5/adtp_8h.html#a35">SepAdtInitializeAuditingOptions</a>();
00297     
00298     <span class="comment">//</span>
00299     <span class="comment">// Reference Monitor initialization is successful if we get to here.</span>
00300     <span class="comment">//</span>
00301 
00302     ZwClose( <a class="code" href="../../d1/d0/rmp_8h.html#a20">SepRmState</a>.<a class="code" href="../../d1/d2/struct__SEP__RM__STATE.html#o2">SepRmThreadHandle</a> );
00303     <a class="code" href="../../d1/d0/rmp_8h.html#a20">SepRmState</a>.<a class="code" href="../../d1/d2/struct__SEP__RM__STATE.html#o2">SepRmThreadHandle</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00304     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00305 }
00306 
00307 
00308 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00309"></a><a class="code" href="../../d1/d0/rmp_8h.html#a24">00309</a> <a class="code" href="../../d1/d0/rmp_8h.html#a24">SepRmCommandServerThread</a>(
00310     IN PVOID StartContext
00311 )
00312 
00313 <span class="comment">/*++</span>
00314 <span class="comment"></span>
00315 <span class="comment">Routine Description:</span>
00316 <span class="comment"></span>
00317 <span class="comment">    This function is executed indefinitely by a dedicated permanent thread</span>
00318 <span class="comment">    of the Sysinit Process, called the Reference Monitor Server Thread.</span>
00319 <span class="comment">    This thread updates Reference Monitor Global State Data by dispatching</span>
00320 <span class="comment">    commands sent from the LSA through the the Reference Monitor LPC Command</span>
00321 <span class="comment">    Port.  The following steps are repeated indefinitely:</span>
00322 <span class="comment"></span>
00323 <span class="comment">    o  Initialize RM Command receive and reply buffer headers</span>
00324 <span class="comment">    o  Perform remaining Reference Monitor initialization involving LSA</span>
00325 <span class="comment">    o  Wait for RM command sent from LSA, send reply to previous command</span>
00326 <span class="comment">       (if any)</span>
00327 <span class="comment">    o  Validate command</span>
00328 <span class="comment">    o  Dispatch to command worker routine to execute command.</span>
00329 <span class="comment"></span>
00330 <span class="comment">Arguments:</span>
00331 <span class="comment"></span>
00332 <span class="comment">    None.</span>
00333 <span class="comment"></span>
00334 <span class="comment">Return Value:</span>
00335 <span class="comment"></span>
00336 <span class="comment">    None.</span>
00337 <span class="comment"></span>
00338 <span class="comment">--*/</span>
00339 
00340 {
00341     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00342     PRM_REPLY_MESSAGE Reply;
00343     RM_COMMAND_MESSAGE CommandMessage;
00344     RM_REPLY_MESSAGE <a class="code" href="../../d3/d8/client_8c.html#a125">ReplyMessage</a>;
00345 
00346     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00347 
00348     <span class="comment">//</span>
00349     <span class="comment">// Perform the rest of the Reference Monitor initialization, involving</span>
00350     <span class="comment">// synchronization with the LSA or dependency on the LSA having run.</span>
00351     <span class="comment">//</span>
00352 
00353     <span class="keywordflow">if</span> (!<a class="code" href="../../d1/d0/rmp_8h.html#a25">SepRmCommandServerThreadInit</a>()) {
00354 
00355         KdPrint((<span class="stringliteral">"Security: Terminating Rm Command Server Thread\n"</span>));
00356         <span class="keywordflow">return</span>;
00357     }
00358 
00359     <span class="comment">//</span>
00360     <span class="comment">// Initialize LPC port message header type and length fields for the</span>
00361     <span class="comment">// received command message.</span>
00362     <span class="comment">//</span>
00363 
00364     CommandMessage.MessageHeader.u2.ZeroInit = 0;
00365     CommandMessage.MessageHeader.u1.s1.TotalLength =
00366         (CSHORT) <span class="keyword">sizeof</span>(RM_COMMAND_MESSAGE);
00367     CommandMessage.MessageHeader.u1.s1.DataLength =
00368     CommandMessage.MessageHeader.u1.s1.TotalLength -
00369         (CSHORT) <span class="keyword">sizeof</span>(PORT_MESSAGE);
00370 
00371     <span class="comment">//</span>
00372     <span class="comment">// Initialize the LPC port message header type and data sizes for</span>
00373     <span class="comment">// for the reply message.</span>
00374     <span class="comment">//</span>
00375 
00376     <a class="code" href="../../d3/d8/client_8c.html#a125">ReplyMessage</a>.MessageHeader.u2.ZeroInit = 0;
00377     <a class="code" href="../../d3/d8/client_8c.html#a125">ReplyMessage</a>.MessageHeader.u1.s1.TotalLength =
00378         (CSHORT) <span class="keyword">sizeof</span>(RM_COMMAND_MESSAGE);
00379     <a class="code" href="../../d3/d8/client_8c.html#a125">ReplyMessage</a>.MessageHeader.u1.s1.DataLength =
00380     <a class="code" href="../../d3/d8/client_8c.html#a125">ReplyMessage</a>.MessageHeader.u1.s1.TotalLength -
00381         (CSHORT) <span class="keyword">sizeof</span>(PORT_MESSAGE);
00382 
00383     <span class="comment">//</span>
00384     <span class="comment">// First time through, there is no reply.</span>
00385     <span class="comment">//</span>
00386 
00387     Reply = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00388 
00389     <span class="comment">//</span>
00390     <span class="comment">// Now loop indefinitely, processing incoming Rm commands from the LSA.</span>
00391     <span class="comment">//</span>
00392 
00393     <span class="keywordflow">for</span>(;;) {
00394 
00395         <span class="comment">//</span>
00396         <span class="comment">// Wait for Command, send reply to previous command (if any)</span>
00397         <span class="comment">//</span>
00398 
00399         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwReplyWaitReceivePort(
00400                     <a class="code" href="../../d1/d0/rmp_8h.html#a20">SepRmState</a>.<a class="code" href="../../d1/d2/struct__SEP__RM__STATE.html#o3">RmCommandPortHandle</a>,
00401                     <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00402                     (PPORT_MESSAGE) Reply,
00403                     (PPORT_MESSAGE) &amp;CommandMessage
00404                     );
00405 
00406         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
00407 
00408             <span class="comment">//</span>
00409             <span class="comment">// malicious user apps can try to connect to this port.  We will</span>
00410             <span class="comment">// fail later, but if their thread vanishes, we'll get a failure</span>
00411             <span class="comment">// here.  Ignore it:</span>
00412             <span class="comment">//</span>
00413 
00414             <span class="keywordflow">if</span> ( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_UNSUCCESSFUL )
00415             {
00416                 <span class="comment">//</span>
00417                 <span class="comment">// skip it:</span>
00418                 <span class="comment">//</span>
00419 
00420                 Reply = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ;
00421                 <span class="keywordflow">continue</span>;
00422             }
00423 
00424             KdPrint((<span class="stringliteral">"Security: RM message receive from Lsa failed %lx\n"</span>,
00425                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>));
00426 
00427         }
00428 
00429         <span class="comment">//</span>
00430         <span class="comment">// Now dispatch to a routine to handle the command.  Allow</span>
00431         <span class="comment">// command errors to occur without bringing system down just now.</span>
00432         <span class="comment">//</span>
00433 
00434         <span class="keywordflow">if</span> ( CommandMessage.MessageHeader.u2.s2.Type == LPC_REQUEST ) {
00435             (*(<a class="code" href="../../d0/d0/rmmain_8c.html#a0">SepRmCommandDispatch</a>[CommandMessage.CommandNumber]))
00436                 (&amp;CommandMessage, &amp;<a class="code" href="../../d3/d8/client_8c.html#a125">ReplyMessage</a>);
00437 
00438             <span class="comment">//</span>
00439             <span class="comment">// Initialize the client thread info and message id for the</span>
00440             <span class="comment">// reply message.  First time through, the reply message structure</span>
00441             <span class="comment">// is not used.</span>
00442             <span class="comment">//</span>
00443 
00444             <a class="code" href="../../d3/d8/client_8c.html#a125">ReplyMessage</a>.MessageHeader.ClientId =
00445                 CommandMessage.MessageHeader.ClientId;
00446             <a class="code" href="../../d3/d8/client_8c.html#a125">ReplyMessage</a>.MessageHeader.MessageId =
00447                 CommandMessage.MessageHeader.MessageId;
00448 
00449             Reply = &amp;<a class="code" href="../../d3/d8/client_8c.html#a125">ReplyMessage</a>;
00450 
00451         } <span class="keywordflow">else</span> {
00452 
00453             Reply = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00454         }
00455     }  <span class="comment">// end_for</span>
00456 
00457     <span class="comment">//</span>
00458     <span class="comment">// Make compiler ferme la bouche</span>
00459     <span class="comment">//</span>
00460 
00461     StartContext;
00462 }
00463 
00464 
00465 BOOLEAN
<a name="l00466"></a><a class="code" href="../../d0/d0/rmmain_8c.html#a3">00466</a> <a class="code" href="../../d1/d0/rmp_8h.html#a25">SepRmCommandServerThreadInit</a>(
00467     VOID
00468     )
00469 
00470 <span class="comment">/*++</span>
00471 <span class="comment"></span>
00472 <span class="comment">Routine Description:</span>
00473 <span class="comment"></span>
00474 <span class="comment">    This function performs initialization of the Reference Monitor Server</span>
00475 <span class="comment">    thread.  The following steps are performed.</span>
00476 <span class="comment"></span>
00477 <span class="comment">    o  Wait on the LSA signalling the event.  When the event is signalled,</span>
00478 <span class="comment">       the LSA has already created the LSA Command Server LPC Port</span>
00479 <span class="comment">    o  Close the LSA Init Event Handle.  The event is not used again.</span>
00480 <span class="comment">    o  Listen for the LSA to connect to the Port</span>
00481 <span class="comment">    o  Accept the connection.</span>
00482 <span class="comment">    o  Connect to the LSA Command Server LPC Port</span>
00483 <span class="comment"></span>
00484 <span class="comment">Arguments:</span>
00485 <span class="comment"></span>
00486 <span class="comment">    None.</span>
00487 <span class="comment"></span>
00488 <span class="comment">Return Value:</span>
00489 <span class="comment"></span>
00490 <span class="comment">--*/</span>
00491 
00492 {
00493     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00494     UNICODE_STRING LsaCommandPortName;
00495     PORT_MESSAGE ConnectionRequest;
00496     SECURITY_QUALITY_OF_SERVICE <a class="code" href="../../d3/d9/ulpc_8h.html#a4">DynamicQos</a>;
00497     OBJECT_ATTRIBUTES <a class="code" href="../../d7/d0/ctlnpqos_8c.html#a4">ObjectAttributes</a>;
00498     PORT_VIEW ClientView;
00499     REMOTE_PORT_VIEW LsaClientView;
00500     BOOLEAN BooleanStatus = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00501 
00502     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00503 
00504     <span class="comment">//</span>
00505     <span class="comment">// Save a pointer to our process so we can get back into this process</span>
00506     <span class="comment">// to send commands to the LSA (using a handle to an LPC port created</span>
00507     <span class="comment">// below).</span>
00508     <span class="comment">//</span>
00509 
00510     <a class="code" href="../../d1/d0/rmp_8h.html#a19">SepRmLsaCallProcess</a> = <a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a>();
00511 
00512     <a class="code" href="../../d4/d0/ob_8h.html#a15">ObReferenceObject</a>(<a class="code" href="../../d1/d0/rmp_8h.html#a19">SepRmLsaCallProcess</a>);
00513 
00514     <span class="comment">//</span>
00515     <span class="comment">// Wait on the LSA signalling the event.  This means that the LSA</span>
00516     <span class="comment">// has created its command port, not that LSA initialization is</span>
00517     <span class="comment">// complete.</span>
00518     <span class="comment">//</span>
00519 
00520     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwWaitForSingleObject(
00521                  <a class="code" href="../../d1/d0/rmp_8h.html#a20">SepRmState</a>.<a class="code" href="../../d1/d2/struct__SEP__RM__STATE.html#o0">LsaInitEventHandle</a>,
00522                  <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00523                  <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00524 
00525     <span class="keywordflow">if</span> ( !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>) ) {
00526 
00527         KdPrint((<span class="stringliteral">"Security Rm Init: Waiting for LSA Init Event failed 0x%lx\n"</span>, <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>));
00528         <span class="keywordflow">goto</span> RmCommandServerThreadInitError;
00529     }
00530 
00531     <span class="comment">//</span>
00532     <span class="comment">// Close the LSA Init Event Handle.  The event is not used again.</span>
00533     <span class="comment">//</span>
00534 
00535     ZwClose(<a class="code" href="../../d1/d0/rmp_8h.html#a20">SepRmState</a>.<a class="code" href="../../d1/d2/struct__SEP__RM__STATE.html#o0">LsaInitEventHandle</a>);
00536 
00537     <span class="comment">//</span>
00538     <span class="comment">// Listen for a connection to be made by the LSA to the Reference Monitor</span>
00539     <span class="comment">// Command Port.  This connection will be made by the LSA process.</span>
00540     <span class="comment">//</span>
00541 
00542     ConnectionRequest.u1.s1.TotalLength = <span class="keyword">sizeof</span>(ConnectionRequest);
00543     ConnectionRequest.u1.s1.DataLength = (CSHORT)0;
00544     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwListenPort(
00545                  <a class="code" href="../../d1/d0/rmp_8h.html#a20">SepRmState</a>.<a class="code" href="../../d1/d2/struct__SEP__RM__STATE.html#o3">RmCommandPortHandle</a>,
00546                  &amp;ConnectionRequest
00547                  );
00548 
00549     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
00550 
00551         KdPrint((<span class="stringliteral">"Security Rm Init: Listen to Command Port failed 0x%lx\n"</span>,
00552             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>));
00553         <span class="keywordflow">goto</span> RmCommandServerThreadInitError;
00554     }
00555 
00556     <span class="comment">//</span>
00557     <span class="comment">// Obtain a handle to the LSA process for use when auditing.</span>
00558     <span class="comment">//</span>
00559 
00560     InitializeObjectAttributes( &amp;<a class="code" href="../../d7/d0/ctlnpqos_8c.html#a4">ObjectAttributes</a>, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, 0, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00561 
00562     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwOpenProcess(
00563                  &amp;<a class="code" href="../../d8/d5/seglobal_8c.html#a91">SepLsaHandle</a>,
00564                  PROCESS_VM_OPERATION | PROCESS_VM_WRITE,
00565                  &amp;<a class="code" href="../../d7/d0/ctlnpqos_8c.html#a4">ObjectAttributes</a>,
00566                  &amp;ConnectionRequest.ClientId
00567                  );
00568 
00569     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
00570 
00571         KdPrint((<span class="stringliteral">"Security Rm Init: Open Listen to Command Port failed 0x%lx\n"</span>,
00572             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>));
00573         <span class="keywordflow">goto</span> RmCommandServerThreadInitError;
00574     }
00575 
00576     <span class="comment">//</span>
00577     <span class="comment">// Accept the connection made by the LSA process.</span>
00578     <span class="comment">//</span>
00579 
00580     LsaClientView.Length = <span class="keyword">sizeof</span>(LsaClientView);
00581 
00582     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwAcceptConnectPort(
00583                  &amp;<a class="code" href="../../d1/d0/rmp_8h.html#a20">SepRmState</a>.<a class="code" href="../../d1/d2/struct__SEP__RM__STATE.html#o3">RmCommandPortHandle</a>,
00584                  <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00585                  &amp;ConnectionRequest,
00586                  <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
00587                  <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00588                  &amp;LsaClientView
00589                  );
00590 
00591     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
00592 
00593         KdPrint((<span class="stringliteral">"Security Rm Init: Accept Connect to Command Port failed 0x%lx\n"</span>,
00594                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>));
00595 
00596         <span class="keywordflow">goto</span> RmCommandServerThreadInitError;
00597     }
00598 
00599     <span class="comment">//</span>
00600     <span class="comment">// Complete the connection.</span>
00601     <span class="comment">//</span>
00602 
00603     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwCompleteConnectPort(<a class="code" href="../../d1/d0/rmp_8h.html#a20">SepRmState</a>.<a class="code" href="../../d1/d2/struct__SEP__RM__STATE.html#o3">RmCommandPortHandle</a>);
00604 
00605     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
00606 
00607         KdPrint((<span class="stringliteral">"Security Rm Init: Complete Connect to Command Port failed 0x%lx\n"</span>,
00608                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>));
00609         <span class="keywordflow">goto</span> RmCommandServerThreadInitError;
00610     }
00611 
00612     <span class="comment">//</span>
00613     <span class="comment">// Set up the security quality of service parameters to use over the</span>
00614     <span class="comment">// Lsa Command LPC port.  Use the most efficient (least overhead) - which</span>
00615     <span class="comment">// is dynamic rather than static tracking.</span>
00616     <span class="comment">//</span>
00617 
00618     <a class="code" href="../../d3/d9/ulpc_8h.html#a4">DynamicQos</a>.ImpersonationLevel = SecurityImpersonation;
00619     <a class="code" href="../../d3/d9/ulpc_8h.html#a4">DynamicQos</a>.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
00620     <a class="code" href="../../d3/d9/ulpc_8h.html#a4">DynamicQos</a>.EffectiveOnly = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00621 
00622     <span class="comment">//</span>
00623     <span class="comment">// Create the section to be used as unnamed shared memory for</span>
00624     <span class="comment">// communication between the RM and LSA.</span>
00625     <span class="comment">//</span>
00626 
00627     <a class="code" href="../../d1/d0/rmp_8h.html#a20">SepRmState</a>.<a class="code" href="../../d1/d2/struct__SEP__RM__STATE.html#o7">LsaCommandPortSectionSize</a>.LowPart = <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
00628     <a class="code" href="../../d1/d0/rmp_8h.html#a20">SepRmState</a>.<a class="code" href="../../d1/d2/struct__SEP__RM__STATE.html#o7">LsaCommandPortSectionSize</a>.HighPart = 0;
00629 
00630     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwCreateSection(
00631                  &amp;<a class="code" href="../../d1/d0/rmp_8h.html#a20">SepRmState</a>.<a class="code" href="../../d1/d2/struct__SEP__RM__STATE.html#o6">LsaCommandPortSectionHandle</a>,
00632                  SECTION_ALL_ACCESS,
00633                  <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,                           <span class="comment">// ObjectAttributes</span>
00634                  &amp;<a class="code" href="../../d1/d0/rmp_8h.html#a20">SepRmState</a>.<a class="code" href="../../d1/d2/struct__SEP__RM__STATE.html#o7">LsaCommandPortSectionSize</a>,
00635                  PAGE_READWRITE,
00636                  SEC_COMMIT,
00637                  <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>                            <span class="comment">// FileHandle</span>
00638                  );
00639 
00640     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
00641 
00642         KdPrint((<span class="stringliteral">"Security Rm Init: Create Memory Section for LSA port failed: %X\n"</span>, <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>));
00643         <span class="keywordflow">goto</span> RmCommandServerThreadInitError;
00644     }
00645 
00646     <span class="comment">//</span>
00647     <span class="comment">// Set up for a call to NtConnectPort and connect to the LSA port.</span>
00648     <span class="comment">// This setup includes a description of the port memory section so that</span>
00649     <span class="comment">// the LPC connection logic can make the section visible to both the</span>
00650     <span class="comment">// client and server processes.</span>
00651     <span class="comment">//</span>
00652 
00653     ClientView.Length = <span class="keyword">sizeof</span>(ClientView);
00654     ClientView.SectionHandle = <a class="code" href="../../d1/d0/rmp_8h.html#a20">SepRmState</a>.<a class="code" href="../../d1/d2/struct__SEP__RM__STATE.html#o6">LsaCommandPortSectionHandle</a>;
00655     ClientView.SectionOffset = 0;
00656     ClientView.ViewSize = <a class="code" href="../../d1/d0/rmp_8h.html#a20">SepRmState</a>.<a class="code" href="../../d1/d2/struct__SEP__RM__STATE.html#o7">LsaCommandPortSectionSize</a>.LowPart;
00657     ClientView.ViewBase = 0;
00658     ClientView.ViewRemoteBase = 0;
00659 
00660     <span class="comment">//</span>
00661     <span class="comment">// Set up the security quality of service parameters to use over the</span>
00662     <span class="comment">// port.  Use dynamic tracking so that XACTSRV will impersonate the</span>
00663     <span class="comment">// user that we are impersonating when we call NtRequestWaitReplyPort.</span>
00664     <span class="comment">// If we used static tracking, XACTSRV would impersonate the context</span>
00665     <span class="comment">// when the connection is made.</span>
00666     <span class="comment">//</span>
00667 
00668     <a class="code" href="../../d3/d9/ulpc_8h.html#a4">DynamicQos</a>.ImpersonationLevel = SecurityImpersonation;
00669     <a class="code" href="../../d3/d9/ulpc_8h.html#a4">DynamicQos</a>.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
00670     <a class="code" href="../../d3/d9/ulpc_8h.html#a4">DynamicQos</a>.EffectiveOnly = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00671 
00672     <span class="comment">//</span>
00673     <span class="comment">// Connect to the Lsa Command LPC Port.  This port is used to send</span>
00674     <span class="comment">// commands from the RM to the LSA.</span>
00675     <span class="comment">//</span>
00676 
00677     <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>( &amp;LsaCommandPortName, <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="stringliteral">"\\SeLsaCommandPort"</span> );
00678 
00679     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwConnectPort(
00680                  &amp;<a class="code" href="../../d1/d0/rmp_8h.html#a20">SepRmState</a>.<a class="code" href="../../d1/d2/struct__SEP__RM__STATE.html#o1">LsaCommandPortHandle</a>,
00681                  &amp;LsaCommandPortName,
00682                  &amp;<a class="code" href="../../d3/d9/ulpc_8h.html#a4">DynamicQos</a>,
00683                  &amp;ClientView,
00684                  <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,                           <span class="comment">// ServerView</span>
00685                  <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,                           <span class="comment">// MaxMessageLength</span>
00686                  <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,                           <span class="comment">// ConnectionInformation</span>
00687                  <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>                            <span class="comment">// ConnectionInformationLength</span>
00688                  );
00689 
00690     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
00691 
00692         KdPrint((<span class="stringliteral">"Security Rm Init: Connect to LSA Port failed 0x%lx\n"</span>, <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>));
00693         <span class="keywordflow">goto</span> RmCommandServerThreadInitError;
00694     }
00695 
00696     <span class="comment">//</span>
00697     <span class="comment">// Store information about the section so that we can create pointers</span>
00698     <span class="comment">// meaningful to LSA.</span>
00699     <span class="comment">//</span>
00700 
00701     <a class="code" href="../../d1/d0/rmp_8h.html#a20">SepRmState</a>.<a class="code" href="../../d1/d2/struct__SEP__RM__STATE.html#o9">RmViewPortMemory</a> = ClientView.ViewBase;
00702     <a class="code" href="../../d1/d0/rmp_8h.html#a20">SepRmState</a>.<a class="code" href="../../d1/d2/struct__SEP__RM__STATE.html#o10">LsaCommandPortMemoryDelta</a> =
00703         (LONG)((ULONG_PTR)ClientView.ViewRemoteBase - (ULONG_PTR) ClientView.ViewBase );
00704     <a class="code" href="../../d1/d0/rmp_8h.html#a20">SepRmState</a>.<a class="code" href="../../d1/d2/struct__SEP__RM__STATE.html#o8">LsaViewPortMemory</a> = ClientView.ViewRemoteBase;
00705 
00706 <span class="comment">/* BugWarning - ScottBi - probably don't need the resource</span>
00707 <span class="comment"></span>
00708 <span class="comment">    //</span>
00709 <span class="comment">    // Create the resource serializing access to the port.  This</span>
00710 <span class="comment">    // resource prevents the port and the shared memory from being</span>
00711 <span class="comment">    // deleted while worker threads are processing requests.</span>
00712 <span class="comment">    //</span>
00713 <span class="comment"></span>
00714 <span class="comment">    if ( !SepRmState.LsaCommandPortResourceInitialized ) {</span>
00715 <span class="comment"></span>
00716 <span class="comment">        ExInitializeResource( &amp;SepRmState.LsaCommandPortResource );</span>
00717 <span class="comment">        SepRmState.LsaCommandPortResourceInitialized = TRUE;</span>
00718 <span class="comment">    }</span>
00719 <span class="comment"></span>
00720 <span class="comment">    SepRmState.LsaCommandPortActive = TRUE;</span>
00721 <span class="comment"></span>
00722 <span class="comment">*/</span>
00723 
00724 RmCommandServerThreadInitFinish:
00725 
00726     <span class="comment">//</span>
00727     <span class="comment">// Dont need this section handle any more, even if returning</span>
00728     <span class="comment">// success.</span>
00729     <span class="comment">//</span>
00730 
00731     <span class="keywordflow">if</span> ( <a class="code" href="../../d1/d0/rmp_8h.html#a20">SepRmState</a>.<a class="code" href="../../d1/d2/struct__SEP__RM__STATE.html#o6">LsaCommandPortSectionHandle</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
00732 
00733        <a class="code" href="../../d5/d0/obclose_8c.html#a1">NtClose</a>( <a class="code" href="../../d1/d0/rmp_8h.html#a20">SepRmState</a>.<a class="code" href="../../d1/d2/struct__SEP__RM__STATE.html#o6">LsaCommandPortSectionHandle</a> );
00734        <a class="code" href="../../d1/d0/rmp_8h.html#a20">SepRmState</a>.<a class="code" href="../../d1/d2/struct__SEP__RM__STATE.html#o6">LsaCommandPortSectionHandle</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00735     }
00736 
00737     <span class="comment">//</span>
00738     <span class="comment">// The Reference Monitor Thread has successfully initialized.</span>
00739     <span class="comment">//</span>
00740 
00741     <span class="keywordflow">return</span> BooleanStatus;
00742 
00743 RmCommandServerThreadInitError:
00744 
00745     <span class="keywordflow">if</span> ( <a class="code" href="../../d1/d0/rmp_8h.html#a20">SepRmState</a>.<a class="code" href="../../d1/d2/struct__SEP__RM__STATE.html#o1">LsaCommandPortHandle</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
00746 
00747        <a class="code" href="../../d5/d0/obclose_8c.html#a1">NtClose</a>( <a class="code" href="../../d1/d0/rmp_8h.html#a20">SepRmState</a>.<a class="code" href="../../d1/d2/struct__SEP__RM__STATE.html#o1">LsaCommandPortHandle</a> );
00748        <a class="code" href="../../d1/d0/rmp_8h.html#a20">SepRmState</a>.<a class="code" href="../../d1/d2/struct__SEP__RM__STATE.html#o1">LsaCommandPortHandle</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00749     }
00750 
00751     BooleanStatus = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00752     <span class="keywordflow">goto</span> RmCommandServerThreadInitFinish;
00753 }
00754 
00755 
00756 
00757 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00758"></a><a class="code" href="../../d1/d0/rmp_8h.html#a26">00758</a> <a class="code" href="../../d1/d0/rmp_8h.html#a26">SepRmComponentTestCommandWrkr</a>(
00759     IN PRM_COMMAND_MESSAGE CommandMessage,
00760     OUT PRM_REPLY_MESSAGE ReplyMessage
00761     )
00762 
00763 <span class="comment">/*++</span>
00764 <span class="comment"></span>
00765 <span class="comment">Routine Description:</span>
00766 <span class="comment"></span>
00767 <span class="comment">    BUGWARNING - Remove this command when other RM commands are implemented.</span>
00768 <span class="comment">             Until then, this command is the only way a CT can verify that</span>
00769 <span class="comment">             an RM command with parameters is sent correctly.</span>
00770 <span class="comment"></span>
00771 <span class="comment">    This function processes the Component Test RM command.</span>
00772 <span class="comment">    This is a temporary command that can be used to verify that the link</span>
00773 <span class="comment">    from RM to LSA is working.  This command verifies that the link</span>
00774 <span class="comment">    is working by receiving a ULONG parameter and verifying that it</span>
00775 <span class="comment">    has the expected value.</span>
00776 <span class="comment"></span>
00777 <span class="comment">Arguments:</span>
00778 <span class="comment"></span>
00779 <span class="comment">    CommandMessage - Pointer to structure containing RM command message</span>
00780 <span class="comment">        information consisting of an LPC PORT_MESSAGE structure followed</span>
00781 <span class="comment">        by the command number (RmComponentTestCommand).  This command</span>
00782 <span class="comment">        currently has one parameter, a fixed ulong value.</span>
00783 <span class="comment"></span>
00784 <span class="comment">    ReplyMessage - Pointer to structure containing LSA reply message</span>
00785 <span class="comment">        information consisting of an LPC PORT_MESSAGE structure followed</span>
00786 <span class="comment">        by the command ReturnedStatus field in which a status code from the</span>
00787 <span class="comment">        command will be returned.</span>
00788 <span class="comment"></span>
00789 <span class="comment">Return Value:</span>
00790 <span class="comment"></span>
00791 <span class="comment">    VOID</span>
00792 <span class="comment"></span>
00793 <span class="comment">--*/</span>
00794 
00795 {
00796     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00797 
00798     <a class="code" href="../../d3/d8/client_8c.html#a125">ReplyMessage</a>-&gt;ReturnedStatus = STATUS_SUCCESS;
00799 
00800     <span class="comment">//</span>
00801     <span class="comment">// Strict check that command is correct.</span>
00802     <span class="comment">//</span>
00803 
00804     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( CommandMessage-&gt;CommandNumber == RmComponentTestCommand );
00805 
00806     KdPrint((<span class="stringliteral">"Security: RM Component Test Command Received\n"</span>));
00807 
00808     <span class="comment">//</span>
00809     <span class="comment">// Verify that the parameter value passed is as expected.</span>
00810     <span class="comment">//</span>
00811 
00812     <span class="keywordflow">if</span> (*((ULONG *) CommandMessage-&gt;CommandParams) !=
00813         RM_CT_COMMAND_PARAM_VALUE ) {
00814 
00815         <a class="code" href="../../d3/d8/client_8c.html#a125">ReplyMessage</a>-&gt;ReturnedStatus = STATUS_INVALID_PARAMETER;
00816     }
00817 
00818     <span class="keywordflow">return</span>;
00819 }
00820 
00821 
00822 
00823 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00824"></a><a class="code" href="../../d1/d0/rmp_8h.html#a28">00824</a> <a class="code" href="../../d1/d0/rmp_8h.html#a28">SepRmSendCommandToLsaWrkr</a>(
00825     IN PRM_COMMAND_MESSAGE CommandMessage,
00826     OUT PRM_REPLY_MESSAGE ReplyMessage
00827     )
00828 
00829 <span class="comment">/*++</span>
00830 <span class="comment"></span>
00831 <span class="comment">Routine Description:</span>
00832 <span class="comment"></span>
00833 <span class="comment">    This function carries out the special Rm Send Command To Lsa Command.  This</span>
00834 <span class="comment">    command is used only by the ctlsarm component test which checks that</span>
00835 <span class="comment">    LSA to RM and RM to LSA communication via LPC is working.</span>
00836 <span class="comment"></span>
00837 <span class="comment">Arguments:</span>
00838 <span class="comment"></span>
00839 <span class="comment">    CommandMessage - Pointer to structure containing RM command message</span>
00840 <span class="comment">        information consisting of an LPC PORT_MESSAGE structure followed</span>
00841 <span class="comment">        by the command number (RmDisableAuditCommand), followed by the</span>
00842 <span class="comment">        command parameters.  The parameters of this special command consists</span>
00843 <span class="comment">        of the Command Number of an LSA command and its parameters (if any).</span>
00844 <span class="comment"></span>
00845 <span class="comment">    ReplyMessage - Pointer to structure containing RM reply message</span>
00846 <span class="comment">        information consisting of an LPC PORT_MESSAGE structure followed</span>
00847 <span class="comment">        by the command ReturnedStatus field in which a status code from the</span>
00848 <span class="comment">        command will be returned.</span>
00849 <span class="comment"></span>
00850 <span class="comment">Return Value:</span>
00851 <span class="comment"></span>
00852 <span class="comment">    VOID</span>
00853 <span class="comment"></span>
00854 <span class="comment">--*/</span>
00855 
00856 {
00857     <span class="comment">//</span>
00858     <span class="comment">// Obtain a pointer to the LSA command's params, and the size of the</span>
00859     <span class="comment">// params in bytes.  If there are no params, set the pointer to NULL.</span>
00860     <span class="comment">//</span>
00861 
00862     PVOID LsaCommandParams =
00863         ((RM_SEND_COMMAND_TO_LSA_PARAMS *)
00864         (CommandMessage-&gt;CommandParams))-&gt;LsaCommandParams;
00865     ULONG LsaCommandParamsLength =
00866         ((RM_SEND_COMMAND_TO_LSA_PARAMS *)
00867         (CommandMessage-&gt;CommandParams))-&gt;LsaCommandParamsLength;
00868 
00869     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00870 
00871     <span class="keywordflow">if</span> (LsaCommandParamsLength == 0) {
00872 
00873         LsaCommandParams = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00874 
00875     }
00876 
00877     <span class="comment">//</span>
00878     <span class="comment">// Strict check that command is correct one for this worker.</span>
00879     <span class="comment">//</span>
00880 
00881     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( CommandMessage-&gt;CommandNumber == RmSendCommandToLsaCommand );
00882 
00883     KdPrint((<span class="stringliteral">"Security: RM Send Command back to LSA Command Received\n"</span>));
00884 
00885     <a class="code" href="../../d3/d8/client_8c.html#a125">ReplyMessage</a>-&gt;ReturnedStatus = STATUS_SUCCESS;
00886 
00887 <span class="comment">//    Status = SepRmCallLsa(</span>
00888 <span class="comment">//                 ((RM_SEND_COMMAND_TO_LSA_PARAMS *)</span>
00889 <span class="comment">//                    (CommandMessage-&gt;CommandParams))-&gt;LsaCommandNumber,</span>
00890 <span class="comment">//                 LsaCommandParams,</span>
00891 <span class="comment">//                 LsaCommandParamsLength,</span>
00892 <span class="comment">//                 NULL,</span>
00893 <span class="comment">//                 0,</span>
00894 <span class="comment">//                 NULL,</span>
00895 <span class="comment">//                 NULL</span>
00896 <span class="comment">//                 );</span>
00897 
00898 
00899     <span class="keywordflow">return</span>;
00900 
00901 }
00902 
00903 
00904 
00905 
00906 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00907"></a><a class="code" href="../../d6/d6/sep_8h.html#a50">00907</a> <a class="code" href="../../d6/d6/sep_8h.html#a50">SepRmCallLsa</a>(
00908     <a class="code" href="../../d2/d2/struct__SEP__WORK__ITEM.html">PSEP_WORK_ITEM</a> SepWorkItem
00909     )
00910 <span class="comment">/*++</span>
00911 <span class="comment"></span>
00912 <span class="comment">Routine Description:</span>
00913 <span class="comment"></span>
00914 <span class="comment">    This function sends a command to the LSA via the LSA Reference Monitor</span>
00915 <span class="comment">    Server Command LPC Port.  If the command has parameters, they will be</span>
00916 <span class="comment">    copied directly into a message structure and sent via LPC, therefore,</span>
00917 <span class="comment">    the supplied parameters may not contain any absolute pointers.  A caller</span>
00918 <span class="comment">    must remove pointers by "marshalling" them into the buffer CommandParams.</span>
00919 <span class="comment"></span>
00920 <span class="comment">    This function will create a queue of requests.  This is in order to allow</span>
00921 <span class="comment">    greater throughput for the majority if its callers.  If a thread enters</span>
00922 <span class="comment">    this routine and finds the queue empty, it is the responsibility of that</span>
00923 <span class="comment">    thread to service all requests that come in while it is working until the</span>
00924 <span class="comment">    queue is empty again.  Other threads that enter will simply hook their work</span>
00925 <span class="comment">    item onto the queue and exit.</span>
00926 <span class="comment"></span>
00927 <span class="comment"></span>
00928 <span class="comment">    To implement a new LSA command, do the following:</span>
00929 <span class="comment">    ================================================</span>
00930 <span class="comment"></span>
00931 <span class="comment">    (1)  If the command takes no parameters, just call this routine directly</span>
00932 <span class="comment">         and provide an LSA worker routine called Lsap&lt;command&gt;Wrkr.  See</span>
00933 <span class="comment">         file lsa\server\lsarm.c for examples</span>
00934 <span class="comment"></span>
00935 <span class="comment">    (2)  If the command takes parameters, provide a routine called</span>
00936 <span class="comment">         SepRmSend&lt;command&gt;Command that takes the parameters in unmarshalled</span>
00937 <span class="comment">         form and calls SepRmCallLsa() with the command id, marshalled</span>
00938 <span class="comment">         parameters, length  of marshalled parameters and pointer to</span>
00939 <span class="comment">         optional reply message.  The marshalled parameters are free format:</span>
00940 <span class="comment">         the only restriction is that there must be no absolute address</span>
00941 <span class="comment">         pointers.  These parameters are all placed in the passed LsaWorkItem</span>
00942 <span class="comment">         structure.</span>
00943 <span class="comment"></span>
00944 <span class="comment">    (3)  In file private\inc\ntrmlsa.h, append a command name  to the</span>
00945 <span class="comment">         enumerated type LSA_COMMAND_NUMBER defined in file</span>
00946 <span class="comment">         private\inc\ntrmlsa.h.  Change the #define for LsapMaximumCommand</span>
00947 <span class="comment">         to reference the new command.</span>
00948 <span class="comment"></span>
00949 <span class="comment">    (4)  Add the Lsap&lt;command&gt;Wrkr to the command dispatch table structure</span>
00950 <span class="comment">         LsapCommandDispatch[] in file lsarm.c.</span>
00951 <span class="comment"></span>
00952 <span class="comment">    (5)  Add function prototypes to lsap.h and sep.h.</span>
00953 <span class="comment"></span>
00954 <span class="comment"></span>
00955 <span class="comment">Arguments:</span>
00956 <span class="comment"></span>
00957 <span class="comment">    LsaWorkItem - Supplies a pointer to an SE_LSA_WORK_ITEM containing the</span>
00958 <span class="comment">        information to be passed to LSA.  This structure will be freed</span>
00959 <span class="comment">        asynchronously by some invocation of this routine, not necessarily</span>
00960 <span class="comment">        in the current context.</span>
00961 <span class="comment"></span>
00962 <span class="comment">        !THIS PARAMETER MUST BE ALLOCATED OUT OF NONPAGED POOL!</span>
00963 <span class="comment"></span>
00964 <span class="comment">Return Value:</span>
00965 <span class="comment"></span>
00966 <span class="comment">    NTSTATUS - Result Code.  This is either a result code returned from</span>
00967 <span class="comment">        trying to send the command/receive the reply, or a status code</span>
00968 <span class="comment">        from the command itself.</span>
00969 <span class="comment"></span>
00970 <span class="comment">--*/</span>
00971 
00972 {
00973     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
00974     LSA_COMMAND_MESSAGE CommandMessage;
00975     LSA_REPLY_MESSAGE <a class="code" href="../../d3/d8/client_8c.html#a125">ReplyMessage</a>;
00976     <a class="code" href="../../d8/d1/struct__SEP__LSA__WORK__ITEM.html">PSEP_LSA_WORK_ITEM</a> WorkQueueItem;
00977     ULONG LocalListLength = 0;
00978     SIZE_T RegionSize;
00979     PVOID CopiedCommandParams = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00980     PVOID LsaViewCopiedCommandParams = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00981 
00982     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00983 
00984 <span class="preprocessor">#if 0</span>
00985 <span class="preprocessor"></span>  <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"Entering SepRmCallLsa\n"</span>);
00986 <span class="preprocessor">#endif</span>
00987 <span class="preprocessor"></span>
00988     WorkQueueItem = <a class="code" href="../../d6/d6/sep_8h.html#a16">SepWorkListHead</a>();
00989 
00990     <a class="code" href="../../d3/d5/procobj_8c.html#a4">KeAttachProcess</a>( &amp;<a class="code" href="../../d1/d0/rmp_8h.html#a19">SepRmLsaCallProcess</a>-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o0">Pcb</a> );
00991 
00992     <span class="keywordflow">while</span> ( WorkQueueItem ) {
00993 
00994 <span class="preprocessor">#if 0</span>
00995 <span class="preprocessor"></span>      <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"Got a work item from head of queue, processing\n"</span>);
00996 <span class="preprocessor">#endif</span>
00997 <span class="preprocessor"></span>
00998         <span class="comment">//</span>
00999         <span class="comment">// Construct a message for LPC.  First, fill in the message header</span>
01000         <span class="comment">// fields for LPC, specifying the message type and data sizes for</span>
01001         <span class="comment">// the outgoing CommandMessage and the incoming ReplyMessage.</span>
01002         <span class="comment">//</span>
01003 
01004         CommandMessage.MessageHeader.u2.ZeroInit = 0;
01005         CommandMessage.MessageHeader.u1.s1.TotalLength =
01006             ((CSHORT) RM_COMMAND_MESSAGE_HEADER_SIZE +
01007             (CSHORT) WorkQueueItem-&gt;<a class="code" href="../../d8/d1/struct__SEP__LSA__WORK__ITEM.html#o7">CommandParamsLength</a>);
01008         CommandMessage.MessageHeader.u1.s1.DataLength =
01009             CommandMessage.MessageHeader.u1.s1.TotalLength -
01010             (CSHORT) <span class="keyword">sizeof</span>(PORT_MESSAGE);
01011 
01012         <a class="code" href="../../d3/d8/client_8c.html#a125">ReplyMessage</a>.MessageHeader.u2.ZeroInit = 0;
01013         <a class="code" href="../../d3/d8/client_8c.html#a125">ReplyMessage</a>.MessageHeader.u1.s1.DataLength = (CSHORT) WorkQueueItem-&gt;<a class="code" href="../../d8/d1/struct__SEP__LSA__WORK__ITEM.html#o9">ReplyBufferLength</a>;
01014         <a class="code" href="../../d3/d8/client_8c.html#a125">ReplyMessage</a>.MessageHeader.u1.s1.TotalLength =
01015             <a class="code" href="../../d3/d8/client_8c.html#a125">ReplyMessage</a>.MessageHeader.u1.s1.DataLength +
01016             (CSHORT) <span class="keyword">sizeof</span>(PORT_MESSAGE);
01017 
01018         <span class="comment">//</span>
01019         <span class="comment">// Next, fill in the header info needed by the LSA.</span>
01020         <span class="comment">//</span>
01021 
01022         CommandMessage.CommandNumber = WorkQueueItem-&gt;<a class="code" href="../../d8/d1/struct__SEP__LSA__WORK__ITEM.html#o6">CommandNumber</a>;
01023         <a class="code" href="../../d3/d8/client_8c.html#a125">ReplyMessage</a>.ReturnedStatus = STATUS_SUCCESS;
01024 
01025         <span class="comment">//</span>
01026         <span class="comment">// Set up the Command Parameters either in the LPC Command Message</span>
01027         <span class="comment">// itself, in the preallocated Lsa shared memory block, or in a</span>
01028         <span class="comment">// specially allocated block.  The parameters are either</span>
01029         <span class="comment">// immediate (i.e. in the WorkQueueItem itself, or are in a buffer</span>
01030         <span class="comment">// pointed to by the address in the WorkQueueItem.</span>
01031         <span class="comment">//</span>
01032 
01033         <span class="keywordflow">switch</span> (WorkQueueItem-&gt;<a class="code" href="../../d8/d1/struct__SEP__LSA__WORK__ITEM.html#o1">CommandParamsMemoryType</a>) {
01034 
01035         <span class="keywordflow">case</span> SepRmImmediateMemory:
01036 
01037             <span class="comment">//</span>
01038             <span class="comment">// The Command Parameters are in the CommandParams buffer</span>
01039             <span class="comment">// in the Work Queue Item.  Just copy them to the corresponding</span>
01040             <span class="comment">// buffer in the CommandMessage buffer.</span>
01041             <span class="comment">//</span>
01042 
01043             CommandMessage.CommandParamsMemoryType = SepRmImmediateMemory;
01044 
01045             RtlCopyMemory(
01046                 CommandMessage.CommandParams,
01047                 &amp;WorkQueueItem-&gt;<a class="code" href="../../d8/d1/struct__SEP__LSA__WORK__ITEM.html#o5">CommandParams</a>,
01048                 WorkQueueItem-&gt;<a class="code" href="../../d8/d1/struct__SEP__LSA__WORK__ITEM.html#o7">CommandParamsLength</a>
01049                 );
01050 
01051             <span class="keywordflow">break</span>;
01052 
01053         <span class="keywordflow">case</span> SepRmPagedPoolMemory:
01054         <span class="keywordflow">case</span> SepRmUnspecifiedMemory:
01055 
01056             <span class="comment">//</span>
01057             <span class="comment">// The Command Parameters are contained in paged pool memory.</span>
01058             <span class="comment">// Since this memory is is not accessible by the LSA, we must</span>
01059             <span class="comment">// copy of them either to the LPC Command Message Block, or</span>
01060             <span class="comment">// into LSA shared memory.</span>
01061             <span class="comment">//</span>
01062 
01063             <span class="keywordflow">if</span> (WorkQueueItem-&gt;<a class="code" href="../../d8/d1/struct__SEP__LSA__WORK__ITEM.html#o7">CommandParamsLength</a> &lt;= LSA_MAXIMUM_COMMAND_PARAM_SIZE) {
01064 
01065                 <span class="comment">//</span>
01066                 <span class="comment">// Parameters will fit into the LPC Command Message block.</span>
01067                 <span class="comment">//</span>
01068 
01069                 CopiedCommandParams = CommandMessage.CommandParams;
01070 
01071                 RtlCopyMemory(
01072                     CopiedCommandParams,
01073                     WorkQueueItem-&gt;<a class="code" href="../../d8/d1/struct__SEP__LSA__WORK__ITEM.html#o5">CommandParams</a>.BaseAddress,
01074                     WorkQueueItem-&gt;<a class="code" href="../../d8/d1/struct__SEP__LSA__WORK__ITEM.html#o7">CommandParamsLength</a>
01075                     );
01076 
01077                 CommandMessage.CommandParamsMemoryType = SepRmImmediateMemory;
01078 
01079             } <span class="keywordflow">else</span> {
01080 
01081                 <span class="comment">//</span>
01082                 <span class="comment">// Parameters too large for LPC Command Message block.</span>
01083                 <span class="comment">// If possible, copy them to the preallocated Lsa Shared</span>
01084                 <span class="comment">// Memory block.  If they are too large to fit, copy them</span>
01085                 <span class="comment">// to an individually allocated chunk of Shared Virtual</span>
01086                 <span class="comment">// Memory.</span>
01087                 <span class="comment">//</span>
01088 
01089                 <span class="keywordflow">if</span> (WorkQueueItem-&gt;<a class="code" href="../../d8/d1/struct__SEP__LSA__WORK__ITEM.html#o7">CommandParamsLength</a> &lt;= <a class="code" href="../../d1/d0/rmp_8h.html#a6">SEP_RM_LSA_SHARED_MEMORY_SIZE</a>) {
01090 
01091                     RtlCopyMemory(
01092                         <a class="code" href="../../d1/d0/rmp_8h.html#a20">SepRmState</a>.<a class="code" href="../../d1/d2/struct__SEP__RM__STATE.html#o9">RmViewPortMemory</a>,
01093                         WorkQueueItem-&gt;<a class="code" href="../../d8/d1/struct__SEP__LSA__WORK__ITEM.html#o5">CommandParams</a>.BaseAddress,
01094                         WorkQueueItem-&gt;<a class="code" href="../../d8/d1/struct__SEP__LSA__WORK__ITEM.html#o7">CommandParamsLength</a>
01095                         );
01096 
01097                     LsaViewCopiedCommandParams = <a class="code" href="../../d1/d0/rmp_8h.html#a20">SepRmState</a>.<a class="code" href="../../d1/d2/struct__SEP__RM__STATE.html#o8">LsaViewPortMemory</a>;
01098                     CommandMessage.CommandParamsMemoryType = SepRmLsaCommandPortSharedMemory;
01099 
01100                 } <span class="keywordflow">else</span> {
01101 
01102                     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d0/d5/adtlog_8c.html#a4">SepAdtCopyToLsaSharedMemory</a>(
01103                                  <a class="code" href="../../d8/d5/seglobal_8c.html#a91">SepLsaHandle</a>,
01104                                  WorkQueueItem-&gt;<a class="code" href="../../d8/d1/struct__SEP__LSA__WORK__ITEM.html#o5">CommandParams</a>.BaseAddress,
01105                                  WorkQueueItem-&gt;<a class="code" href="../../d8/d1/struct__SEP__LSA__WORK__ITEM.html#o7">CommandParamsLength</a>,
01106                                  &amp;LsaViewCopiedCommandParams
01107                                  );
01108 
01109                     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
01110 
01111                         <span class="comment">//</span>
01112                         <span class="comment">// An error occurred, most likely in allocating</span>
01113                         <span class="comment">// shared virtual memory.  For now, just ignore</span>
01114                         <span class="comment">// the error and discard the Audit Record.  Later,</span>
01115                         <span class="comment">// we may consider generating a warning record</span>
01116                         <span class="comment">// indicating some records lost.</span>
01117                         <span class="comment">//</span>
01118 
01119                         <span class="keywordflow">break</span>;
01120 
01121                     }
01122 
01123                     CommandMessage.CommandParamsMemoryType = SepRmLsaCustomSharedMemory;
01124                 }
01125 
01126                 <span class="comment">//</span>
01127                 <span class="comment">// Buffer has been successfully copied to a shared Lsa</span>
01128                 <span class="comment">// memory buffer.  Place the address of the buffer valid in</span>
01129                 <span class="comment">// the LSA's process context in the Command Message.</span>
01130                 <span class="comment">//</span>
01131 
01132                 *((PVOID *) CommandMessage.CommandParams) =
01133                     LsaViewCopiedCommandParams;
01134 
01135                 CommandMessage.MessageHeader.u1.s1.TotalLength =
01136                     ((CSHORT) RM_COMMAND_MESSAGE_HEADER_SIZE +
01137                     (CSHORT) <span class="keyword">sizeof</span>( LsaViewCopiedCommandParams ));
01138                 CommandMessage.MessageHeader.u1.s1.DataLength =
01139                     CommandMessage.MessageHeader.u1.s1.TotalLength -
01140                     (CSHORT) <span class="keyword">sizeof</span>(PORT_MESSAGE);
01141             }
01142 
01143             <span class="comment">//</span>
01144             <span class="comment">// Free input command params buffer if Paged Pool.</span>
01145             <span class="comment">//</span>
01146 
01147             <span class="keywordflow">if</span> (WorkQueueItem-&gt;<a class="code" href="../../d8/d1/struct__SEP__LSA__WORK__ITEM.html#o1">CommandParamsMemoryType</a> == SepRmPagedPoolMemory) {
01148 
01149                 <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( WorkQueueItem-&gt;<a class="code" href="../../d8/d1/struct__SEP__LSA__WORK__ITEM.html#o5">CommandParams</a>.BaseAddress );
01150             }
01151 
01152             <span class="keywordflow">break</span>;
01153 
01154         <span class="keywordflow">default</span>:
01155 
01156             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_PARAMETER;
01157             <span class="keywordflow">break</span>;
01158         }
01159 
01160         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
01161 
01162             <span class="comment">//</span>
01163             <span class="comment">// Send Message to the LSA via the LSA Server Command LPC Port.</span>
01164             <span class="comment">// This must be done in the process in which the handle was created.</span>
01165             <span class="comment">//</span>
01166 
01167             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwRequestWaitReplyPort(
01168                          <a class="code" href="../../d1/d0/rmp_8h.html#a20">SepRmState</a>.<a class="code" href="../../d1/d2/struct__SEP__RM__STATE.html#o1">LsaCommandPortHandle</a>,
01169                          (PPORT_MESSAGE) &amp;CommandMessage,
01170                          (PPORT_MESSAGE) &amp;<a class="code" href="../../d3/d8/client_8c.html#a125">ReplyMessage</a>
01171                          );
01172 
01173             <span class="comment">//</span>
01174             <span class="comment">// If the command was successful, copy the data back to the output</span>
01175             <span class="comment">// buffer.</span>
01176             <span class="comment">//</span>
01177 
01178             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
01179 
01180                 <span class="comment">//</span>
01181                 <span class="comment">// Move output from command (if any) to buffer.  Note that this</span>
01182                 <span class="comment">// is done even if the command returns status, because some status</span>
01183                 <span class="comment">// values are not errors.</span>
01184                 <span class="comment">//</span>
01185 
01186                 <span class="keywordflow">if</span> (ARGUMENT_PRESENT(WorkQueueItem-&gt;<a class="code" href="../../d8/d1/struct__SEP__LSA__WORK__ITEM.html#o8">ReplyBuffer</a>)) {
01187 
01188                     RtlCopyMemory(
01189                         WorkQueueItem-&gt;<a class="code" href="../../d8/d1/struct__SEP__LSA__WORK__ITEM.html#o8">ReplyBuffer</a>,
01190                         <a class="code" href="../../d3/d8/client_8c.html#a125">ReplyMessage</a>.ReplyBuffer,
01191                         WorkQueueItem-&gt;<a class="code" href="../../d8/d1/struct__SEP__LSA__WORK__ITEM.html#o9">ReplyBufferLength</a>
01192                         );
01193                 }
01194 
01195                 <span class="comment">//</span>
01196                 <span class="comment">// Return status from command.</span>
01197                 <span class="comment">//</span>
01198 
01199                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d3/d8/client_8c.html#a125">ReplyMessage</a>.ReturnedStatus;
01200 
01201                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
01202                     KdPrint((<span class="stringliteral">"Security: Command sent from RM to LSA returned 0x%lx\n"</span>,
01203                         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>));
01204                 }
01205 
01206             } <span class="keywordflow">else</span> {
01207 
01208                 KdPrint((<span class="stringliteral">"Security: Sending Command RM to LSA failed 0x%lx\n"</span>, <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>));
01209             }
01210 
01211             <span class="comment">//</span>
01212             <span class="comment">// On return from the LPC call to the LSA, we expect the called</span>
01213             <span class="comment">// LSA worker routine to have copied the Command Parameters</span>
01214             <span class="comment">// buffer (if any).  If a custom shared memory boffer was allocated,</span>
01215             <span class="comment">// free it now.</span>
01216             <span class="comment">//</span>
01217 
01218             <span class="keywordflow">if</span> (CommandMessage.CommandParamsMemoryType == SepRmLsaCustomSharedMemory) {
01219 
01220                 RegionSize = 0;
01221 
01222                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwFreeVirtualMemory(
01223                              <a class="code" href="../../d8/d5/seglobal_8c.html#a91">SepLsaHandle</a>,
01224                              (PVOID *) &amp;CommandMessage.CommandParams,
01225                              &amp;RegionSize,
01226                              MEM_RELEASE
01227                              );
01228 
01229                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>));
01230             }
01231 
01232         }
01233 
01234 
01235         <span class="comment">//</span>
01236         <span class="comment">// Clean up.  We must call the cleanup functions on its parameter</span>
01237         <span class="comment">// and then free the used WorkQueueItem itself.</span>
01238         <span class="comment">//</span>
01239 
01240         <span class="keywordflow">if</span> ( ARGUMENT_PRESENT( WorkQueueItem-&gt;<a class="code" href="../../d8/d1/struct__SEP__LSA__WORK__ITEM.html#o10">CleanupFunction</a>)) {
01241 
01242             (WorkQueueItem-&gt;<a class="code" href="../../d8/d1/struct__SEP__LSA__WORK__ITEM.html#o10">CleanupFunction</a>)(WorkQueueItem-&gt;<a class="code" href="../../d8/d1/struct__SEP__LSA__WORK__ITEM.html#o11">CleanupParameter</a>);
01243         }
01244 
01245         <span class="comment">//</span>
01246         <span class="comment">// Determine if there is more work to do on this list</span>
01247         <span class="comment">//</span>
01248 
01249         WorkQueueItem = <a class="code" href="../../d0/d5/adtlog_8c.html#a6">SepDequeueWorkItem</a>();
01250 <span class="preprocessor">#if 0</span>
01251 <span class="preprocessor"></span>      <span class="keywordflow">if</span> ( WorkQueueItem ) {
01252             <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"Got another item from list, going back\n"</span>);
01253       } <span class="keywordflow">else</span> {
01254           <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"List is empty, leaving\n"</span>);
01255       }
01256 <span class="preprocessor">#endif</span>
01257 <span class="preprocessor"></span>
01258 
01259     }
01260 
01261     <a class="code" href="../../d3/d5/procobj_8c.html#a7">KeDetachProcess</a>();
01262 
01263     <span class="keywordflow">if</span> ( LocalListLength &gt; <a class="code" href="../../d8/d5/seglobal_8c.html#a96">SepLsaQueueLength</a> ) {
01264         <a class="code" href="../../d8/d5/seglobal_8c.html#a96">SepLsaQueueLength</a> = LocalListLength;
01265     }
01266 
01267     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01268 }
01269 
01270 
01271 
01272 
01273 
01274 BOOLEAN
<a name="l01275"></a><a class="code" href="../../d6/d6/sep_8h.html#a52">01275</a> <a class="code" href="../../d0/d0/rmmain_8c.html#a7">SepRmInitPhase0</a>(
01276     )
01277 
01278 <span class="comment">/*++</span>
01279 <span class="comment"></span>
01280 <span class="comment">Routine Description:</span>
01281 <span class="comment"></span>
01282 <span class="comment">    This function performs Reference Monitor Phase 0 initialization.</span>
01283 <span class="comment">    This includes initializing the reference monitor database to a state</span>
01284 <span class="comment">    which allows access validation routines to operate (always granting</span>
01285 <span class="comment">    access) prior to the main init of the Reference Monitor in Phase 1</span>
01286 <span class="comment">    initialization, without having to check if the RM is initialized.</span>
01287 <span class="comment"></span>
01288 <span class="comment"></span>
01289 <span class="comment">Arguments:</span>
01290 <span class="comment"></span>
01291 <span class="comment">    None.</span>
01292 <span class="comment"></span>
01293 <span class="comment">Return Value:</span>
01294 <span class="comment"></span>
01295 <span class="comment">   BOOLEAN - TRUE if successful, else FALSE</span>
01296 <span class="comment"></span>
01297 <span class="comment">--*/</span>
01298 
01299 {
01300 
01301     BOOLEAN CompletionStatus;
01302 
01303     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01304 
01305     CompletionStatus = <a class="code" href="../../d2/d0/rmvars_8c.html#a4">SepRmDbInitialization</a>();
01306 
01307     <span class="keywordflow">return</span> CompletionStatus;
01308 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:41:40 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
