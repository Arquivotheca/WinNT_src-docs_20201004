<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: rtl/heap.c File Reference</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>heap.c File Reference</h1><code>#include "<a class="el" href="../../d6/d8/ntrtlp_8h-source.html">ntrtlp.h</a>"</code><br>
<code>#include "<a class="el" href="../../d4/d8/heap_8h-source.html">heap.h</a>"</code><br>
<code>#include "<a class="el" href="../../d0/d9/heappriv_8h-source.html">heappriv.h</a>"</code><br>

<p>
<a href="../../d2/d8/rtl_2heap_8c-source.html">Go to the source code of this file.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d1/d9/rtl_2heap_8c.html#a0">HEAP_SLOW_FLAGS</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d1/d9/rtl_2heap_8c.html#a1">RtlFindFirstSetRightMember</a>(Set)</td></tr>

<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>PVOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d1/d9/rtl_2heap_8c.html#a4">RtlDebugCreateHeap</a> (IN ULONG Flags, IN PVOID HeapBase OPTIONAL, IN SIZE_T ReserveSize OPTIONAL, IN SIZE_T CommitSize OPTIONAL, IN PVOID Lock OPTIONAL, IN PRTL_HEAP_PARAMETERS Parameters OPTIONAL)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d1/d9/rtl_2heap_8c.html#a5">RtlDebugDestroyHeap</a> (IN PVOID <a class="el" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>PVOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d1/d9/rtl_2heap_8c.html#a6">RtlDebugAllocateHeap</a> (IN PVOID <a class="el" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, IN ULONG Flags, IN SIZE_T <a class="el" href="../../d9/d7/w98_2lh__open_2pi__mem_8h.html#a0">Size</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d1/d9/rtl_2heap_8c.html#a7">RtlDebugFreeHeap</a> (IN PVOID <a class="el" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, IN ULONG Flags, IN PVOID BaseAddress)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>ULONG&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d1/d9/rtl_2heap_8c.html#a8">RtlDebugSizeHeap</a> (IN PVOID <a class="el" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, IN ULONG Flags, IN PVOID BaseAddress)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d1/d9/rtl_2heap_8c.html#a9">RtlDebugZeroHeap</a> (IN PVOID <a class="el" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, IN ULONG Flags)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html">PHEAP_UNCOMMMTTED_RANGE</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d1/d9/rtl_2heap_8c.html#a10">RtlpCreateUnCommittedRange</a> (IN <a class="el" href="../../d8/d6/struct__HEAP__SEGMENT.html">PHEAP_SEGMENT</a> Segment)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d1/d9/rtl_2heap_8c.html#a11">RtlpDestroyUnCommittedRange</a> (IN <a class="el" href="../../d8/d6/struct__HEAP__SEGMENT.html">PHEAP_SEGMENT</a> Segment, IN <a class="el" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html">PHEAP_UNCOMMMTTED_RANGE</a> UnCommittedRange)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d1/d9/rtl_2heap_8c.html#a12">RtlpInsertUnCommittedPages</a> (IN <a class="el" href="../../d8/d6/struct__HEAP__SEGMENT.html">PHEAP_SEGMENT</a> Segment, IN ULONG_PTR Address, IN SIZE_T <a class="el" href="../../d9/d7/w98_2lh__open_2pi__mem_8h.html#a0">Size</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d1/d9/rtl_2heap_8c.html#a13">RtlpDestroyHeapSegment</a> (IN <a class="el" href="../../d8/d6/struct__HEAP__SEGMENT.html">PHEAP_SEGMENT</a> Segment)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d1/d9/rtl_2heap_8c.html#a14">RtlpExtendHeap</a> (IN <a class="el" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap, IN SIZE_T AllocationSize)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>PVOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d1/d9/rtl_2heap_8c.html#a15">RtlCreateHeap</a> (IN ULONG Flags, IN PVOID HeapBase OPTIONAL, IN SIZE_T ReserveSize OPTIONAL, IN SIZE_T CommitSize OPTIONAL, IN PVOID Lock OPTIONAL, IN PRTL_HEAP_PARAMETERS Parameters OPTIONAL)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>PVOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d1/d9/rtl_2heap_8c.html#a16">RtlDestroyHeap</a> (IN PVOID <a class="el" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>PVOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d1/d9/rtl_2heap_8c.html#a17">RtlAllocateHeap</a> (IN PVOID <a class="el" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, IN ULONG Flags, IN SIZE_T <a class="el" href="../../d9/d7/w98_2lh__open_2pi__mem_8h.html#a0">Size</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>PVOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d1/d9/rtl_2heap_8c.html#a18">RtlAllocateHeapSlowly</a> (IN PVOID <a class="el" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, IN ULONG Flags, IN SIZE_T <a class="el" href="../../d9/d7/w98_2lh__open_2pi__mem_8h.html#a0">Size</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d1/d9/rtl_2heap_8c.html#a19">RtlFreeHeap</a> (IN PVOID <a class="el" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, IN ULONG Flags, IN PVOID BaseAddress)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d1/d9/rtl_2heap_8c.html#a20">RtlFreeHeapSlowly</a> (IN PVOID <a class="el" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, IN ULONG Flags, IN PVOID BaseAddress)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>SIZE_T&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d1/d9/rtl_2heap_8c.html#a21">RtlSizeHeap</a> (IN PVOID <a class="el" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, IN ULONG Flags, IN PVOID BaseAddress)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d1/d9/rtl_2heap_8c.html#a22">RtlZeroHeap</a> (IN PVOID <a class="el" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, IN ULONG Flags)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d1/d9/rtl_2heap_8c.html#a23">RtlpFindAndCommitPages</a> (IN <a class="el" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap, IN <a class="el" href="../../d8/d6/struct__HEAP__SEGMENT.html">PHEAP_SEGMENT</a> Segment, IN OUT PSIZE_T <a class="el" href="../../d9/d7/w98_2lh__open_2pi__mem_8h.html#a0">Size</a>, IN PVOID AddressWanted OPTIONAL)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d1/d9/rtl_2heap_8c.html#a24">RtlpInitializeHeapSegment</a> (IN <a class="el" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap, IN <a class="el" href="../../d8/d6/struct__HEAP__SEGMENT.html">PHEAP_SEGMENT</a> Segment, IN UCHAR SegmentIndex, IN ULONG Flags, IN PVOID BaseAddress, IN PVOID UnCommittedAddress, IN PVOID CommitLimitAddress)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d1/d9/rtl_2heap_8c.html#a25">RtlpCoalesceFreeBlocks</a> (IN <a class="el" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap, IN <a class="el" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a> FreeBlock, IN OUT PSIZE_T FreeSize, IN BOOLEAN RemoveFromFreeList)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d1/d9/rtl_2heap_8c.html#a26">RtlpDeCommitFreeBlock</a> (IN <a class="el" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap, IN <a class="el" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a> FreeBlock, IN SIZE_T FreeSize)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d1/d9/rtl_2heap_8c.html#a27">RtlpInsertFreeBlock</a> (IN <a class="el" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap, IN <a class="el" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a> FreeBlock, IN SIZE_T FreeSize)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html">PHEAP_ENTRY_EXTRA</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d1/d9/rtl_2heap_8c.html#a28">RtlpGetExtraStuffPointer</a> (<a class="el" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a> BusyBlock)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>SIZE_T&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d1/d9/rtl_2heap_8c.html#a29">RtlpGetSizeOfBigBlock</a> (IN <a class="el" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a> BusyBlock)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d1/d9/rtl_2heap_8c.html#a30">RtlpCheckBusyBlockTail</a> (IN <a class="el" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a> BusyBlock)</td></tr>

<tr><td colspan=2><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>ULONG&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d1/d9/rtl_2heap_8c.html#a2">RtlpDisableHeapLookaside</a> = 0</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>UCHAR&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d1/d9/rtl_2heap_8c.html#a3">CheckHeapFillPattern</a> [CHECK_HEAP_TAIL_SIZE]</td></tr>

</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="a0" doxytag="rtl/heap.c::HEAP_SLOW_FLAGS" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define HEAP_SLOW_FLAGS          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><pre class="fragment"><div>(<a class="code" href="../../d9/d9/heappriv_8h.html#a7">HEAP_DEBUG_FLAGS</a>           | \
                         HEAP_SETTABLE_USER_FLAGS   | \
                         <a class="code" href="../../d3/d9/heap_8h.html#a31">HEAP_NEED_EXTRA_FLAGS</a>      | \
                         HEAP_CREATE_ALIGN_16       | \
                         HEAP_FREE_CHECKING_ENABLED | \
                         HEAP_TAIL_CHECKING_ENABLED)
</div></pre>
<p>
Definition at line <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l00036">36</a> of file <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html">rtl/heap.c</a>.
<p>
Referenced by <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l01316">RtlAllocateHeap()</a>, and <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l02931">RtlFreeHeap()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a1" doxytag="rtl/heap.c::RtlFindFirstSetRightMember" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define RtlFindFirstSetRightMember          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Set&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><pre class="fragment"><div>(((Set) &amp; 0xFFFF) ?                                     \
        (((Set) &amp; 0xFF) ?                                   \
            <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a20">RtlpBitsClearLow</a>[(Set) &amp; 0xFF] :                \
            <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a20">RtlpBitsClearLow</a>[((Set) &gt;&gt; 8) &amp; 0xFF] + 8) :    \
        ((((Set) &gt;&gt; 16) &amp; 0xFF) ?                           \
            <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a20">RtlpBitsClearLow</a>[ ((Set) &gt;&gt; 16) &amp; 0xFF] + 16 :  \
            <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a20">RtlpBitsClearLow</a>[ (Set) &gt;&gt; 24] + 24)            \
    )
</div></pre>
<p>
Definition at line <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l00068">68</a> of file <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html">rtl/heap.c</a>.
<p>
Referenced by <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l01316">RtlAllocateHeap()</a>, and <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l02075">RtlAllocateHeapSlowly()</a>.    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a17" doxytag="rtl/heap.c::RtlAllocateHeap" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> PVOID RtlAllocateHeap           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>HeapHandle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Flags</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN SIZE_T&nbsp;</td>
          <td class="mdname" nowrap> <em>Size</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l01316">1316</a> of file <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html">rtl/heap.c</a>.
<p>
References <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00615">_HEAP_LOOKASIDE::Depth</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00076">_HEAP_ENTRY::Flags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00200">_HEAP_FREE_ENTRY::Flags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00322">_HEAP::Flags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00323">_HEAP::ForceFlags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00367">_HEAP::FreeLists</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00236">HEAP_ENTRY_BUSY</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00237">HEAP_ENTRY_EXTRA_PRESENT</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00240">HEAP_ENTRY_LAST_ENTRY</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00239">HEAP_ENTRY_VIRTUAL_ALLOC</a>, <a class="el" href="../../d3/d9/heap_8h.html#a41">HEAP_FREE_ENTRY</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00224">HEAP_GRANULARITY</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00228">HEAP_GRANULARITY_SHIFT</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00231">HEAP_MAXIMUM_BLOCK_SIZE</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00233">HEAP_MAXIMUM_FREELISTS</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l00036">HEAP_SLOW_FLAGS</a>, <a class="el" href="../../d5/d5/memory_8c-source.html#l00115">HeapHandle</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00277">_HEAP_SEGMENT::LastEntryInSegment</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00623">_HEAP_LOOKASIDE::LastTotalAllocates</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00369">_HEAP::LockVariable</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00382">_HEAP::Lookaside</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00383">_HEAP::LookasideLockCount</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d3/d9/heap_8h.html#a34">PHEAP_ENTRY</a>, <a class="el" href="../../d3/d9/heap_8h.html#a40">PHEAP_VIRTUAL_ALLOC_ENTRY</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00182">_HEAP_FREE_ENTRY::PreviousSize</a>, <a class="el" href="../../d6/d8/ntrtlp_8h-source.html#l00246">RTL_PAGED_CODE</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00078">RtlAcquireLockRoutine</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l02075">RtlAllocateHeapSlowly()</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l00068">RtlFindFirstSetRightMember</a>, <a class="el" href="../../d1/d5/rtl_2lookasid_8c-source.html#l00130">RtlpAdjustHeapLookasideDepth()</a>, <a class="el" href="../../d1/d5/rtl_2lookasid_8c-source.html#l00222">RtlpAllocateFromHeapLookaside()</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l05024">RtlpExtendHeap()</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00380">RtlpFastInsertFreeBlockDirect</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00525">RtlpFastRemoveDedicatedFreeBlock</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00502">RtlpFastRemoveFreeBlock</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00547">RtlpFastRemoveNonDedicatedFreeBlock</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l05849">RtlpInsertFreeBlock()</a>, <a class="el" href="../../d0/d9/ppc_2exdsptch_8c-source.html#l00466">RtlRaiseException()</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00079">RtlReleaseLockRoutine</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00060">_HEAP_ENTRY::SegmentIndex</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00189">_HEAP_FREE_ENTRY::SegmentIndex</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00355">_HEAP::Segments</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00104">SET_LAST_STATUS</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00045">_HEAP_ENTRY::Size</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00174">_HEAP_FREE_ENTRY::Size</a>, <a class="el" href="../../d9/d6/lh__open_2pi__mem_8h-source.html#l00017">Size</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00091">_HEAP_ENTRY::SmallTagIndex</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00618">_HEAP_LOOKASIDE::TotalAllocates</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00331">_HEAP::TotalFreeSize</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, <a class="el" href="../../d5/d5/struct__HEAP.html#o25">_HEAP::u</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00085">_HEAP_ENTRY::UnusedBytes</a>, <a class="el" href="../../d5/d4/aug98_2dll32_2icc__i386_8h-source.html#l00064">USHORT</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00353">_HEAP::VirtualAllocdBlocks</a>, and <a class="el" href="../../d4/d8/heap_8h-source.html#l00324">_HEAP::VirtualMemoryThreshold</a>.
<p>
<pre class="fragment"><div>01324                    :
01325 
01326     This routine allocates a memory of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified size from <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified
01327     heap.
01328 
01329 Arguments:
01330 
01331     <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a> - Supplies a pointer to an initialized heap structure
01332 
01333     Flags - Specifies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> set of flags to use to <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a58">control</a> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> allocation
01334 
01335     <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> - Specifies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> size, in bytes, of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> allocation
01336 
01337 Return Value:
01338 
01339     PVOID - returns a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> newly allocated block
01340 
01341 --*/
01342 
01343 {
01344     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap = (<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a>)<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
01345     PULONG FreeListsInUse;
01346     ULONG FreeListsInUseUlong;
01347     SIZE_T AllocationSize;
01348     SIZE_T FreeSize, AllocationIndex;
01349     PLIST_ENTRY FreeListHead, Next;
01350     <a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a> BusyBlock;
01351     <a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a> FreeBlock, SplitBlock, SplitBlock2;
01352     ULONG InUseIndex;
01353     UCHAR FreeFlags;
01354     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01355     EXCEPTION_RECORD ExceptionRecord;
01356     PVOID ReturnValue;
01357     BOOLEAN LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01358 
01359     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
01360 
01361 
01362 <span class="preprocessor">#ifndef NTOS_KERNEL_RUNTIME</span>
01363 <span class="preprocessor"></span><span class="preprocessor">#ifdef NTHEAP_ENABLED</span>
01364 <span class="preprocessor"></span>    {
01365         <span class="keywordflow">if</span> (Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o2">Flags</a> &amp; NTHEAP_ENABLED_FLAG) {
01366 
01367             <span class="keywordflow">return</span> RtlAllocateNtHeap( HeapHandle,
01368                                       Flags,
01369                                       Size);
01370         }
01371     }
01372 <span class="preprocessor">#endif // NTHEAP_ENABLED</span>
01373 <span class="preprocessor"></span><span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
01374 <span class="preprocessor"></span>
01375 
01376     <span class="comment">//</span>
01377     <span class="comment">//  Take the callers flags and add in the flags that we must forcibly set</span>
01378     <span class="comment">//  in the heap</span>
01379     <span class="comment">//</span>
01380 
01381     Flags |= Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o3">ForceFlags</a>;
01382 
01383     <span class="comment">//</span>
01384     <span class="comment">//  Check for special features that force us to call the slow, do-everything</span>
01385     <span class="comment">//  version.  We do everything slow for any of the following flags.</span>
01386     <span class="comment">//</span>
01387     <span class="comment">//    HEAP_SLOW_FLAGS defined as           0x6f030f60</span>
01388     <span class="comment">//</span>
01389     <span class="comment">//      HEAP_DEBUG_FLAGS, defined as       0x69020000 (heappriv.h)</span>
01390     <span class="comment">//</span>
01391     <span class="comment">//        HEAP_VALIDATE_PARAMETERS_ENABLED 0x40000000 (heap.h)</span>
01392     <span class="comment">//</span>
01393     <span class="comment">//        HEAP_VALIDATE_ALL_ENABLED        0x20000000 (heap.h)</span>
01394     <span class="comment">//</span>
01395     <span class="comment">//        HEAP_CAPTURE_STACK_BACKTRACES    0x08000000 (heap.h)</span>
01396     <span class="comment">//</span>
01397     <span class="comment">//        HEAP_CREATE_ENABLE_TRACING       0x00020000 (ntrtl.h winnt obsolete)</span>
01398     <span class="comment">//</span>
01399     <span class="comment">//        HEAP_FLAG_PAGE_ALLOCS            0x01000000 (heappage.h)</span>
01400     <span class="comment">//</span>
01401     <span class="comment">//      HEAP_SETTABLE_USER_FLAGS           0x00000E00 (ntrtl.h)</span>
01402     <span class="comment">//</span>
01403     <span class="comment">//      HEAP_NEED_EXTRA_FLAGS              0x0f000100 (heap.h)</span>
01404     <span class="comment">//</span>
01405     <span class="comment">//      HEAP_CREATE_ALIGN_16               0x00010000 (ntrtl.h winnt obsolete)</span>
01406     <span class="comment">//</span>
01407     <span class="comment">//      HEAP_FREE_CHECKING_ENABLED         0x00000040 (ntrtl.h winnt)</span>
01408     <span class="comment">//</span>
01409     <span class="comment">//      HEAP_TAIL_CHECKING_ENABLED         0x00000020 (ntrtl.h winnt )</span>
01410     <span class="comment">//</span>
01411     <span class="comment">//  We also do everything slow if the size is greater than max long</span>
01412     <span class="comment">//</span>
01413 
01414     <span class="keywordflow">if</span> ((Flags &amp; <a class="code" href="../../d1/d9/rtl_2heap_8c.html#a0">HEAP_SLOW_FLAGS</a>) || (<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> &gt;= 0x80000000)) {
01415 
01416         <span class="keywordflow">return</span> <a class="code" href="../../d9/d9/heappriv_8h.html#a38">RtlAllocateHeapSlowly</a>( HeapHandle, Flags, Size );
01417     }
01418 
01419     <span class="comment">//</span>
01420     <span class="comment">//  At this point we know we are doing everything in this routine</span>
01421     <span class="comment">//  and not taking the slow route.</span>
01422     <span class="comment">//</span>
01423     <span class="comment">//  Round the requested size up to the allocation granularity.  Note</span>
01424     <span class="comment">//  that if the request is for 0 bytes, we still allocate memory, because</span>
01425     <span class="comment">//  we add in an extra 1 byte to protect ourselves from idiots.</span>
01426     <span class="comment">//</span>
01427     <span class="comment">//      Allocation size will be either 16, 24, 32, ...</span>
01428     <span class="comment">//      Allocation index will be 2, 3, 4, ...</span>
01429     <span class="comment">//</span>
01430     <span class="comment">//  Note that allocation size 8 is skipped and are indices 0 and 1</span>
01431     <span class="comment">//</span>
01432 
01433     AllocationSize = ((<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> ? <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> : 1) + <a class="code" href="../../d3/d9/heap_8h.html#a3">HEAP_GRANULARITY</a> - 1 + <span class="keyword">sizeof</span>( <a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">HEAP_ENTRY</a> ))
01434         &amp; ~(<a class="code" href="../../d3/d9/heap_8h.html#a3">HEAP_GRANULARITY</a> -1);
01435     AllocationIndex = AllocationSize &gt;&gt;  <a class="code" href="../../d3/d9/heap_8h.html#a4">HEAP_GRANULARITY_SHIFT</a>;
01436 
01437     <span class="comment">//</span>
01438     <span class="comment">//  If there is a lookaside list and the index is within limits then</span>
01439     <span class="comment">//  try and allocate from the lookaside list.  We'll actually capture</span>
01440     <span class="comment">//  the lookaside pointer from the heap and only use the captured pointer.</span>
01441     <span class="comment">//  This will take care of the condition where a walk or lock heap can</span>
01442     <span class="comment">//  cause us to check for a non null pointer and then have it become null</span>
01443     <span class="comment">//  when we read it again.  If it is non null to start with then even if</span>
01444     <span class="comment">//  the user walks or locks the heap via another thread the pointer to</span>
01445     <span class="comment">//  still valid here so we can still try and do a lookaside list pop.</span>
01446     <span class="comment">//</span>
01447 
01448 <span class="preprocessor">#ifndef NTOS_KERNEL_RUNTIME</span>
01449 <span class="preprocessor"></span>
01450     {
01451         <a class="code" href="../../d6/d6/struct__HEAP__LOOKASIDE.html">PHEAP_LOOKASIDE</a> Lookaside = (<a class="code" href="../../d6/d6/struct__HEAP__LOOKASIDE.html">PHEAP_LOOKASIDE</a>)Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o33">Lookaside</a>;
01452 
01453         <span class="keywordflow">if</span> ((Lookaside != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
01454             (Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o34">LookasideLockCount</a> == 0) &amp;&amp;
01455             (AllocationIndex &lt; <a class="code" href="../../d3/d9/heap_8h.html#a6">HEAP_MAXIMUM_FREELISTS</a>)) {
01456 
01457             <span class="comment">//</span>
01458             <span class="comment">//  If the number of operation elapsed operations is 128 times the</span>
01459             <span class="comment">//  lookaside depth then it is time to adjust the depth</span>
01460             <span class="comment">//</span>
01461 
01462             <span class="keywordflow">if</span> ((LONG)(Lookaside[AllocationIndex].<a class="code" href="../../d6/d6/struct__HEAP__LOOKASIDE.html#o3">TotalAllocates</a> - Lookaside[AllocationIndex].<a class="code" href="../../d6/d6/struct__HEAP__LOOKASIDE.html#o7">LastTotalAllocates</a>) &gt;=
01463                       (Lookaside[AllocationIndex].<a class="code" href="../../d6/d6/struct__HEAP__LOOKASIDE.html#o1">Depth</a> * 128)) {
01464 
01465                 <a class="code" href="../../d0/d6/rtl_2lookasid_8c.html#a4">RtlpAdjustHeapLookasideDepth</a>(&amp;(Lookaside[AllocationIndex]));
01466             }
01467 
01468             ReturnValue = <a class="code" href="../../d0/d6/rtl_2lookasid_8c.html#a5">RtlpAllocateFromHeapLookaside</a>(&amp;(Lookaside[AllocationIndex]));
01469 
01470             <span class="keywordflow">if</span> (ReturnValue != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01471 
01472                 <a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a> BusyBlock;
01473 
01474                 BusyBlock = ((<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)ReturnValue) - 1;
01475                 BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o4">UnusedBytes</a> = (UCHAR)(AllocationSize - <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>);
01476                 BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o5">SmallTagIndex</a> = 0;
01477 
01478                 <span class="keywordflow">if</span> (Flags &amp; HEAP_ZERO_MEMORY) {
01479 
01480                     RtlZeroMemory( ReturnValue, Size );
01481                 }
01482 
01483                 <span class="keywordflow">return</span> ReturnValue;
01484             }
01485         }
01486     }
01487 
01488 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
01489 <span class="preprocessor"></span>
01490     <span class="keywordflow">try</span> {
01491 
01492         <span class="comment">//</span>
01493         <span class="comment">//  Check if we need to serialize our access to the heap</span>
01494         <span class="comment">//</span>
01495 
01496         <span class="keywordflow">if</span> (!(Flags &amp; HEAP_NO_SERIALIZE)) {
01497 
01498             <span class="comment">//</span>
01499             <span class="comment">//  Lock the free list.</span>
01500             <span class="comment">//</span>
01501 
01502             <a class="code" href="../../d9/d9/heappriv_8h.html#a3">RtlAcquireLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
01503 
01504             LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01505         }
01506 
01507         <span class="comment">//</span>
01508         <span class="comment">//  If the allocation index is less than the maximum free list size</span>
01509         <span class="comment">//  then we can use the index to check the free list otherwise we have</span>
01510         <span class="comment">//  to either pull the entry off of the [0] index list or allocate</span>
01511         <span class="comment">//  memory directly for this request.</span>
01512         <span class="comment">//</span>
01513 
01514         <span class="keywordflow">if</span> (AllocationIndex &lt; <a class="code" href="../../d3/d9/heap_8h.html#a6">HEAP_MAXIMUM_FREELISTS</a>) {
01515 
01516             <span class="comment">//</span>
01517             <span class="comment">//  With a size that matches a free list size grab the head</span>
01518             <span class="comment">//  of the list and check if there is an available entry</span>
01519             <span class="comment">//</span>
01520 
01521             FreeListHead = &amp;Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o30">FreeLists</a>[ AllocationIndex ];
01522 
01523             <span class="keywordflow">if</span> ( !IsListEmpty( FreeListHead ))  {
01524 
01525                 <span class="comment">//</span>
01526                 <span class="comment">//  We're in luck the list has an entry so now get the free</span>
01527                 <span class="comment">//  entry,  copy its flags, remove it from the free list</span>
01528                 <span class="comment">//</span>
01529 
01530                 FreeBlock = CONTAINING_RECORD( FreeListHead-&gt;Blink,
01531                                                <a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">HEAP_FREE_ENTRY</a>,
01532                                                FreeList );
01533 
01534                 FreeFlags = FreeBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o3">Flags</a>;
01535 
01536                 <a class="code" href="../../d9/d9/heappriv_8h.html#a20">RtlpFastRemoveDedicatedFreeBlock</a>( Heap, FreeBlock );
01537 
01538                 <span class="comment">//</span>
01539                 <span class="comment">//  Adjust the total number of bytes free in the heap</span>
01540                 <span class="comment">//</span>
01541 
01542                 Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o9">TotalFreeSize</a> -= AllocationIndex;
01543 
01544                 <span class="comment">//</span>
01545                 <span class="comment">//  Mark the block as busy and and set the number of bytes</span>
01546                 <span class="comment">//  unused and tag index.  Also if it is the last entry</span>
01547                 <span class="comment">//  then keep that flag.</span>
01548                 <span class="comment">//</span>
01549 
01550                 BusyBlock = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)FreeBlock;
01551                 BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> = <a class="code" href="../../d3/d9/heap_8h.html#a8">HEAP_ENTRY_BUSY</a> | (FreeFlags &amp; <a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>);
01552                 BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o4">UnusedBytes</a> = (UCHAR)(AllocationSize - <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>);
01553                 BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o5">SmallTagIndex</a> = 0;
01554 
01555             } <span class="keywordflow">else</span> {
01556 
01557                 <span class="comment">//</span>
01558                 <span class="comment">//  The free list that matches our request is empty</span>
01559                 <span class="comment">//</span>
01560                 <span class="comment">//  Scan the free list in use vector to find the smallest</span>
01561                 <span class="comment">//  available free block large enough for our allocations.</span>
01562                 <span class="comment">//</span>
01563 
01564                 <span class="comment">//</span>
01565                 <span class="comment">//  Compute the index of the ULONG where the scan should begin</span>
01566                 <span class="comment">//</span>
01567 
01568                 InUseIndex = (ULONG) (AllocationIndex &gt;&gt; 5);
01569                 FreeListsInUse = &amp;Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o25">u</a>.FreeListsInUseUlong[InUseIndex];
01570 
01571                 <span class="comment">//</span>
01572                 <span class="comment">//  Mask off the bits in the first ULONG that represent allocations</span>
01573                 <span class="comment">//  smaller than we need.</span>
01574                 <span class="comment">//</span>
01575 
01576                 FreeListsInUseUlong = *FreeListsInUse++ &amp; ~((1 &lt;&lt; ((ULONG) AllocationIndex &amp; 0x1f)) - 1);
01577 
01578                 <span class="comment">//</span>
01579                 <span class="comment">//  Begin unrolled loop to scan bit vector.</span>
01580                 <span class="comment">//</span>
01581 
01582                 <span class="keywordflow">switch</span> (InUseIndex) {
01583 
01584                 <span class="keywordflow">case</span> 0:
01585 
01586                     <span class="keywordflow">if</span> (FreeListsInUseUlong) {
01587 
01588                         FreeListHead = &amp;Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o30">FreeLists</a>[0];
01589                         <span class="keywordflow">break</span>;
01590                     }
01591 
01592                     FreeListsInUseUlong = *FreeListsInUse++;
01593 
01594                     <span class="comment">//</span>
01595                     <span class="comment">//  deliberate fallthrough to next ULONG</span>
01596                     <span class="comment">//</span>
01597 
01598                 <span class="keywordflow">case</span> 1:
01599 
01600                     <span class="keywordflow">if</span> (FreeListsInUseUlong) {
01601 
01602                         FreeListHead = &amp;Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o30">FreeLists</a>[32];
01603                         <span class="keywordflow">break</span>;
01604                     }
01605 
01606                     FreeListsInUseUlong = *FreeListsInUse++;
01607 
01608                     <span class="comment">//</span>
01609                     <span class="comment">//  deliberate fallthrough to next ULONG</span>
01610                     <span class="comment">//</span>
01611 
01612                 <span class="keywordflow">case</span> 2:
01613 
01614                     <span class="keywordflow">if</span> (FreeListsInUseUlong) {
01615 
01616                         FreeListHead = &amp;Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o30">FreeLists</a>[64];
01617                         <span class="keywordflow">break</span>;
01618                     }
01619 
01620                     FreeListsInUseUlong = *FreeListsInUse++;
01621 
01622                     <span class="comment">//</span>
01623                     <span class="comment">//  deliberate fallthrough to next ULONG</span>
01624                     <span class="comment">//</span>
01625 
01626                 <span class="keywordflow">case</span> 3:
01627 
01628                     <span class="keywordflow">if</span> (FreeListsInUseUlong) {
01629 
01630                         FreeListHead = &amp;Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o30">FreeLists</a>[96];
01631                         <span class="keywordflow">break</span>;
01632                     }
01633 
01634                     <span class="comment">//</span>
01635                     <span class="comment">//  deliberate fallthrough to non dedicated list</span>
01636                     <span class="comment">//</span>
01637 
01638                 <span class="keywordflow">default</span>:
01639 
01640                     <span class="comment">//</span>
01641                     <span class="comment">//  No suitable entry on the free list was found.</span>
01642                     <span class="comment">//</span>
01643 
01644                     <span class="keywordflow">goto</span> LookInNonDedicatedList;
01645                 }
01646 
01647                 <span class="comment">//</span>
01648                 <span class="comment">//  A free list has been found with a large enough allocation.</span>
01649                 <span class="comment">//  FreeListHead contains the base of the vector it was found in.</span>
01650                 <span class="comment">//  FreeListsInUseUlong contains the vector.</span>
01651                 <span class="comment">//</span>
01652 
01653                 FreeListHead += <a class="code" href="../../d1/d9/rtl_2heap_8c.html#a1">RtlFindFirstSetRightMember</a>( FreeListsInUseUlong );
01654 
01655                 <span class="comment">//</span>
01656                 <span class="comment">//  Grab the free block and remove it from the free list</span>
01657                 <span class="comment">//</span>
01658 
01659                 FreeBlock = CONTAINING_RECORD( FreeListHead-&gt;Blink,
01660                                                <a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">HEAP_FREE_ENTRY</a>,
01661                                                FreeList );
01662 
01663                 <a class="code" href="../../d9/d9/heappriv_8h.html#a20">RtlpFastRemoveDedicatedFreeBlock</a>( Heap, FreeBlock );
01664 
01665     SplitFreeBlock:
01666 
01667                 <span class="comment">//</span>
01668                 <span class="comment">//  Save the blocks flags and decrement the amount of</span>
01669                 <span class="comment">//  free space left in the heap</span>
01670                 <span class="comment">//</span>
01671 
01672                 FreeFlags = FreeBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o3">Flags</a>;
01673                 Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o9">TotalFreeSize</a> -= FreeBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o0">Size</a>;
01674 
01675                 <span class="comment">//</span>
01676                 <span class="comment">//  Mark the block busy</span>
01677                 <span class="comment">//</span>
01678 
01679                 BusyBlock = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)FreeBlock;
01680                 BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> = <a class="code" href="../../d3/d9/heap_8h.html#a8">HEAP_ENTRY_BUSY</a>;
01681 
01682                 <span class="comment">//</span>
01683                 <span class="comment">//  Compute the size (i.e., index) of the amount from this block</span>
01684                 <span class="comment">//  that we don't need and can return to the free list</span>
01685                 <span class="comment">//</span>
01686 
01687                 FreeSize = BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a> - AllocationIndex;
01688 
01689                 <span class="comment">//</span>
01690                 <span class="comment">//  Finish setting up the rest of the new busy block</span>
01691                 <span class="comment">//</span>
01692 
01693                 BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)AllocationIndex;
01694                 BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o4">UnusedBytes</a> = (UCHAR)(AllocationSize - <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>);
01695                 BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o5">SmallTagIndex</a> = 0;
01696 
01697                 <span class="comment">//</span>
01698                 <span class="comment">//  Now if the size that we are going to free up is not zero</span>
01699                 <span class="comment">//  then lets get to work and to the split.</span>
01700                 <span class="comment">//</span>
01701 
01702                 <span class="keywordflow">if</span> (FreeSize != 0) {
01703 
01704                     <span class="comment">//</span>
01705                     <span class="comment">//  But first we won't ever bother doing a split that only</span>
01706                     <span class="comment">//  gives us 8 bytes back.  So if free size is one then just</span>
01707                     <span class="comment">//  bump up the size of the new busy block</span>
01708                     <span class="comment">//</span>
01709 
01710                     <span class="keywordflow">if</span> (FreeSize == 1) {
01711 
01712                         BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a> += 1;
01713                         BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o4">UnusedBytes</a> += <span class="keyword">sizeof</span>( <a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">HEAP_ENTRY</a> );
01714 
01715                     } <span class="keywordflow">else</span> {
01716 
01717                         <span class="comment">//</span>
01718                         <span class="comment">//  Get a pointer to where the new free block will be.</span>
01719                         <span class="comment">//  When we split a block the first part goes to the new</span>
01720                         <span class="comment">//  busy block and the second part goes back to the free</span>
01721                         <span class="comment">//  list</span>
01722                         <span class="comment">//</span>
01723 
01724                         SplitBlock = (<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a>)(BusyBlock + AllocationIndex);
01725 
01726                         <span class="comment">//</span>
01727                         <span class="comment">//  Reset the flags that we copied from the original free list</span>
01728                         <span class="comment">//  header, and set it other size fields.</span>
01729                         <span class="comment">//</span>
01730 
01731                         SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o3">Flags</a> = FreeFlags;
01732                         SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o1">PreviousSize</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)AllocationIndex;
01733                         SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o2">SegmentIndex</a> = BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o2">SegmentIndex</a>;
01734                         SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o0">Size</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)FreeSize;
01735 
01736                         <span class="comment">//</span>
01737                         <span class="comment">//  If nothing else follows this entry then we will insert</span>
01738                         <span class="comment">//  this into the corresponding free list (and update</span>
01739                         <span class="comment">//  Segment-&gt;LastEntryInSegment)</span>
01740                         <span class="comment">//</span>
01741 
01742                         <span class="keywordflow">if</span> (FreeFlags &amp; <a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>) {
01743 
01744                             <a class="code" href="../../d9/d9/heappriv_8h.html#a15">RtlpFastInsertFreeBlockDirect</a>( Heap, SplitBlock, (USHORT)FreeSize);
01745                             Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o9">TotalFreeSize</a> += FreeSize;
01746 
01747                         } <span class="keywordflow">else</span> {
01748 
01749                             <span class="comment">//</span>
01750                             <span class="comment">//  Otherwise we need to check the following block</span>
01751                             <span class="comment">//  and if it is busy then update its previous size</span>
01752                             <span class="comment">//  before inserting our new free block into the</span>
01753                             <span class="comment">//  free list</span>
01754                             <span class="comment">//</span>
01755 
01756                             SplitBlock2 = (<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a>)((<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)SplitBlock + FreeSize);
01757 
01758                             <span class="keywordflow">if</span> (SplitBlock2-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a8">HEAP_ENTRY_BUSY</a>) {
01759 
01760                                 SplitBlock2-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o1">PreviousSize</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)FreeSize;
01761 
01762                                 <a class="code" href="../../d9/d9/heappriv_8h.html#a15">RtlpFastInsertFreeBlockDirect</a>( Heap, SplitBlock, (USHORT)FreeSize );
01763                                 Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o9">TotalFreeSize</a> += FreeSize;
01764 
01765                             } <span class="keywordflow">else</span> {
01766 
01767                                 <span class="comment">//</span>
01768                                 <span class="comment">//  The following block is free so we'll merge</span>
01769                                 <span class="comment">//  these to blocks. by first merging the flags</span>
01770                                 <span class="comment">//</span>
01771 
01772                                 SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o3">Flags</a> = SplitBlock2-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o3">Flags</a>;
01773 
01774                                 <span class="comment">//</span>
01775                                 <span class="comment">//  Removing the second block from its free list</span>
01776                                 <span class="comment">//</span>
01777 
01778                                 <a class="code" href="../../d9/d9/heappriv_8h.html#a19">RtlpFastRemoveFreeBlock</a>( Heap, SplitBlock2 );
01779 
01780                                 <span class="comment">//</span>
01781                                 <span class="comment">//  Updating the free total number of free bytes</span>
01782                                 <span class="comment">//  in the heap and updating the size of the new</span>
01783                                 <span class="comment">//  free block</span>
01784                                 <span class="comment">//</span>
01785 
01786                                 Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o9">TotalFreeSize</a> -= SplitBlock2-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o0">Size</a>;
01787                                 FreeSize += SplitBlock2-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o0">Size</a>;
01788 
01789                                 <span class="comment">//</span>
01790                                 <span class="comment">//  If the new free block is still less than the</span>
01791                                 <span class="comment">//  maximum heap block size then we'll simply</span>
01792                                 <span class="comment">//  insert it back in the free list</span>
01793                                 <span class="comment">//</span>
01794 
01795                                 <span class="keywordflow">if</span> (FreeSize &lt;= <a class="code" href="../../d3/d9/heap_8h.html#a5">HEAP_MAXIMUM_BLOCK_SIZE</a>) {
01796 
01797                                     SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o0">Size</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)FreeSize;
01798 
01799                                     <span class="comment">//</span>
01800                                     <span class="comment">//  Again check if the new following block</span>
01801                                     <span class="comment">//  exists and if so then updsate is previous</span>
01802                                     <span class="comment">//  size</span>
01803                                     <span class="comment">//</span>
01804 
01805                                     <span class="keywordflow">if</span> (!(SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>)) {
01806 
01807                                         ((<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a>)((<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)SplitBlock + FreeSize))-&gt;PreviousSize = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)FreeSize;
01808                                     }
01809 
01810                                     <span class="comment">//</span>
01811                                     <span class="comment">//  Insert the new free block into the free</span>
01812                                     <span class="comment">//  list and update the free heap size</span>
01813                                     <span class="comment">//</span>
01814 
01815                                     <a class="code" href="../../d9/d9/heappriv_8h.html#a15">RtlpFastInsertFreeBlockDirect</a>( Heap, SplitBlock, (USHORT)FreeSize );
01816                                     Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o9">TotalFreeSize</a> += FreeSize;
01817 
01818                                 } <span class="keywordflow">else</span> {
01819 
01820                                     <span class="comment">//</span>
01821                                     <span class="comment">//  The new free block is pretty large so we</span>
01822                                     <span class="comment">//  need to call a private routine to do the</span>
01823                                     <span class="comment">//  insert</span>
01824                                     <span class="comment">//</span>
01825 
01826                                     <a class="code" href="../../d9/d9/heappriv_8h.html#a36">RtlpInsertFreeBlock</a>( Heap, SplitBlock, FreeSize );
01827                                 }
01828                             }
01829                         }
01830 
01831                         <span class="comment">//</span>
01832                         <span class="comment">//  Now that free flags made it back into a free block</span>
01833                         <span class="comment">//  we can zero out what we saved.</span>
01834                         <span class="comment">//</span>
01835 
01836                         FreeFlags = 0;
01837 
01838                         <span class="comment">//</span>
01839                         <span class="comment">//  If splitblock now last, update LastEntryInSegment</span>
01840                         <span class="comment">//</span>
01841 
01842                         <span class="keywordflow">if</span> (SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>) {
01843 
01844                             <a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html">PHEAP_SEGMENT</a> Segment;
01845 
01846                             Segment = Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o22">Segments</a>[SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o2">SegmentIndex</a>];
01847                             Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o14">LastEntryInSegment</a> = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)SplitBlock;
01848                         }
01849                     }
01850                 }
01851 
01852                 <span class="comment">//</span>
01853                 <span class="comment">//  If there are no following entries then mark the new block as</span>
01854                 <span class="comment">//  such</span>
01855                 <span class="comment">//</span>
01856 
01857                 <span class="keywordflow">if</span> (FreeFlags &amp; <a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>) {
01858 
01859                     BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> |= <a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>;
01860                 }
01861             }
01862 
01863             <span class="comment">//</span>
01864             <span class="comment">//  Return the address of the user portion of the allocated block.</span>
01865             <span class="comment">//  This is the byte following the header.</span>
01866             <span class="comment">//</span>
01867 
01868             ReturnValue = BusyBlock + 1;
01869 
01870             <span class="comment">//</span>
01871             <span class="comment">//  **** Release the lock before the zero memory call</span>
01872             <span class="comment">//</span>
01873 
01874             <span class="keywordflow">if</span> (LockAcquired) {
01875 
01876                 <a class="code" href="../../d9/d9/heappriv_8h.html#a4">RtlReleaseLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
01877 
01878                 LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01879             }
01880             
01881             <span class="comment">//</span>
01882             <span class="comment">//  If the flags indicate that we should zero memory then do it now</span>
01883             <span class="comment">//</span>
01884 
01885             <span class="keywordflow">if</span> (Flags &amp; HEAP_ZERO_MEMORY) {
01886 
01887                 RtlZeroMemory( ReturnValue, Size );
01888             }
01889 
01890             <span class="comment">//</span>
01891             <span class="comment">//  And return the allocated block to our caller</span>
01892             <span class="comment">//</span>
01893 
01894             leave;
01895 
01896         <span class="comment">//</span>
01897         <span class="comment">//  Otherwise the allocation request is bigger than the last dedicated</span>
01898         <span class="comment">//  free list size.  Now check if the size is within our threshold.</span>
01899         <span class="comment">//  Meaning that it could be in the [0] free list</span>
01900         <span class="comment">//</span>
01901 
01902         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (AllocationIndex &lt;= Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o4">VirtualMemoryThreshold</a>) {
01903 
01904     LookInNonDedicatedList:
01905 
01906             <span class="comment">//</span>
01907             <span class="comment">//  The following code cycles through the [0] free list until</span>
01908             <span class="comment">//  it finds a block that satisfies the request.  The list</span>
01909             <span class="comment">//  is sorted so the search is can be terminated early on success</span>
01910             <span class="comment">//</span>
01911 
01912             FreeListHead = &amp;Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o30">FreeLists</a>[0];
01913             
01914             <span class="comment">//</span>
01915             <span class="comment">//  Check if the largest block in the list is smaller than the request</span>
01916             <span class="comment">//</span>
01917 
01918             Next = FreeListHead-&gt;Blink;
01919 
01920             <span class="keywordflow">if</span> (FreeListHead != Next) {
01921                 
01922                 FreeBlock = CONTAINING_RECORD( Next, <a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">HEAP_FREE_ENTRY</a>, FreeList );
01923 
01924                 <span class="keywordflow">if</span> (FreeBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o0">Size</a> &gt;= AllocationIndex) {
01925 
01926                     <span class="comment">//</span>
01927                     <span class="comment">//  Here we are sure there is at least a block here larger than</span>
01928                     <span class="comment">//  the requested size. Start searching from the first block</span>
01929                     <span class="comment">//</span>
01930 
01931                     Next = FreeListHead-&gt;Flink;
01932                     
01933                     <span class="keywordflow">while</span> (FreeListHead != Next) {
01934 
01935                         FreeBlock = CONTAINING_RECORD( Next, <a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">HEAP_FREE_ENTRY</a>, FreeList );
01936 
01937                         <span class="keywordflow">if</span> (FreeBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o0">Size</a> &gt;= AllocationIndex) {
01938 
01939                             <span class="comment">//</span>
01940                             <span class="comment">//  We've found something that we can use so now remove</span>
01941                             <span class="comment">//  it from the free list and go to where we treat spliting</span>
01942                             <span class="comment">//  a free block.  Note that the block we found here might</span>
01943                             <span class="comment">//  actually be the exact size we need and that is why</span>
01944                             <span class="comment">//  in the split free block case we have to consider having</span>
01945                             <span class="comment">//  nothing free after the split</span>
01946                             <span class="comment">//</span>
01947 
01948                             <a class="code" href="../../d9/d9/heappriv_8h.html#a21">RtlpFastRemoveNonDedicatedFreeBlock</a>( Heap, FreeBlock );
01949 
01950                             <span class="keywordflow">goto</span> SplitFreeBlock;
01951                         }
01952 
01953                         Next = Next-&gt;Flink;
01954                     }
01955                 }
01956             }
01957 
01958             <span class="comment">//</span>
01959             <span class="comment">//  The [0] list is either empty or everything is too small</span>
01960             <span class="comment">//  so now extend the heap which should get us something less</span>
01961             <span class="comment">//  than or equal to the virtual memory threshold</span>
01962             <span class="comment">//</span>
01963 
01964             FreeBlock = <a class="code" href="../../d1/d9/rtl_2heap_8c.html#a14">RtlpExtendHeap</a>( Heap, AllocationSize );
01965 
01966             <span class="comment">//</span>
01967             <span class="comment">//  And provided we got something we'll treat it just like the previous</span>
01968             <span class="comment">//  split free block cases</span>
01969             <span class="comment">//</span>
01970 
01971             <span class="keywordflow">if</span> (FreeBlock != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01972 
01973                 <a class="code" href="../../d9/d9/heappriv_8h.html#a21">RtlpFastRemoveNonDedicatedFreeBlock</a>( Heap, FreeBlock );
01974 
01975                 <span class="keywordflow">goto</span> SplitFreeBlock;
01976             }
01977 
01978             <span class="comment">//</span>
01979             <span class="comment">//  We weren't able to extend the heap so we must be out of memory</span>
01980             <span class="comment">//</span>
01981 
01982             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_NO_MEMORY;
01983 
01984         <span class="comment">//</span>
01985         <span class="comment">//  At this point the allocation is way too big for any of the free lists</span>
01986         <span class="comment">//  and we can only satisfy this request if the heap is growable</span>
01987         <span class="comment">//</span>
01988 
01989         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o2">Flags</a> &amp; HEAP_GROWABLE) {
01990 
01991             <a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html">PHEAP_VIRTUAL_ALLOC_ENTRY</a> VirtualAllocBlock;
01992 
01993             VirtualAllocBlock = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01994 
01995             <span class="comment">//</span>
01996             <span class="comment">//  Compute how much memory we will need for this allocation which</span>
01997             <span class="comment">//  will include the allocation size plus a header, and then go</span>
01998             <span class="comment">//  get the committed memory</span>
01999             <span class="comment">//</span>
02000 
02001             AllocationSize += FIELD_OFFSET( <a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html">HEAP_VIRTUAL_ALLOC_ENTRY</a>, BusyBlock );
02002 
02003             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwAllocateVirtualMemory( NtCurrentProcess(),
02004                                               (PVOID *)&amp;VirtualAllocBlock,
02005                                               0,
02006                                               &amp;AllocationSize,
02007                                               MEM_COMMIT,
02008                                               PAGE_READWRITE );
02009 
02010             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(Status)) {
02011 
02012                 <span class="comment">//</span>
02013                 <span class="comment">//  Just committed, already zero.  Fill in the new block</span>
02014                 <span class="comment">//  and insert it in the list of big allocation</span>
02015                 <span class="comment">//</span>
02016 
02017                 VirtualAllocBlock-&gt;<a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html#o4">BusyBlock</a>.<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(AllocationSize - <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>);
02018                 VirtualAllocBlock-&gt;<a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html#o4">BusyBlock</a>.<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> = <a class="code" href="../../d3/d9/heap_8h.html#a11">HEAP_ENTRY_VIRTUAL_ALLOC</a> | <a class="code" href="../../d3/d9/heap_8h.html#a9">HEAP_ENTRY_EXTRA_PRESENT</a> | <a class="code" href="../../d3/d9/heap_8h.html#a8">HEAP_ENTRY_BUSY</a>;
02019                 VirtualAllocBlock-&gt;<a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html#o2">CommitSize</a> = AllocationSize;
02020                 VirtualAllocBlock-&gt;<a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html#o3">ReserveSize</a> = AllocationSize;
02021 
02022                 InsertTailList( &amp;Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o21">VirtualAllocdBlocks</a>, (PLIST_ENTRY)VirtualAllocBlock );
02023 
02024                 <span class="comment">//</span>
02025                 <span class="comment">//  Return the address of the user portion of the allocated block.</span>
02026                 <span class="comment">//  This is the byte following the header.</span>
02027                 <span class="comment">//</span>
02028 
02029                 ReturnValue = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)(VirtualAllocBlock + 1);
02030 
02031                 leave;
02032             }
02033 
02034         } <span class="keywordflow">else</span> {
02035 
02036             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_BUFFER_TOO_SMALL;
02037         }
02038 
02039         <span class="comment">//</span>
02040         <span class="comment">//  This is the error return.</span>
02041         <span class="comment">//</span>
02042 
02043         <span class="keywordflow">if</span> (Flags &amp; HEAP_GENERATE_EXCEPTIONS) {
02044 
02045             <span class="comment">//</span>
02046             <span class="comment">//  Construct an exception record.</span>
02047             <span class="comment">//</span>
02048 
02049             ExceptionRecord.ExceptionCode = STATUS_NO_MEMORY;
02050             ExceptionRecord.ExceptionRecord = (PEXCEPTION_RECORD)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02051             ExceptionRecord.NumberParameters = 1;
02052             ExceptionRecord.ExceptionFlags = 0;
02053             ExceptionRecord.ExceptionInformation[ 0 ] = AllocationSize;
02054 
02055             <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a9">RtlRaiseException</a>( &amp;ExceptionRecord );
02056         }
02057 
02058         <a class="code" href="../../d9/d9/heappriv_8h.html#a9">SET_LAST_STATUS</a>(Status);
02059 
02060         ReturnValue = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02061 
02062     } finally {
02063 
02064         <span class="keywordflow">if</span> (LockAcquired) {
02065 
02066             <a class="code" href="../../d9/d9/heappriv_8h.html#a4">RtlReleaseLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
02067         }
02068     }
02069 
02070     <span class="keywordflow">return</span> ReturnValue;
02071 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a18" doxytag="rtl/heap.c::RtlAllocateHeapSlowly" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> PVOID RtlAllocateHeapSlowly           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>HeapHandle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Flags</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN SIZE_T&nbsp;</td>
          <td class="mdname" nowrap> <em>Size</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l02075">2075</a> of file <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html">rtl/heap.c</a>.
<p>
References <a class="el" href="../../d4/d8/heap_8h-source.html#l00351">_HEAP::AlignMask</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00350">_HEAP::AlignRound</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00397">ALLOC_HEAP_FILL</a>, <a class="el" href="../../d9/d9/heappriv_8h.html#a60a27">AllocationAction</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00395">CHECK_HEAP_TAIL_FILL</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00394">CHECK_HEAP_TAIL_SIZE</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00103">DEBUG_HEAP</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00056">EXCEPTION_CONTINUE_SEARCH</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00055">EXCEPTION_EXECUTE_HANDLER</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00200">_HEAP_FREE_ENTRY::Flags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00076">_HEAP_ENTRY::Flags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00322">_HEAP::Flags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00367">_HEAP::FreeLists</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00236">HEAP_ENTRY_BUSY</a>, <a class="el" href="../../d3/d9/heap_8h.html#a35">HEAP_ENTRY_EXTRA</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00237">HEAP_ENTRY_EXTRA_PRESENT</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00238">HEAP_ENTRY_FILL_PATTERN</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00240">HEAP_ENTRY_LAST_ENTRY</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00239">HEAP_ENTRY_VIRTUAL_ALLOC</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00228">HEAP_GRANULARITY_SHIFT</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00231">HEAP_MAXIMUM_BLOCK_SIZE</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00233">HEAP_MAXIMUM_FREELISTS</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00401">HEAP_NEED_EXTRA_FLAGS</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00400">HEAP_SMALL_TAG_MASK</a>, <a class="el" href="../../d5/d5/memory_8c-source.html#l00115">HeapHandle</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00563">IS_HEAP_TAGGING_ENABLED</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00277">_HEAP_SEGMENT::LastEntryInSegment</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00369">_HEAP::LockVariable</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d3/d9/heap_8h.html#a36">PHEAP_ENTRY_EXTRA</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00182">_HEAP_FREE_ENTRY::PreviousSize</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00365">_HEAP::PseudoTagEntries</a>, <a class="el" href="../../d6/d8/ntrtlp_8h-source.html#l00246">RTL_PAGED_CODE</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00078">RtlAcquireLockRoutine</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l00444">RtlDebugAllocateHeap()</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l00068">RtlFindFirstSetRightMember</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l05024">RtlpExtendHeap()</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l06008">RtlpGetExtraStuffPointer()</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l05849">RtlpInsertFreeBlock()</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00322">RtlpInsertFreeBlockDirect</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00465">RtlpRemoveFreeBlock</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l05554">RtlpUpdateTagEntry()</a>, <a class="el" href="../../d0/d9/ppc_2exdsptch_8c-source.html#l00466">RtlRaiseException()</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00079">RtlReleaseLockRoutine</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00189">_HEAP_FREE_ENTRY::SegmentIndex</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00060">_HEAP_ENTRY::SegmentIndex</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00355">_HEAP::Segments</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00104">SET_LAST_STATUS</a>, <a class="el" href="../../d9/d6/lh__open_2pi__mem_8h-source.html#l00017">Size</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00174">_HEAP_FREE_ENTRY::Size</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00045">_HEAP_ENTRY::Size</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00331">_HEAP::TotalFreeSize</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, <a class="el" href="../../d5/d5/struct__HEAP.html#o25">_HEAP::u</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00085">_HEAP_ENTRY::UnusedBytes</a>, <a class="el" href="../../d5/d4/aug98_2dll32_2icc__i386_8h-source.html#l00064">USHORT</a>, <a class="el" href="../../d9/d9/heappriv_8h.html#a60a28">VirtualAllocationAction</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00353">_HEAP::VirtualAllocdBlocks</a>, and <a class="el" href="../../d4/d8/heap_8h-source.html#l00324">_HEAP::VirtualMemoryThreshold</a>.
<p>
Referenced by <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l01316">RtlAllocateHeap()</a>, and <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l00444">RtlDebugAllocateHeap()</a>.
<p>
<pre class="fragment"><div>02083                    :
02084 
02085     This routine does <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> equivalent of Rtl Allocate Heap but <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> does <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> will
02086     additional heap consistency checking logic and tagging.
02087 
02088 Arguments:
02089 
02090     <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a> - Supplies a pointer to an initialized heap structure
02091 
02092     Flags - Specifies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> set of flags to use to <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a58">control</a> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> allocation
02093 
02094     <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> - Specifies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> size, in bytes, of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> allocation
02095 
02096 Return Value:
02097 
02098     PVOID - returns a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> newly allocated block
02099 
02100 --*/
02101 
02102 {
02103     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap = (<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a>)<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
02104     BOOLEAN LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02105     PVOID ReturnValue = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02106     PULONG FreeListsInUse;
02107     ULONG FreeListsInUseUlong;
02108     SIZE_T AllocationSize;
02109     SIZE_T FreeSize, AllocationIndex;
02110     UCHAR EntryFlags, FreeFlags;
02111     PLIST_ENTRY FreeListHead, Next;
02112     <a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a> BusyBlock;
02113     <a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a> FreeBlock, SplitBlock, SplitBlock2;
02114     <a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html">PHEAP_ENTRY_EXTRA</a> ExtraStuff;
02115     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
02116     EXCEPTION_RECORD ExceptionRecord;
02117     SIZE_T ZeroSize = 0;
02118 
02119     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
02120 
02121     <span class="comment">//</span>
02122     <span class="comment">//  Note that Flags has already been OR'd with Heap-&gt;ForceFlags.</span>
02123     <span class="comment">//</span>
02124 
02125 <span class="preprocessor">#ifndef NTOS_KERNEL_RUNTIME</span>
02126 <span class="preprocessor"></span>
02127     <span class="comment">//</span>
02128     <span class="comment">//  In the non kernel case check if we should be using the debug version</span>
02129     <span class="comment">//  of heap allocation</span>
02130     <span class="comment">//</span>
02131 
02132     <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/heappriv_8h.html#a8">DEBUG_HEAP</a>( Flags )) {
02133 
02134         <span class="keywordflow">return</span> <a class="code" href="../../d4/d9/heapdbg_8c.html#a13">RtlDebugAllocateHeap</a>( HeapHandle, Flags, Size );
02135     }
02136 
02137 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
02138 <span class="preprocessor"></span>
02139     <span class="comment">//</span>
02140     <span class="comment">//  If the size is greater than maxlong then say we can't allocate that</span>
02141     <span class="comment">//  much and return the error to our caller</span>
02142     <span class="comment">//</span>
02143 
02144     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> &gt; 0x7fffffff) {
02145 
02146         <a class="code" href="../../d9/d9/heappriv_8h.html#a9">SET_LAST_STATUS</a>( STATUS_NO_MEMORY );
02147 
02148         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02149     }
02150 
02151     <span class="comment">//</span>
02152     <span class="comment">//  Round up the requested size to the allocation granularity.  Note</span>
02153     <span class="comment">//  that if the request is for zero bytes we will still allocate memory,</span>
02154     <span class="comment">//</span>
02155     <span class="comment">//      Allocation size will be either 16, 24, 32, ...</span>
02156     <span class="comment">//      Allocation index will be 2, 3, 4, ...</span>
02157     <span class="comment">//</span>
02158 
02159     AllocationSize = ((<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> ? <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> : 1) + Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o19">AlignRound</a>) &amp; Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o20">AlignMask</a>;
02160 
02161     <span class="comment">//</span>
02162     <span class="comment">//  Generate the flags needed for this heap entry.  Mark it busy and add</span>
02163     <span class="comment">//  any user settable bits.  Also if the input flag indicates any entry</span>
02164     <span class="comment">//  extra fields and we have a tag to use then make room for the extra</span>
02165     <span class="comment">//  fields in the heap entry</span>
02166     <span class="comment">//</span>
02167 
02168     EntryFlags = (UCHAR)(<a class="code" href="../../d3/d9/heap_8h.html#a8">HEAP_ENTRY_BUSY</a> | ((Flags &amp; HEAP_SETTABLE_USER_FLAGS) &gt;&gt; 4));
02169 
02170     <span class="keywordflow">if</span> ((Flags &amp; <a class="code" href="../../d3/d9/heap_8h.html#a31">HEAP_NEED_EXTRA_FLAGS</a>) || (Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o29">PseudoTagEntries</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
02171 
02172         EntryFlags |= <a class="code" href="../../d3/d9/heap_8h.html#a9">HEAP_ENTRY_EXTRA_PRESENT</a>;
02173         AllocationSize += <span class="keyword">sizeof</span>( <a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html">HEAP_ENTRY_EXTRA</a> );
02174     }
02175 
02176     AllocationIndex = AllocationSize &gt;&gt; <a class="code" href="../../d3/d9/heap_8h.html#a4">HEAP_GRANULARITY_SHIFT</a>;
02177 
02178     <span class="keywordflow">try</span> {
02179 
02180         <span class="comment">//</span>
02181         <span class="comment">//  Lock the free list.</span>
02182         <span class="comment">//</span>
02183 
02184         <span class="keywordflow">if</span> (!(Flags &amp; HEAP_NO_SERIALIZE)) {
02185 
02186             <a class="code" href="../../d9/d9/heappriv_8h.html#a3">RtlAcquireLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
02187 
02188             LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02189         }
02190 
02191         <span class="comment">//</span>
02192         <span class="comment">//  Do all the actual heap work under the protection of a try-except clause</span>
02193         <span class="comment">//  to protect us from corruption</span>
02194         <span class="comment">//</span>
02195 
02196         <span class="keywordflow">try</span> {
02197 
02198             <span class="comment">//</span>
02199             <span class="comment">//  If the allocation index is less than the maximum free list size</span>
02200             <span class="comment">//  then we can use the index to check the free list otherwise we have</span>
02201             <span class="comment">//  to either pull the entry off of the [0] index list or allocate</span>
02202             <span class="comment">//  memory directly for this request.</span>
02203             <span class="comment">//</span>
02204 
02205             <span class="keywordflow">if</span> (AllocationIndex &lt; <a class="code" href="../../d3/d9/heap_8h.html#a6">HEAP_MAXIMUM_FREELISTS</a>) {
02206 
02207                 <span class="comment">//</span>
02208                 <span class="comment">//  With a size that matches a free list size grab the head</span>
02209                 <span class="comment">//  of the list and check if there is an available entry</span>
02210                 <span class="comment">//</span>
02211 
02212                 FreeListHead = &amp;Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o30">FreeLists</a>[ AllocationIndex ];
02213 
02214                 <span class="keywordflow">if</span> ( !IsListEmpty( FreeListHead ))  {
02215 
02216                     <span class="comment">//</span>
02217                     <span class="comment">//  We're in luck the list has an entry so now get the free</span>
02218                     <span class="comment">//  entry,  copy its flags, remove it from the free list</span>
02219                     <span class="comment">//</span>
02220 
02221                     FreeBlock = CONTAINING_RECORD( FreeListHead-&gt;Flink,
02222                                                    <a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">HEAP_FREE_ENTRY</a>,
02223                                                    FreeList );
02224 
02225                     FreeFlags = FreeBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o3">Flags</a>;
02226 
02227                     <a class="code" href="../../d9/d9/heappriv_8h.html#a18">RtlpRemoveFreeBlock</a>( Heap, FreeBlock );
02228 
02229                     <span class="comment">//</span>
02230                     <span class="comment">//  Adjust the total number of bytes free in the heap</span>
02231                     <span class="comment">//</span>
02232 
02233                     Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o9">TotalFreeSize</a> -= AllocationIndex;
02234 
02235                     <span class="comment">//</span>
02236                     <span class="comment">//  Mark the block as busy and and set the number of bytes</span>
02237                     <span class="comment">//  unused and tag index.  Also if it is the last entry</span>
02238                     <span class="comment">//  then keep that flag.</span>
02239                     <span class="comment">//</span>
02240 
02241                     BusyBlock = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)FreeBlock;
02242                     BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> = EntryFlags | (FreeFlags &amp; <a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>);
02243                     BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o4">UnusedBytes</a> = (UCHAR)(AllocationSize - <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>);
02244 
02245                 } <span class="keywordflow">else</span> {
02246 
02247                     <span class="comment">//</span>
02248                     <span class="comment">//  The free list that matches our request is empty.  We know</span>
02249                     <span class="comment">//  that there are 128 free lists managed by a 4 ulong bitmap.</span>
02250                     <span class="comment">//  The next big if-else-if statement will decide which ulong</span>
02251                     <span class="comment">//  we tackle</span>
02252                     <span class="comment">//</span>
02253                     <span class="comment">//  Check if the requested allocation index within the first</span>
02254                     <span class="comment">//  quarter of the free lists.</span>
02255                     <span class="comment">//</span>
02256 
02257                     <span class="keywordflow">if</span> (AllocationIndex &lt; (<a class="code" href="../../d3/d9/heap_8h.html#a6">HEAP_MAXIMUM_FREELISTS</a> * 1) / 4) {
02258 
02259                         <span class="comment">//</span>
02260                         <span class="comment">//  Grab a pointer to the corresponding bitmap ulong, and</span>
02261                         <span class="comment">//  then get the bit we're actually interested in to be the</span>
02262                         <span class="comment">//  first bit of the ulong.</span>
02263                         <span class="comment">//</span>
02264 
02265                         FreeListsInUse = &amp;Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o25">u</a>.FreeListsInUseUlong[ 0 ];
02266                         FreeListsInUseUlong = *FreeListsInUse++ &gt;&gt; ((ULONG) AllocationIndex &amp; 0x1F);
02267 
02268                         <span class="comment">//</span>
02269                         <span class="comment">//  If the remaining bitmap has any bits set then we know</span>
02270                         <span class="comment">//  there is a non empty list that is larger than our</span>
02271                         <span class="comment">//  requested index so find that bit and compute the list</span>
02272                         <span class="comment">//  head of the next non empty list</span>
02273                         <span class="comment">//</span>
02274 
02275                         <span class="keywordflow">if</span> (FreeListsInUseUlong) {
02276 
02277                             FreeListHead += <a class="code" href="../../d1/d9/rtl_2heap_8c.html#a1">RtlFindFirstSetRightMember</a>( FreeListsInUseUlong );
02278 
02279                         } <span class="keywordflow">else</span> {
02280 
02281                             <span class="comment">//</span>
02282                             <span class="comment">//  The rest of the first ulong is all zeros so we need</span>
02283                             <span class="comment">//  to move to the second ulong</span>
02284                             <span class="comment">//</span>
02285 
02286                             FreeListsInUseUlong = *FreeListsInUse++;
02287 
02288                             <span class="comment">//</span>
02289                             <span class="comment">//  Check if the second ulong has any bits set and if</span>
02290                             <span class="comment">//  so then compute the list head of the next non empty</span>
02291                             <span class="comment">//  list</span>
02292                             <span class="comment">//</span>
02293 
02294                             <span class="keywordflow">if</span> (FreeListsInUseUlong) {
02295 
02296                                 FreeListHead += ((<a class="code" href="../../d3/d9/heap_8h.html#a6">HEAP_MAXIMUM_FREELISTS</a> * 1) / 4) -
02297                                     (AllocationIndex &amp; 0x1F)  +
02298                                     <a class="code" href="../../d1/d9/rtl_2heap_8c.html#a1">RtlFindFirstSetRightMember</a>( FreeListsInUseUlong );
02299 
02300                             } <span class="keywordflow">else</span> {
02301 
02302                                 <span class="comment">//</span>
02303                                 <span class="comment">//  Do the same test for the third ulong</span>
02304                                 <span class="comment">//</span>
02305 
02306                                 FreeListsInUseUlong = *FreeListsInUse++;
02307 
02308                                 <span class="keywordflow">if</span> (FreeListsInUseUlong) {
02309 
02310                                     FreeListHead += ((<a class="code" href="../../d3/d9/heap_8h.html#a6">HEAP_MAXIMUM_FREELISTS</a> * 2) / 4) -
02311                                         (AllocationIndex &amp; 0x1F) +
02312                                         <a class="code" href="../../d1/d9/rtl_2heap_8c.html#a1">RtlFindFirstSetRightMember</a>( FreeListsInUseUlong );
02313 
02314                                 } <span class="keywordflow">else</span> {
02315 
02316                                     <span class="comment">//</span>
02317                                     <span class="comment">//  Repeat the test for the forth ulong, and if</span>
02318                                     <span class="comment">//  that one is also empty then we need to grab</span>
02319                                     <span class="comment">//  the allocation off of the [0] index list</span>
02320                                     <span class="comment">//</span>
02321 
02322                                     FreeListsInUseUlong = *FreeListsInUse++;
02323 
02324                                     <span class="keywordflow">if</span> (FreeListsInUseUlong) {
02325 
02326                                         FreeListHead += ((<a class="code" href="../../d3/d9/heap_8h.html#a6">HEAP_MAXIMUM_FREELISTS</a> * 3) / 4) -
02327                                             (AllocationIndex &amp; 0x1F)  +
02328                                             <a class="code" href="../../d1/d9/rtl_2heap_8c.html#a1">RtlFindFirstSetRightMember</a>( FreeListsInUseUlong );
02329 
02330                                     } <span class="keywordflow">else</span> {
02331 
02332                                         <span class="keywordflow">goto</span> LookInNonDedicatedList;
02333                                     }
02334                                 }
02335                             }
02336                         }
02337 
02338                     <span class="comment">//</span>
02339                     <span class="comment">//  Otherwise check if the requested allocation index lies</span>
02340                     <span class="comment">//  within the second quarter of the free lists.  We repeat the</span>
02341                     <span class="comment">//  test just like we did above on the second, third, and forth</span>
02342                     <span class="comment">//  bitmap ulongs.</span>
02343                     <span class="comment">//</span>
02344 
02345                     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (AllocationIndex &lt; (<a class="code" href="../../d3/d9/heap_8h.html#a6">HEAP_MAXIMUM_FREELISTS</a> * 2) / 4) {
02346 
02347                         FreeListsInUse = &amp;Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o25">u</a>.FreeListsInUseUlong[ 1 ];
02348                         FreeListsInUseUlong = *FreeListsInUse++ &gt;&gt; ((ULONG) AllocationIndex &amp; 0x1F);
02349 
02350                         <span class="keywordflow">if</span> (FreeListsInUseUlong) {
02351 
02352                             FreeListHead += <a class="code" href="../../d1/d9/rtl_2heap_8c.html#a1">RtlFindFirstSetRightMember</a>( FreeListsInUseUlong );
02353 
02354                         } <span class="keywordflow">else</span> {
02355 
02356                             FreeListsInUseUlong = *FreeListsInUse++;
02357 
02358                             <span class="keywordflow">if</span> (FreeListsInUseUlong) {
02359 
02360                                 FreeListHead += ((<a class="code" href="../../d3/d9/heap_8h.html#a6">HEAP_MAXIMUM_FREELISTS</a> * 1) / 4) -
02361                                     (AllocationIndex &amp; 0x1F)  +
02362                                     <a class="code" href="../../d1/d9/rtl_2heap_8c.html#a1">RtlFindFirstSetRightMember</a>( FreeListsInUseUlong );
02363 
02364                             } <span class="keywordflow">else</span> {
02365 
02366                                 FreeListsInUseUlong = *FreeListsInUse++;
02367 
02368                                 <span class="keywordflow">if</span> (FreeListsInUseUlong) {
02369 
02370                                     FreeListHead += ((<a class="code" href="../../d3/d9/heap_8h.html#a6">HEAP_MAXIMUM_FREELISTS</a> * 2) / 4) -
02371                                         (AllocationIndex &amp; 0x1F)  +
02372                                         <a class="code" href="../../d1/d9/rtl_2heap_8c.html#a1">RtlFindFirstSetRightMember</a>( FreeListsInUseUlong );
02373 
02374                                 } <span class="keywordflow">else</span> {
02375 
02376                                     <span class="keywordflow">goto</span> LookInNonDedicatedList;
02377                                 }
02378                             }
02379                         }
02380 
02381                     <span class="comment">//</span>
02382                     <span class="comment">//  Otherwise check if the requested allocation index lies</span>
02383                     <span class="comment">//  within the third quarter of the free lists. We repeat the</span>
02384                     <span class="comment">//  test just like we did above on the third and forth bitmap</span>
02385                     <span class="comment">//  ulongs</span>
02386                     <span class="comment">//</span>
02387 
02388                     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (AllocationIndex &lt; (<a class="code" href="../../d3/d9/heap_8h.html#a6">HEAP_MAXIMUM_FREELISTS</a> * 3) / 4) {
02389 
02390                         FreeListsInUse = &amp;Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o25">u</a>.FreeListsInUseUlong[ 2 ];
02391                         FreeListsInUseUlong = *FreeListsInUse++ &gt;&gt; ((ULONG) AllocationIndex &amp; 0x1F);
02392 
02393                         <span class="keywordflow">if</span> (FreeListsInUseUlong) {
02394 
02395                             FreeListHead += <a class="code" href="../../d1/d9/rtl_2heap_8c.html#a1">RtlFindFirstSetRightMember</a>( FreeListsInUseUlong );
02396 
02397                         } <span class="keywordflow">else</span> {
02398 
02399                             FreeListsInUseUlong = *FreeListsInUse++;
02400 
02401                             <span class="keywordflow">if</span> (FreeListsInUseUlong) {
02402 
02403                                 FreeListHead += ((<a class="code" href="../../d3/d9/heap_8h.html#a6">HEAP_MAXIMUM_FREELISTS</a> * 1) / 4) -
02404                                     (AllocationIndex &amp; 0x1F)  +
02405                                     <a class="code" href="../../d1/d9/rtl_2heap_8c.html#a1">RtlFindFirstSetRightMember</a>( FreeListsInUseUlong );
02406 
02407                             } <span class="keywordflow">else</span> {
02408 
02409                                 <span class="keywordflow">goto</span> LookInNonDedicatedList;
02410                             }
02411                         }
02412 
02413                     <span class="comment">//</span>
02414                     <span class="comment">//  Lastly the requested allocation index must lie within the</span>
02415                     <span class="comment">//  last quarter of the free lists.  We repeat the test just</span>
02416                     <span class="comment">//  like we did above on the forth ulong</span>
02417                     <span class="comment">//</span>
02418 
02419                     } <span class="keywordflow">else</span> {
02420 
02421                         FreeListsInUse = &amp;Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o25">u</a>.FreeListsInUseUlong[ 3 ];
02422                         FreeListsInUseUlong = *FreeListsInUse++ &gt;&gt; ((ULONG) AllocationIndex &amp; 0x1F);
02423 
02424                         <span class="keywordflow">if</span> (FreeListsInUseUlong) {
02425 
02426                             FreeListHead += <a class="code" href="../../d1/d9/rtl_2heap_8c.html#a1">RtlFindFirstSetRightMember</a>( FreeListsInUseUlong );
02427 
02428                         } <span class="keywordflow">else</span> {
02429 
02430                             <span class="keywordflow">goto</span> LookInNonDedicatedList;
02431                         }
02432                     }
02433 
02434                     <span class="comment">//</span>
02435                     <span class="comment">//  At this point the free list head points to a non empty free</span>
02436                     <span class="comment">//  list that is of greater size than we need.</span>
02437                     <span class="comment">//</span>
02438 
02439                     FreeBlock = CONTAINING_RECORD( FreeListHead-&gt;Flink,
02440                                                    <a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">HEAP_FREE_ENTRY</a>,
02441                                                    FreeList );
02442 
02443     SplitFreeBlock:
02444 
02445                     <span class="comment">//</span>
02446                     <span class="comment">//  Remember the flags that go with this block and remove it</span>
02447                     <span class="comment">//  from its list</span>
02448                     <span class="comment">//</span>
02449 
02450                     FreeFlags = FreeBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o3">Flags</a>;
02451 
02452                     <a class="code" href="../../d9/d9/heappriv_8h.html#a18">RtlpRemoveFreeBlock</a>( Heap, FreeBlock );
02453 
02454                     <span class="comment">//</span>
02455                     <span class="comment">//  Adjust the amount free in the heap</span>
02456                     <span class="comment">//</span>
02457 
02458                     Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o9">TotalFreeSize</a> -= FreeBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o0">Size</a>;
02459 
02460                     <span class="comment">//</span>
02461                     <span class="comment">//  Mark the block busy</span>
02462                     <span class="comment">//</span>
02463 
02464                     BusyBlock = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)FreeBlock;
02465                     BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> = EntryFlags;
02466 
02467                     <span class="comment">//</span>
02468                     <span class="comment">//  Compute the size (i.e., index) of the amount from this</span>
02469                     <span class="comment">//  block that we don't need and can return to the free list</span>
02470                     <span class="comment">//</span>
02471 
02472                     FreeSize = BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a> - AllocationIndex;
02473 
02474                     <span class="comment">//</span>
02475                     <span class="comment">//  Finish setting up the rest of the new busy block</span>
02476                     <span class="comment">//</span>
02477 
02478                     BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)AllocationIndex;
02479                     BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o4">UnusedBytes</a> = (UCHAR)(AllocationSize - <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>);
02480 
02481                     <span class="comment">//</span>
02482                     <span class="comment">//  Now if the size that we are going to free up is not zero</span>
02483                     <span class="comment">//  then lets get to work and to the split.</span>
02484                     <span class="comment">//</span>
02485 
02486                     <span class="keywordflow">if</span> (FreeSize != 0) {
02487 
02488                         <span class="comment">//</span>
02489                         <span class="comment">//  But first we won't ever bother doing a split that only</span>
02490                         <span class="comment">//  gives us 8 bytes back.  So if free size is one then</span>
02491                         <span class="comment">//  just bump up the size of the new busy block</span>
02492                         <span class="comment">//</span>
02493 
02494                         <span class="keywordflow">if</span> (FreeSize == 1) {
02495 
02496                             BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a> += 1;
02497                             BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o4">UnusedBytes</a> += <span class="keyword">sizeof</span>( <a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">HEAP_ENTRY</a> );
02498 
02499                         } <span class="keywordflow">else</span> {
02500 
02501                             <span class="comment">//</span>
02502                             <span class="comment">//  Get a pointer to where the new free block will be.</span>
02503                             <span class="comment">//  When we split a block the first part goes to the</span>
02504                             <span class="comment">//  new busy block and the second part goes back to the</span>
02505                             <span class="comment">//  free list</span>
02506                             <span class="comment">//</span>
02507 
02508                             SplitBlock = (<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a>)(BusyBlock + AllocationIndex);
02509 
02510                             <span class="comment">//</span>
02511                             <span class="comment">//  Reset the flags that we copied from the original</span>
02512                             <span class="comment">//  free list header, and set it other size fields.</span>
02513                             <span class="comment">//</span>
02514 
02515                             SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o3">Flags</a> = FreeFlags;
02516                             SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o1">PreviousSize</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)AllocationIndex;
02517                             SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o2">SegmentIndex</a> = BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o2">SegmentIndex</a>;
02518                             SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o0">Size</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)FreeSize;
02519 
02520                             <span class="comment">//</span>
02521                             <span class="comment">//  If nothing else follows this entry then we will</span>
02522                             <span class="comment">//  insert this into the corresponding free list</span>
02523                             <span class="comment">//</span>
02524 
02525                             <span class="keywordflow">if</span> (FreeFlags &amp; <a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>) {
02526 
02527                                 <a class="code" href="../../d9/d9/heappriv_8h.html#a14">RtlpInsertFreeBlockDirect</a>( Heap, SplitBlock, (USHORT)FreeSize );
02528 
02529                                 Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o9">TotalFreeSize</a> += FreeSize;
02530 
02531                             } <span class="keywordflow">else</span> {
02532 
02533                                 <span class="comment">//</span>
02534                                 <span class="comment">//  Otherwise we need to check the following block</span>
02535                                 <span class="comment">//  and if it is busy then update its previous size</span>
02536                                 <span class="comment">//  before inserting our new free block into the</span>
02537                                 <span class="comment">//  free list</span>
02538                                 <span class="comment">//</span>
02539 
02540                                 SplitBlock2 = (<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a>)((<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)SplitBlock + FreeSize);
02541 
02542                                 <span class="keywordflow">if</span> (SplitBlock2-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a8">HEAP_ENTRY_BUSY</a>) {
02543 
02544                                     SplitBlock2-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o1">PreviousSize</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)FreeSize;
02545 
02546                                     <a class="code" href="../../d9/d9/heappriv_8h.html#a14">RtlpInsertFreeBlockDirect</a>( Heap, SplitBlock, (USHORT)FreeSize );
02547 
02548                                     Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o9">TotalFreeSize</a> += FreeSize;
02549 
02550                                 } <span class="keywordflow">else</span> {
02551 
02552                                     <span class="comment">//</span>
02553                                     <span class="comment">//  The following block is free so we'll merge</span>
02554                                     <span class="comment">//  these to blocks. by first merging the flags</span>
02555                                     <span class="comment">//</span>
02556 
02557                                     SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o3">Flags</a> = SplitBlock2-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o3">Flags</a>;
02558 
02559                                     <span class="comment">//</span>
02560                                     <span class="comment">//  Removing the second block from its free</span>
02561                                     <span class="comment">//  list</span>
02562                                     <span class="comment">//</span>
02563 
02564                                     <a class="code" href="../../d9/d9/heappriv_8h.html#a18">RtlpRemoveFreeBlock</a>( Heap, SplitBlock2 );
02565 
02566                                     <span class="comment">//</span>
02567                                     <span class="comment">//  Updating the free total number of free</span>
02568                                     <span class="comment">//  bytes in the heap and updating the size of</span>
02569                                     <span class="comment">//  the new free block</span>
02570                                     <span class="comment">//</span>
02571 
02572                                     Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o9">TotalFreeSize</a> -= SplitBlock2-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o0">Size</a>;
02573                                     FreeSize += SplitBlock2-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o0">Size</a>;
02574 
02575                                     <span class="comment">//</span>
02576                                     <span class="comment">//  If the new free block is still less than</span>
02577                                     <span class="comment">//  the maximum heap block size then we'll</span>
02578                                     <span class="comment">//  simply insert it back in the free list</span>
02579                                     <span class="comment">//</span>
02580 
02581                                     <span class="keywordflow">if</span> (FreeSize &lt;= <a class="code" href="../../d3/d9/heap_8h.html#a5">HEAP_MAXIMUM_BLOCK_SIZE</a>) {
02582 
02583                                         SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o0">Size</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)FreeSize;
02584 
02585                                         <span class="comment">//</span>
02586                                         <span class="comment">//  Again check if the new following block</span>
02587                                         <span class="comment">//  exists and if so then updsate is</span>
02588                                         <span class="comment">//  previous size</span>
02589                                         <span class="comment">//</span>
02590 
02591                                         <span class="keywordflow">if</span> (!(SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>)) {
02592 
02593                                             ((<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a>)((<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)SplitBlock + FreeSize))-&gt;PreviousSize = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)FreeSize;
02594                                         }
02595 
02596                                         <span class="comment">//</span>
02597                                         <span class="comment">//  Insert the new free block into the free</span>
02598                                         <span class="comment">//  list and update the free heap size</span>
02599                                         <span class="comment">//</span>
02600 
02601                                         <a class="code" href="../../d9/d9/heappriv_8h.html#a14">RtlpInsertFreeBlockDirect</a>( Heap, SplitBlock, (USHORT)FreeSize );
02602 
02603                                         Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o9">TotalFreeSize</a> += FreeSize;
02604 
02605                                     } <span class="keywordflow">else</span> {
02606 
02607                                         <span class="comment">//</span>
02608                                         <span class="comment">//  The new free block is pretty large so</span>
02609                                         <span class="comment">//  we need to call a private routine to do</span>
02610                                         <span class="comment">//  the insert</span>
02611                                         <span class="comment">//</span>
02612 
02613                                         <a class="code" href="../../d9/d9/heappriv_8h.html#a36">RtlpInsertFreeBlock</a>( Heap, SplitBlock, FreeSize );
02614                                     }
02615                                 }
02616                             }
02617 
02618                             <span class="comment">//</span>
02619                             <span class="comment">//  Now that free flags made it back into a free block</span>
02620                             <span class="comment">//  we can zero out what we saved.</span>
02621                             <span class="comment">//</span>
02622 
02623                             FreeFlags = 0;
02624 
02625                             <span class="comment">//</span>
02626                             <span class="comment">//  If splitblock now last, update LastEntryInSegment</span>
02627                             <span class="comment">//</span>
02628 
02629                             <span class="keywordflow">if</span> (SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>) {
02630 
02631                                 <a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html">PHEAP_SEGMENT</a> Segment;
02632 
02633                                 Segment = Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o22">Segments</a>[SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o2">SegmentIndex</a>];
02634                                 Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o14">LastEntryInSegment</a> = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)SplitBlock;
02635                             }
02636 
02637                         }
02638                     }
02639 
02640                     <span class="comment">//</span>
02641                     <span class="comment">//  If there are no following entries then mark the new block</span>
02642                     <span class="comment">//  as such</span>
02643                     <span class="comment">//</span>
02644 
02645                     <span class="keywordflow">if</span> (FreeFlags &amp; <a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>) {
02646 
02647                         BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> |= <a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>;
02648                     }
02649                 }
02650 
02651                 <span class="comment">//</span>
02652                 <span class="comment">//  Return the address of the user portion of the allocated block.</span>
02653                 <span class="comment">//  This is the byte following the header.</span>
02654                 <span class="comment">//</span>
02655 
02656                 ReturnValue = BusyBlock + 1;
02657 
02658                 <span class="comment">//</span>
02659                 <span class="comment">//  If the flags indicate that we should zero memory then</span>
02660                 <span class="comment">//  remember how much to zero.  We'll do the zeroing later</span>
02661                 <span class="comment">//</span>
02662 
02663                 <span class="keywordflow">if</span> (Flags &amp; HEAP_ZERO_MEMORY) {
02664 
02665                     ZeroSize = <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
02666 
02667                 <span class="comment">//</span>
02668                 <span class="comment">//  Otherwise if the flags indicate that we should fill heap then</span>
02669                 <span class="comment">//  it it now.</span>
02670                 <span class="comment">//</span>
02671 
02672                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o2">Flags</a> &amp; HEAP_FREE_CHECKING_ENABLED) {
02673 
02674                     RtlFillMemoryUlong( (PCHAR)(BusyBlock + 1), Size &amp; ~0x3, ALLOC_HEAP_FILL );
02675                 }
02676 
02677                 <span class="comment">//</span>
02678                 <span class="comment">//  If the flags indicate that we should do tail checking then copy</span>
02679                 <span class="comment">//  the fill pattern right after the heap block.</span>
02680                 <span class="comment">//</span>
02681 
02682                 <span class="keywordflow">if</span> (Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o2">Flags</a> &amp; HEAP_TAIL_CHECKING_ENABLED) {
02683 
02684                     RtlFillMemory( (PCHAR)ReturnValue + Size,
02685                                    CHECK_HEAP_TAIL_SIZE,
02686                                    CHECK_HEAP_TAIL_FILL );
02687 
02688                     BusyBlock-&gt;Flags |= <a class="code" href="../../d3/d9/heap_8h.html#a10">HEAP_ENTRY_FILL_PATTERN</a>;
02689                 }
02690 
02691                 BusyBlock-&gt;SmallTagIndex = 0;
02692 
02693                 <span class="comment">//</span>
02694                 <span class="comment">//  If the flags indicate that there is an extra block persent then</span>
02695                 <span class="comment">//  we'll fill it in</span>
02696                 <span class="comment">//</span>
02697 
02698                 <span class="keywordflow">if</span> (BusyBlock-&gt;Flags &amp; <a class="code" href="../../d3/d9/heap_8h.html#a9">HEAP_ENTRY_EXTRA_PRESENT</a>) {
02699 
02700                     ExtraStuff = <a class="code" href="../../d9/d9/heappriv_8h.html#a41">RtlpGetExtraStuffPointer</a>( BusyBlock );
02701 
02702                     RtlZeroMemory( ExtraStuff, <span class="keyword">sizeof</span>( *ExtraStuff ));
02703 
02704 <span class="preprocessor">    #ifndef NTOS_KERNEL_RUNTIME</span>
02705 <span class="preprocessor"></span>
02706                 <span class="comment">//</span>
02707                 <span class="comment">//  In the non kernel case the tagging goes in either the extra</span>
02708                 <span class="comment">//  stuff of the busy block small tag index</span>
02709                 <span class="comment">//</span>
02710 
02711                     <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/heappriv_8h.html#a22">IS_HEAP_TAGGING_ENABLED</a>()) {
02712 
02713                         ExtraStuff-&gt;<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html#o1">TagIndex</a> = <a class="code" href="../../d9/d9/heappriv_8h.html#a52">RtlpUpdateTagEntry</a>( Heap,
02714                                                                    (USHORT)((Flags &amp; HEAP_TAG_MASK) &gt;&gt; HEAP_TAG_SHIFT),
02715                                                                    0,
02716                                                                    BusyBlock-&gt;Size,
02717                                                                    AllocationAction );
02718                     }
02719 
02720                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/heappriv_8h.html#a22">IS_HEAP_TAGGING_ENABLED</a>()) {
02721 
02722                     BusyBlock-&gt;SmallTagIndex = (UCHAR)<a class="code" href="../../d9/d9/heappriv_8h.html#a52">RtlpUpdateTagEntry</a>( Heap,
02723                                                                           (USHORT)((Flags &amp; HEAP_SMALL_TAG_MASK) &gt;&gt; HEAP_TAG_SHIFT),
02724                                                                           0,
02725                                                                           BusyBlock-&gt;Size,
02726                                                                           AllocationAction );
02727 
02728 <span class="preprocessor">    #endif // NTOS_KERNEL_RUNTIME</span>
02729 <span class="preprocessor"></span>
02730                 }
02731 
02732                 <span class="comment">//</span>
02733                 <span class="comment">//  Return the address of the user portion of the allocated block.</span>
02734                 <span class="comment">//  This is the byte following the header.</span>
02735                 <span class="comment">//</span>
02736 
02737                 leave;
02738 
02739             <span class="comment">//</span>
02740             <span class="comment">//  Otherwise the allocation request is bigger than the last dedicated</span>
02741             <span class="comment">//  free list size.  Now check if the size is within our threshold.</span>
02742             <span class="comment">//  Meaning that it could be in the [0] free list</span>
02743             <span class="comment">//</span>
02744 
02745             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (AllocationIndex &lt;= Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o4">VirtualMemoryThreshold</a>) {
02746 
02747     LookInNonDedicatedList:
02748 
02749                 <span class="comment">//</span>
02750                 <span class="comment">//  The following code cycles through the [0] free list until</span>
02751                 <span class="comment">//  it finds a block that satisfies the request.  The list</span>
02752                 <span class="comment">//  is sorted so the search is can be terminated early on success</span>
02753                 <span class="comment">//</span>
02754 
02755                 FreeListHead = &amp;Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o30">FreeLists</a>[ 0 ];
02756                 Next = FreeListHead-&gt;Flink;
02757 
02758                 <span class="keywordflow">while</span> (FreeListHead != Next) {
02759 
02760                     FreeBlock = CONTAINING_RECORD( Next, <a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">HEAP_FREE_ENTRY</a>, FreeList );
02761 
02762                     <span class="keywordflow">if</span> (FreeBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o0">Size</a> &gt;= AllocationIndex) {
02763 
02764                         <span class="comment">//</span>
02765                         <span class="comment">//  We've found something that we can use so now go to</span>
02766                         <span class="comment">//  where we treat spliting a free block.  Note that</span>
02767                         <span class="comment">//  the block we found here might actually be the exact</span>
02768                         <span class="comment">//  size we need and that is why in the split free block</span>
02769                         <span class="comment">//  case we have to consider having nothing free after the</span>
02770                         <span class="comment">//  split</span>
02771                         <span class="comment">//</span>
02772 
02773                         <span class="keywordflow">goto</span> SplitFreeBlock;
02774 
02775                     } <span class="keywordflow">else</span> {
02776 
02777                         Next = Next-&gt;Flink;
02778                     }
02779                 }
02780 
02781                 <span class="comment">//</span>
02782                 <span class="comment">//  The [0] list is either empty or everything is too small</span>
02783                 <span class="comment">//  so now extend the heap which should get us something less</span>
02784                 <span class="comment">//  than or equal to the virtual memory threshold</span>
02785                 <span class="comment">//</span>
02786 
02787                 FreeBlock = <a class="code" href="../../d1/d9/rtl_2heap_8c.html#a14">RtlpExtendHeap</a>( Heap, AllocationSize );
02788 
02789                 <span class="comment">//</span>
02790                 <span class="comment">//  And provided we got something we'll treat it just like the</span>
02791                 <span class="comment">//  previous split free block cases</span>
02792                 <span class="comment">//</span>
02793 
02794                 <span class="keywordflow">if</span> (FreeBlock != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02795 
02796                     <span class="keywordflow">goto</span> SplitFreeBlock;
02797                 }
02798 
02799                 <span class="comment">//</span>
02800                 <span class="comment">//  We weren't able to extend the heap so we must be out of memory</span>
02801                 <span class="comment">//</span>
02802 
02803                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_NO_MEMORY;
02804 
02805             <span class="comment">//</span>
02806             <span class="comment">//  At this point the allocation is way too big for any of the free</span>
02807             <span class="comment">//  lists and we can only satisfy this request if the heap is growable</span>
02808             <span class="comment">//</span>
02809 
02810             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o2">Flags</a> &amp; HEAP_GROWABLE) {
02811 
02812                 <a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html">PHEAP_VIRTUAL_ALLOC_ENTRY</a> VirtualAllocBlock;
02813 
02814                 VirtualAllocBlock = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02815 
02816                 <span class="comment">//</span>
02817                 <span class="comment">//  Compute how much memory we will need for this allocation which</span>
02818                 <span class="comment">//  will include the allocation size plus a header, and then go</span>
02819                 <span class="comment">//  get the committed memory</span>
02820                 <span class="comment">//</span>
02821 
02822                 AllocationSize += FIELD_OFFSET( <a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html">HEAP_VIRTUAL_ALLOC_ENTRY</a>, BusyBlock );
02823 
02824                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwAllocateVirtualMemory( NtCurrentProcess(),
02825                                                   (PVOID *)&amp;VirtualAllocBlock,
02826                                                   0,
02827                                                   &amp;AllocationSize,
02828                                                   MEM_COMMIT,
02829                                                   PAGE_READWRITE );
02830 
02831                 <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
02832 
02833                     <span class="comment">//</span>
02834                     <span class="comment">//  Just committed, already zero.  Fill in the new block</span>
02835                     <span class="comment">//  and insert it in the list of big allocation</span>
02836                     <span class="comment">//</span>
02837 
02838                     VirtualAllocBlock-&gt;<a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html#o4">BusyBlock</a>.<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(AllocationSize - <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>);
02839                     VirtualAllocBlock-&gt;<a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html#o4">BusyBlock</a>.<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> = EntryFlags | <a class="code" href="../../d3/d9/heap_8h.html#a11">HEAP_ENTRY_VIRTUAL_ALLOC</a> | <a class="code" href="../../d3/d9/heap_8h.html#a9">HEAP_ENTRY_EXTRA_PRESENT</a>;
02840                     VirtualAllocBlock-&gt;<a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html#o2">CommitSize</a> = AllocationSize;
02841                     VirtualAllocBlock-&gt;<a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html#o3">ReserveSize</a> = AllocationSize;
02842 
02843 <span class="preprocessor">    #ifndef NTOS_KERNEL_RUNTIME</span>
02844 <span class="preprocessor"></span>
02845                     <span class="comment">//</span>
02846                     <span class="comment">//  In the non kernel case see if we need to add heap tagging</span>
02847                     <span class="comment">//</span>
02848 
02849                     <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/heappriv_8h.html#a22">IS_HEAP_TAGGING_ENABLED</a>()) {
02850 
02851                         VirtualAllocBlock-&gt;<a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html#o1">ExtraStuff</a>.<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html#o1">TagIndex</a> =
02852                             <a class="code" href="../../d9/d9/heappriv_8h.html#a52">RtlpUpdateTagEntry</a>( Heap,
02853                                                 (USHORT)((Flags &amp; HEAP_SMALL_TAG_MASK) &gt;&gt; HEAP_TAG_SHIFT),
02854                                                 0,
02855                                                 VirtualAllocBlock-&gt;<a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html#o2">CommitSize</a> &gt;&gt; HEAP_GRANULARITY_SHIFT,
02856                                                 VirtualAllocationAction );
02857                     }
02858 
02859 <span class="preprocessor">    #endif // NTOS_KERNEL_RUNTIME</span>
02860 <span class="preprocessor"></span>
02861                     InsertTailList( &amp;Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o21">VirtualAllocdBlocks</a>, (PLIST_ENTRY)VirtualAllocBlock );
02862 
02863                     <span class="comment">//</span>
02864                     <span class="comment">//  Return the address of the user portion of the allocated</span>
02865                     <span class="comment">//  block.  This is the byte following the header.</span>
02866                     <span class="comment">//</span>
02867 
02868                     ReturnValue = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)(VirtualAllocBlock + 1);
02869 
02870                     leave;
02871                 }
02872 
02873             <span class="comment">//</span>
02874             <span class="comment">//  Otherwise we have an error condition</span>
02875             <span class="comment">//</span>
02876 
02877             } <span class="keywordflow">else</span> {
02878 
02879                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_BUFFER_TOO_SMALL;
02880             }
02881 
02882             <a class="code" href="../../d9/d9/heappriv_8h.html#a9">SET_LAST_STATUS</a>( Status );
02883 
02884             <span class="keywordflow">if</span> (Flags &amp; HEAP_GENERATE_EXCEPTIONS) {
02885 
02886                 <span class="comment">//</span>
02887                 <span class="comment">//  Construct an exception record.</span>
02888                 <span class="comment">//</span>
02889 
02890                 ExceptionRecord.ExceptionCode = STATUS_NO_MEMORY;
02891                 ExceptionRecord.ExceptionRecord = (PEXCEPTION_RECORD)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02892                 ExceptionRecord.NumberParameters = 1;
02893                 ExceptionRecord.ExceptionFlags = 0;
02894                 ExceptionRecord.ExceptionInformation[ 0 ] = AllocationSize;
02895 
02896                 <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a9">RtlRaiseException</a>( &amp;ExceptionRecord );
02897             }
02898 
02899         } except( GetExceptionCode() == STATUS_NO_MEMORY ? EXCEPTION_CONTINUE_SEARCH :
02900                                                            EXCEPTION_EXECUTE_HANDLER ) {
02901 
02902             <a class="code" href="../../d9/d9/heappriv_8h.html#a9">SET_LAST_STATUS</a>( GetExceptionCode() );
02903         }
02904 
02905         <span class="comment">//</span>
02906         <span class="comment">//  Check if there is anything to zero out</span>
02907         <span class="comment">//</span>
02908 
02909         <span class="keywordflow">if</span> ( ZeroSize ) {
02910 
02911             RtlZeroMemory( ReturnValue, ZeroSize );
02912         }
02913 
02914     } finally {
02915 
02916         <span class="keywordflow">if</span> (LockAcquired) {
02917 
02918             <a class="code" href="../../d9/d9/heappriv_8h.html#a4">RtlReleaseLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
02919         }
02920     }
02921 
02922     <span class="comment">//</span>
02923     <span class="comment">//  And return to our caller</span>
02924     <span class="comment">//</span>
02925 
02926     <span class="keywordflow">return</span> ReturnValue;
02927 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a15" doxytag="rtl/heap.c::RtlCreateHeap" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> PVOID RtlCreateHeap           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Flags</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID HeapBase&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN SIZE_T ReserveSize&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN SIZE_T CommitSize&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID Lock&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PRTL_HEAP_PARAMETERS Parameters&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l00191">191</a> of file <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html">rtl/heap.c</a>.
<p>
References <a class="el" href="../../d4/d8/heap_8h-source.html#l00394">CHECK_HEAP_TAIL_SIZE</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00103">DEBUG_HEAP</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00055">EXCEPTION_EXECUTE_HANDLER</a>, <a class="el" href="../../d3/d9/heap_8h.html#a55">HEAP</a>, <a class="el" href="../../d8/d8/heappage_8h-source.html#l00050">HEAP_BREAK_WHEN_OUT_OF_VM</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00392">HEAP_CAPTURE_STACK_BACKTRACES</a>, <a class="el" href="../../d3/d9/heap_8h.html#a33">HEAP_ENTRY</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00236">HEAP_ENTRY_BUSY</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00224">HEAP_GRANULARITY</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00228">HEAP_GRANULARITY_SHIFT</a>, <a class="el" href="../../d3/d9/heap_8h.html#a47">HEAP_LOCK</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00388">HEAP_LOCK_USER_ALLOCATED</a>, <a class="el" href="../../d9/d9/heappriv_8h.html#a25">HEAP_LOOKASIDE</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00231">HEAP_MAXIMUM_BLOCK_SIZE</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00233">HEAP_MAXIMUM_FREELISTS</a>, <a class="el" href="../../d8/d8/heappage_8h-source.html#l00051">HEAP_NO_ALIGNMENT</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00405">HEAP_NUMBER_OF_PSEUDO_TAG</a>, <a class="el" href="../../d8/d8/heappage_8h-source.html#l00049">HEAP_PROTECTION_ENABLED</a>, <a class="el" href="../../d3/d9/heap_8h.html#a53">HEAP_PSEUDO_TAG_ENTRY</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00281">HEAP_SEGMENT_USER_ALLOCATED</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00387">HEAP_SIGNATURE</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00391">HEAP_SKIP_VALIDATION_CHECKS</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00390">HEAP_VALIDATE_ALL_ENABLED</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00389">HEAP_VALIDATE_PARAMETERS_ENABLED</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00134">HeapDebugBreak</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00121">HeapDebugPrint</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00563">IS_HEAP_TAGGING_ENABLED</a>, <a class="el" href="../../d7/d9/usercli_8h-source.html#l00367">Lock</a>, <a class="el" href="../../d9/d9/cmdat3_8c-source.html#l00105">MmHeapDeCommitFreeBlockThreshold</a>, <a class="el" href="../../d9/d9/cmdat3_8c-source.html#l00104">MmHeapDeCommitTotalFreeThreshold</a>, <a class="el" href="../../d9/d9/cmdat3_8c-source.html#l00103">MmHeapSegmentCommit</a>, <a class="el" href="../../d9/d9/cmdat3_8c-source.html#l00102">MmHeapSegmentReserve</a>, <a class="el" href="../../d8/d9/exts_8h-source.html#l00092">n</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00253">_HEAP_UNCOMMMTTED_RANGE::Next</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d2/ldrp_8h-source.html#l00370">NtGlobalFlag</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00599">PAGE_SIZE</a>, <a class="el" href="../../d3/d9/heap_8h.html#a48">PHEAP_LOCK</a>, <a class="el" href="../../d9/d9/heappriv_8h.html#a26">PHEAP_LOOKASIDE</a>, <a class="el" href="../../d3/d9/heap_8h.html#a54">PHEAP_PSEUDO_TAG_ENTRY</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00030">ROUND_UP_TO_POWER2</a>, <a class="el" href="../../d6/d8/ntrtlp_8h-source.html#l00246">RTL_PAGED_CODE</a>, <a class="el" href="../../d4/d6/config_2utils_2regutil_8c-source.html#l00022">RtlAllocateHeap</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l00204">RtlDebugCreateHeap()</a>, <a class="el" href="../../d5/d6/rtl_2regutil_8c-source.html#l01432">RtlGetNtGlobalFlags()</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00077">RtlInitializeLockRoutine</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l04457">RtlpAddHeapToProcessList()</a>, <a class="el" href="../../d7/d8/heappage_8c-source.html#l00189">RtlpDebugPageHeap</a>, <a class="el" href="../../d7/d8/heappage_8c-source.html#l01997">RtlpDebugPageHeapCreate()</a>, <a class="el" href="../../d9/d1/ldrinit_8c-source.html#l00047">RtlpDisableHeapLookaside</a>, <a class="el" href="../../d1/d5/rtl_2lookasid_8c-source.html#l00045">RtlpInitializeHeapLookaside()</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l04732">RtlpInitializeHeapSegment()</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, and <a class="el" href="../../d5/d4/aug98_2dll32_2icc__i386_8h-source.html#l00064">USHORT</a>.
<p>
Referenced by <a class="el" href="../../d2/d9/csrinit_8c-source.html#l00359">CsrpConnectToServer()</a>, <a class="el" href="../../d9/d1/ldrinit_8c-source.html#l00575">LdrpForkProcess()</a>, <a class="el" href="../../d9/d1/ldrinit_8c-source.html#l00616">LdrpInitializeProcess()</a>, <a class="el" href="../../d2/d0/theap_8c-source.html#l00077">main()</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l00204">RtlDebugCreateHeap()</a>, <a class="el" href="../../d7/d8/heappage_8c-source.html#l01997">RtlpDebugPageHeapCreate()</a>, <a class="el" href="../../d5/d8/smbtrsup_8c-source.html#l00551">SmbTraceStart()</a>, and <a class="el" href="../../d7/d7/clinit_8c-source.html#l00059">UserClientDllInitialize()</a>.
<p>
<pre class="fragment"><div>00202                    :
00203 
00204     This routine initializes a heap.
00205 
00206 Arguments:
00207 
00208     Flags - Specifies optional attributes of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap.
00209 
00210         Valid Flags Values:
00211 
00212         HEAP_NO_SERIALIZE - <span class="keywordflow">if</span> set, then allocations and deallocations on
00213                          <span class="keyword">this</span> heap are NOT <span class="keyword">synchronized</span> by these <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a24">routines</a>.
00214 
00215         HEAP_GROWABLE - <span class="keywordflow">if</span> set, then <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> a <span class="stringliteral">"sparse"</span> heap where
00216                         memory <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> committed <a class="code" href="../../d3/d0/imm32_8def.html#a1">only</a> as necessary instead of
00217                         being preallocated.
00218 
00219     HeapBase - <span class="keywordflow">if</span> not <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, <span class="keyword">this</span> specifies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> base address <span class="keywordflow">for</span> memory
00220         to use as <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap.  If <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, memory <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> allocated by these <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a24">routines</a>.
00221 
00222     ReserveSize - <span class="keywordflow">if</span> not zero, <span class="keyword">this</span> specifies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> amount of <span class="keyword">virtual</span> address
00223         space to reserve <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap.
00224 
00225     CommitSize - <span class="keywordflow">if</span> not zero, <span class="keyword">this</span> specifies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> amount of <span class="keyword">virtual</span> address
00226         space to commit <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap.  Must be less than ReserveSize.  If
00227         zero, then defaults to one page.
00228 
00229     <a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a> - <span class="keywordflow">if</span> not <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, <span class="keyword">this</span> parameter points to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> resource lock to
00230         use.  Only valid <span class="keywordflow">if</span> HEAP_NO_SERIALIZE <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> NOT set.
00231 
00232     Parameters - optional heap parameters.
00233 
00234 Return Value:
00235 
00236     PVOID - a pointer to be used in accessing <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> created heap.
00237 
00238 --*/
00239 
00240 {
00241     ULONG_PTR HighestUserAddress;
00242     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00243     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00244     <a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html">PHEAP_SEGMENT</a> Segment = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00245     PLIST_ENTRY FreeListHead;
00246     ULONG SizeOfHeapHeader;
00247     ULONG SegmentFlags;
00248     PVOID CommittedBase;
00249     PVOID UnCommittedBase;
00250     MEMORY_BASIC_INFORMATION MemoryInformation;
00251     SYSTEM_BASIC_INFORMATION SystemInformation;
00252     ULONG <a class="code" href="../../d7/d0/exts_8h.html#a0">n</a>;
00253     ULONG InitialCountOfUnusedUnCommittedRanges;
00254     SIZE_T MaximumHeapBlockSize;
00255     PVOID NextHeapHeaderAddress;
00256     <a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html">PHEAP_UNCOMMMTTED_RANGE</a> UnCommittedRange, *pp;
00257     RTL_HEAP_PARAMETERS TempParameters;
00258     ULONG <a class="code" href="../../d9/d2/ldrp_8h.html#a33">NtGlobalFlag</a> = <a class="code" href="../../d4/d7/rtl_2regutil_8c.html#a25">RtlGetNtGlobalFlags</a>();
00259 
00260 <span class="preprocessor">#ifndef NTOS_KERNEL_RUNTIME</span>
00261 <span class="preprocessor"></span>
00262     PPEB Peb;
00263 
00264 <span class="preprocessor">#else // NTOS_KERNEL_RUNTIME</span>
00265 <span class="preprocessor"></span>
00266     <span class="keyword">extern</span> SIZE_T <a class="code" href="../../d8/d0/cmdat3_8c.html#a46">MmHeapSegmentReserve</a>;
00267     <span class="keyword">extern</span> SIZE_T <a class="code" href="../../d8/d0/cmdat3_8c.html#a47">MmHeapSegmentCommit</a>;
00268     <span class="keyword">extern</span> SIZE_T <a class="code" href="../../d8/d0/cmdat3_8c.html#a48">MmHeapDeCommitTotalFreeThreshold</a>;
00269     <span class="keyword">extern</span> SIZE_T <a class="code" href="../../d8/d0/cmdat3_8c.html#a49">MmHeapDeCommitFreeBlockThreshold</a>;
00270 
00271 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
00272 <span class="preprocessor"></span>
00273     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
00274 
00275 <span class="preprocessor">#ifndef NTOS_KERNEL_RUNTIME</span>
00276 <span class="preprocessor"></span><span class="preprocessor">#ifdef NTHEAP_ENABLED</span>
00277 <span class="preprocessor"></span>    {
00278         <span class="keywordflow">if</span> (Flags &amp; NTHEAP_ENABLED_FLAG) {
00279 
00280             Heap = RtlCreateNtHeap( Flags, NULL );
00281 
00282             <span class="keywordflow">if</span> (Heap != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00283 
00284                 <span class="keywordflow">return</span> Heap;
00285             }
00286 
00287             Flags &amp;= ~NTHEAP_ENABLED_FLAG;
00288         }
00289     }
00290 <span class="preprocessor">#endif // NTHEAP_ENABLED</span>
00291 <span class="preprocessor"></span><span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
00292 <span class="preprocessor"></span>
00293     <span class="comment">//</span>
00294     <span class="comment">//  Check if we should be using the page heap code.  If not then turn</span>
00295     <span class="comment">//  off any of the page heap flags before going on</span>
00296     <span class="comment">//</span>
00297 
00298 <span class="preprocessor">#ifdef DEBUG_PAGE_HEAP</span>
00299 <span class="preprocessor"></span>
00300     <span class="keywordflow">if</span> ( <a class="code" href="../../d6/d9/heappage_8c.html#a36">RtlpDebugPageHeap</a> &amp;&amp; ( HeapBase == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) &amp;&amp; ( <a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> )) {
00301 
00302         PVOID PageHeap;
00303 
00304         PageHeap = <a class="code" href="../../d7/d9/heappage_8h.html#a9">RtlpDebugPageHeapCreate</a>(
00305 
00306             Flags,
00307             HeapBase,
00308             ReserveSize,
00309             CommitSize,
00310             Lock,
00311             Parameters );
00312 
00313         <span class="keywordflow">if</span> (PageHeap != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00314             <span class="keywordflow">return</span> PageHeap;
00315         }
00316 
00317         <span class="comment">//</span>
00318         <span class="comment">// A `-1' value signals a recursive call from page heap</span>
00319         <span class="comment">// manager. We set this to null and continue creating</span>
00320         <span class="comment">// a normal heap. This small hack is required so that we</span>
00321         <span class="comment">// minimize the dependencies between the normal and the page</span>
00322         <span class="comment">// heap manager.</span>
00323         <span class="comment">//</span>
00324 
00325         <span class="keywordflow">if</span> ((SIZE_T)Parameters == (SIZE_T)-1) {
00326 
00327             Parameters = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00328         }
00329     }
00330 
00331     Flags &amp;= ~( <a class="code" href="../../d7/d9/heappage_8h.html#a2">HEAP_PROTECTION_ENABLED</a> |
00332         <a class="code" href="../../d7/d9/heappage_8h.html#a3">HEAP_BREAK_WHEN_OUT_OF_VM</a> |
00333         <a class="code" href="../../d7/d9/heappage_8h.html#a4">HEAP_NO_ALIGNMENT</a> );
00334 
00335 <span class="preprocessor">#endif // DEBUG_PAGE_HEAP</span>
00336 <span class="preprocessor"></span>
00337     <span class="comment">//</span>
00338     <span class="comment">//  If the caller does not want to skip heap validiation checks then we</span>
00339     <span class="comment">//  need to validate the rest of the flags but simply masking out only</span>
00340     <span class="comment">//  those flags that want on a create heap call</span>
00341     <span class="comment">//</span>
00342 
00343     <span class="keywordflow">if</span> (!(Flags &amp; <a class="code" href="../../d3/d9/heap_8h.html#a23">HEAP_SKIP_VALIDATION_CHECKS</a>)) {
00344 
00345         <span class="keywordflow">if</span> (Flags &amp; ~HEAP_CREATE_VALID_MASK) {
00346 
00347             <a class="code" href="../../d9/d9/heappriv_8h.html#a10">HeapDebugPrint</a>(( <span class="stringliteral">"Invalid flags (%08x) specified to RtlCreateHeap\n"</span>, Flags ));
00348             <a class="code" href="../../d9/d9/heappriv_8h.html#a11">HeapDebugBreak</a>( NULL );
00349 
00350             Flags &amp;= HEAP_CREATE_VALID_MASK;
00351         }
00352     }
00353 
00354     <span class="comment">//</span>
00355     <span class="comment">//  The maximum heap block size is really 0x7f000 which is 0x80000 minus a</span>
00356     <span class="comment">//  page.  Maximum block size is 0xfe00 and granularity shift is 3.</span>
00357     <span class="comment">//</span>
00358 
00359     MaximumHeapBlockSize = <a class="code" href="../../d3/d9/heap_8h.html#a5">HEAP_MAXIMUM_BLOCK_SIZE</a> &lt;&lt; <a class="code" href="../../d3/d9/heap_8h.html#a4">HEAP_GRANULARITY_SHIFT</a>;
00360 
00361     <span class="comment">//</span>
00362     <span class="comment">//  Assume we're going to be successful until we're shown otherwise</span>
00363     <span class="comment">//</span>
00364 
00365     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
00366 
00367     <span class="comment">//</span>
00368     <span class="comment">//  This part of the routine builds up local variable containing all the</span>
00369     <span class="comment">//  parameters used to initialize the heap.  First thing we do is zero</span>
00370     <span class="comment">//  it out.</span>
00371     <span class="comment">//</span>
00372 
00373     RtlZeroMemory( &amp;TempParameters, <span class="keyword">sizeof</span>( TempParameters ) );
00374 
00375     <span class="comment">//</span>
00376     <span class="comment">//  If our caller supplied the optional heap parameters then we'll</span>
00377     <span class="comment">//  make sure the size is good and copy over them over to our</span>
00378     <span class="comment">//  local copy</span>
00379     <span class="comment">//</span>
00380 
00381     <span class="keywordflow">if</span> (ARGUMENT_PRESENT( Parameters )) {
00382 
00383         <span class="keywordflow">try</span> {
00384 
00385             <span class="keywordflow">if</span> (Parameters-&gt;Length == <span class="keyword">sizeof</span>( *Parameters )) {
00386 
00387                 RtlMoveMemory( &amp;TempParameters, Parameters, <span class="keyword">sizeof</span>( *Parameters ) );
00388             }
00389 
00390         } except( EXCEPTION_EXECUTE_HANDLER ) {
00391 
00392             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = GetExceptionCode();
00393         }
00394 
00395         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
00396 
00397             <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00398         }
00399     }
00400 
00401     <span class="comment">//</span>
00402     <span class="comment">//  Set the parameter block to the local copy</span>
00403     <span class="comment">//</span>
00404 
00405     Parameters = &amp;TempParameters;
00406 
00407     <span class="comment">//</span>
00408     <span class="comment">//  If nt global flags tells us to always do tail or free checking</span>
00409     <span class="comment">//  or to disable coalescing then force those bits set in the user</span>
00410     <span class="comment">//  specified flags</span>
00411     <span class="comment">//</span>
00412 
00413     <span class="keywordflow">if</span> (<a class="code" href="../../d9/d2/ldrp_8h.html#a33">NtGlobalFlag</a> &amp; FLG_HEAP_ENABLE_TAIL_CHECK) {
00414 
00415         Flags |= HEAP_TAIL_CHECKING_ENABLED;
00416     }
00417 
00418     <span class="keywordflow">if</span> (<a class="code" href="../../d9/d2/ldrp_8h.html#a33">NtGlobalFlag</a> &amp; FLG_HEAP_ENABLE_FREE_CHECK) {
00419 
00420         Flags |= HEAP_FREE_CHECKING_ENABLED;
00421     }
00422 
00423     <span class="keywordflow">if</span> (<a class="code" href="../../d9/d2/ldrp_8h.html#a33">NtGlobalFlag</a> &amp; FLG_HEAP_DISABLE_COALESCING) {
00424 
00425         Flags |= HEAP_DISABLE_COALESCE_ON_FREE;
00426     }
00427 
00428 <span class="preprocessor">#ifndef NTOS_KERNEL_RUNTIME</span>
00429 <span class="preprocessor"></span>
00430     <span class="comment">//</span>
00431     <span class="comment">//  In the non kernel case we also check if we should</span>
00432     <span class="comment">//  validate parameters, validate all, or do stack backtraces</span>
00433     <span class="comment">//</span>
00434 
00435     Peb = NtCurrentPeb();
00436 
00437     <span class="keywordflow">if</span> (<a class="code" href="../../d9/d2/ldrp_8h.html#a33">NtGlobalFlag</a> &amp; FLG_HEAP_VALIDATE_PARAMETERS) {
00438 
00439         Flags |= <a class="code" href="../../d3/d9/heap_8h.html#a21">HEAP_VALIDATE_PARAMETERS_ENABLED</a>;
00440     }
00441 
00442     <span class="keywordflow">if</span> (<a class="code" href="../../d9/d2/ldrp_8h.html#a33">NtGlobalFlag</a> &amp; FLG_HEAP_VALIDATE_ALL) {
00443 
00444         Flags |= <a class="code" href="../../d3/d9/heap_8h.html#a22">HEAP_VALIDATE_ALL_ENABLED</a>;
00445     }
00446 
00447     <span class="keywordflow">if</span> (<a class="code" href="../../d9/d2/ldrp_8h.html#a33">NtGlobalFlag</a> &amp; FLG_USER_STACK_TRACE_DB) {
00448 
00449         Flags |= <a class="code" href="../../d3/d9/heap_8h.html#a24">HEAP_CAPTURE_STACK_BACKTRACES</a>;
00450     }
00451 
00452     <span class="comment">//</span>
00453     <span class="comment">//  Also in the non kernel case the PEB will have some state</span>
00454     <span class="comment">//  variables that we need to set if the user hasn't specified</span>
00455     <span class="comment">//  otherwise</span>
00456     <span class="comment">//</span>
00457 
00458     <span class="keywordflow">if</span> (Parameters-&gt;SegmentReserve == 0) {
00459 
00460         Parameters-&gt;SegmentReserve = Peb-&gt;HeapSegmentReserve;
00461     }
00462 
00463     <span class="keywordflow">if</span> (Parameters-&gt;SegmentCommit == 0) {
00464 
00465         Parameters-&gt;SegmentCommit = Peb-&gt;HeapSegmentCommit;
00466     }
00467 
00468     <span class="keywordflow">if</span> (Parameters-&gt;DeCommitFreeBlockThreshold == 0) {
00469 
00470         Parameters-&gt;DeCommitFreeBlockThreshold = Peb-&gt;HeapDeCommitFreeBlockThreshold;
00471     }
00472 
00473     <span class="keywordflow">if</span> (Parameters-&gt;DeCommitTotalFreeThreshold == 0) {
00474 
00475         Parameters-&gt;DeCommitTotalFreeThreshold = Peb-&gt;HeapDeCommitTotalFreeThreshold;
00476     }
00477 <span class="preprocessor">#else // NTOS_KERNEL_RUNTIME</span>
00478 <span class="preprocessor"></span>
00479     <span class="comment">//</span>
00480     <span class="comment">//  In the kernel case Mm has some global variables that we set</span>
00481     <span class="comment">//  into the paramters if the user hasn't specified otherwise</span>
00482     <span class="comment">//</span>
00483 
00484     <span class="keywordflow">if</span> (Parameters-&gt;SegmentReserve == 0) {
00485 
00486         Parameters-&gt;SegmentReserve = <a class="code" href="../../d8/d0/cmdat3_8c.html#a46">MmHeapSegmentReserve</a>;
00487     }
00488 
00489     <span class="keywordflow">if</span> (Parameters-&gt;SegmentCommit == 0) {
00490 
00491         Parameters-&gt;SegmentCommit = <a class="code" href="../../d8/d0/cmdat3_8c.html#a47">MmHeapSegmentCommit</a>;
00492     }
00493 
00494     <span class="keywordflow">if</span> (Parameters-&gt;DeCommitFreeBlockThreshold == 0) {
00495 
00496         Parameters-&gt;DeCommitFreeBlockThreshold = <a class="code" href="../../d8/d0/cmdat3_8c.html#a49">MmHeapDeCommitFreeBlockThreshold</a>;
00497     }
00498 
00499     <span class="keywordflow">if</span> (Parameters-&gt;DeCommitTotalFreeThreshold == 0) {
00500 
00501         Parameters-&gt;DeCommitTotalFreeThreshold = <a class="code" href="../../d8/d0/cmdat3_8c.html#a48">MmHeapDeCommitTotalFreeThreshold</a>;
00502     }
00503 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
00504 <span class="preprocessor"></span>
00505     <span class="comment">//</span>
00506     <span class="comment">//  Get the highest user address</span>
00507     <span class="comment">//</span>
00508 
00509     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(ZwQuerySystemInformation(SystemBasicInformation,
00510                                              &amp;SystemInformation,
00511                                              <span class="keyword">sizeof</span>(SystemInformation),
00512                                              NULL))) {
00513         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00514     }
00515     HighestUserAddress = SystemInformation.MaximumUserModeAddress;
00516 
00517     <span class="comment">//</span>
00518     <span class="comment">//  If the user hasn't said what the largest allocation size is then</span>
00519     <span class="comment">//  we should compute it as the difference between the highest and lowest</span>
00520     <span class="comment">//  address less one page</span>
00521     <span class="comment">//</span>
00522 
00523     <span class="keywordflow">if</span> (Parameters-&gt;MaximumAllocationSize == 0) {
00524 
00525         Parameters-&gt;MaximumAllocationSize = (HighestUserAddress -
00526                                              (ULONG_PTR)MM_LOWEST_USER_ADDRESS -
00527                                              <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> );
00528     }
00529 
00530     <span class="comment">//</span>
00531     <span class="comment">//  Set the virtual memory threshold to be non zero and not more than the</span>
00532     <span class="comment">//  maximum heap block size of 0x7f000.  If the user specified one that is</span>
00533     <span class="comment">//  too large we automatically and silently drop it down.</span>
00534     <span class="comment">//</span>
00535 
00536     <span class="keywordflow">if</span> ((Parameters-&gt;VirtualMemoryThreshold == 0) ||
00537         (Parameters-&gt;VirtualMemoryThreshold &gt; MaximumHeapBlockSize)) {
00538 
00539         Parameters-&gt;VirtualMemoryThreshold = MaximumHeapBlockSize;
00540     }
00541 
00542     <span class="comment">//</span>
00543     <span class="comment">//  The default commit size is one page and the default reserve size is</span>
00544     <span class="comment">//  64 pages.</span>
00545     <span class="comment">//</span>
00546     <span class="comment">//  **** this doesn't check that commit size if specified is less than</span>
00547     <span class="comment">//  **** reserved size if specified</span>
00548     <span class="comment">//</span>
00549 
00550     <span class="keywordflow">if</span> (!ARGUMENT_PRESENT( CommitSize )) {
00551 
00552         CommitSize = <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
00553 
00554         <span class="keywordflow">if</span> (!ARGUMENT_PRESENT( ReserveSize )) {
00555 
00556             ReserveSize = 64 * CommitSize;
00557 
00558         } <span class="keywordflow">else</span> {
00559 
00560             ReserveSize = <a class="code" href="../../d3/d9/heap_8h.html#a1">ROUND_UP_TO_POWER2</a>( ReserveSize, PAGE_SIZE );
00561         }
00562 
00563     } <span class="keywordflow">else</span> {
00564 
00565         <span class="comment">//</span>
00566         <span class="comment">//  The heap actually uses space that is reserved and commited</span>
00567         <span class="comment">//  to store internal data structures (the LOCK,</span>
00568         <span class="comment">//  the HEAP_PSEUDO_TAG, etc.). These structures can be larger than</span>
00569         <span class="comment">//  4K especially on a 64-bit build. So, make sure the commit</span>
00570         <span class="comment">//  is at least 8K in length which is the minimal page size for</span>
00571         <span class="comment">//  64-bit systems</span>
00572         <span class="comment">//</span>
00573 
00574         CommitSize = <a class="code" href="../../d3/d9/heap_8h.html#a1">ROUND_UP_TO_POWER2</a>(CommitSize, PAGE_SIZE);
00575 
00576         <span class="keywordflow">if</span> (!ARGUMENT_PRESENT( ReserveSize )) {
00577 
00578             ReserveSize = <a class="code" href="../../d3/d9/heap_8h.html#a1">ROUND_UP_TO_POWER2</a>( CommitSize, 16 * PAGE_SIZE );
00579 
00580         } <span class="keywordflow">else</span> {
00581 
00582             ReserveSize = <a class="code" href="../../d3/d9/heap_8h.html#a1">ROUND_UP_TO_POWER2</a>( ReserveSize, PAGE_SIZE );
00583         }
00584 
00585     }
00586 
00587 <span class="preprocessor">#ifndef NTOS_KERNEL_RUNTIME</span>
00588 <span class="preprocessor"></span>
00589     <span class="comment">//</span>
00590     <span class="comment">//  In the non kernel case check if we are creating a debug heap</span>
00591     <span class="comment">//  the test checks that skip validation checks is false.</span>
00592     <span class="comment">//</span>
00593 
00594     <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/heappriv_8h.html#a8">DEBUG_HEAP</a>( Flags )) {
00595 
00596         <span class="keywordflow">return</span> <a class="code" href="../../d4/d9/heapdbg_8c.html#a10">RtlDebugCreateHeap</a>( Flags,
00597                                    HeapBase,
00598                                    ReserveSize,
00599                                    CommitSize,
00600                                    Lock,
00601                                    Parameters );
00602     }
00603 
00604 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
00605 <span class="preprocessor"></span>
00606     <span class="comment">//</span>
00607     <span class="comment">//  Compute the size of the heap which will be the</span>
00608     <span class="comment">//  heap struct itself and if we are to seralize with</span>
00609     <span class="comment">//  out own lock then add room for the lock.  If the</span>
00610     <span class="comment">//  user did not supply the lock then set the lock</span>
00611     <span class="comment">//  variable to -1.</span>
00612     <span class="comment">//</span>
00613 
00614     SizeOfHeapHeader = <span class="keyword">sizeof</span>( <a class="code" href="../../d5/d5/struct__HEAP.html">HEAP</a> );
00615 
00616     <span class="keywordflow">if</span> (!(Flags &amp; HEAP_NO_SERIALIZE)) {
00617 
00618         <span class="keywordflow">if</span> (ARGUMENT_PRESENT( Lock )) {
00619 
00620             Flags |= <a class="code" href="../../d3/d9/heap_8h.html#a20">HEAP_LOCK_USER_ALLOCATED</a>;
00621 
00622         } <span class="keywordflow">else</span> {
00623 
00624             SizeOfHeapHeader += <span class="keyword">sizeof</span>( <a class="code" href="../../d4/d6/struct__HEAP__LOCK.html">HEAP_LOCK</a> );
00625             <a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a> = (<a class="code" href="../../d4/d6/struct__HEAP__LOCK.html">PHEAP_LOCK</a>)-1;
00626         }
00627 
00628     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ARGUMENT_PRESENT( Lock )) {
00629 
00630         <span class="comment">//</span>
00631         <span class="comment">//  In this error case the call said not to seralize but also fed us</span>
00632         <span class="comment">//  a lock</span>
00633         <span class="comment">//</span>
00634 
00635         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00636     }
00637 
00638     <span class="comment">//</span>
00639     <span class="comment">//  See if caller allocate the space for the heap.</span>
00640     <span class="comment">//</span>
00641 
00642     <span class="keywordflow">if</span> (ARGUMENT_PRESENT( HeapBase )) {
00643 
00644         <span class="comment">//</span>
00645         <span class="comment">//  The call specified a heap base now check if there is</span>
00646         <span class="comment">//  a caller supplied commit routine</span>
00647         <span class="comment">//</span>
00648 
00649         <span class="keywordflow">if</span> (Parameters-&gt;CommitRoutine != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00650 
00651             <span class="comment">//</span>
00652             <span class="comment">//  The caller specified a commit routine so he caller</span>
00653             <span class="comment">//  also needs to have given us certain parameters and make</span>
00654             <span class="comment">//  sure the heap is not growable.  Otherwise it is an error</span>
00655             <span class="comment">//</span>
00656 
00657             <span class="keywordflow">if</span> ((Parameters-&gt;InitialCommit == 0) ||
00658                 (Parameters-&gt;InitialReserve == 0) ||
00659                 (Parameters-&gt;InitialCommit &gt; Parameters-&gt;InitialReserve) ||
00660                 (Flags &amp; HEAP_GROWABLE)) {
00661 
00662                 <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00663             }
00664 
00665             <span class="comment">//</span>
00666             <span class="comment">//  Set the commited base and the uncommited base to the</span>
00667             <span class="comment">//  proper pointers within the heap.</span>
00668             <span class="comment">//</span>
00669 
00670             CommittedBase = HeapBase;
00671             UnCommittedBase = (PCHAR)CommittedBase + Parameters-&gt;InitialCommit;
00672             ReserveSize = Parameters-&gt;InitialReserve;
00673 
00674             <span class="comment">//</span>
00675             <span class="comment">//  Zero out a page of the heap where our first part goes</span>
00676             <span class="comment">//</span>
00677             <span class="comment">//  **** what if the size is less than a page</span>
00678             <span class="comment">//</span>
00679 
00680             RtlZeroMemory( CommittedBase, PAGE_SIZE );
00681 
00682         } <span class="keywordflow">else</span> {
00683 
00684             <span class="comment">//</span>
00685             <span class="comment">//  The user gave us space but not commit routine</span>
00686             <span class="comment">//  So query the base to get its size</span>
00687             <span class="comment">//</span>
00688 
00689             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwQueryVirtualMemory( NtCurrentProcess(),
00690                                            HeapBase,
00691                                            MemoryBasicInformation,
00692                                            &amp;MemoryInformation,
00693                                            <span class="keyword">sizeof</span>( MemoryInformation ),
00694                                            NULL );
00695 
00696             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
00697 
00698                 <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00699             }
00700 
00701             <span class="comment">//</span>
00702             <span class="comment">//  Make sure the user gave us a base address for this block</span>
00703             <span class="comment">//  and that the memory is not free</span>
00704             <span class="comment">//</span>
00705 
00706             <span class="keywordflow">if</span> (MemoryInformation.BaseAddress != HeapBase) {
00707 
00708                 <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00709             }
00710 
00711             <span class="keywordflow">if</span> (MemoryInformation.State == MEM_FREE) {
00712 
00713                 <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00714             }
00715 
00716             <span class="comment">//</span>
00717             <span class="comment">//  Set our commit base to the start of the range</span>
00718             <span class="comment">//</span>
00719 
00720             CommittedBase = MemoryInformation.BaseAddress;
00721 
00722             <span class="comment">//</span>
00723             <span class="comment">//  If the memory is commmitted then</span>
00724             <span class="comment">//  we can zero out a page worth</span>
00725             <span class="comment">//</span>
00726 
00727             <span class="keywordflow">if</span> (MemoryInformation.State == MEM_COMMIT) {
00728 
00729                 RtlZeroMemory( CommittedBase, PAGE_SIZE );
00730 
00731                 <span class="comment">//</span>
00732                 <span class="comment">//  Set the commit size and uncommited base according</span>
00733                 <span class="comment">//  to the start of the vm</span>
00734                 <span class="comment">//</span>
00735 
00736                 CommitSize = MemoryInformation.RegionSize;
00737                 UnCommittedBase = (PCHAR)CommittedBase + CommitSize;
00738 
00739                 <span class="comment">//</span>
00740                 <span class="comment">//  Find out the uncommited base is reserved and if so</span>
00741                 <span class="comment">//  the update the reserve size accordingly.</span>
00742                 <span class="comment">//</span>
00743 
00744                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwQueryVirtualMemory( NtCurrentProcess(),
00745                                                UnCommittedBase,
00746                                                MemoryBasicInformation,
00747                                                &amp;MemoryInformation,
00748                                                <span class="keyword">sizeof</span>( MemoryInformation ),
00749                                                NULL );
00750 
00751                 ReserveSize = CommitSize;
00752 
00753                 <span class="keywordflow">if</span> ((<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) &amp;&amp;
00754                     (MemoryInformation.State == MEM_RESERVE)) {
00755 
00756                     ReserveSize += MemoryInformation.RegionSize;
00757                 }
00758 
00759             } <span class="keywordflow">else</span> {
00760 
00761                 <span class="comment">//</span>
00762                 <span class="comment">//  The memory the user gave us is not committed so dummy</span>
00763                 <span class="comment">//  up these small nummbers</span>
00764                 <span class="comment">//</span>
00765 
00766                 CommitSize = <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
00767                 UnCommittedBase = CommittedBase;
00768             }
00769         }
00770 
00771         <span class="comment">//</span>
00772         <span class="comment">//  This user gave us a base and we've just taken care of the committed</span>
00773         <span class="comment">//  bookkeeping.  So mark this segment as user supplied and set the</span>
00774         <span class="comment">//  heap</span>
00775         <span class="comment">//</span>
00776 
00777         SegmentFlags = <a class="code" href="../../d3/d9/heap_8h.html#a18">HEAP_SEGMENT_USER_ALLOCATED</a>;
00778         Heap = (<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a>)HeapBase;
00779 
00780     } <span class="keywordflow">else</span> {
00781 
00782         <span class="comment">//</span>
00783         <span class="comment">//  The user did not specify a heap base so we have to allocate the</span>
00784         <span class="comment">//  vm here.  First make sure the user did not give us a commit routine</span>
00785         <span class="comment">//</span>
00786 
00787         <span class="keywordflow">if</span> (Parameters-&gt;CommitRoutine != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00788 
00789             <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00790         }
00791 
00792         <span class="comment">//</span>
00793         <span class="comment">//  Reserve the amount of virtual address space requested.</span>
00794         <span class="comment">//</span>
00795 
00796         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwAllocateVirtualMemory( NtCurrentProcess(),
00797                                           (PVOID *)&amp;Heap,
00798                                           0,
00799                                           &amp;ReserveSize,
00800                                           MEM_RESERVE,
00801                                           PAGE_READWRITE );
00802 
00803         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
00804 
00805             <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00806         }
00807 
00808         <span class="comment">//</span>
00809         <span class="comment">//  Indicate that this segment is not user supplied</span>
00810         <span class="comment">//</span>
00811 
00812         SegmentFlags = 0;
00813 
00814         <span class="comment">//</span>
00815         <span class="comment">//  Set the default commit size to one page</span>
00816         <span class="comment">//</span>
00817 
00818         <span class="keywordflow">if</span> (!ARGUMENT_PRESENT( CommitSize )) {
00819 
00820             CommitSize = <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
00821         }
00822 
00823         <span class="comment">//</span>
00824         <span class="comment">//  Set the committed and uncommitted base to be the same the following</span>
00825         <span class="comment">//  code will actually commit the page for us</span>
00826         <span class="comment">//</span>
00827 
00828         CommittedBase = Heap;
00829         UnCommittedBase = Heap;
00830     }
00831 
00832     <span class="comment">//</span>
00833     <span class="comment">//  At this point we have a heap pointer, committed base, uncommitted base,</span>
00834     <span class="comment">//  segment flags, commit size, and reserve size.  If the committed and</span>
00835     <span class="comment">//  uncommited base are the same then we need to commit the amount</span>
00836     <span class="comment">//  specified by the commit size</span>
00837     <span class="comment">//</span>
00838 
00839     <span class="keywordflow">if</span> (CommittedBase == UnCommittedBase) {
00840 
00841         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwAllocateVirtualMemory( NtCurrentProcess(),
00842                                           (PVOID *)&amp;CommittedBase,
00843                                           0,
00844                                           &amp;CommitSize,
00845                                           MEM_COMMIT,
00846                                           PAGE_READWRITE );
00847 
00848         <span class="comment">//</span>
00849         <span class="comment">//  In the non successful case we need to back out any vm reservation</span>
00850         <span class="comment">//  we did earlier</span>
00851         <span class="comment">//</span>
00852 
00853         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
00854 
00855             <span class="keywordflow">if</span> (!ARGUMENT_PRESENT(HeapBase)) {
00856 
00857                 <span class="comment">//</span>
00858                 <span class="comment">//  Return the reserved virtual address space.</span>
00859                 <span class="comment">//</span>
00860 
00861                 ZwFreeVirtualMemory( NtCurrentProcess(),
00862                                      (PVOID *)&amp;Heap,
00863                                      &amp;ReserveSize,
00864                                      MEM_RELEASE );
00865 
00866             }
00867 
00868             <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00869         }
00870 
00871         <span class="comment">//</span>
00872         <span class="comment">//  The new uncommitted base is not adjusted above what we just</span>
00873         <span class="comment">//  committed</span>
00874         <span class="comment">//</span>
00875 
00876         UnCommittedBase = (PVOID)((PCHAR)UnCommittedBase + CommitSize);
00877     }
00878 
00879     <span class="comment">//</span>
00880     <span class="comment">//  At this point we have memory for the start of the heap committed and</span>
00881     <span class="comment">//  ready to be initialized.  So now we need initialize the heap</span>
00882     <span class="comment">//</span>
00883 
00884     <span class="comment">//</span>
00885     <span class="comment">//  Calculate the end of the heap header and make room for 8 uncommitted</span>
00886     <span class="comment">//  range structures.  Once we have the room for them then chain them</span>
00887     <span class="comment">//  together and null terminate the chain</span>
00888     <span class="comment">//</span>
00889 
00890     NextHeapHeaderAddress = Heap + 1;
00891 
00892     UnCommittedRange = (<a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html">PHEAP_UNCOMMMTTED_RANGE</a>)<a class="code" href="../../d3/d9/heap_8h.html#a1">ROUND_UP_TO_POWER2</a>( NextHeapHeaderAddress,
00893                                                                     <span class="keyword">sizeof</span>( QUAD ) );
00894 
00895     InitialCountOfUnusedUnCommittedRanges = 8;
00896 
00897     SizeOfHeapHeader += InitialCountOfUnusedUnCommittedRanges * <span class="keyword">sizeof</span>( *UnCommittedRange );
00898 
00899     <span class="comment">//</span>
00900     <span class="comment">//  **** what a hack Pp is really a pointer to the next field of the</span>
00901     <span class="comment">//  **** uncommmtted range structure.  So we set next by setting through Pp</span>
00902     <span class="comment">//</span>
00903 
00904     pp = &amp;Heap-&gt;UnusedUnCommittedRanges;
00905 
00906     <span class="keywordflow">while</span> (InitialCountOfUnusedUnCommittedRanges--) {
00907 
00908         *pp = UnCommittedRange;
00909         pp = &amp;UnCommittedRange-&gt;<a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html#o0">Next</a>;
00910         UnCommittedRange += 1;
00911     }
00912 
00913     NextHeapHeaderAddress = UnCommittedRange;
00914 
00915     *pp = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00916 
00917     <span class="comment">//</span>
00918     <span class="comment">//  Check if tagging is enabled in global flags.  This check is always true</span>
00919     <span class="comment">//  in a debug build.</span>
00920     <span class="comment">//</span>
00921     <span class="comment">//  If tagging is enabled then make room for 129 pseudo tag heap entry.</span>
00922     <span class="comment">//  Which is one more than the number of free lists.  Also point the heap</span>
00923     <span class="comment">//  header to this array of pseudo tags entries.</span>
00924     <span class="comment">//</span>
00925 
00926     <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/heappriv_8h.html#a22">IS_HEAP_TAGGING_ENABLED</a>()) {
00927 
00928         Heap-&gt;PseudoTagEntries = (<a class="code" href="../../d7/d6/struct__HEAP__PSEUDO__TAG__ENTRY.html">PHEAP_PSEUDO_TAG_ENTRY</a>)<a class="code" href="../../d3/d9/heap_8h.html#a1">ROUND_UP_TO_POWER2</a>( NextHeapHeaderAddress,
00929                                                                              <span class="keyword">sizeof</span>( QUAD ) );
00930 
00931         SizeOfHeapHeader += <a class="code" href="../../d3/d9/heap_8h.html#a32">HEAP_NUMBER_OF_PSEUDO_TAG</a> * <span class="keyword">sizeof</span>( <a class="code" href="../../d7/d6/struct__HEAP__PSEUDO__TAG__ENTRY.html">HEAP_PSEUDO_TAG_ENTRY</a> );
00932 
00933         <span class="comment">//</span>
00934         <span class="comment">//  **** this advancement of the next heap address doesn't seem right</span>
00935         <span class="comment">//  **** given that a pseudo heap entry is 12 ulongs in length and not</span>
00936         <span class="comment">//  **** a single byte</span>
00937 
00938         NextHeapHeaderAddress = Heap-&gt;PseudoTagEntries + <a class="code" href="../../d3/d9/heap_8h.html#a32">HEAP_NUMBER_OF_PSEUDO_TAG</a>;
00939     }
00940 
00941     <span class="comment">//</span>
00942     <span class="comment">//  Round the size of the heap header to the next 8 byte boundary</span>
00943     <span class="comment">//</span>
00944 
00945     SizeOfHeapHeader = (ULONG) <a class="code" href="../../d3/d9/heap_8h.html#a1">ROUND_UP_TO_POWER2</a>( SizeOfHeapHeader,
00946                                                    HEAP_GRANULARITY );
00947 
00948     <span class="comment">//</span>
00949     <span class="comment">//  If the sizeof the heap header is larger than the native</span>
00950     <span class="comment">//  page size, you have a problem. Further, if the CommitSize passed</span>
00951     <span class="comment">//  in was smaller than the SizeOfHeapHeader, you may not even make it</span>
00952     <span class="comment">//  this far before death...</span>
00953     <span class="comment">//</span>
00954     <span class="comment">//  HeapDbgPrint() doesn't work for IA64 yet.</span>
00955     <span class="comment">//</span>
00956     <span class="comment">//  HeapDbgPrint(("Size of the heap header is %u bytes, commit was %u bytes\n", SizeOfHeapHeader, (ULONG) CommitSize));</span>
00957     <span class="comment">//</span>
00958 
00959     <span class="comment">//</span>
00960     <span class="comment">//  Fill in the heap header fields</span>
00961     <span class="comment">//</span>
00962 
00963     Heap-&gt;Entry.Size = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(SizeOfHeapHeader &gt;&gt; <a class="code" href="../../d3/d9/heap_8h.html#a4">HEAP_GRANULARITY_SHIFT</a>);
00964     Heap-&gt;Entry.Flags = <a class="code" href="../../d3/d9/heap_8h.html#a8">HEAP_ENTRY_BUSY</a>;
00965 
00966     Heap-&gt;Signature = <a class="code" href="../../d3/d9/heap_8h.html#a19">HEAP_SIGNATURE</a>;
00967     Heap-&gt;Flags = Flags;
00968     Heap-&gt;ForceFlags = (Flags &amp; (HEAP_NO_SERIALIZE |
00969                                  HEAP_GENERATE_EXCEPTIONS |
00970                                  HEAP_ZERO_MEMORY |
00971                                  HEAP_REALLOC_IN_PLACE_ONLY |
00972                                  <a class="code" href="../../d3/d9/heap_8h.html#a21">HEAP_VALIDATE_PARAMETERS_ENABLED</a> |
00973                                  <a class="code" href="../../d3/d9/heap_8h.html#a22">HEAP_VALIDATE_ALL_ENABLED</a> |
00974                                  HEAP_TAIL_CHECKING_ENABLED |
00975                                  HEAP_CREATE_ALIGN_16 |
00976                                  HEAP_FREE_CHECKING_ENABLED));
00977 
00978     Heap-&gt;FreeListsInUseTerminate = 0xFFFF;
00979     Heap-&gt;HeaderValidateLength = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)((PCHAR)NextHeapHeaderAddress - (PCHAR)Heap);
00980     Heap-&gt;HeaderValidateCopy = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00981 
00982     <span class="comment">//</span>
00983     <span class="comment">//  Initialize the free list to be all empty</span>
00984     <span class="comment">//</span>
00985 
00986     FreeListHead = &amp;Heap-&gt;FreeLists[ 0 ];
00987     <a class="code" href="../../d7/d0/exts_8h.html#a0">n</a> = <a class="code" href="../../d3/d9/heap_8h.html#a6">HEAP_MAXIMUM_FREELISTS</a>;
00988 
00989     <span class="keywordflow">while</span> (<a class="code" href="../../d7/d0/exts_8h.html#a0">n</a>--) {
00990 
00991         InitializeListHead( FreeListHead );
00992         FreeListHead++;
00993     }
00994 
00995     <span class="comment">//</span>
00996     <span class="comment">//  Make it so that there a no big block allocations</span>
00997     <span class="comment">//</span>
00998 
00999     InitializeListHead( &amp;Heap-&gt;VirtualAllocdBlocks );
01000 
01001     <span class="comment">//</span>
01002     <span class="comment">//  Initialize the cricital section that controls access to</span>
01003     <span class="comment">//  the free list.  If the lock variable is -1 then the caller</span>
01004     <span class="comment">//  did not supply a lock so we need to make room for one</span>
01005     <span class="comment">//  and initialize it.</span>
01006     <span class="comment">//</span>
01007 
01008     <span class="keywordflow">if</span> (<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a> == (<a class="code" href="../../d4/d6/struct__HEAP__LOCK.html">PHEAP_LOCK</a>)-1) {
01009 
01010         <a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a> = (<a class="code" href="../../d4/d6/struct__HEAP__LOCK.html">PHEAP_LOCK</a>)NextHeapHeaderAddress;
01011 
01012         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d9/heappriv_8h.html#a2">RtlInitializeLockRoutine</a>( Lock );
01013 
01014         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
01015 
01016             <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01017         }
01018 
01019         NextHeapHeaderAddress = (<a class="code" href="../../d4/d6/struct__HEAP__LOCK.html">PHEAP_LOCK</a>)<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a> + 1;
01020     }
01021 
01022     Heap-&gt;LockVariable = <a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>;
01023 
01024 
01025     <span class="comment">//</span>
01026     <span class="comment">//  Initialize the first segment for the heap</span>
01027     <span class="comment">//</span>
01028 
01029     <span class="keywordflow">if</span> (!<a class="code" href="../../d9/d9/heappriv_8h.html#a33">RtlpInitializeHeapSegment</a>( Heap,
01030                                     (<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html">PHEAP_SEGMENT</a>)((PCHAR)Heap + SizeOfHeapHeader),
01031                                     0,
01032                                     SegmentFlags,
01033                                     CommittedBase,
01034                                     UnCommittedBase,
01035                                     (PCHAR)CommittedBase + ReserveSize )) {
01036 
01037         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01038     }
01039 
01040     <span class="comment">//</span>
01041     <span class="comment">//  Fill in additional heap entry fields</span>
01042     <span class="comment">//</span>
01043 
01044     Heap-&gt;ProcessHeapsListIndex = 0;
01045     Heap-&gt;SegmentReserve = Parameters-&gt;SegmentReserve;
01046     Heap-&gt;SegmentCommit = Parameters-&gt;SegmentCommit;
01047     Heap-&gt;DeCommitFreeBlockThreshold = Parameters-&gt;DeCommitFreeBlockThreshold &gt;&gt; <a class="code" href="../../d3/d9/heap_8h.html#a4">HEAP_GRANULARITY_SHIFT</a>;
01048     Heap-&gt;DeCommitTotalFreeThreshold = Parameters-&gt;DeCommitTotalFreeThreshold &gt;&gt; <a class="code" href="../../d3/d9/heap_8h.html#a4">HEAP_GRANULARITY_SHIFT</a>;
01049     Heap-&gt;MaximumAllocationSize = Parameters-&gt;MaximumAllocationSize;
01050 
01051     Heap-&gt;VirtualMemoryThreshold = (ULONG) (<a class="code" href="../../d3/d9/heap_8h.html#a1">ROUND_UP_TO_POWER2</a>( Parameters-&gt;VirtualMemoryThreshold,
01052                                                        HEAP_GRANULARITY ) &gt;&gt; <a class="code" href="../../d3/d9/heap_8h.html#a4">HEAP_GRANULARITY_SHIFT</a>);
01053 
01054     Heap-&gt;CommitRoutine = Parameters-&gt;CommitRoutine;
01055 
01056     <span class="comment">//</span>
01057     <span class="comment">//  We either align the heap at 16 or 8 byte boundaries.  The AlignRound</span>
01058     <span class="comment">//  and AlignMask are used to bring allocation sizes up to the next</span>
01059     <span class="comment">//  boundary.  The align round includes the heap header and the optional</span>
01060     <span class="comment">//  check tail size</span>
01061     <span class="comment">//</span>
01062 
01063     <span class="keywordflow">if</span> (Flags &amp; HEAP_CREATE_ALIGN_16) {
01064 
01065         Heap-&gt;AlignRound = 15 + <span class="keyword">sizeof</span>( <a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">HEAP_ENTRY</a> );
01066         Heap-&gt;AlignMask = (ULONG)~15;
01067 
01068     } <span class="keywordflow">else</span> {
01069 
01070         Heap-&gt;AlignRound = <a class="code" href="../../d3/d9/heap_8h.html#a3">HEAP_GRANULARITY</a> - 1 + <span class="keyword">sizeof</span>( <a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">HEAP_ENTRY</a> );
01071         Heap-&gt;AlignMask = (ULONG)~(<a class="code" href="../../d3/d9/heap_8h.html#a3">HEAP_GRANULARITY</a> - 1);
01072     }
01073 
01074     <span class="keywordflow">if</span> (Heap-&gt;Flags &amp; HEAP_TAIL_CHECKING_ENABLED) {
01075 
01076         Heap-&gt;AlignRound += <a class="code" href="../../d3/d9/heap_8h.html#a25">CHECK_HEAP_TAIL_SIZE</a>;
01077     }
01078 
01079 <span class="preprocessor">#ifndef NTOS_KERNEL_RUNTIME</span>
01080 <span class="preprocessor"></span>
01081     <span class="comment">//</span>
01082     <span class="comment">//  In the non kernel case we need to add this heap to the processes heap</span>
01083     <span class="comment">//  list</span>
01084     <span class="comment">//</span>
01085 
01086     <a class="code" href="../../d9/d9/heappriv_8h.html#a43">RtlpAddHeapToProcessList</a>( Heap );
01087 
01088     <span class="comment">//</span>
01089     <span class="comment">//  Initialize the heap lookaide lists.  This is only for the user mode</span>
01090     <span class="comment">//  heap and the heap contains a pointer to the lookaside list array.</span>
01091     <span class="comment">//  The array is sized the same as the dedicated free list.  First we</span>
01092     <span class="comment">//  allocate space for the lookaside list and then we initialize each</span>
01093     <span class="comment">//  lookaside list.</span>
01094     <span class="comment">//</span>
01095     <span class="comment">//  But the caller asked for no serialize or asked for non growable</span>
01096     <span class="comment">//  heap then we won't enable the lookaside lists.</span>
01097     <span class="comment">//</span>
01098 
01099     Heap-&gt;Lookaside = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01100     Heap-&gt;LookasideLockCount = 0;
01101 
01102     <span class="keywordflow">if</span> ((!(Flags &amp; HEAP_NO_SERIALIZE)) &amp;&amp;
01103         ( (Flags &amp; HEAP_GROWABLE)) &amp;&amp;
01104         (!(<a class="code" href="../../d8/d2/ldrinit_8c.html#a6">RtlpDisableHeapLookaside</a>))) {
01105 
01106         ULONG i;
01107 
01108         Heap-&gt;Lookaside = <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a0">RtlAllocateHeap</a>( Heap,
01109                                            Flags,
01110                                            <span class="keyword">sizeof</span>(<a class="code" href="../../d6/d6/struct__HEAP__LOOKASIDE.html">HEAP_LOOKASIDE</a>) * HEAP_MAXIMUM_FREELISTS );
01111 
01112         <span class="keywordflow">if</span> (Heap-&gt;Lookaside != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01113 
01114             <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="../../d3/d9/heap_8h.html#a6">HEAP_MAXIMUM_FREELISTS</a>; i += 1) {
01115 
01116                 <a class="code" href="../../d0/d6/rtl_2lookasid_8c.html#a2">RtlpInitializeHeapLookaside</a>( &amp;(((<a class="code" href="../../d6/d6/struct__HEAP__LOOKASIDE.html">PHEAP_LOOKASIDE</a>)(Heap-&gt;Lookaside))[i]),
01117                                              32 );
01118             }
01119         }
01120     }
01121 
01122 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
01123 <span class="preprocessor"></span>
01124     <span class="comment">//</span>
01125     <span class="comment">//  And return the fully initialized heap to our caller</span>
01126     <span class="comment">//</span>
01127 
01128     <span class="keywordflow">return</span> (PVOID)Heap;
01129 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="rtl/heap.c::RtlDebugAllocateHeap" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> PVOID RtlDebugAllocateHeap           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>HeapHandle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Flags</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN SIZE_T&nbsp;</td>
          <td class="mdname" nowrap> <em>Size</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l00444">444</a> of file <a class="el" href="../../d5/d8/heapdbg_8c-source.html">heapdbg.c</a>.
<p>
References <a class="el" href="../../d4/d8/heap_8h-source.html#l00351">_HEAP::AlignMask</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00350">_HEAP::AlignRound</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00449">_HEAP_STOP_ON_VALUES::AllocAddress</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00113">_HEAP_ENTRY_EXTRA::AllocatorBackTraceIndex</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00450">_HEAP_STOP_ON_VALUES::AllocTag</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00056">EXCEPTION_CONTINUE_SEARCH</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00055">EXCEPTION_EXECUTE_HANDLER</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00076">_HEAP_ENTRY::Flags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00322">_HEAP::Flags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00323">_HEAP::ForceFlags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00392">HEAP_CAPTURE_STACK_BACKTRACES</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00237">HEAP_ENTRY_EXTRA_PRESENT</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00391">HEAP_SKIP_VALIDATION_CHECKS</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00390">HEAP_VALIDATE_ALL_ENABLED</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00134">HeapDebugBreak</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00121">HeapDebugPrint</a>, <a class="el" href="../../d5/d5/memory_8c-source.html#l00115">HeapHandle</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00443">_HEAP_STOP_ON_TAG::HeapIndex</a>, <a class="el" href="../../d8/d8/heappage_8h-source.html#l00058">IF_DEBUG_PAGE_HEAP_THEN_RETURN</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00563">IS_HEAP_TAGGING_ENABLED</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00369">_HEAP::LockVariable</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00332">_HEAP::MaximumAllocationSize</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00333">_HEAP::ProcessHeapsListIndex</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00078">RtlAcquireLockRoutine</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l02075">RtlAllocateHeapSlowly()</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l04250">RtlpCheckHeapSignature()</a>, <a class="el" href="../../d7/d8/heappage_8c-source.html#l02336">RtlpDebugPageHeapAllocate()</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l06008">RtlpGetExtraStuffPointer()</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l05425">RtlpGetTagName()</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00463">RtlpHeapStopOn</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l02025">RtlpValidateHeap()</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l00112">RtlpValidateHeapHeaders()</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00079">RtlReleaseLockRoutine</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00104">SET_LAST_STATUS</a>, <a class="el" href="../../d9/d6/lh__open_2pi__mem_8h-source.html#l00017">Size</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00091">_HEAP_ENTRY::SmallTagIndex</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00121">_HEAP_ENTRY_EXTRA::TagIndex</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00442">_HEAP_STOP_ON_TAG::TagIndex</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, and <a class="el" href="../../d5/d4/aug98_2dll32_2icc__i386_8h-source.html#l00064">USHORT</a>.
<p>
Referenced by <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l02075">RtlAllocateHeapSlowly()</a>.
<p>
<pre class="fragment"><div>00452                    :
00453 
00454 Arguments:
00455 
00456 Return Value:
00457 
00458 --*/
00459 
00460 {
00461     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap = (<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a>)<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
00462     BOOLEAN LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00463     PVOID ReturnValue = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00464     SIZE_T AllocationSize;
00465     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> TagIndex;
00466     <a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a> BusyBlock;
00467     <a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html">PHEAP_ENTRY_EXTRA</a> ExtraStuff;
00468 
00469     <a class="code" href="../../d7/d9/heappage_8h.html#a6">IF_DEBUG_PAGE_HEAP_THEN_RETURN</a>( HeapHandle,
00470                                     <a class="code" href="../../d7/d9/heappage_8h.html#a10">RtlpDebugPageHeapAllocate</a>( HeapHandle, Flags, Size ));
00471 
00472     <span class="keywordflow">try</span> {
00473 
00474         <span class="keywordflow">try</span> {
00475 
00476             <span class="comment">//</span>
00477             <span class="comment">//  Validate that HeapAddress points to a HEAP structure.</span>
00478             <span class="comment">//</span>
00479 
00480             <span class="keywordflow">if</span> (!<a class="code" href="../../d9/d9/heappriv_8h.html#a46">RtlpCheckHeapSignature</a>( Heap, <span class="stringliteral">"RtlAllocateHeap"</span> )) {
00481 
00482                 ReturnValue = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00483                 leave;
00484             }
00485 
00486             Flags |= Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o3">ForceFlags</a> | HEAP_SETTABLE_USER_VALUE | <a class="code" href="../../d3/d9/heap_8h.html#a23">HEAP_SKIP_VALIDATION_CHECKS</a>;
00487 
00488             <span class="comment">//</span>
00489             <span class="comment">//  Verify that the size did not wrap or exceed the limit for this heap.</span>
00490             <span class="comment">//</span>
00491 
00492             AllocationSize = (((<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> ? <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> : 1) + Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o19">AlignRound</a>) &amp; Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o20">AlignMask</a>) +
00493                              <span class="keyword">sizeof</span>( <a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html">HEAP_ENTRY_EXTRA</a> );
00494 
00495             <span class="keywordflow">if</span> ((AllocationSize &lt; Size) || (AllocationSize &gt; Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o10">MaximumAllocationSize</a>)) {
00496 
00497                 <a class="code" href="../../d9/d9/heappriv_8h.html#a10">HeapDebugPrint</a>(( <span class="stringliteral">"Invalid allocation size - %lx (exceeded %x)\n"</span>,
00498                                  Size,
00499                                  Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o10">MaximumAllocationSize</a> ));
00500 
00501                 ReturnValue = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00502                 leave;
00503             }
00504 
00505             <span class="comment">//</span>
00506             <span class="comment">//  Lock the heap</span>
00507             <span class="comment">//</span>
00508 
00509             <span class="keywordflow">if</span> (!(Flags &amp; HEAP_NO_SERIALIZE)) {
00510 
00511                 <a class="code" href="../../d9/d9/heappriv_8h.html#a3">RtlAcquireLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
00512 
00513                 LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00514 
00515                 Flags |= HEAP_NO_SERIALIZE;
00516             }
00517 
00518             <a class="code" href="../../d9/d9/heappriv_8h.html#a48">RtlpValidateHeap</a>( Heap, FALSE );
00519 
00520             ReturnValue = <a class="code" href="../../d9/d9/heappriv_8h.html#a38">RtlAllocateHeapSlowly</a>( HeapHandle, Flags, Size );
00521 
00522             <a class="code" href="../../d9/d9/heappriv_8h.html#a50">RtlpValidateHeapHeaders</a>( Heap, TRUE );
00523 
00524             <span class="keywordflow">if</span> (ReturnValue != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00525 
00526                 BusyBlock = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)ReturnValue - 1;
00527 
00528                 <span class="keywordflow">if</span> (BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a9">HEAP_ENTRY_EXTRA_PRESENT</a>) {
00529 
00530                     ExtraStuff = <a class="code" href="../../d9/d9/heappriv_8h.html#a41">RtlpGetExtraStuffPointer</a>( BusyBlock );
00531 
00532 <span class="preprocessor">    #if i386</span>
00533 <span class="preprocessor"></span>
00534                     <span class="keywordflow">if</span> (Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o2">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a24">HEAP_CAPTURE_STACK_BACKTRACES</a>) {
00535 
00536                         ExtraStuff-&gt;<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html#o0">AllocatorBackTraceIndex</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)RtlLogStackBackTrace();
00537 
00538                     } <span class="keywordflow">else</span> {
00539 
00540                         ExtraStuff-&gt;<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html#o0">AllocatorBackTraceIndex</a> = 0;
00541                     }
00542 
00543 <span class="preprocessor">    #endif // i386</span>
00544 <span class="preprocessor"></span>
00545                     TagIndex = ExtraStuff-&gt;<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html#o1">TagIndex</a>;
00546 
00547                 } <span class="keywordflow">else</span> {
00548 
00549                     TagIndex = BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o5">SmallTagIndex</a>;
00550                 }
00551 
00552                 <span class="keywordflow">if</span> (Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o2">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a22">HEAP_VALIDATE_ALL_ENABLED</a>) {
00553 
00554                     <a class="code" href="../../d9/d9/heappriv_8h.html#a48">RtlpValidateHeap</a>( Heap, FALSE );
00555                 }
00556             }
00557 
00558             <span class="keywordflow">if</span> (ReturnValue != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00559 
00560                 <span class="keywordflow">if</span> ((ULONG_PTR)ReturnValue == <a class="code" href="../../d3/d9/heap_8h.html#a65">RtlpHeapStopOn</a>.<a class="code" href="../../d2/d7/struct__HEAP__STOP__ON__VALUES.html#o0">AllocAddress</a>) {
00561 
00562                     <a class="code" href="../../d9/d9/heappriv_8h.html#a10">HeapDebugPrint</a>(( <span class="stringliteral">"Just allocated block at %lx for 0x%x bytes\n"</span>,
00563                                      <a class="code" href="../../d3/d9/heap_8h.html#a65">RtlpHeapStopOn</a>.<a class="code" href="../../d2/d7/struct__HEAP__STOP__ON__VALUES.html#o0">AllocAddress</a>,
00564                                      Size ));
00565 
00566                     <a class="code" href="../../d9/d9/heappriv_8h.html#a11">HeapDebugBreak</a>( NULL );
00567 
00568                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((<a class="code" href="../../d9/d9/heappriv_8h.html#a22">IS_HEAP_TAGGING_ENABLED</a>()) &amp;&amp;
00569                            (TagIndex != 0) &amp;&amp;
00570                            (TagIndex == <a class="code" href="../../d3/d9/heap_8h.html#a65">RtlpHeapStopOn</a>.<a class="code" href="../../d2/d7/struct__HEAP__STOP__ON__VALUES.html#o1">AllocTag</a>.<a class="code" href="../../d9/d6/struct__HEAP__STOP__ON__TAG.html#o1">TagIndex</a>) &amp;&amp;
00571                            (Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o11">ProcessHeapsListIndex</a> == <a class="code" href="../../d3/d9/heap_8h.html#a65">RtlpHeapStopOn</a>.<a class="code" href="../../d2/d7/struct__HEAP__STOP__ON__VALUES.html#o1">AllocTag</a>.<a class="code" href="../../d9/d6/struct__HEAP__STOP__ON__TAG.html#o2">HeapIndex</a>)) {
00572 
00573                     <a class="code" href="../../d9/d9/heappriv_8h.html#a10">HeapDebugPrint</a>(( <span class="stringliteral">"Just allocated block at %lx for 0x%x bytes with tag %ws\n"</span>,
00574                                      ReturnValue,
00575                                      Size,
00576                                      <a class="code" href="../../d9/d9/heappriv_8h.html#a51">RtlpGetTagName</a>( Heap, TagIndex )));
00577 
00578                     <a class="code" href="../../d9/d9/heappriv_8h.html#a11">HeapDebugBreak</a>( NULL );
00579                 }
00580             }
00581 
00582         } except( GetExceptionCode() == STATUS_NO_MEMORY ? EXCEPTION_CONTINUE_SEARCH :
00583                                                            EXCEPTION_EXECUTE_HANDLER ) {
00584 
00585             <a class="code" href="../../d9/d9/heappriv_8h.html#a9">SET_LAST_STATUS</a>( GetExceptionCode() );
00586 
00587             ReturnValue = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00588         }
00589 
00590     } finally {
00591 
00592         <span class="keywordflow">if</span> (LockAcquired) {
00593 
00594             <a class="code" href="../../d9/d9/heappriv_8h.html#a4">RtlReleaseLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
00595         }
00596     }
00597 
00598     <span class="keywordflow">return</span> ReturnValue;
00599 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="rtl/heap.c::RtlDebugCreateHeap" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> PVOID RtlDebugCreateHeap           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Flags</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID HeapBase&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN SIZE_T ReserveSize&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN SIZE_T CommitSize&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID Lock&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PRTL_HEAP_PARAMETERS Parameters&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l00204">204</a> of file <a class="el" href="../../d5/d8/heapdbg_8c-source.html">heapdbg.c</a>.
<p>
References <a class="el" href="../../d4/d8/heap_8h-source.html#l00363">_HEAP::AllocatorBackTraceIndex</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00322">_HEAP::Flags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00392">HEAP_CAPTURE_STACK_BACKTRACES</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00391">HEAP_SKIP_VALIDATION_CHECKS</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00134">HeapDebugBreak</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00121">HeapDebugPrint</a>, <a class="el" href="../../d7/d9/usercli_8h-source.html#l00367">Lock</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d6/d2/queryvm_8c-source.html#l00061">NtQueryVirtualMemory()</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l00191">RtlCreateHeap()</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l00112">RtlpValidateHeapHeaders()</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, and <a class="el" href="../../d5/d4/aug98_2dll32_2icc__i386_8h-source.html#l00064">USHORT</a>.
<p>
Referenced by <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l00191">RtlCreateHeap()</a>.
<p>
<pre class="fragment"><div>00215                    :
00216 
00217 Arguments:
00218 
00219 Return Value:
00220 
00221 --*/
00222 
00223 {
00224     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap;
00225     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00226     MEMORY_BASIC_INFORMATION MemoryInformation;
00227 
00228     <span class="keywordflow">if</span> (ReserveSize &lt;= <span class="keyword">sizeof</span>( <a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">HEAP_ENTRY</a> )) {
00229 
00230         <a class="code" href="../../d9/d9/heappriv_8h.html#a10">HeapDebugPrint</a>(( <span class="stringliteral">"Invalid ReserveSize parameter - %lx\n"</span>, ReserveSize ));
00231         <a class="code" href="../../d9/d9/heappriv_8h.html#a11">HeapDebugBreak</a>( NULL );
00232 
00233         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00234     }
00235 
00236     <span class="keywordflow">if</span> (ReserveSize &lt; CommitSize) {
00237 
00238         <a class="code" href="../../d9/d9/heappriv_8h.html#a10">HeapDebugPrint</a>(( <span class="stringliteral">"Invalid CommitSize parameter - %lx\n"</span>, CommitSize ));
00239         <a class="code" href="../../d9/d9/heappriv_8h.html#a11">HeapDebugBreak</a>( NULL );
00240 
00241         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00242     }
00243 
00244     <span class="keywordflow">if</span> ((Flags &amp; HEAP_NO_SERIALIZE) &amp;&amp; ARGUMENT_PRESENT( Lock )) {
00245 
00246         <a class="code" href="../../d9/d9/heappriv_8h.html#a10">HeapDebugPrint</a>(( <span class="stringliteral">"May not specify Lock parameter with HEAP_NO_SERIALIZE\n"</span> ));
00247         <a class="code" href="../../d9/d9/heappriv_8h.html#a11">HeapDebugBreak</a>( NULL );
00248 
00249         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00250     }
00251 
00252     <span class="keywordflow">if</span> (ARGUMENT_PRESENT( HeapBase )) {
00253 
00254         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d5/d3/queryvm_8c.html#a4">NtQueryVirtualMemory</a>( NtCurrentProcess(),
00255                                        HeapBase,
00256                                        MemoryBasicInformation,
00257                                        &amp;MemoryInformation,
00258                                        <span class="keyword">sizeof</span>( MemoryInformation ),
00259                                        NULL );
00260 
00261         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
00262 
00263             <a class="code" href="../../d9/d9/heappriv_8h.html#a10">HeapDebugPrint</a>(( <span class="stringliteral">"Specified HeapBase (%lx) invalid,  Status = %lx\n"</span>,
00264                              HeapBase,
00265                              Status ));
00266 
00267             <a class="code" href="../../d9/d9/heappriv_8h.html#a11">HeapDebugBreak</a>( NULL );
00268 
00269             <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00270         }
00271 
00272         <span class="keywordflow">if</span> (MemoryInformation.BaseAddress != HeapBase) {
00273 
00274             <a class="code" href="../../d9/d9/heappriv_8h.html#a10">HeapDebugPrint</a>(( <span class="stringliteral">"Specified HeapBase (%lx) != to BaseAddress (%lx)\n"</span>,
00275                              HeapBase,
00276                              MemoryInformation.BaseAddress ));
00277 
00278             <a class="code" href="../../d9/d9/heappriv_8h.html#a11">HeapDebugBreak</a>( NULL );
00279 
00280             <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00281         }
00282 
00283         <span class="keywordflow">if</span> (MemoryInformation.State == MEM_FREE) {
00284 
00285             <a class="code" href="../../d9/d9/heappriv_8h.html#a10">HeapDebugPrint</a>(( <span class="stringliteral">"Specified HeapBase (%lx) is free or not writable\n"</span>,
00286                              MemoryInformation.BaseAddress ));
00287 
00288             <a class="code" href="../../d9/d9/heappriv_8h.html#a11">HeapDebugBreak</a>( NULL );
00289 
00290             <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00291         }
00292     }
00293 
00294     Heap = <a class="code" href="../../d1/d9/rtl_2heap_8c.html#a15">RtlCreateHeap</a>( Flags |
00295                             HEAP_SKIP_VALIDATION_CHECKS |
00296                             HEAP_TAIL_CHECKING_ENABLED  |
00297                             HEAP_FREE_CHECKING_ENABLED,
00298                           HeapBase,
00299                           ReserveSize,
00300                           CommitSize,
00301                           Lock,
00302                           Parameters );
00303 
00304     <span class="keywordflow">if</span> (Heap != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00305 
00306 <span class="preprocessor">#if i386</span>
00307 <span class="preprocessor"></span>
00308         <span class="keywordflow">if</span> (Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o2">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a24">HEAP_CAPTURE_STACK_BACKTRACES</a>) {
00309 
00310             Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o27">AllocatorBackTraceIndex</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)RtlLogStackBackTrace();
00311         }
00312 
00313 <span class="preprocessor">#endif // i386</span>
00314 <span class="preprocessor"></span>
00315         <a class="code" href="../../d9/d9/heappriv_8h.html#a50">RtlpValidateHeapHeaders</a>( Heap, TRUE );
00316     }
00317 
00318     <span class="keywordflow">return</span> Heap;
00319 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="rtl/heap.c::RtlDebugDestroyHeap" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> BOOLEAN RtlDebugDestroyHeap           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>HeapHandle</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l00388">388</a> of file <a class="el" href="../../d5/d8/heapdbg_8c-source.html">heapdbg.c</a>.
<p>
References <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00335">_HEAP::HeaderValidateCopy</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00121">HeapDebugPrint</a>, <a class="el" href="../../d5/d5/memory_8c-source.html#l00115">HeapHandle</a>, <a class="el" href="../../d8/d9/exts_8h-source.html#l00092">n</a>, <a class="el" href="../../d4/d6/freevm_8c-source.html#l00066">NtFreeVirtualMemory()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l04250">RtlpCheckHeapSignature()</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l02025">RtlpValidateHeap()</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00321">_HEAP::Signature</a>, and <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>.
<p>
Referenced by <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l01133">RtlDestroyHeap()</a>.
<p>
<pre class="fragment"><div>00394                    :
00395 
00396 Arguments:
00397 
00398 Return Value:
00399 
00400 --*/
00401 
00402 {
00403     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap = (<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a>)<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
00404     LIST_ENTRY ListEntry;
00405     SIZE_T <a class="code" href="../../d7/d0/exts_8h.html#a0">n</a>;
00406 
00407     <span class="keywordflow">if</span> (<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a> == NtCurrentPeb()-&gt;ProcessHeap) {
00408 
00409         <a class="code" href="../../d9/d9/heappriv_8h.html#a10">HeapDebugPrint</a>(( <span class="stringliteral">"May not destroy the process heap at %x\n"</span>, HeapHandle ));
00410 
00411         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00412     }
00413 
00414     <span class="keywordflow">if</span> (!<a class="code" href="../../d9/d9/heappriv_8h.html#a46">RtlpCheckHeapSignature</a>( Heap, <span class="stringliteral">"RtlDestroyHeap"</span> )) {
00415 
00416         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00417     }
00418 
00419     <span class="keywordflow">if</span> (!<a class="code" href="../../d9/d9/heappriv_8h.html#a48">RtlpValidateHeap</a>( Heap, FALSE )) {
00420 
00421         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00422     }
00423 
00424     <span class="comment">//</span>
00425     <span class="comment">//  Now mark the heap as invalid by zeroing the signature field.</span>
00426     <span class="comment">//</span>
00427 
00428     Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o1">Signature</a> = 0;
00429 
00430     <span class="keywordflow">if</span> (Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o13">HeaderValidateCopy</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00431 
00432         <a class="code" href="../../d7/d0/exts_8h.html#a0">n</a> = 0;
00433         <a class="code" href="../../d3/d7/freevm_8c.html#a6">NtFreeVirtualMemory</a>( NtCurrentProcess(),
00434                              &amp;Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o13">HeaderValidateCopy</a>,
00435                              &amp;n,
00436                              MEM_RELEASE );
00437     }
00438 
00439     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00440 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a7" doxytag="rtl/heap.c::RtlDebugFreeHeap" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> BOOLEAN RtlDebugFreeHeap           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>HeapHandle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Flags</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>BaseAddress</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l00797">797</a> of file <a class="el" href="../../d5/d8/heapdbg_8c-source.html">heapdbg.c</a>.
<p>
References <a class="el" href="../../d7/d6/halmips_8h-source.html#l00055">EXCEPTION_EXECUTE_HANDLER</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00076">_HEAP_ENTRY::Flags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00323">_HEAP::ForceFlags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00453">_HEAP_STOP_ON_VALUES::FreeAddress</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00454">_HEAP_STOP_ON_VALUES::FreeTag</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00237">HEAP_ENTRY_EXTRA_PRESENT</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00228">HEAP_GRANULARITY_SHIFT</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00391">HEAP_SKIP_VALIDATION_CHECKS</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00440">_HEAP_STOP_ON_TAG::HeapAndTagIndex</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00134">HeapDebugBreak</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00121">HeapDebugPrint</a>, <a class="el" href="../../d5/d5/memory_8c-source.html#l00115">HeapHandle</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00443">_HEAP_STOP_ON_TAG::HeapIndex</a>, <a class="el" href="../../d8/d8/heappage_8h-source.html#l00058">IF_DEBUG_PAGE_HEAP_THEN_RETURN</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00563">IS_HEAP_TAGGING_ENABLED</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00369">_HEAP::LockVariable</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00333">_HEAP::ProcessHeapsListIndex</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00078">RtlAcquireLockRoutine</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l03273">RtlFreeHeapSlowly()</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l04250">RtlpCheckHeapSignature()</a>, <a class="el" href="../../d7/d8/heappage_8c-source.html#l02693">RtlpDebugPageHeapFree()</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l06008">RtlpGetExtraStuffPointer()</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l05425">RtlpGetTagName()</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00463">RtlpHeapStopOn</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l02025">RtlpValidateHeap()</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l01696">RtlpValidateHeapEntry()</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l00112">RtlpValidateHeapHeaders()</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00079">RtlReleaseLockRoutine</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00104">SET_LAST_STATUS</a>, <a class="el" href="../../d9/d6/lh__open_2pi__mem_8h-source.html#l00017">Size</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00045">_HEAP_ENTRY::Size</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00091">_HEAP_ENTRY::SmallTagIndex</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00121">_HEAP_ENTRY_EXTRA::TagIndex</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00442">_HEAP_STOP_ON_TAG::TagIndex</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, and <a class="el" href="../../d5/d4/aug98_2dll32_2icc__i386_8h-source.html#l00064">USHORT</a>.
<p>
Referenced by <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l03273">RtlFreeHeapSlowly()</a>.
<p>
<pre class="fragment"><div>00805                    :
00806 
00807 Arguments:
00808 
00809 Return Value:
00810 
00811 --*/
00812 
00813 {
00814     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap = (<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a>)<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
00815     <a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a> BusyBlock;
00816     <a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html">PHEAP_ENTRY_EXTRA</a> ExtraStuff;
00817     SIZE_T <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
00818     BOOLEAN Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00819     BOOLEAN LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00820     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> TagIndex;
00821 
00822     <a class="code" href="../../d7/d9/heappage_8h.html#a6">IF_DEBUG_PAGE_HEAP_THEN_RETURN</a>( HeapHandle,
00823                                     <a class="code" href="../../d7/d9/heappage_8h.html#a11">RtlpDebugPageHeapFree</a>( HeapHandle, Flags, BaseAddress ));
00824 
00825     <span class="keywordflow">try</span> {
00826 
00827         <span class="keywordflow">try</span> {
00828 
00829             <span class="comment">//</span>
00830             <span class="comment">//  Validate that HeapAddress points to a HEAP structure.</span>
00831             <span class="comment">//</span>
00832 
00833             <span class="keywordflow">if</span> (!<a class="code" href="../../d9/d9/heappriv_8h.html#a46">RtlpCheckHeapSignature</a>( Heap, <span class="stringliteral">"RtlFreeHeap"</span> )) {
00834 
00835                 Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00836                 leave;
00837             }
00838 
00839             Flags |= Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o3">ForceFlags</a> | <a class="code" href="../../d3/d9/heap_8h.html#a23">HEAP_SKIP_VALIDATION_CHECKS</a>;
00840 
00841             <span class="comment">//</span>
00842             <span class="comment">//  Lock the heap</span>
00843             <span class="comment">//</span>
00844 
00845             <span class="keywordflow">if</span> (!(Flags &amp; HEAP_NO_SERIALIZE)) {
00846 
00847                 <a class="code" href="../../d9/d9/heappriv_8h.html#a3">RtlAcquireLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
00848 
00849                 LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00850 
00851                 Flags |= HEAP_NO_SERIALIZE;
00852             }
00853 
00854             <a class="code" href="../../d9/d9/heappriv_8h.html#a48">RtlpValidateHeap</a>( Heap, FALSE );
00855 
00856             BusyBlock = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)BaseAddress - 1;
00857             <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> = BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a> &lt;&lt; <a class="code" href="../../d3/d9/heap_8h.html#a4">HEAP_GRANULARITY_SHIFT</a>;
00858 
00859             <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/heappriv_8h.html#a47">RtlpValidateHeapEntry</a>( Heap, BusyBlock, <span class="stringliteral">"RtlFreeHeap"</span> )) {
00860 
00861                 <span class="keywordflow">if</span> ((ULONG_PTR)BaseAddress == <a class="code" href="../../d3/d9/heap_8h.html#a65">RtlpHeapStopOn</a>.<a class="code" href="../../d2/d7/struct__HEAP__STOP__ON__VALUES.html#o4">FreeAddress</a>) {
00862 
00863                     <a class="code" href="../../d9/d9/heappriv_8h.html#a10">HeapDebugPrint</a>(( <span class="stringliteral">"About to free block at %lx\n"</span>,
00864                                      <a class="code" href="../../d3/d9/heap_8h.html#a65">RtlpHeapStopOn</a>.<a class="code" href="../../d2/d7/struct__HEAP__STOP__ON__VALUES.html#o4">FreeAddress</a> ));
00865 
00866                     <a class="code" href="../../d9/d9/heappriv_8h.html#a11">HeapDebugBreak</a>( NULL );
00867 
00868                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((<a class="code" href="../../d9/d9/heappriv_8h.html#a22">IS_HEAP_TAGGING_ENABLED</a>()) &amp;&amp; (<a class="code" href="../../d3/d9/heap_8h.html#a65">RtlpHeapStopOn</a>.<a class="code" href="../../d2/d7/struct__HEAP__STOP__ON__VALUES.html#o5">FreeTag</a>.<a class="code" href="../../d9/d6/struct__HEAP__STOP__ON__TAG.html#o0">HeapAndTagIndex</a> != 0)) {
00869 
00870                     <span class="keywordflow">if</span> (BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a9">HEAP_ENTRY_EXTRA_PRESENT</a>) {
00871 
00872                         ExtraStuff = <a class="code" href="../../d9/d9/heappriv_8h.html#a41">RtlpGetExtraStuffPointer</a>( BusyBlock );
00873 
00874                         TagIndex = ExtraStuff-&gt;<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html#o1">TagIndex</a>;
00875 
00876                     } <span class="keywordflow">else</span> {
00877 
00878                         TagIndex = BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o5">SmallTagIndex</a>;
00879                     }
00880 
00881                     <span class="keywordflow">if</span> ((TagIndex != 0) &amp;&amp;
00882                         (TagIndex == <a class="code" href="../../d3/d9/heap_8h.html#a65">RtlpHeapStopOn</a>.<a class="code" href="../../d2/d7/struct__HEAP__STOP__ON__VALUES.html#o5">FreeTag</a>.<a class="code" href="../../d9/d6/struct__HEAP__STOP__ON__TAG.html#o1">TagIndex</a>) &amp;&amp;
00883                         (Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o11">ProcessHeapsListIndex</a> == <a class="code" href="../../d3/d9/heap_8h.html#a65">RtlpHeapStopOn</a>.<a class="code" href="../../d2/d7/struct__HEAP__STOP__ON__VALUES.html#o5">FreeTag</a>.<a class="code" href="../../d9/d6/struct__HEAP__STOP__ON__TAG.html#o2">HeapIndex</a>)) {
00884 
00885                         <a class="code" href="../../d9/d9/heappriv_8h.html#a10">HeapDebugPrint</a>(( <span class="stringliteral">"About to free block at %lx with tag %ws\n"</span>,
00886                                          BaseAddress,
00887                                          <a class="code" href="../../d9/d9/heappriv_8h.html#a51">RtlpGetTagName</a>( Heap, TagIndex )));
00888 
00889                         <a class="code" href="../../d9/d9/heappriv_8h.html#a11">HeapDebugBreak</a>( NULL );
00890                     }
00891                 }
00892 
00893                 Result = <a class="code" href="../../d9/d9/heappriv_8h.html#a39">RtlFreeHeapSlowly</a>( HeapHandle, Flags, BaseAddress );
00894 
00895                 <a class="code" href="../../d9/d9/heappriv_8h.html#a50">RtlpValidateHeapHeaders</a>( Heap, TRUE );
00896                 <a class="code" href="../../d9/d9/heappriv_8h.html#a48">RtlpValidateHeap</a>( Heap, FALSE );
00897             }
00898 
00899         } except( EXCEPTION_EXECUTE_HANDLER ) {
00900 
00901             <a class="code" href="../../d9/d9/heappriv_8h.html#a9">SET_LAST_STATUS</a>( GetExceptionCode() );
00902 
00903             Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00904         }
00905 
00906     } finally {
00907 
00908         <span class="keywordflow">if</span> (LockAcquired) {
00909 
00910             <a class="code" href="../../d9/d9/heappriv_8h.html#a4">RtlReleaseLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
00911         }
00912     }
00913 
00914     <span class="keywordflow">return</span> Result;
00915 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a8" doxytag="rtl/heap.c::RtlDebugSizeHeap" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ULONG RtlDebugSizeHeap           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>HeapHandle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Flags</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>BaseAddress</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l01177">1177</a> of file <a class="el" href="../../d5/d8/heapdbg_8c-source.html">heapdbg.c</a>.
<p>
References <a class="el" href="../../d7/d6/halmips_8h-source.html#l00055">EXCEPTION_EXECUTE_HANDLER</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00323">_HEAP::ForceFlags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00391">HEAP_SKIP_VALIDATION_CHECKS</a>, <a class="el" href="../../d5/d5/memory_8c-source.html#l00115">HeapHandle</a>, <a class="el" href="../../d8/d8/heappage_8h-source.html#l00058">IF_DEBUG_PAGE_HEAP_THEN_RETURN</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00369">_HEAP::LockVariable</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00078">RtlAcquireLockRoutine</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l04250">RtlpCheckHeapSignature()</a>, <a class="el" href="../../d7/d8/heappage_8c-source.html#l03401">RtlpDebugPageHeapSize()</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l02025">RtlpValidateHeap()</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l01696">RtlpValidateHeapEntry()</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00079">RtlReleaseLockRoutine</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l03655">RtlSizeHeap()</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00104">SET_LAST_STATUS</a>, and <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>.
<p>
Referenced by <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l03655">RtlSizeHeap()</a>.
<p>
<pre class="fragment"><div>01185                    :
01186 
01187 Arguments:
01188 
01189 Return Value:
01190 
01191 --*/
01192 
01193 {
01194     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap = (<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a>)<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
01195     <a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a> BusyBlock;
01196     BOOLEAN LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01197     SIZE_T BusySize;
01198 
01199     <a class="code" href="../../d7/d9/heappage_8h.html#a6">IF_DEBUG_PAGE_HEAP_THEN_RETURN</a>( HeapHandle,
01200                                     <a class="code" href="../../d7/d9/heappage_8h.html#a14">RtlpDebugPageHeapSize</a>( HeapHandle, Flags, BaseAddress ));
01201 
01202     BusySize = 0xFFFFFFFF;
01203 
01204     <span class="keywordflow">try</span> {
01205 
01206         <span class="keywordflow">try</span> {
01207 
01208             <span class="comment">//</span>
01209             <span class="comment">//  Validate that HeapAddress points to a HEAP structure.</span>
01210             <span class="comment">//</span>
01211 
01212             <span class="keywordflow">if</span> (!<a class="code" href="../../d9/d9/heappriv_8h.html#a46">RtlpCheckHeapSignature</a>( Heap, <span class="stringliteral">"RtlSizeHeap"</span> )) {
01213 
01214                 BusySize = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01215                 leave;
01216             }
01217 
01218             Flags |= Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o3">ForceFlags</a> | <a class="code" href="../../d3/d9/heap_8h.html#a23">HEAP_SKIP_VALIDATION_CHECKS</a>;
01219 
01220             <span class="comment">//</span>
01221             <span class="comment">//  Lock the heap</span>
01222             <span class="comment">//</span>
01223 
01224             <span class="keywordflow">if</span> (!(Flags &amp; HEAP_NO_SERIALIZE)) {
01225 
01226                 <a class="code" href="../../d9/d9/heappriv_8h.html#a3">RtlAcquireLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
01227 
01228                 Flags |= HEAP_NO_SERIALIZE;
01229 
01230                 LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01231             }
01232 
01233             <a class="code" href="../../d9/d9/heappriv_8h.html#a48">RtlpValidateHeap</a>( Heap, FALSE );
01234 
01235             BusyBlock = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)BaseAddress - 1;
01236 
01237             <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/heappriv_8h.html#a47">RtlpValidateHeapEntry</a>( Heap, BusyBlock, <span class="stringliteral">"RtlSizeHeap"</span> )) {
01238 
01239                 BusySize = <a class="code" href="../../d1/d9/rtl_2heap_8c.html#a21">RtlSizeHeap</a>( HeapHandle, Flags, BaseAddress );
01240             }
01241 
01242         } except( EXCEPTION_EXECUTE_HANDLER ) {
01243 
01244             <a class="code" href="../../d9/d9/heappriv_8h.html#a9">SET_LAST_STATUS</a>( GetExceptionCode() );
01245         }
01246 
01247     } finally {
01248 
01249         <span class="keywordflow">if</span> (LockAcquired) {
01250 
01251             <a class="code" href="../../d9/d9/heappriv_8h.html#a4">RtlReleaseLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
01252         }
01253     }
01254 
01255     <span class="keywordflow">return</span> BusySize;
01256 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a9" doxytag="rtl/heap.c::RtlDebugZeroHeap" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS RtlDebugZeroHeap           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>HeapHandle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Flags</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l01338">1338</a> of file <a class="el" href="../../d5/d8/heapdbg_8c-source.html">heapdbg.c</a>.
<p>
References <a class="el" href="../../d7/d6/halmips_8h-source.html#l00055">EXCEPTION_EXECUTE_HANDLER</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00323">_HEAP::ForceFlags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00391">HEAP_SKIP_VALIDATION_CHECKS</a>, <a class="el" href="../../d5/d5/memory_8c-source.html#l00115">HeapHandle</a>, <a class="el" href="../../d8/d8/heappage_8h-source.html#l00058">IF_DEBUG_PAGE_HEAP_THEN_RETURN</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00369">_HEAP::LockVariable</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00078">RtlAcquireLockRoutine</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l04250">RtlpCheckHeapSignature()</a>, <a class="el" href="../../d7/d8/heappage_8c-source.html#l03828">RtlpDebugPageHeapZero()</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l02025">RtlpValidateHeap()</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00079">RtlReleaseLockRoutine</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l03762">RtlZeroHeap()</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, and <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>.
<p>
Referenced by <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l03762">RtlZeroHeap()</a>.
<p>
<pre class="fragment"><div>01345                    :
01346 
01347 Arguments:
01348 
01349 Return Value:
01350 
01351 --*/
01352 
01353 {
01354     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01355     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap = (<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a>)<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
01356     BOOLEAN LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01357     SIZE_T LargestFreeSize;
01358 
01359     <a class="code" href="../../d7/d9/heappage_8h.html#a6">IF_DEBUG_PAGE_HEAP_THEN_RETURN</a>( HeapHandle,
01360                                     <a class="code" href="../../d7/d9/heappage_8h.html#a26">RtlpDebugPageHeapZero</a>( HeapHandle, Flags ));
01361 
01362     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
01363     LargestFreeSize = 0;
01364 
01365     <span class="keywordflow">try</span> {
01366 
01367         <span class="keywordflow">try</span> {
01368 
01369             <span class="comment">//</span>
01370             <span class="comment">//  Validate that HeapAddress points to a HEAP structure.</span>
01371             <span class="comment">//</span>
01372 
01373             <span class="keywordflow">if</span> (!<a class="code" href="../../d9/d9/heappriv_8h.html#a46">RtlpCheckHeapSignature</a>( Heap, <span class="stringliteral">"RtlZeroHeap"</span> )) {
01374 
01375                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_PARAMETER;
01376                 leave;
01377             }
01378 
01379             Flags |= Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o3">ForceFlags</a> | <a class="code" href="../../d3/d9/heap_8h.html#a23">HEAP_SKIP_VALIDATION_CHECKS</a>;
01380 
01381             <span class="comment">//</span>
01382             <span class="comment">//  Lock the heap</span>
01383             <span class="comment">//</span>
01384 
01385             <span class="keywordflow">if</span> (!(Flags &amp; HEAP_NO_SERIALIZE)) {
01386 
01387                 <a class="code" href="../../d9/d9/heappriv_8h.html#a3">RtlAcquireLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
01388 
01389                 LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01390 
01391                 Flags |= HEAP_NO_SERIALIZE;
01392             }
01393 
01394             <span class="keywordflow">if</span> (!<a class="code" href="../../d9/d9/heappriv_8h.html#a48">RtlpValidateHeap</a>( Heap, FALSE )) {
01395 
01396                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_PARAMETER;
01397 
01398             } <span class="keywordflow">else</span> {
01399 
01400                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d1/d9/rtl_2heap_8c.html#a22">RtlZeroHeap</a>( HeapHandle, Flags );
01401             }
01402 
01403         } except( EXCEPTION_EXECUTE_HANDLER ) {
01404 
01405             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = GetExceptionCode();
01406         }
01407 
01408     } finally {
01409 
01410         <span class="keywordflow">if</span> (LockAcquired) {
01411 
01412             <a class="code" href="../../d9/d9/heappriv_8h.html#a4">RtlReleaseLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
01413         }
01414     }
01415 
01416     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01417 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a16" doxytag="rtl/heap.c::RtlDestroyHeap" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> PVOID RtlDestroyHeap           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>HeapHandle</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l01133">1133</a> of file <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html">rtl/heap.c</a>.
<p>
References <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00103">DEBUG_HEAP</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00322">_HEAP::Flags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00388">HEAP_LOCK_USER_ALLOCATED</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00234">HEAP_MAXIMUM_SEGMENTS</a>, <a class="el" href="../../d3/d9/heap_8h.html#a39">HEAP_VIRTUAL_ALLOC_ENTRY</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00121">HeapDebugPrint</a>, <a class="el" href="../../d5/d5/memory_8c-source.html#l00115">HeapHandle</a>, <a class="el" href="../../d8/d8/heappage_8h-source.html#l00058">IF_DEBUG_PAGE_HEAP_THEN_RETURN</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00369">_HEAP::LockVariable</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00295">_HEAP_UCR_SEGMENT::Next</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d3/d9/heap_8h.html#a50">PHEAP_UCR_SEGMENT</a>, <a class="el" href="../../d6/d8/ntrtlp_8h-source.html#l00246">RTL_PAGED_CODE</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l00388">RtlDebugDestroyHeap()</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00080">RtlDeleteLockRoutine</a>, <a class="el" href="../../d7/d8/heappage_8c-source.html#l03259">RtlpDebugPageHeapDestroy()</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l04959">RtlpDestroyHeapSegment()</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l05893">RtlpDestroyTags()</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l04571">RtlpRemoveHeapFromProcessList()</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00355">_HEAP::Segments</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00340">_HEAP::UCRSegments</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00353">_HEAP::VirtualAllocdBlocks</a>, and <a class="el" href="../../d2/d7/hal_8h.html#a212">VOID()</a>.
<p>
Referenced by <a class="el" href="../../d7/d8/heappage_8c-source.html#l03259">RtlpDebugPageHeapDestroy()</a>, <a class="el" href="../../d5/d8/smbtrsup_8c-source.html#l01879">SmbTraceDisconnect()</a>, and <a class="el" href="../../d7/d7/clinit_8c-source.html#l00059">UserClientDllInitialize()</a>.
<p>
<pre class="fragment"><div>01139                    :
01140 
01141     This routine <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> opposite of Rtl <a class="code" href="../../d4/d5/conimep_8h.html#a111">Create</a> Heap.  It tears down an
01142     existing heap structure.
01143 
01144 Arguments:
01145 
01146     <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a> - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap being destroyed
01147 
01148 Return Value:
01149 
01150     PVOID - Returns null <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap was destroyed completely and a
01151         pointer back to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap <span class="keywordflow">if</span> <span class="keywordflow">for</span> some <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a10">reason</a> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap could
01152         not be destroyed.
01153 
01154 --*/
01155 
01156 {
01157     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap = (<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a>)<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
01158     <a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html">PHEAP_SEGMENT</a> Segment;
01159     <a class="code" href="../../d4/d7/struct__HEAP__UCR__SEGMENT.html">PHEAP_UCR_SEGMENT</a> UCRSegments;
01160     PLIST_ENTRY Head, Next;
01161     PVOID BaseAddress;
01162     SIZE_T RegionSize;
01163     UCHAR SegmentIndex;
01164 
01165     <span class="comment">//</span>
01166     <span class="comment">//  Validate that HeapAddress points to a HEAP structure.</span>
01167     <span class="comment">//</span>
01168 
01169     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
01170 
01171     <span class="keywordflow">if</span> (<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01172 
01173         <a class="code" href="../../d9/d9/heappriv_8h.html#a10">HeapDebugPrint</a>(( <span class="stringliteral">"Ignoring RtlDestroyHeap( NULL )\n"</span> ));
01174 
01175         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01176     }
01177 
01178 <span class="preprocessor">#ifndef NTOS_KERNEL_RUNTIME</span>
01179 <span class="preprocessor"></span><span class="preprocessor">#ifdef NTHEAP_ENABLED</span>
01180 <span class="preprocessor"></span>    {
01181         <span class="keywordflow">if</span> (Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o2">Flags</a> &amp; NTHEAP_ENABLED_FLAG) {
01182 
01183             <span class="keywordflow">return</span> RtlDestroyNtHeap( HeapHandle );
01184         }
01185     }
01186 <span class="preprocessor">#endif // NTHEAP_ENABLED</span>
01187 <span class="preprocessor"></span><span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
01188 <span class="preprocessor"></span>
01189     <span class="comment">//</span>
01190     <span class="comment">//  Check if this is the debug version of heap using page allocation</span>
01191     <span class="comment">//  with guard pages</span>
01192     <span class="comment">//</span>
01193 
01194     <a class="code" href="../../d7/d9/heappage_8h.html#a6">IF_DEBUG_PAGE_HEAP_THEN_RETURN</a>( HeapHandle,
01195                                     <a class="code" href="../../d7/d9/heappage_8h.html#a13">RtlpDebugPageHeapDestroy</a>( HeapHandle ));
01196 
01197 <span class="preprocessor">#ifndef NTOS_KERNEL_RUNTIME</span>
01198 <span class="preprocessor"></span>
01199     <span class="comment">//</span>
01200     <span class="comment">//  In the non kernel case check if this is the debug version of heap</span>
01201     <span class="comment">//  and of so then call the debug version to do the teardown</span>
01202     <span class="comment">//</span>
01203 
01204     <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/heappriv_8h.html#a8">DEBUG_HEAP</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o2">Flags</a> )) {
01205 
01206         <span class="keywordflow">if</span> (!<a class="code" href="../../d4/d9/heapdbg_8c.html#a12">RtlDebugDestroyHeap</a>( HeapHandle )) {
01207 
01208             <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
01209         }
01210     }
01211 
01212     <span class="comment">//</span>
01213     <span class="comment">//  We are not allowed to destroy the process heap</span>
01214     <span class="comment">//</span>
01215 
01216     <span class="keywordflow">if</span> (<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a> == NtCurrentPeb()-&gt;ProcessHeap) {
01217 
01218         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
01219     }
01220 
01221 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
01222 <span class="preprocessor"></span>
01223     <span class="comment">//</span>
01224     <span class="comment">//  For every big allocation we remove it from the list and free the</span>
01225     <span class="comment">//  vm</span>
01226     <span class="comment">//</span>
01227 
01228     Head = &amp;Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o21">VirtualAllocdBlocks</a>;
01229     Next = Head-&gt;Flink;
01230 
01231     <span class="keywordflow">while</span> (Head != Next) {
01232 
01233         BaseAddress = CONTAINING_RECORD( Next, <a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html">HEAP_VIRTUAL_ALLOC_ENTRY</a>, Entry );
01234 
01235         Next = Next-&gt;Flink;
01236         RegionSize = 0;
01237 
01238         ZwFreeVirtualMemory( NtCurrentProcess(),
01239                              (PVOID *)&amp;BaseAddress,
01240                              &amp;RegionSize,
01241                              MEM_RELEASE );
01242     }
01243 
01244 <span class="preprocessor">#ifndef NTOS_KERNEL_RUNTIME</span>
01245 <span class="preprocessor"></span>
01246     <span class="comment">//</span>
01247     <span class="comment">//  In the non kernel case we need to destory any heap tags we have setup</span>
01248     <span class="comment">//  and remove this heap from the process heap list</span>
01249     <span class="comment">//</span>
01250 
01251     <a class="code" href="../../d9/d9/heappriv_8h.html#a54">RtlpDestroyTags</a>( Heap );
01252     <a class="code" href="../../d9/d9/heappriv_8h.html#a44">RtlpRemoveHeapFromProcessList</a>( Heap );
01253 
01254 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
01255 <span class="preprocessor"></span>
01256     <span class="comment">//</span>
01257     <span class="comment">//  If the heap is serialized, delete the critical section created</span>
01258     <span class="comment">//  by RtlCreateHeap.</span>
01259     <span class="comment">//</span>
01260 
01261     <span class="keywordflow">if</span> (!(Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o2">Flags</a> &amp; HEAP_NO_SERIALIZE)) {
01262 
01263         <span class="keywordflow">if</span> (!(Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o2">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a20">HEAP_LOCK_USER_ALLOCATED</a>)) {
01264 
01265             (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>)<a class="code" href="../../d9/d9/heappriv_8h.html#a5">RtlDeleteLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
01266         }
01267 
01268         Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01269     }
01270 
01271     <span class="comment">//</span>
01272     <span class="comment">//  For every uncommitted segment we free its vm</span>
01273     <span class="comment">//</span>
01274 
01275     UCRSegments = Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o17">UCRSegments</a>;
01276     Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o17">UCRSegments</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01277 
01278     <span class="keywordflow">while</span> (UCRSegments) {
01279 
01280         BaseAddress = UCRSegments;
01281         UCRSegments = UCRSegments-&gt;<a class="code" href="../../d4/d7/struct__HEAP__UCR__SEGMENT.html#o0">Next</a>;
01282         RegionSize = 0;
01283 
01284         ZwFreeVirtualMemory( NtCurrentProcess(),
01285                              &amp;BaseAddress,
01286                              &amp;RegionSize,
01287                              MEM_RELEASE );
01288     }
01289 
01290     <span class="comment">//</span>
01291     <span class="comment">//  For every segment in the heap we call a worker routine to</span>
01292     <span class="comment">//  destory the segment</span>
01293     <span class="comment">//</span>
01294 
01295     SegmentIndex = <a class="code" href="../../d3/d9/heap_8h.html#a7">HEAP_MAXIMUM_SEGMENTS</a>;
01296 
01297     <span class="keywordflow">while</span> (SegmentIndex--) {
01298 
01299         Segment = Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o22">Segments</a>[ SegmentIndex ];
01300 
01301         <span class="keywordflow">if</span> (Segment) {
01302 
01303             <a class="code" href="../../d1/d9/rtl_2heap_8c.html#a13">RtlpDestroyHeapSegment</a>( Segment );
01304         }
01305     }
01306 
01307     <span class="comment">//</span>
01308     <span class="comment">//  And we return to our caller</span>
01309     <span class="comment">//</span>
01310 
01311     <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01312 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a19" doxytag="rtl/heap.c::RtlFreeHeap" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> BOOLEAN RtlFreeHeap           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>HeapHandle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Flags</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>BaseAddress</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l02931">2931</a> of file <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html">rtl/heap.c</a>.
<p>
References <a class="el" href="../../d4/d8/heap_8h-source.html#l00328">_HEAP::DeCommitFreeBlockThreshold</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00329">_HEAP::DeCommitTotalFreeThreshold</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00160">_HEAP_VIRTUAL_ALLOC_ENTRY::Entry</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00055">EXCEPTION_EXECUTE_HANDLER</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00200">_HEAP_FREE_ENTRY::Flags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00076">_HEAP_ENTRY::Flags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00322">_HEAP::Flags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00323">_HEAP::ForceFlags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00236">HEAP_ENTRY_BUSY</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00240">HEAP_ENTRY_LAST_ENTRY</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00239">HEAP_ENTRY_VIRTUAL_ALLOC</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00231">HEAP_MAXIMUM_BLOCK_SIZE</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00233">HEAP_MAXIMUM_FREELISTS</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00234">HEAP_MAXIMUM_SEGMENTS</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l00036">HEAP_SLOW_FLAGS</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00039">HEAPASSERT</a>, <a class="el" href="../../d5/d5/memory_8c-source.html#l00115">HeapHandle</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00369">_HEAP::LockVariable</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00382">_HEAP::Lookaside</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00383">_HEAP::LookasideLockCount</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d6/d8/ntrtlp_8h-source.html#l00246">RTL_PAGED_CODE</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00078">RtlAcquireLockRoutine</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l03273">RtlFreeHeapSlowly()</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l05312">RtlpCoalesceFreeBlocks()</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l05527">RtlpDeCommitFreeBlock()</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00397">RtlpFastInsertDedicatedFreeBlockDirect</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00425">RtlpFastInsertNonDedicatedFreeBlockDirect</a>, <a class="el" href="../../d1/d5/rtl_2lookasid_8c-source.html#l00288">RtlpFreeToHeapLookaside()</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l05849">RtlpInsertFreeBlock()</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00079">RtlReleaseLockRoutine</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00060">_HEAP_ENTRY::SegmentIndex</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00104">SET_LAST_STATUS</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00045">_HEAP_ENTRY::Size</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00331">_HEAP::TotalFreeSize</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, and <a class="el" href="../../d5/d4/aug98_2dll32_2icc__i386_8h-source.html#l00064">USHORT</a>.
<p>
<pre class="fragment"><div>02939                    :
02940 
02941     This routine returns a previously allocated block back to its heap
02942 
02943 Arguments:
02944 
02945     <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a> - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> owning heap structure
02946 
02947     Flags - Specifies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> set of flags to use in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> deallocation
02948 
02949     BaseAddress - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> block being freed
02950 
02951 Return Value:
02952 
02953     BOOLEAN - <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> block was properly freed and <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> otherwise
02954 
02955 --*/
02956 
02957 {
02958     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
02959     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap = (<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a>)<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
02960     <a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a> BusyBlock;
02961     <a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html">PHEAP_ENTRY_EXTRA</a> ExtraStuff;
02962     SIZE_T FreeSize;
02963     BOOLEAN LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02964     BOOLEAN ReturnValue = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02965 
02966     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
02967 
02968     <span class="comment">//</span>
02969     <span class="comment">//  First check if the address we're given is null and if so then</span>
02970     <span class="comment">//  there is really nothing to do so just return success</span>
02971     <span class="comment">//</span>
02972 
02973     <span class="keywordflow">if</span> (BaseAddress == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02974 
02975         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02976     }
02977 
02978 <span class="preprocessor">#ifndef NTOS_KERNEL_RUNTIME</span>
02979 <span class="preprocessor"></span><span class="preprocessor">#ifdef NTHEAP_ENABLED</span>
02980 <span class="preprocessor"></span>    {
02981         <span class="keywordflow">if</span> (Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o2">Flags</a> &amp; NTHEAP_ENABLED_FLAG) {
02982 
02983             <span class="keywordflow">return</span> RtlFreeNtHeap( HeapHandle,
02984                                   Flags,
02985                                   BaseAddress);
02986         }
02987     }
02988 <span class="preprocessor">#endif // NTHEAP_ENABLED</span>
02989 <span class="preprocessor"></span><span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
02990 <span class="preprocessor"></span>
02991 
02992     <span class="comment">//</span>
02993     <span class="comment">//  Compliment the input flags with those enforced by the heap</span>
02994     <span class="comment">//</span>
02995 
02996     Flags |= Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o3">ForceFlags</a>;
02997 
02998     <span class="comment">//</span>
02999     <span class="comment">//  Now check if we should go the slow route</span>
03000     <span class="comment">//</span>
03001 
03002     <span class="keywordflow">if</span> (Flags &amp; <a class="code" href="../../d1/d9/rtl_2heap_8c.html#a0">HEAP_SLOW_FLAGS</a>) {
03003 
03004         <span class="keywordflow">return</span> <a class="code" href="../../d9/d9/heappriv_8h.html#a39">RtlFreeHeapSlowly</a>(HeapHandle, Flags, BaseAddress);
03005     }
03006 
03007     <span class="comment">//</span>
03008     <span class="comment">//  We can do everything in this routine. So now backup to get</span>
03009     <span class="comment">//  a pointer to the start of the block</span>
03010     <span class="comment">//</span>
03011 
03012     BusyBlock = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)BaseAddress - 1;
03013 
03014     <span class="comment">//</span>
03015     <span class="comment">//  Protect ourselves from idiots by refusing to free blocks</span>
03016     <span class="comment">//  that do not have the busy bit set.</span>
03017     <span class="comment">//</span>
03018     <span class="comment">//  Also refuse to free blocks that are not eight-byte aligned.</span>
03019     <span class="comment">//  The specific idiot in this case is Office95, which likes</span>
03020     <span class="comment">//  to free a random pointer when you start Word95 from a desktop</span>
03021     <span class="comment">//  shortcut.</span>
03022     <span class="comment">//</span>
03023     <span class="comment">//  As further insurance against idiots, check the segment index</span>
03024     <span class="comment">//  to make sure it is less than HEAP_MAXIMUM_SEGMENTS (16). This</span>
03025     <span class="comment">//  should fix all the dorks who have ASCII or Unicode where the</span>
03026     <span class="comment">//  heap header is supposed to be.</span>
03027     <span class="comment">//</span>
03028 
03029     <span class="keywordflow">try</span> {
03030         <span class="keywordflow">if</span> ((!(BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a8">HEAP_ENTRY_BUSY</a>)) ||
03031             (((ULONG_PTR)BaseAddress &amp; 0x7) != 0) ||
03032             (BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o2">SegmentIndex</a> &gt;= <a class="code" href="../../d3/d9/heap_8h.html#a7">HEAP_MAXIMUM_SEGMENTS</a>)) {
03033 
03034             <span class="comment">//</span>
03035             <span class="comment">//  Not a busy block, or it's not aligned or the segment is</span>
03036             <span class="comment">//  to big, meaning it's corrupt</span>
03037             <span class="comment">//</span>
03038 
03039             <a class="code" href="../../d9/d9/heappriv_8h.html#a9">SET_LAST_STATUS</a>( STATUS_INVALID_PARAMETER );
03040 
03041             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03042         }
03043     } except(EXCEPTION_EXECUTE_HANDLER) {
03044 
03045         <a class="code" href="../../d9/d9/heappriv_8h.html#a9">SET_LAST_STATUS</a>( STATUS_INVALID_PARAMETER );
03046         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03047     }
03048 
03049     <span class="comment">//</span>
03050     <span class="comment">//  If there is a lookaside list and the block is not a big allocation</span>
03051     <span class="comment">//  and the index is for a dedicated list then free the block to the</span>
03052     <span class="comment">//  lookaside list.  We'll actually capture</span>
03053     <span class="comment">//  the lookaside pointer from the heap and only use the captured pointer.</span>
03054     <span class="comment">//  This will take care of the condition where a walk or lock heap can</span>
03055     <span class="comment">//  cause us to check for a non null pointer and then have it become null</span>
03056     <span class="comment">//  when we read it again.  If it is non null to start with then even if</span>
03057     <span class="comment">//  the user walks or locks the heap via another thread the pointer to</span>
03058     <span class="comment">//  still valid here so we can still try and do a lookaside list push</span>
03059     <span class="comment">//</span>
03060 
03061 <span class="preprocessor">#ifndef NTOS_KERNEL_RUNTIME</span>
03062 <span class="preprocessor"></span>
03063     {
03064         <a class="code" href="../../d6/d6/struct__HEAP__LOOKASIDE.html">PHEAP_LOOKASIDE</a> Lookaside = (<a class="code" href="../../d6/d6/struct__HEAP__LOOKASIDE.html">PHEAP_LOOKASIDE</a>)Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o33">Lookaside</a>;
03065 
03066         <span class="keywordflow">if</span> ((Lookaside != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
03067             (Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o34">LookasideLockCount</a> == 0) &amp;&amp;
03068             (!(BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a11">HEAP_ENTRY_VIRTUAL_ALLOC</a>)) &amp;&amp;
03069             ((FreeSize = BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a>) &lt; <a class="code" href="../../d3/d9/heap_8h.html#a6">HEAP_MAXIMUM_FREELISTS</a>)) {
03070 
03071             <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/rtl_2lookasid_8c.html#a6">RtlpFreeToHeapLookaside</a>( &amp;Lookaside[FreeSize], BaseAddress)) {
03072 
03073                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03074             }
03075         }
03076     }
03077 
03078 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
03079 <span class="preprocessor"></span>
03080     <span class="keywordflow">try</span> {
03081 
03082         <span class="comment">//</span>
03083         <span class="comment">//  Check if we need to lock the heap</span>
03084         <span class="comment">//</span>
03085 
03086         <span class="keywordflow">if</span> (!(Flags &amp; HEAP_NO_SERIALIZE)) {
03087 
03088             <a class="code" href="../../d9/d9/heappriv_8h.html#a3">RtlAcquireLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
03089 
03090             LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03091         }
03092 
03093         <span class="comment">//</span>
03094         <span class="comment">//  Check if this is not a virtual block allocation meaning</span>
03095         <span class="comment">//  that we it is part of the heap free list structure and not</span>
03096         <span class="comment">//  one huge allocation that we got from vm</span>
03097         <span class="comment">//</span>
03098 
03099         <span class="keywordflow">if</span> (!(BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a11">HEAP_ENTRY_VIRTUAL_ALLOC</a>)) {
03100 
03101             <span class="comment">//</span>
03102             <span class="comment">//  This block is not a big allocation so we need to</span>
03103             <span class="comment">//  to get its size, and coalesce the blocks note that</span>
03104             <span class="comment">//  the user mode heap does this conditionally on a heap</span>
03105             <span class="comment">//  flag.  The coalesce function returns the newly formed</span>
03106             <span class="comment">//  free block and the new size.</span>
03107             <span class="comment">//</span>
03108 
03109             FreeSize = BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a>;
03110 
03111 <span class="preprocessor">    #ifdef NTOS_KERNEL_RUNTIME</span>
03112 <span class="preprocessor"></span>
03113             BusyBlock = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)<a class="code" href="../../d9/d9/heappriv_8h.html#a34">RtlpCoalesceFreeBlocks</a>( Heap,
03114                                                              (<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a>)BusyBlock,
03115                                                              &amp;FreeSize,
03116                                                              FALSE );
03117 
03118 <span class="preprocessor">    #else // NTOS_KERNEL_RUNTIME</span>
03119 <span class="preprocessor"></span>
03120             <span class="keywordflow">if</span> (!(Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o2">Flags</a> &amp; HEAP_DISABLE_COALESCE_ON_FREE)) {
03121 
03122                 BusyBlock = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)<a class="code" href="../../d9/d9/heappriv_8h.html#a34">RtlpCoalesceFreeBlocks</a>( Heap,
03123                                                                  (<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a>)BusyBlock,
03124                                                                  &amp;FreeSize,
03125                                                                  FALSE );
03126             }
03127 
03128 <span class="preprocessor">    #endif // NTOS_KERNEL_RUNTIME</span>
03129 <span class="preprocessor"></span>
03130             <span class="comment">//</span>
03131             <span class="comment">//  Check for a small allocation that can go on a freelist</span>
03132             <span class="comment">//  first, these should never trigger a decommit.</span>
03133             <span class="comment">//</span>
03134 
03135             <a class="code" href="../../d9/d9/heappriv_8h.html#a0">HEAPASSERT</a>(HEAP_MAXIMUM_FREELISTS &lt; Heap-&gt;DeCommitFreeBlockThreshold);
03136 
03137             <span class="comment">//</span>
03138             <span class="comment">//  If the allocation fits on a free list then insert it on</span>
03139             <span class="comment">//  the appropriate free list.  If the block is not the last</span>
03140             <span class="comment">//  entry then make sure that the next block knows our correct</span>
03141             <span class="comment">//  size, and update the heap free space counter.</span>
03142             <span class="comment">//</span>
03143 
03144             <span class="keywordflow">if</span> (FreeSize &lt; <a class="code" href="../../d3/d9/heap_8h.html#a6">HEAP_MAXIMUM_FREELISTS</a>) {
03145 
03146                 <a class="code" href="../../d9/d9/heappriv_8h.html#a16">RtlpFastInsertDedicatedFreeBlockDirect</a>( Heap,
03147                                                         (<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a>)BusyBlock,
03148                                                         (USHORT)FreeSize );
03149 
03150                 <span class="keywordflow">if</span> (!(BusyBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>)) {
03151 
03152                     <a class="code" href="../../d9/d9/heappriv_8h.html#a0">HEAPASSERT</a>((BusyBlock + FreeSize)-&gt;PreviousSize == (USHORT)FreeSize);
03153                 }
03154 
03155                 Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o9">TotalFreeSize</a> += FreeSize;
03156 
03157             <span class="comment">//</span>
03158             <span class="comment">//  Otherwise the block is to big for one of the dedicated free list so</span>
03159             <span class="comment">//  see if the free size is under the decommit threshold by itself</span>
03160             <span class="comment">//  or the total free in the heap is under the decomit threshold then</span>
03161             <span class="comment">//  we'll put this into a free list</span>
03162             <span class="comment">//</span>
03163 
03164             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((FreeSize &lt; Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o7">DeCommitFreeBlockThreshold</a>) ||
03165                        ((Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o9">TotalFreeSize</a> + FreeSize) &lt; Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o8">DeCommitTotalFreeThreshold</a>)) {
03166 
03167                 <span class="comment">//</span>
03168                 <span class="comment">//  Check if the block can go into the [0] index free list, and if</span>
03169                 <span class="comment">//  so then do the insert and make sure the following block is</span>
03170                 <span class="comment">//  needed knows our correct size, and update the heaps free space</span>
03171                 <span class="comment">//  counter</span>
03172                 <span class="comment">//</span>
03173 
03174                 <span class="keywordflow">if</span> (FreeSize &lt;= (ULONG)<a class="code" href="../../d3/d9/heap_8h.html#a5">HEAP_MAXIMUM_BLOCK_SIZE</a>) {
03175 
03176                     <a class="code" href="../../d9/d9/heappriv_8h.html#a17">RtlpFastInsertNonDedicatedFreeBlockDirect</a>( Heap,
03177                                                                (<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a>)BusyBlock,
03178                                                                (USHORT)FreeSize );
03179 
03180                     <span class="keywordflow">if</span> (!(BusyBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>)) {
03181 
03182                         <a class="code" href="../../d9/d9/heappriv_8h.html#a0">HEAPASSERT</a>((BusyBlock + FreeSize)-&gt;PreviousSize == (USHORT)FreeSize);
03183                     }
03184 
03185                     Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o9">TotalFreeSize</a> += FreeSize;
03186 
03187                 } <span class="keywordflow">else</span> {
03188 
03189                     <span class="comment">//</span>
03190                     <span class="comment">//  The block is too big to go on a free list in its</span>
03191                     <span class="comment">//  entirety but we don't want to decommit anything so</span>
03192                     <span class="comment">//  simply call a worker routine to hack up the block</span>
03193                     <span class="comment">//  into pieces that will fit on the free lists.</span>
03194                     <span class="comment">//</span>
03195 
03196                     <a class="code" href="../../d9/d9/heappriv_8h.html#a36">RtlpInsertFreeBlock</a>( Heap, (<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a>)BusyBlock, FreeSize );
03197                 }
03198 
03199             <span class="comment">//</span>
03200             <span class="comment">//  Otherwise the block is to big for any lists and we should decommit</span>
03201             <span class="comment">//  the block</span>
03202             <span class="comment">//</span>
03203 
03204             } <span class="keywordflow">else</span> {
03205 
03206                 <a class="code" href="../../d9/d9/heappriv_8h.html#a35">RtlpDeCommitFreeBlock</a>( Heap, (<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a>)BusyBlock, FreeSize );
03207             }
03208 
03209         } <span class="keywordflow">else</span> {
03210 
03211             <span class="comment">//</span>
03212             <span class="comment">//  This is a big virtual block allocation.  To free it we only have to</span>
03213             <span class="comment">//  remove it from the heaps list of virtual allocated blocks, unlock</span>
03214             <span class="comment">//  the heap, and return the block to vm</span>
03215             <span class="comment">//</span>
03216 
03217             <a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html">PHEAP_VIRTUAL_ALLOC_ENTRY</a> VirtualAllocBlock;
03218 
03219             VirtualAllocBlock = CONTAINING_RECORD( BusyBlock, <a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html">HEAP_VIRTUAL_ALLOC_ENTRY</a>, BusyBlock );
03220 
03221             RemoveEntryList( &amp;VirtualAllocBlock-&gt;<a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html#o0">Entry</a> );
03222 
03223             <span class="comment">//</span>
03224             <span class="comment">//  Release lock here as there is no reason to hold it across</span>
03225             <span class="comment">//  the system call.</span>
03226             <span class="comment">//</span>
03227 
03228             <span class="keywordflow">if</span> (LockAcquired) {
03229 
03230                 <a class="code" href="../../d9/d9/heappriv_8h.html#a4">RtlReleaseLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
03231                 LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03232             }
03233 
03234             FreeSize = 0;
03235 
03236             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwFreeVirtualMemory( NtCurrentProcess(),
03237                                           (PVOID *)&amp;VirtualAllocBlock,
03238                                           &amp;FreeSize,
03239                                           MEM_RELEASE );
03240 
03241 
03242             <span class="comment">//</span>
03243             <span class="comment">//  Check if we had trouble freeing the block back to vm</span>
03244             <span class="comment">//  and return an error if necessary</span>
03245             <span class="comment">//</span>
03246 
03247             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
03248 
03249                 <a class="code" href="../../d9/d9/heappriv_8h.html#a9">SET_LAST_STATUS</a>( Status );
03250 
03251                 ReturnValue = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03252             }
03253         }
03254 
03255     } finally {
03256 
03257         <span class="keywordflow">if</span> (LockAcquired) {
03258 
03259             <a class="code" href="../../d9/d9/heappriv_8h.html#a4">RtlReleaseLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
03260         }
03261     }
03262 
03263     <span class="comment">//</span>
03264     <span class="comment">//  The block was freed successfully so return success to our</span>
03265     <span class="comment">//  caller</span>
03266     <span class="comment">//</span>
03267 
03268     <span class="keywordflow">return</span> ReturnValue;
03269 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a20" doxytag="rtl/heap.c::RtlFreeHeapSlowly" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> BOOLEAN RtlFreeHeapSlowly           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>HeapHandle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Flags</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>BaseAddress</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l03273">3273</a> of file <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html">rtl/heap.c</a>.
<p>
References <a class="el" href="../../d4/d8/heap_8h-source.html#l00162">_HEAP_VIRTUAL_ALLOC_ENTRY::CommitSize</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00103">DEBUG_HEAP</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00328">_HEAP::DeCommitFreeBlockThreshold</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00329">_HEAP::DeCommitTotalFreeThreshold</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00160">_HEAP_VIRTUAL_ALLOC_ENTRY::Entry</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00055">EXCEPTION_EXECUTE_HANDLER</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00161">_HEAP_VIRTUAL_ALLOC_ENTRY::ExtraStuff</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00076">_HEAP_ENTRY::Flags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00322">_HEAP::Flags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00200">_HEAP_FREE_ENTRY::Flags</a>, <a class="el" href="../../d9/d9/heappriv_8h.html#a60a29">FreeAction</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00150">_HEAP_FREE_ENTRY_EXTRA::FreeBackTraceIndex</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00392">HEAP_CAPTURE_STACK_BACKTRACES</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00236">HEAP_ENTRY_BUSY</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00237">HEAP_ENTRY_EXTRA_PRESENT</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00240">HEAP_ENTRY_LAST_ENTRY</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00239">HEAP_ENTRY_VIRTUAL_ALLOC</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00228">HEAP_GRANULARITY_SHIFT</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00231">HEAP_MAXIMUM_BLOCK_SIZE</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00234">HEAP_MAXIMUM_SEGMENTS</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00039">HEAPASSERT</a>, <a class="el" href="../../d5/d5/memory_8c-source.html#l00115">HeapHandle</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00563">IS_HEAP_TAGGING_ENABLED</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00369">_HEAP::LockVariable</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d3/d9/heap_8h.html#a38">PHEAP_FREE_ENTRY_EXTRA</a>, <a class="el" href="../../d6/d8/ntrtlp_8h-source.html#l00246">RTL_PAGED_CODE</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00078">RtlAcquireLockRoutine</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l00797">RtlDebugFreeHeap()</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l05312">RtlpCoalesceFreeBlocks()</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l05527">RtlpDeCommitFreeBlock()</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l05849">RtlpInsertFreeBlock()</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00322">RtlpInsertFreeBlockDirect</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l05554">RtlpUpdateTagEntry()</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00079">RtlReleaseLockRoutine</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00060">_HEAP_ENTRY::SegmentIndex</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00104">SET_LAST_STATUS</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00045">_HEAP_ENTRY::Size</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00091">_HEAP_ENTRY::SmallTagIndex</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00121">_HEAP_ENTRY_EXTRA::TagIndex</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00149">_HEAP_FREE_ENTRY_EXTRA::TagIndex</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00331">_HEAP::TotalFreeSize</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, <a class="el" href="../../d5/d4/aug98_2dll32_2icc__i386_8h-source.html#l00064">USHORT</a>, and <a class="el" href="../../d9/d9/heappriv_8h.html#a60a30">VirtualFreeAction</a>.
<p>
Referenced by <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l00797">RtlDebugFreeHeap()</a>, and <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l02931">RtlFreeHeap()</a>.
<p>
<pre class="fragment"><div>03281                    :
03282 
03283     This routine returns a previously allocated block back to its heap.
03284     It <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> slower version of Rtl Free Heap and does more checking and
03285     tagging <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a58">control</a>.
03286 
03287 Arguments:
03288 
03289     <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a> - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> owning heap structure
03290 
03291     Flags - Specifies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> set of flags to use in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> deallocation
03292 
03293     BaseAddress - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> block being freed
03294 
03295 Return Value:
03296 
03297     BOOLEAN - <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> block was properly freed and <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> otherwise
03298 
03299 --*/
03300 
03301 {
03302     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
03303     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap = (<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a>)<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
03304     <a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a> BusyBlock;
03305     <a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html">PHEAP_ENTRY_EXTRA</a> ExtraStuff;
03306     SIZE_T FreeSize;
03307     BOOLEAN Result;
03308     BOOLEAN LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03309 
03310 <span class="preprocessor">#ifndef NTOS_KERNEL_RUNTIME</span>
03311 <span class="preprocessor"></span>
03312     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> TagIndex;
03313 
03314 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
03315 <span class="preprocessor"></span>
03316     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
03317 
03318     <span class="comment">//</span>
03319     <span class="comment">//  Note that Flags has already been OR'd with Heap-&gt;ForceFlags.</span>
03320     <span class="comment">//</span>
03321 
03322 <span class="preprocessor">#ifndef NTOS_KERNEL_RUNTIME</span>
03323 <span class="preprocessor"></span>
03324     <span class="comment">//</span>
03325     <span class="comment">//  In the non kernel case see if we should be calling the debug version to</span>
03326     <span class="comment">//  free the heap</span>
03327     <span class="comment">//</span>
03328 
03329     <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/heappriv_8h.html#a8">DEBUG_HEAP</a>( Flags )) {
03330 
03331         <span class="keywordflow">return</span> <a class="code" href="../../d4/d9/heapdbg_8c.html#a15">RtlDebugFreeHeap</a>( HeapHandle, Flags, BaseAddress );
03332     }
03333 
03334 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
03335 <span class="preprocessor"></span>
03336     <span class="comment">//</span>
03337     <span class="comment">//  Until we figure out otherwise we'll assume that this call will fail</span>
03338     <span class="comment">//</span>
03339 
03340     Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03341 
03342     <span class="keywordflow">try</span> {
03343 
03344         <span class="comment">//</span>
03345         <span class="comment">//  Lock the heap</span>
03346         <span class="comment">//</span>
03347 
03348         <span class="keywordflow">if</span> (!(Flags &amp; HEAP_NO_SERIALIZE)) {
03349 
03350             <a class="code" href="../../d9/d9/heappriv_8h.html#a3">RtlAcquireLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
03351 
03352             LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03353         }
03354 
03355         <span class="keywordflow">try</span> {
03356 
03357             <span class="comment">//</span>
03358             <span class="comment">//  Backup to get a pointer to the start of the block</span>
03359             <span class="comment">//</span>
03360 
03361             BusyBlock = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)BaseAddress - 1;
03362 
03363             <span class="comment">//</span>
03364             <span class="comment">//  Protect ourselves from idiots by refusing to free blocks</span>
03365             <span class="comment">//  that do not have the busy bit set.</span>
03366             <span class="comment">//</span>
03367             <span class="comment">//  Also refuse to free blocks that are not eight-byte aligned.</span>
03368             <span class="comment">//  The specific idiot in this case is Office95, which likes</span>
03369             <span class="comment">//  to free a random pointer when you start Word95 from a desktop</span>
03370             <span class="comment">//  shortcut.</span>
03371             <span class="comment">//</span>
03372             <span class="comment">//  As further insurance against idiots, check the segment index</span>
03373             <span class="comment">//  to make sure it is less than HEAP_MAXIMUM_SEGMENTS (16). This</span>
03374             <span class="comment">//  should fix all the dorks who have ASCII or Unicode where the</span>
03375             <span class="comment">//  heap header is supposed to be.</span>
03376             <span class="comment">//</span>
03377             <span class="comment">//  Note that this test is just opposite from the test used in</span>
03378             <span class="comment">//  Rtl Free Heap</span>
03379             <span class="comment">//</span>
03380 
03381             <span class="keywordflow">if</span> ((BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a8">HEAP_ENTRY_BUSY</a>) &amp;&amp;
03382                 (((ULONG_PTR)BaseAddress &amp; 0x7) == 0) &amp;&amp;
03383                 (BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o2">SegmentIndex</a> &lt; <a class="code" href="../../d3/d9/heap_8h.html#a7">HEAP_MAXIMUM_SEGMENTS</a>)) {
03384 
03385                 <span class="comment">//</span>
03386                 <span class="comment">//  Check if this is a virtual block allocation</span>
03387                 <span class="comment">//</span>
03388 
03389                 <span class="keywordflow">if</span> (BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a11">HEAP_ENTRY_VIRTUAL_ALLOC</a>) {
03390 
03391                     <a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html">PHEAP_VIRTUAL_ALLOC_ENTRY</a> VirtualAllocBlock;
03392 
03393                     <span class="comment">//</span>
03394                     <span class="comment">//  This is a big virtual block allocation.  To free it</span>
03395                     <span class="comment">//  we only have to remove it from the heaps list of</span>
03396                     <span class="comment">//  virtual allocated blocks, unlock the heap, and return</span>
03397                     <span class="comment">//  the block to vm</span>
03398                     <span class="comment">//</span>
03399 
03400                     VirtualAllocBlock = CONTAINING_RECORD( BusyBlock, <a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html">HEAP_VIRTUAL_ALLOC_ENTRY</a>, BusyBlock );
03401 
03402                     RemoveEntryList( &amp;VirtualAllocBlock-&gt;<a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html#o0">Entry</a> );
03403 
03404 <span class="preprocessor">    #ifndef NTOS_KERNEL_RUNTIME</span>
03405 <span class="preprocessor"></span>
03406                     <span class="comment">//</span>
03407                     <span class="comment">//  In the non kernel case see if we need to free the tag</span>
03408                     <span class="comment">//</span>
03409 
03410                     <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/heappriv_8h.html#a22">IS_HEAP_TAGGING_ENABLED</a>()) {
03411 
03412                         <a class="code" href="../../d9/d9/heappriv_8h.html#a52">RtlpUpdateTagEntry</a>( Heap,
03413                                             VirtualAllocBlock-&gt;<a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html#o1">ExtraStuff</a>.<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html#o1">TagIndex</a>,
03414                                             VirtualAllocBlock-&gt;<a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html#o2">CommitSize</a> &gt;&gt; HEAP_GRANULARITY_SHIFT,
03415                                             0,
03416                                             VirtualFreeAction );
03417                     }
03418 
03419 <span class="preprocessor">    #endif // NTOS_KERNEL_RUNTIME</span>
03420 <span class="preprocessor"></span>
03421                     FreeSize = 0;
03422 
03423                     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwFreeVirtualMemory( NtCurrentProcess(),
03424                                                   (PVOID *)&amp;VirtualAllocBlock,
03425                                                   &amp;FreeSize,
03426                                                   MEM_RELEASE );
03427 
03428                     <span class="comment">//</span>
03429                     <span class="comment">//  Check if everything worked okay, if we had trouble freeing</span>
03430                     <span class="comment">//  the block back to vm return an error if necessary,</span>
03431                     <span class="comment">//</span>
03432 
03433                     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
03434 
03435                         Result = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03436 
03437                     } <span class="keywordflow">else</span> {
03438 
03439                         <a class="code" href="../../d9/d9/heappriv_8h.html#a9">SET_LAST_STATUS</a>( Status );
03440                     }
03441 
03442                 } <span class="keywordflow">else</span> {
03443 
03444                     <span class="comment">//</span>
03445                     <span class="comment">//  This block is not a big allocation so we need to</span>
03446                     <span class="comment">//  to get its size, and coalesce the blocks note that</span>
03447                     <span class="comment">//  the user mode heap does this conditionally on a heap</span>
03448                     <span class="comment">//  flag.  The coalesce function returns the newly formed</span>
03449                     <span class="comment">//  free block and the new size.</span>
03450                     <span class="comment">//</span>
03451 
03452 <span class="preprocessor">    #ifndef NTOS_KERNEL_RUNTIME</span>
03453 <span class="preprocessor"></span>
03454                     <span class="comment">//</span>
03455                     <span class="comment">//  First in the non kernel case remove any tagging we might</span>
03456                     <span class="comment">//  have been using.  Note that the will either be in</span>
03457                     <span class="comment">//  the heap header, or in the extra block if present</span>
03458                     <span class="comment">//</span>
03459 
03460                     <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/heappriv_8h.html#a22">IS_HEAP_TAGGING_ENABLED</a>()) {
03461 
03462                         <span class="keywordflow">if</span> (BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a9">HEAP_ENTRY_EXTRA_PRESENT</a>) {
03463 
03464                             ExtraStuff = (<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html">PHEAP_ENTRY_EXTRA</a>)(BusyBlock + BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a> - 1);
03465 
03466                             TagIndex = <a class="code" href="../../d9/d9/heappriv_8h.html#a52">RtlpUpdateTagEntry</a>( Heap,
03467                                                            ExtraStuff-&gt;<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html#o1">TagIndex</a>,
03468                                                            BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a>,
03469                                                            0,
03470                                                            FreeAction );
03471 
03472                         } <span class="keywordflow">else</span> {
03473 
03474                             TagIndex = <a class="code" href="../../d9/d9/heappriv_8h.html#a52">RtlpUpdateTagEntry</a>( Heap,
03475                                                            BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o5">SmallTagIndex</a>,
03476                                                            BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a>,
03477                                                            0,
03478                                                            FreeAction );
03479                         }
03480 
03481                     } <span class="keywordflow">else</span> {
03482 
03483                         TagIndex = 0;
03484                     }
03485 
03486 <span class="preprocessor">    #endif // NTOS_KERNEL_RUNTIME</span>
03487 <span class="preprocessor"></span>
03488                     <span class="comment">//</span>
03489                     <span class="comment">//  This is the size of the block we are freeing</span>
03490                     <span class="comment">//</span>
03491 
03492                     FreeSize = BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a>;
03493 
03494 <span class="preprocessor">    #ifndef NTOS_KERNEL_RUNTIME</span>
03495 <span class="preprocessor"></span>
03496                     <span class="comment">//</span>
03497                     <span class="comment">//  In the non kernel case see if we should coalesce on free</span>
03498                     <span class="comment">//</span>
03499 
03500                     <span class="keywordflow">if</span> (!(Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o2">Flags</a> &amp; HEAP_DISABLE_COALESCE_ON_FREE)) {
03501 
03502 <span class="preprocessor">    #endif // NTOS_KERNEL_RUNTIME</span>
03503 <span class="preprocessor"></span>
03504                         <span class="comment">//</span>
03505                         <span class="comment">//  In kernel case and in the tested user mode case we</span>
03506                         <span class="comment">//  now coalesce free blocks</span>
03507                         <span class="comment">//</span>
03508 
03509                         BusyBlock = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)<a class="code" href="../../d9/d9/heappriv_8h.html#a34">RtlpCoalesceFreeBlocks</a>( Heap, (<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a>)BusyBlock, &amp;FreeSize, FALSE );
03510 
03511 <span class="preprocessor">    #ifndef NTOS_KERNEL_RUNTIME</span>
03512 <span class="preprocessor"></span>
03513                     }
03514 
03515 <span class="preprocessor">    #endif // NTOS_KERNEL_RUNTIME</span>
03516 <span class="preprocessor"></span>
03517                     <span class="comment">//</span>
03518                     <span class="comment">//  If the block should not be decommit then try and put it</span>
03519                     <span class="comment">//  on a free list</span>
03520                     <span class="comment">//</span>
03521 
03522                     <span class="keywordflow">if</span> ((FreeSize &lt; Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o7">DeCommitFreeBlockThreshold</a>) ||
03523                         ((Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o9">TotalFreeSize</a> + FreeSize) &lt; Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o8">DeCommitTotalFreeThreshold</a>)) {
03524 
03525                         <span class="comment">//</span>
03526                         <span class="comment">//  Check if the block can fit on one of the dedicated free</span>
03527                         <span class="comment">//  lists</span>
03528                         <span class="comment">//</span>
03529 
03530                         <span class="keywordflow">if</span> (FreeSize &lt;= (ULONG)<a class="code" href="../../d3/d9/heap_8h.html#a5">HEAP_MAXIMUM_BLOCK_SIZE</a>) {
03531 
03532                             <span class="comment">//</span>
03533                             <span class="comment">//  It can fit on a dedicated free list so insert it on</span>
03534                             <span class="comment">//</span>
03535 
03536                             <a class="code" href="../../d9/d9/heappriv_8h.html#a14">RtlpInsertFreeBlockDirect</a>( Heap, (<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a>)BusyBlock, (USHORT)FreeSize );
03537 
03538                             <span class="comment">//</span>
03539                             <span class="comment">//  If there is a following entry then make sure the</span>
03540                             <span class="comment">//  sizes agree</span>
03541                             <span class="comment">//</span>
03542 
03543                             <span class="keywordflow">if</span> (!(BusyBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>)) {
03544 
03545                                 <a class="code" href="../../d9/d9/heappriv_8h.html#a0">HEAPASSERT</a>((BusyBlock + FreeSize)-&gt;PreviousSize == (USHORT)FreeSize);
03546                             }
03547 
03548                             <span class="comment">//</span>
03549                             <span class="comment">//  Update the heap with the amount of free space</span>
03550                             <span class="comment">//  available</span>
03551                             <span class="comment">//</span>
03552 
03553                             Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o9">TotalFreeSize</a> += FreeSize;
03554 
03555                         } <span class="keywordflow">else</span> {
03556 
03557                             <span class="comment">//</span>
03558                             <span class="comment">//  The block goes on the non dedicated free list</span>
03559                             <span class="comment">//</span>
03560 
03561                             <a class="code" href="../../d9/d9/heappriv_8h.html#a36">RtlpInsertFreeBlock</a>( Heap, (<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a>)BusyBlock, FreeSize );
03562                         }
03563 
03564 <span class="preprocessor">    #ifndef NTOS_KERNEL_RUNTIME</span>
03565 <span class="preprocessor"></span>
03566                         <span class="comment">//</span>
03567                         <span class="comment">//  In the non kernel case see if the there was tag and if</span>
03568                         <span class="comment">//  so then update the entry to show that it's been freed</span>
03569                         <span class="comment">//</span>
03570 
03571                         <span class="keywordflow">if</span> (TagIndex != 0) {
03572 
03573                             <a class="code" href="../../d2/d6/struct__HEAP__FREE__ENTRY__EXTRA.html">PHEAP_FREE_ENTRY_EXTRA</a> FreeExtra;
03574 
03575                             BusyBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o3">Flags</a> |= <a class="code" href="../../d3/d9/heap_8h.html#a9">HEAP_ENTRY_EXTRA_PRESENT</a>;
03576 
03577                             FreeExtra = (<a class="code" href="../../d2/d6/struct__HEAP__FREE__ENTRY__EXTRA.html">PHEAP_FREE_ENTRY_EXTRA</a>)(BusyBlock + BusyBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o0">Size</a>) - 1;
03578 
03579                             FreeExtra-&gt;<a class="code" href="../../d2/d6/struct__HEAP__FREE__ENTRY__EXTRA.html#o0">TagIndex</a> = TagIndex;
03580                             FreeExtra-&gt;<a class="code" href="../../d2/d6/struct__HEAP__FREE__ENTRY__EXTRA.html#o1">FreeBackTraceIndex</a> = 0;
03581 
03582 <span class="preprocessor">    #if i386</span>
03583 <span class="preprocessor"></span>
03584                             <span class="comment">//</span>
03585                             <span class="comment">//  In the x86 case we can also capture the stack</span>
03586                             <span class="comment">//  backtrace</span>
03587                             <span class="comment">//</span>
03588 
03589                             <span class="keywordflow">if</span> (Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o2">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a24">HEAP_CAPTURE_STACK_BACKTRACES</a>) {
03590 
03591                                 FreeExtra-&gt;<a class="code" href="../../d2/d6/struct__HEAP__FREE__ENTRY__EXTRA.html#o1">FreeBackTraceIndex</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)RtlLogStackBackTrace();
03592                             }
03593 
03594 <span class="preprocessor">    #endif // i386</span>
03595 <span class="preprocessor"></span>
03596                         }
03597 
03598 <span class="preprocessor">    #endif // NTOS_KERNEL_RUNTIME</span>
03599 <span class="preprocessor"></span>
03600                     } <span class="keywordflow">else</span> {
03601 
03602                         <span class="comment">//</span>
03603                         <span class="comment">//  Otherwise the block is big enough to decommit so have a</span>
03604                         <span class="comment">//  worker routine to do the decommit</span>
03605                         <span class="comment">//</span>
03606 
03607                         <a class="code" href="../../d9/d9/heappriv_8h.html#a35">RtlpDeCommitFreeBlock</a>( Heap, (<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a>)BusyBlock, FreeSize );
03608                     }
03609 
03610                     <span class="comment">//</span>
03611                     <span class="comment">//  And say the free worked fine</span>
03612                     <span class="comment">//</span>
03613 
03614                     Result = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03615                 }
03616 
03617             } <span class="keywordflow">else</span> {
03618 
03619                 <span class="comment">//</span>
03620                 <span class="comment">//  Not a busy block, or it's not aligned or the segment is</span>
03621                 <span class="comment">//  to big, meaning it's corrupt</span>
03622                 <span class="comment">//</span>
03623 
03624                 <a class="code" href="../../d9/d9/heappriv_8h.html#a9">SET_LAST_STATUS</a>( STATUS_INVALID_PARAMETER );
03625             }
03626 
03627         } except( EXCEPTION_EXECUTE_HANDLER ) {
03628 
03629             <a class="code" href="../../d9/d9/heappriv_8h.html#a9">SET_LAST_STATUS</a>( GetExceptionCode() );
03630 
03631             Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03632         }
03633 
03634     } finally {
03635 
03636         <span class="comment">//</span>
03637         <span class="comment">//  Unlock the heap</span>
03638         <span class="comment">//</span>
03639 
03640         <span class="keywordflow">if</span> (LockAcquired) {
03641 
03642             <a class="code" href="../../d9/d9/heappriv_8h.html#a4">RtlReleaseLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
03643         }
03644     }
03645 
03646     <span class="comment">//</span>
03647     <span class="comment">//  And return to our caller</span>
03648     <span class="comment">//</span>
03649 
03650     <span class="keywordflow">return</span> Result;
03651 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a30" doxytag="rtl/heap.c::RtlpCheckBusyBlockTail" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> BOOLEAN RtlpCheckBusyBlockTail           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>BusyBlock</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l06117">6117</a> of file <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html">rtl/heap.c</a>.
<p>
References <a class="el" href="../../d4/d8/heap_8h-source.html#l00394">CHECK_HEAP_TAIL_SIZE</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l00043">CheckHeapFillPattern</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00239">HEAP_ENTRY_VIRTUAL_ALLOC</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00228">HEAP_GRANULARITY_SHIFT</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00134">HeapDebugBreak</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00121">HeapDebugPrint</a>, <a class="el" href="../../d6/d8/ntrtlp_8h-source.html#l00246">RTL_PAGED_CODE</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l06070">RtlpGetSizeOfBigBlock()</a>, <a class="el" href="../../d9/d6/lh__open_2pi__mem_8h-source.html#l00017">Size</a>, and <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>.
<p>
Referenced by <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l02025">RtlpValidateHeap()</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l01696">RtlpValidateHeapEntry()</a>, and <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l01790">RtlpValidateHeapSegment()</a>.
<p>
<pre class="fragment"><div>06123                    :
06124 
06125     This routine checks to see <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> bytes beyond <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> user specified
06126     allocation have been modified.  It does <span class="keyword">this</span> by checking <span class="keywordflow">for</span> a tail
06127     fill pattern
06128 
06129 Arguments:
06130 
06131     BusyBlock - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap block being queried
06132 
06133 Return Value:
06134 
06135     BOOLEAN - <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> tail <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> still okay and <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> otherwise
06136 
06137 --*/
06138 
06139 {
06140     PCHAR Tail;
06141     SIZE_T <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>, cbEqual;
06142 
06143     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
06144 
06145     <span class="comment">//</span>
06146     <span class="comment">//  Compute the user allocated size of the input heap block</span>
06147     <span class="comment">//</span>
06148 
06149     <span class="keywordflow">if</span> (BusyBlock-&gt;Flags &amp; <a class="code" href="../../d3/d9/heap_8h.html#a11">HEAP_ENTRY_VIRTUAL_ALLOC</a>) {
06150 
06151         <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> = <a class="code" href="../../d9/d9/heappriv_8h.html#a40">RtlpGetSizeOfBigBlock</a>( BusyBlock );
06152 
06153     } <span class="keywordflow">else</span> {
06154 
06155         <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> = (BusyBlock-&gt;Size &lt;&lt; <a class="code" href="../../d3/d9/heap_8h.html#a4">HEAP_GRANULARITY_SHIFT</a>) - BusyBlock-&gt;UnusedBytes;
06156     }
06157 
06158     <span class="comment">//</span>
06159     <span class="comment">//  Compute a pointer to the tail of the input block.  This would</span>
06160     <span class="comment">//  be the space right after the user allocated portion</span>
06161     <span class="comment">//</span>
06162 
06163     Tail = (PCHAR)(BusyBlock + 1) + <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
06164 
06165     <span class="comment">//</span>
06166     <span class="comment">//  Check if the tail fill pattern is still there</span>
06167     <span class="comment">//</span>
06168 
06169     cbEqual = RtlCompareMemory( Tail,
06170                                 CheckHeapFillPattern,
06171                                 CHECK_HEAP_TAIL_SIZE );
06172 
06173     <span class="comment">//</span>
06174     <span class="comment">//  If the number we get back isn't equal to the tail size then</span>
06175     <span class="comment">//  someone modified the block beyond its user specified allocation</span>
06176     <span class="comment">//  size</span>
06177     <span class="comment">//</span>
06178 
06179     <span class="keywordflow">if</span> (cbEqual != <a class="code" href="../../d3/d9/heap_8h.html#a25">CHECK_HEAP_TAIL_SIZE</a>) {
06180 
06181         <span class="comment">//</span>
06182         <span class="comment">//  Do some debug printing</span>
06183         <span class="comment">//</span>
06184 
06185         <a class="code" href="../../d9/d9/heappriv_8h.html#a10">HeapDebugPrint</a>(( <span class="stringliteral">"Heap block at %p modified at %p past requested size of %lx\n"</span>,
06186                          BusyBlock,
06187                          Tail + cbEqual,
06188                          Size ));
06189 
06190         <a class="code" href="../../d9/d9/heappriv_8h.html#a11">HeapDebugBreak</a>( BusyBlock );
06191 
06192         <span class="comment">//</span>
06193         <span class="comment">//  And tell our caller there was an error</span>
06194         <span class="comment">//</span>
06195 
06196         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
06197 
06198     } <span class="keywordflow">else</span> {
06199 
06200         <span class="comment">//</span>
06201         <span class="comment">//  And return to our caller that the tail is fine</span>
06202         <span class="comment">//</span>
06203 
06204         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
06205     }
06206 }
}
</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a25" doxytag="rtl/heap.c::RtlpCoalesceFreeBlocks" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a> RtlpCoalesceFreeBlocks           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d5/d5/struct__HEAP.html">PHEAP</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>Heap</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>FreeBlock</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN OUT PSIZE_T&nbsp;</td>
          <td class="mdname" nowrap> <em>FreeSize</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN BOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>RemoveFromFreeList</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l05312">5312</a> of file <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html">rtl/heap.c</a>.
<p>
References <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00200">_HEAP_FREE_ENTRY::Flags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00236">HEAP_ENTRY_BUSY</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00240">HEAP_ENTRY_LAST_ENTRY</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00231">HEAP_MAXIMUM_BLOCK_SIZE</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00039">HEAPASSERT</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00277">_HEAP_SEGMENT::LastEntryInSegment</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00182">_HEAP_FREE_ENTRY::PreviousSize</a>, <a class="el" href="../../d6/d8/ntrtlp_8h-source.html#l00246">RTL_PAGED_CODE</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00465">RtlpRemoveFreeBlock</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00189">_HEAP_FREE_ENTRY::SegmentIndex</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00174">_HEAP_FREE_ENTRY::Size</a>, and <a class="el" href="../../d5/d4/aug98_2dll32_2icc__i386_8h-source.html#l00064">USHORT</a>.
<p>
Referenced by <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l02931">RtlFreeHeap()</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l03273">RtlFreeHeapSlowly()</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l04312">RtlpCoalesceHeap()</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l05024">RtlpExtendHeap()</a>, and <a class="el" href="../../d6/d8/heapdll_8c-source.html#l04693">RtlpGrowBlockInPlace()</a>.
<p>
<pre class="fragment"><div>05321                    :
05322 
05323     This routine coalesces <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> free block together.
05324 
05325 Arguments:
05326 
05327     Heap - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap being manipulated
05328 
05329     FreeBlock - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> free block that we want coalesced
05330 
05331     FreeSize - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> size, in bytes, of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> free block.  On <span class="keywordflow">return</span> <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a>
05332         contains <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> size, in bytes, of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> newly coalesced free block
05333 
05334     RemoveFromFreeList - Indicates <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> input free block <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> already on a
05335         free list and needs to be removed to before coalescing
05336 
05337 Return Value:
05338 
05339     <a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a> - returns a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> newly coalesced free block
05340 
05341 --*/
05342 
05343 {
05344     <a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a> FreeBlock1, NextFreeBlock;
05345 
05346     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
05347 
05348     <span class="comment">//</span>
05349     <span class="comment">//  Point to the preceding block</span>
05350     <span class="comment">//</span>
05351 
05352     FreeBlock1 = (<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a>)((<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)FreeBlock - FreeBlock-&gt;PreviousSize);
05353 
05354     <span class="comment">//</span>
05355     <span class="comment">//  Check if there is a preceding block, and if it is free, and the two sizes</span>
05356     <span class="comment">//  put together will still fit on a free lists.</span>
05357     <span class="comment">//</span>
05358 
05359     <span class="keywordflow">if</span> ((FreeBlock1 != FreeBlock) &amp;&amp;
05360         !(FreeBlock1-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a8">HEAP_ENTRY_BUSY</a>) &amp;&amp;
05361         ((*FreeSize + FreeBlock1-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o0">Size</a>) &lt;= <a class="code" href="../../d3/d9/heap_8h.html#a5">HEAP_MAXIMUM_BLOCK_SIZE</a>)) {
05362 
05363         <span class="comment">//</span>
05364         <span class="comment">//  We are going to merge ourselves with the preceding block</span>
05365         <span class="comment">//</span>
05366 
05367         <a class="code" href="../../d9/d9/heappriv_8h.html#a0">HEAPASSERT</a>(FreeBlock-&gt;PreviousSize == FreeBlock1-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o0">Size</a>);
05368 
05369         <span class="comment">//</span>
05370         <span class="comment">//  Check if we need to remove the input block from the free list</span>
05371         <span class="comment">//</span>
05372 
05373         <span class="keywordflow">if</span> (RemoveFromFreeList) {
05374 
05375             <a class="code" href="../../d9/d9/heappriv_8h.html#a18">RtlpRemoveFreeBlock</a>( Heap, FreeBlock );
05376 
05377             Heap-&gt;TotalFreeSize -= FreeBlock-&gt;Size;
05378 
05379             <span class="comment">//</span>
05380             <span class="comment">//  We're removed so we don't have to do it again</span>
05381             <span class="comment">//</span>
05382 
05383             RemoveFromFreeList = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
05384         }
05385 
05386         <span class="comment">//</span>
05387         <span class="comment">//  Remove the preceding block from its free list</span>
05388         <span class="comment">//</span>
05389 
05390         <a class="code" href="../../d9/d9/heappriv_8h.html#a18">RtlpRemoveFreeBlock</a>( Heap, FreeBlock1 );
05391 
05392         <span class="comment">//</span>
05393         <span class="comment">//  Copy over the last entry flag if necessary from what we're freeing</span>
05394         <span class="comment">//  to the preceding block</span>
05395         <span class="comment">//</span>
05396 
05397         FreeBlock1-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o3">Flags</a> = FreeBlock-&gt;Flags &amp; <a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>;
05398 
05399         <span class="keywordflow">if</span>( FreeBlock1-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a> ) {
05400 
05401             <a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html">PHEAP_SEGMENT</a> Segment;
05402 
05403             Segment = Heap-&gt;Segments[FreeBlock1-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o2">SegmentIndex</a>];
05404             Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o14">LastEntryInSegment</a> = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)FreeBlock1;
05405         }
05406 
05407         <span class="comment">//</span>
05408         <span class="comment">//  Point to the preceding block, and adjust the sizes for the</span>
05409         <span class="comment">//  new free block.  It is the total of both blocks.</span>
05410         <span class="comment">//</span>
05411 
05412         FreeBlock = FreeBlock1;
05413 
05414         *FreeSize += FreeBlock1-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o0">Size</a>;
05415 
05416         Heap-&gt;TotalFreeSize -= FreeBlock1-&gt;Size;
05417 
05418         FreeBlock-&gt;Size = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)*FreeSize;
05419 
05420         <span class="comment">//</span>
05421         <span class="comment">//  Check if we need to update the previous size of the next</span>
05422         <span class="comment">//  entry</span>
05423         <span class="comment">//</span>
05424 
05425         <span class="keywordflow">if</span> (!(FreeBlock-&gt;Flags &amp; <a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>)) {
05426 
05427             ((<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)FreeBlock + *FreeSize)-&gt;PreviousSize = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)*FreeSize;
05428         }
05429     }
05430 
05431     <span class="comment">//</span>
05432     <span class="comment">//  Check if there is a following block.</span>
05433     <span class="comment">//</span>
05434 
05435     <span class="keywordflow">if</span> (!(FreeBlock-&gt;Flags &amp; <a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>)) {
05436 
05437         <span class="comment">//</span>
05438         <span class="comment">//  There is a following block so now get a pointer to it</span>
05439         <span class="comment">//  and check if it is free and if putting the two blocks together</span>
05440         <span class="comment">//  still fits on a free list</span>
05441         <span class="comment">//</span>
05442 
05443         NextFreeBlock = (<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a>)((<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)FreeBlock + *FreeSize);
05444 
05445         <span class="keywordflow">if</span> (!(NextFreeBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a8">HEAP_ENTRY_BUSY</a>) &amp;&amp;
05446             ((*FreeSize + NextFreeBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o0">Size</a>) &lt;= <a class="code" href="../../d3/d9/heap_8h.html#a5">HEAP_MAXIMUM_BLOCK_SIZE</a>)) {
05447 
05448             <span class="comment">//</span>
05449             <span class="comment">//  We are going to merge ourselves with the following block</span>
05450             <span class="comment">//</span>
05451 
05452             <a class="code" href="../../d9/d9/heappriv_8h.html#a0">HEAPASSERT</a>(*FreeSize == NextFreeBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o1">PreviousSize</a>);
05453 
05454             <span class="comment">//</span>
05455             <span class="comment">//  Check if we need to remove the input block from the free list</span>
05456             <span class="comment">//</span>
05457 
05458             <span class="keywordflow">if</span> (RemoveFromFreeList) {
05459 
05460                 <a class="code" href="../../d9/d9/heappriv_8h.html#a18">RtlpRemoveFreeBlock</a>( Heap, FreeBlock );
05461 
05462                 Heap-&gt;TotalFreeSize -= FreeBlock-&gt;Size;
05463 
05464                 <span class="comment">//</span>
05465                 <span class="comment">//  **** this assignment isn't necessary because there isn't</span>
05466                 <span class="comment">//  **** any more merging after this one</span>
05467                 <span class="comment">//</span>
05468 
05469                 RemoveFromFreeList = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
05470             }
05471 
05472             <span class="comment">//</span>
05473             <span class="comment">//  Copy up the last entry flag if necessary from the following</span>
05474             <span class="comment">//  block to our input block</span>
05475             <span class="comment">//</span>
05476 
05477             FreeBlock-&gt;Flags = NextFreeBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>;
05478 
05479             <span class="keywordflow">if</span>( FreeBlock-&gt;Flags &amp; <a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a> ) {
05480 
05481                 <a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html">PHEAP_SEGMENT</a> Segment;
05482 
05483                 Segment = Heap-&gt;Segments[FreeBlock-&gt;SegmentIndex];
05484                 Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o14">LastEntryInSegment</a> = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)FreeBlock;
05485             }
05486 
05487             <span class="comment">//</span>
05488             <span class="comment">//  Remove the following block from its free list</span>
05489             <span class="comment">//</span>
05490 
05491             <a class="code" href="../../d9/d9/heappriv_8h.html#a18">RtlpRemoveFreeBlock</a>( Heap, NextFreeBlock );
05492 
05493             <span class="comment">//</span>
05494             <span class="comment">//  Adjust the size for the newly combined block</span>
05495             <span class="comment">//</span>
05496 
05497             *FreeSize += NextFreeBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o0">Size</a>;
05498 
05499             Heap-&gt;TotalFreeSize -= NextFreeBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o0">Size</a>;
05500 
05501             FreeBlock-&gt;Size = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)*FreeSize;
05502 
05503             <span class="comment">//</span>
05504             <span class="comment">//  Check if we need to update the previous size of the next block</span>
05505             <span class="comment">//</span>
05506 
05507             <span class="keywordflow">if</span> (!(FreeBlock-&gt;Flags &amp; <a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>)) {
05508 
05509                 ((<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)FreeBlock + *FreeSize)-&gt;PreviousSize = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)*FreeSize;
05510             }
05511         }
05512     }
05513 
05514     <span class="comment">//</span>
05515     <span class="comment">//  And return the free block to our caller</span>
05516     <span class="comment">//</span>
05517 
05518     <span class="keywordflow">return</span> FreeBlock;
05519 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a10" doxytag="rtl/heap.c::RtlpCreateUnCommittedRange" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html">PHEAP_UNCOMMMTTED_RANGE</a> RtlpCreateUnCommittedRange           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d8/d6/struct__HEAP__SEGMENT.html">PHEAP_SEGMENT</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>Segment</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l03962">3962</a> of file <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html">rtl/heap.c</a>.
<p>
References <a class="el" href="../../d4/d8/heap_8h-source.html#l00297">_HEAP_UCR_SEGMENT::CommittedSize</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00253">_HEAP_UNCOMMMTTED_RANGE::Next</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00295">_HEAP_UCR_SEGMENT::Next</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00599">PAGE_SIZE</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00296">_HEAP_UCR_SEGMENT::ReservedSize</a>, <a class="el" href="../../d6/d8/ntrtlp_8h-source.html#l00246">RTL_PAGED_CODE</a>, and <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>.
<p>
Referenced by <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l05527">RtlpDeCommitFreeBlock()</a>, and <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l04227">RtlpInsertUnCommittedPages()</a>.
<p>
<pre class="fragment"><div>03968                    :
03969 
03970     This routine add a <span class="keyword">new</span> uncommitted range structure to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified heap
03971     segment.  This routine works by essentially doing a pop of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> stack of
03972     unused uncommitted range structures located off <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap structure.  If
03973     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> stack <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> empty then we'll create some more before doing <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> pop.
03974 
03975 Arguments:
03976 
03977     Segment - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap segment being modified
03978 
03979 Return Value:
03980 
03981     PHEAP_UNCOMMITTED_RANGE - returns a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> newly created
03982         uncommitted range structure
03983 
03984 --*/
03985 
03986 {
03987     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
03988     PVOID FirstEntry, LastEntry;
03989     <a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html">PHEAP_UNCOMMMTTED_RANGE</a> UnCommittedRange, *pp;
03990     SIZE_T ReserveSize, CommitSize;
03991     <a class="code" href="../../d4/d7/struct__HEAP__UCR__SEGMENT.html">PHEAP_UCR_SEGMENT</a> UCRSegment;
03992 
03993     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
03994 
03995     <span class="comment">//</span>
03996     <span class="comment">//  Get a pointer to the unused uncommitted range structures for</span>
03997     <span class="comment">//  the specified heap</span>
03998     <span class="comment">//</span>
03999 
04000     pp = &amp;Segment-&gt;Heap-&gt;UnusedUnCommittedRanges;
04001 
04002     <span class="comment">//</span>
04003     <span class="comment">//  If the list is null then we need to allocate some more to</span>
04004     <span class="comment">//  put on the list</span>
04005     <span class="comment">//</span>
04006 
04007     <span class="keywordflow">if</span> (*pp == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
04008 
04009         <span class="comment">//</span>
04010         <span class="comment">//  Get the next uncommitted range segment from the heap</span>
04011         <span class="comment">//</span>
04012 
04013         UCRSegment = Segment-&gt;Heap-&gt;UCRSegments;
04014 
04015         <span class="comment">//</span>
04016         <span class="comment">//  If there are no more uncommitted range segments or</span>
04017         <span class="comment">//  the segemtns commited and reserved sizes are equal (meaning</span>
04018         <span class="comment">//  it's all used up) then we need to allocate another uncommitted</span>
04019         <span class="comment">//  range segment</span>
04020         <span class="comment">//</span>
04021 
04022         <span class="keywordflow">if</span> ((UCRSegment == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) ||
04023             (UCRSegment-&gt;<a class="code" href="../../d4/d7/struct__HEAP__UCR__SEGMENT.html#o2">CommittedSize</a> == UCRSegment-&gt;<a class="code" href="../../d4/d7/struct__HEAP__UCR__SEGMENT.html#o1">ReservedSize</a>)) {
04024 
04025             <span class="comment">//</span>
04026             <span class="comment">//  We'll reserve 16 pages of memory and commit at this</span>
04027             <span class="comment">//  time one page of it.</span>
04028             <span class="comment">//</span>
04029 
04030             ReserveSize = <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> * 16;
04031             UCRSegment = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04032 
04033             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwAllocateVirtualMemory( NtCurrentProcess(),
04034                                               &amp;UCRSegment,
04035                                               0,
04036                                               &amp;ReserveSize,
04037                                               MEM_RESERVE,
04038                                               PAGE_READWRITE );
04039 
04040             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
04041 
04042                 <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04043             }
04044 
04045             CommitSize = <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
04046 
04047             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwAllocateVirtualMemory( NtCurrentProcess(),
04048                                               &amp;UCRSegment,
04049                                               0,
04050                                               &amp;CommitSize,
04051                                               MEM_COMMIT,
04052                                               PAGE_READWRITE );
04053 
04054             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
04055 
04056                 ZwFreeVirtualMemory( NtCurrentProcess(),
04057                                      &amp;UCRSegment,
04058                                      &amp;ReserveSize,
04059                                      MEM_RELEASE );
04060 
04061                 <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04062             }
04063 
04064             <span class="comment">//</span>
04065             <span class="comment">//  Add this new segment to the front of the UCR segments</span>
04066             <span class="comment">//</span>
04067 
04068             UCRSegment-&gt;<a class="code" href="../../d4/d7/struct__HEAP__UCR__SEGMENT.html#o0">Next</a> = Segment-&gt;Heap-&gt;UCRSegments;
04069             Segment-&gt;Heap-&gt;UCRSegments = UCRSegment;
04070 
04071             <span class="comment">//</span>
04072             <span class="comment">//  Set the segments commit and reserve size</span>
04073             <span class="comment">//</span>
04074 
04075             UCRSegment-&gt;<a class="code" href="../../d4/d7/struct__HEAP__UCR__SEGMENT.html#o1">ReservedSize</a> = ReserveSize;
04076             UCRSegment-&gt;<a class="code" href="../../d4/d7/struct__HEAP__UCR__SEGMENT.html#o2">CommittedSize</a> = CommitSize;
04077 
04078             <span class="comment">//</span>
04079             <span class="comment">//  Point to the first free spot in the segment</span>
04080             <span class="comment">//</span>
04081 
04082             FirstEntry = (PCHAR)(UCRSegment + 1);
04083 
04084         } <span class="keywordflow">else</span> {
04085 
04086             <span class="comment">//</span>
04087             <span class="comment">//  We have an existing UCR segment with available space</span>
04088             <span class="comment">//  So now try and commit another PAGE_SIZE bytes.  When we are done</span>
04089             <span class="comment">//  FirstEntry will point to the newly committed space</span>
04090             <span class="comment">//</span>
04091 
04092             CommitSize = <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
04093             FirstEntry = (PCHAR)UCRSegment + UCRSegment-&gt;<a class="code" href="../../d4/d7/struct__HEAP__UCR__SEGMENT.html#o2">CommittedSize</a>;
04094 
04095             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwAllocateVirtualMemory( NtCurrentProcess(),
04096                                               &amp;FirstEntry,
04097                                               0,
04098                                               &amp;CommitSize,
04099                                               MEM_COMMIT,
04100                                               PAGE_READWRITE );
04101 
04102             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
04103 
04104                 <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04105             }
04106 
04107             <span class="comment">//</span>
04108             <span class="comment">//  And update the amount committed in the segment</span>
04109             <span class="comment">//</span>
04110 
04111             UCRSegment-&gt;<a class="code" href="../../d4/d7/struct__HEAP__UCR__SEGMENT.html#o2">CommittedSize</a> += CommitSize;
04112         }
04113 
04114         <span class="comment">//</span>
04115         <span class="comment">//  At this point UCR segment exists and First Entry points to the</span>
04116         <span class="comment">//  start of the available committed space.  We'll make Last Entry</span>
04117         <span class="comment">//  point to the end of the committed space</span>
04118         <span class="comment">//</span>
04119 
04120         LastEntry = (PCHAR)UCRSegment + UCRSegment-&gt;<a class="code" href="../../d4/d7/struct__HEAP__UCR__SEGMENT.html#o2">CommittedSize</a>;
04121 
04122         <span class="comment">//</span>
04123         <span class="comment">//  Now the task is to push all of this new space unto the</span>
04124         <span class="comment">//  unused uncommitted range list off the heap, then we can</span>
04125         <span class="comment">//  do a regular pop</span>
04126         <span class="comment">//</span>
04127 
04128         UnCommittedRange = (<a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html">PHEAP_UNCOMMMTTED_RANGE</a>)FirstEntry;
04129 
04130         pp = &amp;Segment-&gt;Heap-&gt;UnusedUnCommittedRanges;
04131 
04132         <span class="keywordflow">while</span> ((PCHAR)UnCommittedRange &lt; (PCHAR)LastEntry) {
04133 
04134             *pp = UnCommittedRange;
04135             pp = &amp;UnCommittedRange-&gt;<a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html#o0">Next</a>;
04136             UnCommittedRange += 1;
04137         }
04138 
04139         <span class="comment">//</span>
04140         <span class="comment">//  Null terminate the list</span>
04141         <span class="comment">//</span>
04142 
04143         *pp = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04144 
04145         <span class="comment">//</span>
04146         <span class="comment">//  And have Pp point the new top of the list</span>
04147         <span class="comment">//</span>
04148 
04149         pp = &amp;Segment-&gt;Heap-&gt;UnusedUnCommittedRanges;
04150     }
04151 
04152     <span class="comment">//</span>
04153     <span class="comment">//  At this point the Pp points to a non empty list of unused uncommitted</span>
04154     <span class="comment">//  range structures.  So we pop the list and return the top to our caller</span>
04155     <span class="comment">//</span>
04156 
04157     UnCommittedRange = *pp;
04158     *pp = UnCommittedRange-&gt;<a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html#o0">Next</a>;
04159 
04160     <span class="keywordflow">return</span> UnCommittedRange;
04161 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a26" doxytag="rtl/heap.c::RtlpDeCommitFreeBlock" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID RtlpDeCommitFreeBlock           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d5/d5/struct__HEAP.html">PHEAP</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>Heap</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>FreeBlock</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN SIZE_T&nbsp;</td>
          <td class="mdname" nowrap> <em>FreeSize</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l05527">5527</a> of file <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html">rtl/heap.c</a>.
<p>
References <a class="el" href="../../d4/d8/heap_8h-source.html#l00260">_HEAP_SEGMENT::Entry</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00269">_HEAP_SEGMENT::FirstEntry</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00200">_HEAP_FREE_ENTRY::Flags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00076">_HEAP_ENTRY::Flags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00240">HEAP_ENTRY_LAST_ENTRY</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00228">HEAP_GRANULARITY_SHIFT</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00121">HeapDebugPrint</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00277">_HEAP_SEGMENT::LastEntryInSegment</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00272">_HEAP_SEGMENT::NumberOfUnCommittedPages</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00599">PAGE_SIZE</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00182">_HEAP_FREE_ENTRY::PreviousSize</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00053">_HEAP_ENTRY::PreviousSize</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00031">ROUND_DOWN_TO_POWER2</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00030">ROUND_UP_TO_POWER2</a>, <a class="el" href="../../d6/d8/ntrtlp_8h-source.html#l00246">RTL_PAGED_CODE</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l03962">RtlpCreateUnCommittedRange()</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l04169">RtlpDestroyUnCommittedRange()</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l05849">RtlpInsertFreeBlock()</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00322">RtlpInsertFreeBlockDirect</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l04227">RtlpInsertUnCommittedPages()</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00060">_HEAP_ENTRY::SegmentIndex</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00174">_HEAP_FREE_ENTRY::Size</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, and <a class="el" href="../../d5/d4/aug98_2dll32_2icc__i386_8h-source.html#l00064">USHORT</a>.
<p>
Referenced by <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l02931">RtlFreeHeap()</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l03273">RtlFreeHeapSlowly()</a>, and <a class="el" href="../../d6/d8/heapdll_8c-source.html#l04312">RtlpCoalesceHeap()</a>.
<p>
<pre class="fragment"><div>05535                    :
05536 
05537     This routine takes a free block and decommits <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a>.  This <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> usually called
05538     because <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> block <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> beyond <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> decommit threshold
05539 
05540 Arguments:
05541 
05542     Heap - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap being manipulated
05543 
05544     FreeBlock - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> block being decommitted
05545 
05546     FreeSize - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> size, in bytes, of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> free block being decommitted
05547 
05548 Return Value:
05549 
05550     None.
05551 
05552 --*/
05553 
05554 {
05555     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
05556     ULONG_PTR DeCommitAddress;
05557     SIZE_T DeCommitSize;
05558     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> LeadingFreeSize, TrailingFreeSize;
05559     <a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html">PHEAP_SEGMENT</a> Segment;
05560     <a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a> LeadingFreeBlock, TrailingFreeBlock;
05561     <a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a> LeadingBusyBlock, TrailingBusyBlock;
05562     <a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html">PHEAP_UNCOMMMTTED_RANGE</a> UnCommittedRange;
05563 
05564     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
05565 
05566     <span class="comment">//</span>
05567     <span class="comment">//  If the heap has a user specified decommit routine then we won't really</span>
05568     <span class="comment">//  decommit anything instead we'll call a worker routine to chop it up</span>
05569     <span class="comment">//  into pieces that will fit on the free lists</span>
05570     <span class="comment">//</span>
05571 
05572     <span class="keywordflow">if</span> (Heap-&gt;CommitRoutine != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05573 
05574         <a class="code" href="../../d9/d9/heappriv_8h.html#a36">RtlpInsertFreeBlock</a>( Heap, FreeBlock, FreeSize );
05575 
05576         <span class="keywordflow">return</span>;
05577     }
05578 
05579     <span class="comment">//</span>
05580     <span class="comment">//  Get a pointer to the owning segment</span>
05581     <span class="comment">//</span>
05582 
05583     Segment = Heap-&gt;Segments[ FreeBlock-&gt;SegmentIndex ];
05584 
05585     <span class="comment">//</span>
05586     <span class="comment">//  The leading busy block identifies the preceding in use block before</span>
05587     <span class="comment">//  what we are trying to decommit.  It is only used if what we are trying</span>
05588     <span class="comment">//  decommit is right on a page boundary and then it is the block right</span>
05589     <span class="comment">//  before us if it exists.</span>
05590     <span class="comment">//</span>
05591     <span class="comment">//  The leading free block is used to identify whatever space is needed</span>
05592     <span class="comment">//  to round up the callers specified address to a page address.  If the</span>
05593     <span class="comment">//  caller already gave us a page aligned address then the free block</span>
05594     <span class="comment">//  address is identical to what the caller supplied.</span>
05595     <span class="comment">//</span>
05596 
05597     LeadingBusyBlock = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
05598     LeadingFreeBlock = FreeBlock;
05599 
05600     <span class="comment">//</span>
05601     <span class="comment">//  Make sure the block we are trying to decommit start on the next full</span>
05602     <span class="comment">//  page boundary.  The leading free size is the size of whatever it takes</span>
05603     <span class="comment">//  to round up the free block to the next page specified in units of</span>
05604     <span class="comment">//  heap entries.</span>
05605     <span class="comment">//</span>
05606 
05607     DeCommitAddress = <a class="code" href="../../d3/d9/heap_8h.html#a1">ROUND_UP_TO_POWER2</a>( LeadingFreeBlock, PAGE_SIZE );
05608     LeadingFreeSize = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)((<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)DeCommitAddress - (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)LeadingFreeBlock);
05609 
05610     <span class="comment">//</span>
05611     <span class="comment">//  If we leading free size only has space for one heap entry then we'll</span>
05612     <span class="comment">//  bump it up to include the next page, because we don't want to leave</span>
05613     <span class="comment">//  anything that small laying around.  Otherwise if we have a preceding</span>
05614     <span class="comment">//  block and the leading free size is zero then identify the preceding</span>
05615     <span class="comment">//  block as the leading busy block</span>
05616     <span class="comment">//</span>
05617 
05618     <span class="keywordflow">if</span> (LeadingFreeSize == 1) {
05619 
05620         DeCommitAddress += <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
05621         LeadingFreeSize += <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> &gt;&gt; <a class="code" href="../../d3/d9/heap_8h.html#a4">HEAP_GRANULARITY_SHIFT</a>;
05622 
05623     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (LeadingFreeBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o1">PreviousSize</a> != 0) {
05624 
05625         <span class="keywordflow">if</span> (DeCommitAddress == (ULONG_PTR)LeadingFreeBlock) {
05626 
05627             LeadingBusyBlock = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)LeadingFreeBlock - LeadingFreeBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o1">PreviousSize</a>;
05628         }
05629     }
05630 
05631     <span class="comment">//</span>
05632     <span class="comment">//  The trailing busy block identifies the block immediately after the one</span>
05633     <span class="comment">//  we are trying to decommit provided what we are decommitting ends right</span>
05634     <span class="comment">//  on a page boundary otherwise the trailing busy block stays null and</span>
05635     <span class="comment">//  the trailing free block value is used.</span>
05636     <span class="comment">//</span>
05637     <span class="comment">//  **** gdk ****</span>
05638     <span class="comment">//  **** the assignment of tailing free block doesn't seem right because</span>
05639     <span class="comment">//  **** Free size should be in bytes, and not heap entries</span>
05640     <span class="comment">//</span>
05641 
05642     TrailingBusyBlock = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
05643     TrailingFreeBlock = (<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a>)((<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)FreeBlock + FreeSize);
05644 
05645     <span class="comment">//</span>
05646     <span class="comment">//  Make sure the block we are trying to decommit ends on a page boundary.</span>
05647     <span class="comment">//</span>
05648     <span class="comment">//  And compute how many heap entries we had to backup to make it land on a</span>
05649     <span class="comment">//  page boundary.</span>
05650     <span class="comment">//</span>
05651 
05652     DeCommitSize = <a class="code" href="../../d3/d9/heap_8h.html#a2">ROUND_DOWN_TO_POWER2</a>( (ULONG_PTR)TrailingFreeBlock, PAGE_SIZE );
05653     TrailingFreeSize = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)((<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)TrailingFreeBlock - (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)DeCommitSize);
05654 
05655     <span class="comment">//</span>
05656     <span class="comment">//  If the trailing free size is exactly one heap in size then we will</span>
05657     <span class="comment">//  nibble off a bit more from the decommit size because free block of</span>
05658     <span class="comment">//  exactly one heap entry in size are useless.  Otherwise if we actually</span>
05659     <span class="comment">//  ended on a page boundary and there is a block after us then indicate</span>
05660     <span class="comment">//  that we have a trailing busy block</span>
05661     <span class="comment">//</span>
05662 
05663     <span class="keywordflow">if</span> (TrailingFreeSize == (<span class="keyword">sizeof</span>( <a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">HEAP_ENTRY</a> ) &gt;&gt; <a class="code" href="../../d3/d9/heap_8h.html#a4">HEAP_GRANULARITY_SHIFT</a>)) {
05664 
05665         DeCommitSize -= <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
05666         TrailingFreeSize += <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> &gt;&gt; <a class="code" href="../../d3/d9/heap_8h.html#a4">HEAP_GRANULARITY_SHIFT</a>;
05667 
05668     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((TrailingFreeSize == 0) &amp;&amp; !(FreeBlock-&gt;Flags &amp; <a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>)) {
05669 
05670         TrailingBusyBlock = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)TrailingFreeBlock;
05671     }
05672 
05673     <span class="comment">//</span>
05674     <span class="comment">//  Now adjust the trailing free block to compensate for the trailing free size</span>
05675     <span class="comment">//  we just computed.</span>
05676     <span class="comment">//</span>
05677 
05678     TrailingFreeBlock = (<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a>)((<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)TrailingFreeBlock - TrailingFreeSize);
05679 
05680     <span class="comment">//</span>
05681     <span class="comment">//  Right now DeCommit size is really a pointer.  If it points at is beyond</span>
05682     <span class="comment">//  the decommit address then make the size really be just the byte count</span>
05683     <span class="comment">//  to decommit.  Otherwise the decommit size is zero.</span>
05684     <span class="comment">//</span>
05685 
05686     <span class="keywordflow">if</span> (DeCommitSize &gt; DeCommitAddress) {
05687 
05688         DeCommitSize -= DeCommitAddress;
05689 
05690     } <span class="keywordflow">else</span> {
05691 
05692         DeCommitSize = 0;
05693     }
05694 
05695     <span class="comment">//</span>
05696     <span class="comment">//  **** this next test is bogus given the if-then-else that just preceded it</span>
05697     <span class="comment">//</span>
05698     <span class="comment">//  Now check if we still have something to decommit</span>
05699     <span class="comment">//</span>
05700 
05701     <span class="keywordflow">if</span> (DeCommitSize != 0) {
05702 
05703         <span class="comment">//</span>
05704         <span class="comment">//  Before freeing the memory to MM we have to be sure we can create </span>
05705         <span class="comment">//  a PHEAP_UNCOMMMTTED_RANGE later. So we do it right now</span>
05706         <span class="comment">//</span>
05707 
05708         UnCommittedRange = <a class="code" href="../../d1/d9/rtl_2heap_8c.html#a10">RtlpCreateUnCommittedRange</a>(Segment);
05709 
05710         <span class="keywordflow">if</span> (UnCommittedRange == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05711             
05712             <a class="code" href="../../d9/d9/heappriv_8h.html#a10">HeapDebugPrint</a>(( <span class="stringliteral">"Failing creating uncommitted range (%x for %x)\n"</span>, DeCommitAddress, DeCommitSize ));
05713 
05714             <span class="comment">//</span>
05715             <span class="comment">//  We weren't successful in the decommit so now simply</span>
05716             <span class="comment">//  add the leading free block to the free list</span>
05717             <span class="comment">//</span>
05718 
05719             <a class="code" href="../../d9/d9/heappriv_8h.html#a36">RtlpInsertFreeBlock</a>( Heap, LeadingFreeBlock, FreeSize );
05720 
05721             <span class="keywordflow">return</span>;
05722         }
05723 
05724         <span class="comment">//</span>
05725         <span class="comment">//  Decommit the memory</span>
05726         <span class="comment">//</span>
05727 
05728         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwFreeVirtualMemory( NtCurrentProcess(),
05729                                       (PVOID *)&amp;DeCommitAddress,
05730                                       &amp;DeCommitSize,
05731                                       MEM_DECOMMIT );
05732 
05733         <span class="comment">//</span>
05734         <span class="comment">//  Push back the UnCommittedRange structure. Now the insert cannot fail</span>
05735         <span class="comment">//</span>
05736 
05737         <a class="code" href="../../d1/d9/rtl_2heap_8c.html#a11">RtlpDestroyUnCommittedRange</a>( Segment, UnCommittedRange );
05738 
05739         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
05740 
05741             <span class="comment">//</span>
05742             <span class="comment">//  Insert information regarding the pages we just decommitted</span>
05743             <span class="comment">//  to the lsit of uncommited pages in the segment</span>
05744             <span class="comment">//</span>
05745 
05746             <a class="code" href="../../d1/d9/rtl_2heap_8c.html#a12">RtlpInsertUnCommittedPages</a>( Segment,
05747                                         DeCommitAddress,
05748                                         DeCommitSize );
05749             <span class="comment">//</span>
05750             <span class="comment">//  Adjust the segments count of uncommitted pages</span>
05751             <span class="comment">//</span>
05752 
05753             Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o9">NumberOfUnCommittedPages</a> += (ULONG)(DeCommitSize / <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
05754 
05755             <span class="comment">//</span>
05756             <span class="comment">//  If we have a leading free block then mark its proper state</span>
05757             <span class="comment">//  update the heap, and put it on the free list</span>
05758             <span class="comment">//</span>
05759 
05760             <span class="keywordflow">if</span> (LeadingFreeSize != 0) {
05761 
05762                 LeadingFreeBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o3">Flags</a> = <a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>;
05763                 LeadingFreeBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o0">Size</a> = LeadingFreeSize;
05764                 Heap-&gt;TotalFreeSize += LeadingFreeSize;
05765 
05766                 Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o14">LastEntryInSegment</a> = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)LeadingFreeBlock;
05767 
05768                 <a class="code" href="../../d9/d9/heappriv_8h.html#a14">RtlpInsertFreeBlockDirect</a>( Heap, LeadingFreeBlock, LeadingFreeSize );
05769 
05770             <span class="comment">//</span>
05771             <span class="comment">//  Otherwise if we actually have a leading busy block then</span>
05772             <span class="comment">//  make sure the busy block knows we're uncommitted</span>
05773             <span class="comment">//</span>
05774 
05775             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (LeadingBusyBlock != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05776 
05777                 LeadingBusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> |= <a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>;
05778 
05779                 Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o14">LastEntryInSegment</a> = LeadingBusyBlock;
05780 
05781             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o14">LastEntryInSegment</a> &gt;= (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)DeCommitAddress)
05782                             &amp;&amp;
05783                        ((PCHAR)Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o14">LastEntryInSegment</a> &lt; ((PCHAR)DeCommitAddress + DeCommitSize))) {
05784 
05785                      Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o14">LastEntryInSegment</a> = Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o7">FirstEntry</a>;
05786             }
05787 
05788             <span class="comment">//</span>
05789             <span class="comment">//  If there is a trailing free block then sets its state,</span>
05790             <span class="comment">//  update the heap, and insert it on a free list</span>
05791             <span class="comment">//</span>
05792 
05793             <span class="keywordflow">if</span> (TrailingFreeSize != 0) {
05794 
05795                 TrailingFreeBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o1">PreviousSize</a> = 0;
05796                 TrailingFreeBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o2">SegmentIndex</a> = Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o0">Entry</a>.<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o2">SegmentIndex</a>;
05797                 TrailingFreeBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o3">Flags</a> = 0;
05798                 TrailingFreeBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o0">Size</a> = TrailingFreeSize;
05799 
05800                 ((<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a>)((<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)TrailingFreeBlock + TrailingFreeSize))-&gt;PreviousSize = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)TrailingFreeSize;
05801 
05802                 <a class="code" href="../../d9/d9/heappriv_8h.html#a14">RtlpInsertFreeBlockDirect</a>( Heap, TrailingFreeBlock, TrailingFreeSize );
05803 
05804                 Heap-&gt;TotalFreeSize += TrailingFreeSize;
05805 
05806             <span class="comment">//</span>
05807             <span class="comment">//  Otherwise if we actually have a succeeding block then</span>
05808             <span class="comment">//  make it know we are uncommitted</span>
05809             <span class="comment">//</span>
05810 
05811             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (TrailingBusyBlock != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05812 
05813                 TrailingBusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o1">PreviousSize</a> = 0;
05814             }
05815 
05816         } <span class="keywordflow">else</span> {
05817 
05818             <span class="comment">//</span>
05819             <span class="comment">//  We weren't successful in the decommit so now simply</span>
05820             <span class="comment">//  add the leading free block to the free list</span>
05821             <span class="comment">//</span>
05822 
05823             <a class="code" href="../../d9/d9/heappriv_8h.html#a36">RtlpInsertFreeBlock</a>( Heap, LeadingFreeBlock, FreeSize );
05824         }
05825 
05826     } <span class="keywordflow">else</span> {
05827 
05828         <span class="comment">//</span>
05829         <span class="comment">//  There is nothing left to decommit to take our leading free block</span>
05830         <span class="comment">//  and put it on a free list</span>
05831         <span class="comment">//</span>
05832 
05833         <a class="code" href="../../d9/d9/heappriv_8h.html#a36">RtlpInsertFreeBlock</a>( Heap, LeadingFreeBlock, FreeSize );
05834     }
05835 
05836     <span class="comment">//</span>
05837     <span class="comment">//  And return to our caller</span>
05838     <span class="comment">//</span>
05839 
05840     <span class="keywordflow">return</span>;
05841 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a13" doxytag="rtl/heap.c::RtlpDestroyHeapSegment" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS RtlpDestroyHeapSegment           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d8/d6/struct__HEAP__SEGMENT.html">PHEAP_SEGMENT</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>Segment</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l04959">4959</a> of file <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html">rtl/heap.c</a>.
<p>
References <a class="el" href="../../d4/d8/heap_8h-source.html#l00281">HEAP_SEGMENT_USER_ALLOCATED</a>, and <a class="el" href="../../d6/d8/ntrtlp_8h-source.html#l00246">RTL_PAGED_CODE</a>.
<p>
Referenced by <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l01133">RtlDestroyHeap()</a>.
<p>
<pre class="fragment"><div>04965                    :
04966 
04967     This routine removes an existing heap segment.  After <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> call <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a>
04968     <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> as <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> segment never existed
04969 
04970 Arguments:
04971 
04972     Segment - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap segment being destroyed
04973 
04974 Return Value:
04975 
04976     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> - An appropriate status value
04977 
04978 --*/
04979 
04980 {
04981     PVOID BaseAddress;
04982     SIZE_T BytesToFree;
04983 
04984     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
04985 
04986     <span class="comment">//</span>
04987     <span class="comment">//  We actually only have work to do if the segment is not</span>
04988     <span class="comment">//  user allocated.  If the segement is user allocated then</span>
04989     <span class="comment">//  we'll assume knows how to get rid of the memory</span>
04990     <span class="comment">//</span>
04991 
04992     <span class="keywordflow">if</span> (!(Segment-&gt;Flags &amp; <a class="code" href="../../d3/d9/heap_8h.html#a18">HEAP_SEGMENT_USER_ALLOCATED</a>)) {
04993 
04994         BaseAddress = Segment-&gt;BaseAddress;
04995         BytesToFree = 0;
04996 
04997         <span class="comment">//</span>
04998         <span class="comment">//  Free all the virtual memory for the segment and return</span>
04999         <span class="comment">//  to our caller.</span>
05000         <span class="comment">//</span>
05001 
05002         <span class="keywordflow">return</span> ZwFreeVirtualMemory( NtCurrentProcess(),
05003                                     (PVOID *)&amp;BaseAddress,
05004                                     &amp;BytesToFree,
05005                                     MEM_RELEASE );
05006 
05007     } <span class="keywordflow">else</span> {
05008 
05009         <span class="comment">//</span>
05010         <span class="comment">//  User allocated segments are a noop</span>
05011         <span class="comment">//</span>
05012 
05013         <span class="keywordflow">return</span> STATUS_SUCCESS;
05014     }
05015 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a11" doxytag="rtl/heap.c::RtlpDestroyUnCommittedRange" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID RtlpDestroyUnCommittedRange           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d8/d6/struct__HEAP__SEGMENT.html">PHEAP_SEGMENT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>Segment</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html">PHEAP_UNCOMMMTTED_RANGE</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>UnCommittedRange</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l04169">4169</a> of file <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html">rtl/heap.c</a>.
<p>
References <a class="el" href="../../d6/d8/ntrtlp_8h-source.html#l00246">RTL_PAGED_CODE</a>.
<p>
Referenced by <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l05527">RtlpDeCommitFreeBlock()</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l04422">RtlpFindAndCommitPages()</a>, and <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l04227">RtlpInsertUnCommittedPages()</a>.
<p>
<pre class="fragment"><div>04176                    :
04177 
04178     This routine returns an uncommitted range structure back to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> unused
04179     uncommitted range list
04180 
04181 Arguments:
04182 
04183     Segment - Supplies any segment in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap being modified.  Most likely but
04184         not necessarily <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> segment containing <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> uncommitted range structure
04185 
04186     UnCommittedRange - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> uncommitted range structure
04187         being decommissioned.
04188 
04189 Return Value:
04190 
04191     None.
04192 
04193 --*/
04194 
04195 {
04196     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
04197 
04198     <span class="comment">//</span>
04199     <span class="comment">//  This routine simply does a "push" of the uncommitted range structure</span>
04200     <span class="comment">//  onto the heap's stack of unused uncommitted ranges</span>
04201     <span class="comment">//</span>
04202 
04203     UnCommittedRange-&gt;Next = Segment-&gt;Heap-&gt;UnusedUnCommittedRanges;
04204     Segment-&gt;Heap-&gt;UnusedUnCommittedRanges = UnCommittedRange;
04205 
04206     <span class="comment">//</span>
04207     <span class="comment">//  For safety sake we'll also zero out the fields in the decommissioned</span>
04208     <span class="comment">//  structure</span>
04209     <span class="comment">//</span>
04210 
04211     UnCommittedRange-&gt;Address = 0;
04212     UnCommittedRange-&gt;Size = 0;
04213 
04214     <span class="comment">//</span>
04215     <span class="comment">//  And return to our caller</span>
04216     <span class="comment">//</span>
04217 
04218     <span class="keywordflow">return</span>;
04219 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a14" doxytag="rtl/heap.c::RtlpExtendHeap" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a> RtlpExtendHeap           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d5/d5/struct__HEAP.html">PHEAP</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>Heap</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN SIZE_T&nbsp;</td>
          <td class="mdname" nowrap> <em>AllocationSize</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l05024">5024</a> of file <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html">rtl/heap.c</a>.
<p>
References <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00228">HEAP_GRANULARITY_SHIFT</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00234">HEAP_MAXIMUM_SEGMENTS</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00265">_HEAP_SEGMENT::LargestUnCommittedRange</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00272">_HEAP_SEGMENT::NumberOfUnCommittedPages</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00599">PAGE_SIZE</a>, <a class="el" href="../../d6/d8/ntrtlp_8h-source.html#l00246">RTL_PAGED_CODE</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l05312">RtlpCoalesceFreeBlocks()</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l04312">RtlpCoalesceHeap()</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l04422">RtlpFindAndCommitPages()</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l04732">RtlpInitializeHeapSegment()</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l05849">RtlpInsertFreeBlock()</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00174">_HEAP_FREE_ENTRY::Size</a>, and <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>.
<p>
Referenced by <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l01316">RtlAllocateHeap()</a>, and <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l02075">RtlAllocateHeapSlowly()</a>.
<p>
<pre class="fragment"><div>05031                    :
05032 
05033     This routine <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> used to extend <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> amount of committed memory in a heap
05034 
05035 Arguments:
05036 
05037     Heap - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap being modified
05038 
05039     AllocationSize - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> size, in bytes, that we need to extend <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
05040         heap
05041 
05042 Return Value:
05043 
05044     <a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a> - Returns a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> newly created heap entry
05045         of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified size, or <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> <span class="keywordflow">if</span> we weren'<a class="code" href="../../d4/d1/genmips_8c.html#a17">t</a> able to extend <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap
05046 
05047 --*/
05048 
05049 {
05050     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
05051     <a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html">PHEAP_SEGMENT</a> Segment;
05052     <a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a> FreeBlock;
05053     UCHAR SegmentIndex, EmptySegmentIndex;
05054     ULONG NumberOfPages;
05055     SIZE_T CommitSize;
05056     SIZE_T ReserveSize;
05057     SIZE_T FreeSize;
05058 
05059     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
05060 
05061     <span class="comment">//</span>
05062     <span class="comment">//  Compute the number of pages need to hold this extension</span>
05063     <span class="comment">//  And then compute the real free, still in bytes, based on</span>
05064     <span class="comment">//  the page count</span>
05065     <span class="comment">//</span>
05066 
05067     NumberOfPages = (ULONG) ((AllocationSize + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1) / <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
05068     FreeSize = NumberOfPages * <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
05069 
05070     <span class="comment">//</span>
05071     <span class="comment">//  For every segment we're either going to look for an existing</span>
05072     <span class="comment">//  heap segment that we can get some pages out of or we will</span>
05073     <span class="comment">//  identify a free heap segment index where we'll try and create a new</span>
05074     <span class="comment">//  segment</span>
05075     <span class="comment">//</span>
05076 
05077     EmptySegmentIndex = <a class="code" href="../../d3/d9/heap_8h.html#a7">HEAP_MAXIMUM_SEGMENTS</a>;
05078 
05079     <span class="keywordflow">for</span> (SegmentIndex=0; SegmentIndex&lt;<a class="code" href="../../d3/d9/heap_8h.html#a7">HEAP_MAXIMUM_SEGMENTS</a>; SegmentIndex++) {
05080 
05081         Segment = Heap-&gt;Segments[ SegmentIndex ];
05082 
05083         <span class="comment">//</span>
05084         <span class="comment">//  If the segment exists and number of uncommitted pages will</span>
05085         <span class="comment">//  satisfy our reguest and the largest uncommitted range will</span>
05086         <span class="comment">//  also satisfy our request then we'll try and segment</span>
05087         <span class="comment">//</span>
05088         <span class="comment">//  **** note that this second test seems unnecessary given that</span>
05089         <span class="comment">//  **** the largest uncommitted range is also being tested</span>
05090         <span class="comment">//</span>
05091 
05092         <span class="keywordflow">if</span> ((Segment) &amp;&amp;
05093             (NumberOfPages &lt;= Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o9">NumberOfUnCommittedPages</a>) &amp;&amp;
05094             (FreeSize &lt;= Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o4">LargestUnCommittedRange</a>)) {
05095 
05096             <span class="comment">//</span>
05097             <span class="comment">//  Looks like a good segment so try and commit the</span>
05098             <span class="comment">//  amount we need</span>
05099             <span class="comment">//</span>
05100 
05101             FreeBlock = <a class="code" href="../../d9/d9/heappriv_8h.html#a37">RtlpFindAndCommitPages</a>( Heap,
05102                                                 Segment,
05103                                                 &amp;FreeSize,
05104                                                 NULL );
05105 
05106             <span class="comment">//</span>
05107             <span class="comment">//  If we were successful the we will coalesce it with adjacent</span>
05108             <span class="comment">//  free blocks and put it in the free list then return the</span>
05109             <span class="comment">//  the free block</span>
05110             <span class="comment">//</span>
05111 
05112             <span class="keywordflow">if</span> (FreeBlock != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05113 
05114                 <span class="comment">//</span>
05115                 <span class="comment">//  **** gdk ****</span>
05116                 <span class="comment">//  **** this doesn't seem right given that coalesece should take</span>
05117                 <span class="comment">//  **** byte count and not heap entry count</span>
05118                 <span class="comment">//</span>
05119 
05120                 FreeSize = FreeSize &gt;&gt; <a class="code" href="../../d3/d9/heap_8h.html#a4">HEAP_GRANULARITY_SHIFT</a>;
05121 
05122                 FreeBlock = <a class="code" href="../../d9/d9/heappriv_8h.html#a34">RtlpCoalesceFreeBlocks</a>( Heap, FreeBlock, &amp;FreeSize, FALSE );
05123 
05124                 <a class="code" href="../../d9/d9/heappriv_8h.html#a36">RtlpInsertFreeBlock</a>( Heap, FreeBlock, FreeSize );
05125 
05126                 <span class="keywordflow">return</span> FreeBlock;
05127             }
05128 
05129         <span class="comment">//</span>
05130         <span class="comment">//  Otherwise if the segment index is not in use and we haven't</span>
05131         <span class="comment">//  yet identified a unused segment index then remembeer this</span>
05132         <span class="comment">//  index</span>
05133         <span class="comment">//</span>
05134 
05135         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((Segment == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
05136                    (EmptySegmentIndex == <a class="code" href="../../d3/d9/heap_8h.html#a7">HEAP_MAXIMUM_SEGMENTS</a>)) {
05137 
05138             EmptySegmentIndex = SegmentIndex;
05139         }
05140     }
05141 
05142     <span class="comment">//</span>
05143     <span class="comment">//  At this point we weren't able to get the memory from an existing</span>
05144     <span class="comment">//  heap segment so now check if we found an unused segment index</span>
05145     <span class="comment">//  and if we're alowed to grow the heap.</span>
05146     <span class="comment">//</span>
05147 
05148     <span class="keywordflow">if</span> ((EmptySegmentIndex != <a class="code" href="../../d3/d9/heap_8h.html#a7">HEAP_MAXIMUM_SEGMENTS</a>) &amp;&amp;
05149         (Heap-&gt;Flags &amp; HEAP_GROWABLE)) {
05150 
05151         Segment = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
05152 
05153         <span class="comment">//</span>
05154         <span class="comment">//  Calculate a reserve size for the new segment, we might</span>
05155         <span class="comment">//  need to fudge it up if the allocation size we're going for</span>
05156         <span class="comment">//  right now is already beyond the default reserve size</span>
05157         <span class="comment">//</span>
05158 
05159         <span class="keywordflow">if</span> ((AllocationSize + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>) &gt; Heap-&gt;SegmentReserve) {
05160 
05161             ReserveSize = AllocationSize + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
05162 
05163         } <span class="keywordflow">else</span> {
05164 
05165             ReserveSize = Heap-&gt;SegmentReserve;
05166         }
05167 
05168         <span class="comment">//</span>
05169         <span class="comment">//  Try and reserve some vm</span>
05170         <span class="comment">//</span>
05171 
05172         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwAllocateVirtualMemory( NtCurrentProcess(),
05173                                           (PVOID *)&amp;Segment,
05174                                           0,
05175                                           &amp;ReserveSize,
05176                                           MEM_RESERVE,
05177                                           PAGE_READWRITE );
05178 
05179         <span class="comment">//</span>
05180         <span class="comment">//  If we get back status no memory then we should trim back the</span>
05181         <span class="comment">//  request to something reasonable and try again.  We'll half</span>
05182         <span class="comment">//  the amount until we it either succeeds or until we reach</span>
05183         <span class="comment">//  the allocation size.  In the latter case we are really</span>
05184         <span class="comment">//  out of memory.</span>
05185         <span class="comment">//</span>
05186 
05187         <span class="keywordflow">while</span> ((!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) &amp;&amp; (ReserveSize != (AllocationSize + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>))) {
05188 
05189             ReserveSize = ReserveSize / 2;
05190 
05191             <span class="keywordflow">if</span>( ReserveSize &lt; (AllocationSize + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>) ) {
05192 
05193                 ReserveSize = (AllocationSize + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
05194             }
05195 
05196             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwAllocateVirtualMemory( NtCurrentProcess(),
05197                                               (PVOID *)&amp;Segment,
05198                                               0,
05199                                               &amp;ReserveSize,
05200                                               MEM_RESERVE,
05201                                               PAGE_READWRITE );
05202         }
05203 
05204         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
05205 
05206             <span class="comment">//</span>
05207             <span class="comment">//  Adjust the heap state information</span>
05208             <span class="comment">//</span>
05209 
05210             Heap-&gt;SegmentReserve += ReserveSize;
05211 
05212             <span class="comment">//</span>
05213             <span class="comment">//  Compute the commit size to be either the default, or if</span>
05214             <span class="comment">//  that's not big enough then make it big enough to handle</span>
05215             <span class="comment">//  this current request</span>
05216             <span class="comment">//</span>
05217 
05218             <span class="keywordflow">if</span> ((AllocationSize + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>) &gt; Heap-&gt;SegmentCommit) {
05219 
05220                 CommitSize = AllocationSize + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
05221 
05222             } <span class="keywordflow">else</span> {
05223 
05224                 CommitSize = Heap-&gt;SegmentCommit;
05225             }
05226 
05227             <span class="comment">//</span>
05228             <span class="comment">//  Try and commit the memory</span>
05229             <span class="comment">//</span>
05230 
05231             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwAllocateVirtualMemory( NtCurrentProcess(),
05232                                               (PVOID *)&amp;Segment,
05233                                               0,
05234                                               &amp;CommitSize,
05235                                               MEM_COMMIT,
05236                                               PAGE_READWRITE );
05237 
05238             <span class="comment">//</span>
05239             <span class="comment">//  If the commit is successful but we were not able to</span>
05240             <span class="comment">//  initialize the heap segment then still make the status</span>
05241             <span class="comment">//  and error value</span>
05242             <span class="comment">//</span>
05243 
05244             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status ) &amp;&amp;
05245                 !<a class="code" href="../../d9/d9/heappriv_8h.html#a33">RtlpInitializeHeapSegment</a>( Heap,
05246                                             Segment,
05247                                             EmptySegmentIndex,
05248                                             0,
05249                                             Segment,
05250                                             (PCHAR)Segment + CommitSize,
05251                                             (PCHAR)Segment + ReserveSize)) {
05252 
05253                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_NO_MEMORY;
05254             }
05255 
05256             <span class="comment">//</span>
05257             <span class="comment">//  If we've been successful so far then we're done and we</span>
05258             <span class="comment">//  can return the first entry in the segment to our caller</span>
05259             <span class="comment">//</span>
05260 
05261             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(Status)) {
05262 
05263                 <span class="keywordflow">return</span> (<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a>)Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o7">FirstEntry</a>;
05264             }
05265 
05266             <span class="comment">//</span>
05267             <span class="comment">//  Otherwise either the commit or heap segment initialization failed</span>
05268             <span class="comment">//  so we'll release the memory which will also decommit it if necessary</span>
05269             <span class="comment">//</span>
05270 
05271             ZwFreeVirtualMemory( NtCurrentProcess(),
05272                                  (PVOID *)&amp;Segment,
05273                                  &amp;ReserveSize,
05274                                  MEM_RELEASE );
05275         }
05276     }
05277 
05278 <span class="preprocessor">#ifndef NTOS_KERNEL_RUNTIME</span>
05279 <span class="preprocessor"></span>
05280     <span class="comment">//</span>
05281     <span class="comment">//  In the non kernel case we disabled coaleseing on free then what we'll</span>
05282     <span class="comment">//  do as a last resort is coalesce the heap and see if a block comes out</span>
05283     <span class="comment">//  that we can use</span>
05284     <span class="comment">//</span>
05285 
05286     <span class="keywordflow">if</span> (Heap-&gt;Flags &amp; HEAP_DISABLE_COALESCE_ON_FREE) {
05287 
05288         FreeBlock = <a class="code" href="../../d9/d9/heappriv_8h.html#a45">RtlpCoalesceHeap</a>( Heap );
05289 
05290         <span class="keywordflow">if</span> ((FreeBlock != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp; (FreeBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o0">Size</a> &gt;= AllocationSize)) {
05291 
05292             <span class="keywordflow">return</span> FreeBlock;
05293         }
05294     }
05295 
05296 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
05297 <span class="preprocessor"></span>
05298     <span class="comment">//</span>
05299     <span class="comment">//  Either the heap cannot grow or we out of resources of some type</span>
05300     <span class="comment">//  so we're going to return null</span>
05301     <span class="comment">//</span>
05302 
05303     <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
05304 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a23" doxytag="rtl/heap.c::RtlpFindAndCommitPages" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a> RtlpFindAndCommitPages           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d5/d5/struct__HEAP.html">PHEAP</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>Heap</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d8/d6/struct__HEAP__SEGMENT.html">PHEAP_SEGMENT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>Segment</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN OUT PSIZE_T&nbsp;</td>
          <td class="mdname" nowrap> <em>Size</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID AddressWanted&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l04422">4422</a> of file <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html">rtl/heap.c</a>.
<p>
References <a class="el" href="../../d4/d8/heap_8h-source.html#l00254">_HEAP_UNCOMMMTTED_RANGE::Address</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00076">_HEAP_ENTRY::Flags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00240">HEAP_ENTRY_LAST_ENTRY</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00228">HEAP_GRANULARITY_SHIFT</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00134">HeapDebugBreak</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00121">HeapDebugPrint</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00253">_HEAP_UNCOMMMTTED_RANGE::Next</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00599">PAGE_SIZE</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00053">_HEAP_ENTRY::PreviousSize</a>, <a class="el" href="../../d6/d8/ntrtlp_8h-source.html#l00246">RTL_PAGED_CODE</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l04169">RtlpDestroyUnCommittedRange()</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00060">_HEAP_ENTRY::SegmentIndex</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00255">_HEAP_UNCOMMMTTED_RANGE::Size</a>, <a class="el" href="../../d9/d6/lh__open_2pi__mem_8h-source.html#l00017">Size</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00045">_HEAP_ENTRY::Size</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, and <a class="el" href="../../d5/d4/aug98_2dll32_2icc__i386_8h-source.html#l00064">USHORT</a>.
<p>
Referenced by <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l05024">RtlpExtendHeap()</a>, and <a class="el" href="../../d6/d8/heapdll_8c-source.html#l04693">RtlpGrowBlockInPlace()</a>.
<p>
<pre class="fragment"><div>04431                    :
04432 
04433     This function searches <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> supplied segment <span class="keywordflow">for</span> an uncommitted range that
04434     satisfies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified size.  It commits <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> range and returns a heap entry
04435     <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> range.
04436 
04437 Arguments:
04438 
04439     Heap - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap being maniuplated
04440 
04441     Segment - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> segment being searched
04442 
04443     <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> size of what we need to look <span class="keywordflow">for</span>, on <span class="keywordflow">return</span> <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> contains
04444         <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> size of what we're just found and committed.
04445 
04446     AddressWanted - Optionally gives an address where we would like <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> pages
04447         based.  If supplied <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> entry must start at <span class="keyword">this</span> address
04448 
04449 Return Value:
04450 
04451     <a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a> - Returns a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> newly committed range that
04452         satisfies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> given size requirement, or <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> <span class="keywordflow">if</span> we could not find
04453         something large enough and/or based at <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> address wanted.
04454 
04455 --*/
04456 
04457 {
04458     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
04459     <a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a> FirstEntry, LastEntry, PreviousLastEntry;
04460     <a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html">PHEAP_UNCOMMMTTED_RANGE</a> PreviousUnCommittedRange, UnCommittedRange, *pp;
04461     ULONG_PTR Address;
04462     SIZE_T Length;
04463 
04464     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
04465 
04466     <span class="comment">//</span>
04467     <span class="comment">//  What the outer loop does is cycle through the uncommited ranges</span>
04468     <span class="comment">//  stored in in the specified segment</span>
04469     <span class="comment">//</span>
04470 
04471     PreviousUnCommittedRange = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04472     pp = &amp;Segment-&gt;UnCommittedRanges;
04473 
04474     <span class="keywordflow">while</span> (UnCommittedRange = *pp) {
04475 
04476         <span class="comment">//</span>
04477         <span class="comment">//  Check for the best of worlds, where the size of this current</span>
04478         <span class="comment">//  uncommitted range satisfies our size request and either the user</span>
04479         <span class="comment">//  didn't specify an address or the address match</span>
04480         <span class="comment">//</span>
04481 
04482         <span class="keywordflow">if</span> ((UnCommittedRange-&gt;<a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html#o2">Size</a> &gt;= *<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>) &amp;&amp;
04483             (!ARGUMENT_PRESENT( AddressWanted ) || (UnCommittedRange-&gt;<a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html#o1">Address</a> == (ULONG_PTR)AddressWanted ))) {
04484 
04485             <span class="comment">//</span>
04486             <span class="comment">//  Calculate an address</span>
04487             <span class="comment">//</span>
04488 
04489             Address = UnCommittedRange-&gt;<a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html#o1">Address</a>;
04490 
04491             <span class="comment">//</span>
04492             <span class="comment">//  Commit the memory.  If the heap doesn't have a commit</span>
04493             <span class="comment">//  routine then use the default mm supplied routine.</span>
04494             <span class="comment">//</span>
04495 
04496             <span class="keywordflow">if</span> (Heap-&gt;CommitRoutine != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
04497 
04498                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = (Heap-&gt;CommitRoutine)( Heap,
04499                                                 (PVOID *)&amp;Address,
04500                                                 <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> );
04501 
04502             } <span class="keywordflow">else</span> {
04503 
04504                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwAllocateVirtualMemory( NtCurrentProcess(),
04505                                                   (PVOID *)&amp;Address,
04506                                                   0,
04507                                                   Size,
04508                                                   MEM_COMMIT,
04509                                                   PAGE_READWRITE );
04510 
04511             }
04512 
04513             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
04514 
04515                 <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04516             }
04517 
04518             <span class="comment">//</span>
04519             <span class="comment">//  At this point we have some committed memory, with Address and Size</span>
04520             <span class="comment">//  giving us the necessary details</span>
04521             <span class="comment">//</span>
04522             <span class="comment">//  Update the number of uncommitted pages in the segment and if necessary</span>
04523             <span class="comment">//  mark down the largest uncommitted range</span>
04524             <span class="comment">//</span>
04525 
04526             Segment-&gt;NumberOfUnCommittedPages -= (ULONG) (*<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> / <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
04527 
04528             <span class="keywordflow">if</span> (Segment-&gt;LargestUnCommittedRange == UnCommittedRange-&gt;<a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html#o2">Size</a>) {
04529 
04530                 Segment-&gt;LargestUnCommittedRange = 0;
04531             }
04532 
04533             <span class="comment">//</span>
04534             <span class="comment">//  First entry is the start of the newly committed range</span>
04535             <span class="comment">//</span>
04536 
04537             FirstEntry = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)Address;
04538 
04539             <span class="comment">//</span>
04540             <span class="comment">//  We want last entry to point to the last real entry before</span>
04541             <span class="comment">//  this newly committed spot.  To do this we start by</span>
04542             <span class="comment">//  setting last entry to either the first entry for the</span>
04543             <span class="comment">//  segment or (if we can do better), to right after the last</span>
04544             <span class="comment">//  uncommitted range we examined.  Either way it points to</span>
04545             <span class="comment">//  some committed range</span>
04546             <span class="comment">//</span>
04547 
04548             <span class="keywordflow">if</span> ((Segment-&gt;LastEntryInSegment-&gt;Flags &amp; <a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>) &amp;&amp;
04549                 (ULONG_PTR)(Segment-&gt;LastEntryInSegment + Segment-&gt;LastEntryInSegment-&gt;Size) == UnCommittedRange-&gt;<a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html#o1">Address</a>) {
04550 
04551                 LastEntry = Segment-&gt;LastEntryInSegment;
04552 
04553             } <span class="keywordflow">else</span> {
04554 
04555                 <span class="keywordflow">if</span> (PreviousUnCommittedRange == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
04556 
04557                     LastEntry = Segment-&gt;FirstEntry;
04558 
04559                 } <span class="keywordflow">else</span> {
04560 
04561                     LastEntry = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)(PreviousUnCommittedRange-&gt;<a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html#o1">Address</a> +
04562                                               PreviousUnCommittedRange-&gt;<a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html#o2">Size</a>);
04563                 }
04564 
04565                 <span class="comment">//</span>
04566                 <span class="comment">//  Now we zoom through the entries until we find the one</span>
04567                 <span class="comment">//  marked last</span>
04568                 <span class="comment">//</span>
04569 
04570                 <span class="keywordflow">while</span> (!(LastEntry-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>)) {
04571 
04572                     PreviousLastEntry = LastEntry;
04573                     LastEntry += LastEntry-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a>;
04574 
04575                     <span class="keywordflow">if</span> (((PCHAR)LastEntry &gt;= (PCHAR)Segment-&gt;LastValidEntry) || (LastEntry-&gt;Size == 0)) {
04576 
04577                         <span class="comment">//</span>
04578                         <span class="comment">//  Check for the situation where the last entry in the</span>
04579                         <span class="comment">//  segment isn't marked as a last entry but does put</span>
04580                         <span class="comment">//  us right where the have a new committed range</span>
04581                         <span class="comment">//</span>
04582 
04583                         <span class="keywordflow">if</span> (LastEntry == (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)Address) {
04584 
04585                             LastEntry = PreviousLastEntry;
04586 
04587                             <span class="keywordflow">break</span>;
04588                         }
04589 
04590                         <a class="code" href="../../d9/d9/heappriv_8h.html#a10">HeapDebugPrint</a>(( <span class="stringliteral">"Heap missing last entry in committed range near %x\n"</span>, PreviousLastEntry ));
04591                         <a class="code" href="../../d9/d9/heappriv_8h.html#a11">HeapDebugBreak</a>( PreviousLastEntry );
04592 
04593                         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04594                     }
04595                 }
04596             }
04597 
04598             <span class="comment">//</span>
04599             <span class="comment">//  Turn off the last bit on this entry because what's following</span>
04600             <span class="comment">//  is no longer uncommitted</span>
04601             <span class="comment">//</span>
04602 
04603             LastEntry-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp;= ~<a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>;
04604 
04605             <span class="comment">//</span>
04606             <span class="comment">//  Shrink the uncommited range by the size we've committed</span>
04607             <span class="comment">//</span>
04608 
04609             UnCommittedRange-&gt;<a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html#o1">Address</a> += *<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
04610             UnCommittedRange-&gt;<a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html#o2">Size</a> -= *<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
04611 
04612             <span class="comment">//</span>
04613             <span class="comment">//  Now if the size is zero then we've committed everything that there</span>
04614             <span class="comment">//  was in the range.  Otherwise make sure the first entry of what</span>
04615             <span class="comment">//  we've just committed knows that an uncommitted range follows.</span>
04616             <span class="comment">//</span>
04617 
04618             <span class="keywordflow">if</span> (UnCommittedRange-&gt;<a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html#o2">Size</a> == 0) {
04619 
04620                 <span class="comment">//</span>
04621                 <span class="comment">//  This uncommitted range is about to vanish.  Base on if the</span>
04622                 <span class="comment">//  range is the last one in the segemnt then we know how to</span>
04623                 <span class="comment">//  mark the committed range as being last or not.</span>
04624                 <span class="comment">//</span>
04625 
04626                 <span class="keywordflow">if</span> (UnCommittedRange-&gt;<a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html#o1">Address</a> == (ULONG_PTR)Segment-&gt;LastValidEntry) {
04627 
04628                     FirstEntry-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> = <a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>;
04629 
04630                     Segment-&gt;LastEntryInSegment = FirstEntry;
04631 
04632                 } <span class="keywordflow">else</span> {
04633 
04634                     FirstEntry-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> = 0;
04635 
04636                     Segment-&gt;LastEntryInSegment = Segment-&gt;FirstEntry;
04637                 }
04638 
04639                 <span class="comment">//</span>
04640                 <span class="comment">//  Remove this zero sized range from the uncommitted range</span>
04641                 <span class="comment">//  list, and update the segment counters</span>
04642                 <span class="comment">//</span>
04643 
04644                 *pp = UnCommittedRange-&gt;<a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html#o0">Next</a>;
04645 
04646                 <a class="code" href="../../d1/d9/rtl_2heap_8c.html#a11">RtlpDestroyUnCommittedRange</a>( Segment, UnCommittedRange );
04647 
04648                 Segment-&gt;NumberOfUnCommittedRanges -= 1;
04649 
04650             } <span class="keywordflow">else</span> {
04651 
04652                 <span class="comment">//</span>
04653                 <span class="comment">//  Otherwise the range is not empty so we know what we committed</span>
04654                 <span class="comment">//  is immediately followed by an uncommitted range</span>
04655                 <span class="comment">//</span>
04656 
04657                 FirstEntry-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> = <a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>;
04658 
04659                 Segment-&gt;LastEntryInSegment = FirstEntry;
04660             }
04661 
04662             <span class="comment">//</span>
04663             <span class="comment">//  Update the fields in the first entry, and optional</span>
04664             <span class="comment">//  following entry.</span>
04665             <span class="comment">//</span>
04666 
04667             FirstEntry-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o2">SegmentIndex</a> = LastEntry-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o2">SegmentIndex</a>;
04668             FirstEntry-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(*<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> &gt;&gt; <a class="code" href="../../d3/d9/heap_8h.html#a4">HEAP_GRANULARITY_SHIFT</a>);
04669             FirstEntry-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o1">PreviousSize</a> = LastEntry-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a>;
04670 
04671             <span class="keywordflow">if</span> (!(FirstEntry-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>)) {
04672 
04673                 (FirstEntry + FirstEntry-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a>)-&gt;PreviousSize = FirstEntry-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a>;
04674             }
04675 
04676             <span class="comment">//</span>
04677             <span class="comment">//  Now if we adjusted the largest uncommitted range to zero then</span>
04678             <span class="comment">//  we need to go back and find the largest uncommitted range</span>
04679             <span class="comment">//  To do that we simply zoom down the uncommitted range list</span>
04680             <span class="comment">//  remembering the largest one</span>
04681             <span class="comment">//</span>
04682 
04683             <span class="keywordflow">if</span> (Segment-&gt;LargestUnCommittedRange == 0) {
04684 
04685                 UnCommittedRange = Segment-&gt;UnCommittedRanges;
04686 
04687                 <span class="keywordflow">while</span> (UnCommittedRange != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
04688 
04689                     <span class="keywordflow">if</span> (UnCommittedRange-&gt;<a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html#o2">Size</a> &gt;= Segment-&gt;LargestUnCommittedRange) {
04690 
04691                         Segment-&gt;LargestUnCommittedRange = UnCommittedRange-&gt;<a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html#o2">Size</a>;
04692                     }
04693 
04694                     UnCommittedRange = UnCommittedRange-&gt;<a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html#o0">Next</a>;
04695                 }
04696             }
04697 
04698             <span class="comment">//</span>
04699             <span class="comment">//  And return the heap entry to our caller</span>
04700             <span class="comment">//</span>
04701 
04702             <span class="keywordflow">return</span> (<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a>)FirstEntry;
04703 
04704         } <span class="keywordflow">else</span> {
04705 
04706             <span class="comment">//</span>
04707             <span class="comment">//  Otherwise the current uncommited range is too small or</span>
04708             <span class="comment">//  doesn't have the right address so go to the next uncommitted</span>
04709             <span class="comment">//  range entry</span>
04710             <span class="comment">//</span>
04711 
04712             PreviousUnCommittedRange = UnCommittedRange;
04713             pp = &amp;UnCommittedRange-&gt;<a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html#o0">Next</a>;
04714         }
04715     }
04716 
04717     <span class="comment">//</span>
04718     <span class="comment">//  At this point we did not find an uncommitted range entry that satisfied</span>
04719     <span class="comment">//  our requirements either because of size and/or address.  So return null</span>
04720     <span class="comment">//  to tell the user we didn't find anything.</span>
04721     <span class="comment">//</span>
04722 
04723     <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04724 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a28" doxytag="rtl/heap.c::RtlpGetExtraStuffPointer" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html">PHEAP_ENTRY_EXTRA</a> RtlpGetExtraStuffPointer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>BusyBlock</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l06008">6008</a> of file <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html">rtl/heap.c</a>.
<p>
References <a class="el" href="../../d4/d8/heap_8h-source.html#l00161">_HEAP_VIRTUAL_ALLOC_ENTRY::ExtraStuff</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00076">_HEAP_ENTRY::Flags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00239">HEAP_ENTRY_VIRTUAL_ALLOC</a>, and <a class="el" href="../../d4/d8/heap_8h-source.html#l00045">_HEAP_ENTRY::Size</a>.
<p>
Referenced by <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l02075">RtlAllocateHeapSlowly()</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l00444">RtlDebugAllocateHeap()</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l00797">RtlDebugFreeHeap()</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l00603">RtlDebugReAllocateHeap()</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l01192">RtlGetUserInfoHeap()</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l01790">RtlpValidateHeapSegment()</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l00518">RtlReAllocateHeap()</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l01356">RtlSetUserValueHeap()</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l02976">RtlUsageHeap()</a>, and <a class="el" href="../../d6/d8/heapdll_8c-source.html#l03714">RtlWalkHeap()</a>.
<p>
<pre class="fragment"><div>06014                    :
06015 
06016     This routine calculates where <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> extra stuff record will be given
06017     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> busy block and returns a pointer to <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a>.  The caller must have
06018     already checked that <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> entry extry field <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> present
06019 
06020 Arguments:
06021 
06022     BusyBlock - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> busy block whose extra stuff we are seeking
06023 
06024 Return Value:
06025 
06026     <a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html">PHEAP_ENTRY_EXTRA</a> - returns a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> extra stuff record.
06027 
06028 --*/
06029 
06030 {
06031     ULONG AllocationIndex;
06032 
06033     <span class="comment">//</span>
06034     <span class="comment">//  On big blocks the extra stuff is automatically part of the</span>
06035     <span class="comment">//  block</span>
06036     <span class="comment">//</span>
06037 
06038     <span class="keywordflow">if</span> (BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a11">HEAP_ENTRY_VIRTUAL_ALLOC</a>) {
06039 
06040         <a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html">PHEAP_VIRTUAL_ALLOC_ENTRY</a> VirtualAllocBlock;
06041 
06042         VirtualAllocBlock = CONTAINING_RECORD( BusyBlock, <a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html">HEAP_VIRTUAL_ALLOC_ENTRY</a>, BusyBlock );
06043 
06044         <span class="keywordflow">return</span> &amp;VirtualAllocBlock-&gt;<a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html#o1">ExtraStuff</a>;
06045 
06046     } <span class="keywordflow">else</span> {
06047 
06048         <span class="comment">//</span>
06049         <span class="comment">//  On non big blocks the extra stuff follows immediately after</span>
06050         <span class="comment">//  the allocation itself.</span>
06051         <span class="comment">//</span>
06052         <span class="comment">//  **** What a hack</span>
06053         <span class="comment">//  **** We do some funny math here because the busy block</span>
06054         <span class="comment">//  **** stride is 8 bytes we know we can stride it by its</span>
06055         <span class="comment">//  **** index minus one to get to the end of the allocation</span>
06056         <span class="comment">//</span>
06057 
06058         AllocationIndex = BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a>;
06059 
06060         <span class="keywordflow">return</span> (<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html">PHEAP_ENTRY_EXTRA</a>)(BusyBlock + AllocationIndex - 1);
06061     }
06062 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a29" doxytag="rtl/heap.c::RtlpGetSizeOfBigBlock" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SIZE_T RtlpGetSizeOfBigBlock           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>BusyBlock</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l06070">6070</a> of file <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html">rtl/heap.c</a>.
<p>
References <a class="el" href="../../d4/d8/heap_8h-source.html#l00162">_HEAP_VIRTUAL_ALLOC_ENTRY::CommitSize</a>, and <a class="el" href="../../d6/d8/ntrtlp_8h-source.html#l00246">RTL_PAGED_CODE</a>.
<p>
Referenced by <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l06117">RtlpCheckBusyBlockTail()</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l00518">RtlReAllocateHeap()</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l03655">RtlSizeHeap()</a>, and <a class="el" href="../../d6/d8/heapdll_8c-source.html#l03714">RtlWalkHeap()</a>.
<p>
<pre class="fragment"><div>06076                    :
06077 
06078     This routine returns <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> size, in bytes, of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> big allocation block
06079 
06080 Arguments:
06081 
06082     BusyBlock - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> block being queried
06083 
06084 Return Value:
06085 
06086     SIZE_T - Returns <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> size, in bytes, that was allocated to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> big
06087         block
06088 
06089 --*/
06090 
06091 {
06092     <a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html">PHEAP_VIRTUAL_ALLOC_ENTRY</a> VirtualAllocBlock;
06093 
06094     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
06095 
06096     <span class="comment">//</span>
06097     <span class="comment">//  Get a pointer to the block header itself</span>
06098     <span class="comment">//</span>
06099 
06100     VirtualAllocBlock = CONTAINING_RECORD( BusyBlock, <a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html">HEAP_VIRTUAL_ALLOC_ENTRY</a>, BusyBlock );
06101 
06102     <span class="comment">//</span>
06103     <span class="comment">//  The size allocated to the block is actually the difference between the</span>
06104     <span class="comment">//  commit size stored in the virtual alloc block and the size stored in</span>
06105     <span class="comment">//  in the block.</span>
06106     <span class="comment">//</span>
06107 
06108     <span class="keywordflow">return</span> VirtualAllocBlock-&gt;<a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html#o2">CommitSize</a> - BusyBlock-&gt;Size;
06109 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a24" doxytag="rtl/heap.c::RtlpInitializeHeapSegment" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> BOOLEAN RtlpInitializeHeapSegment           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d5/d5/struct__HEAP.html">PHEAP</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>Heap</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d8/d6/struct__HEAP__SEGMENT.html">PHEAP_SEGMENT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>Segment</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN UCHAR&nbsp;</td>
          <td class="mdname" nowrap> <em>SegmentIndex</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Flags</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>BaseAddress</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>UnCommittedAddress</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>CommitLimitAddress</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l04732">4732</a> of file <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html">rtl/heap.c</a>.
<p>
References <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00076">_HEAP_ENTRY::Flags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00236">HEAP_ENTRY_BUSY</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00240">HEAP_ENTRY_LAST_ENTRY</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00224">HEAP_GRANULARITY</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00228">HEAP_GRANULARITY_SHIFT</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00280">HEAP_SEGMENT_SIGNATURE</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d2/ldrp_8h-source.html#l00370">NtGlobalFlag</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00599">PAGE_SIZE</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00053">_HEAP_ENTRY::PreviousSize</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00030">ROUND_UP_TO_POWER2</a>, <a class="el" href="../../d6/d8/ntrtlp_8h-source.html#l00246">RTL_PAGED_CODE</a>, <a class="el" href="../../d5/d6/rtl_2regutil_8c-source.html#l01432">RtlGetNtGlobalFlags()</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l05849">RtlpInsertFreeBlock()</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l04227">RtlpInsertUnCommittedPages()</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00060">_HEAP_ENTRY::SegmentIndex</a>, <a class="el" href="../../d9/d6/lh__open_2pi__mem_8h-source.html#l00017">Size</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, and <a class="el" href="../../d5/d4/aug98_2dll32_2icc__i386_8h-source.html#l00064">USHORT</a>.
<p>
Referenced by <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l00191">RtlCreateHeap()</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l02132">RtlExtendHeap()</a>, and <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l05024">RtlpExtendHeap()</a>.
<p>
<pre class="fragment"><div>04744                    :
04745 
04746     This <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a24">routines</a> initializes <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> internal structures <span class="keywordflow">for</span> a heap segment.
04747     The caller supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap and <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> memory <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> segment being
04748     initialized
04749 
04750 Arguments:
04751 
04752     Heap - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> address of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap owning <span class="keyword">this</span> segment
04753 
04754     Segment - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> segment being initialized
04755 
04756     SegmentIndex - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> segement index within <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap that <span class="keyword">this</span>
04757         <span class="keyword">new</span> segment <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> being assigned
04758 
04759     Flags - Supplies flags controlling <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> initialization of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> segment
04760         Valid flags are:
04761 
04762             <a class="code" href="../../d3/d9/heap_8h.html#a18">HEAP_SEGMENT_USER_ALLOCATED</a>
04763 
04764     BaseAddress - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> base address <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> segment
04765 
04766     UnCommittedAddress - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> address where <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> uncommited range starts
04767 
04768     CommitLimitAddress - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> top address available to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> segment
04769 
04770 Return Value:
04771 
04772     BOOLEAN - <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> initialization <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> successful and <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> otherwise
04773 
04774 --*/
04775 
04776 {
04777     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
04778     <a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a> FirstEntry;
04779     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> PreviousSize, <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
04780     ULONG NumberOfPages;
04781     ULONG NumberOfCommittedPages;
04782     ULONG NumberOfUnCommittedPages;
04783     SIZE_T CommitSize;
04784     ULONG <a class="code" href="../../d9/d2/ldrp_8h.html#a33">NtGlobalFlag</a> = <a class="code" href="../../d4/d7/rtl_2regutil_8c.html#a25">RtlGetNtGlobalFlags</a>();
04785 
04786     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
04787 
04788     <span class="comment">//</span>
04789     <span class="comment">//  Compute the total number of pages possible in this segment</span>
04790     <span class="comment">//</span>
04791 
04792     NumberOfPages = (ULONG) (((PCHAR)CommitLimitAddress - (PCHAR)BaseAddress) / <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
04793 
04794     <span class="comment">//</span>
04795     <span class="comment">//  First entry points to the first possible segment entry after</span>
04796     <span class="comment">//  the segment header</span>
04797     <span class="comment">//</span>
04798 
04799     FirstEntry = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)<a class="code" href="../../d3/d9/heap_8h.html#a1">ROUND_UP_TO_POWER2</a>( Segment + 1,
04800                                                   HEAP_GRANULARITY );
04801 
04802     <span class="comment">//</span>
04803     <span class="comment">//  Now if the heap is equal to the base address for the segment which</span>
04804     <span class="comment">//  it the case for the segment zero then the previous size is the</span>
04805     <span class="comment">//  heap header.  Otherwise there isn't a previous entry</span>
04806     <span class="comment">//</span>
04807 
04808     <span class="keywordflow">if</span> ((PVOID)Heap == BaseAddress) {
04809 
04810         PreviousSize = Heap-&gt;Entry.Size;
04811 
04812     } <span class="keywordflow">else</span> {
04813 
04814         PreviousSize = 0;
04815     }
04816 
04817     <span class="comment">//</span>
04818     <span class="comment">//  Compute the index size of the segement header</span>
04819     <span class="comment">//</span>
04820 
04821     <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(((PCHAR)FirstEntry - (PCHAR)Segment) &gt;&gt; <a class="code" href="../../d3/d9/heap_8h.html#a4">HEAP_GRANULARITY_SHIFT</a>);
04822 
04823     <span class="comment">//</span>
04824     <span class="comment">//  If the first available heap entry is not committed and</span>
04825     <span class="comment">//  it is beyond the heap limit then we cannot initialize</span>
04826     <span class="comment">//</span>
04827 
04828     <span class="keywordflow">if</span> ((PCHAR)(FirstEntry + 1) &gt;= (PCHAR)UnCommittedAddress) {
04829 
04830         <span class="keywordflow">if</span> ((PCHAR)(FirstEntry + 1) &gt;= (PCHAR)CommitLimitAddress) {
04831 
04832             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04833         }
04834 
04835         <span class="comment">//</span>
04836         <span class="comment">//  Enough of the segment has not been committed so we</span>
04837         <span class="comment">//  will commit enough now to handle the first entry</span>
04838         <span class="comment">//</span>
04839 
04840         CommitSize = (PCHAR)(FirstEntry + 1) - (PCHAR)UnCommittedAddress;
04841 
04842         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwAllocateVirtualMemory( NtCurrentProcess(),
04843                                           (PVOID *)&amp;UnCommittedAddress,
04844                                           0,
04845                                           &amp;CommitSize,
04846                                           MEM_COMMIT,
04847                                           PAGE_READWRITE );
04848 
04849         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
04850 
04851             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04852         }
04853 
04854         <span class="comment">//</span>
04855         <span class="comment">//  Because we had to commit some memory we need to adjust</span>
04856         <span class="comment">//  the uncommited address</span>
04857         <span class="comment">//</span>
04858 
04859         UnCommittedAddress = (PVOID)((PCHAR)UnCommittedAddress + CommitSize);
04860     }
04861 
04862     <span class="comment">//</span>
04863     <span class="comment">//  At this point we know there is enough memory committed to handle the</span>
04864     <span class="comment">//  segment header and one heap entry</span>
04865     <span class="comment">//</span>
04866     <span class="comment">//  Now compute the number of uncommited pages and the number of committed</span>
04867     <span class="comment">//  pages</span>
04868     <span class="comment">//</span>
04869 
04870     NumberOfUnCommittedPages = (ULONG)(((PCHAR)CommitLimitAddress - (PCHAR)UnCommittedAddress) / <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
04871     NumberOfCommittedPages = NumberOfPages - NumberOfUnCommittedPages;
04872 
04873     <span class="comment">//</span>
04874     <span class="comment">//  Initialize the heap segment heap entry.  We</span>
04875     <span class="comment">//  calculated earlier if there was a previous entry</span>
04876     <span class="comment">//</span>
04877 
04878     Segment-&gt;Entry.PreviousSize = PreviousSize;
04879     Segment-&gt;Entry.Size = <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
04880     Segment-&gt;Entry.Flags = <a class="code" href="../../d3/d9/heap_8h.html#a8">HEAP_ENTRY_BUSY</a>;
04881     Segment-&gt;Entry.SegmentIndex = SegmentIndex;
04882 
04883 <span class="preprocessor">#if i386 &amp;&amp; !NTOS_KERNEL_RUNTIME</span>
04884 <span class="preprocessor"></span>
04885     <span class="comment">//</span>
04886     <span class="comment">//  In the non kernel x86 case see if we need to capture the callers stack</span>
04887     <span class="comment">//  backtrace</span>
04888     <span class="comment">//</span>
04889 
04890     <span class="keywordflow">if</span> (<a class="code" href="../../d9/d2/ldrp_8h.html#a33">NtGlobalFlag</a> &amp; FLG_USER_STACK_TRACE_DB) {
04891 
04892         Segment-&gt;AllocatorBackTraceIndex = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)RtlLogStackBackTrace();
04893     }
04894 
04895 <span class="preprocessor">#endif // i386 &amp;&amp; !NTOS_KERNEL_RUNTIME</span>
04896 <span class="preprocessor"></span>
04897     <span class="comment">//</span>
04898     <span class="comment">//  Now initializes the heap segment</span>
04899     <span class="comment">//</span>
04900 
04901     Segment-&gt;Signature = <a class="code" href="../../d3/d9/heap_8h.html#a17">HEAP_SEGMENT_SIGNATURE</a>;
04902     Segment-&gt;Flags = Flags;
04903     Segment-&gt;Heap = Heap;
04904     Segment-&gt;BaseAddress = BaseAddress;
04905     Segment-&gt;FirstEntry = FirstEntry;
04906     Segment-&gt;LastValidEntry = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)((PCHAR)BaseAddress + (NumberOfPages * <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>));
04907     Segment-&gt;NumberOfPages = NumberOfPages;
04908     Segment-&gt;NumberOfUnCommittedPages = NumberOfUnCommittedPages;
04909 
04910     <span class="comment">//</span>
04911     <span class="comment">//  If there are uncommitted pages then we need to insert them</span>
04912     <span class="comment">//  into the uncommitted ranges list</span>
04913     <span class="comment">//</span>
04914 
04915     <span class="keywordflow">if</span> (NumberOfUnCommittedPages) {
04916 
04917         <a class="code" href="../../d1/d9/rtl_2heap_8c.html#a12">RtlpInsertUnCommittedPages</a>( Segment,
04918                                     (ULONG_PTR)UnCommittedAddress,
04919                                     NumberOfUnCommittedPages * PAGE_SIZE );
04920     }
04921 
04922     <span class="comment">//</span>
04923     <span class="comment">//  Have the containing heap point to this segment via the specified index</span>
04924     <span class="comment">//</span>
04925 
04926     Heap-&gt;Segments[ SegmentIndex ] = Segment;
04927 
04928     <span class="comment">//</span>
04929     <span class="comment">//  Initialize the first free heap entry after the heap segment header and</span>
04930     <span class="comment">//  put it in the free list.  This first entry will be for whatever is left</span>
04931     <span class="comment">//  of the committed range</span>
04932     <span class="comment">//</span>
04933 
04934     PreviousSize = Segment-&gt;Entry.Size;
04935     FirstEntry-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> = <a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>;
04936 
04937     Segment-&gt;LastEntryInSegment = FirstEntry;
04938 
04939     FirstEntry-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o1">PreviousSize</a> = PreviousSize;
04940     FirstEntry-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o2">SegmentIndex</a> = SegmentIndex;
04941 
04942     <a class="code" href="../../d9/d9/heappriv_8h.html#a36">RtlpInsertFreeBlock</a>( Heap,
04943                          (<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a>)FirstEntry,
04944                          (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)UnCommittedAddress - FirstEntry);
04945 
04946     <span class="comment">//</span>
04947     <span class="comment">//  And return to our caller</span>
04948     <span class="comment">//</span>
04949 
04950     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04951 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a27" doxytag="rtl/heap.c::RtlpInsertFreeBlock" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID RtlpInsertFreeBlock           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d5/d5/struct__HEAP.html">PHEAP</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>Heap</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>FreeBlock</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN SIZE_T&nbsp;</td>
          <td class="mdname" nowrap> <em>FreeSize</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l05849">5849</a> of file <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html">rtl/heap.c</a>.
<p>
References <a class="el" href="../../d4/d8/heap_8h-source.html#l00263">_HEAP_SEGMENT::Flags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00240">HEAP_ENTRY_LAST_ENTRY</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00231">HEAP_MAXIMUM_BLOCK_SIZE</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00270">_HEAP_SEGMENT::LastValidEntry</a>, <a class="el" href="../../d6/d8/ntrtlp_8h-source.html#l00246">RTL_PAGED_CODE</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00322">RtlpInsertFreeBlockDirect</a>, <a class="el" href="../../d9/d6/lh__open_2pi__mem_8h-source.html#l00017">Size</a>, and <a class="el" href="../../d5/d4/aug98_2dll32_2icc__i386_8h-source.html#l00064">USHORT</a>.
<p>
Referenced by <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l01316">RtlAllocateHeap()</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l02075">RtlAllocateHeapSlowly()</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l02931">RtlFreeHeap()</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l03273">RtlFreeHeapSlowly()</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l04312">RtlpCoalesceHeap()</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l05527">RtlpDeCommitFreeBlock()</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l05024">RtlpExtendHeap()</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l04693">RtlpGrowBlockInPlace()</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l04732">RtlpInitializeHeapSegment()</a>, and <a class="el" href="../../d6/d8/heapdll_8c-source.html#l00518">RtlReAllocateHeap()</a>.
<p>
<pre class="fragment"><div>05857                    :
05858 
05859     This <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a24">routines</a> take a piece of committed memory and adds to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
05860     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> appropriate free lists <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap.  If necessary <span class="keyword">this</span>
05861     routine will divide up <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> free block to sizes that fit
05862     on <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> free list
05863 
05864 
05865 Arguments:
05866 
05867     Heap - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> owning heap
05868 
05869     FreeBlock - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> block being freed
05870 
05871     FreeSize - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> size, in bytes, of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> block being freed
05872 
05873 Return Value:
05874 
05875     None.
05876 
05877 --*/
05878 
05879 {
05880     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> PreviousSize, <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
05881     UCHAR Flags;
05882     UCHAR SegmentIndex;
05883     <a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html">PHEAP_SEGMENT</a> Segment;
05884 
05885     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
05886 
05887     <span class="comment">//</span>
05888     <span class="comment">//  Get the size of the previous block, the index of the segment</span>
05889     <span class="comment">//  containing this block, and the flags specific to the block</span>
05890     <span class="comment">//</span>
05891 
05892     PreviousSize = FreeBlock-&gt;PreviousSize;
05893 
05894     SegmentIndex = FreeBlock-&gt;SegmentIndex;
05895     Segment = Heap-&gt;Segments[ SegmentIndex ];
05896 
05897     Flags = FreeBlock-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o2">Flags</a>;
05898 
05899     <span class="comment">//</span>
05900     <span class="comment">//  Adjust the total amount free in the heap</span>
05901     <span class="comment">//</span>
05902 
05903     Heap-&gt;TotalFreeSize += FreeSize;
05904 
05905     <span class="comment">//</span>
05906     <span class="comment">//  Now, while there is still something left to add to the free list</span>
05907     <span class="comment">//  we'll process the information</span>
05908     <span class="comment">//</span>
05909 
05910     <span class="keywordflow">while</span> (FreeSize != 0) {
05911 
05912         <span class="comment">//</span>
05913         <span class="comment">//  If the size is too big for our free lists then we'll</span>
05914         <span class="comment">//  chop it down.</span>
05915         <span class="comment">//</span>
05916 
05917         <span class="keywordflow">if</span> (FreeSize &gt; (ULONG)<a class="code" href="../../d3/d9/heap_8h.html#a5">HEAP_MAXIMUM_BLOCK_SIZE</a>) {
05918 
05919             <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> = <a class="code" href="../../d3/d9/heap_8h.html#a5">HEAP_MAXIMUM_BLOCK_SIZE</a>;
05920 
05921             <span class="comment">//</span>
05922             <span class="comment">//  This little adjustment is so that we don't have a remainder</span>
05923             <span class="comment">//  that is too small to be useful on the next iteration</span>
05924             <span class="comment">//  through the loop</span>
05925             <span class="comment">//</span>
05926 
05927             <span class="keywordflow">if</span> (FreeSize == ((ULONG)<a class="code" href="../../d3/d9/heap_8h.html#a5">HEAP_MAXIMUM_BLOCK_SIZE</a> + 1)) {
05928 
05929                 <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> -= 16;
05930             }
05931 
05932             <span class="comment">//</span>
05933             <span class="comment">//  Guarantee that Last entry does not get set in this</span>
05934             <span class="comment">//  block.</span>
05935             <span class="comment">//</span>
05936 
05937             FreeBlock-&gt;Flags = 0;
05938 
05939         } <span class="keywordflow">else</span> {
05940 
05941             <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)FreeSize;
05942 
05943             <span class="comment">//</span>
05944             <span class="comment">//  This could propagate the last entry flag</span>
05945             <span class="comment">//</span>
05946 
05947             FreeBlock-&gt;Flags = Flags;
05948         }
05949 
05950         <span class="comment">//</span>
05951         <span class="comment">//  Update the block sizes and then insert this</span>
05952         <span class="comment">//  block into a free list</span>
05953         <span class="comment">//</span>
05954 
05955         FreeBlock-&gt;PreviousSize = PreviousSize;
05956         FreeBlock-&gt;SegmentIndex = SegmentIndex;
05957         FreeBlock-&gt;Size = <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
05958 
05959         <a class="code" href="../../d9/d9/heappriv_8h.html#a14">RtlpInsertFreeBlockDirect</a>( Heap, FreeBlock, Size );
05960 
05961         <span class="comment">//</span>
05962         <span class="comment">//  Note the size of what we just freed, and then update</span>
05963         <span class="comment">//  our state information for the next time through the</span>
05964         <span class="comment">//  loop</span>
05965         <span class="comment">//</span>
05966 
05967         PreviousSize = <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
05968 
05969         FreeSize -= <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
05970         FreeBlock = (<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a>)((<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)FreeBlock + <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>);
05971 
05972         <span class="comment">//</span>
05973         <span class="comment">//  Check if we're done with the free block based on the</span>
05974         <span class="comment">//  segment information, otherwise go back up and check size</span>
05975         <span class="comment">//  Note that is means that we can get called with a very</span>
05976         <span class="comment">//  large size and still work.</span>
05977         <span class="comment">//</span>
05978 
05979         <span class="keywordflow">if</span> ((<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)FreeBlock &gt;= Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o8">LastValidEntry</a>) {
05980 
05981             <span class="keywordflow">return</span>;
05982         }
05983     }
05984 
05985     <span class="comment">//</span>
05986     <span class="comment">//  If the block we're freeing did not think it was the last entry</span>
05987     <span class="comment">//  then tell the next block our real size.</span>
05988     <span class="comment">//</span>
05989 
05990     <span class="keywordflow">if</span> (!(Flags &amp; <a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>)) {
05991 
05992         FreeBlock-&gt;PreviousSize = PreviousSize;
05993     }
05994 
05995     <span class="comment">//</span>
05996     <span class="comment">//  And return to our caller</span>
05997     <span class="comment">//</span>
05998 
05999     <span class="keywordflow">return</span>;
06000 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a12" doxytag="rtl/heap.c::RtlpInsertUnCommittedPages" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID RtlpInsertUnCommittedPages           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d8/d6/struct__HEAP__SEGMENT.html">PHEAP_SEGMENT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>Segment</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG_PTR&nbsp;</td>
          <td class="mdname" nowrap> <em>Address</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN SIZE_T&nbsp;</td>
          <td class="mdname" nowrap> <em>Size</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l04227">4227</a> of file <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html">rtl/heap.c</a>.
<p>
References <a class="el" href="../../d4/d8/heap_8h-source.html#l00254">_HEAP_UNCOMMMTTED_RANGE::Address</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00121">HeapDebugPrint</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00253">_HEAP_UNCOMMMTTED_RANGE::Next</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d6/d8/ntrtlp_8h-source.html#l00246">RTL_PAGED_CODE</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l03962">RtlpCreateUnCommittedRange()</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l04169">RtlpDestroyUnCommittedRange()</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00255">_HEAP_UNCOMMMTTED_RANGE::Size</a>, and <a class="el" href="../../d9/d6/lh__open_2pi__mem_8h-source.html#l00017">Size</a>.
<p>
Referenced by <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l05527">RtlpDeCommitFreeBlock()</a>, and <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l04732">RtlpInitializeHeapSegment()</a>.
<p>
<pre class="fragment"><div>04235                    :
04236 
04237     This routine adds <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified range to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> list of uncommitted pages
04238     in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> segment.  When done <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> information will hang off <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> segments
04239     uncommitted ranges list.
04240 
04241 Arguments:
04242 
04243     Segment - Supplies a segment whose uncommitted range <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> being modified
04244 
04245     Address - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> base (start) address for the uncommitted range
04246 
04247     Size - Supplies the size, in bytes, of the uncommitted range
04248 
04249 Return Value:
04250 
04251     None.
04252 
04253 --*/
04254 
04255 {
04256     <a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html">PHEAP_UNCOMMMTTED_RANGE</a> UnCommittedRange, *pp;
04257 
04258     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
04259 
04260     <span class="comment">//</span>
04261     <span class="comment">//  Get a pointer to the front of the segments uncommitted range list</span>
04262     <span class="comment">//  The list is sorted by ascending address</span>
04263     <span class="comment">//</span>
04264 
04265     pp = &amp;Segment-&gt;UnCommittedRanges;
04266 
04267     <span class="comment">//</span>
04268     <span class="comment">//  While we haven't reached the end of the list we'll zoom through</span>
04269     <span class="comment">//  trying to find a fit</span>
04270     <span class="comment">//</span>
04271 
04272     <span class="keywordflow">while</span> (UnCommittedRange = *pp) {
04273 
04274         <span class="comment">//</span>
04275         <span class="comment">//  If address we want is less than what we're pointing at then</span>
04276         <span class="comment">//  we've found where this new entry goes</span>
04277         <span class="comment">//</span>
04278 
04279         <span class="keywordflow">if</span> (UnCommittedRange-&gt;<a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html#o1">Address</a> &gt; Address) {
04280 
04281             <span class="comment">//</span>
04282             <span class="comment">//  If the new block matches right up to the existing block</span>
04283             <span class="comment">//  then we can simply backup the existing block and add</span>
04284             <span class="comment">//  to its size</span>
04285             <span class="comment">//</span>
04286 
04287             <span class="keywordflow">if</span> ((Address + <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>) == UnCommittedRange-&gt;<a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html#o1">Address</a>) {
04288 
04289                 UnCommittedRange-&gt;<a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html#o1">Address</a> = Address;
04290                 UnCommittedRange-&gt;<a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html#o2">Size</a> += <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
04291 
04292                 <span class="comment">//</span>
04293                 <span class="comment">//  Check if we need to update our notion of what the</span>
04294                 <span class="comment">//  largest uncommitted range is</span>
04295                 <span class="comment">//</span>
04296 
04297                 <span class="keywordflow">if</span> (UnCommittedRange-&gt;<a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html#o2">Size</a> &gt; Segment-&gt;LargestUnCommittedRange) {
04298 
04299                     Segment-&gt;LargestUnCommittedRange = UnCommittedRange-&gt;<a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html#o2">Size</a>;
04300                 }
04301 
04302                 <span class="comment">//</span>
04303                 <span class="comment">//  And return to our caller</span>
04304                 <span class="comment">//</span>
04305 
04306                 <span class="keywordflow">return</span>;
04307             }
04308 
04309             <span class="comment">//</span>
04310             <span class="comment">//  Pp is the address of the block right before us, and *Pp is the</span>
04311             <span class="comment">//  address of the block right after us.  So now fall out to where</span>
04312             <span class="comment">//  the insertion takes place.</span>
04313             <span class="comment">//</span>
04314 
04315             <span class="keywordflow">break</span>;
04316 
04317         <span class="comment">//</span>
04318         <span class="comment">//  Otherwise if this existing block stops right where the new block</span>
04319         <span class="comment">//  starts then we get to modify this entry.</span>
04320         <span class="comment">//</span>
04321 
04322         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((UnCommittedRange-&gt;<a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html#o1">Address</a> + UnCommittedRange-&gt;<a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html#o2">Size</a>) == Address) {
04323 
04324             <span class="comment">//</span>
04325             <span class="comment">//  Remember the starting address and compute the new larger size</span>
04326             <span class="comment">//</span>
04327 
04328             Address = UnCommittedRange-&gt;<a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html#o1">Address</a>;
04329             <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> += UnCommittedRange-&gt;<a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html#o2">Size</a>;
04330 
04331             <span class="comment">//</span>
04332             <span class="comment">//  Remove this entry from the list and then return it to the</span>
04333             <span class="comment">//  unused uncommitted list</span>
04334             <span class="comment">//</span>
04335 
04336             *pp = UnCommittedRange-&gt;<a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html#o0">Next</a>;
04337 
04338             <a class="code" href="../../d1/d9/rtl_2heap_8c.html#a11">RtlpDestroyUnCommittedRange</a>( Segment, UnCommittedRange );
04339 
04340             <span class="comment">//</span>
04341             <span class="comment">//  Modify the segemnt counters and largest size state.  The next</span>
04342             <span class="comment">//  time through the loop should hit the first case above where</span>
04343             <span class="comment">//  we'll either merge with a list following us or add a new</span>
04344             <span class="comment">//  entry</span>
04345             <span class="comment">//</span>
04346 
04347             Segment-&gt;NumberOfUnCommittedRanges -= 1;
04348 
04349             <span class="keywordflow">if</span> (<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> &gt; Segment-&gt;LargestUnCommittedRange) {
04350 
04351                 Segment-&gt;LargestUnCommittedRange = <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
04352             }
04353 
04354         <span class="comment">//</span>
04355         <span class="comment">//  Otherwise we'll continue search down the list</span>
04356         <span class="comment">//</span>
04357 
04358         } <span class="keywordflow">else</span> {
04359 
04360             pp = &amp;UnCommittedRange-&gt;<a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html#o0">Next</a>;
04361         }
04362     }
04363 
04364     <span class="comment">//</span>
04365     <span class="comment">//  If we reach this point that means we've either fallen off the end of the</span>
04366     <span class="comment">//  list, or the list is empty, or we've located the spot where a new uncommitted</span>
04367     <span class="comment">//  range structure belongs.  So allocate a new uncommitted range structure,</span>
04368     <span class="comment">//  and make sure we got one.</span>
04369     <span class="comment">//</span>
04370     <span class="comment">//  Pp is the address of the block right before us and *Pp is the address of the</span>
04371     <span class="comment">//  block right after us</span>
04372     <span class="comment">//</span>
04373 
04374     UnCommittedRange = <a class="code" href="../../d1/d9/rtl_2heap_8c.html#a10">RtlpCreateUnCommittedRange</a>( Segment );
04375 
04376     <span class="keywordflow">if</span> (UnCommittedRange == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
04377 
04378         <a class="code" href="../../d9/d9/heappriv_8h.html#a10">HeapDebugPrint</a>(( <span class="stringliteral">"Abandoning uncommitted range (%x for %x)\n"</span>, Address, Size ));
04379         <span class="comment">// HeapDebugBreak( NULL );</span>
04380 
04381         <span class="keywordflow">return</span>;
04382     }
04383 
04384     <span class="comment">//</span>
04385     <span class="comment">//  Fill in the new uncommitted range structure</span>
04386     <span class="comment">//</span>
04387 
04388     UnCommittedRange-&gt;<a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html#o1">Address</a> = Address;
04389     UnCommittedRange-&gt;<a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html#o2">Size</a> = <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
04390 
04391     <span class="comment">//</span>
04392     <span class="comment">//  Insert it in the list for the segment</span>
04393     <span class="comment">//</span>
04394 
04395     UnCommittedRange-&gt;<a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html#o0">Next</a> = *pp;
04396     *pp = UnCommittedRange;
04397 
04398     <span class="comment">//</span>
04399     <span class="comment">//  Update the segment counters and notion of the largest uncommitted range</span>
04400     <span class="comment">//</span>
04401 
04402     Segment-&gt;NumberOfUnCommittedRanges += 1;
04403 
04404     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> &gt;= Segment-&gt;LargestUnCommittedRange) {
04405 
04406         Segment-&gt;LargestUnCommittedRange = <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
04407     }
04408 
04409     <span class="comment">//</span>
04410     <span class="comment">//  And return to our caller</span>
04411     <span class="comment">//</span>
04412 
04413     <span class="keywordflow">return</span>;
04414 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a21" doxytag="rtl/heap.c::RtlSizeHeap" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SIZE_T RtlSizeHeap           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>HeapHandle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Flags</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>BaseAddress</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l03655">3655</a> of file <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html">rtl/heap.c</a>.
<p>
References <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00103">DEBUG_HEAP</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00076">_HEAP_ENTRY::Flags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00323">_HEAP::ForceFlags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00236">HEAP_ENTRY_BUSY</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00239">HEAP_ENTRY_VIRTUAL_ALLOC</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00228">HEAP_GRANULARITY_SHIFT</a>, <a class="el" href="../../d5/d5/memory_8c-source.html#l00115">HeapHandle</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l01177">RtlDebugSizeHeap()</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l06070">RtlpGetSizeOfBigBlock()</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00104">SET_LAST_STATUS</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00045">_HEAP_ENTRY::Size</a>, and <a class="el" href="../../d4/d8/heap_8h-source.html#l00085">_HEAP_ENTRY::UnusedBytes</a>.
<p>
Referenced by <a class="el" href="../../d5/d7/handtabl_8c-source.html#l00828">HMAllocObject()</a>, <a class="el" href="../../d5/d7/handtabl_8c-source.html#l01069">HMFreeObject()</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l01177">RtlDebugSizeHeap()</a>, and <a class="el" href="../../d7/d8/heappage_8c-source.html#l04620">RtlpDphNormalHeapSize()</a>.
<p>
<pre class="fragment"><div>03663                    :
03664 
03665     This routine returns <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> size, in bytes, of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> indicated block
03666     of heap storage.  The size <a class="code" href="../../d3/d0/imm32_8def.html#a1">only</a> includes <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> number of bytes <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
03667     original caller used to allocate <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> block and not any unused
03668     bytes at <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> end of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> block.
03669 
03670 Arguments:
03671 
03672     <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a> - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap that owns <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> block
03673         being queried
03674 
03675     Flags - Supplies a set of flags used to allocate <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> block
03676 
03677     BaseAddress - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> address of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> block being queried
03678 
03679 Return Value:
03680 
03681     SIZE_T - returns <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> size, in bytes, of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> queried block, or -1
03682         <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> block <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> not in use.
03683 
03684 --*/
03685 
03686 {
03687     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap = (<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a>)<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
03688     <a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a> BusyBlock;
03689     SIZE_T BusySize;
03690 
03691     <span class="comment">//</span>
03692     <span class="comment">//  Compliment the input flags with those enforced by the heap</span>
03693     <span class="comment">//</span>
03694 
03695     Flags |= Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o3">ForceFlags</a>;
03696 
03697     <span class="comment">//</span>
03698     <span class="comment">//  Check if this is the nonkernel debug version of heap</span>
03699     <span class="comment">//</span>
03700 
03701 <span class="preprocessor">#ifndef NTOS_KERNEL_RUNTIME</span>
03702 <span class="preprocessor"></span>
03703     <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/heappriv_8h.html#a8">DEBUG_HEAP</a>( Flags )) {
03704 
03705         <span class="keywordflow">return</span> <a class="code" href="../../d4/d9/heapdbg_8c.html#a19">RtlDebugSizeHeap</a>( HeapHandle, Flags, BaseAddress );
03706     }
03707 
03708 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
03709 <span class="preprocessor"></span>
03710     <span class="comment">//</span>
03711     <span class="comment">//  No lock is required since nothing is modified and nothing</span>
03712     <span class="comment">//  outside the busy block is read.  Backup to get a pointer</span>
03713     <span class="comment">//  to the heap entry</span>
03714     <span class="comment">//</span>
03715 
03716     BusyBlock = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)BaseAddress - 1;
03717 
03718     <span class="comment">//</span>
03719     <span class="comment">//  If the block is not in use then the answer is -1 and</span>
03720     <span class="comment">//  we'll set the error status for the user mode thread</span>
03721     <span class="comment">//</span>
03722 
03723     <span class="keywordflow">if</span> (!(BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a8">HEAP_ENTRY_BUSY</a>)) {
03724 
03725         BusySize = -1;
03726 
03727         <a class="code" href="../../d9/d9/heappriv_8h.html#a9">SET_LAST_STATUS</a>( STATUS_INVALID_PARAMETER );
03728 
03729     <span class="comment">//</span>
03730     <span class="comment">//  Otherwise if the block is from our large allocation then</span>
03731     <span class="comment">//  we'll get the result from that routine</span>
03732     <span class="comment">//</span>
03733 
03734     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a11">HEAP_ENTRY_VIRTUAL_ALLOC</a>) {
03735 
03736         BusySize = <a class="code" href="../../d9/d9/heappriv_8h.html#a40">RtlpGetSizeOfBigBlock</a>( BusyBlock );
03737 
03738     <span class="comment">//</span>
03739     <span class="comment">//  Otherwise the block must be one that we can handle so</span>
03740     <span class="comment">//  calculate its block size and then subtract what's not being</span>
03741     <span class="comment">//  used by the caller.</span>
03742     <span class="comment">//</span>
03743     <span class="comment">//  **** this seems to include the heap entry header in its</span>
03744     <span class="comment">//  **** calculation.  Is that what we really want?</span>
03745     <span class="comment">//</span>
03746 
03747     } <span class="keywordflow">else</span> {
03748 
03749         BusySize = (BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a> &lt;&lt; <a class="code" href="../../d3/d9/heap_8h.html#a4">HEAP_GRANULARITY_SHIFT</a>) -
03750                    BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o4">UnusedBytes</a>;
03751     }
03752 
03753     <span class="comment">//</span>
03754     <span class="comment">//  And return to our caller</span>
03755     <span class="comment">//</span>
03756 
03757     <span class="keywordflow">return</span> BusySize;
03758 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a22" doxytag="rtl/heap.c::RtlZeroHeap" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS RtlZeroHeap           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>HeapHandle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Flags</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l03762">3762</a> of file <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html">rtl/heap.c</a>.
<p>
References <a class="el" href="../../d4/d8/heap_8h-source.html#l00254">_HEAP_UNCOMMMTTED_RANGE::Address</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00103">DEBUG_HEAP</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00055">EXCEPTION_EXECUTE_HANDLER</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00269">_HEAP_SEGMENT::FirstEntry</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00322">_HEAP::Flags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00076">_HEAP_ENTRY::Flags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00323">_HEAP::ForceFlags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00396">FREE_HEAP_FILL</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00236">HEAP_ENTRY_BUSY</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00238">HEAP_ENTRY_FILL_PATTERN</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00240">HEAP_ENTRY_LAST_ENTRY</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00228">HEAP_GRANULARITY_SHIFT</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00234">HEAP_MAXIMUM_SEGMENTS</a>, <a class="el" href="../../d5/d5/memory_8c-source.html#l00115">HeapHandle</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00270">_HEAP_SEGMENT::LastValidEntry</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00369">_HEAP::LockVariable</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00253">_HEAP_UNCOMMMTTED_RANGE::Next</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d6/d8/ntrtlp_8h-source.html#l00246">RTL_PAGED_CODE</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00078">RtlAcquireLockRoutine</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l01338">RtlDebugZeroHeap()</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00079">RtlReleaseLockRoutine</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00355">_HEAP::Segments</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00255">_HEAP_UNCOMMMTTED_RANGE::Size</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00045">_HEAP_ENTRY::Size</a>, <a class="el" href="../../d9/d6/lh__open_2pi__mem_8h-source.html#l00017">Size</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, and <a class="el" href="../../d4/d8/heap_8h-source.html#l00274">_HEAP_SEGMENT::UnCommittedRanges</a>.
<p>
Referenced by <a class="el" href="../../d2/d9/kernel_2exitwin_8c-source.html#l00324">EndShutdown()</a>, and <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l01338">RtlDebugZeroHeap()</a>.
<p>
<pre class="fragment"><div>03769                    :
03770 
03771     This routine zero's (or fills) in all <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> free blocks in a heap.
03772     It does not touch big allocations.
03773 
03774 Arguments:
03775 
03776     <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a> - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap being zeroed
03777 
03778     Flags - Supplies a set of heap flags to compliment those already
03779         set in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap
03780 
03781 Return Value:
03782 
03783     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> - An appropriate status code
03784 
03785 --*/
03786 
03787 {
03788     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap = (<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a>)<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
03789     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
03790     BOOLEAN LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03791     <a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html">PHEAP_SEGMENT</a> Segment;
03792     ULONG SegmentIndex;
03793     <a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a> CurrentBlock;
03794     <a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a> FreeBlock;
03795     SIZE_T <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
03796     <a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html">PHEAP_UNCOMMMTTED_RANGE</a> UnCommittedRange;
03797 
03798     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
03799 
03800     <span class="comment">//</span>
03801     <span class="comment">//  Compliment the input flags with those enforced by the heap</span>
03802     <span class="comment">//</span>
03803 
03804     Flags |= Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o3">ForceFlags</a>;
03805 
03806     <span class="comment">//</span>
03807     <span class="comment">//  Check if this is the nonkernel debug version of heap</span>
03808     <span class="comment">//</span>
03809 
03810 <span class="preprocessor">#ifndef NTOS_KERNEL_RUNTIME</span>
03811 <span class="preprocessor"></span>
03812     <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/heappriv_8h.html#a8">DEBUG_HEAP</a>( Flags )) {
03813 
03814         <span class="keywordflow">return</span> <a class="code" href="../../d4/d9/heapdbg_8c.html#a21">RtlDebugZeroHeap</a>( HeapHandle, Flags );
03815     }
03816 
03817 <span class="preprocessor">#endif // NTOS_KERNEL_RUNTIME</span>
03818 <span class="preprocessor"></span>
03819     <span class="comment">//</span>
03820     <span class="comment">//  Unless something happens otherwise we'll assume that we'll</span>
03821     <span class="comment">//  be successful</span>
03822     <span class="comment">//</span>
03823 
03824     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
03825 
03826     <span class="keywordflow">try</span> {
03827 
03828         <span class="comment">//</span>
03829         <span class="comment">//  Lock the heap</span>
03830         <span class="comment">//</span>
03831 
03832         <span class="keywordflow">if</span> (!(Flags &amp; HEAP_NO_SERIALIZE)) {
03833 
03834             <a class="code" href="../../d9/d9/heappriv_8h.html#a3">RtlAcquireLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
03835 
03836             LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03837         }
03838 
03839         <span class="keywordflow">try</span> {
03840 
03841             <span class="comment">//</span>
03842             <span class="comment">//  Zero fill all the free blocks in all the segements</span>
03843             <span class="comment">//</span>
03844 
03845             <span class="keywordflow">for</span> (SegmentIndex=0; SegmentIndex&lt;<a class="code" href="../../d3/d9/heap_8h.html#a7">HEAP_MAXIMUM_SEGMENTS</a>; SegmentIndex++) {
03846 
03847                 Segment = Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o22">Segments</a>[ SegmentIndex ];
03848 
03849                 <span class="keywordflow">if</span> (!Segment) {
03850 
03851                     <span class="keywordflow">continue</span>;
03852                 }
03853 
03854                 UnCommittedRange = Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o11">UnCommittedRanges</a>;
03855                 CurrentBlock = Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o7">FirstEntry</a>;
03856 
03857                 <span class="comment">//</span>
03858                 <span class="comment">//  With the current segment we'll zoom through the</span>
03859                 <span class="comment">//  blocks until we reach the end</span>
03860                 <span class="comment">//</span>
03861 
03862                 <span class="keywordflow">while</span> (CurrentBlock &lt; Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o8">LastValidEntry</a>) {
03863 
03864                     <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> = CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a> &lt;&lt; <a class="code" href="../../d3/d9/heap_8h.html#a4">HEAP_GRANULARITY_SHIFT</a>;
03865 
03866                     <span class="comment">//</span>
03867                     <span class="comment">//  If the block is not in use then we'll either zero</span>
03868                     <span class="comment">//  it or fill it.</span>
03869                     <span class="comment">//</span>
03870 
03871                     <span class="keywordflow">if</span> (!(CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a8">HEAP_ENTRY_BUSY</a>)) {
03872 
03873                         FreeBlock = (<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a>)CurrentBlock;
03874 
03875                         <span class="keywordflow">if</span> ((Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o2">Flags</a> &amp; HEAP_FREE_CHECKING_ENABLED) &amp;&amp;
03876                             (CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a10">HEAP_ENTRY_FILL_PATTERN</a>)) {
03877 
03878                             RtlFillMemoryUlong( FreeBlock + 1,
03879                                                 Size - <span class="keyword">sizeof</span>( *FreeBlock ),
03880                                                 FREE_HEAP_FILL );
03881 
03882                         } <span class="keywordflow">else</span> {
03883 
03884                             RtlFillMemoryUlong( FreeBlock + 1,
03885                                                 Size - <span class="keyword">sizeof</span>( *FreeBlock ),
03886                                                 0 );
03887                         }
03888                     }
03889 
03890                     <span class="comment">//</span>
03891                     <span class="comment">//  If the following entry is uncommited then we need to</span>
03892                     <span class="comment">//  skip over it.  This code strongly implies that the</span>
03893                     <span class="comment">//  uncommitted range list is in perfect sync with the</span>
03894                     <span class="comment">//  blocks in the segement</span>
03895                     <span class="comment">//</span>
03896 
03897                     <span class="keywordflow">if</span> (CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>) {
03898 
03899                         CurrentBlock += CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a>;
03900 
03901                         <span class="comment">//</span>
03902                         <span class="comment">//  Check if the we've reached the end of the segment</span>
03903                         <span class="comment">//  and should just break out of the while loop</span>
03904                         <span class="comment">//</span>
03905                         <span class="comment">//</span>
03906                         <span class="comment">//  **** "break;" would probably be more clear here</span>
03907                         <span class="comment">//</span>
03908 
03909                         <span class="keywordflow">if</span> (UnCommittedRange == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03910 
03911                             CurrentBlock = Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o8">LastValidEntry</a>;
03912 
03913                         <span class="comment">//</span>
03914                         <span class="comment">//  Otherwise skip over the uncommitted range</span>
03915                         <span class="comment">//</span>
03916 
03917                         } <span class="keywordflow">else</span> {
03918 
03919                             CurrentBlock = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)
03920                                 ((PCHAR)UnCommittedRange-&gt;<a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html#o1">Address</a> + UnCommittedRange-&gt;<a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html#o2">Size</a>);
03921 
03922                             UnCommittedRange = UnCommittedRange-&gt;<a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html#o0">Next</a>;
03923                         }
03924 
03925                     <span class="comment">//</span>
03926                     <span class="comment">//  Otherwise the next block exists so advance to it</span>
03927                     <span class="comment">//</span>
03928 
03929                     } <span class="keywordflow">else</span> {
03930 
03931                         CurrentBlock += CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a>;
03932                     }
03933                 }
03934             }
03935 
03936         } except( EXCEPTION_EXECUTE_HANDLER ) {
03937 
03938             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = GetExceptionCode();
03939         }
03940 
03941     } finally {
03942 
03943         <span class="comment">//</span>
03944         <span class="comment">//  Unlock the heap</span>
03945         <span class="comment">//</span>
03946 
03947         <span class="keywordflow">if</span> (LockAcquired) {
03948 
03949             <a class="code" href="../../d9/d9/heappriv_8h.html#a4">RtlReleaseLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
03950         }
03951     }
03952 
03953     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
03954 }

</div></pre>    </td>
  </tr>
</table>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="a3" doxytag="rtl/heap.c::CheckHeapFillPattern" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> UCHAR <a class="el" href="../../d9/d9/heappriv_8h.html#a23">CheckHeapFillPattern</a>[CHECK_HEAP_TAIL_SIZE]          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Initial value:</b><pre class="fragment"><div> {
    <a class="code" href="../../d3/d9/heap_8h.html#a26">CHECK_HEAP_TAIL_FILL</a>,
    <a class="code" href="../../d3/d9/heap_8h.html#a26">CHECK_HEAP_TAIL_FILL</a>,
    <a class="code" href="../../d3/d9/heap_8h.html#a26">CHECK_HEAP_TAIL_FILL</a>,
    <a class="code" href="../../d3/d9/heap_8h.html#a26">CHECK_HEAP_TAIL_FILL</a>,
    <a class="code" href="../../d3/d9/heap_8h.html#a26">CHECK_HEAP_TAIL_FILL</a>,
    <a class="code" href="../../d3/d9/heap_8h.html#a26">CHECK_HEAP_TAIL_FILL</a>,
    <a class="code" href="../../d3/d9/heap_8h.html#a26">CHECK_HEAP_TAIL_FILL</a>,










    <a class="code" href="../../d3/d9/heap_8h.html#a26">CHECK_HEAP_TAIL_FILL</a>
}
</div></pre>
<p>
Definition at line <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l00043">43</a> of file <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html">rtl/heap.c</a>.
<p>
Referenced by <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l06117">RtlpCheckBusyBlockTail()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a2" doxytag="rtl/heap.c::RtlpDisableHeapLookaside" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ULONG <a class="el" href="../../d1/d9/rtl_2heap_8c.html#a2">RtlpDisableHeapLookaside</a> = 0          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l00029">29</a> of file <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html">rtl/heap.c</a>.
<p>
Referenced by <a class="el" href="../../d9/d1/ldrinit_8c-source.html#l00186">LdrpInitialize()</a>, and <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l00191">RtlCreateHeap()</a>.    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:44:03 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
