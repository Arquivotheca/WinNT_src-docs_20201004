<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: write.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>write.c</h1><a href="../../d0/d0/io_2write_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1989-1993  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    write.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module contains the code to implement the NtWriteFile system service.</span>
00012 <span class="comment"></span>
00013 <span class="comment">Author:</span>
00014 <span class="comment"></span>
00015 <span class="comment">    Darryl E. Havens (darrylh) 14-Apr-1989</span>
00016 <span class="comment"></span>
00017 <span class="comment">Environment:</span>
00018 <span class="comment"></span>
00019 <span class="comment">    Kernel mode</span>
00020 <span class="comment"></span>
00021 <span class="comment">Revision History:</span>
00022 <span class="comment"></span>
00023 <span class="comment"></span>
00024 <span class="comment">--*/</span>
00025 
00026 <span class="preprocessor">#include "<a class="code" href="../../d0/d6/iop_8h.html">iop.h</a>"</span>
00027 
00028 <span class="preprocessor">#ifdef ALLOC_PRAGMA</span>
00029 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, NtWriteFile)</span>
00030 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, NtWriteFile64)</span>
00031 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, NtWriteFileGather)</span>
00032 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00033 <span class="preprocessor"></span>
00034 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00035"></a><a class="code" href="../../d0/d0/io_2write_8c.html#a0">00035</a> <a class="code" href="../../d0/d0/io_2write_8c.html#a0">NtWriteFile</a>(
00036     IN HANDLE FileHandle,
00037     IN HANDLE Event OPTIONAL,
00038     IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
00039     IN PVOID ApcContext OPTIONAL,
00040     OUT PIO_STATUS_BLOCK IoStatusBlock,
00041     IN PVOID Buffer,
00042     IN ULONG Length,
00043     IN PLARGE_INTEGER ByteOffset OPTIONAL,
00044     IN PULONG Key OPTIONAL
00045     )
00046 
00047 <span class="comment">/*++</span>
00048 <span class="comment"></span>
00049 <span class="comment">Routine Description:</span>
00050 <span class="comment"></span>
00051 <span class="comment">    This service writes Length bytes of data from the caller's Buffer to the</span>
00052 <span class="comment">    file associated with FileHandle starting at StartingBlock|ByteOffset.</span>
00053 <span class="comment">    The actual number of bytes written to the file will be returned in the</span>
00054 <span class="comment">    second longword of the IoStatusBlock.</span>
00055 <span class="comment"></span>
00056 <span class="comment">    If the writer has the file open for APPEND access, then the data will be</span>
00057 <span class="comment">    written to the current EOF mark.  The StartingBlock and ByteOffset are</span>
00058 <span class="comment">    ignored if the caller has APPEND access.</span>
00059 <span class="comment"></span>
00060 <span class="comment">Arguments:</span>
00061 <span class="comment"></span>
00062 <span class="comment">    FileHandle - Supplies a handle to the file to be written.</span>
00063 <span class="comment"></span>
00064 <span class="comment">    Event - Optionally supplies an event to be set to the Signaled state when</span>
00065 <span class="comment">        the write operation is complete.</span>
00066 <span class="comment"></span>
00067 <span class="comment">    ApcRoutine - Optionally supplies an APC routine to be executed when the</span>
00068 <span class="comment">        write operation is complete.</span>
00069 <span class="comment"></span>
00070 <span class="comment">    ApcContext - Supplies a context parameter to be passed to the APC routine</span>
00071 <span class="comment">        when it is invoked, if an APC routine was specified.</span>
00072 <span class="comment"></span>
00073 <span class="comment">    IoStatusBlock - Supplies the address of the caller's I/O status block.</span>
00074 <span class="comment"></span>
00075 <span class="comment">    Buffer - Supplies the address of the buffer containing data to be written</span>
00076 <span class="comment">        to the file.</span>
00077 <span class="comment"></span>
00078 <span class="comment">    Length - Length, in bytes, of the data to be written to the file.</span>
00079 <span class="comment"></span>
00080 <span class="comment">    ByteOffset - Specifies the starting byte offset within the file to begin</span>
00081 <span class="comment">        the write operation.  If not specified and the file is open for</span>
00082 <span class="comment">        synchronous I/O, then the current file position is used.  If the</span>
00083 <span class="comment">        file is not opened for synchronous I/O and the parameter is not</span>
00084 <span class="comment">        specified, then it is in error.</span>
00085 <span class="comment"></span>
00086 <span class="comment">    Key - Optionally specifies a key to be used if there are locks associated</span>
00087 <span class="comment">        with the file.</span>
00088 <span class="comment"></span>
00089 <span class="comment">Return Value:</span>
00090 <span class="comment"></span>
00091 <span class="comment">    The status returned is success if the write operation was properly queued</span>
00092 <span class="comment">    to the I/O system.  Once the write completes the status of the operation</span>
00093 <span class="comment">    can be determined by examining the Status field of the I/O status block.</span>
00094 <span class="comment"></span>
00095 <span class="comment">--*/</span>
00096 
00097 {
00098     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
00099     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
00100     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> fileObject;
00101     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> deviceObject;
00102     <a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html">PFAST_IO_DISPATCH</a> fastIoDispatch;
00103     <a class="code" href="../../d0/d9/ntosdef_8h.html#a39">KPROCESSOR_MODE</a> requestorMode;
00104     <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> mdl;
00105     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpSp;
00106     ACCESS_MASK grantedAccess;
00107     <a class="code" href="../../d3/d5/struct__OBJECT__HANDLE__INFORMATION.html">OBJECT_HANDLE_INFORMATION</a> handleInformation;
00108     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> exceptionCode;
00109     BOOLEAN synchronousIo;
00110     <a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a> eventObject = (<a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00111     ULONG keyValue = 0;
00112     LARGE_INTEGER fileOffset = {0,0};
00113     PULONG majorFunction;
00114 
00115     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00116 
00117     <span class="comment">//</span>
00118     <span class="comment">// Get the previous mode;  i.e., the mode of the caller.</span>
00119     <span class="comment">//</span>
00120 
00121     requestorMode = KeGetPreviousMode();
00122 
00123     <span class="comment">//</span>
00124     <span class="comment">// Reference the file object so the target device can be found and the</span>
00125     <span class="comment">// access rights mask can be used in the following checks for callers in</span>
00126     <span class="comment">// user mode.  Note that if the handle does not refer to a file object,</span>
00127     <span class="comment">// then it will fail.</span>
00128     <span class="comment">//</span>
00129 
00130     status = <a class="code" href="../../d7/d1/obref_8c.html#a4">ObReferenceObjectByHandle</a>( FileHandle,
00131                                         0<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>,
00132                                         <a class="code" href="../../d5/d8/fssup_8c.html#a3">IoFileObjectType</a>,
00133                                         requestorMode,
00134                                         (PVOID *) &amp;fileObject,
00135                                         &amp;handleInformation);
00136     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
00137         <span class="keywordflow">return</span> status;
00138     }
00139 
00140     grantedAccess = handleInformation.<a class="code" href="../../d3/d5/struct__OBJECT__HANDLE__INFORMATION.html#o1">GrantedAccess</a>;
00141 
00142     <span class="comment">//</span>
00143     <span class="comment">// Get the address of the target device object.</span>
00144     <span class="comment">//</span>
00145 
00146     deviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a76">IoGetRelatedDeviceObject</a>( fileObject );
00147 
00148     <span class="comment">//</span>
00149     <span class="comment">// Check to see if the requestor mode was user.  If so, perform a bunch</span>
00150     <span class="comment">// of extra checks.</span>
00151     <span class="comment">//</span>
00152 
00153     <span class="keywordflow">if</span> (requestorMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
00154 
00155         <span class="comment">//</span>
00156         <span class="comment">// The caller's access mode is not kernel so probe each of the arguments</span>
00157         <span class="comment">// and capture them as necessary.  If any failures occur, the condition</span>
00158         <span class="comment">// handler will be invoked to handle them.  It will simply cleanup and</span>
00159         <span class="comment">// return an access violation status code back to the system service</span>
00160         <span class="comment">// dispatcher.</span>
00161         <span class="comment">//</span>
00162 
00163         <span class="comment">//</span>
00164         <span class="comment">// Check to ensure that the caller has either WRITE_DATA or APPEND_DATA</span>
00165         <span class="comment">// access to the file.  If not, cleanup and return an access denied</span>
00166         <span class="comment">// error status value.  Note that if this is a pipe then the APPEND_DATA</span>
00167         <span class="comment">// access check may not be made since this access code is overlaid with</span>
00168         <span class="comment">// CREATE_PIPE_INSTANCE access.</span>
00169         <span class="comment">//</span>
00170 
00171         <span class="keywordflow">if</span> (!<a class="code" href="../../d0/d5/se_8h.html#a9">SeComputeGrantedAccesses</a>( grantedAccess, (!(fileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a157">FO_NAMED_PIPE</a>) ? FILE_APPEND_DATA : 0) | FILE_WRITE_DATA )) {
00172             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
00173             <span class="keywordflow">return</span> STATUS_ACCESS_DENIED;
00174         }
00175 
00176         <span class="comment">//</span>
00177         <span class="comment">// Attempt to probe the caller's parameters within the exception</span>
00178         <span class="comment">// handler block.</span>
00179         <span class="comment">//</span>
00180 
00181         <span class="keywordflow">try</span> {
00182 
00183             <span class="comment">//</span>
00184             <span class="comment">// The IoStatusBlock parameter must be writeable by the caller.</span>
00185             <span class="comment">//</span>
00186 
00187             <a class="code" href="../../d5/d8/ex_8h.html#a32">ProbeForWriteIoStatusEx</a>( IoStatusBlock , ApcRoutine);
00188 
00189             <span class="comment">//</span>
00190             <span class="comment">// The caller's data buffer must be readable from the caller's</span>
00191             <span class="comment">// mode.  This check ensures that this is the case.  Since the</span>
00192             <span class="comment">// buffer address is captured, the caller cannot change it,</span>
00193             <span class="comment">// even though he/she can change the protection from another</span>
00194             <span class="comment">// thread.  This error will be caught by the probe/lock or</span>
00195             <span class="comment">// buffer copy operations later.</span>
00196             <span class="comment">//</span>
00197 
00198             <a class="code" href="../../d5/d8/ex_8h.html#a11">ProbeForRead</a>( <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>, Length, <span class="keyword">sizeof</span>( UCHAR ) );
00199 
00200             <span class="comment">//</span>
00201             <span class="comment">// If this file has an I/O completion port associated w/it, then</span>
00202             <span class="comment">// ensure that the caller did not supply an APC routine, as the</span>
00203             <span class="comment">// two are mutually exclusive methods for I/O completion</span>
00204             <span class="comment">// notification.</span>
00205             <span class="comment">//</span>
00206 
00207             <span class="keywordflow">if</span> (fileObject-&gt;CompletionContext &amp;&amp; <a class="code" href="../../d0/d6/iop_8h.html#a19">IopApcRoutinePresent</a>( ApcRoutine )) {
00208                 <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
00209                 <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
00210             }
00211 
00212             <span class="comment">//</span>
00213             <span class="comment">// Check that the ByteOffset parameter is readable from the</span>
00214             <span class="comment">// caller's mode, if one was specified, and capture it.</span>
00215             <span class="comment">//</span>
00216 
00217             <span class="keywordflow">if</span> (ARGUMENT_PRESENT( ByteOffset )) {
00218                 <a class="code" href="../../d5/d8/ex_8h.html#a11">ProbeForRead</a>( ByteOffset,
00219                               <span class="keyword">sizeof</span>( LARGE_INTEGER ),
00220                               <span class="keyword">sizeof</span>( ULONG ) );
00221                 fileOffset = *ByteOffset;
00222             }
00223 
00224             <span class="comment">//</span>
00225             <span class="comment">// Check to see whether the caller has opened the file without</span>
00226             <span class="comment">// intermediate buffering.  If so, perform the following Buffer</span>
00227             <span class="comment">// and ByteOffset parameter checks differently.</span>
00228             <span class="comment">//</span>
00229 
00230             <span class="keywordflow">if</span> (fileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a153">FO_NO_INTERMEDIATE_BUFFERING</a>) {
00231 
00232                 <span class="comment">//</span>
00233                 <span class="comment">// The file was opened without intermediate buffering enabled.</span>
00234                 <span class="comment">// Check that the Buffer is properly aligned, and that the</span>
00235                 <span class="comment">// length is an integral number of the block size.</span>
00236                 <span class="comment">//</span>
00237 
00238                 <span class="keywordflow">if</span> ((deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o23">SectorSize</a> &amp;&amp;
00239                     (Length &amp; (deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o23">SectorSize</a> - 1))) ||
00240                     (ULONG_PTR) <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> &amp; deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o17">AlignmentRequirement</a>) {
00241 
00242                     <span class="comment">//</span>
00243                     <span class="comment">// Check for sector sizes that are not a power of two.</span>
00244                     <span class="comment">//</span>
00245 
00246                     <span class="keywordflow">if</span> ((deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o23">SectorSize</a> &amp;&amp;
00247                         Length % deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o23">SectorSize</a>) ||
00248                         (ULONG_PTR) <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> &amp; deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o17">AlignmentRequirement</a>) {
00249                         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
00250                         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
00251                     }
00252                 }
00253 
00254                 <span class="comment">//</span>
00255                 <span class="comment">// If a ByteOffset parameter was specified, ensure that it is</span>
00256                 <span class="comment">// is of the proper type.</span>
00257                 <span class="comment">//</span>
00258 
00259                 <span class="keywordflow">if</span> (ARGUMENT_PRESENT( ByteOffset )) {
00260                     <span class="keywordflow">if</span> (fileOffset.LowPart == FILE_WRITE_TO_END_OF_FILE &amp;&amp;
00261                         fileOffset.HighPart == -1) {
00262                         NOTHING;
00263                     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fileOffset.LowPart == FILE_USE_FILE_POINTER_POSITION &amp;&amp;
00264                                fileOffset.HighPart == -1 &amp;&amp;
00265                                (fileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a151">FO_SYNCHRONOUS_IO</a>)) {
00266                         NOTHING;
00267                     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o23">SectorSize</a> &amp;&amp;
00268                         (fileOffset.LowPart &amp; (deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o23">SectorSize</a> - 1))) {
00269                         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
00270                         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
00271                     }
00272                 }
00273             }
00274 
00275             <span class="comment">//</span>
00276             <span class="comment">// Finally, ensure that if there is a key parameter specified it</span>
00277             <span class="comment">// is readable by the caller.</span>
00278             <span class="comment">//</span>
00279 
00280             <span class="keywordflow">if</span> (ARGUMENT_PRESENT( <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a51">Key</a> )) {
00281                 keyValue = <a class="code" href="../../d5/d8/ex_8h.html#a20">ProbeAndReadUlong</a>( <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a51">Key</a> );
00282             }
00283 
00284         } except(<a class="code" href="../../d0/d6/iop_8h.html#a169">IopExceptionFilter</a>( GetExceptionInformation(), &amp;exceptionCode )) {
00285 
00286             <span class="comment">//</span>
00287             <span class="comment">// An exception was incurred while attempting to probe the</span>
00288             <span class="comment">// caller's parameters.  Simply cleanup, dereference the file</span>
00289             <span class="comment">// object, and return with the appropriate status code.</span>
00290             <span class="comment">//</span>
00291 
00292             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
00293             <span class="keywordflow">return</span> exceptionCode;
00294 
00295         }
00296 
00297     } <span class="keywordflow">else</span> {
00298 
00299         <span class="comment">//</span>
00300         <span class="comment">// The caller's mode is kernel.  Get the appropriate parameters to</span>
00301         <span class="comment">// their expected locations without making all of the checks.</span>
00302         <span class="comment">//</span>
00303 
00304         <span class="keywordflow">if</span> (ARGUMENT_PRESENT( ByteOffset )) {
00305             fileOffset = *ByteOffset;
00306         }
00307 
00308         <span class="keywordflow">if</span> (ARGUMENT_PRESENT( <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a51">Key</a> )) {
00309             keyValue = *<a class="code" href="../../d2/d0/nt6_2user32_8def.html#a51">Key</a>;
00310         }
00311 <span class="preprocessor">#if DBG</span>
00312 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (fileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a153">FO_NO_INTERMEDIATE_BUFFERING</a>) {
00313 
00314             <span class="comment">//</span>
00315             <span class="comment">// The file was opened without intermediate buffering enabled.</span>
00316             <span class="comment">// Check that the Buffer is properly aligned, and that the</span>
00317             <span class="comment">// length is an integral number of the block size.</span>
00318             <span class="comment">//</span>
00319 
00320             <span class="keywordflow">if</span> ((deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o23">SectorSize</a> &amp;&amp;
00321                 (Length &amp; (deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o23">SectorSize</a> - 1))) ||
00322                 (ULONG_PTR) <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> &amp; deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o17">AlignmentRequirement</a>) {
00323 
00324                 <span class="comment">//</span>
00325                 <span class="comment">// Check for sector sizes that are not a power of two.</span>
00326                 <span class="comment">//</span>
00327 
00328                 <span class="keywordflow">if</span> ((deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o23">SectorSize</a> &amp;&amp;
00329                     Length % deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o23">SectorSize</a>) ||
00330                     (ULONG_PTR) <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> &amp; deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o17">AlignmentRequirement</a>) {
00331                     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
00332                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00333                     <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
00334                 }
00335             }
00336 
00337             <span class="comment">//</span>
00338             <span class="comment">// If a ByteOffset parameter was specified, ensure that it is</span>
00339             <span class="comment">// is of the proper type.</span>
00340             <span class="comment">//</span>
00341 
00342             <span class="keywordflow">if</span> (ARGUMENT_PRESENT( ByteOffset )) {
00343                 <span class="keywordflow">if</span> (fileOffset.LowPart == FILE_WRITE_TO_END_OF_FILE &amp;&amp;
00344                     fileOffset.HighPart == -1) {
00345                     NOTHING;
00346                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fileOffset.LowPart == FILE_USE_FILE_POINTER_POSITION &amp;&amp;
00347                            fileOffset.HighPart == -1 &amp;&amp;
00348                            (fileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a151">FO_SYNCHRONOUS_IO</a>)) {
00349                     NOTHING;
00350                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o23">SectorSize</a> &amp;&amp;
00351                     (fileOffset.LowPart &amp; (deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o23">SectorSize</a> - 1))) {
00352                     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
00353                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00354                     <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
00355                 }
00356             }
00357         }
00358 <span class="preprocessor">#endif // DBG</span>
00359 <span class="preprocessor"></span>
00360     }
00361 
00362     <span class="comment">//</span>
00363     <span class="comment">// If the caller has only append access to the file, ignore the input</span>
00364     <span class="comment">// parameters and set the ByteOffset to indicate that this write is</span>
00365     <span class="comment">// to the end of the file.  Otherwise, ensure that the parameters are</span>
00366     <span class="comment">// valid.</span>
00367     <span class="comment">//</span>
00368 
00369     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d5/se_8h.html#a9">SeComputeGrantedAccesses</a>( grantedAccess, FILE_APPEND_DATA | FILE_WRITE_DATA ) == FILE_APPEND_DATA) {
00370 
00371         <span class="comment">//</span>
00372         <span class="comment">// This is an append operation to the end of a file.  Set the</span>
00373         <span class="comment">// ByteOffset parameter to give drivers a consistent view of</span>
00374         <span class="comment">// this type of call.</span>
00375         <span class="comment">//</span>
00376 
00377         fileOffset.LowPart = FILE_WRITE_TO_END_OF_FILE;
00378         fileOffset.HighPart = -1;
00379     }
00380 
00381     <span class="comment">//</span>
00382     <span class="comment">// Get the address of the event object and set the event to the Not-</span>
00383     <span class="comment">// Signaled state, if an event was specified.  Note here too, that if</span>
00384     <span class="comment">// the handle does not refer to an event, then the reference will fail.</span>
00385     <span class="comment">//</span>
00386 
00387     <span class="keywordflow">if</span> (ARGUMENT_PRESENT( <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a> )) {
00388         status = <a class="code" href="../../d7/d1/obref_8c.html#a4">ObReferenceObjectByHandle</a>( <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>,
00389                                             EVENT_MODIFY_STATE,
00390                                             <a class="code" href="../../d7/d7/ntapi_8c.html#a3">ExEventObjectType</a>,
00391                                             requestorMode,
00392                                             (PVOID *) &amp;eventObject,
00393                                             <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00394         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
00395             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
00396             <span class="keywordflow">return</span> status;
00397         } <span class="keywordflow">else</span> {
00398             <a class="code" href="../../d4/d9/ke_8h.html#a21">KeClearEvent</a>( eventObject );
00399         }
00400     }
00401 
00402     <span class="comment">//</span>
00403     <span class="comment">// Get the address of the fast io dispatch structure.</span>
00404     <span class="comment">//</span>
00405 
00406     fastIoDispatch = deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o3">DriverObject</a>-&gt;<a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html#o10">FastIoDispatch</a>;
00407 
00408     <span class="comment">//</span>
00409     <span class="comment">// Make a special check here to determine whether this is a synchronous</span>
00410     <span class="comment">// I/O operation.  If it is, then wait here until the file is owned by</span>
00411     <span class="comment">// the current thread.  If the wait terminates with an alerted status,</span>
00412     <span class="comment">// then cleanup and return the alerted status.  This allows the caller</span>
00413     <span class="comment">// specify FILE_SYNCHRONOUS_IO_ALERT as a synchronous I/O option.</span>
00414     <span class="comment">//</span>
00415     <span class="comment">// If everything works, then check to see whether a ByteOffset parameter</span>
00416     <span class="comment">// was supplied.  If not, or if it was and it is set to the "use file</span>
00417     <span class="comment">// pointer position", then initialize the file offset to be whatever</span>
00418     <span class="comment">// the current byte offset into the file is according to the file pointer</span>
00419     <span class="comment">// context information in the file object.</span>
00420     <span class="comment">//</span>
00421 
00422     <span class="keywordflow">if</span> (fileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a151">FO_SYNCHRONOUS_IO</a>) {
00423 
00424         BOOLEAN interrupted;
00425 
00426         <span class="keywordflow">if</span> (!<a class="code" href="../../d0/d6/iop_8h.html#a13">IopAcquireFastLock</a>( fileObject )) {
00427             status = <a class="code" href="../../d0/d6/iop_8h.html#a147">IopAcquireFileObjectLock</a>( fileObject,
00428                                                requestorMode,
00429                                                (BOOLEAN) ((fileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a152">FO_ALERTABLE_IO</a>) != 0),
00430                                                &amp;interrupted );
00431             <span class="keywordflow">if</span> (interrupted) {
00432                 <span class="keywordflow">if</span> (eventObject) {
00433                     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( eventObject );
00434                 }
00435                 <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
00436                 <span class="keywordflow">return</span> status;
00437             }
00438         }
00439 
00440         synchronousIo = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00441 
00442         <span class="keywordflow">if</span> ((!ARGUMENT_PRESENT( ByteOffset ) &amp;&amp; !fileOffset.LowPart ) ||
00443             (fileOffset.LowPart == FILE_USE_FILE_POINTER_POSITION &amp;&amp;
00444             fileOffset.HighPart == -1 )) {
00445             fileOffset = fileObject-&gt;CurrentByteOffset;
00446         }
00447 
00448         <span class="comment">//</span>
00449         <span class="comment">// Turbo write support.  If the file is currently cached on this</span>
00450         <span class="comment">// file object, then call the Cache Manager directly via FsRtl</span>
00451         <span class="comment">// and try to successfully complete the request here.  Note if</span>
00452         <span class="comment">// FastIoWrite returns FALSE or we get an I/O error, we simply</span>
00453         <span class="comment">// fall through and go the "long way" and create an Irp.</span>
00454         <span class="comment">//</span>
00455 
00456         <span class="keywordflow">if</span> (fileObject-&gt;PrivateCacheMap) {
00457 
00458             IO_STATUS_BLOCK localIoStatus;
00459 
00460             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(fastIoDispatch &amp;&amp; fastIoDispatch-&gt;<a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html#o3">FastIoWrite</a>);
00461 
00462             <span class="comment">//</span>
00463             <span class="comment">//  Negative file offsets are illegal.</span>
00464             <span class="comment">//</span>
00465 
00466             <span class="keywordflow">if</span> (fileOffset.HighPart &lt; 0 &amp;&amp;
00467                 (fileOffset.HighPart != -1 ||
00468                 fileOffset.LowPart != FILE_WRITE_TO_END_OF_FILE)) {
00469 
00470                 <span class="keywordflow">if</span> (eventObject) {
00471                     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( eventObject );
00472                 }
00473                 <a class="code" href="../../d0/d6/iop_8h.html#a22">IopReleaseFileObjectLock</a>( fileObject );
00474                 <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
00475                 <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
00476             }
00477 
00478             <span class="keywordflow">if</span> (fastIoDispatch-&gt;<a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html#o3">FastIoWrite</a>( fileObject,
00479                                              &amp;fileOffset,
00480                                              Length,
00481                                              <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
00482                                              keyValue,
00483                                              <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>,
00484                                              &amp;localIoStatus,
00485                                              deviceObject )
00486 
00487                     &amp;&amp;
00488 
00489                 (localIoStatus.Status == STATUS_SUCCESS)) {
00490 
00491                 <a class="code" href="../../d4/d6/iosubs_8c.html#a131">IopUpdateWriteOperationCount</a>( );
00492                 <a class="code" href="../../d4/d6/iosubs_8c.html#a134">IopUpdateWriteTransferCount</a>( (ULONG)localIoStatus.Information );
00493 
00494                 <span class="comment">//</span>
00495                 <span class="comment">// Carefully return the I/O status.</span>
00496 
00497                 <span class="keywordflow">try</span> {
00498                     *IoStatusBlock = localIoStatus;
00499                 } except( <a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a> ) {
00500                     localIoStatus.Status = GetExceptionCode();
00501                     localIoStatus.Information = 0;
00502                 }
00503 
00504                 <span class="comment">//</span>
00505                 <span class="comment">// If an event was specified, set it.</span>
00506                 <span class="comment">//</span>
00507 
00508                 <span class="keywordflow">if</span> (ARGUMENT_PRESENT( <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a> )) {
00509                     <a class="code" href="../../d2/d8/eventobj_8c.html#a8">KeSetEvent</a>( eventObject, 0, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00510                     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( eventObject );
00511                 }
00512 
00513                 <span class="comment">//</span>
00514                 <span class="comment">// Note that the file object event need not be set to the</span>
00515                 <span class="comment">// Signaled state, as it is already set.</span>
00516                 <span class="comment">//</span>
00517 
00518                 <span class="comment">//</span>
00519                 <span class="comment">// Cleanup and return.</span>
00520                 <span class="comment">//</span>
00521 
00522                 <a class="code" href="../../d0/d6/iop_8h.html#a22">IopReleaseFileObjectLock</a>( fileObject );
00523                 <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
00524                 <span class="keywordflow">return</span> localIoStatus.Status;
00525             }
00526         }
00527 
00528     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!ARGUMENT_PRESENT( ByteOffset ) &amp;&amp; !(fileObject-&gt;Flags &amp; (<a class="code" href="../../d0/d5/io_8h.html#a157">FO_NAMED_PIPE</a> | <a class="code" href="../../d0/d5/io_8h.html#a159">FO_MAILSLOT</a>))) {
00529 
00530         <span class="comment">//</span>
00531         <span class="comment">// The file is not open for synchronous I/O operations, but the</span>
00532         <span class="comment">// caller did not specify a ByteOffset parameter.  This is an error</span>
00533         <span class="comment">// situation, so cleanup and return with the appropriate status.</span>
00534         <span class="comment">//</span>
00535 
00536         <span class="keywordflow">if</span> (eventObject) {
00537             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( eventObject );
00538         }
00539         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
00540         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
00541 
00542     } <span class="keywordflow">else</span> {
00543 
00544         <span class="comment">//</span>
00545         <span class="comment">// This is not a synchronous I/O operation.</span>
00546         <span class="comment">//</span>
00547 
00548         synchronousIo = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00549     }
00550 
00551     <span class="comment">//</span>
00552     <span class="comment">//  Negative file offsets are illegal.</span>
00553     <span class="comment">//</span>
00554 
00555     <span class="keywordflow">if</span> (fileOffset.HighPart &lt; 0 &amp;&amp;
00556         (fileOffset.HighPart != -1 ||
00557         fileOffset.LowPart != FILE_WRITE_TO_END_OF_FILE)) {
00558 
00559         <span class="keywordflow">if</span> (eventObject) {
00560             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( eventObject );
00561         }
00562         <span class="keywordflow">if</span> (synchronousIo) {
00563             <a class="code" href="../../d0/d6/iop_8h.html#a22">IopReleaseFileObjectLock</a>( fileObject );
00564         }
00565         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
00566         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
00567     }
00568 
00569     <span class="comment">//</span>
00570     <span class="comment">// Set the file object to the Not-Signaled state.</span>
00571     <span class="comment">//</span>
00572 
00573     <a class="code" href="../../d4/d9/ke_8h.html#a21">KeClearEvent</a>( &amp;fileObject-&gt;Event );
00574 
00575     <span class="comment">//</span>
00576     <span class="comment">// Allocate and initialize the I/O Request Packet (IRP) for this operation.</span>
00577     <span class="comment">// The allocation is performed with an exception handler in case the</span>
00578     <span class="comment">// caller does not have enough quota to allocate the packet.</span>
00579     <span class="comment">//</span>
00580 
00581     irp = <a class="code" href="../../d0/d6/iop_8h.html#a16">IopAllocateIrp</a>( deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o13">StackSize</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
00582     <span class="keywordflow">if</span> (!irp) {
00583 
00584         <span class="comment">//</span>
00585         <span class="comment">// An IRP could not be allocated.  Cleanup and return an appropriate</span>
00586         <span class="comment">// error status code.</span>
00587         <span class="comment">//</span>
00588 
00589         <a class="code" href="../../d0/d6/iop_8h.html#a148">IopAllocateIrpCleanup</a>( fileObject, eventObject );
00590 
00591         <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
00592     }
00593     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.OriginalFileObject = fileObject;
00594     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.Thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
00595     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.AuxiliaryBuffer = (PVOID) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00596     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o10">RequestorMode</a> = requestorMode;
00597     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o11">PendingReturned</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00598     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o14">Cancel</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00599     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o25">CancelRoutine</a> = (<a class="code" href="../../d0/d5/io_8h.html#a286">PDRIVER_CANCEL</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00600 
00601     <span class="comment">//</span>
00602     <span class="comment">// Fill in the service independent parameters in the IRP.</span>
00603     <span class="comment">//</span>
00604 
00605     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o19">UserEvent</a> = eventObject;
00606     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o18">UserIosb</a> = IoStatusBlock;
00607     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o24">Overlay</a>.AsynchronousParameters.UserApcRoutine = ApcRoutine;
00608     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o24">Overlay</a>.AsynchronousParameters.UserApcContext = ApcContext;
00609 
00610     <span class="comment">//</span>
00611     <span class="comment">// Get a pointer to the stack location for the first driver.  This will be</span>
00612     <span class="comment">// used to pass the original function codes and parameters.  Note that</span>
00613     <span class="comment">// setting the major function code here also sets:</span>
00614     <span class="comment">//</span>
00615     <span class="comment">//      MinorFunction = 0;</span>
00616     <span class="comment">//      Flags = 0;</span>
00617     <span class="comment">//      Control = 0;</span>
00618     <span class="comment">//</span>
00619 
00620     irpSp = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>( irp );
00621     majorFunction = (PULONG) irpSp;
00622     *majorFunction = <a class="code" href="../../d0/d5/io_8h.html#a17">IRP_MJ_WRITE</a>;
00623     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a> = fileObject;
00624     <span class="keywordflow">if</span> (fileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a154">FO_WRITE_THROUGH</a>) {
00625         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o2">Flags</a> = <a class="code" href="../../d0/d5/io_8h.html#a204">SL_WRITE_THROUGH</a>;
00626     }
00627 
00628     <span class="comment">//</span>
00629     <span class="comment">// Now determine whether this device expects to have data buffered to it</span>
00630     <span class="comment">// or whether it performs direct I/O.  This is based on the DO_BUFFERED_IO</span>
00631     <span class="comment">// flag in the device object.  If the flag is set, then a system buffer is</span>
00632     <span class="comment">// allocated and the caller's data is copied into it.  Otherwise, a Memory</span>
00633     <span class="comment">// Descriptor List (MDL) is allocated and the caller's buffer is locked</span>
00634     <span class="comment">// down using it.</span>
00635     <span class="comment">//</span>
00636 
00637     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.SystemBuffer = (PVOID) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00638     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o2">MdlAddress</a> = (<a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00639 
00640     <span class="keywordflow">if</span> (deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o8">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a123">DO_BUFFERED_IO</a>) {
00641 
00642         <span class="comment">//</span>
00643         <span class="comment">// The device does not support direct I/O.  Allocate a system buffer,</span>
00644         <span class="comment">// and copy the caller's data into it.  This is done using an</span>
00645         <span class="comment">// exception handler that will perform cleanup if the operation</span>
00646         <span class="comment">// fails.  Note that this is only done if the operation has a non-zero</span>
00647         <span class="comment">// length.</span>
00648         <span class="comment">//</span>
00649 
00650         <span class="keywordflow">if</span> (Length) {
00651 
00652             <span class="keywordflow">try</span> {
00653 
00654                 <span class="comment">//</span>
00655                 <span class="comment">// Allocate the intermediary system buffer from nonpaged pool,</span>
00656                 <span class="comment">// charge quota for it, and copy the caller's data into it.</span>
00657                 <span class="comment">//</span>
00658 
00659                 irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.SystemBuffer =
00660                     <a class="code" href="../../d5/d5/cc_8h.html#a11">ExAllocatePoolWithQuota</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a177">NonPagedPoolCacheAligned</a>, Length );
00661                 RtlCopyMemory( irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.SystemBuffer, <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>, Length );
00662 
00663             } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
00664 
00665                 <span class="comment">//</span>
00666                 <span class="comment">// An exception was incurred while either probing the caller's</span>
00667                 <span class="comment">// buffer, allocating the system buffer, or copying the data</span>
00668                 <span class="comment">// from the caller's buffer to the system buffer.  Determine</span>
00669                 <span class="comment">// what actually happened, clean everything up, and return an</span>
00670                 <span class="comment">// appropriate error status code.</span>
00671                 <span class="comment">//</span>
00672 
00673                 <a class="code" href="../../d0/d6/iop_8h.html#a170">IopExceptionCleanup</a>( fileObject,
00674                                      irp,
00675                                      eventObject,
00676                                      (<a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00677 
00678                 <span class="keywordflow">return</span> GetExceptionCode();
00679 
00680             }
00681 
00682             <span class="comment">//</span>
00683             <span class="comment">// Set the IRP_BUFFERED_IO flag in the IRP so that I/O completion</span>
00684             <span class="comment">// will know that this is not a direct I/O operation.  Also set the</span>
00685             <span class="comment">// IRP_DEALLOCATE_BUFFER flag so it will deallocate the buffer.</span>
00686             <span class="comment">//</span>
00687 
00688             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> = <a class="code" href="../../d0/d5/io_8h.html#a178">IRP_BUFFERED_IO</a> | <a class="code" href="../../d0/d5/io_8h.html#a179">IRP_DEALLOCATE_BUFFER</a>;
00689 
00690         } <span class="keywordflow">else</span> {
00691 
00692             <span class="comment">//</span>
00693             <span class="comment">// This is a zero-length write.  Simply indicate that this is</span>
00694             <span class="comment">// buffered I/O, and pass along the request.  The buffer will</span>
00695             <span class="comment">// not be set to deallocate so the completion path does not</span>
00696             <span class="comment">// have to special-case the length.</span>
00697             <span class="comment">//</span>
00698 
00699             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> = <a class="code" href="../../d0/d5/io_8h.html#a178">IRP_BUFFERED_IO</a>;
00700         }
00701 
00702     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o8">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a125">DO_DIRECT_IO</a>) {
00703 
00704         <span class="comment">//</span>
00705         <span class="comment">// This is a direct I/O operation.  Allocate an MDL and invoke the</span>
00706         <span class="comment">// memory management routine to lock the buffer into memory.  This</span>
00707         <span class="comment">// is done using an exception handler that will perform cleanup if</span>
00708         <span class="comment">// the operation fails.  Note that no MDL is allocated, nor is any</span>
00709         <span class="comment">// memory probed or locked if the length of the request was zero.</span>
00710         <span class="comment">//</span>
00711 
00712         mdl = (<a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00713         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> = 0;
00714 
00715         <span class="keywordflow">if</span> (Length) {
00716 
00717             <span class="keywordflow">try</span> {
00718 
00719                 <span class="comment">//</span>
00720                 <span class="comment">// Allocate an MDL, charging quota for it, and hang it off of</span>
00721                 <span class="comment">// the IRP.  Probe and lock the pages associated with the</span>
00722                 <span class="comment">// caller's buffer for read access and fill in the MDL with</span>
00723                 <span class="comment">// the PFNs of those pages.</span>
00724                 <span class="comment">//</span>
00725 
00726                 mdl = <a class="code" href="../../d4/d6/iosubs_8c.html#a19">IoAllocateMdl</a>( <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>, Length, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, irp );
00727                 <span class="keywordflow">if</span> (mdl == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00728                     <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INSUFFICIENT_RESOURCES );
00729                 }
00730 
00731                 <a class="code" href="../../d5/d6/iosup_8c.html#a41">MmProbeAndLockPages</a>( mdl, requestorMode, <a class="code" href="../../d2/d1/mm_8h.html#a344a168">IoReadAccess</a> );
00732 
00733             } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
00734 
00735                 <span class="comment">//</span>
00736                 <span class="comment">// An exception was incurred while either allocating the MDL</span>
00737                 <span class="comment">// or while attempting to probe and lock the caller's buffer.</span>
00738                 <span class="comment">// Determine what actually happened, clean everything up, and</span>
00739                 <span class="comment">// return an appropriate error status code.</span>
00740                 <span class="comment">//</span>
00741 
00742                 <a class="code" href="../../d0/d6/iop_8h.html#a170">IopExceptionCleanup</a>( fileObject,
00743                                      irp,
00744                                      eventObject,
00745                                      (<a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00746 
00747                 <span class="keywordflow">return</span> GetExceptionCode();
00748             }
00749 
00750         }
00751 
00752     } <span class="keywordflow">else</span> {
00753 
00754         <span class="comment">//</span>
00755         <span class="comment">// Pass the address of the caller's buffer to the device driver.  It</span>
00756         <span class="comment">// is now up to the driver to do everything.</span>
00757         <span class="comment">//</span>
00758 
00759         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> = 0;
00760         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o26">UserBuffer</a> = <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>;
00761 
00762     }
00763 
00764     <span class="comment">//</span>
00765     <span class="comment">// If this write operation is to be performed without any caching, set the</span>
00766     <span class="comment">// appropriate flag in the IRP so no caching is performed.</span>
00767     <span class="comment">//</span>
00768 
00769     <span class="keywordflow">if</span> (fileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a153">FO_NO_INTERMEDIATE_BUFFERING</a>) {
00770         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a173">IRP_NOCACHE</a> | <a class="code" href="../../d0/d5/io_8h.html#a184">IRP_WRITE_OPERATION</a> | <a class="code" href="../../d0/d5/io_8h.html#a186">IRP_DEFER_IO_COMPLETION</a>;
00771     } <span class="keywordflow">else</span> {
00772         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a184">IRP_WRITE_OPERATION</a> | <a class="code" href="../../d0/d5/io_8h.html#a186">IRP_DEFER_IO_COMPLETION</a>;
00773     }
00774 
00775     <span class="comment">//</span>
00776     <span class="comment">// Copy the caller's parameters to the service-specific portion of the</span>
00777     <span class="comment">// IRP.</span>
00778     <span class="comment">//</span>
00779 
00780     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.Write.Length = Length;
00781     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.Write.Key = keyValue;
00782     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.Write.ByteOffset = fileOffset;
00783 
00784     <span class="comment">//</span>
00785     <span class="comment">// Queue the packet, call the driver, and synchronize appopriately with</span>
00786     <span class="comment">// I/O completion.</span>
00787     <span class="comment">//</span>
00788 
00789     status = <a class="code" href="../../d0/d6/iop_8h.html#a212">IopSynchronousServiceTail</a>( deviceObject,
00790                                         irp,
00791                                         fileObject,
00792                                         <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
00793                                         requestorMode,
00794                                         synchronousIo,
00795                                         <a class="code" href="../../d0/d6/iop_8h.html#a240a139">WriteTransfer</a> );
00796 
00797     <span class="keywordflow">return</span> status;
00798 }
00799 
00800 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00801"></a><a class="code" href="../../d0/d0/io_2write_8c.html#a1">00801</a> <a class="code" href="../../d0/d0/io_2write_8c.html#a1">NtWriteFileGather</a>(
00802     IN HANDLE FileHandle,
00803     IN HANDLE Event OPTIONAL,
00804     IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
00805     IN PVOID ApcContext OPTIONAL,
00806     OUT PIO_STATUS_BLOCK IoStatusBlock,
00807     IN PFILE_SEGMENT_ELEMENT SegmentArray,
00808     IN ULONG Length,
00809     IN PLARGE_INTEGER ByteOffset OPTIONAL,
00810     IN PULONG Key OPTIONAL
00811     )
00812 
00813 <span class="comment">/*++</span>
00814 <span class="comment"></span>
00815 <span class="comment">Routine Description:</span>
00816 <span class="comment"></span>
00817 <span class="comment">    This service writes Length bytes of data from the caller's segment</span>
00818 <span class="comment">    buffers to the file associated with FileHandle starting at</span>
00819 <span class="comment">    StartingBlock|ByteOffset. The actual number of bytes written to the file</span>
00820 <span class="comment">    will be returned in the second longword of the IoStatusBlock.</span>
00821 <span class="comment"></span>
00822 <span class="comment">    If the writer has the file open for APPEND access, then the data will be</span>
00823 <span class="comment">    written to the current EOF mark.  The StartingBlock and ByteOffset are</span>
00824 <span class="comment">    ignored if the caller has APPEND access.</span>
00825 <span class="comment"></span>
00826 <span class="comment">Arguments:</span>
00827 <span class="comment"></span>
00828 <span class="comment">    FileHandle - Supplies a handle to the file to be written.</span>
00829 <span class="comment"></span>
00830 <span class="comment">    Event - Optionally supplies an event to be set to the Signaled state when</span>
00831 <span class="comment">        the write operation is complete.</span>
00832 <span class="comment"></span>
00833 <span class="comment">    ApcRoutine - Optionally supplies an APC routine to be executed when the</span>
00834 <span class="comment">        write operation is complete.</span>
00835 <span class="comment"></span>
00836 <span class="comment">    ApcContext - Supplies a context parameter to be passed to the APC routine</span>
00837 <span class="comment">        when it is invoked, if an APC routine was specified.</span>
00838 <span class="comment"></span>
00839 <span class="comment">    IoStatusBlock - Supplies the address of the caller's I/O status block.</span>
00840 <span class="comment"></span>
00841 <span class="comment">    SegmentArray - An array of buffer segment pointers that specify</span>
00842 <span class="comment">        where the data should be read from.</span>
00843 <span class="comment"></span>
00844 <span class="comment">    Length - Length, in bytes, of the data to be written to the file.</span>
00845 <span class="comment"></span>
00846 <span class="comment">    ByteOffset - Specifies the starting byte offset within the file to begin</span>
00847 <span class="comment">        the write operation.  If not specified and the file is open for</span>
00848 <span class="comment">        synchronous I/O, then the current file position is used.  If the</span>
00849 <span class="comment">        file is not opened for synchronous I/O and the parameter is not</span>
00850 <span class="comment">        specified, then it is in error.</span>
00851 <span class="comment"></span>
00852 <span class="comment">    Key - Optionally specifies a key to be used if there are locks associated</span>
00853 <span class="comment">        with the file.</span>
00854 <span class="comment"></span>
00855 <span class="comment">Return Value:</span>
00856 <span class="comment"></span>
00857 <span class="comment">    The status returned is success if the write operation was properly queued</span>
00858 <span class="comment">    to the I/O system.  Once the write completes the status of the operation</span>
00859 <span class="comment">    can be determined by examining the Status field of the I/O status block.</span>
00860 <span class="comment"></span>
00861 <span class="comment">Notes:</span>
00862 <span class="comment">    This interface is only supported for no buffering and asynchronous I/O.</span>
00863 <span class="comment"></span>
00864 <span class="comment">--*/</span>
00865 
00866 {
00867     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
00868     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
00869     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> fileObject;
00870     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> deviceObject;
00871     <a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html">PFAST_IO_DISPATCH</a> fastIoDispatch;
00872     PFILE_SEGMENT_ELEMENT capturedArray = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00873     <a class="code" href="../../d0/d9/ntosdef_8h.html#a39">KPROCESSOR_MODE</a> requestorMode;
00874     <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> mdl;
00875     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpSp;
00876     ACCESS_MASK grantedAccess;
00877     <a class="code" href="../../d3/d5/struct__OBJECT__HANDLE__INFORMATION.html">OBJECT_HANDLE_INFORMATION</a> handleInformation;
00878     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> exceptionCode;
00879     <a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a> eventObject = (<a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00880     ULONG elementCount;
00881     ULONG keyValue = 0;
00882     LARGE_INTEGER fileOffset = {0,0};
00883     PULONG majorFunction;
00884     ULONG i;
00885     BOOLEAN synchronousIo;
00886 
00887     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00888 
00889     <span class="comment">//</span>
00890     <span class="comment">// Get the previous mode;  i.e., the mode of the caller.</span>
00891     <span class="comment">//</span>
00892 
00893     requestorMode = KeGetPreviousMode();
00894 
00895     <span class="comment">//</span>
00896     <span class="comment">// Reference the file object so the target device can be found and the</span>
00897     <span class="comment">// access rights mask can be used in the following checks for callers in</span>
00898     <span class="comment">// user mode.  Note that if the handle does not refer to a file object,</span>
00899     <span class="comment">// then it will fail.</span>
00900     <span class="comment">//</span>
00901 
00902     status = <a class="code" href="../../d7/d1/obref_8c.html#a4">ObReferenceObjectByHandle</a>( FileHandle,
00903                                         0<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>,
00904                                         <a class="code" href="../../d5/d8/fssup_8c.html#a3">IoFileObjectType</a>,
00905                                         requestorMode,
00906                                         (PVOID *) &amp;fileObject,
00907                                         &amp;handleInformation);
00908     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
00909         <span class="keywordflow">return</span> status;
00910     }
00911 
00912     grantedAccess = handleInformation.<a class="code" href="../../d3/d5/struct__OBJECT__HANDLE__INFORMATION.html#o1">GrantedAccess</a>;
00913 
00914     <span class="comment">//</span>
00915     <span class="comment">// Get the address of the target device object.</span>
00916     <span class="comment">//</span>
00917 
00918     deviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a76">IoGetRelatedDeviceObject</a>( fileObject );
00919 
00920     <span class="comment">//</span>
00921     <span class="comment">// Verify this is a valid gather write request.  In particular it must</span>
00922     <span class="comment">// be non cached, asynchronous, use completion ports, non buffer I/O</span>
00923     <span class="comment">// device and directed at a file system device.</span>
00924     <span class="comment">//</span>
00925 
00926     <span class="keywordflow">if</span> (!(fileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a153">FO_NO_INTERMEDIATE_BUFFERING</a>) ||
00927         (fileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a151">FO_SYNCHRONOUS_IO</a>) ||
00928         deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o8">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a123">DO_BUFFERED_IO</a> ||
00929         (deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o12">DeviceType</a> != FILE_DEVICE_DISK_FILE_SYSTEM &amp;&amp;
00930          deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o12">DeviceType</a> != FILE_DEVICE_DFS &amp;&amp;
00931          deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o12">DeviceType</a> != FILE_DEVICE_TAPE_FILE_SYSTEM &amp;&amp;
00932          deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o12">DeviceType</a> != FILE_DEVICE_CD_ROM_FILE_SYSTEM &amp;&amp;
00933          deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o12">DeviceType</a> != FILE_DEVICE_NETWORK_FILE_SYSTEM &amp;&amp;
00934          deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o12">DeviceType</a> != FILE_DEVICE_FILE_SYSTEM &amp;&amp;
00935          deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o12">DeviceType</a> != FILE_DEVICE_DFS_VOLUME)) {
00936 
00937         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
00938         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
00939     }
00940 
00941     elementCount = <a class="code" href="../../d2/d1/mm_8h.html#a5">BYTES_TO_PAGES</a>( Length );
00942 
00943     <span class="comment">//</span>
00944     <span class="comment">// Check to see if the requestor mode was user.  If so, perform a bunch</span>
00945     <span class="comment">// of extra checks.</span>
00946     <span class="comment">//</span>
00947 
00948     <span class="keywordflow">if</span> (requestorMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
00949 
00950         <span class="comment">//</span>
00951         <span class="comment">// The caller's access mode is not kernel so probe each of the arguments</span>
00952         <span class="comment">// and capture them as necessary.  If any failures occur, the condition</span>
00953         <span class="comment">// handler will be invoked to handle them.  It will simply cleanup and</span>
00954         <span class="comment">// return an access violation status code back to the system service</span>
00955         <span class="comment">// dispatcher.</span>
00956         <span class="comment">//</span>
00957 
00958         <span class="comment">//</span>
00959         <span class="comment">// Check to ensure that the caller has either WRITE_DATA or APPEND_DATA</span>
00960         <span class="comment">// access to the file.  If not, cleanup and return an access denied</span>
00961         <span class="comment">// error status value.  Note that if this is a pipe then the APPEND_DATA</span>
00962         <span class="comment">// access check may not be made since this access code is overlaid with</span>
00963         <span class="comment">// CREATE_PIPE_INSTANCE access.</span>
00964         <span class="comment">//</span>
00965 
00966         <span class="keywordflow">if</span> (!<a class="code" href="../../d0/d5/se_8h.html#a9">SeComputeGrantedAccesses</a>( grantedAccess, (!(fileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a157">FO_NAMED_PIPE</a>) ? FILE_APPEND_DATA : 0) | FILE_WRITE_DATA )) {
00967             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
00968             <span class="keywordflow">return</span> STATUS_ACCESS_DENIED;
00969         }
00970 
00971         <span class="comment">//</span>
00972         <span class="comment">// Attempt to probe the caller's parameters within the exception</span>
00973         <span class="comment">// handler block.</span>
00974         <span class="comment">//</span>
00975 
00976         <span class="keywordflow">try</span> {
00977 
00978             <span class="comment">//</span>
00979             <span class="comment">// The IoStatusBlock parameter must be writeable by the caller.</span>
00980             <span class="comment">//</span>
00981 
00982             <a class="code" href="../../d5/d8/ex_8h.html#a32">ProbeForWriteIoStatusEx</a>( IoStatusBlock , ApcRoutine);
00983 
00984             <span class="comment">//</span>
00985             <span class="comment">// The SegmentArray paramter must be accessible.</span>
00986             <span class="comment">//</span>
00987 
00988 <span class="preprocessor">#ifdef _X86_</span>
00989 <span class="preprocessor"></span>            <a class="code" href="../../d5/d8/ex_8h.html#a11">ProbeForRead</a>( SegmentArray,
00990                           elementCount * <span class="keyword">sizeof</span>( FILE_SEGMENT_ELEMENT ),
00991                           <span class="keyword">sizeof</span>( ULONG )
00992                           );
00993 <span class="preprocessor">#elif defined(_WIN64)</span>
00994 <span class="preprocessor"></span>            
00995             <span class="comment">//</span>
00996             <span class="comment">// If we are a wow64 process, follow the X86 rules</span>
00997             <span class="comment">//</span>
00998 
00999             <span class="keywordflow">if</span> (<a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a>()-&gt;Wow64Process) {
01000                 <a class="code" href="../../d5/d8/ex_8h.html#a11">ProbeForRead</a>( SegmentArray,
01001                               elementCount * <span class="keyword">sizeof</span>( FILE_SEGMENT_ELEMENT ),
01002                               <span class="keyword">sizeof</span>( ULONG )
01003                               );
01004             } <span class="keywordflow">else</span> {
01005                 <a class="code" href="../../d5/d8/ex_8h.html#a11">ProbeForRead</a>( SegmentArray,
01006                               elementCount * <span class="keyword">sizeof</span>( FILE_SEGMENT_ELEMENT ),
01007                               TYPE_ALIGNMENT( FILE_SEGMENT_ELEMENT )
01008                               );
01009             }
01010 <span class="preprocessor">#else</span>
01011 <span class="preprocessor"></span>            <a class="code" href="../../d5/d8/ex_8h.html#a11">ProbeForRead</a>( SegmentArray,
01012                           elementCount * <span class="keyword">sizeof</span>( FILE_SEGMENT_ELEMENT ),
01013                           TYPE_ALIGNMENT( FILE_SEGMENT_ELEMENT )
01014                           );
01015 <span class="preprocessor">#endif</span>
01016 <span class="preprocessor"></span>
01017             <span class="keywordflow">if</span> (Length != 0) {
01018 
01019                 <span class="comment">//</span>
01020                 <span class="comment">// Capture the segment array so it cannot be changed after</span>
01021                 <span class="comment">// it has been looked at.</span>
01022                 <span class="comment">//</span>
01023 
01024                 capturedArray = <a class="code" href="../../d5/d5/cc_8h.html#a11">ExAllocatePoolWithQuota</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>,
01025                                                          elementCount * <span class="keyword">sizeof</span>( FILE_SEGMENT_ELEMENT )
01026                                                          );
01027 
01028                 RtlCopyMemory( capturedArray,
01029                                SegmentArray,
01030                                elementCount * <span class="keyword">sizeof</span>( FILE_SEGMENT_ELEMENT )
01031                                );
01032 
01033                 SegmentArray = capturedArray;
01034 
01035                 <span class="comment">//</span>
01036                 <span class="comment">// Verify that all the addresses are page aligned.</span>
01037                 <span class="comment">//</span>
01038 
01039                 <span class="keywordflow">for</span> (i = 0; i &lt; elementCount; i++) {
01040 
01041                     <span class="keywordflow">if</span> ( SegmentArray[i].Alignment &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1)) {
01042                         <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>(STATUS_INVALID_PARAMETER);
01043                     }
01044                 }
01045             }
01046 
01047             <span class="comment">//</span>
01048             <span class="comment">// If this file has an I/O completion port associated w/it, then</span>
01049             <span class="comment">// ensure that the caller did not supply an APC routine, as the</span>
01050             <span class="comment">// two are mutually exclusive methods for I/O completion</span>
01051             <span class="comment">// notification.</span>
01052             <span class="comment">//</span>
01053 
01054             <span class="keywordflow">if</span> (fileObject-&gt;CompletionContext &amp;&amp; <a class="code" href="../../d0/d6/iop_8h.html#a19">IopApcRoutinePresent</a>( ApcRoutine )) {
01055 
01056                 <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>(STATUS_INVALID_PARAMETER);
01057 
01058             }
01059 
01060             <span class="comment">//</span>
01061             <span class="comment">// Check that the ByteOffset parameter is readable from the</span>
01062             <span class="comment">// caller's mode, if one was specified, and capture it.</span>
01063             <span class="comment">//</span>
01064 
01065             <span class="keywordflow">if</span> (ARGUMENT_PRESENT( ByteOffset )) {
01066                 <a class="code" href="../../d5/d8/ex_8h.html#a11">ProbeForRead</a>( ByteOffset,
01067                               <span class="keyword">sizeof</span>( LARGE_INTEGER ),
01068                               <span class="keyword">sizeof</span>( ULONG ) );
01069                 fileOffset = *ByteOffset;
01070             }
01071 
01072             <span class="comment">//</span>
01073             <span class="comment">// Check to see whether the caller has opened the file without</span>
01074             <span class="comment">// intermediate buffering.  If so, perform the following ByteOffset</span>
01075             <span class="comment">// parameter check differently.</span>
01076             <span class="comment">//</span>
01077 
01078             <span class="keywordflow">if</span> (fileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a153">FO_NO_INTERMEDIATE_BUFFERING</a>) {
01079 
01080                 <span class="comment">//</span>
01081                 <span class="comment">// The file was opened without intermediate buffering enabled.</span>
01082                 <span class="comment">// Check that the Buffer is properly aligned, and that the</span>
01083                 <span class="comment">// length is an integral number of 512-byte blocks.</span>
01084                 <span class="comment">//</span>
01085 
01086                 <span class="keywordflow">if</span> ((deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o23">SectorSize</a> &amp;&amp;
01087                     (Length &amp; (deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o23">SectorSize</a> - 1)))) {
01088 
01089                     <span class="comment">//</span>
01090                     <span class="comment">// Check for sector sizes that are not a power of two.</span>
01091                     <span class="comment">//</span>
01092 
01093                     <span class="keywordflow">if</span> ((deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o23">SectorSize</a> &amp;&amp;
01094                         Length % deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o23">SectorSize</a>) ) {
01095 
01096                         <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>(STATUS_INVALID_PARAMETER);
01097                     }
01098                 }
01099 
01100                 <span class="comment">//</span>
01101                 <span class="comment">// If a ByteOffset parameter was specified, ensure that it is</span>
01102                 <span class="comment">// is of the proper type.</span>
01103                 <span class="comment">//</span>
01104 
01105                 <span class="keywordflow">if</span> (ARGUMENT_PRESENT( ByteOffset )) {
01106                     <span class="keywordflow">if</span> (fileOffset.LowPart == FILE_WRITE_TO_END_OF_FILE &amp;&amp;
01107                         fileOffset.HighPart == -1) {
01108                         NOTHING;
01109                     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fileOffset.LowPart == FILE_USE_FILE_POINTER_POSITION &amp;&amp;
01110                                fileOffset.HighPart == -1 &amp;&amp;
01111                                (fileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a151">FO_SYNCHRONOUS_IO</a>)) {
01112                         NOTHING;
01113                     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o23">SectorSize</a> &amp;&amp;
01114                         (fileOffset.LowPart &amp; (deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o23">SectorSize</a> - 1))) {
01115 
01116                         <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>(STATUS_INVALID_PARAMETER);
01117                     }
01118                 }
01119             }
01120 
01121             <span class="comment">//</span>
01122             <span class="comment">// Finally, ensure that if there is a key parameter specified it</span>
01123             <span class="comment">// is readable by the caller.</span>
01124             <span class="comment">//</span>
01125 
01126             <span class="keywordflow">if</span> (ARGUMENT_PRESENT( <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a51">Key</a> )) {
01127                 keyValue = <a class="code" href="../../d5/d8/ex_8h.html#a20">ProbeAndReadUlong</a>( <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a51">Key</a> );
01128             }
01129 
01130         } except(<a class="code" href="../../d0/d6/iop_8h.html#a169">IopExceptionFilter</a>( GetExceptionInformation(), &amp;exceptionCode )) {
01131 
01132             <span class="comment">//</span>
01133             <span class="comment">// An exception was incurred while attempting to probe the</span>
01134             <span class="comment">// caller's parameters.  Simply cleanup, dereference the file</span>
01135             <span class="comment">// object, and return with the appropriate status code.</span>
01136             <span class="comment">//</span>
01137 
01138             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
01139 
01140             <span class="keywordflow">if</span> (capturedArray != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01141                 <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( capturedArray );
01142             }
01143 
01144             <span class="keywordflow">return</span> exceptionCode;
01145 
01146         }
01147 
01148     } <span class="keywordflow">else</span> {
01149 
01150         <span class="comment">//</span>
01151         <span class="comment">// The caller's mode is kernel.  Get the appropriate parameters to</span>
01152         <span class="comment">// their expected locations without making all of the checks.</span>
01153         <span class="comment">//</span>
01154 
01155         <span class="keywordflow">if</span> (ARGUMENT_PRESENT( ByteOffset )) {
01156             fileOffset = *ByteOffset;
01157         }
01158 
01159         <span class="keywordflow">if</span> (ARGUMENT_PRESENT( <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a51">Key</a> )) {
01160             keyValue = *<a class="code" href="../../d2/d0/nt6_2user32_8def.html#a51">Key</a>;
01161         }
01162 <span class="preprocessor">#if DBG</span>
01163 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (fileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a153">FO_NO_INTERMEDIATE_BUFFERING</a>) {
01164 
01165             <span class="comment">//</span>
01166             <span class="comment">// The file was opened without intermediate buffering enabled.</span>
01167             <span class="comment">// Check that the the length is an integral number of the block</span>
01168             <span class="comment">//  size.</span>
01169             <span class="comment">//</span>
01170 
01171             <span class="keywordflow">if</span> ((deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o23">SectorSize</a> &amp;&amp;
01172                 (Length &amp; (deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o23">SectorSize</a> - 1)))) {
01173 
01174                 <span class="comment">//</span>
01175                 <span class="comment">// Check for sector sizes that are not a power of two.</span>
01176                 <span class="comment">//</span>
01177 
01178                 <span class="keywordflow">if</span> ((deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o23">SectorSize</a> &amp;&amp;
01179                     Length % deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o23">SectorSize</a>)) {
01180                     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
01181                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
01182                     <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
01183                 }
01184             }
01185 
01186             <span class="comment">//</span>
01187             <span class="comment">// If a ByteOffset parameter was specified, ensure that it is</span>
01188             <span class="comment">// is of the proper type.</span>
01189             <span class="comment">//</span>
01190 
01191             <span class="keywordflow">if</span> (ARGUMENT_PRESENT( ByteOffset )) {
01192                 <span class="keywordflow">if</span> (fileOffset.LowPart == FILE_WRITE_TO_END_OF_FILE &amp;&amp;
01193                     fileOffset.HighPart == -1) {
01194                     NOTHING;
01195                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fileOffset.LowPart == FILE_USE_FILE_POINTER_POSITION &amp;&amp;
01196                            fileOffset.HighPart == -1 &amp;&amp;
01197                            (fileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a151">FO_SYNCHRONOUS_IO</a>)) {
01198                     NOTHING;
01199                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o23">SectorSize</a> &amp;&amp;
01200                     (fileOffset.LowPart &amp; (deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o23">SectorSize</a> - 1))) {
01201                     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
01202                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
01203                     <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
01204                 }
01205             }
01206         }
01207 
01208         <span class="keywordflow">if</span> (Length != 0) {
01209 
01210             <span class="comment">//</span>
01211             <span class="comment">// Verify that all the addresses are page aligned.</span>
01212             <span class="comment">//</span>
01213 
01214             <span class="keywordflow">for</span> (i = 0; i &lt; elementCount; i++) {
01215 
01216                 <span class="keywordflow">if</span> ( SegmentArray[i].Alignment &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1)) {
01217 
01218                     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
01219                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
01220                     <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
01221                 }
01222             }
01223         }
01224 <span class="preprocessor">#endif // DBG</span>
01225 <span class="preprocessor"></span>
01226     }
01227 
01228     <span class="comment">//</span>
01229     <span class="comment">// If the caller has only append access to the file, ignore the input</span>
01230     <span class="comment">// parameters and set the ByteOffset to indicate that this write is</span>
01231     <span class="comment">// to the end of the file.  Otherwise, ensure that the parameters are</span>
01232     <span class="comment">// valid.</span>
01233     <span class="comment">//</span>
01234 
01235     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d5/se_8h.html#a9">SeComputeGrantedAccesses</a>( grantedAccess, FILE_APPEND_DATA | FILE_WRITE_DATA ) == FILE_APPEND_DATA) {
01236 
01237         <span class="comment">//</span>
01238         <span class="comment">// This is an append operation to the end of a file.  Set the</span>
01239         <span class="comment">// ByteOffset parameter to give drivers a consistent view of</span>
01240         <span class="comment">// this type of call.</span>
01241         <span class="comment">//</span>
01242 
01243         fileOffset.LowPart = FILE_WRITE_TO_END_OF_FILE;
01244         fileOffset.HighPart = -1;
01245     }
01246 
01247     <span class="comment">//</span>
01248     <span class="comment">// Get the address of the event object and set the event to the Not-</span>
01249     <span class="comment">// Signaled state, if an event was specified.  Note here too, that if</span>
01250     <span class="comment">// the handle does not refer to an event, then the reference will fail.</span>
01251     <span class="comment">//</span>
01252 
01253     <span class="keywordflow">if</span> (ARGUMENT_PRESENT( <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a> )) {
01254         status = <a class="code" href="../../d7/d1/obref_8c.html#a4">ObReferenceObjectByHandle</a>( <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>,
01255                                             EVENT_MODIFY_STATE,
01256                                             <a class="code" href="../../d7/d7/ntapi_8c.html#a3">ExEventObjectType</a>,
01257                                             requestorMode,
01258                                             (PVOID *) &amp;eventObject,
01259                                             <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
01260         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
01261             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
01262             <span class="keywordflow">if</span> (capturedArray != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01263                 <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( capturedArray );
01264             }
01265             <span class="keywordflow">return</span> status;
01266         } <span class="keywordflow">else</span> {
01267             <a class="code" href="../../d4/d9/ke_8h.html#a21">KeClearEvent</a>( eventObject );
01268         }
01269     }
01270 
01271     <span class="comment">//</span>
01272     <span class="comment">// Get the address of the fast io dispatch structure.</span>
01273     <span class="comment">//</span>
01274 
01275     fastIoDispatch = deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o3">DriverObject</a>-&gt;<a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html#o10">FastIoDispatch</a>;
01276 
01277     <span class="comment">//</span>
01278     <span class="comment">// Make a special check here to determine whether this is a synchronous</span>
01279     <span class="comment">// I/O operation.  If it is, then wait here until the file is owned by</span>
01280     <span class="comment">// the current thread.  If the wait terminates with an alerted status,</span>
01281     <span class="comment">// then cleanup and return the alerted status.  This allows the caller</span>
01282     <span class="comment">// specify FILE_SYNCHRONOUS_IO_ALERT as a synchronous I/O option.</span>
01283     <span class="comment">//</span>
01284     <span class="comment">// If everything works, then check to see whether a ByteOffset parameter</span>
01285     <span class="comment">// was supplied.  If not, or if it was and it is set to the "use file</span>
01286     <span class="comment">// pointer position", then initialize the file offset to be whatever</span>
01287     <span class="comment">// the current byte offset into the file is according to the file pointer</span>
01288     <span class="comment">// context information in the file object.</span>
01289     <span class="comment">//</span>
01290 
01291     <span class="keywordflow">if</span> (fileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a151">FO_SYNCHRONOUS_IO</a>) {
01292 
01293         BOOLEAN interrupted;
01294 
01295         <span class="keywordflow">if</span> (!<a class="code" href="../../d0/d6/iop_8h.html#a13">IopAcquireFastLock</a>( fileObject )) {
01296             status = <a class="code" href="../../d0/d6/iop_8h.html#a147">IopAcquireFileObjectLock</a>( fileObject,
01297                                                requestorMode,
01298                                                (BOOLEAN) ((fileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a152">FO_ALERTABLE_IO</a>) != 0),
01299                                                &amp;interrupted );
01300             <span class="keywordflow">if</span> (interrupted) {
01301                 <span class="keywordflow">if</span> (eventObject) {
01302                     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( eventObject );
01303                 }
01304                 <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
01305                 <span class="keywordflow">if</span> (capturedArray != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01306                     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( capturedArray );
01307                 }
01308                 <span class="keywordflow">return</span> status;
01309             }
01310         }
01311 
01312         synchronousIo = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01313 
01314         <span class="keywordflow">if</span> ((!ARGUMENT_PRESENT( ByteOffset ) &amp;&amp; !fileOffset.LowPart ) ||
01315             (fileOffset.LowPart == FILE_USE_FILE_POINTER_POSITION &amp;&amp;
01316             fileOffset.HighPart == -1 )) {
01317             fileOffset = fileObject-&gt;CurrentByteOffset;
01318         }
01319 
01320     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!ARGUMENT_PRESENT( ByteOffset ) &amp;&amp; !(fileObject-&gt;Flags &amp; (<a class="code" href="../../d0/d5/io_8h.html#a157">FO_NAMED_PIPE</a> | <a class="code" href="../../d0/d5/io_8h.html#a159">FO_MAILSLOT</a>))) {
01321 
01322         <span class="comment">//</span>
01323         <span class="comment">// The file is not open for synchronous I/O operations, but the</span>
01324         <span class="comment">// caller did not specify a ByteOffset parameter.  This is an error</span>
01325         <span class="comment">// situation, so cleanup and return with the appropriate status.</span>
01326         <span class="comment">//</span>
01327 
01328         <span class="keywordflow">if</span> (eventObject) {
01329             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( eventObject );
01330         }
01331         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
01332         <span class="keywordflow">if</span> (capturedArray != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01333             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( capturedArray );
01334         }
01335         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
01336 
01337     } <span class="keywordflow">else</span> {
01338 
01339         <span class="comment">//</span>
01340         <span class="comment">// This is not a synchronous I/O operation.</span>
01341         <span class="comment">//</span>
01342 
01343         synchronousIo = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01344     }
01345 
01346     <span class="comment">//</span>
01347     <span class="comment">//  Negative file offsets are illegal.</span>
01348     <span class="comment">//</span>
01349 
01350     <span class="keywordflow">if</span> (fileOffset.HighPart &lt; 0 &amp;&amp;
01351         (fileOffset.HighPart != -1 ||
01352         fileOffset.LowPart != FILE_WRITE_TO_END_OF_FILE)) {
01353 
01354         <span class="keywordflow">if</span> (eventObject) {
01355             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( eventObject );
01356         }
01357         <span class="keywordflow">if</span> (synchronousIo) {
01358             <a class="code" href="../../d0/d6/iop_8h.html#a22">IopReleaseFileObjectLock</a>( fileObject );
01359         }
01360         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
01361         <span class="keywordflow">if</span> (capturedArray != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01362             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( capturedArray );
01363         }
01364         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
01365     }
01366 
01367     <span class="comment">//</span>
01368     <span class="comment">// Set the file object to the Not-Signaled state.</span>
01369     <span class="comment">//</span>
01370 
01371     <a class="code" href="../../d4/d9/ke_8h.html#a21">KeClearEvent</a>( &amp;fileObject-&gt;Event );
01372 
01373     <span class="comment">//</span>
01374     <span class="comment">// Allocate and initialize the I/O Request Packet (IRP) for this operation.</span>
01375     <span class="comment">// The allocation is performed with an exception handler in case the</span>
01376     <span class="comment">// caller does not have enough quota to allocate the packet.</span>
01377     <span class="comment">//</span>
01378 
01379     irp = <a class="code" href="../../d0/d6/iop_8h.html#a16">IopAllocateIrp</a>( deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o13">StackSize</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
01380     <span class="keywordflow">if</span> (!irp) {
01381 
01382         <span class="comment">//</span>
01383         <span class="comment">// An IRP could not be allocated.  Cleanup and return an appropriate</span>
01384         <span class="comment">// error status code.</span>
01385         <span class="comment">//</span>
01386 
01387         <a class="code" href="../../d0/d6/iop_8h.html#a148">IopAllocateIrpCleanup</a>( fileObject, eventObject );
01388 
01389         <span class="keywordflow">if</span> (capturedArray != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01390             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( capturedArray );
01391         }
01392         <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
01393     }
01394     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.OriginalFileObject = fileObject;
01395     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.Thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
01396     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.AuxiliaryBuffer = (PVOID) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01397     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o10">RequestorMode</a> = requestorMode;
01398     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o11">PendingReturned</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01399     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o14">Cancel</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01400     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o25">CancelRoutine</a> = (<a class="code" href="../../d0/d5/io_8h.html#a286">PDRIVER_CANCEL</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01401 
01402     <span class="comment">//</span>
01403     <span class="comment">// Fill in the service independent parameters in the IRP.</span>
01404     <span class="comment">//</span>
01405 
01406     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o19">UserEvent</a> = eventObject;
01407     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o18">UserIosb</a> = IoStatusBlock;
01408     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o24">Overlay</a>.AsynchronousParameters.UserApcRoutine = ApcRoutine;
01409     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o24">Overlay</a>.AsynchronousParameters.UserApcContext = ApcContext;
01410 
01411     <span class="comment">//</span>
01412     <span class="comment">// Get a pointer to the stack location for the first driver.  This will be</span>
01413     <span class="comment">// used to pass the original function codes and parameters.  Note that</span>
01414     <span class="comment">// setting the major function code here also sets:</span>
01415     <span class="comment">//</span>
01416     <span class="comment">//      MinorFunction = 0;</span>
01417     <span class="comment">//      Flags = 0;</span>
01418     <span class="comment">//      Control = 0;</span>
01419     <span class="comment">//</span>
01420 
01421     irpSp = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>( irp );
01422     majorFunction = (PULONG) irpSp;
01423     *majorFunction = <a class="code" href="../../d0/d5/io_8h.html#a17">IRP_MJ_WRITE</a>;
01424     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a> = fileObject;
01425     <span class="keywordflow">if</span> (fileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a154">FO_WRITE_THROUGH</a>) {
01426         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o2">Flags</a> = <a class="code" href="../../d0/d5/io_8h.html#a204">SL_WRITE_THROUGH</a>;
01427     }
01428 
01429     <span class="comment">//</span>
01430     <span class="comment">// Now determine whether this device expects to have data buffered to it</span>
01431     <span class="comment">// or whether it performs direct I/O.  This is based on the DO_BUFFERED_IO</span>
01432     <span class="comment">// flag in the device object.  If the flag is set, then a system buffer is</span>
01433     <span class="comment">// allocated and the caller's data is copied into it.  Otherwise, a Memory</span>
01434     <span class="comment">// Descriptor List (MDL) is allocated and the caller's buffer is locked</span>
01435     <span class="comment">// down using it.</span>
01436     <span class="comment">//</span>
01437 
01438     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.SystemBuffer = (PVOID) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01439     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o2">MdlAddress</a> = (<a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01440 
01441     <span class="comment">//</span>
01442     <span class="comment">// This is a direct I/O operation.  Allocate an MDL and invoke the</span>
01443     <span class="comment">// memory management routine to lock the buffer into memory.  This</span>
01444     <span class="comment">// is done using an exception handler that will perform cleanup if</span>
01445     <span class="comment">// the operation fails.  Note that no MDL is allocated, nor is any</span>
01446     <span class="comment">// memory probed or locked if the length of the request was zero.</span>
01447     <span class="comment">//</span>
01448 
01449     mdl = (<a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01450     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> = 0;
01451 
01452     <span class="keywordflow">if</span> (Length) {
01453 
01454         <span class="keywordflow">try</span> {
01455 
01456             <span class="comment">//</span>
01457             <span class="comment">// Allocate an MDL, charging quota for it, and hang it off of</span>
01458             <span class="comment">// the IRP.  Probe and lock the pages associated with the</span>
01459             <span class="comment">// caller's buffer for write access and fill in the MDL with</span>
01460             <span class="comment">// the PFNs of those pages.</span>
01461             <span class="comment">//</span>
01462 
01463             mdl = <a class="code" href="../../d4/d6/iosubs_8c.html#a19">IoAllocateMdl</a>( (PVOID)(ULONG_PTR) SegmentArray[0].<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>, Length, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, irp );
01464             <span class="keywordflow">if</span> (mdl == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01465                 <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INSUFFICIENT_RESOURCES );
01466             }
01467 
01468             <span class="comment">//</span>
01469             <span class="comment">// The address of the first file segment is used as a base</span>
01470             <span class="comment">// address.</span>
01471             <span class="comment">//</span>
01472 
01473             <a class="code" href="../../d5/d6/iosup_8c.html#a44">MmProbeAndLockSelectedPages</a>( mdl,
01474                                          SegmentArray,
01475                                          requestorMode,
01476                                          <a class="code" href="../../d2/d1/mm_8h.html#a344a168">IoReadAccess</a> );
01477 
01478             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o26">UserBuffer</a> = (PVOID)(ULONG_PTR) SegmentArray[0].Buffer;
01479 
01480         } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
01481 
01482             <span class="comment">//</span>
01483             <span class="comment">// An exception was incurred while either allocating the MDL</span>
01484             <span class="comment">// or while attempting to probe and lock the caller's buffer.</span>
01485             <span class="comment">// Determine what actually happened, clean everything up, and</span>
01486             <span class="comment">// return an appropriate error status code.</span>
01487             <span class="comment">//</span>
01488 
01489             <a class="code" href="../../d0/d6/iop_8h.html#a170">IopExceptionCleanup</a>( fileObject,
01490                                  irp,
01491                                  eventObject,
01492                                  (<a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
01493 
01494             <span class="keywordflow">if</span> (capturedArray != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01495                 <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( capturedArray );
01496             }
01497            <span class="keywordflow">return</span> GetExceptionCode();
01498         }
01499 
01500     }
01501 
01502     <span class="comment">//</span>
01503     <span class="comment">// We are done with the captured buffer.</span>
01504     <span class="comment">//</span>
01505 
01506     <span class="keywordflow">if</span> (capturedArray != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01507         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( capturedArray );
01508     }
01509 
01510     <span class="comment">//</span>
01511     <span class="comment">// If this write operation is to be performed without any caching, set the</span>
01512     <span class="comment">// appropriate flag in the IRP so no caching is performed.</span>
01513     <span class="comment">//</span>
01514 
01515     <span class="keywordflow">if</span> (fileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a153">FO_NO_INTERMEDIATE_BUFFERING</a>) {
01516         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a173">IRP_NOCACHE</a> | <a class="code" href="../../d0/d5/io_8h.html#a184">IRP_WRITE_OPERATION</a> | <a class="code" href="../../d0/d5/io_8h.html#a186">IRP_DEFER_IO_COMPLETION</a>;
01517     } <span class="keywordflow">else</span> {
01518         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a184">IRP_WRITE_OPERATION</a> | <a class="code" href="../../d0/d5/io_8h.html#a186">IRP_DEFER_IO_COMPLETION</a>;
01519     }
01520 
01521     <span class="comment">//</span>
01522     <span class="comment">// Copy the caller's parameters to the service-specific portion of the</span>
01523     <span class="comment">// IRP.</span>
01524     <span class="comment">//</span>
01525 
01526     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.Write.Length = Length;
01527     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.Write.Key = keyValue;
01528     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.Write.ByteOffset = fileOffset;
01529 
01530     <span class="comment">//</span>
01531     <span class="comment">// Queue the packet, call the driver, and synchronize appopriately with</span>
01532     <span class="comment">// I/O completion.</span>
01533     <span class="comment">//</span>
01534 
01535     status = <a class="code" href="../../d0/d6/iop_8h.html#a212">IopSynchronousServiceTail</a>( deviceObject,
01536                                         irp,
01537                                         fileObject,
01538                                         <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
01539                                         requestorMode,
01540                                         synchronousIo,
01541                                         <a class="code" href="../../d0/d6/iop_8h.html#a240a139">WriteTransfer</a> );
01542 
01543     <span class="keywordflow">return</span> status;
01544 
01545 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:42:27 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
