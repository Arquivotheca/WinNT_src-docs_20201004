<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: vdm.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>vdm.c</h1><a href="../../d0/d4/ke_2ia64_2vdm_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1990  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    VDM.C</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module contains support routines for the x86 monitor for</span>
00012 <span class="comment">    running Dos applications in V86 mode.</span>
00013 <span class="comment"></span>
00014 <span class="comment">Author:</span>
00015 <span class="comment"></span>
00016 <span class="comment">    Dave Hastings (daveh) 20 Mar 1991</span>
00017 <span class="comment"></span>
00018 <span class="comment">Environment:</span>
00019 <span class="comment"></span>
00020 <span class="comment">    The code in this module is all x86 and EM specific.</span>
00021 <span class="comment"></span>
00022 <span class="comment">Notes:</span>
00023 <span class="comment"></span>
00024 <span class="comment">    In its current implementation, this code is less robust than it needs</span>
00025 <span class="comment">    to be.  This will be fixed.  Specifically, parameter verification needs</span>
00026 <span class="comment">    to be done. (daveh 7/15/91)</span>
00027 <span class="comment"></span>
00028 <span class="comment">    Support for 32 bit segements (2/2/92)</span>
00029 <span class="comment">Revision History:</span>
00030 <span class="comment"></span>
00031 <span class="comment">    20-Mar-1991 daveh</span>
00032 <span class="comment">        created</span>
00033 <span class="comment">    Charles Spirakis (intel) 23 Jun 1996 - Starting to move the necessary</span>
00034 <span class="comment">    code from the i386 environment to the EM environment. This code was</span>
00035 <span class="comment">        shamelessly stolen from ../i386/vdm.c</span>
00036 <span class="comment">--*/</span>
00037 <span class="preprocessor">#include "<a class="code" href="../../d0/d0/ki_8h.html">ki.h</a>"</span>
00038 <span class="preprocessor">#include "<a class="code" href="../../d8/d3/ia32def_8h.html">ia32def.h</a>"</span>
00039 <span class="preprocessor">#include "<a class="code" href="../../d1/d5/vdmntos_8h.html">vdmntos.h</a>"</span>
00040 
00041 <span class="comment">// The beginnings of the real VDM code for the EM port</span>
00042 
<a name="l00043"></a><a class="code" href="../../d0/d4/ke_2ia64_2vdm_8c.html#a0">00043</a> ULONG <a class="code" href="../../d0/d6/emulx86_8c.html#a0">KeIA32EFlagsAndMaskV86</a> = EFLAGS_USER_SANITIZE;
<a name="l00044"></a><a class="code" href="../../d0/d4/ke_2ia64_2vdm_8c.html#a1">00044</a> ULONG <a class="code" href="../../d0/d6/emulx86_8c.html#a1">KeIA32EFlagsOrMaskV86</a> = EFLAGS_INTERRUPT_MASK;
<a name="l00045"></a><a class="code" href="../../d0/d4/ke_2ia64_2vdm_8c.html#a2">00045</a> BOOLEAN <a class="code" href="../../d0/d6/emulx86_8c.html#a2">KeIA32VdmIoplAllowed</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
<a name="l00046"></a><a class="code" href="../../d0/d4/ke_2ia64_2vdm_8c.html#a3">00046</a> ULONG <a class="code" href="../../d0/d6/emulx86_8c.html#a3">KeIA32VirtualIntExtensions</a> = 0;
00047 
<a name="l00048"></a><a class="code" href="../../d0/d4/ke_2ia64_2vdm_8c.html#a4">00048</a> <a class="code" href="../../d3/d7/struct__KMUTANT.html">KMUTEX</a> <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a2">VdmStringIoMutex</a>;
<a name="l00049"></a><a class="code" href="../../d0/d4/ke_2ia64_2vdm_8c.html#a5">00049</a> PULONG <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a3">VdmFixedStateLinear</a>;
00050 
00051 
00052 <span class="preprocessor">#if !defined(WX86)</span>
00053 <span class="preprocessor"></span>
00054 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00055"></a><a class="code" href="../../d0/d4/ke_2ia64_2vdm_8c.html#a6">00055</a> <a class="code" href="../../d2/d4/ke_2ppc_2vdm_8c.html#a0">NtInitializeVDM</a>(
00056     VOID
00057     )
00058 {
00059     <span class="keywordflow">return</span> STATUS_SUCCESS;
00060 }
00061 
00062 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00063"></a><a class="code" href="../../d0/d4/ke_2ia64_2vdm_8c.html#a7">00063</a> <a class="code" href="../../d8/d3/ke_2alpha_2vdm_8c.html#a1">NtVdmStartExecution</a> (
00064     )
00065 
00066 <span class="comment">/*++</span>
00067 <span class="comment"></span>
00068 <span class="comment">Routine Description:</span>
00069 <span class="comment">    </span>
00070 <span class="comment">    This routine returns STATUS_NOT_IMPLEMENTED</span>
00071 <span class="comment"></span>
00072 <span class="comment">Arguments:</span>
00073 <span class="comment">    </span>
00074 <span class="comment">Return Value:</span>
00075 <span class="comment"></span>
00076 <span class="comment">    STATUS_NOT_IMPLEMENTED</span>
00077 <span class="comment">--*/</span>
00078 {
00079 
00080     <span class="keywordflow">return</span> STATUS_NOT_IMPLEMENTED;
00081     
00082 }
00083 
00084 <span class="preprocessor">#else    // WX86</span>
00085 <span class="preprocessor"></span>
00086 <span class="preprocessor">#pragma hdrstop</span>
00087 <span class="preprocessor"></span>
00088 <span class="preprocessor">#define VDM_IO_TEST 0</span>
00089 <span class="preprocessor"></span>
00090 <span class="preprocessor">#if VDM_IO_TEST</span>
00091 <span class="preprocessor"></span><a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00092 TestIoHandlerStuff(
00093     VOID
00094     );
00095 <span class="preprocessor">#endif</span>
00096 <span class="preprocessor"></span>
00097 <span class="preprocessor">#if DBG</span>
00098 <span class="preprocessor"></span><a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00099 PspPrintDescriptor(
00100     IN PLDT_ENTRY Descriptor
00101     );
00102 
00103 <span class="keyword">extern</span> ULONG fShowLdt;
00104 <span class="preprocessor">#endif</span>
00105 <span class="preprocessor"></span>
00106 
00107 BOOLEAN
00108 KiIA32VdmDispatchIo(
00109     IN ULONG PortNumber,
00110     IN ULONG Size,
00111     IN BOOLEAN Read,
00112     IN UCHAR InstructionSize,
00113     IN PKIA32_FRAME TrapFrame
00114     );
00115 
00116 BOOLEAN
00117 KiIA32VdmDispatchStringIo(
00118     IN ULONG PortNumber,
00119     IN ULONG Size,
00120     IN BOOLEAN Rep,
00121     IN BOOLEAN Read,
00122     IN ULONG Count,
00123     IN ULONG Address,
00124     IN UCHAR InstructionSize,
00125     IN PKIA32_FRAME TrapFrame
00126     );
00127 
00128 
00129 BOOLEAN
00130 <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a12">VdmDispatchIoToHandler</a>(
00131     IN PVDM_IO_HANDLER VdmIoHandler,
00132     IN ULONG Context,
00133     IN ULONG PortNumber,
00134     IN ULONG Size,
00135     IN BOOLEAN Read,
00136     IN OUT PULONG Data
00137     );
00138 
00139 BOOLEAN
00140 <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a13">VdmDispatchUnalignedIoToHandler</a>(
00141     IN PVDM_IO_HANDLER VdmIoHandler,
00142     IN ULONG Context,
00143     IN ULONG PortNumber,
00144     IN ULONG Size,
00145     IN BOOLEAN Read,
00146     IN OUT PULONG Data
00147     );
00148 
00149 BOOLEAN
00150 <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a14">VdmDispatchStringIoToHandler</a>(
00151     IN PVDM_IO_HANDLER VdmIoHandler,
00152     IN ULONG Context,
00153     IN ULONG PortNumber,
00154     IN ULONG Size,
00155     IN ULONG Count,
00156     IN BOOLEAN Read,
00157     IN ULONG Data
00158     );
00159 
00160 BOOLEAN
00161 <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a15">VdmCallStringIoHandler</a>(
00162     IN PVDM_IO_HANDLER VdmIoHandler,
00163     IN PVOID StringIoRoutine,
00164     IN ULONG Context,
00165     IN ULONG PortNumber,
00166     IN ULONG Size,
00167     IN ULONG Count,
00168     IN BOOLEAN Read,
00169     IN ULONG Data
00170     );
00171 
00172 BOOLEAN
00173 <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a19">VdmConvertToLinearAddress</a>(
00174     IN ULONG SegmentedAddress,
00175     IN PVOID *LinearAddress
00176     );
00177 
00178 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00179 KeIA32VdmInitialize(
00180     VOID
00181     );
00182 
00183 ULONG
00184 KiIA32VdmEnablePentiumExtentions(
00185     ULONG
00186     );
00187 
00188 <span class="preprocessor">#ifdef ALLOC_PRAGMA</span>
00189 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, KiIA32VdmDispatchIo)</span>
00190 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, KiIA32VdmDispatchStringIo)</span>
00191 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, VdmDispatchIoToHandler)</span>
00192 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, VdmDispatchUnalignedIoToHandler)</span>
00193 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, VdmDispatchStringIoToHandler)</span>
00194 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, VdmCallStringIoHandler)</span>
00195 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, VdmConvertToLinearAddress)</span>
00196 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(INIT, KeIA32VdmInitialize)</span>
00197 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00198 <span class="preprocessor"></span>
00199 
00200 BOOLEAN
00201 KiIA32VdmDispatchIo(
00202     IN ULONG PortNumber,
00203     IN ULONG Size,
00204     IN BOOLEAN Read,
00205     IN UCHAR InstructionSize,
00206     IN PKIA32_FRAME TrapFrame
00207     )
00208 <span class="comment">/*++</span>
00209 <span class="comment"></span>
00210 <span class="comment">Routine Description:</span>
00211 <span class="comment"></span>
00212 <span class="comment">    This routine sets up the Event info for an IO event, and causes the</span>
00213 <span class="comment">    event to be reflected to the Monitor.</span>
00214 <span class="comment"></span>
00215 <span class="comment">    It is assumed that interrupts are enabled upon entry, and Irql is</span>
00216 <span class="comment">    at APC level.</span>
00217 <span class="comment"></span>
00218 <span class="comment">Arguments:</span>
00219 <span class="comment"></span>
00220 <span class="comment">    PortNumber -- Supplies the port number the IO was done to</span>
00221 <span class="comment">    Size -- Supplies the size of the IO operation.</span>
00222 <span class="comment">    Read -- Indicates whether the IO operation was a read or a write.</span>
00223 <span class="comment">    InstructionSize -- Supplies the size of the IO instruction in bytes.</span>
00224 <span class="comment"></span>
00225 <span class="comment">Return Value:</span>
00226 <span class="comment"></span>
00227 <span class="comment">    True if the io instruction will be reflected to User mode.</span>
00228 <span class="comment"></span>
00229 <span class="comment">--*/</span>
00230 {
00231     <a class="code" href="../../d0/d6/struct__Vdm__Tib.html">PVDM_TIB</a> VdmTib;
00232     EXCEPTION_RECORD ExceptionRecord;
00233     VDM_IO_HANDLER VdmIoHandler;
00234     ULONG Result;
00235     BOOLEAN Success = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00236     ULONG Context;
00237 
00238     Success = PsIA32GetVdmIoHandler(
00239         <a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a>(),
00240         PortNumber &amp; ~0x3,
00241         &amp;VdmIoHandler,
00242         &amp;Context
00243         );
00244 
00245     <span class="keywordflow">if</span> (Success) {
00246         Result = TrapFrame-&gt;Eax;
00247         <span class="comment">// if port is not aligned, perform unaligned IO</span>
00248         <span class="comment">// else do the io the easy way</span>
00249         <span class="keywordflow">if</span> (PortNumber % <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>) {
00250             Success = <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a13">VdmDispatchUnalignedIoToHandler</a>(
00251                 &amp;VdmIoHandler,
00252                 Context,
00253                 PortNumber,
00254                 Size,
00255                 Read,
00256                 &amp;Result
00257                 );
00258         } <span class="keywordflow">else</span> {
00259             Success = <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a12">VdmDispatchIoToHandler</a>(
00260                 &amp;VdmIoHandler,
00261                 Context,
00262                 PortNumber,
00263                 Size,
00264                 Read,
00265                 &amp;Result
00266                 );
00267         }
00268     }
00269 
00270     <span class="keywordflow">if</span> (Success) {
00271         <span class="keywordflow">if</span> (Read) {
00272             <span class="keywordflow">switch</span> (<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>) {
00273             <span class="keywordflow">case</span> 4:
00274                 TrapFrame-&gt;Eax = Result;
00275                 <span class="keywordflow">break</span>;
00276             <span class="keywordflow">case</span> 2:
00277                 *(<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>)(&amp;TrapFrame-&gt;Eax) = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)Result;
00278                 <span class="keywordflow">break</span>;
00279             <span class="keywordflow">case</span> 1:
00280                 *(PUCHAR)(&amp;TrapFrame-&gt;Eax) = (UCHAR)Result;
00281                 <span class="keywordflow">break</span>;
00282             }
00283         }
00284         TrapFrame-&gt;Eip += (ULONG) InstructionSize;
00285         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00286     } <span class="keywordflow">else</span> {
00287         <span class="keywordflow">try</span> {
00288             VdmTib = NtCurrentTeb()-&gt;Vdm;
00289             VdmTib-&gt;<a class="code" href="../../d0/d6/struct__Vdm__Tib.html#o5">EventInfo</a>.<a class="code" href="../../d1/d6/struct__VdmEventInfo.html#o2">InstructionSize</a> = (ULONG) InstructionSize;
00290             VdmTib-&gt;<a class="code" href="../../d0/d6/struct__Vdm__Tib.html#o5">EventInfo</a>.<a class="code" href="../../d1/d6/struct__VdmEventInfo.html#o1">Event</a> = <a class="code" href="../../d2/d5/ke_2i386_2vdmp_8h.html#a33a25">VdmIO</a>;
00291             VdmTib-&gt;<a class="code" href="../../d0/d6/struct__Vdm__Tib.html#o5">EventInfo</a>.<a class="code" href="../../d1/d6/struct__VdmEventInfo.html#o3">IoInfo</a>.<a class="code" href="../../d3/d6/struct__VdmIoInfo.html#o0">PortNumber</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)PortNumber;
00292             VdmTib-&gt;<a class="code" href="../../d0/d6/struct__Vdm__Tib.html#o5">EventInfo</a>.<a class="code" href="../../d1/d6/struct__VdmEventInfo.html#o3">IoInfo</a>.<a class="code" href="../../d3/d6/struct__VdmIoInfo.html#o1">Size</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
00293             VdmTib-&gt;<a class="code" href="../../d0/d6/struct__Vdm__Tib.html#o5">EventInfo</a>.<a class="code" href="../../d1/d6/struct__VdmEventInfo.html#o3">IoInfo</a>.<a class="code" href="../../d3/d6/struct__VdmIoInfo.html#o2">Read</a> = Read;
00294         } except(EXCEPTION_EXECUTE_HANDLER) {
00295             ExceptionRecord.ExceptionCode = STATUS_ACCESS_VIOLATION;
00296             ExceptionRecord.ExceptionFlags = 0;
00297             ExceptionRecord.NumberParameters = 0;
00298             <a class="code" href="../../d5/d8/ex_8h.html#a302">ExRaiseException</a>(&amp;ExceptionRecord);
00299             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00300         }
00301     }
00302 
00303     <a class="code" href="../../d7/d7/strtexec_8c.html#a1">VdmEndExecution</a>(TrapFrame, VdmTib);
00304 
00305     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00306 }
00307 
00308 
00309 BOOLEAN
00310 KiIA32VdmDispatchStringIo(
00311     IN ULONG PortNumber,
00312     IN ULONG Size,
00313     IN BOOLEAN Rep,
00314     IN BOOLEAN Read,
00315     IN ULONG Count,
00316     IN ULONG Address,
00317     IN UCHAR InstructionSize,
00318     IN PKIA32_FRAME TrapFrame
00319     )
00320 <span class="comment">/*++</span>
00321 <span class="comment"></span>
00322 <span class="comment">Routine Description:</span>
00323 <span class="comment"></span>
00324 <span class="comment">    This routine sets up the Event info for a string IO event, and causes the</span>
00325 <span class="comment">    event to be reflected to the Monitor.</span>
00326 <span class="comment"></span>
00327 <span class="comment">    It is assumed that interrupts are enabled upon entry, and Irql is</span>
00328 <span class="comment">    at APC level.</span>
00329 <span class="comment"></span>
00330 <span class="comment">Arguments:</span>
00331 <span class="comment"></span>
00332 <span class="comment">    PortNumber -- Supplies the port number the IO was done to</span>
00333 <span class="comment">    Size -- Supplies the size of the IO operation.</span>
00334 <span class="comment">    Read -- Indicates whether the IO operation was a read or a write.</span>
00335 <span class="comment">    Count -- indicates the number of IO operations of Size size</span>
00336 <span class="comment">    Address -- Indicates address for string io</span>
00337 <span class="comment">    InstructionSize -- Supplies the size of the IO instruction in bytes.</span>
00338 <span class="comment"></span>
00339 <span class="comment"></span>
00340 <span class="comment">Return Value:</span>
00341 <span class="comment"></span>
00342 <span class="comment">    True if the io instruction will be reflected to User mode.</span>
00343 <span class="comment">--*/</span>
00344 {
00345     <a class="code" href="../../d0/d6/struct__Vdm__Tib.html">PVDM_TIB</a> VdmTib;
00346     EXCEPTION_RECORD ExceptionRecord;
00347     BOOLEAN Success = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00348     VDM_IO_HANDLER VdmIoHandler;
00349     ULONG Context;
00350 
00351     Success = PsIA32GetVdmIoHandler(
00352         <a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a>(),
00353         PortNumber &amp; ~0x3,
00354         &amp;VdmIoHandler,
00355         &amp;Context
00356         );
00357 
00358 
00359     <span class="keywordflow">if</span> (Success) {
00360         Success = <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a14">VdmDispatchStringIoToHandler</a>(
00361             &amp;VdmIoHandler,
00362             Context,
00363             PortNumber,
00364             Size,
00365             Count,
00366             Read,
00367             Address
00368             );
00369     }
00370 
00371     <span class="keywordflow">if</span> (Success) {
00372         <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a> pIndexRegister;
00373         <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
00374 
00375         <span class="comment">// WARNING no 32 bit address support</span>
00376 
00377         pIndexRegister = Read ? (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>)&amp;TrapFrame-&gt;Edi
00378                               : (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>)&amp;TrapFrame-&gt;Esi;
00379 
00380         <span class="keywordflow">if</span> (TrapFrame-&gt;EFlags &amp; EFLAGS_DF_MASK) {
00381             <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = *pIndexRegister - (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(<a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> * <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>);
00382             }
00383         <span class="keywordflow">else</span> {
00384             <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = *pIndexRegister + (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(<a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> * <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>);
00385             }
00386 
00387         *pIndexRegister = <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
00388 
00389         <span class="keywordflow">if</span> (Rep) {
00390             (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)TrapFrame-&gt;Ecx = 0;
00391             }
00392 
00393         TrapFrame-&gt;Eip += (ULONG) InstructionSize;
00394         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00395     }
00396 
00397     <span class="keywordflow">try</span> {
00398         VdmTib = NtCurrentTeb()-&gt;Vdm;
00399         VdmTib-&gt;<a class="code" href="../../d0/d6/struct__Vdm__Tib.html#o5">EventInfo</a>.<a class="code" href="../../d1/d6/struct__VdmEventInfo.html#o2">InstructionSize</a> = (ULONG) InstructionSize;
00400         VdmTib-&gt;<a class="code" href="../../d0/d6/struct__Vdm__Tib.html#o5">EventInfo</a>.<a class="code" href="../../d1/d6/struct__VdmEventInfo.html#o1">Event</a> = <a class="code" href="../../d2/d5/ke_2i386_2vdmp_8h.html#a33a26">VdmStringIO</a>;
00401         VdmTib-&gt;<a class="code" href="../../d0/d6/struct__Vdm__Tib.html#o5">EventInfo</a>.<a class="code" href="../../d1/d6/struct__VdmEventInfo.html#o4">StringIoInfo</a>.<a class="code" href="../../d4/d6/struct__VdmStringIoInfo.html#o0">PortNumber</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)PortNumber;
00402         VdmTib-&gt;<a class="code" href="../../d0/d6/struct__Vdm__Tib.html#o5">EventInfo</a>.<a class="code" href="../../d1/d6/struct__VdmEventInfo.html#o4">StringIoInfo</a>.<a class="code" href="../../d4/d6/struct__VdmStringIoInfo.html#o1">Size</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
00403         VdmTib-&gt;<a class="code" href="../../d0/d6/struct__Vdm__Tib.html#o5">EventInfo</a>.<a class="code" href="../../d1/d6/struct__VdmEventInfo.html#o4">StringIoInfo</a>.Rep = Rep;
00404         VdmTib-&gt;<a class="code" href="../../d0/d6/struct__Vdm__Tib.html#o5">EventInfo</a>.<a class="code" href="../../d1/d6/struct__VdmEventInfo.html#o4">StringIoInfo</a>.<a class="code" href="../../d4/d6/struct__VdmStringIoInfo.html#o2">Read</a> = Read;
00405         VdmTib-&gt;<a class="code" href="../../d0/d6/struct__Vdm__Tib.html#o5">EventInfo</a>.<a class="code" href="../../d1/d6/struct__VdmEventInfo.html#o4">StringIoInfo</a>.<a class="code" href="../../d4/d6/struct__VdmStringIoInfo.html#o3">Count</a> = <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a>;
00406         VdmTib-&gt;<a class="code" href="../../d0/d6/struct__Vdm__Tib.html#o5">EventInfo</a>.<a class="code" href="../../d1/d6/struct__VdmEventInfo.html#o4">StringIoInfo</a>.<a class="code" href="../../d4/d6/struct__VdmStringIoInfo.html#o4">Address</a> = Address;
00407     } except(EXCEPTION_EXECUTE_HANDLER) {
00408         ExceptionRecord.ExceptionCode = STATUS_ACCESS_VIOLATION;
00409         ExceptionRecord.ExceptionFlags = 0;
00410         ExceptionRecord.NumberParameters = 0;
00411         <a class="code" href="../../d5/d8/ex_8h.html#a302">ExRaiseException</a>(&amp;ExceptionRecord);
00412         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00413     }
00414 
00415 
00416     <a class="code" href="../../d7/d7/strtexec_8c.html#a1">VdmEndExecution</a>(TrapFrame, VdmTib);
00417 
00418     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00419 }
00420 
00421 
00422 BOOLEAN
00423 <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a12">VdmDispatchIoToHandler</a>(
00424     IN PVDM_IO_HANDLER VdmIoHandler,
00425     IN ULONG Context,
00426     IN ULONG PortNumber,
00427     IN ULONG Size,
00428     IN BOOLEAN Read,
00429     IN OUT PULONG Data
00430     )
00431 <span class="comment">/*++</span>
00432 <span class="comment"></span>
00433 <span class="comment">Routine Description:</span>
00434 <span class="comment"></span>
00435 <span class="comment">     This routine calls the handler for the IO.  If there is not a handler</span>
00436 <span class="comment">     of the proper size, it will call this function for 2 io's to the next</span>
00437 <span class="comment">     smaller size.  If the size was a byte, and there was no handler, FALSE</span>
00438 <span class="comment">     is returned.</span>
00439 <span class="comment"></span>
00440 <span class="comment">Arguments:</span>
00441 <span class="comment"></span>
00442 <span class="comment">    VdmIoHandler -- Supplies a pointer to the handler table</span>
00443 <span class="comment">    Context -- Supplies 32 bits of data set when the port was trapped</span>
00444 <span class="comment">    PortNumber -- Supplies the port number the IO was done to</span>
00445 <span class="comment">    Size -- Supplies the size of the IO operation.</span>
00446 <span class="comment">    Read -- Indicates whether the IO operation was a read or a write.</span>
00447 <span class="comment">    Result -- Supplies a pointer to the location to put the result</span>
00448 <span class="comment"></span>
00449 <span class="comment">Return Value:</span>
00450 <span class="comment"></span>
00451 <span class="comment">    True if one or more handlers were called to take care of the IO.</span>
00452 <span class="comment">    False if no handler was called to take care of the IO.</span>
00453 <span class="comment"></span>
00454 <span class="comment">--*/</span>
00455 {
00456     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00457     BOOLEAN Success1, Success2;
00458     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> FnIndex;
00459     UCHAR AccessType;
00460 
00461     <span class="comment">// Insure that Io is aligned</span>
00462     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>((!(PortNumber % Size)));
00463 
00464     <span class="keywordflow">if</span> (Read) {
00465         FnIndex = 0;
00466         AccessType = <a class="code" href="../../d4/d3/v86emul_8h.html#a0">EMULATOR_READ_ACCESS</a>;
00467     } <span class="keywordflow">else</span> {
00468         FnIndex = 1;
00469         AccessType = <a class="code" href="../../d4/d3/v86emul_8h.html#a1">EMULATOR_WRITE_ACCESS</a>;
00470     }
00471 
00472     <span class="keywordflow">switch</span> (<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>) {
00473     <span class="keywordflow">case</span> 1:
00474         <span class="keywordflow">if</span> (VdmIoHandler-&gt;IoFunctions[FnIndex].UcharIo[PortNumber % 4]) {
00475             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = (*(VdmIoHandler-&gt;IoFunctions[FnIndex].UcharIo[PortNumber % 4]))(
00476                 Context,
00477                 PortNumber,
00478                 AccessType,
00479                 (PUCHAR)Data
00480                 );
00481             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(Status)) {
00482                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00483             }
00484         }
00485         <span class="comment">// No handler for this port</span>
00486         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00487 
00488     <span class="keywordflow">case</span> 2:
00489         <span class="keywordflow">if</span> (VdmIoHandler-&gt;IoFunctions[FnIndex].UshortIo[PortNumber % 2]) {
00490             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = (*(VdmIoHandler-&gt;IoFunctions[FnIndex].UshortIo[PortNumber % 2]))(
00491                 Context,
00492                 PortNumber,
00493                 AccessType,
00494                 (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>)Data
00495                 );
00496             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(Status)) {
00497                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00498             }
00499         } <span class="keywordflow">else</span> {
00500             <span class="comment">// Dispatch to the two uchar handlers for this ushort port</span>
00501             Success1 = <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a12">VdmDispatchIoToHandler</a>(
00502                 VdmIoHandler,
00503                 Context,
00504                 PortNumber,
00505                 Size /2,
00506                 Read,
00507                 Data
00508                 );
00509 
00510             Success2 = <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a12">VdmDispatchIoToHandler</a>(
00511                 VdmIoHandler,
00512                 Context,
00513                 PortNumber + 1,
00514                 Size / 2,
00515                 Read,
00516                 (PULONG)((PUCHAR)Data + 1)
00517                 );
00518 
00519             <span class="keywordflow">return</span> (Success1 || Success2);
00520 
00521         }
00522         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00523 
00524     <span class="keywordflow">case</span> 4:
00525         <span class="keywordflow">if</span> (VdmIoHandler-&gt;IoFunctions[FnIndex].UlongIo) {
00526             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = (*(VdmIoHandler-&gt;IoFunctions[FnIndex].UlongIo))(
00527                 Context,
00528                 PortNumber,
00529                 AccessType,
00530                 Data
00531                 );
00532             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(Status)) {
00533                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00534             }
00535         } <span class="keywordflow">else</span> {
00536             <span class="comment">// Dispatch to the two ushort handlers for this port</span>
00537             Success1 = <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a12">VdmDispatchIoToHandler</a>(
00538                 VdmIoHandler,
00539                 Context,
00540                 PortNumber,
00541                 Size /2,
00542                 Read,
00543                 Data);
00544             Success2 = <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a12">VdmDispatchIoToHandler</a>(
00545                 VdmIoHandler,
00546                 Context,
00547                 PortNumber + 2,
00548                 Size / 2,
00549                 Read,
00550                 (PULONG)((PUSHORT)Data + 1)
00551                 );
00552 
00553             <span class="keywordflow">return</span> (Success1 || Success2);
00554         }
00555         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00556     }
00557 }
00558 
00559 BOOLEAN
00560 <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a13">VdmDispatchUnalignedIoToHandler</a>(
00561     IN PVDM_IO_HANDLER VdmIoHandler,
00562     IN ULONG Context,
00563     IN ULONG PortNumber,
00564     IN ULONG Size,
00565     IN BOOLEAN Read,
00566     IN OUT PULONG Data
00567     )
00568 <span class="comment">/*++</span>
00569 <span class="comment"></span>
00570 <span class="comment">Routine Description:</span>
00571 <span class="comment"></span>
00572 <span class="comment">     This routine converts the unaligned IO to the necessary number of aligned</span>
00573 <span class="comment">     IOs to smaller ports.</span>
00574 <span class="comment"></span>
00575 <span class="comment">Arguments:</span>
00576 <span class="comment"></span>
00577 <span class="comment">    VdmIoHandler -- Supplies a pointer to the handler table</span>
00578 <span class="comment">    Context -- Supplies 32 bits of data set when the port was trapped</span>
00579 <span class="comment">    PortNumber -- Supplies the port number the IO was done to</span>
00580 <span class="comment">    Size -- Supplies the size of the IO operation.</span>
00581 <span class="comment">    Read -- Indicates whether the IO operation was a read or a write.</span>
00582 <span class="comment">    Result -- Supplies a pointer to the location to put the result</span>
00583 <span class="comment"></span>
00584 <span class="comment">Return Value:</span>
00585 <span class="comment"></span>
00586 <span class="comment">    True if one or more handlers were called to take care of the IO.</span>
00587 <span class="comment">    False if no handler was called to take care of the IO.</span>
00588 <span class="comment"></span>
00589 <span class="comment">--*/</span>
00590 {
00591     ULONG <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>;
00592     BOOLEAN Success;
00593 
00594     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>((Size &gt; 1));
00595     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>((PortNumber % Size));
00596 
00597     <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> = 0;
00598 
00599     <span class="comment">//</span>
00600     <span class="comment">//  The possible unaligned io situations are as follows.</span>
00601     <span class="comment">//</span>
00602     <span class="comment">//  1.  Uchar aligned Ulong io</span>
00603     <span class="comment">//          We have to dispatch a uchar io, a ushort io, and a uchar io</span>
00604     <span class="comment">//</span>
00605     <span class="comment">//  2.  Ushort aligned Ulong Io</span>
00606     <span class="comment">//          We have to dispatch a ushort io, and a ushort io</span>
00607     <span class="comment">//</span>
00608     <span class="comment">//  3.  Uchar aligned Ushort Io</span>
00609     <span class="comment">//          We have to dispatch a uchar io and a uchar io</span>
00610     <span class="comment">//</span>
00611 
00612     <span class="comment">// if the port is uchar aligned</span>
00613     <span class="keywordflow">if</span> ((PortNumber % <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>) &amp; 1) {
00614         Success = <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a12">VdmDispatchIoToHandler</a>(
00615             VdmIoHandler,
00616             Context,
00617             PortNumber,
00618             1,
00619             Read,
00620             Data
00621             );
00622         <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> += 1;
00623     <span class="comment">// else it is ushort aligned (and therefore must be a ulong port)</span>
00624     } <span class="keywordflow">else</span> {
00625         Success = <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a12">VdmDispatchIoToHandler</a>(
00626             VdmIoHandler,
00627             Context,
00628             PortNumber,
00629             2,
00630             Read,
00631             Data
00632             );
00633         <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> += 2;
00634     }
00635 
00636     <span class="comment">// if it is a ulong port, we know we have a ushort IO to dispatch</span>
00637     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> == 4) {
00638         Success |= <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a12">VdmDispatchIoToHandler</a>(
00639             VdmIoHandler,
00640             Context,
00641             PortNumber + Offset,
00642             2,
00643             Read,
00644             (PULONG)((PUCHAR)Data + Offset)
00645             );
00646         <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> += 2;
00647     }
00648 
00649     <span class="comment">// If we haven't dispatched the entire port, dispatch the final uchar</span>
00650     <span class="keywordflow">if</span> (<a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> != 4) {
00651         Success |= <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a12">VdmDispatchIoToHandler</a>(
00652             VdmIoHandler,
00653             Context,
00654             PortNumber + Offset,
00655             1,
00656             Read,
00657             (PULONG)((PUCHAR)Data + Offset)
00658             );
00659     }
00660 
00661     <span class="keywordflow">return</span> Success;
00662 }
00663 
00664 
00665 BOOLEAN
00666 <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a14">VdmDispatchStringIoToHandler</a>(
00667     IN PVDM_IO_HANDLER VdmIoHandler,
00668     IN ULONG Context,
00669     IN ULONG PortNumber,
00670     IN ULONG Size,
00671     IN ULONG Count,
00672     IN BOOLEAN Read,
00673     IN ULONG Data
00674     )
00675 <span class="comment">/*++</span>
00676 <span class="comment"></span>
00677 <span class="comment">Routine Description:</span>
00678 <span class="comment"></span>
00679 <span class="comment">     This routine calls the handler for the IO.  If there is not a handler</span>
00680 <span class="comment">     of the proper size, or the io is not aligned, it will simulate the io</span>
00681 <span class="comment">     to the normal io handlers.</span>
00682 <span class="comment"></span>
00683 <span class="comment">Arguments:</span>
00684 <span class="comment"></span>
00685 <span class="comment">    VdmIoHandler -- Supplies a pointer to the handler table</span>
00686 <span class="comment">    Context -- Supplies 32 bits of data set when the port was trapped</span>
00687 <span class="comment">    PortNumber -- Supplies the port number the IO was done to</span>
00688 <span class="comment">    Size -- Supplies the size of the IO operation.</span>
00689 <span class="comment">    Count -- Supplies the number of IO operations.</span>
00690 <span class="comment">    Read -- Indicates whether the IO operation was a read or a write.</span>
00691 <span class="comment">    Data -- Supplies a segmented address at which to put the result.</span>
00692 <span class="comment"></span>
00693 <span class="comment">Return Value:</span>
00694 <span class="comment"></span>
00695 <span class="comment">    True if one or more handlers were called to take care of the IO.</span>
00696 <span class="comment">    False if no handler was called to take care of the IO.</span>
00697 <span class="comment"></span>
00698 <span class="comment">--*/</span>
00699 {
00700     BOOLEAN Success = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00701     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> FnIndex;
00702     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00703 
00704     <span class="keywordflow">if</span> (Read) {
00705         FnIndex = 0;
00706     } <span class="keywordflow">else</span> {
00707         FnIndex = 1;
00708     }
00709 
00710     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>(
00711         &amp;VdmStringIoMutex,
00712         Executive,
00713         KernelMode,
00714         FALSE,
00715         NULL
00716         );
00717 
00718     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(Status)) {
00719         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00720     }
00721 
00722     <span class="keywordflow">switch</span> (<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>) {
00723     <span class="keywordflow">case</span> 1:
00724         Success = <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a15">VdmCallStringIoHandler</a>(
00725             VdmIoHandler,
00726             (PVOID)VdmIoHandler-&gt;IoFunctions[FnIndex].UcharStringIo[PortNumber % 4],
00727             Context,
00728             PortNumber,
00729             Size,
00730             Count,
00731             Read,
00732             Data
00733             );
00734     <span class="keywordflow">case</span> 2:
00735         Success = <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a15">VdmCallStringIoHandler</a>(
00736             VdmIoHandler,
00737             (PVOID)VdmIoHandler-&gt;IoFunctions[FnIndex].UshortStringIo[PortNumber % 2],
00738             Context,
00739             PortNumber,
00740             Size,
00741             Count,
00742             Read,
00743             Data
00744             );
00745     <span class="keywordflow">case</span> 4:
00746         Success = <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a15">VdmCallStringIoHandler</a>(
00747             VdmIoHandler,
00748             (PVOID)VdmIoHandler-&gt;IoFunctions[FnIndex].UlongStringIo,
00749             Context,
00750             PortNumber,
00751             Size,
00752             Count,
00753             Read,
00754             Data
00755             );
00756     }
00757     <a class="code" href="../../d3/d5/mutntobj_8c.html#a5">KeReleaseMutex</a>(&amp;VdmStringIoMutex, FALSE);
00758     <span class="keywordflow">return</span> Success;
00759 }
00760 
00761 <span class="preprocessor">#define STRINGIO_BUFFER_SIZE 1024</span>
00762 <span class="preprocessor"></span>UCHAR <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a8">VdmStringIoBuffer</a>[<a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a1">STRINGIO_BUFFER_SIZE</a>];
00763 
00764 BOOLEAN
00765 <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a15">VdmCallStringIoHandler</a>(
00766     IN PVDM_IO_HANDLER VdmIoHandler,
00767     IN PVOID StringIoRoutine,
00768     IN ULONG Context,
00769     IN ULONG PortNumber,
00770     IN ULONG Size,
00771     IN ULONG Count,
00772     IN BOOLEAN Read,
00773     IN ULONG Data
00774     )
00775 <span class="comment">/*++</span>
00776 <span class="comment"></span>
00777 <span class="comment">Routine Description:</span>
00778 <span class="comment"></span>
00779 <span class="comment">    This routine actually performs the call to string io routine.  It takes</span>
00780 <span class="comment">    care of buffering the user data in kernel space so that the device driver</span>
00781 <span class="comment">    does not have to.  If there is not a string io function, or the io is</span>
00782 <span class="comment">    misaligned, it will be simulated as a series of normal io operations</span>
00783 <span class="comment"></span>
00784 <span class="comment">Arguments:</span>
00785 <span class="comment"></span>
00786 <span class="comment">    StringIoRoutine -- Supplies a pointer to the string Io routine</span>
00787 <span class="comment">    Context -- Supplies 32 bits of data set when the port was trapped</span>
00788 <span class="comment">    PortNumber -- Supplies the number of the port to perform Io to</span>
00789 <span class="comment">    Size -- Supplies the size of the io operations</span>
00790 <span class="comment">    Count -- Supplies the number of Io operations in the string.</span>
00791 <span class="comment">    Read -- Indicates a read operation</span>
00792 <span class="comment">    Data -- Supplies a pointer to the user buffer to perform the io on.</span>
00793 <span class="comment"></span>
00794 <span class="comment">Returns</span>
00795 <span class="comment"></span>
00796 <span class="comment">    TRUE if a handler was called</span>
00797 <span class="comment">    FALSE if not.</span>
00798 <span class="comment"></span>
00799 <span class="comment">--*/</span>
00800 {
00801     ULONG TotalBytes,BytesDone,BytesToDo,LoopCount,NumberIo;
00802     PUCHAR CurrentDataPtr;
00803     UCHAR AccessType;
00804     EXCEPTION_RECORD ExceptionRecord;
00805     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00806     BOOLEAN Success;
00807 
00808     Success = <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a19">VdmConvertToLinearAddress</a>(
00809         Data,
00810         &amp;CurrentDataPtr
00811         );
00812 
00813     <span class="keywordflow">if</span> (!Success) {
00814         ExceptionRecord.ExceptionCode = STATUS_ACCESS_VIOLATION;
00815         ExceptionRecord.ExceptionFlags = 0;
00816         ExceptionRecord.NumberParameters = 0;
00817         <a class="code" href="../../d5/d8/ex_8h.html#a302">ExRaiseException</a>(&amp;ExceptionRecord);
00818         <span class="comment">// Cause kernel exit, rather than Io reflection</span>
00819         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00820     }
00821 
00822 
00823     TotalBytes = <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> * <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
00824     BytesDone = 0;
00825 
00826     <span class="keywordflow">if</span> (PortNumber % <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>) {
00827         StringIoRoutine = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00828     }
00829 
00830     <span class="keywordflow">if</span> (Read) {
00831         AccessType = <a class="code" href="../../d4/d3/v86emul_8h.html#a0">EMULATOR_READ_ACCESS</a>;
00832     } <span class="keywordflow">else</span> {
00833         AccessType = <a class="code" href="../../d4/d3/v86emul_8h.html#a1">EMULATOR_WRITE_ACCESS</a>;
00834     }
00835 
00836 
00837     <span class="comment">// Set up try out here to avoid overhead in loop</span>
00838     <span class="keywordflow">try</span> {
00839         <span class="keywordflow">while</span> (BytesDone &lt; TotalBytes) {
00840             <span class="keywordflow">if</span> ((BytesDone + <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a1">STRINGIO_BUFFER_SIZE</a>) &gt; TotalBytes) {
00841                 BytesToDo = TotalBytes - BytesDone;
00842             } <span class="keywordflow">else</span> {
00843                 BytesToDo = <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a1">STRINGIO_BUFFER_SIZE</a>;
00844             }
00845 
00846             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>((!(BytesToDo % Size)));
00847 
00848             <span class="keywordflow">if</span> (!Read) {
00849                 RtlMoveMemory(VdmStringIoBuffer, CurrentDataPtr, BytesToDo);
00850             }
00851 
00852             NumberIo = BytesToDo / <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
00853 
00854             <span class="keywordflow">if</span> (StringIoRoutine) {
00855                 <span class="comment">// in order to avoid having 3 separate calls, one for each size</span>
00856                 <span class="comment">// we simply cast the parameters appropriately for the</span>
00857                 <span class="comment">// byte routine.</span>
00858 
00859                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = (*((<a class="code" href="../../d4/d3/v86emul_8h.html#a7">PDRIVER_IO_PORT_UCHAR_STRING</a>)StringIoRoutine))(
00860                     Context,
00861                     PortNumber,
00862                     AccessType,
00863                     <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a8">VdmStringIoBuffer</a>,
00864                     NumberIo
00865                     );
00866 
00867                 <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(Status)) {
00868                     Success |= <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00869                 }
00870             } <span class="keywordflow">else</span> {
00871                 <span class="keywordflow">if</span> (PortNumber % <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>) {
00872                     <span class="keywordflow">for</span> (LoopCount = 0; LoopCount &lt; NumberIo; LoopCount++ ) {
00873                         Success |= <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a13">VdmDispatchUnalignedIoToHandler</a>(
00874                             VdmIoHandler,
00875                             Context,
00876                             PortNumber,
00877                             Size,
00878                             Read,
00879                             (PULONG)(VdmStringIoBuffer + LoopCount * Size)
00880                             );
00881                     }
00882                 } <span class="keywordflow">else</span> {
00883                     <span class="keywordflow">for</span> (LoopCount = 0; LoopCount &lt; NumberIo; LoopCount++ ) {
00884                         Success |= <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a12">VdmDispatchIoToHandler</a>(
00885                             VdmIoHandler,
00886                             Context,
00887                             PortNumber,
00888                             Size,
00889                             Read,
00890                             (PULONG)(VdmStringIoBuffer + LoopCount * Size)
00891                             );
00892                     }
00893 
00894                 }
00895             }
00896 
00897             <span class="keywordflow">if</span> (Read) {
00898                 RtlMoveMemory(CurrentDataPtr, VdmStringIoBuffer, BytesToDo);
00899             }
00900 
00901             BytesDone += BytesToDo;
00902             CurrentDataPtr += BytesToDo;
00903         }
00904     } except(EXCEPTION_EXECUTE_HANDLER) {
00905         ExceptionRecord.ExceptionCode = GetExceptionCode();
00906         ExceptionRecord.ExceptionFlags = 0;
00907         ExceptionRecord.NumberParameters = 0;
00908         <a class="code" href="../../d5/d8/ex_8h.html#a302">ExRaiseException</a>(&amp;ExceptionRecord);
00909         <span class="comment">// Cause kernel exit, rather than Io reflection</span>
00910         Success = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00911     }
00912     <span class="keywordflow">return</span> Success;
00913 
00914 }
00915 
00916 
00917 BOOLEAN
00918 <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a19">VdmConvertToLinearAddress</a>(
00919     IN ULONG SegmentedAddress,
00920     OUT PVOID *LinearAddress
00921     )
00922 <span class="comment">/*++</span>
00923 <span class="comment"></span>
00924 <span class="comment">Routine Description:</span>
00925 <span class="comment"></span>
00926 <span class="comment">    This routine converts the specified segmented address into a linear</span>
00927 <span class="comment">    address, based on processor mode in user mode.</span>
00928 <span class="comment"></span>
00929 <span class="comment">Arguments:</span>
00930 <span class="comment"></span>
00931 <span class="comment">    SegmentedAddress -- Supplies the segmented address to convert.</span>
00932 <span class="comment">    LinearAddress -- Supplies a pointer to the destination for the</span>
00933 <span class="comment">        coresponding linear address</span>
00934 <span class="comment"></span>
00935 <span class="comment">Return Value:</span>
00936 <span class="comment"></span>
00937 <span class="comment">    True if the address was converted.</span>
00938 <span class="comment">    False otherwise</span>
00939 <span class="comment"></span>
00940 <span class="comment">Note:</span>
00941 <span class="comment"></span>
00942 <span class="comment">    A linear address of 0 is a valid return</span>
00943 <span class="comment">--*/</span>
00944 {
00945     <a class="code" href="../../d1/d8/struct__KTHREAD.html">PKTHREAD</a> Thread;
00946     PKIA32_FRAME TrapFrame;
00947     BOOLEAN Success;
00948     KXDESCRIPTOR XDescriptor;
00949     ULONG Base, Limit, Flags;
00950 
00951     Thread = <a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a3">KeGetCurrentThread</a>();
00952     TrapFrame = (PKIA32_FRAME) VdmGetTrapFrame(Thread);
00953 
00954     <span class="keywordflow">if</span> (TrapFrame-&gt;EFlags &amp; EFLAGS_V86_MASK) {
00955         *LinearAddress = (PVOID)(((SegmentedAddress &amp; 0xFFFF0000) &gt;&gt; 12) +
00956             (SegmentedAddress &amp; 0xFFFF));
00957         Success = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00958     } <span class="keywordflow">else</span> {
00959         Success = KeIA32UnscrambleLdtEntry(
00960             (USHORT)((SegmentedAddress &amp; 0xFFFF0000) &gt;&gt; 12),
00961             &amp;XDescriptor
00962             );
00963         <span class="keywordflow">if</span> (Success) {
00964             *LinearAddress = (PVOID)(XDescriptor.Words.Bits.Base + 
00965                              (SegmentedAddress &amp; 0xFFFF));
00966         }
00967     }
00968     <span class="keywordflow">return</span> Success;
00969 }
00970 
00971 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00972 KeIA32VdmInitialize(
00973     VOID
00974     )
00975 <span class="comment">/*++</span>
00976 <span class="comment"></span>
00977 <span class="comment">Routine Description:</span>
00978 <span class="comment"></span>
00979 <span class="comment">    This routine initializes the vdm stuff</span>
00980 <span class="comment"></span>
00981 <span class="comment">Arguments:</span>
00982 <span class="comment"></span>
00983 <span class="comment">    None</span>
00984 <span class="comment"></span>
00985 <span class="comment">Return Value:</span>
00986 <span class="comment"></span>
00987 <span class="comment">    None</span>
00988 <span class="comment">--*/</span>
00989 {
00990     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00991     OBJECT_ATTRIBUTES <a class="code" href="../../d7/d0/ctlnpqos_8c.html#a4">ObjectAttributes</a>;
00992     HANDLE RegistryHandle = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00993     UNICODE_STRING WorkString;
00994     UCHAR KeyInformation[<span class="keyword">sizeof</span>(KEY_VALUE_BASIC_INFORMATION) + 30];
00995     ULONG ResultLength;
00996 
00997     <a class="code" href="../../d3/d5/mutntobj_8c.html#a2">KeInitializeMutex</a>( &amp;VdmStringIoMutex, MUTEX_LEVEL_VDM_IO );
00998 
00999     <span class="comment">//</span>
01000     <span class="comment">// Set up and open KeyPath to wow key</span>
01001     <span class="comment">//</span>
01002 
01003     <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(
01004         &amp;WorkString,
01005         L<span class="stringliteral">"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Wow"</span>
01006         );
01007 
01008     InitializeObjectAttributes(
01009         &amp;ObjectAttributes,
01010         &amp;WorkString,
01011         OBJ_CASE_INSENSITIVE,
01012         (HANDLE)NULL,
01013         NULL
01014         );
01015 
01016     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwOpenKey(
01017         &amp;RegistryHandle,
01018         KEY_READ,
01019         &amp;ObjectAttributes
01020         );
01021 
01022     <span class="comment">//</span>
01023     <span class="comment">// If there is no Wow key, don't allow Vdms to run</span>
01024     <span class="comment">//</span>
01025     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(Status)) {
01026         <span class="keywordflow">return</span>;
01027     }
01028 
01029     <span class="comment">//</span>
01030     <span class="comment">// Set up for using virtual interrupt extensions if they are available</span>
01031     <span class="comment">//</span>
01032 
01033 <span class="preprocessor">#ifdef USE_VME</span>
01034 <span class="preprocessor"></span>
01035     <span class="comment">//</span>
01036     <span class="comment">// Get the Pentium Feature disable value.</span>
01037     <span class="comment">// If this value is present, don't enable vme stuff.</span>
01038     <span class="comment">//</span>
01039     <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(
01040         &amp;WorkString,
01041         L<span class="stringliteral">"DisableVme"</span>
01042         );
01043 
01044     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwQueryValueKey(
01045         RegistryHandle,
01046         &amp;WorkString,
01047         KeyValueBasicInformation,
01048         &amp;KeyInformation,
01049         <span class="keyword">sizeof</span>(KEY_VALUE_BASIC_INFORMATION) + 30,
01050         &amp;ResultLength
01051         );
01052 
01053     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(Status)) {
01054 
01055         <span class="comment">//</span>
01056         <span class="comment">// If we have the extensions, set the appropriate bits</span>
01057         <span class="comment">// in cr4</span>
01058         <span class="comment">//</span>
01059                 <span class="comment">//</span>
01060                 <span class="comment">// The merced processor emulates the P6, but we don't</span>
01061                 <span class="comment">// plan on implementing it... We might implement the PVI</span>
01062                 <span class="comment">// stuff though...</span>
01063                 <span class="comment">//</span>
01064         <span class="keywordflow">if</span> (<a class="code" href="../../d4/d9/ke_8h.html#a137">KeFeatureBits</a> &amp; <a class="code" href="../../d5/d3/i386_8h.html#a0">KF_V86_VIS</a>) {
01065             <a class="code" href="../../d2/d1/xipi_8c.html#a1">KiIpiGenericCall</a>(
01066                 KiIA32VdmEnablePentiumExtentions,
01067                 TRUE
01068                 );
01069             <a class="code" href="../../d0/d6/emulx86_8c.html#a3">KeIA32VirtualIntExtensions</a> = V86_VIRTUAL_INT_EXTENSIONS;
01070         }
01071     }
01072 
01073     <span class="comment">//</span>
01074     <span class="comment">// If we have V86 mode int extensions, we don't want to run with</span>
01075     <span class="comment">// IOPL in v86 mode</span>
01076     <span class="comment">//</span>
01077     <span class="keywordflow">if</span> (!<a class="code" href="../../d0/d6/emulx86_8c.html#a3">KeIA32VirtualIntExtensions</a> &amp; V86_VIRTUAL_INT_EXTENSIONS) {
01078         <span class="comment">//</span>
01079         <span class="comment">// Read registry to determine if Vdms will run with IOPL in v86 mode</span>
01080         <span class="comment">//</span>
01081 
01082         <span class="comment">//</span>
01083         <span class="comment">// Get the VdmIOPL value.</span>
01084         <span class="comment">//</span>
01085         <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(
01086             &amp;WorkString,
01087             L<span class="stringliteral">"VdmIOPL"</span>
01088             );
01089 
01090         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwQueryValueKey(
01091             RegistryHandle,
01092             &amp;WorkString,
01093             KeyValueBasicInformation,
01094             &amp;KeyInformation,
01095             <span class="keyword">sizeof</span>(KEY_VALUE_BASIC_INFORMATION) + 30,
01096             &amp;ResultLength
01097             );
01098 
01099         <span class="comment">//</span>
01100         <span class="comment">// If the value exists, let Vdms run with IOPL in V86 mode</span>
01101         <span class="comment">//</span>
01102         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(Status)) {
01103             <span class="comment">//</span>
01104             <span class="comment">// KeEflagsAndMaskV86 and KeEflagsOrMaskV86 are used</span>
01105             <span class="comment">// in SANITIZE_FLAGS, and the Vdm code to make sure the</span>
01106             <span class="comment">// values in EFlags for v86 mode trap frames are acceptable</span>
01107             <span class="comment">//</span>
01108             <a class="code" href="../../d0/d6/emulx86_8c.html#a0">KeIA32EFlagsAndMaskV86</a> = EFLAGS_USER_SANITIZE | EFLAGS_INTERRUPT_MASK;
01109             <a class="code" href="../../d0/d6/emulx86_8c.html#a1">KeIA32EFlagsOrMaskV86</a> = EFLAGS_IOPL_MASK;
01110 
01111             <span class="comment">//</span>
01112             <span class="comment">// KeVdmIoplAllowed is used by the Vdm code to determine if</span>
01113             <span class="comment">// the virtual interrupt flag is in EFlags, or 40:xx</span>
01114             <span class="comment">//</span>
01115             <a class="code" href="../../d0/d6/emulx86_8c.html#a2">KeIA32VdmIoplAllowed</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01116 
01117         }
01118     }
01119 <span class="preprocessor">#endif</span>
01120 <span class="preprocessor"></span>    ZwClose(RegistryHandle);
01121 }
01122 
01123 
01124 BOOLEAN
01125 KeIA32VdmInsertQueueApc (
01126     IN <a class="code" href="../../d1/d5/struct__KAPC.html">PKAPC</a>             Apc,
01127     IN <a class="code" href="../../d1/d8/struct__KTHREAD.html">PKTHREAD</a>          Thread,
01128     IN KPROCESSOR_MODE   ApcMode,
01129     IN PKKERNEL_ROUTINE  KernelRoutine,
01130     IN PKRUNDOWN_ROUTINE RundownRoutine OPTIONAL,
01131     IN PKNORMAL_ROUTINE  NormalRoutine  OPTIONAL,
01132     IN PVOID             NormalContext   OPTIONAL,
01133     IN PVOID             SystemArgument1 OPTIONAL,
01134     IN PVOID             SystemArgument2 OPTIONAL,
01135     IN KPRIORITY         Increment
01136     )
01137 
01138 <span class="comment">/*++</span>
01139 <span class="comment"></span>
01140 <span class="comment">Routine Description:</span>
01141 <span class="comment"></span>
01142 <span class="comment">    This function initializes, and queues a vdm type of APC to the</span>
01143 <span class="comment">    specified thread.</span>
01144 <span class="comment"></span>
01145 <span class="comment"></span>
01146 <span class="comment">    A Vdm type of APC:</span>
01147 <span class="comment">       - OriginalApcEnvironment</span>
01148 <span class="comment">       - will only be queued to one thread at a time</span>
01149 <span class="comment">       - if UserMode Fires on the next system exit. A UserMode apc should</span>
01150 <span class="comment">         not be queued if the current vdm context is not application mode.</span>
01151 <span class="comment"></span>
01152 <span class="comment">Arguments:</span>
01153 <span class="comment"></span>
01154 <span class="comment">    Apc - Supplies a pointer to a control object of type APC.</span>
01155 <span class="comment"></span>
01156 <span class="comment">    Thread - Supplies a pointer to a dispatcher object of type thread.</span>
01157 <span class="comment"></span>
01158 <span class="comment">    ApcMode - Supplies the processor mode user\kernel of the Apc</span>
01159 <span class="comment"></span>
01160 <span class="comment">    KernelRoutine - Supplies a pointer to a function that is to be</span>
01161 <span class="comment">        executed at IRQL APC_LEVEL in kernel mode.</span>
01162 <span class="comment"></span>
01163 <span class="comment">    RundownRoutine - Supplies an optional pointer to a function that is to be</span>
01164 <span class="comment">        called if the APC is in a thread's APC queue when the thread terminates.</span>
01165 <span class="comment"></span>
01166 <span class="comment">    NormalRoutine - Supplies an optional pointer to a function that is</span>
01167 <span class="comment">        to be executed at IRQL 0 in the specified processor mode. If this</span>
01168 <span class="comment">        parameter is not specified, then the ProcessorMode and NormalContext</span>
01169 <span class="comment">        parameters are ignored.</span>
01170 <span class="comment"></span>
01171 <span class="comment">    NormalContext - Supplies a pointer to an arbitrary data structure which is</span>
01172 <span class="comment">        to be passed to the function specified by the NormalRoutine parameter.</span>
01173 <span class="comment"></span>
01174 <span class="comment">    SystemArgument1, SystemArgument2 - Supply a set of two arguments that</span>
01175 <span class="comment">        contain untyped data provided by the executive.</span>
01176 <span class="comment"></span>
01177 <span class="comment">    Increment - Supplies the priority increment that is to be applied if</span>
01178 <span class="comment">        queuing the APC causes a thread wait to be satisfied.</span>
01179 <span class="comment"></span>
01180 <span class="comment"></span>
01181 <span class="comment">Return Value:</span>
01182 <span class="comment"></span>
01183 <span class="comment">    If APC queuing is disabled, then a value of FALSE is returned.</span>
01184 <span class="comment">    Otherwise a value of TRUE is returned.</span>
01185 <span class="comment"></span>
01186 <span class="comment"></span>
01187 <span class="comment">--*/</span>
01188 {
01189 
01190     <a class="code" href="../../d3/d5/struct__KAPC__STATE.html">PKAPC_STATE</a> ApcState;
01191     <a class="code" href="../../d1/d8/struct__KTHREAD.html">PKTHREAD</a> ApcThread;
01192     KIRQL   OldIrql;
01193     BOOLEAN Inserted;
01194 
01195     <span class="comment">//</span>
01196     <span class="comment">// Raise IRQL to dispatcher level and lock dispatcher database.</span>
01197     <span class="comment">//</span>
01198 
01199     <a class="code" href="../../d4/d9/ke_8h.html#a36">KiLockDispatcherDatabase</a>(&amp;OldIrql);
01200 
01201     <span class="comment">//</span>
01202     <span class="comment">// If the apc object not initialized, then initialize it and acquire</span>
01203     <span class="comment">// the target thread APC queue lock.</span>
01204     <span class="comment">//</span>
01205 
01206     <span class="keywordflow">if</span> (Apc-&gt;Type != <a class="code" href="../../d4/d9/ke_8h.html#a402a175">ApcObject</a>) {
01207         Apc-&gt;Type = <a class="code" href="../../d4/d9/ke_8h.html#a402a175">ApcObject</a>;
01208         Apc-&gt;Size = <span class="keyword">sizeof</span>(<a class="code" href="../../d1/d5/struct__KAPC.html">KAPC</a>);
01209         Apc-&gt;ApcStateIndex  = <a class="code" href="../../d4/d9/ke_8h.html#a403a181">OriginalApcEnvironment</a>;
01210     } <span class="keywordflow">else</span> {
01211 
01212         <span class="comment">//</span>
01213         <span class="comment">// Acquire the APC thread APC queue lock.</span>
01214         <span class="comment">//</span>
01215         <span class="comment">// If the APC is inserted in the corresponding APC queue, and the</span>
01216         <span class="comment">// APC thread is not the same thread as the target thread, then</span>
01217         <span class="comment">// the APC is removed from its current queue, the APC pending state</span>
01218         <span class="comment">// is updated, the APC thread APC queue lock is released, and the</span>
01219         <span class="comment">// target thread APC queue lock is acquired. Otherwise, the APC</span>
01220         <span class="comment">// thread and the target thread are same thread and the APC is already</span>
01221         <span class="comment">// queued to the correct thread.</span>
01222         <span class="comment">//</span>
01223         <span class="comment">// If the APC is not inserted in an APC queue, then release the</span>
01224         <span class="comment">// APC thread APC queue lock and acquire the target thread APC queue</span>
01225         <span class="comment">// lock.</span>
01226         <span class="comment">//</span>
01227 
01228         ApcThread = Apc-&gt;Thread;
01229         <span class="keywordflow">if</span> (ApcThread) {
01230             KiAcquireSpinLock(&amp;ApcThread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o38">ApcQueueLock</a>);
01231             <span class="keywordflow">if</span> (Apc-&gt;Inserted) {
01232                 <span class="keywordflow">if</span> (ApcThread == Apc-&gt;Thread &amp;&amp; Apc-&gt;Thread != Thread) {
01233                     Apc-&gt;Inserted = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01234                     RemoveEntryList(&amp;Apc-&gt;ApcListEntry);
01235                     ApcState = Apc-&gt;Thread-&gt;ApcStatePointer[Apc-&gt;ApcStateIndex];
01236                     <span class="keywordflow">if</span> (IsListEmpty(&amp;ApcState-&gt;<a class="code" href="../../d3/d5/struct__KAPC__STATE.html#o0">ApcListHead</a>[Apc-&gt;ApcMode]) != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01237                         <span class="keywordflow">if</span> (Apc-&gt;ApcMode == <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
01238                             ApcState-&gt;<a class="code" href="../../d3/d5/struct__KAPC__STATE.html#o3">KernelApcPending</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01239 
01240                         } <span class="keywordflow">else</span> {
01241                             ApcState-&gt;<a class="code" href="../../d3/d5/struct__KAPC__STATE.html#o4">UserApcPending</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01242                         }
01243                     }
01244 
01245                 } <span class="keywordflow">else</span> {
01246                     KiReleaseSpinLock(&amp;ApcThread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o38">ApcQueueLock</a>);
01247                     <a class="code" href="../../d0/d0/ki_8h.html#a84">KiUnlockDispatcherDatabase</a>(OldIrql);
01248                     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01249                 }
01250             }
01251 
01252             KiReleaseSpinLock(&amp;ApcThread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o38">ApcQueueLock</a>);
01253         }
01254     }
01255 
01256 
01257     KiAcquireSpinLock(&amp;Thread-&gt;ApcQueueLock);
01258 
01259     Apc-&gt;ApcMode = ApcMode;
01260     Apc-&gt;Thread  = Thread;
01261     Apc-&gt;KernelRoutine   = KernelRoutine;
01262     Apc-&gt;RundownRoutine  = RundownRoutine;
01263     Apc-&gt;NormalRoutine   = NormalRoutine;
01264     Apc-&gt;SystemArgument1 = SystemArgument1;
01265     Apc-&gt;SystemArgument2 = SystemArgument2;
01266     Apc-&gt;NormalContext   = NormalContext;
01267 
01268     <span class="comment">//</span>
01269     <span class="comment">// Unlock the target thread APC queue.</span>
01270     <span class="comment">//</span>
01271 
01272     KiReleaseSpinLock(&amp;Thread-&gt;ApcQueueLock);
01273 
01274     <span class="comment">//</span>
01275     <span class="comment">// If APC queuing is enable, then attempt to queue the APC object.</span>
01276     <span class="comment">//</span>
01277 
01278     <span class="keywordflow">if</span> (Thread-&gt;ApcQueueable &amp;&amp; <a class="code" href="../../d0/d0/ki_8h.html#a123">KiInsertQueueApc</a>(Apc, Increment)) {
01279         Inserted = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01280 
01281         <span class="comment">//</span>
01282         <span class="comment">// If UserMode:</span>
01283         <span class="comment">//    For vdm a UserMode Apc is only queued by a kernel mode</span>
01284         <span class="comment">//    apc which is on the current thread for the target thread.</span>
01285         <span class="comment">//    Force UserApcPending for User mode apcstate, so that</span>
01286         <span class="comment">//    the apc will fire when this thread exits the kernel.</span>
01287         <span class="comment">//</span>
01288 
01289         <span class="keywordflow">if</span> (ApcMode == <a class="code" href="../../d0/d9/ntosdef_8h.html#a76a70">UserMode</a>) {
01290             <a class="code" href="../../d0/d0/ki_8h.html#a14">KiBoostPriorityThread</a>(Thread, Increment);
01291             Thread-&gt;ApcState.UserApcPending = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01292         }
01293 
01294     } <span class="keywordflow">else</span> {
01295         Inserted = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01296     }
01297 
01298     <span class="comment">//</span>
01299     <span class="comment">// Unlock the dispatcher database, lower IRQL to its previous value, and</span>
01300     <span class="comment">// return whether the APC object was inserted.</span>
01301     <span class="comment">//</span>
01302 
01303     <a class="code" href="../../d0/d0/ki_8h.html#a84">KiUnlockDispatcherDatabase</a>(OldIrql);
01304     <span class="keywordflow">return</span> Inserted;
01305 }
01306 
01307 
01308 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01309 KeIA32VdmClearApcObject(
01310     IN <a class="code" href="../../d1/d5/struct__KAPC.html">PKAPC</a> Apc
01311     )
01312 <span class="comment">/*++</span>
01313 <span class="comment"></span>
01314 <span class="comment">Routine Description:</span>
01315 <span class="comment"></span>
01316 <span class="comment">    Clears a VDM APC object, synchronously with Ke386VdmInsertQueueApc, and</span>
01317 <span class="comment">    is expected to be called by one of the vdm kernel apc routine or the</span>
01318 <span class="comment">    rundown routine.</span>
01319 <span class="comment"></span>
01320 <span class="comment"></span>
01321 <span class="comment">Arguments:</span>
01322 <span class="comment"></span>
01323 <span class="comment">    Apc - Supplies a pointer to a control object of type APC.</span>
01324 <span class="comment"></span>
01325 <span class="comment"></span>
01326 <span class="comment">Return Value:</span>
01327 <span class="comment"></span>
01328 <span class="comment">    void</span>
01329 <span class="comment"></span>
01330 <span class="comment">--*/</span>
01331 {
01332 
01333     KIRQL   OldIrql;
01334 
01335     <span class="comment">//</span>
01336     <span class="comment">// Take Dispatcher database lock, to sync with Ke386VDMInsertQueueApc</span>
01337     <span class="comment">//</span>
01338 
01339     <a class="code" href="../../d4/d9/ke_8h.html#a36">KiLockDispatcherDatabase</a>(&amp;OldIrql);
01340     Apc-&gt;Thread  = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01341     <a class="code" href="../../d0/d0/ki_8h.html#a84">KiUnlockDispatcherDatabase</a>(OldIrql);
01342 
01343 }
01344 
01345 <span class="comment">//</span>
01346 <span class="comment">//  END of ACTIVE CODE</span>
01347 <span class="comment">//</span>
01348 
01349 <span class="preprocessor">#if VDM_IO_TEST</span>
01350 <span class="preprocessor"></span><a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01351 TestIoByteRoutine(
01352     IN ULONG Port,
01353     IN UCHAR AccessMode,
01354     IN OUT PUCHAR Data
01355     )
01356 {
01357     <span class="keywordflow">if</span> (AccessMode &amp; <a class="code" href="../../d4/d3/v86emul_8h.html#a0">EMULATOR_READ_ACCESS</a>) {
01358         *Data = Port - 400;
01359     }
01360 
01361     <span class="keywordflow">return</span> STATUS_SUCCESS;
01362 }
01363 
01364 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01365 TestIoWordReadRoutine(
01366     IN ULONG Port,
01367     IN UCHAR AccessMode,
01368     IN OUT PUSHORT Data
01369     )
01370 {
01371     <span class="keywordflow">if</span> (AccessMode &amp; <a class="code" href="../../d4/d3/v86emul_8h.html#a0">EMULATOR_READ_ACCESS</a>) {
01372         *Data = Port - 200;
01373     }
01374 
01375     <span class="keywordflow">return</span> STATUS_SUCCESS;
01376 }
01377 
01378 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01379 TestIoWordWriteRoutine(
01380     IN ULONG Port,
01381     IN UCHAR AccessMode,
01382     IN OUT PUSHORT Data
01383     )
01384 {
01385     <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"Word Write routine port # %lx, %x\n"</span>,Port,*Data);
01386 
01387     <span class="keywordflow">return</span> STATUS_SUCCESS;
01388 }
01389 
01390 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01391 TestIoDwordRoutine(
01392     IN ULONG Port,
01393     IN USHORT AccessMode,
01394     IN OUT PULONG Data
01395     )
01396 {
01397     <span class="keywordflow">if</span> (AccessMode &amp; <a class="code" href="../../d4/d3/v86emul_8h.html#a0">EMULATOR_READ_ACCESS</a>) {
01398         *Data = Port;
01399     }
01400 
01401     <span class="keywordflow">return</span> STATUS_SUCCESS;
01402 }
01403 
01404 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01405 TestIoStringRoutine(
01406     IN ULONG Port,
01407     IN USHORT AccessMode,
01408     IN OUT PSHORT Data,
01409     IN ULONG Count
01410     )
01411 {
01412     ULONG i;
01413 
01414     <span class="keywordflow">if</span> (AccessMode &amp; <a class="code" href="../../d4/d3/v86emul_8h.html#a0">EMULATOR_READ_ACCESS</a>) {
01415         <span class="keywordflow">for</span> (i = 0;i &lt; <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> ;i++ ) {
01416             Data[i] = i;
01417         }
01418     } <span class="keywordflow">else</span> {
01419         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"String Port Called for write port #%lx,"</span>,Port);
01420         <span class="keywordflow">for</span> (i = 0;i &lt; <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> ;i++ ) {
01421             <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"%x\n"</span>,Data[i]);
01422         }
01423     }
01424 
01425     <span class="keywordflow">return</span> STATUS_SUCCESS;
01426 }
01427 
01428 PROCESS_IO_PORT_HANDLER_INFORMATION IoPortHandler;
01429 <a class="code" href="../../d2/d3/struct__EMULATOR__ACCESS__ENTRY.html">EMULATOR_ACCESS_ENTRY</a> Entry[4];
01430 BOOLEAN Connect = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, Disconnect = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01431 
01432 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01433 TestIoHandlerStuff(
01434     VOID
01435     )
01436 {
01437     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01438 
01439     IoPortHandler.Install = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01440     IoPortHandler.NumEntries = 5<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>;
01441     IoPortHandler.EmulatorAccessEntries = Entry;
01442 
01443     Entry[0].<a class="code" href="../../d2/d3/struct__EMULATOR__ACCESS__ENTRY.html#o0">BasePort</a> = 0x400;
01444     Entry[0].<a class="code" href="../../d2/d3/struct__EMULATOR__ACCESS__ENTRY.html#o1">NumConsecutivePorts</a> = 0x30;
01445     Entry[0].<a class="code" href="../../d2/d3/struct__EMULATOR__ACCESS__ENTRY.html#o2">AccessType</a> = <a class="code" href="../../d4/d3/v86emul_8h.html#a15a12">Uchar</a>;
01446     Entry[0].<a class="code" href="../../d2/d3/struct__EMULATOR__ACCESS__ENTRY.html#o3">AccessMode</a> = <a class="code" href="../../d4/d3/v86emul_8h.html#a0">EMULATOR_READ_ACCESS</a> | <a class="code" href="../../d4/d3/v86emul_8h.html#a1">EMULATOR_WRITE_ACCESS</a>;
01447     Entry[0].<a class="code" href="../../d2/d3/struct__EMULATOR__ACCESS__ENTRY.html#o4">StringSupport</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01448     Entry[0].<a class="code" href="../../d2/d3/struct__EMULATOR__ACCESS__ENTRY.html#o5">Routine</a> = TestIoByteRoutine;
01449 
01450     Entry[1].<a class="code" href="../../d2/d3/struct__EMULATOR__ACCESS__ENTRY.html#o0">BasePort</a> = 0x400;
01451     Entry[1].<a class="code" href="../../d2/d3/struct__EMULATOR__ACCESS__ENTRY.html#o1">NumConsecutivePorts</a> = 0x18;
01452     Entry[1].<a class="code" href="../../d2/d3/struct__EMULATOR__ACCESS__ENTRY.html#o2">AccessType</a> = <a class="code" href="../../d4/d3/v86emul_8h.html#a15a13">Ushort</a>;
01453     Entry[1].<a class="code" href="../../d2/d3/struct__EMULATOR__ACCESS__ENTRY.html#o3">AccessMode</a> = <a class="code" href="../../d4/d3/v86emul_8h.html#a0">EMULATOR_READ_ACCESS</a> | <a class="code" href="../../d4/d3/v86emul_8h.html#a1">EMULATOR_WRITE_ACCESS</a>;
01454     Entry[1].<a class="code" href="../../d2/d3/struct__EMULATOR__ACCESS__ENTRY.html#o4">StringSupport</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01455     Entry[1].<a class="code" href="../../d2/d3/struct__EMULATOR__ACCESS__ENTRY.html#o5">Routine</a> = TestIoWordReadRoutine;
01456 
01457     Entry[2].<a class="code" href="../../d2/d3/struct__EMULATOR__ACCESS__ENTRY.html#o0">BasePort</a> = 0x400;
01458     Entry[2].<a class="code" href="../../d2/d3/struct__EMULATOR__ACCESS__ENTRY.html#o1">NumConsecutivePorts</a> = 0xc;
01459     Entry[2].<a class="code" href="../../d2/d3/struct__EMULATOR__ACCESS__ENTRY.html#o2">AccessType</a> = <a class="code" href="../../d4/d3/v86emul_8h.html#a15a14">Ulong</a>;
01460     Entry[2].<a class="code" href="../../d2/d3/struct__EMULATOR__ACCESS__ENTRY.html#o3">AccessMode</a> = <a class="code" href="../../d4/d3/v86emul_8h.html#a0">EMULATOR_READ_ACCESS</a> | <a class="code" href="../../d4/d3/v86emul_8h.html#a1">EMULATOR_WRITE_ACCESS</a>;
01461     Entry[2].<a class="code" href="../../d2/d3/struct__EMULATOR__ACCESS__ENTRY.html#o4">StringSupport</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01462     Entry[2].<a class="code" href="../../d2/d3/struct__EMULATOR__ACCESS__ENTRY.html#o5">Routine</a> = TestIoDwordRoutine;
01463 
01464     Entry[3].<a class="code" href="../../d2/d3/struct__EMULATOR__ACCESS__ENTRY.html#o0">BasePort</a> = 0x400;
01465     Entry[3].<a class="code" href="../../d2/d3/struct__EMULATOR__ACCESS__ENTRY.html#o1">NumConsecutivePorts</a> = 0x18;
01466     Entry[3].<a class="code" href="../../d2/d3/struct__EMULATOR__ACCESS__ENTRY.html#o2">AccessType</a> = <a class="code" href="../../d4/d3/v86emul_8h.html#a15a13">Ushort</a>;
01467     Entry[3].<a class="code" href="../../d2/d3/struct__EMULATOR__ACCESS__ENTRY.html#o3">AccessMode</a> = <a class="code" href="../../d4/d3/v86emul_8h.html#a0">EMULATOR_READ_ACCESS</a> | <a class="code" href="../../d4/d3/v86emul_8h.html#a1">EMULATOR_WRITE_ACCESS</a>;
01468     Entry[3].<a class="code" href="../../d2/d3/struct__EMULATOR__ACCESS__ENTRY.html#o4">StringSupport</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01469     Entry[3].<a class="code" href="../../d2/d3/struct__EMULATOR__ACCESS__ENTRY.html#o5">Routine</a> = TestIoStringRoutine;
01470 
01471      <span class="keywordflow">if</span> (Connect) {
01472         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwSetInformationProcess(
01473             NtCurrentProcess(),
01474             ProcessIoPortHandlers,
01475             &amp;IoPortHandler,
01476             <span class="keyword">sizeof</span>(PROCESS_IO_PORT_HANDLER_INFORMATION)
01477             ) ;
01478         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(Status)) {
01479             DbgBreakPoint();
01480         }
01481         Connect = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01482     }
01483 
01484     IoPortHandler.Install = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01485     <span class="keywordflow">if</span> (Disconnect) {
01486         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwSetInformationProcess(
01487             NtCurrentProcess(),
01488             ProcessIoPortHandlers,
01489             &amp;IoPortHandler,
01490             <span class="keyword">sizeof</span>(PROCESS_IO_PORT_HANDLER_INFORMATION)
01491             );
01492         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(Status)) {
01493             DbgBreakPoint();
01494         }
01495         Disconnect = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01496     }
01497 }
01498 <span class="preprocessor">#endif</span>
01499 <span class="preprocessor"></span>
01500 
01501 <span class="preprocessor">#endif</span>
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:42:21 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
