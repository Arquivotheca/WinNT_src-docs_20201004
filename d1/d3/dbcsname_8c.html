<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: dbcsname.c File Reference</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>dbcsname.c File Reference</h1><code>#include "FsRtlP.h"</code><br>

<p>
<a href="../../d2/d2/dbcsname_8c-source.html">Go to the source code of this file.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d1/d3/dbcsname_8c.html#a0">Dbg</a>&nbsp;&nbsp;&nbsp;(0x10000000)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d1/d3/dbcsname_8c.html#a1">DavePrint</a>&nbsp;&nbsp;&nbsp;NOTHING</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d1/d3/dbcsname_8c.html#a2">MODULE_POOL_TAG</a>&nbsp;&nbsp;&nbsp;('drSF')</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d1/d3/dbcsname_8c.html#a3">GetDbcs</a>(BUF, OFFSET, DBCS_CHAR, LENGTH)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d1/d3/dbcsname_8c.html#a4">MATCHES_ARRAY_SIZE</a>&nbsp;&nbsp;&nbsp;16</td></tr>

<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d1/d3/dbcsname_8c.html#a5">FsRtlIsFatDbcsLegal</a> (IN ANSI_STRING DbcsName, IN BOOLEAN WildCardsPermissible, IN BOOLEAN PathNamePermissible, IN BOOLEAN LeadingBackslashPermissible)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d1/d3/dbcsname_8c.html#a6">FsRtlIsHpfsDbcsLegal</a> (IN ANSI_STRING DbcsName, IN BOOLEAN WildCardsPermissible, IN BOOLEAN PathNamePermissible, IN BOOLEAN LeadingBackslashPermissible)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d1/d3/dbcsname_8c.html#a7">FsRtlDissectDbcs</a> (IN ANSI_STRING Path, OUT PANSI_STRING FirstName, OUT PANSI_STRING RemainingName)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d1/d3/dbcsname_8c.html#a8">FsRtlDoesDbcsContainWildCards</a> (IN PANSI_STRING <a class="el" href="../../d9/d3/rules_8c.html#a6">Name</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d1/d3/dbcsname_8c.html#a9">FsRtlIsDbcsInExpression</a> (IN PANSI_STRING Expression, IN PANSI_STRING <a class="el" href="../../d9/d3/rules_8c.html#a6">Name</a>)</td></tr>

</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="a1" doxytag="dbcsname.c::DavePrint" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define DavePrint&nbsp;&nbsp;&nbsp;NOTHING          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d2/d2/dbcsname_8c-source.html#l00060">60</a> of file <a class="el" href="../../d2/d2/dbcsname_8c-source.html">dbcsname.c</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a0" doxytag="dbcsname.c::Dbg" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define Dbg&nbsp;&nbsp;&nbsp;(0x10000000)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d2/d2/dbcsname_8c-source.html#l00047">47</a> of file <a class="el" href="../../d2/d2/dbcsname_8c-source.html">dbcsname.c</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="dbcsname.c::GetDbcs" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define GetDbcs          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">BUF,         <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OFFSET,         <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>DBCS_CHAR,         <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>LENGTH&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><pre class="fragment"><div>{               \
    <span class="keywordflow">if</span> (<a class="code" href="../../d1/d8/fsrtl_8h.html#a36">FsRtlIsLeadDbcsCharacter</a>( (BUF)[(OFFSET)] )) {       \
        *(DBCS_CHAR) = (WCHAR)((BUF)[(<a class="code" href="../../d0/d2/genxx_8h.html#a43">OFFSET</a>)] +             \
                               0x100 * (BUF)[(<a class="code" href="../../d0/d2/genxx_8h.html#a43">OFFSET</a>) + 1]); \
        *(LENGTH) = 2;                                       \
    } <span class="keywordflow">else</span> {                                                 \
        *(DBCS_CHAR) = (WCHAR)(BUF)[(<a class="code" href="../../d0/d2/genxx_8h.html#a43">OFFSET</a>)];               \
        *(LENGTH) = 1;                                       \
    }                                                        \
}
</div></pre>
<p>
Definition at line <a class="el" href="../../d2/d2/dbcsname_8c-source.html#l00757">757</a> of file <a class="el" href="../../d2/d2/dbcsname_8c-source.html">dbcsname.c</a>.
<p>
Referenced by <a class="el" href="../../d2/d2/dbcsname_8c-source.html#l00771">FsRtlIsDbcsInExpression()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="dbcsname.c::MATCHES_ARRAY_SIZE" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define MATCHES_ARRAY_SIZE&nbsp;&nbsp;&nbsp;16          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d2/d2/dbcsname_8c-source.html#l00768">768</a> of file <a class="el" href="../../d2/d2/dbcsname_8c-source.html">dbcsname.c</a>.
<p>
Referenced by <a class="el" href="../../d2/d2/dbcsname_8c-source.html#l00771">FsRtlIsDbcsInExpression()</a>, and <a class="el" href="../../d5/d4/name_8c-source.html#l00482">FsRtlIsNameInExpressionPrivate()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a2" doxytag="dbcsname.c::MODULE_POOL_TAG" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define MODULE_POOL_TAG&nbsp;&nbsp;&nbsp;('drSF')          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d2/d2/dbcsname_8c-source.html#l00069">69</a> of file <a class="el" href="../../d2/d2/dbcsname_8c-source.html">dbcsname.c</a>.
<p>
Referenced by <a class="el" href="../../d6/d8/unc_8c-source.html#l00104">FsRtlpRegisterProviderWithMUP()</a>, and <a class="el" href="../../d6/d8/unc_8c-source.html#l00247">FsRtlRegisterUncProvider()</a>.    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a7" doxytag="dbcsname.c::FsRtlDissectDbcs" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID FsRtlDissectDbcs           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN ANSI_STRING&nbsp;</td>
          <td class="mdname" nowrap> <em>Path</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PANSI_STRING&nbsp;</td>
          <td class="mdname" nowrap> <em>FirstName</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PANSI_STRING&nbsp;</td>
          <td class="mdname" nowrap> <em>RemainingName</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d2/d2/dbcsname_8c-source.html#l00542">542</a> of file <a class="el" href="../../d2/d2/dbcsname_8c-source.html">dbcsname.c</a>.
<p>
References <a class="el" href="../../d2/d7/fsrtl_8h-source.html#l01033">FsRtlIsLeadDbcsCharacter</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>, and <a class="el" href="../../d5/d4/aug98_2dll32_2icc__i386_8h-source.html#l00064">USHORT</a>.
<p>
Referenced by <a class="el" href="../../d2/d2/dbcsname_8c-source.html#l00081">FsRtlIsFatDbcsLegal()</a>, and <a class="el" href="../../d2/d2/dbcsname_8c-source.html#l00345">FsRtlIsHpfsDbcsLegal()</a>.
<p>
<pre class="fragment"><div>00550                    :
00551 
00552     This routine takes an input Dbcs string and dissects <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> into two
00553     substrings.  The first output string contains <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> name that appears at
00554     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> beginning of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> input string, <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> second output string contains <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
00555     remainder of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> input string.
00556 
00557     In <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> input string backslashes are used to separate names.  The input
00558     string must not start with a backslash.  Both output strings will not
00559     begin with a backslash.
00560 
00561     If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> input string does not contain any names then both output strings
00562     are empty.  If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> input string contains <a class="code" href="../../d3/d0/imm32_8def.html#a1">only</a> one name then <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> first
00563     output string contains <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> name and <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> second string <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> empty.
00564 
00565     Note that both output strings use <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> same string buffer memory of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
00566     input string.
00567 
00568     Example of its results are:
00569 
00570 <span class="comment">//. .     InputString    FirstPart    RemainingPart</span>
00571 <span class="comment">//</span>
00572 <span class="comment">//. .     empty          empty        empty</span>
00573 <span class="comment">//</span>
00574 <span class="comment">//. .     A              A            empty</span>
00575 <span class="comment">//</span>
00576 <span class="comment">//. .     A\B\C\D\E      A            B\C\D\E</span>
00577 <span class="comment">//</span>
00578 <span class="comment">//. .     *A?            *A?          empty</span>
00579 <span class="comment">//</span>
00580 <span class="comment">//. .     \A             A            empty</span>
00581 <span class="comment">//</span>
00582 <span class="comment">//. .     A[,]           A[,]         empty</span>
00583 <span class="comment">//</span>
00584 <span class="comment">//. .     A\\B+;\C       A            \B+;\C</span>
00585 
00586 Arguments:
00587 
00588     InputName - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> input string being dissected
00589 
00590     Is8dot3 - Indicates <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> first part of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> input name must be 8.3
00591         or can be <span class="keywordtype">long</span> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> name.
00592 
00593     FirstPart - Receives <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> first name in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> input string
00594 
00595     RemainingPart - Receives <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> remaining part of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> input string
00596 
00597 Return Value:
00598 
00599     NONE
00600 
00601 --*/
00602 
00603 {
00604     ULONG i = 0;
00605     ULONG PathLength;
00606     ULONG FirstNameStart;
00607 
00608     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00609 
00610     <span class="comment">//</span>
00611     <span class="comment">//  Make both output strings empty for now</span>
00612     <span class="comment">//</span>
00613 
00614     FirstName-&gt;Length = 0;
00615     FirstName-&gt;MaximumLength = 0;
00616     FirstName-&gt;Buffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00617 
00618     RemainingName-&gt;Length = 0;
00619     RemainingName-&gt;MaximumLength = 0;
00620     RemainingName-&gt;Buffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00621 
00622     PathLength = Path.Length;
00623 
00624     <span class="comment">//</span>
00625     <span class="comment">//  Check for an empty input string</span>
00626     <span class="comment">//</span>
00627 
00628     <span class="keywordflow">if</span> (PathLength == 0) {
00629 
00630         <span class="keywordflow">return</span>;
00631     }
00632 
00633     <span class="comment">//</span>
00634     <span class="comment">//  Skip over a starting backslash, and make sure there is more.</span>
00635     <span class="comment">//</span>
00636 
00637     <span class="keywordflow">if</span> ( Path.Buffer[0] == <span class="charliteral">'\\'</span> ) {
00638 
00639         i = 1;
00640     }
00641 
00642     <span class="comment">//</span>
00643     <span class="comment">//  Now run down the input string until we hit a backslash or the end</span>
00644     <span class="comment">//  of the string, remembering where we started;</span>
00645     <span class="comment">//</span>
00646 
00647     <span class="keywordflow">for</span> ( FirstNameStart = i;
00648           (i &lt; PathLength) &amp;&amp; (Path.Buffer[i] != <span class="charliteral">'\\'</span>);
00649           i += 1 ) {
00650 
00651         <span class="comment">//</span>
00652         <span class="comment">//  If this is the first byte of a Dbcs character, skip over the</span>
00653         <span class="comment">//  next byte as well.</span>
00654         <span class="comment">//</span>
00655 
00656         <span class="keywordflow">if</span> ( <a class="code" href="../../d1/d8/fsrtl_8h.html#a36">FsRtlIsLeadDbcsCharacter</a>( Path.Buffer[i] ) ) {
00657 
00658             i += 1;
00659         }
00660     }
00661 
00662     <span class="comment">//</span>
00663     <span class="comment">//  At this point all characters up to (but not including) i are</span>
00664     <span class="comment">//  in the first part.   So setup the first name</span>
00665     <span class="comment">//</span>
00666 
00667     FirstName-&gt;Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(i - FirstNameStart);
00668     FirstName-&gt;MaximumLength = FirstName-&gt;Length;
00669     FirstName-&gt;Buffer = &amp;Path.Buffer[FirstNameStart];
00670 
00671     <span class="comment">//</span>
00672     <span class="comment">//  Now the remaining part needs a string only if the first part didn't</span>
00673     <span class="comment">//  exhaust the entire input string.  We know that if anything is left</span>
00674     <span class="comment">//  that is must start with a backslash.  Note that if there is only</span>
00675     <span class="comment">//  a trailing backslash, the length will get correctly set to zero.</span>
00676     <span class="comment">//</span>
00677 
00678     <span class="keywordflow">if</span> (i &lt; PathLength) {
00679 
00680         RemainingName-&gt;Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(PathLength - (i + 1));
00681         RemainingName-&gt;MaximumLength = RemainingName-&gt;Length;
00682         RemainingName-&gt;Buffer = &amp;Path.Buffer[i + 1];
00683     }
00684 
00685     <span class="comment">//</span>
00686     <span class="comment">//  And return to our caller</span>
00687     <span class="comment">//</span>
00688 
00689     <span class="keywordflow">return</span>;
00690 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a8" doxytag="dbcsname.c::FsRtlDoesDbcsContainWildCards" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> BOOLEAN FsRtlDoesDbcsContainWildCards           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PANSI_STRING&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>Name</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d2/d2/dbcsname_8c-source.html#l00694">694</a> of file <a class="el" href="../../d2/d2/dbcsname_8c-source.html">dbcsname.c</a>.
<p>
References <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d2/d7/fsrtl_8h-source.html#l00946">FsRtlIsAnsiCharacterWild</a>, <a class="el" href="../../d2/d7/fsrtl_8h-source.html#l01033">FsRtlIsLeadDbcsCharacter</a>, <a class="el" href="../../d9/d9/geninst_8c-source.html#l00154">Name</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>, and <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>.
<p>
Referenced by <a class="el" href="../../d2/d2/dbcsname_8c-source.html#l00771">FsRtlIsDbcsInExpression()</a>, and <a class="el" href="../../d2/d2/dbcsname_8c-source.html#l00081">FsRtlIsFatDbcsLegal()</a>.
<p>
<pre class="fragment"><div>00700                    :
00701 
00702     This routine checks <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> input Dbcs name contains any wild card
00703     characters (i.e., *, ?, ANSI_DOS_STAR, or ANSI_DOS_QM).
00704 
00705 Arguments:
00706 
00707     <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a> - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> name to examine
00708 
00709 Return Value:
00710 
00711     BOOLEAN - <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> input name contains any wildcard characters and
00712         <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> otherwise.
00713 
00714 --*/
00715 
00716 {
00717     CLONG i;
00718 
00719     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00720 
00721     <span class="comment">//</span>
00722     <span class="comment">//  Check each character in the name to see if it's a wildcard</span>
00723     <span class="comment">//  character</span>
00724     <span class="comment">//</span>
00725 
00726     <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length; i += 1) {
00727 
00728         <span class="comment">//</span>
00729         <span class="comment">//  check for dbcs character because we'll just skip over those</span>
00730         <span class="comment">//</span>
00731 
00732         <span class="keywordflow">if</span> (<a class="code" href="../../d1/d8/fsrtl_8h.html#a36">FsRtlIsLeadDbcsCharacter</a>( <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Buffer[i] )) {
00733 
00734             i += 1;
00735 
00736         <span class="comment">//</span>
00737         <span class="comment">//  else check for a wild card character</span>
00738         <span class="comment">//</span>
00739 
00740         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="../../d1/d8/fsrtl_8h.html#a29">FsRtlIsAnsiCharacterWild</a>( <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Buffer[i] )) {
00741 
00742             <span class="comment">//</span>
00743             <span class="comment">//  Tell caller that this name contains wild cards</span>
00744             <span class="comment">//</span>
00745 
00746             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00747         }
00748     }
00749 
00750     <span class="comment">//</span>
00751     <span class="comment">//  No wildcard characters were found, so return to our caller</span>
00752     <span class="comment">//</span>
00753 
00754     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00755 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a9" doxytag="dbcsname.c::FsRtlIsDbcsInExpression" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> BOOLEAN FsRtlIsDbcsInExpression           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PANSI_STRING&nbsp;</td>
          <td class="mdname" nowrap> <em>Expression</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PANSI_STRING&nbsp;</td>
          <td class="mdname" nowrap> <em>Name</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d2/d2/dbcsname_8c-source.html#l00771">771</a> of file <a class="el" href="../../d2/d2/dbcsname_8c-source.html">dbcsname.c</a>.
<p>
References <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d0/d5/cdfs__rec_8c-source.html#l00032">Dbg</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02290">DebugTrace</a>, <a class="el" href="../../d7/d2/cmwraper_8c-source.html#l00304">ExFreePool()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d2/d2/dbcsname_8c-source.html#l00694">FsRtlDoesDbcsContainWildCards()</a>, <a class="el" href="../../d2/d7/fsrtl_8h-source.html#l01033">FsRtlIsLeadDbcsCharacter</a>, <a class="el" href="../../d4/d7/fsrtlp_8h-source.html#l00040">FsRtlpAllocatePool</a>, <a class="el" href="../../d2/d2/dbcsname_8c-source.html#l00757">GetDbcs</a>, <a class="el" href="../../d2/d2/dbcsname_8c-source.html#l00768">MATCHES_ARRAY_SIZE</a>, <a class="el" href="../../d9/d9/geninst_8c-source.html#l00154">Name</a>, <a class="el" href="../../d6/d8/gen8dot3_8c-source.html#l00032">NlsMbOemCodePageTag</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l00033">Offset</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>, <a class="el" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, and <a class="el" href="../../d5/d4/aug98_2dll32_2icc__i386_8h-source.html#l00064">USHORT</a>.
<p>
<pre class="fragment"><div>00778                    :
00779 
00780     This routine compares a Dbcs name and an expression and tells <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller
00781     <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> name <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> language defined by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> expression.  The input name
00782     cannot contain wildcards, <span class="keywordflow">while</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> expression may contain wildcards.
00783 
00784     Expression wild cards are evaluated as shown in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> nondeterministic
00785     finite automatons below.  Note that ~* and ~? are DOS_STAR and DOS_QM.
00786 
00787 
00788              ~* <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> DOS_STAR, ~? <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> DOS_QM, and ~. <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> DOS_DOT
00789 
00790 
00791                                        S
00792                                     &lt;-----&lt;
00793                                  X  |     |  e       Y
00794              X * Y ==       (0)-----&gt;-(1)-&gt;-----(2)-----(3)
00795 
00796 
00797                                       S-.
00798                                     &lt;-----&lt;
00799                                  X  |     |  e       Y
00800              X ~* Y ==      (0)-----&gt;-(1)-&gt;-----(2)-----(3)
00801 
00802 
00803 
00804                                 X     S     S     Y
00805              X ?? Y ==      (0)---(1)---(2)---(3)---(4)
00806 
00807 
00808 
00809                                 X     .        .      Y
00810              X ~.~. Y ==    (0)---(1)----(2)------(3)---(4)
00811                                    |      |________|
00812                                    |           ^   |
00813                                    |_______________|
00814                                       ^EOF or .^
00815 
00816 
00817                                 X     S-.     S-.     Y
00818              X ~?~? Y ==    (0)---(1)-----(2)-----(3)---(4)
00819                                    |      |________|
00820                                    |           ^   |
00821                                    |_______________|
00822                                       ^EOF or .^
00823 
00824 
00825 
00826          where S <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> any single character
00827 
00828                S-. <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> any single character except <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <span class="keyword">final</span> .
00829 
00830                e <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> a null character transition
00831 
00832                EOF <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> end of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> name string
00833 
00834     In words:
00835 
00836         * matches 0 or more characters.
00837 
00838         ? matches exactly 1 character.
00839 
00840         DOS_STAR matches 0 or more characters until encountering and <a class="code" href="../../d7/d1/genuedef_8c.html#a7">matching</a>
00841             <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <span class="keyword">final</span> . in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> name.
00842 
00843         DOS_QM matches any single character, or upon encountering a period or
00844             end of name string, advances <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> expression to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> end of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
00845             set of contiguous DOS_QMs.
00846 
00847         DOS_DOT matches either a . or zero characters beyond name string.
00848 
00849 Arguments:
00850 
00851     Expression - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> input expression to check against
00852 
00853     <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a> - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> input name to check <span class="keywordflow">for</span>.
00854 
00855 Return Value:
00856 
00857     BOOLEAN - <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> <span class="keywordflow">if</span> <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> an element in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> set of strings denoted
00858         by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> input Expression and <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> otherwise.
00859 
00860 --*/
00861 
00862 {
00863     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> NameOffset;
00864     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> ExprOffset;
00865     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> Length;
00866 
00867     ULONG SrcCount;
00868     ULONG DestCount;
00869     ULONG PreviousDestCount;
00870     ULONG MatchesCount;
00871 
00872     WCHAR NameChar, ExprChar;
00873 
00874     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> LocalBuffer[<a class="code" href="../../d1/d3/dbcsname_8c.html#a4">MATCHES_ARRAY_SIZE</a> * 2];
00875 
00876     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> *AuxBuffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00877     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> *PreviousMatches;
00878     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> *CurrentMatches;
00879 
00880     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> MaxState;
00881     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> CurrentState;
00882 
00883     BOOLEAN NameFinished = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00884 
00885     <span class="comment">//</span>
00886     <span class="comment">//  The idea behind the algorithm is pretty simple.  We keep track of</span>
00887     <span class="comment">//  all possible locations in the regular expression that are matching</span>
00888     <span class="comment">//  the name.  If when the name has been exhausted one of the locations</span>
00889     <span class="comment">//  in the expression is also just exhausted, the name is in the language</span>
00890     <span class="comment">//  defined by the regular expression.</span>
00891     <span class="comment">//</span>
00892 
00893     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00894 
00895     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, Dbg, <span class="stringliteral">"FsRtlIsDbcsInExpression\n"</span>, 0);
00896     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, Dbg, <span class="stringliteral">" Expression      = %Z\n"</span>, Expression );
00897     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, Dbg, <span class="stringliteral">" Name            = %Z\n"</span>, Name );
00898 
00899     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length != 0 );
00900     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( Expression-&gt;Length != 0 );
00901 
00902     <span class="comment">//</span>
00903     <span class="comment">//  If one string is empty return FALSE.  If both are empty return TRUE.</span>
00904     <span class="comment">//</span>
00905 
00906     <span class="keywordflow">if</span> ( (<a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length == 0) || (Expression-&gt;Length == 0) ) {
00907 
00908         <span class="keywordflow">return</span> (BOOLEAN)(!(<a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length + Expression-&gt;Length));
00909     }
00910 
00911     <span class="comment">//</span>
00912     <span class="comment">//  Special case by far the most common wild card search of *</span>
00913     <span class="comment">//</span>
00914 
00915     <span class="keywordflow">if</span> ((Expression-&gt;Length == 1) &amp;&amp; (Expression-&gt;Buffer[0] == <span class="charliteral">'*'</span>)) {
00916 
00917         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00918     }
00919 
00920     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d1/d8/fsrtl_8h.html#a132">FsRtlDoesDbcsContainWildCards</a>( Expression ) );
00921 
00922     <span class="comment">//</span>
00923     <span class="comment">//  Also special case expressions of the form *X.  With this and the prior</span>
00924     <span class="comment">//  case we have covered virtually all normal queries.</span>
00925     <span class="comment">//</span>
00926 
00927     <span class="keywordflow">if</span> (Expression-&gt;Buffer[0] == <span class="charliteral">'*'</span>) {
00928 
00929         ANSI_STRING LocalExpression;
00930 
00931         LocalExpression = *Expression;
00932 
00933         LocalExpression.Buffer += 1;
00934         LocalExpression.Length -= 1;
00935 
00936         <span class="comment">//</span>
00937         <span class="comment">//  Only special case an expression with a single *</span>
00938         <span class="comment">//</span>
00939 
00940         <span class="keywordflow">if</span> ( !<a class="code" href="../../d1/d8/fsrtl_8h.html#a132">FsRtlDoesDbcsContainWildCards</a>( &amp;LocalExpression ) ) {
00941 
00942             ULONG StartingNameOffset;
00943 
00944             <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length &lt; (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(Expression-&gt;Length - 1)) {
00945 
00946                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00947             }
00948 
00949             StartingNameOffset = <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length - LocalExpression.Length;
00950 
00951             <span class="comment">//</span>
00952             <span class="comment">//  FsRtlIsDbcsInExpression(): bug fix "expression[0] == *" case</span>
00953             <span class="comment">//</span>
00954             <span class="comment">//  StatingNameOffset must not bisect DBCS characters.</span>
00955             <span class="comment">//</span>
00956 
00957             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d9/gen8dot3_8c.html#a5">NlsMbOemCodePageTag</a>) {
00958 
00959                 ULONG i = 0;
00960 
00961                 <span class="keywordflow">while</span> ( i &lt; StartingNameOffset ) {
00962 
00963                     i += <a class="code" href="../../d1/d8/fsrtl_8h.html#a36">FsRtlIsLeadDbcsCharacter</a>( <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Buffer[i] ) ? 2 : 1;
00964                 }
00965 
00966                 <span class="keywordflow">if</span> ( i &gt; StartingNameOffset ) {
00967 
00968                     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00969                 }
00970             }
00971 
00972             <span class="comment">//</span>
00973             <span class="comment">//  Do a simple memory compare if case sensitive, otherwise</span>
00974             <span class="comment">//  we have got to check this one character at a time.</span>
00975             <span class="comment">//</span>
00976 
00977             <span class="keywordflow">return</span> (BOOLEAN) RtlEqualMemory( LocalExpression.Buffer,
00978                                              <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Buffer + StartingNameOffset,
00979                                              LocalExpression.Length );
00980         }
00981     }
00982 
00983     <span class="comment">//</span>
00984     <span class="comment">//  Walk through the name string, picking off characters.  We go one</span>
00985     <span class="comment">//  character beyond the end because some wild cards are able to match</span>
00986     <span class="comment">//  zero characters beyond the end of the string.</span>
00987     <span class="comment">//</span>
00988     <span class="comment">//  With each new name character we determine a new set of states that</span>
00989     <span class="comment">//  match the name so far.  We use two arrays that we swap back and forth</span>
00990     <span class="comment">//  for this purpose.  One array lists the possible expression states for</span>
00991     <span class="comment">//  all name characters up to but not including the current one, and other</span>
00992     <span class="comment">//  array is used to build up the list of states considering the current</span>
00993     <span class="comment">//  name character as well.  The arrays are then switched and the process</span>
00994     <span class="comment">//  repeated.</span>
00995     <span class="comment">//</span>
00996     <span class="comment">//  There is not a one-to-one correspondence between state number and</span>
00997     <span class="comment">//  offset into the expression.  This is evident from the NFAs in the</span>
00998     <span class="comment">//  initial comment to this function.  State numbering is not continuous.</span>
00999     <span class="comment">//  This allows a simple conversion between state number and expression</span>
01000     <span class="comment">//  offset.  Each character in the expression can represent one or two</span>
01001     <span class="comment">//  states.  * and DOS_STAR generate two states: ExprOffset*2 and</span>
01002     <span class="comment">//  ExprOffset*2 + 1.  All other expreesion characters can produce only</span>
01003     <span class="comment">//  a single state.  Thus ExprOffset = State/2.</span>
01004     <span class="comment">//</span>
01005     <span class="comment">//</span>
01006     <span class="comment">//  Here is a short description of the variables involved:</span>
01007     <span class="comment">//</span>
01008     <span class="comment">//  NameOffset  - The offset of the current name char being processed.</span>
01009     <span class="comment">//</span>
01010     <span class="comment">//  ExprOffset  - The offset of the current expression char being processed.</span>
01011     <span class="comment">//</span>
01012     <span class="comment">//  SrcCount    - Prior match being investigated with current name char</span>
01013     <span class="comment">//</span>
01014     <span class="comment">//  DestCount   - Next location to put a matching assuming current name char</span>
01015     <span class="comment">//</span>
01016     <span class="comment">//  NameFinished - Allows one more itteration through the Matches array</span>
01017     <span class="comment">//                 after the name is exhusted (to come *s for example)</span>
01018     <span class="comment">//</span>
01019     <span class="comment">//  PreviousDestCount - This is used to prevent entry duplication, see coment</span>
01020     <span class="comment">//</span>
01021     <span class="comment">//  PreviousMatches   - Holds the previous set of matches (the Src array)</span>
01022     <span class="comment">//</span>
01023     <span class="comment">//  CurrentMatches    - Holds the current set of matches (the Dest array)</span>
01024     <span class="comment">//</span>
01025     <span class="comment">//  AuxBuffer, LocalBuffer - the storage for the Matches arrays</span>
01026     <span class="comment">//</span>
01027 
01028     <span class="comment">//</span>
01029     <span class="comment">//  Set up the initial variables</span>
01030     <span class="comment">//</span>
01031 
01032     PreviousMatches = &amp;LocalBuffer[0];
01033     CurrentMatches = &amp;LocalBuffer[<a class="code" href="../../d1/d3/dbcsname_8c.html#a4">MATCHES_ARRAY_SIZE</a>];
01034 
01035     PreviousMatches[0] = 0;
01036     MatchesCount = 1;
01037 
01038     NameOffset = 0;
01039 
01040     MaxState = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(Expression-&gt;Length * 2);
01041 
01042     <span class="keywordflow">while</span> ( !NameFinished ) {
01043 
01044         <span class="keywordflow">if</span> ( NameOffset &lt; <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length ) {
01045 
01046             <a class="code" href="../../d1/d3/dbcsname_8c.html#a3">GetDbcs</a>( <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Buffer, NameOffset, &amp;NameChar, &amp;Length );
01047             NameOffset += Length;
01048 
01049         } <span class="keywordflow">else</span> {
01050 
01051             NameFinished = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01052 
01053             <span class="comment">//</span>
01054             <span class="comment">//  if we have already exhasted the expression, cool.  Don't</span>
01055             <span class="comment">//  continue.</span>
01056             <span class="comment">//</span>
01057 
01058             <span class="keywordflow">if</span> ( PreviousMatches[MatchesCount-1] == MaxState ) {
01059 
01060                 <span class="keywordflow">break</span>;
01061             }
01062         }
01063 
01064 
01065         <span class="comment">//</span>
01066         <span class="comment">//  Now, for each of the previous stored expression matches, see what</span>
01067         <span class="comment">//  we can do with this name character.</span>
01068         <span class="comment">//</span>
01069 
01070         SrcCount = 0;
01071         DestCount = 0;
01072         PreviousDestCount = 0;
01073 
01074         <span class="keywordflow">while</span> ( SrcCount &lt; MatchesCount ) {
01075 
01076             <span class="comment">//</span>
01077             <span class="comment">//  We have to carry on our expression analysis as far as possible</span>
01078             <span class="comment">//  for each character of name, so we loop here until the</span>
01079             <span class="comment">//  expression stops matching.  A clue here is that expression</span>
01080             <span class="comment">//  cases that can match zero or more characters end with a</span>
01081             <span class="comment">//  continue, while those that can accept only a single character</span>
01082             <span class="comment">//  end with a break.</span>
01083             <span class="comment">//</span>
01084 
01085             ExprOffset = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)((PreviousMatches[SrcCount++] + 1) / 2);
01086 
01087             Length = 0;
01088 
01089 
01090             <span class="keywordflow">while</span> ( <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> ) {
01091 
01092                 <span class="keywordflow">if</span> ( ExprOffset == Expression-&gt;Length ) {
01093 
01094                     <span class="keywordflow">break</span>;
01095                 }
01096 
01097                 <span class="comment">//</span>
01098                 <span class="comment">//  The first time through the loop we don't want</span>
01099                 <span class="comment">//  to increment ExprOffset.</span>
01100                 <span class="comment">//</span>
01101 
01102                 ExprOffset += Length;
01103 
01104                 CurrentState = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(ExprOffset * 2);
01105 
01106                 <span class="keywordflow">if</span> ( ExprOffset == Expression-&gt;Length ) {
01107 
01108                     CurrentMatches[DestCount++] = MaxState;
01109                     <span class="keywordflow">break</span>;
01110                 }
01111 
01112                 <a class="code" href="../../d1/d3/dbcsname_8c.html#a3">GetDbcs</a>(Expression-&gt;Buffer, ExprOffset, &amp;ExprChar, &amp;Length);
01113 
01114                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( !((ExprChar &gt;= <span class="charliteral">'a'</span>) &amp;&amp; (ExprChar &lt;= <span class="charliteral">'z'</span>)) );
01115 
01116                 <span class="comment">//</span>
01117                 <span class="comment">//  Before we get started, we have to check for something</span>
01118                 <span class="comment">//  really gross.  We may be about to exhaust the local</span>
01119                 <span class="comment">//  space for ExpressionMatches[][], so we have to allocate</span>
01120                 <span class="comment">//  some pool if this is the case.  Yuk!</span>
01121                 <span class="comment">//</span>
01122 
01123                 <span class="keywordflow">if</span> ( (DestCount &gt;= <a class="code" href="../../d1/d3/dbcsname_8c.html#a4">MATCHES_ARRAY_SIZE</a> - 2) &amp;&amp;
01124                      (AuxBuffer == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) ) {
01125 
01126                     AuxBuffer = <a class="code" href="../../d3/d8/fsrtlp_8h.html#a2">FsRtlpAllocatePool</a>( PagedPool,
01127                                                     (Expression-&gt;Length+1) *
01128                                                     <span class="keyword">sizeof</span>(USHORT)*2*2 );
01129 
01130                     RtlCopyMemory( AuxBuffer,
01131                                    CurrentMatches,
01132                                    MATCHES_ARRAY_SIZE * <span class="keyword">sizeof</span>(USHORT) );
01133 
01134                     CurrentMatches = AuxBuffer;
01135 
01136                     RtlCopyMemory( AuxBuffer + (Expression-&gt;Length+1)*2,
01137                                    PreviousMatches,
01138                                    MATCHES_ARRAY_SIZE * <span class="keyword">sizeof</span>(USHORT) );
01139 
01140                     PreviousMatches = AuxBuffer + (Expression-&gt;Length+1)*2;
01141 
01142                 }
01143 
01144                 <span class="comment">//</span>
01145                 <span class="comment">//  * matches any character zero or more times.</span>
01146                 <span class="comment">//</span>
01147 
01148                 <span class="keywordflow">if</span> (ExprChar == <span class="charliteral">'*'</span>) {
01149 
01150                     CurrentMatches[DestCount++] = CurrentState;
01151                     CurrentMatches[DestCount++] = CurrentState + 1;
01152                     <span class="keywordflow">continue</span>;
01153                 }
01154 
01155                 <span class="comment">//</span>
01156                 <span class="comment">//  DOS_STAR matches any character except . zero or more times.</span>
01157                 <span class="comment">//</span>
01158 
01159                 <span class="keywordflow">if</span> (ExprChar == ANSI_DOS_STAR) {
01160 
01161                     BOOLEAN ICanEatADot = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01162 
01163                     <span class="comment">//</span>
01164                     <span class="comment">//  If we are at a period, determine if we are allowed to</span>
01165                     <span class="comment">//  consume it, ie. make sure it is not the last one.</span>
01166                     <span class="comment">//</span>
01167 
01168                     <span class="keywordflow">if</span> ( !NameFinished &amp;&amp; (NameChar == <span class="charliteral">'.'</span>) ) {
01169 
01170                         WCHAR NameChar;
01171                         <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>;
01172                         <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> Length;
01173 
01174                         <span class="keywordflow">for</span> ( <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> = NameOffset;
01175                               <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> &lt; <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length;
01176                               <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> += Length ) {
01177 
01178                             <a class="code" href="../../d1/d3/dbcsname_8c.html#a3">GetDbcs</a>( <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Buffer, Offset, &amp;NameChar, &amp;Length );
01179 
01180                             <span class="keywordflow">if</span> (NameChar == <span class="charliteral">'.'</span>) {
01181 
01182                                 ICanEatADot = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01183                                 <span class="keywordflow">break</span>;
01184                             }
01185                         }
01186                     }
01187 
01188                     <span class="keywordflow">if</span> (NameFinished || (NameChar != <span class="charliteral">'.'</span>) || ICanEatADot) {
01189 
01190                         CurrentMatches[DestCount++] = CurrentState;
01191                         CurrentMatches[DestCount++] = CurrentState + 1;
01192                         <span class="keywordflow">continue</span>;
01193 
01194                     } <span class="keywordflow">else</span> {
01195 
01196                         <span class="comment">//</span>
01197                         <span class="comment">//  We are at a period.  We can only match zero</span>
01198                         <span class="comment">//  characters (ie. the epsilon transition).</span>
01199                         <span class="comment">//</span>
01200 
01201                         CurrentMatches[DestCount++] = CurrentState + 1;
01202                         <span class="keywordflow">continue</span>;
01203                     }
01204                 }
01205 
01206                 <span class="comment">//</span>
01207                 <span class="comment">//  The following expreesion characters all match by consuming</span>
01208                 <span class="comment">//  a character, thus force the expression, and thus state</span>
01209                 <span class="comment">//  forward.</span>
01210                 <span class="comment">//</span>
01211 
01212                 CurrentState += (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(Length * 2);
01213 
01214                 <span class="comment">//</span>
01215                 <span class="comment">//  DOS_QM is the most complicated.  If the name is finished,</span>
01216                 <span class="comment">//  we can match zero characters.  If this name is a '.', we</span>
01217                 <span class="comment">//  don't match, but look at the next expression.  Otherwise</span>
01218                 <span class="comment">//  we match a single character.</span>
01219                 <span class="comment">//</span>
01220 
01221                 <span class="keywordflow">if</span> ( ExprChar == ANSI_DOS_QM ) {
01222 
01223                     <span class="keywordflow">if</span> ( NameFinished || (NameChar == <span class="charliteral">'.'</span>) ) {
01224 
01225                         <span class="keywordflow">continue</span>;
01226                     }
01227 
01228                     CurrentMatches[DestCount++] = CurrentState;
01229                     <span class="keywordflow">break</span>;
01230                 }
01231 
01232                 <span class="comment">//</span>
01233                 <span class="comment">//  A DOS_DOT can match either a period, or zero characters</span>
01234                 <span class="comment">//  beyond the end of name.</span>
01235                 <span class="comment">//</span>
01236 
01237                 <span class="keywordflow">if</span> (ExprChar == DOS_DOT) {
01238 
01239                     <span class="keywordflow">if</span> ( NameFinished ) {
01240 
01241                         <span class="keywordflow">continue</span>;
01242                     }
01243 
01244                     <span class="keywordflow">if</span> (NameChar == <span class="charliteral">'.'</span>) {
01245 
01246                         CurrentMatches[DestCount++] = CurrentState;
01247                         <span class="keywordflow">break</span>;
01248                     }
01249                 }
01250 
01251                 <span class="comment">//</span>
01252                 <span class="comment">//  From this point on a name character is required to even</span>
01253                 <span class="comment">//  continue, let alone make a match.</span>
01254                 <span class="comment">//</span>
01255 
01256                 <span class="keywordflow">if</span> ( NameFinished ) {
01257 
01258                     <span class="keywordflow">break</span>;
01259                 }
01260 
01261                 <span class="comment">//</span>
01262                 <span class="comment">//  If this expression was a '?' we can match it once.</span>
01263                 <span class="comment">//</span>
01264 
01265                 <span class="keywordflow">if</span> (ExprChar == <span class="charliteral">'?'</span>) {
01266 
01267                     CurrentMatches[DestCount++] = CurrentState;
01268                     <span class="keywordflow">break</span>;
01269                 }
01270 
01271                 <span class="comment">//</span>
01272                 <span class="comment">//  Finally, check if the expression char matches the name char</span>
01273                 <span class="comment">//</span>
01274 
01275                 <span class="keywordflow">if</span> (ExprChar == NameChar) {
01276 
01277                     CurrentMatches[DestCount++] = CurrentState;
01278                     <span class="keywordflow">break</span>;
01279                 }
01280 
01281                 <span class="comment">//</span>
01282                 <span class="comment">//  The expression didn't match so go look at the next</span>
01283                 <span class="comment">//  previous match.</span>
01284                 <span class="comment">//</span>
01285 
01286                 <span class="keywordflow">break</span>;
01287             }
01288 
01289 
01290             <span class="comment">//</span>
01291             <span class="comment">//  Prevent duplication in the destination array.</span>
01292             <span class="comment">//</span>
01293             <span class="comment">//  Each of the arrays is montonically increasing and non-</span>
01294             <span class="comment">//  duplicating, thus we skip over any source element in the src</span>
01295             <span class="comment">//  array if we just added the same element to the destination</span>
01296             <span class="comment">//  array.  This guarentees non-duplication in the dest. array.</span>
01297             <span class="comment">//</span>
01298 
01299             <span class="keywordflow">if</span> ((SrcCount &lt; MatchesCount) &amp;&amp;
01300                 (PreviousDestCount &lt; DestCount) ) {
01301 
01302                 <span class="keywordflow">while</span> (PreviousDestCount &lt; DestCount) {
01303 
01304                     <span class="keywordflow">while</span> ( PreviousMatches[SrcCount] &lt;
01305                          CurrentMatches[PreviousDestCount] ) {
01306 
01307 
01308                         SrcCount += 1;
01309                     }
01310 
01311                     PreviousDestCount += 1;
01312                 }
01313             }
01314         }
01315 
01316         <span class="comment">//</span>
01317         <span class="comment">//  If we found no matches in the just finished itteration, it's time</span>
01318         <span class="comment">//  to bail.</span>
01319         <span class="comment">//</span>
01320 
01321         <span class="keywordflow">if</span> ( DestCount == 0 ) {
01322 
01323 
01324             <span class="keywordflow">if</span> (AuxBuffer != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) { <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( AuxBuffer ); }
01325 
01326             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01327         }
01328 
01329         <span class="comment">//</span>
01330         <span class="comment">//  Swap the meaning the two arrays</span>
01331         <span class="comment">//</span>
01332 
01333         {
01334             <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> *Tmp;
01335 
01336             Tmp = PreviousMatches;
01337 
01338             PreviousMatches = CurrentMatches;
01339 
01340             CurrentMatches = Tmp;
01341         }
01342 
01343         MatchesCount = DestCount;
01344     }
01345 
01346 
01347     CurrentState = PreviousMatches[MatchesCount-1];
01348 
01349     <span class="keywordflow">if</span> (AuxBuffer != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) { <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( AuxBuffer ); }
01350 
01351 
01352     <span class="keywordflow">return</span> (BOOLEAN)(CurrentState == MaxState);
01353 }
}
</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="dbcsname.c::FsRtlIsFatDbcsLegal" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> BOOLEAN FsRtlIsFatDbcsLegal           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN ANSI_STRING&nbsp;</td>
          <td class="mdname" nowrap> <em>DbcsName</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN BOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>WildCardsPermissible</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN BOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>PathNamePermissible</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN BOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>LeadingBackslashPermissible</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d2/d2/dbcsname_8c-source.html#l00081">81</a> of file <a class="el" href="../../d2/d2/dbcsname_8c-source.html">dbcsname.c</a>.
<p>
References <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d2/d2/dbcsname_8c-source.html#l00542">FsRtlDissectDbcs()</a>, <a class="el" href="../../d2/d2/dbcsname_8c-source.html#l00694">FsRtlDoesDbcsContainWildCards()</a>, <a class="el" href="../../d2/d7/fsrtl_8h-source.html#l00954">FsRtlIsAnsiCharacterLegalFat</a>, <a class="el" href="../../d2/d7/fsrtl_8h-source.html#l01033">FsRtlIsLeadDbcsCharacter</a>, <a class="el" href="../../d2/d9/cmchek_8c-source.html#l00095">Index</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>, and <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>.
<p>
Referenced by <a class="el" href="../../d6/d4/namesup_8c-source.html#l00176">UdfIs8dot3Name()</a>.
<p>
<pre class="fragment"><div>00090                    :
00091 
00092     This routine simple returns whether <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> names conforms
00093     to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> system specific rules <span class="keywordflow">for</span> legal <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> names.  This routine
00094     will check <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> single name, or <span class="keywordflow">if</span> PathNamePermissible <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> specified as
00095     <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, whether <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> whole <a class="code" href="../../d3/d3/dumpuser_8c.html#a14">path</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> a legal name.
00096 
00097     For FAT, <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> following rules apply:
00098 
00099     <a class="code" href="../../d2/d1/bench_8h.html#a5">A</a>. <a class="code" href="../../d2/d1/bench_8h.html#a5">A</a> Fat <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> name may not contain any of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> following characters:
00100 
00101        0x00-0x1F <span class="stringliteral">" / : | + , ; = [ ]</span>
00102 <span class="stringliteral"></span>
00103 <span class="stringliteral">    B. A Fat file name is either of the form N.E or just N, where N is a</span>
00104 <span class="stringliteral">       string of 1-8 bytes and E is a string of 1-3 bytes conformant to</span>
00105 <span class="stringliteral">       rule A above. In addition, neither N nor E may contain a period</span>
00106 <span class="stringliteral">       character or end with a space character.</span>
00107 <span class="stringliteral"></span>
00108 <span class="stringliteral">       Incidently, N corresponds to name and E to extension.</span>
00109 <span class="stringliteral"></span>
00110 <span class="stringliteral">    Case: Lower case characters are taken as valid, but are up-shifted upon</span>
00111 <span class="stringliteral">          receipt, ie. Fat only deals with upper case file names.</span>
00112 <span class="stringliteral"></span>
00113 <span class="stringliteral">    For example, the files "</span>.foo<span class="stringliteral">", "</span><a class="code" href="../../d8/d7/udbgk_8c.html#a2">foo</a>.<span class="stringliteral">", and "</span>foo .b<span class="stringliteral">" are illegal, while</span>
00114 <span class="stringliteral">    "</span><a class="code" href="../../d8/d7/udbgk_8c.html#a2">foo</a>. b<span class="stringliteral">" and "</span> <a class="code" href="../../d0/d3/utxcpt2_8c.html#a5">bar</a><span class="stringliteral">" are legal.</span>
00115 <span class="stringliteral"></span>
00116 <span class="stringliteral">Arguments:</span>
00117 <span class="stringliteral"></span>
00118 <span class="stringliteral">    DbcsName - Supllies the name/path to check.</span>
00119 <span class="stringliteral"></span>
00120 <span class="stringliteral">    WildCardsPermissible - Specifies if Nt wild card characters are to be</span>
00121 <span class="stringliteral">        considered considered legal.</span>
00122 <span class="stringliteral"></span>
00123 <span class="stringliteral">    PathNamePermissible - Spcifes if Name may be a path name separated by</span>
00124 <span class="stringliteral">        backslash characters, or just a simple file name.</span>
00125 <span class="stringliteral"></span>
00126 <span class="stringliteral">    LeadingBackSlashPermissible - Specifies if a single leading backslash</span>
00127 <span class="stringliteral">        is permissible in the file/path name.</span>
00128 <span class="stringliteral"></span>
00129 <span class="stringliteral">Return Value:</span>
00130 <span class="stringliteral"></span>
00131 <span class="stringliteral">    BOOLEAN - TRUE if the name is legal, FALSE otherwise.</span>
00132 <span class="stringliteral"></span>
00133 <span class="stringliteral">--*/</span>
00134 <span class="stringliteral">{</span>
00135 <span class="stringliteral">    BOOLEAN ExtensionPresent = FALSE;</span>
00136 <span class="stringliteral"></span>
00137 <span class="stringliteral">    ULONG Index;</span>
00138 <span class="stringliteral"></span>
00139 <span class="stringliteral">    UCHAR Char;</span>
00140 <span class="stringliteral"></span>
00141 <span class="stringliteral">    PAGED_CODE();</span>
00142 <span class="stringliteral"></span>
00143 <span class="stringliteral">    //</span>
00144 <span class="stringliteral">    //  Empty names are not valid.</span>
00145 <span class="stringliteral">    //</span>
00146 <span class="stringliteral"></span>
00147 <span class="stringliteral">    if ( DbcsName.Length == 0 ) { return FALSE; }</span>
00148 <span class="stringliteral"></span>
00149 <span class="stringliteral">    //</span>
00150 <span class="stringliteral">    //  If Wild Cards are OK, then for directory enumeration to work</span>
00151 <span class="stringliteral">    //  correctly we have to accept . and ..</span>
00152 <span class="stringliteral">    //</span>
00153 <span class="stringliteral"></span>
00154 <span class="stringliteral">    if ( WildCardsPermissible &amp;&amp;</span>
00155 <span class="stringliteral">         ( ( (DbcsName.Length == 1) &amp;&amp;</span>
00156 <span class="stringliteral">             ((DbcsName.Buffer[0] == '.') ||</span>
00157 <span class="stringliteral">              (DbcsName.Buffer[0] == ANSI_DOS_DOT)) )</span>
00158 <span class="stringliteral">           ||</span>
00159 <span class="stringliteral">           ( (DbcsName.Length == 2) &amp;&amp;</span>
00160 <span class="stringliteral">             ( ((DbcsName.Buffer[0] == '.') &amp;&amp;</span>
00161 <span class="stringliteral">                (DbcsName.Buffer[1] == '.')) ||</span>
00162 <span class="stringliteral">               ((DbcsName.Buffer[0] == ANSI_DOS_DOT) &amp;&amp;</span>
00163 <span class="stringliteral">                (DbcsName.Buffer[1] == ANSI_DOS_DOT)) ) ) ) ) {</span>
00164 <span class="stringliteral"></span>
00165 <span class="stringliteral">        return TRUE;</span>
00166 <span class="stringliteral">    }</span>
00167 <span class="stringliteral"></span>
00168 <span class="stringliteral">    //</span>
00169 <span class="stringliteral">    //  If a leading \ is OK, skip over it (if there's more)</span>
00170 <span class="stringliteral">    //</span>
00171 <span class="stringliteral"></span>
00172 <span class="stringliteral">    if ( DbcsName.Buffer[0] == '\\' ) {</span>
00173 <span class="stringliteral"></span>
00174 <span class="stringliteral">        if ( LeadingBackslashPermissible ) {</span>
00175 <span class="stringliteral"></span>
00176 <span class="stringliteral">            if ( (DbcsName.Length &gt; 1) ) {</span>
00177 <span class="stringliteral"></span>
00178 <span class="stringliteral">                DbcsName.Buffer += 1;</span>
00179 <span class="stringliteral">                DbcsName.Length -= 1;</span>
00180 <span class="stringliteral"></span>
00181 <span class="stringliteral">            } else { return TRUE; }</span>
00182 <span class="stringliteral"></span>
00183 <span class="stringliteral">        } else { return FALSE; }</span>
00184 <span class="stringliteral">    }</span>
00185 <span class="stringliteral"></span>
00186 <span class="stringliteral">    //</span>
00187 <span class="stringliteral">    //  If we got a path name, check each componant.</span>
00188 <span class="stringliteral">    //</span>
00189 <span class="stringliteral"></span>
00190 <span class="stringliteral">    if ( PathNamePermissible ) {</span>
00191 <span class="stringliteral"></span>
00192 <span class="stringliteral">        ANSI_STRING FirstName;</span>
00193 <span class="stringliteral">        ANSI_STRING RemainingName;</span>
00194 <span class="stringliteral"></span>
00195 <span class="stringliteral">        RemainingName = DbcsName;</span>
00196 <span class="stringliteral"></span>
00197 <span class="stringliteral">        while ( RemainingName.Length != 0 ) {</span>
00198 <span class="stringliteral"></span>
00199 <span class="stringliteral">            //</span>
00200 <span class="stringliteral">            //  This will catch the case of an illegal double backslash.</span>
00201 <span class="stringliteral">            //</span>
00202 <span class="stringliteral"></span>
00203 <span class="stringliteral">            if ( RemainingName.Buffer[0] == '\\' ) { return FALSE; }</span>
00204 <span class="stringliteral"></span>
00205 <span class="stringliteral">            FsRtlDissectDbcs(RemainingName, &amp;FirstName, &amp;RemainingName);</span>
00206 <span class="stringliteral"></span>
00207 <span class="stringliteral">            if ( !FsRtlIsFatDbcsLegal( FirstName,</span>
00208 <span class="stringliteral">                                       WildCardsPermissible,</span>
00209 <span class="stringliteral">                                       FALSE,</span>
00210 <span class="stringliteral">                                       FALSE) ) {</span>
00211 <span class="stringliteral"></span>
00212 <span class="stringliteral">                return FALSE;</span>
00213 <span class="stringliteral">            }</span>
00214 <span class="stringliteral">        }</span>
00215 <span class="stringliteral"></span>
00216 <span class="stringliteral">        //</span>
00217 <span class="stringliteral">        //  All the componants were OK, so the path is OK.</span>
00218 <span class="stringliteral">        //</span>
00219 <span class="stringliteral"></span>
00220 <span class="stringliteral">        return TRUE;</span>
00221 <span class="stringliteral">    }</span>
00222 <span class="stringliteral"></span>
00223 <span class="stringliteral">    //</span>
00224 <span class="stringliteral">    //  If this name contains wild cards, just check for invalid characters.</span>
00225 <span class="stringliteral">    //</span>
00226 <span class="stringliteral"></span>
00227 <span class="stringliteral">    if ( WildCardsPermissible &amp;&amp; FsRtlDoesDbcsContainWildCards(&amp;DbcsName) ) {</span>
00228 <span class="stringliteral"></span>
00229 <span class="stringliteral">        for ( Index = 0; Index &lt; DbcsName.Length; Index += 1 ) {</span>
00230 <span class="stringliteral"></span>
00231 <span class="stringliteral">            Char = DbcsName.Buffer[ Index ];</span>
00232 <span class="stringliteral"></span>
00233 <span class="stringliteral">            //</span>
00234 <span class="stringliteral">            //  Skip over any Dbcs chacters</span>
00235 <span class="stringliteral">            //</span>
00236 <span class="stringliteral"></span>
00237 <span class="stringliteral">            if ( FsRtlIsLeadDbcsCharacter( Char ) ) {</span>
00238 <span class="stringliteral"></span>
00239 <span class="stringliteral">                ASSERT( Index != (ULONG)(DbcsName.Length - 1) );</span>
00240 <span class="stringliteral">                Index += 1;</span>
00241 <span class="stringliteral">                continue;</span>
00242 <span class="stringliteral">            }</span>
00243 <span class="stringliteral"></span>
00244 <span class="stringliteral">            //</span>
00245 <span class="stringliteral">            //  Make sure this character is legal, and if a wild card, that</span>
00246 <span class="stringliteral">            //  wild cards are permissible.</span>
00247 <span class="stringliteral">            //</span>
00248 <span class="stringliteral"></span>
00249 <span class="stringliteral">            if ( !FsRtlIsAnsiCharacterLegalFat(Char, WildCardsPermissible) ) {</span>
00250 <span class="stringliteral">                return FALSE;</span>
00251 <span class="stringliteral">            }</span>
00252 <span class="stringliteral">        }</span>
00253 <span class="stringliteral"></span>
00254 <span class="stringliteral">        return TRUE;</span>
00255 <span class="stringliteral">    }</span>
00256 <span class="stringliteral"></span>
00257 <span class="stringliteral"></span>
00258 <span class="stringliteral">    //</span>
00259 <span class="stringliteral">    //  At this point we should only have a single name, which can't have</span>
00260 <span class="stringliteral">    //  more than 12 characters (including a single period)</span>
00261 <span class="stringliteral">    //</span>
00262 <span class="stringliteral"></span>
00263 <span class="stringliteral">    if ( DbcsName.Length &gt; 12 ) { return FALSE; }</span>
00264 <span class="stringliteral"></span>
00265 <span class="stringliteral">    for ( Index = 0; Index &lt; DbcsName.Length; Index += 1 ) {</span>
00266 <span class="stringliteral"></span>
00267 <span class="stringliteral">        Char = DbcsName.Buffer[ Index ];</span>
00268 <span class="stringliteral"></span>
00269 <span class="stringliteral">        //</span>
00270 <span class="stringliteral">        //  Skip over and Dbcs chacters</span>
00271 <span class="stringliteral">        //</span>
00272 <span class="stringliteral"></span>
00273 <span class="stringliteral">        if ( FsRtlIsLeadDbcsCharacter( Char ) ) {</span>
00274 <span class="stringliteral"></span>
00275 <span class="stringliteral">            //</span>
00276 <span class="stringliteral">            //  FsRtlIsFatDbcsLegal(): fat name part and extension part dbcs check</span>
00277 <span class="stringliteral">            //</span>
00278 <span class="stringliteral">            //  1) if we're looking at base part ( !ExtensionPresent ) and the 8th byte</span>
00279 <span class="stringliteral">            //     is in the dbcs leading byte range, it's error ( Index == 7 ). If the</span>
00280 <span class="stringliteral">            //     length of base part is more than 8 ( Index &gt; 7 ), it's definitely error.</span>
00281 <span class="stringliteral">            //</span>
00282 <span class="stringliteral">            //  2) if the last byte ( Index == DbcsName.Length - 1 ) is in the dbcs leading</span>
00283 <span class="stringliteral">            //     byte range, it's error</span>
00284 <span class="stringliteral">            //</span>
00285 <span class="stringliteral"></span>
00286 <span class="stringliteral">            if ( (!ExtensionPresent &amp;&amp; (Index &gt;= 7)) ||</span>
00287 <span class="stringliteral">                 ( Index == (ULONG)(DbcsName.Length - 1) ) ) {</span>
00288 <span class="stringliteral">                return FALSE;</span>
00289 <span class="stringliteral">            }</span>
00290 <span class="stringliteral"></span>
00291 <span class="stringliteral">            Index += 1;</span>
00292 <span class="stringliteral"></span>
00293 <span class="stringliteral">            continue;</span>
00294 <span class="stringliteral">        }</span>
00295 <span class="stringliteral"></span>
00296 <span class="stringliteral">        //</span>
00297 <span class="stringliteral">        //  Make sure this character is legal, and if a wild card, that</span>
00298 <span class="stringliteral">        //  wild cards are permissible.</span>
00299 <span class="stringliteral">        //</span>
00300 <span class="stringliteral"></span>
00301 <span class="stringliteral">        if ( !FsRtlIsAnsiCharacterLegalFat(Char, WildCardsPermissible) ) {</span>
00302 <span class="stringliteral"></span>
00303 <span class="stringliteral">            return FALSE;</span>
00304 <span class="stringliteral">        }</span>
00305 <span class="stringliteral"></span>
00306 <span class="stringliteral">        if ( (Char == '.') || (Char == ANSI_DOS_DOT) ) {</span>
00307 <span class="stringliteral"></span>
00308 <span class="stringliteral">            //</span>
00309 <span class="stringliteral">            //  We stepped onto a period.  We require the following things:</span>
00310 <span class="stringliteral">            //</span>
00311 <span class="stringliteral">            //      - It can't be the first character</span>
00312 <span class="stringliteral">            //      - There can only be one</span>
00313 <span class="stringliteral">            //      - There can't be more than three characters following</span>
00314 <span class="stringliteral">            //      - The previous character can't be a space.</span>
00315 <span class="stringliteral">            //</span>
00316 <span class="stringliteral"></span>
00317 <span class="stringliteral">            if ( (Index == 0) ||</span>
00318 <span class="stringliteral">                 ExtensionPresent ||</span>
00319 <span class="stringliteral">                 (DbcsName.Length - (Index + 1) &gt; 3) ||</span>
00320 <span class="stringliteral">                 (DbcsName.Buffer[Index - 1] == ' ') ) {</span>
00321 <span class="stringliteral"></span>
00322 <span class="stringliteral">                return FALSE;</span>
00323 <span class="stringliteral">            }</span>
00324 <span class="stringliteral"></span>
00325 <span class="stringliteral">            ExtensionPresent = TRUE;</span>
00326 <span class="stringliteral">        }</span>
00327 <span class="stringliteral"></span>
00328 <span class="stringliteral">        //</span>
00329 <span class="stringliteral">        //  The base part of the name can't be more than 8 characters long.</span>
00330 <span class="stringliteral">        //</span>
00331 <span class="stringliteral"></span>
00332 <span class="stringliteral">        if ( (Index &gt;= 8) &amp;&amp; !ExtensionPresent ) { return FALSE; }</span>
00333 <span class="stringliteral">    }</span>
00334 <span class="stringliteral"></span>
00335 <span class="stringliteral">    //</span>
00336 <span class="stringliteral">    //  The name cannot end in a space or a period.</span>
00337 <span class="stringliteral">    //</span>
00338 <span class="stringliteral"></span>
00339 <span class="stringliteral">    if ( (Char == ' ') || (Char == '.') || (Char == ANSI_DOS_DOT)) { return FALSE; }</span>
00340 <span class="stringliteral"></span>
00341 <span class="stringliteral">    return TRUE;</span>
00342 <span class="stringliteral">}</span>
</span>
</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="dbcsname.c::FsRtlIsHpfsDbcsLegal" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> BOOLEAN FsRtlIsHpfsDbcsLegal           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN ANSI_STRING&nbsp;</td>
          <td class="mdname" nowrap> <em>DbcsName</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN BOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>WildCardsPermissible</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN BOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>PathNamePermissible</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN BOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>LeadingBackslashPermissible</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d2/d2/dbcsname_8c-source.html#l00345">345</a> of file <a class="el" href="../../d2/d2/dbcsname_8c-source.html">dbcsname.c</a>.
<p>
References <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d2/d2/dbcsname_8c-source.html#l00542">FsRtlDissectDbcs()</a>, <a class="el" href="../../d2/d7/fsrtl_8h-source.html#l00962">FsRtlIsAnsiCharacterLegalHpfs</a>, <a class="el" href="../../d2/d7/fsrtl_8h-source.html#l01033">FsRtlIsLeadDbcsCharacter</a>, <a class="el" href="../../d2/d9/cmchek_8c-source.html#l00095">Index</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>, and <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>.
<p>
<pre class="fragment"><div>00354                    :
00355 
00356     This routine simple returns whether <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> names conforms
00357     to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> system specific rules <span class="keywordflow">for</span> legal <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> names.  This routine
00358     will check <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> single name, or <span class="keywordflow">if</span> PathNamePermissible <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> specified as
00359     <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, whether <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> whole <a class="code" href="../../d3/d3/dumpuser_8c.html#a14">path</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> a legal name.
00360 
00361     For HPFS, <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> following rules apply:
00362 
00363     <a class="code" href="../../d2/d1/bench_8h.html#a5">A</a>. An HPFS <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> name may not contain any of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> following characters:
00364 
00365        0x0000 - 0x001F  <span class="stringliteral">" / : &lt; &gt; ? | *</span>
00366 <span class="stringliteral"></span>
00367 <span class="stringliteral">    B. An HPFS file name may not end in a period or a space.</span>
00368 <span class="stringliteral"></span>
00369 <span class="stringliteral">    C. An HPFS file name must contain no more than 255 bytes.</span>
00370 <span class="stringliteral"></span>
00371 <span class="stringliteral">    Case: HPFS is case preserving, but not case sensitive.  Case is</span>
00372 <span class="stringliteral">          preserved on creates, but not checked for on file name compares.</span>
00373 <span class="stringliteral"></span>
00374 <span class="stringliteral">    For example, the files "</span><a class="code" href="../../d8/d7/udbgk_8c.html#a2">foo</a> <span class="stringliteral">" and "</span><a class="code" href="../../d8/d7/udbgk_8c.html#a2">foo</a>.<span class="stringliteral">" are illegal, while "</span>.<a class="code" href="../../d8/d7/udbgk_8c.html#a2">foo</a><span class="stringliteral">",</span>
00375 <span class="stringliteral">    "</span> <a class="code" href="../../d8/d7/udbgk_8c.html#a2">foo</a><span class="stringliteral">" and "</span><a class="code" href="../../d8/d7/udbgk_8c.html#a2">foo</a>.bar.foo<span class="stringliteral">" are legal.</span>
00376 <span class="stringliteral"></span>
00377 <span class="stringliteral">Arguments:</span>
00378 <span class="stringliteral"></span>
00379 <span class="stringliteral">    DbcsName - Supllies the name/path to check.</span>
00380 <span class="stringliteral"></span>
00381 <span class="stringliteral">    WildCardsPermissible - Specifies if Nt wild card characters are to be</span>
00382 <span class="stringliteral">        considered considered legal.</span>
00383 <span class="stringliteral"></span>
00384 <span class="stringliteral">    PathNamePermissible - Spcifes if Name may be a path name separated by</span>
00385 <span class="stringliteral">        backslash characters, or just a simple file name.</span>
00386 <span class="stringliteral"></span>
00387 <span class="stringliteral">    LeadingBackSlashPermissible - Specifies if a single leading backslash</span>
00388 <span class="stringliteral">        is permissible in the file/path name.</span>
00389 <span class="stringliteral"></span>
00390 <span class="stringliteral">Return Value:</span>
00391 <span class="stringliteral"></span>
00392 <span class="stringliteral">    BOOLEAN - TRUE if the name is legal, FALSE otherwise.</span>
00393 <span class="stringliteral"></span>
00394 <span class="stringliteral">--*/</span>
00395 <span class="stringliteral">{</span>
00396 <span class="stringliteral">    BOOLEAN ExtensionPresent = FALSE;</span>
00397 <span class="stringliteral"></span>
00398 <span class="stringliteral">    ULONG Index;</span>
00399 <span class="stringliteral"></span>
00400 <span class="stringliteral">    UCHAR Char;</span>
00401 <span class="stringliteral"></span>
00402 <span class="stringliteral">    PAGED_CODE();</span>
00403 <span class="stringliteral"></span>
00404 <span class="stringliteral">    //</span>
00405 <span class="stringliteral">    //  Empty names are not valid.</span>
00406 <span class="stringliteral">    //</span>
00407 <span class="stringliteral"></span>
00408 <span class="stringliteral">    if ( DbcsName.Length == 0 ) { return FALSE; }</span>
00409 <span class="stringliteral"></span>
00410 <span class="stringliteral">    //</span>
00411 <span class="stringliteral">    //  If Wild Cards are OK, then for directory enumeration to work</span>
00412 <span class="stringliteral">    //  correctly we have to accept . and ..</span>
00413 <span class="stringliteral">    //</span>
00414 <span class="stringliteral"></span>
00415 <span class="stringliteral">    if ( WildCardsPermissible &amp;&amp;</span>
00416 <span class="stringliteral">         ( ( (DbcsName.Length == 1) &amp;&amp;</span>
00417 <span class="stringliteral">             ((DbcsName.Buffer[0] == '.') ||</span>
00418 <span class="stringliteral">              (DbcsName.Buffer[0] == ANSI_DOS_DOT)) )</span>
00419 <span class="stringliteral">           ||</span>
00420 <span class="stringliteral">           ( (DbcsName.Length == 2) &amp;&amp;</span>
00421 <span class="stringliteral">             ( ((DbcsName.Buffer[0] == '.') &amp;&amp;</span>
00422 <span class="stringliteral">                (DbcsName.Buffer[1] == '.')) ||</span>
00423 <span class="stringliteral">               ((DbcsName.Buffer[0] == ANSI_DOS_DOT) &amp;&amp;</span>
00424 <span class="stringliteral">                (DbcsName.Buffer[1] == ANSI_DOS_DOT)) ) ) ) ) {</span>
00425 <span class="stringliteral"></span>
00426 <span class="stringliteral">        return TRUE;</span>
00427 <span class="stringliteral">    }</span>
00428 <span class="stringliteral"></span>
00429 <span class="stringliteral">    //</span>
00430 <span class="stringliteral">    //  If a leading \ is OK, skip over it (if there's more)</span>
00431 <span class="stringliteral">    //</span>
00432 <span class="stringliteral"></span>
00433 <span class="stringliteral">    if ( DbcsName.Buffer[0] == '\\' ) {</span>
00434 <span class="stringliteral"></span>
00435 <span class="stringliteral">        if ( LeadingBackslashPermissible ) {</span>
00436 <span class="stringliteral"></span>
00437 <span class="stringliteral">            if ( (DbcsName.Length &gt; 1) ) {</span>
00438 <span class="stringliteral"></span>
00439 <span class="stringliteral">                DbcsName.Buffer += 1;</span>
00440 <span class="stringliteral">                DbcsName.Length -= 1;</span>
00441 <span class="stringliteral"></span>
00442 <span class="stringliteral">            } else { return TRUE; }</span>
00443 <span class="stringliteral"></span>
00444 <span class="stringliteral">        } else { return FALSE; }</span>
00445 <span class="stringliteral">    }</span>
00446 <span class="stringliteral"></span>
00447 <span class="stringliteral">    //</span>
00448 <span class="stringliteral">    //  If we got a path name, check each componant.</span>
00449 <span class="stringliteral">    //</span>
00450 <span class="stringliteral"></span>
00451 <span class="stringliteral">    if ( PathNamePermissible ) {</span>
00452 <span class="stringliteral"></span>
00453 <span class="stringliteral">        ANSI_STRING FirstName;</span>
00454 <span class="stringliteral">        ANSI_STRING RemainingName;</span>
00455 <span class="stringliteral"></span>
00456 <span class="stringliteral">        RemainingName = DbcsName;</span>
00457 <span class="stringliteral"></span>
00458 <span class="stringliteral">        while ( RemainingName.Length != 0 ) {</span>
00459 <span class="stringliteral"></span>
00460 <span class="stringliteral">            //</span>
00461 <span class="stringliteral">            //  This will catch the case of an illegal double backslash.</span>
00462 <span class="stringliteral">            //</span>
00463 <span class="stringliteral"></span>
00464 <span class="stringliteral">            if ( RemainingName.Buffer[0] == '\\' ) { return FALSE; }</span>
00465 <span class="stringliteral"></span>
00466 <span class="stringliteral">            FsRtlDissectDbcs(RemainingName, &amp;FirstName, &amp;RemainingName);</span>
00467 <span class="stringliteral"></span>
00468 <span class="stringliteral">            if ( !FsRtlIsHpfsDbcsLegal( FirstName,</span>
00469 <span class="stringliteral">                                       WildCardsPermissible,</span>
00470 <span class="stringliteral">                                       FALSE,</span>
00471 <span class="stringliteral">                                       FALSE) ) {</span>
00472 <span class="stringliteral"></span>
00473 <span class="stringliteral">                return FALSE;</span>
00474 <span class="stringliteral">            }</span>
00475 <span class="stringliteral">        }</span>
00476 <span class="stringliteral"></span>
00477 <span class="stringliteral">        //</span>
00478 <span class="stringliteral">        //  All the componants were OK, so the path is OK.</span>
00479 <span class="stringliteral">        //</span>
00480 <span class="stringliteral"></span>
00481 <span class="stringliteral">        return TRUE;</span>
00482 <span class="stringliteral">    }</span>
00483 <span class="stringliteral"></span>
00484 <span class="stringliteral">    //</span>
00485 <span class="stringliteral">    //  At this point we should only have a single name, which can't have</span>
00486 <span class="stringliteral">    //  more than 255 characters</span>
00487 <span class="stringliteral">    //</span>
00488 <span class="stringliteral"></span>
00489 <span class="stringliteral">    if ( DbcsName.Length &gt; 255 ) { return FALSE; }</span>
00490 <span class="stringliteral"></span>
00491 <span class="stringliteral">    for ( Index = 0; Index &lt; DbcsName.Length; Index += 1 ) {</span>
00492 <span class="stringliteral"></span>
00493 <span class="stringliteral">        Char = DbcsName.Buffer[ Index ];</span>
00494 <span class="stringliteral"></span>
00495 <span class="stringliteral">        //</span>
00496 <span class="stringliteral">        //  Skip over and Dbcs chacters</span>
00497 <span class="stringliteral">        //</span>
00498 <span class="stringliteral"></span>
00499 <span class="stringliteral">        if ( FsRtlIsLeadDbcsCharacter( Char ) ) {</span>
00500 <span class="stringliteral"></span>
00501 <span class="stringliteral">            //</span>
00502 <span class="stringliteral">            //  FsRtlIsHpfsDbcsLegal () hpfs dbcs check</span>
00503 <span class="stringliteral">            //</span>
00504 <span class="stringliteral">            //  If the last byte ( Index == DbcsName.Length - 1 ) is in the</span>
00505 <span class="stringliteral">            //  dbcs leading byte range, it's error.</span>
00506 <span class="stringliteral">            //</span>
00507 <span class="stringliteral"></span>
00508 <span class="stringliteral">            if ( Index == (ULONG)(DbcsName.Length - 1) ) {</span>
00509 <span class="stringliteral"></span>
00510 <span class="stringliteral">                return FALSE;</span>
00511 <span class="stringliteral">            }</span>
00512 <span class="stringliteral"></span>
00513 <span class="stringliteral">            Index += 1;</span>
00514 <span class="stringliteral">            continue;</span>
00515 <span class="stringliteral">        }</span>
00516 <span class="stringliteral"></span>
00517 <span class="stringliteral">        //</span>
00518 <span class="stringliteral">        //  Make sure this character is legal, and if a wild card, that</span>
00519 <span class="stringliteral">        //  wild cards are permissible.</span>
00520 <span class="stringliteral">        //</span>
00521 <span class="stringliteral"></span>
00522 <span class="stringliteral">        if ( !FsRtlIsAnsiCharacterLegalHpfs(Char, WildCardsPermissible) ) {</span>
00523 <span class="stringliteral"></span>
00524 <span class="stringliteral">            return FALSE;</span>
00525 <span class="stringliteral">        }</span>
00526 <span class="stringliteral">    }</span>
00527 <span class="stringliteral"></span>
00528 <span class="stringliteral">    //</span>
00529 <span class="stringliteral">    //  The name cannot end in a space or a period.</span>
00530 <span class="stringliteral">    //</span>
00531 <span class="stringliteral"></span>
00532 <span class="stringliteral">    if ( (Char == ' ') || (Char == '.') || (Char == ANSI_DOS_DOT) ) {</span>
00533 <span class="stringliteral"></span>
00534 <span class="stringliteral">        return FALSE;</span>
00535 <span class="stringliteral">    }</span>
00536 <span class="stringliteral"></span>
00537 <span class="stringliteral">    return TRUE;</span>
00538 <span class="stringliteral">}</span>
</span>
</div></pre>    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:43:23 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
