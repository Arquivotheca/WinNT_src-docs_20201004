<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: hivedata.h Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>hivedata.h</h1><a href="../../d0/d1/hivedata_8h.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1999  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    hivedata.h</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module contains data structures used by the </span>
00012 <span class="comment">    direct memory loaded hive manager.</span>
00013 <span class="comment"></span>
00014 <span class="comment">Author:</span>
00015 <span class="comment"></span>
00016 <span class="comment">    Dragos C. Sambotin (dragoss) 13-Jan-99</span>
00017 <span class="comment"></span>
00018 <span class="comment">Revision History:</span>
00019 <span class="comment"></span>
00020 <span class="comment"></span>
00021 <span class="comment"></span>
00022 <span class="comment">--*/</span>
00023 
00024 <span class="preprocessor">#ifndef __HIVE_DATA__</span>
00025 <span class="preprocessor"></span><span class="preprocessor">#define __HIVE_DATA__</span>
00026 <span class="preprocessor"></span>
00027 <span class="comment">//</span>
00028 <span class="comment">// ===== Arbitrary Limits Imposed For Sanity =====</span>
00029 <span class="comment">//</span>
<a name="l00030"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a0">00030</a> <span class="preprocessor">#define HSANE_CELL_MAX      (1024*1024)     // 1 megabyte max size for</span>
00031 <span class="preprocessor"></span>                                            <span class="comment">// a single cell</span>
00032 
00033 
00034 <span class="comment">//</span>
00035 <span class="comment">// ===== Tuning =====</span>
00036 
<a name="l00037"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a1">00037</a> <span class="preprocessor">#define HBIN_THRESHOLD      (HBLOCK_SIZE-512)   // If less than threshold</span>
00038 <span class="preprocessor"></span>                                                <span class="comment">// bytes would be left in</span>
00039                                                 <span class="comment">// bin, add another page</span>
00040 
<a name="l00041"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a2">00041</a> <span class="preprocessor">#define HLOG_GROW           HBLOCK_SIZE         // Minimum size to grow log</span>
00042 <span class="preprocessor"></span>                                                <span class="comment">// by.  Can set this up</span>
00043                                                 <span class="comment">// if we think it thrashes.</span>
00044 
<a name="l00045"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a3">00045</a> <span class="preprocessor">#define HCELL_BIG_ROUND     (HBLOCK_SIZE*3)     //</span>
00046 <span class="preprocessor"></span>                                                <span class="comment">// If someone tries to</span>
00047                                                 <span class="comment">// allocate a very large</span>
00048                                                 <span class="comment">// cell, round it up to</span>
00049                                                 <span class="comment">// HBLOCK_SIZE.  This is</span>
00050                                                 <span class="comment">// the rather arbitrary</span>
00051                                                 <span class="comment">// define for "very large"</span>
00052                                                 <span class="comment">//</span>
00053 <span class="comment">//</span>
00054 <span class="comment">// Never shrink the log files smaller than this, this prevents people</span>
00055 <span class="comment">// from sucking up all the disk space and then being unable to do</span>
00056 <span class="comment">// critical registry operations (like logging on to delete some files)</span>
00057 <span class="comment">//</span>
<a name="l00058"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a4">00058</a> <span class="preprocessor">#define HLOG_MINSIZE(Hive)  \</span>
00059 <span class="preprocessor">    ((Hive)-&gt;Cluster * HSECTOR_SIZE * 2)</span>
00060 <span class="preprocessor"></span>
00061 <span class="comment">//</span>
00062 <span class="comment">// ===== Basic Structures and Definitions =====</span>
00063 <span class="comment">//</span>
00064 <span class="comment">// These are same whether on disk or in memory.</span>
00065 <span class="comment">//</span>
00066 
00067 <span class="comment">//</span>
00068 <span class="comment">// NOTE:    Volatile == storage goes away at reboot</span>
00069 <span class="comment">//          Stable == Persistent == Not Volatile</span>
00070 <span class="comment">//</span>
<a name="l00071"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a77">00071</a> <span class="keyword">typedef</span> <span class="keyword">enum</span> {
00072     <a class="code" href="../../d0/d1/hivedata_8h.html#a77a75">Stable</a> = 0,
00073     <a class="code" href="../../d0/d1/hivedata_8h.html#a77a76">Volatile</a> = 1
00074 } <a class="code" href="../../d0/d1/hivedata_8h.html#a77">HSTORAGE_TYPE</a>;
00075 
<a name="l00076"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a5">00076</a> <span class="preprocessor">#define HTYPE_COUNT 2</span>
00077 <span class="preprocessor"></span>
00078 <span class="comment">//</span>
00079 <span class="comment">// --- HCELL_INDEX ---</span>
00080 <span class="comment">//</span>
00081 <span class="comment">//</span>
00082 <span class="comment">// Handle to a cell -&gt; effectively the "virtual" address of the cell,</span>
00083 <span class="comment">// HvMapCell converts this to a "real" address, that is, a memory</span>
00084 <span class="comment">// address.  Mapping scheme is very much like that standard two level</span>
00085 <span class="comment">// page table.  No mappings stored in file, they are built up when</span>
00086 <span class="comment">// the file is read in.  (The INDEX in HCELL_INDEX is historical)</span>
00087 <span class="comment">//</span>
00088 <span class="comment">//  Bit     31  30-21   20-12   11-0</span>
00089 <span class="comment">//        +----------------------------+</span>
00090 <span class="comment">//        | T | Table | Block | Offset |</span>
00091 <span class="comment">//        +----------------------------+</span>
00092 <span class="comment">//</span>
00093 <span class="comment">//  T = Type(1)= 0 for stable ("normal") storage</span>
00094 <span class="comment">//               1 for volatile storage</span>
00095 <span class="comment">//</span>
00096 <span class="comment">//      Table(10) = Index into directory of mapping tables, selects a table.</span>
00097 <span class="comment">//                  Each mapping table is an array of HMAP_ENTRY structures.</span>
00098 <span class="comment">//</span>
00099 <span class="comment">//      Block(9) = Index into Table, selects an HMAP_ENTRY.  HMAP_ENTRY</span>
00100 <span class="comment">//                 contains address of area in memory that this HCELL_INDEX</span>
00101 <span class="comment">//                 maps to.  (Base of memory copy of Block)</span>
00102 <span class="comment">//</span>
00103 <span class="comment">//      Offset(12) = Offset within page, of the Cell header for the cell</span>
00104 <span class="comment">//                   of interest.</span>
00105 <span class="comment">//</span>
<a name="l00106"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a49">00106</a> <span class="keyword">typedef</span> ULONG <a class="code" href="../../d0/d1/hivedata_8h.html#a49">HCELL_INDEX</a>;
<a name="l00107"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a50">00107</a> <span class="keyword">typedef</span> <a class="code" href="../../d0/d1/hivedata_8h.html#a49">HCELL_INDEX</a> *<a class="code" href="../../d0/d1/hivedata_8h.html#a50">PHCELL_INDEX</a>;
00108 
<a name="l00109"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a6">00109</a> <span class="preprocessor">#define HCELL_NIL   ((HCELL_INDEX)(-1))</span>
00110 <span class="preprocessor"></span>
<a name="l00111"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a7">00111</a> <span class="preprocessor">#define HCELL_TYPE_MASK         0x80000000</span>
<a name="l00112"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a8">00112</a> <span class="preprocessor"></span><span class="preprocessor">#define HCELL_TYPE_SHIFT        31</span>
00113 <span class="preprocessor"></span>
<a name="l00114"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a9">00114</a> <span class="preprocessor">#define HCELL_TABLE_MASK        0x7fe00000</span>
<a name="l00115"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a10">00115</a> <span class="preprocessor"></span><span class="preprocessor">#define HCELL_TABLE_SHIFT       21</span>
00116 <span class="preprocessor"></span>
<a name="l00117"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a11">00117</a> <span class="preprocessor">#define HCELL_BLOCK_MASK        0x001ff000</span>
<a name="l00118"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a12">00118</a> <span class="preprocessor"></span><span class="preprocessor">#define HCELL_BLOCK_SHIFT       12</span>
00119 <span class="preprocessor"></span>
<a name="l00120"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a13">00120</a> <span class="preprocessor">#define HCELL_OFFSET_MASK       0x00000fff</span>
00121 <span class="preprocessor"></span>
<a name="l00122"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a14">00122</a> <span class="preprocessor">#define HBLOCK_SIZE             0x1000      // LOGICAL block size</span>
00123 <span class="preprocessor"></span>                                            <span class="comment">// This is the size of one of</span>
00124                                             <span class="comment">// the registry's logical/virtual</span>
00125                                             <span class="comment">// pages.  It has no particular</span>
00126                                             <span class="comment">// relationship to page size</span>
00127                                             <span class="comment">// of the machine.</span>
00128 
<a name="l00129"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a15">00129</a> <span class="preprocessor">#define HSECTOR_SIZE            0x200       // LOGICAL sector size</span>
<a name="l00130"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a16">00130</a> <span class="preprocessor"></span><span class="preprocessor">#define HSECTOR_COUNT           8           // LOGICAL sectors / LOGICAL Block</span>
00131 <span class="preprocessor"></span>
<a name="l00132"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a17">00132</a> <span class="preprocessor">#define HTABLE_SLOTS        512         // 9 bits of address</span>
<a name="l00133"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a18">00133</a> <span class="preprocessor"></span><span class="preprocessor">#define HDIRECTORY_SLOTS    1024        // 10 bits of address</span>
00134 <span class="preprocessor"></span>
<a name="l00135"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a19">00135</a> <span class="preprocessor">#define HvGetCellType(Cell) ((ULONG)((Cell &amp; HCELL_TYPE_MASK) &gt;&gt; HCELL_TYPE_SHIFT))</span>
00136 <span class="preprocessor"></span>
00137 <span class="comment">//</span>
00138 <span class="comment">// --- HCELL --- an object within the hive  (A bin is filled with HCELLs)</span>
00139 <span class="comment">//</span>
00140 <span class="comment">// Any given item of user data must fit within a single HCELL.</span>
00141 <span class="comment">// HCELLs cannot span Bins.</span>
00142 <span class="comment">//</span>
<a name="l00143"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a20">00143</a> <span class="preprocessor">#define HCELL_PAD(Hive)         ((Hive-&gt;Version&gt;=2) ? 8 : 16)</span>
00144 <span class="preprocessor"></span>                                <span class="comment">// All cells must be at least this large,</span>
00145                                 <span class="comment">// All allocations on this boundary</span>
00146 
<a name="l00147"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a21">00147</a> <span class="preprocessor">#define HCELL_ALLOCATE_FILL 0xb2    // bz -&gt; buzz buzz (yeah, it's a stretch)</span>
00148 <span class="preprocessor"></span>                                    <span class="comment">// must fill all newly allocated</span>
00149                                     <span class="comment">// cells for security reasons</span>
00150 
<a name="l00151"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a22">00151</a> <span class="preprocessor">#define HCELL_FREE_FILL     0xfc    // fc = HvFreeCell...</span>
00152 <span class="preprocessor"></span>
00153 <span class="comment">//</span>
00154 <span class="comment">// Currently we support two cell formats, one with a Last backpointer (old version),</span>
00155 <span class="comment">// and one without (new version)</span>
00156 <span class="comment">//</span>
00157 <span class="comment">// All cells in a hive must be of the same type.  Version 1 hives use the old version,</span>
00158 <span class="comment">// Version 2 or greater use the new version.</span>
00159 <span class="comment">//</span>
00160 
<a name="l00161"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a23">00161</a> <span class="preprocessor">#define USE_OLD_CELL(Hive) (Hive-&gt;Version==1)</span>
00162 <span class="preprocessor"></span>
<a name="l00163"></a><a class="code" href="../../d8/d4/struct__HCELL.html">00163</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d8/d4/struct__HCELL.html">_HCELL</a> {
<a name="l00164"></a><a class="code" href="../../d8/d4/struct__HCELL.html#o0">00164</a>     LONG    <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
00165     <span class="keyword">union </span>{
00166         <span class="keyword">struct </span>{
<a name="l00167"></a><a class="code" href="../../d8/d4/struct__HCELL.html#o1">00167</a>             ULONG <a class="code" href="../../d8/d4/struct__HCELL.html#o1">Last</a>;
00168             <span class="keyword">union </span>{
00169                 ULONG <a class="code" href="../../d8/d4/struct__HCELL.html#o2">UserData</a>;
00170                 <a class="code" href="../../d0/d1/hivedata_8h.html#a49">HCELL_INDEX</a> <a class="code" href="../../d8/d4/struct__HCELL.html#o3">Next</a>;   <span class="comment">// offset of next element in freelist (not a FLink)</span>
00171             } u;
00172         } <a class="code" href="../../d8/d4/struct__HCELL.html#o5">OldCell</a>;
00173 
00174         <span class="keyword">struct </span>{
00175             <span class="keyword">union </span>{
<a name="l00176"></a><a class="code" href="../../d8/d4/struct__HCELL.html#o2">00176</a>                 ULONG <a class="code" href="../../d8/d4/struct__HCELL.html#o2">UserData</a>;
<a name="l00177"></a><a class="code" href="../../d8/d4/struct__HCELL.html#o3">00177</a>                 <a class="code" href="../../d0/d1/hivedata_8h.html#a49">HCELL_INDEX</a> <a class="code" href="../../d8/d4/struct__HCELL.html#o3">Next</a>;    <span class="comment">// offset of next element in freelist (not a FLink)</span>
00178             } u;
00179         } <a class="code" href="../../d8/d4/struct__HCELL.html#o7">NewCell</a>;
00180     } <a class="code" href="../../d8/d4/struct__HCELL.html#o4">u</a>;
00181 } <a class="code" href="../../d8/d4/struct__HCELL.html">HCELL</a>, *<a class="code" href="../../d8/d4/struct__HCELL.html">PHCELL</a>;
00182 
00183 
00184 <span class="comment">//</span>
00185 <span class="comment">// --- HBIN ---  is a contiguous set of HBLOCKs, filled with HCELLs.</span>
00186 <span class="comment">//</span>
<a name="l00187"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a24">00187</a> <span class="preprocessor">#define HBIN_SIGNATURE          0x6e696268      // "hbin"</span>
<a name="l00188"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a25">00188</a> <span class="preprocessor"></span><span class="preprocessor">#define HBIN_NIL                (-1)</span>
00189 <span class="preprocessor"></span>
00190 <span class="preprocessor">#pragma pack(4)</span>
<a name="l00191"></a><a class="code" href="../../d7/d4/struct__HBIN.html">00191</a> <span class="preprocessor"></span><span class="keyword">typedef</span> <span class="keyword">struct  </span><a class="code" href="../../d7/d4/struct__HBIN.html">_HBIN</a> {
<a name="l00192"></a><a class="code" href="../../d7/d4/struct__HBIN.html#o0">00192</a>     ULONG       <a class="code" href="../../d7/d4/struct__HBIN.html#o0">Signature</a>;
<a name="l00193"></a><a class="code" href="../../d7/d4/struct__HBIN.html#o1">00193</a>     ULONG       <a class="code" href="../../d7/d4/struct__HBIN.html#o1">FileOffset</a>;     <span class="comment">// Own file offset (used in checking)</span>
<a name="l00194"></a><a class="code" href="../../d7/d4/struct__HBIN.html#o2">00194</a>     ULONG       <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;           <span class="comment">// Size of bin in bytes, all inclusive</span>
<a name="l00195"></a><a class="code" href="../../d7/d4/struct__HBIN.html#o3">00195</a>     ULONG       <a class="code" href="../../d7/d4/struct__HBIN.html#o3">Reserved1</a>[2];   <span class="comment">// Old FreeSpace and FreeList (from 1.0)</span>
<a name="l00196"></a><a class="code" href="../../d7/d4/struct__HBIN.html#o4">00196</a>     LARGE_INTEGER   <a class="code" href="../../d7/d4/struct__HBIN.html#o4">TimeStamp</a>;  <span class="comment">// Old Link (from 1.0).  Usually trash, but</span>
00197                                 <span class="comment">// first bin has valid value used for .log</span>
00198                                 <span class="comment">// correspondence testing, only meaningful</span>
00199                                 <span class="comment">// on disk.</span>
<a name="l00200"></a><a class="code" href="../../d7/d4/struct__HBIN.html#o5">00200</a>     ULONG       <a class="code" href="../../d7/d4/struct__HBIN.html#o5">MemAlloc</a>;       <span class="comment">// if non 0, this is first bin of allocation</span>
00201                                 <span class="comment">// and this is it's size.  else, middle</span>
00202                                 <span class="comment">// bin of an allocation.  MEMORY ONLY,</span>
00203                                 <span class="comment">// field on disk has no meaning.</span>
00204 
00205     <span class="comment">//</span>
00206     <span class="comment">// Cell data goes here</span>
00207     <span class="comment">//</span>
00208 
00209 } <a class="code" href="../../d7/d4/struct__HBIN.html">HBIN</a>, *<a class="code" href="../../d7/d4/struct__HBIN.html">PHBIN</a>;
00210 <span class="preprocessor">#pragma pack()</span>
00211 <span class="preprocessor"></span>
00212 <span class="comment">//</span>
00213 <span class="comment">// ===== On Disk Structures =====</span>
00214 <span class="comment">//</span>
00215 
00216 <span class="comment">//</span>
00217 <span class="comment">// NOTE:    Hive storage is always allocated in units of 4K.  This size</span>
00218 <span class="comment">//          must be used on all systems, regardless of page size, since</span>
00219 <span class="comment">//          the file format needs to be transportable amoung systems.</span>
00220 <span class="comment">//</span>
00221 <span class="comment">// NOTE:    The integrity code depends on certain blocks (e.g., the</span>
00222 <span class="comment">//          BASE block) being at least as large as the size of a physical</span>
00223 <span class="comment">//          sector.  (Otherwise data that should be left alone will</span>
00224 <span class="comment">//          be written because the FS has to block/deblock.)  This means</span>
00225 <span class="comment">//          that the current code will not work with sectors &gt; 4K.</span>
00226 <span class="comment">//</span>
00227 <span class="comment">// NOTE:    A hive on disk always contains at least two blocks of storage.</span>
00228 <span class="comment">//          1 block for the base block, and 1 for the minimum 1 bin.</span>
00229 <span class="comment">//</span>
00230 <span class="comment">// NOTE:    Only modified parts of the hive get written to disk.</span>
00231 <span class="comment">//          This is not just for efficiency, but also to avoid risk</span>
00232 <span class="comment">//          of destruction of unlogged data.  Dirty bits keep track</span>
00233 <span class="comment">//          of what has been modified, they reside in a simple</span>
00234 <span class="comment">//          bit map attached to the hive.  One bit for each logical</span>
00235 <span class="comment">//          sector of 512 bytes.</span>
00236 <span class="comment">//</span>
00237 <span class="comment">//          If the physical sector size of the machine is less than 512,</span>
00238 <span class="comment">//          no matter, we'll always write in clumps of 512.  If the</span>
00239 <span class="comment">//          physical sector size is greater than 512, we'll always clump</span>
00240 <span class="comment">//          data together so that we log and write data</span>
00241 <span class="comment">//          in chunks of that size.  Physical sector sizes &gt; 4K will</span>
00242 <span class="comment">//          not work correctly (logging will not work right, so system</span>
00243 <span class="comment">//          crashes may lose data that would not otherwise be lost.)</span>
00244 <span class="comment">//</span>
00245 
00246 
00247 <span class="comment">//</span>
00248 <span class="comment">// An on disk image of a hive looks like this:</span>
00249 <span class="comment">//</span>
00250 <span class="comment">//      +---------------------------------------+</span>
00251 <span class="comment">//      | HBASE_BLOCK                           | 1 Hive Block == 4K</span>
00252 <span class="comment">//      |                                       |</span>
00253 <span class="comment">//      +---------------------------------------+ &lt;- HBLOCK_SIZE boundary</span>
00254 <span class="comment">//      | Bin - 1 to N 4K blocks                |</span>
00255 <span class="comment">//      | Each contains a signature, size, and  |</span>
00256 <span class="comment">//      | a boundary tag heap internal to       |</span>
00257 <span class="comment">//      | itself.  Once allocated lives forever |</span>
00258 <span class="comment">//      | and always at same file offset.       |</span>
00259 <span class="comment">//      +---------------------------------------+ &lt;- HBLOCK_SIZE boundary</span>
00260 <span class="comment">//      | Bin ...                               |</span>
00261 <span class="comment">//      +---------------------------------------+ &lt;- HBLOCK_SIZE boundary</span>
00262 <span class="comment">//              ...</span>
00263 <span class="comment">//      +---------------------------------------+ &lt;- HBLOCK_SIZE boundary</span>
00264 <span class="comment">//      | Last allocated Bin, new bins are put  |</span>
00265 <span class="comment">//      | immediately after this one.           |</span>
00266 <span class="comment">//      +---------------------------------------+ &lt;- HBLOCK_SIZE boundary</span>
00267 <span class="comment">//</span>
00268 <span class="comment">//  Hive files must allocate on HBLOCK_SIZE boundaries because they</span>
00269 <span class="comment">//  might be written on many different systems, and must therefore be</span>
00270 <span class="comment">//  set up for the largest cluster size we will support.</span>
00271 <span class="comment">//</span>
00272 
00273 <span class="comment">//</span>
00274 <span class="comment">//  The log file format is:</span>
00275 <span class="comment">//</span>
00276 <span class="comment">//          +-------------------------------+</span>
00277 <span class="comment">//          | HBASE_BLOCK copy              |</span>
00278 <span class="comment">//          +-------------------------------+ &lt;- cluster (usually 512) bound</span>
00279 <span class="comment">//          | DirtyVector                   |</span>
00280 <span class="comment">//          | (length computed from length  |</span>
00281 <span class="comment">//          |  in the base block            |</span>
00282 <span class="comment">//          | (with "DIRT" on front as a    |</span>
00283 <span class="comment">//          |  signature)                   |</span>
00284 <span class="comment">//          +-------------------------------+ &lt;- cluster (usually 512) bound</span>
00285 <span class="comment">//          | Dirty Data                    |</span>
00286 <span class="comment">//          +-------------------------------+ &lt;- cluster (usually 512) bound</span>
00287 <span class="comment">//          | Dirty Data                    |</span>
00288 <span class="comment">//          +-------------------------------+ &lt;- cluster (usually 512) bound</span>
00289 <span class="comment">//          | ...                           |</span>
00290 <span class="comment">//          +-------------------------------+</span>
00291 <span class="comment">//</span>
00292 <span class="comment">//  Recovery consists of reading the file in, computing which clusters</span>
00293 <span class="comment">//  of data are present from the dirtyvector, and where they belong in</span>
00294 <span class="comment">//  the hive address space.  Position in file is by sequential count.</span>
00295 <span class="comment">//</span>
00296 <span class="comment">//  Logs can allocate on cluster boundaries (physical sector size of</span>
00297 <span class="comment">//  host machine) because they will never be written on any machine other</span>
00298 <span class="comment">//  than the one that created them.</span>
00299 <span class="comment">//</span>
00300 <span class="comment">//  For log to be valid:</span>
00301 <span class="comment">//</span>
00302 <span class="comment">//      Signature, format, major.minor must match expected values.</span>
00303 <span class="comment">//      Sequence1 and Sequence2 must match.</span>
00304 <span class="comment">//      CheckSum must be correct.</span>
00305 <span class="comment">//      Signture on DirtyVector must be correct</span>
00306 <span class="comment">//</span>
00307 <span class="comment">//  For log to be applicable:</span>
00308 <span class="comment">//</span>
00309 <span class="comment">//      Sequence in log must match sequence in hive.</span>
00310 <span class="comment">//      TimeStamp in log must match TimeStamp in hive.</span>
00311 <span class="comment">//      Hive must be in mid-update state, or have bogus header.</span>
00312 <span class="comment">//</span>
00313 
00314 <span class="comment">//</span>
00315 <span class="comment">// --- HBASE_BLOCK --- on disk description of the hive</span>
00316 <span class="comment">//</span>
00317 
00318 <span class="comment">//</span>
00319 <span class="comment">// NOTE:    HBASE_BLOCK must be &gt;= the size of physical sector,</span>
00320 <span class="comment">//          or integrity assumptions will be violated, and crash</span>
00321 <span class="comment">//          recovery may not work.</span>
00322 <span class="comment">//</span>
<a name="l00323"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a26">00323</a> <span class="preprocessor">#define HBASE_BLOCK_SIGNATURE   0x66676572  // "regf"</span>
00324 <span class="preprocessor"></span>
<a name="l00325"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a27">00325</a> <span class="preprocessor">#define HSYS_MAJOR          1               // Must match to read at all</span>
<a name="l00326"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a28">00326</a> <span class="preprocessor"></span><span class="preprocessor">#define HSYS_MINOR          3               // Must be &lt;= to write, always</span>
00327 <span class="preprocessor"></span>                                            <span class="comment">// set up to writer's version.</span>
00328 
<a name="l00329"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a29">00329</a> <span class="preprocessor">#define HBASE_FORMAT_MEMORY 1               // Direct memory load case</span>
00330 <span class="preprocessor"></span>
<a name="l00331"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a30">00331</a> <span class="preprocessor">#define HBASE_NAME_ALLOC    64              // 32 unicode chars</span>
00332 <span class="preprocessor"></span>
00333 <span class="preprocessor">#pragma pack(4)</span>
<a name="l00334"></a><a class="code" href="../../d6/d4/struct__HBASE__BLOCK.html">00334</a> <span class="preprocessor"></span><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d6/d4/struct__HBASE__BLOCK.html">_HBASE_BLOCK</a> {
<a name="l00335"></a><a class="code" href="../../d6/d4/struct__HBASE__BLOCK.html#o0">00335</a>     ULONG           <a class="code" href="../../d6/d4/struct__HBASE__BLOCK.html#o0">Signature</a>;
<a name="l00336"></a><a class="code" href="../../d6/d4/struct__HBASE__BLOCK.html#o1">00336</a>     ULONG           <a class="code" href="../../d6/d4/struct__HBASE__BLOCK.html#o1">Sequence1</a>;
<a name="l00337"></a><a class="code" href="../../d6/d4/struct__HBASE__BLOCK.html#o2">00337</a>     ULONG           <a class="code" href="../../d6/d4/struct__HBASE__BLOCK.html#o2">Sequence2</a>;
<a name="l00338"></a><a class="code" href="../../d6/d4/struct__HBASE__BLOCK.html#o3">00338</a>     LARGE_INTEGER   <a class="code" href="../../d6/d4/struct__HBASE__BLOCK.html#o3">TimeStamp</a>;
<a name="l00339"></a><a class="code" href="../../d6/d4/struct__HBASE__BLOCK.html#o4">00339</a>     ULONG           <a class="code" href="../../d6/d4/struct__HBASE__BLOCK.html#o4">Major</a>;
<a name="l00340"></a><a class="code" href="../../d6/d4/struct__HBASE__BLOCK.html#o5">00340</a>     ULONG           <a class="code" href="../../d6/d4/struct__HBASE__BLOCK.html#o5">Minor</a>;
<a name="l00341"></a><a class="code" href="../../d6/d4/struct__HBASE__BLOCK.html#o6">00341</a>     ULONG           <a class="code" href="../../d6/d4/struct__HBASE__BLOCK.html#o6">Type</a>;                   <span class="comment">// HFILE_TYPE_[PRIMARY|LOG]</span>
<a name="l00342"></a><a class="code" href="../../d6/d4/struct__HBASE__BLOCK.html#o7">00342</a>     ULONG           <a class="code" href="../../d6/d4/struct__HBASE__BLOCK.html#o7">Format</a>;
<a name="l00343"></a><a class="code" href="../../d6/d4/struct__HBASE__BLOCK.html#o8">00343</a>     <a class="code" href="../../d0/d1/hivedata_8h.html#a49">HCELL_INDEX</a>     <a class="code" href="../../d6/d4/struct__HBASE__BLOCK.html#o8">RootCell</a>;
<a name="l00344"></a><a class="code" href="../../d6/d4/struct__HBASE__BLOCK.html#o9">00344</a>     ULONG           <a class="code" href="../../d6/d4/struct__HBASE__BLOCK.html#o9">Length</a>;                 <span class="comment">// Includes all but header</span>
<a name="l00345"></a><a class="code" href="../../d6/d4/struct__HBASE__BLOCK.html#o10">00345</a>     ULONG           <a class="code" href="../../d6/d4/struct__HBASE__BLOCK.html#o10">Cluster</a>;                <span class="comment">// for logs only</span>
<a name="l00346"></a><a class="code" href="../../d6/d4/struct__HBASE__BLOCK.html#o11">00346</a>     UCHAR           <a class="code" href="../../d6/d4/struct__HBASE__BLOCK.html#o11">FileName</a>[<a class="code" href="../../d0/d1/hivedata_8h.html#a30">HBASE_NAME_ALLOC</a>];  <span class="comment">// filename tail</span>
<a name="l00347"></a><a class="code" href="../../d6/d4/struct__HBASE__BLOCK.html#o12">00347</a>     ULONG           <a class="code" href="../../d6/d4/struct__HBASE__BLOCK.html#o12">Reserved1</a>[99];
<a name="l00348"></a><a class="code" href="../../d6/d4/struct__HBASE__BLOCK.html#o13">00348</a>     ULONG           <a class="code" href="../../d6/d4/struct__HBASE__BLOCK.html#o13">CheckSum</a>;
<a name="l00349"></a><a class="code" href="../../d6/d4/struct__HBASE__BLOCK.html#o14">00349</a>     ULONG           <a class="code" href="../../d6/d4/struct__HBASE__BLOCK.html#o14">Reserved2</a>[128*7];
00350 } <a class="code" href="../../d6/d4/struct__HBASE__BLOCK.html">HBASE_BLOCK</a>, *<a class="code" href="../../d6/d4/struct__HBASE__BLOCK.html">PHBASE_BLOCK</a>;
00351 <span class="preprocessor">#pragma pack()</span>
00352 <span class="preprocessor"></span>
<a name="l00353"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a31">00353</a> <span class="preprocessor">#define HLOG_HEADER_SIZE  (FIELD_OFFSET(HBASE_BLOCK, Reserved2))</span>
<a name="l00354"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a32">00354</a> <span class="preprocessor"></span><span class="preprocessor">#define HLOG_DV_SIGNATURE   0x54524944      // "DIRT"</span>
00355 <span class="preprocessor"></span>
00356 <span class="comment">//</span>
00357 <span class="comment">// ===== In Memory Structures =====</span>
00358 <span class="comment">//</span>
00359 
00360 <span class="comment">//</span>
00361 <span class="comment">// In memory image of a Hive looks just like the on-disk image,</span>
00362 <span class="comment">// EXCEPT that the HBIN structures can be spread throughout memory</span>
00363 <span class="comment">// rather than packed together.</span>
00364 <span class="comment">//</span>
00365 <span class="comment">// To find an HCELL in memory, a mechanism that takes an HCELL_INDEX and</span>
00366 <span class="comment">// derives a memory address from it is used.  That mechanism is very</span>
00367 <span class="comment">// similar to a two level hardware paging table.</span>
00368 <span class="comment">//</span>
00369 <span class="comment">// A bit map is used to remember which parts of the hive are dirty.</span>
00370 <span class="comment">//</span>
00371 <span class="comment">// An HBLOCK can be in three different states</span>
00372 <span class="comment">//  1. Present in memory.  BlockAddress and BinAddress are valid pointers.</span>
00373 <span class="comment">//     This is the normal state of an HBLOCK.</span>
00374 <span class="comment">//</span>
00375 <span class="comment">//  2. Discardable.  The HBIN containing this HBLOCK is completely free, but</span>
00376 <span class="comment">//     the bin is dirty and needs to be written to the hive file before it</span>
00377 <span class="comment">//     can be free.  This is the state we will be in if somebody frees a</span>
00378 <span class="comment">//     cell, causing the entire HBIN to become free.  HvpEnlistFreeCell will</span>
00379 <span class="comment">//     transition all the HBLOCKs in the free HBIN to this state, but will</span>
00380 <span class="comment">//     not free their memory.  After the dirty HBLOCKs are flushed to the</span>
00381 <span class="comment">//     file, the memory will be freed.</span>
00382 <span class="comment">//</span>
00383 <span class="comment">//     Note that if we need to allocate more storage from an HBIN in this</span>
00384 <span class="comment">//     state, HvAllocateCell will simply change its state back to State 1</span>
00385 <span class="comment">//     and it will be usable.</span>
00386 <span class="comment">//</span>
00387 <span class="comment">//     An HBLOCK in this state has a valid BlockAddress and BinAddress, but</span>
00388 <span class="comment">//     the HMAP_DISCARDABLE bit will be set.</span>
00389 <span class="comment">//</span>
00390 <span class="comment">//  3. Discarded.  The HBIN containing this HBLOCK is completely free, and</span>
00391 <span class="comment">//     is not dirty (i.e. it is marked as free in the hive file as well).</span>
00392 <span class="comment">//     There is no memory allocated to contain this HBIN.  After HvSyncHive</span>
00393 <span class="comment">//     writes out an HBIN that is in State 2, it frees its pool and the</span>
00394 <span class="comment">//     HBIN moves into this state.</span>
00395 <span class="comment">//</span>
00396 <span class="comment">//     In order to use this HBIN, memory must be allocated to back it, and</span>
00397 <span class="comment">//     the HBIN and initial HCELL must be recreated.  (we could re-read it</span>
00398 <span class="comment">//     from the hive file, but there's not much point in that since we know</span>
00399 <span class="comment">//     that it is entirely free, so we might as well just recreate it and</span>
00400 <span class="comment">//     save the disk i/o)</span>
00401 <span class="comment">//</span>
00402 <span class="comment">//     An HBLOCK in this state has a NULL BlockAddress in the map.</span>
00403 <span class="comment">//     The BinAddress will contain the next HCELL in the free list, so</span>
00404 <span class="comment">//     we can reconstruct this when we need it.</span>
00405 <span class="comment">//     The HMAP_NEWALLOC bit will be set for the first HBLOCK in the HBIN.</span>
00406 <span class="comment">//</span>
00407 
00408 <span class="comment">//</span>
00409 <span class="comment">// --- HMAP_ENTRY --- Holds memory location of HCELL</span>
00410 <span class="comment">//</span>
<a name="l00411"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a33">00411</a> <span class="preprocessor">#define HMAP_FLAGS      (3)</span>
<a name="l00412"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a34">00412</a> <span class="preprocessor"></span><span class="preprocessor">#define HMAP_BASE       (~3)</span>
<a name="l00413"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a35">00413</a> <span class="preprocessor"></span><span class="preprocessor">#define HMAP_NEWALLOC   1</span>
<a name="l00414"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a36">00414</a> <span class="preprocessor"></span><span class="preprocessor">#define HMAP_DISCARDABLE 2</span>
00415 <span class="preprocessor"></span>
<a name="l00416"></a><a class="code" href="../../d2/d8/struct__HMAP__ENTRY.html">00416</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d2/d8/struct__HMAP__ENTRY.html">_HMAP_ENTRY</a> {
<a name="l00417"></a><a class="code" href="../../d2/d8/struct__HMAP__ENTRY.html#o0">00417</a>     ULONG_PTR    <a class="code" href="../../d2/d8/struct__HMAP__ENTRY.html#o0">BlockAddress</a>;       <span class="comment">// Low 2 bits always 0.  High bits</span>
00418                                     <span class="comment">// are memory address of HBLOCK that</span>
00419                                     <span class="comment">// HCELL starts in, add Offset to this.</span>
00420                                     <span class="comment">// (An HCELL can span several HBLOCKs)</span>
00421                                     <span class="comment">//</span>
00422 
<a name="l00423"></a><a class="code" href="../../d2/d8/struct__HMAP__ENTRY.html#o1">00423</a>     ULONG_PTR    <a class="code" href="../../d2/d8/struct__HMAP__ENTRY.html#o1">BinAddress</a>;         <span class="comment">// Low bit set TRUE to mark beginning</span>
00424                                     <span class="comment">// of a new allocation.</span>
00425                                     <span class="comment">// High bits are memory address of</span>
00426                                     <span class="comment">// first HBLOCK in same bin.</span>
00427                                     <span class="comment">// (A given HCELL is always contained</span>
00428                                     <span class="comment">//  in a single bin.)</span>
00429 } <a class="code" href="../../d2/d8/struct__HMAP__ENTRY.html">HMAP_ENTRY</a>, *<a class="code" href="../../d2/d8/struct__HMAP__ENTRY.html">PHMAP_ENTRY</a>;
00430 
00431 
00432 <span class="comment">//</span>
00433 <span class="comment">// --- HMAP_TABLE --- Array of MAP_ENTRYs that point to memory HBLOCKs</span>
00434 <span class="comment">//</span>
00435 <span class="comment">// Each HBLOCK worth of space in the Hive image has an entry in</span>
00436 <span class="comment">// an HMAP_TABLE.</span>
00437 <span class="comment">//</span>
<a name="l00438"></a><a class="code" href="../../d3/d8/struct__HMAP__TABLE.html">00438</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d3/d8/struct__HMAP__TABLE.html">_HMAP_TABLE</a> {
<a name="l00439"></a><a class="code" href="../../d3/d8/struct__HMAP__TABLE.html#o0">00439</a>     <a class="code" href="../../d2/d8/struct__HMAP__ENTRY.html">HMAP_ENTRY</a>  <a class="code" href="../../d3/d8/struct__HMAP__TABLE.html#o0">Table</a>[ <a class="code" href="../../d0/d1/hivedata_8h.html#a17">HTABLE_SLOTS</a> ];
00440 } <a class="code" href="../../d3/d8/struct__HMAP__TABLE.html">HMAP_TABLE</a>, *<a class="code" href="../../d3/d8/struct__HMAP__TABLE.html">PHMAP_TABLE</a>;
00441 
00442 
00443 <span class="comment">//</span>
00444 <span class="comment">// --- HMAP_DIRECTORY --- Array of pointers to HMAP_TABLEs</span>
00445 <span class="comment">//</span>
<a name="l00446"></a><a class="code" href="../../d1/d8/struct__HMAP__DIRECTORY.html">00446</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d1/d8/struct__HMAP__DIRECTORY.html">_HMAP_DIRECTORY</a> {
<a name="l00447"></a><a class="code" href="../../d1/d8/struct__HMAP__DIRECTORY.html#o0">00447</a>     <a class="code" href="../../d0/d1/hivedata_8h.html#a60">PHMAP_TABLE</a> <a class="code" href="../../d1/d8/struct__HMAP__DIRECTORY.html#o0">Directory</a>[  <a class="code" href="../../d0/d1/hivedata_8h.html#a18">HDIRECTORY_SLOTS</a> ];
00448 } <a class="code" href="../../d1/d8/struct__HMAP__DIRECTORY.html">HMAP_DIRECTORY</a>, *<a class="code" href="../../d1/d8/struct__HMAP__DIRECTORY.html">PHMAP_DIRECTORY</a>;
00449 
00450 
00451 <span class="comment">//</span>
00452 <span class="comment">// ===== Hive Routines typedefs =====</span>
00453 <span class="comment">//</span>
00454 <span class="keyword">struct </span><a class="code" href="../../d7/d7/struct__HHIVE.html">_HHIVE</a>; <span class="comment">// forward</span>
00455 
00456 <span class="keyword">typedef</span>
00457 PVOID
<a name="l00458"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a63">00458</a> (*PALLOCATE_ROUTINE) (
00459     ULONG       Length,             <span class="comment">// Size of new block wanted</span>
00460     BOOLEAN     UseForIo            <span class="comment">// TRUE if yes, FALSE if no</span>
00461     );
00462 
00463 <span class="keyword">typedef</span>
00464 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00465"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a64">00465</a> (*PFREE_ROUTINE) (
00466     PVOID       MemoryBlock,
00467     ULONG       GlobalQuotaSize
00468     );
00469 
00470 <span class="keyword">typedef</span>
00471 BOOLEAN
<a name="l00472"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a65">00472</a> (*PFILE_SET_SIZE_ROUTINE) (
00473     <span class="keyword">struct </span><a class="code" href="../../d7/d7/struct__HHIVE.html">_HHIVE</a>  *<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>,
00474     ULONG          FileType,
00475     ULONG          FileSize
00476     );
00477 
<a name="l00478"></a><a class="code" href="../../d5/d4/structCMP__OFFSET__ARRAY.html">00478</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00479"></a><a class="code" href="../../d5/d4/structCMP__OFFSET__ARRAY.html#o0">00479</a>     ULONG  FileOffset;
<a name="l00480"></a><a class="code" href="../../d5/d4/structCMP__OFFSET__ARRAY.html#o1">00480</a>     PVOID  DataBuffer;
<a name="l00481"></a><a class="code" href="../../d5/d4/structCMP__OFFSET__ARRAY.html#o2">00481</a>     ULONG  DataLength;
00482 } <a class="code" href="../../d5/d4/structCMP__OFFSET__ARRAY.html">CMP_OFFSET_ARRAY</a>, * <a class="code" href="../../d0/d1/hivedata_8h.html#a66">PCMP_OFFSET_ARRAY</a>;
00483 
00484 <span class="keyword">typedef</span>
00485 BOOLEAN
<a name="l00486"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a67">00486</a> (*PFILE_WRITE_ROUTINE) (
00487     <span class="keyword">struct </span><a class="code" href="../../d7/d7/struct__HHIVE.html">_HHIVE</a>  *<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>,
00488     ULONG       FileType,
00489     <a class="code" href="../../d0/d1/hivedata_8h.html#a66">PCMP_OFFSET_ARRAY</a> offsetArray,
00490     ULONG offsetArrayCount,
00491     PULONG FileOffset
00492     );
00493 
00494 <span class="keyword">typedef</span>
00495 BOOLEAN
<a name="l00496"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a68">00496</a> (*PFILE_READ_ROUTINE) (
00497     <span class="keyword">struct </span><a class="code" href="../../d7/d7/struct__HHIVE.html">_HHIVE</a>  *<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>,
00498     ULONG       FileType,
00499     PULONG      FileOffset,
00500     PVOID       DataBuffer,
00501     ULONG       DataLength
00502     );
00503 
00504 <span class="keyword">typedef</span>
00505 BOOLEAN
<a name="l00506"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a69">00506</a> (*PFILE_FLUSH_ROUTINE) (
00507     <span class="keyword">struct </span><a class="code" href="../../d7/d7/struct__HHIVE.html">_HHIVE</a>  *<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>,
00508     ULONG           FileType
00509     );
00510 
00511 <span class="keyword">typedef</span>
00512 <span class="keyword">struct </span><a class="code" href="../../d4/d9/struct__CELL__DATA.html">_CELL_DATA</a> *
<a name="l00513"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a70">00513</a> (*PGET_CELL_ROUTINE)(
00514     <span class="keyword">struct </span><a class="code" href="../../d7/d7/struct__HHIVE.html">_HHIVE</a>   *<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>,
00515     <a class="code" href="../../d0/d1/hivedata_8h.html#a49">HCELL_INDEX</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a>
00516     );
00517 
00518 <span class="comment">//</span>
00519 <span class="comment">// --- HHIVE --- In memory descriptor for a hive.</span>
00520 <span class="comment">//</span>
00521 
00522 <span class="comment">//</span>
00523 <span class="comment">// HHIVE contains pointers to service procedures, and pointers to</span>
00524 <span class="comment">// map structure.</span>
00525 <span class="comment">//</span>
00526 <span class="comment">// NOTE:    Optimization - If the size of a hive is less than what can</span>
00527 <span class="comment">//          be mapped with a single HMAP_TABLE (HTABLE_SLOTS * HBLOCK_SIZE,</span>
00528 <span class="comment">//          or 2 megabytes) there is no real HMAP_DIRECTORY.  Instead,</span>
00529 <span class="comment">//          a single DWORD in the HHIVE acts as the 0th entry of the</span>
00530 <span class="comment">//          directory.</span>
00531 <span class="comment">//</span>
00532 <span class="comment">// NOTE:    Free Storage Management - When a hive is loaded, we build up</span>
00533 <span class="comment">//          a display (vector) of lists of free cells.  The first part</span>
00534 <span class="comment">//          of this vector contains lists that only hold one size cell.</span>
00535 <span class="comment">//          The size of cell on the list is HCELL_PAD * (ListIndex+1)</span>
00536 <span class="comment">//          There are 15 of these lists, so all free cells between 8 and</span>
00537 <span class="comment">//          120 bytes are on these lists.</span>
00538 <span class="comment">//</span>
00539 <span class="comment">//          The second part of this vector contains lists that hold more</span>
00540 <span class="comment">//          than one size cell.  Each size bucket is twice the previous</span>
00541 <span class="comment">//          size.  There are 8 of these lists, so all free cells between 136 and</span>
00542 <span class="comment">//          32768 bytes are on these lists.</span>
00543 <span class="comment">//</span>
00544 <span class="comment">//          The last list in this vector contains all cells too large to</span>
00545 <span class="comment">//          fit in any previous list.</span>
00546 <span class="comment">//</span>
00547 <span class="comment">//          Example:    All free cells of size 1 HCELL_PAD (8 bytes)</span>
00548 <span class="comment">//                      are on the list at offset 0 in FreeDisplay.</span>
00549 <span class="comment">//</span>
00550 <span class="comment">//                      All free cells of size 15 HCELL_PAD (120 bytes)</span>
00551 <span class="comment">//                      are on the list at offset 0xe.</span>
00552 <span class="comment">//</span>
00553 <span class="comment">//                      All free cells of size 16-31 HCELL_PAD (128-248 bytes)</span>
00554 <span class="comment">//                      are on the list at offset 0xf</span>
00555 <span class="comment">//</span>
00556 <span class="comment">//                      All free cells of size 32-63 HCELL_PAD (256-506 bytes)</span>
00557 <span class="comment">//                      are on the list at offset 0x10.</span>
00558 <span class="comment">//</span>
00559 <span class="comment">//                      All free cells of size 2048 HCELL_PAD (16384 bytes)</span>
00560 <span class="comment">//                      OR greater, are on the list at offset 0x17.</span>
00561 <span class="comment">//</span>
00562 <span class="comment">//          FreeSummary is a bit vector, with a bit set to true for each</span>
00563 <span class="comment">//          entry in FreeDisplay that is not empty.</span>
00564 <span class="comment">//</span>
00565 
<a name="l00566"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a37">00566</a> <span class="preprocessor">#define HHIVE_SIGNATURE 0xBEE0BEE0</span>
00567 <span class="preprocessor"></span>
<a name="l00568"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a38">00568</a> <span class="preprocessor">#define HFILE_TYPE_PRIMARY      0   // Base hive file</span>
<a name="l00569"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a39">00569</a> <span class="preprocessor"></span><span class="preprocessor">#define HFILE_TYPE_ALTERNATE    1   // Alternate (e.g. system.alt)</span>
<a name="l00570"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a40">00570</a> <span class="preprocessor"></span><span class="preprocessor">#define HFILE_TYPE_LOG          2   // Log (security.log)</span>
<a name="l00571"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a41">00571</a> <span class="preprocessor"></span><span class="preprocessor">#define HFILE_TYPE_EXTERNAL     3   // Target of savekey, etc.</span>
<a name="l00572"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a42">00572</a> <span class="preprocessor"></span><span class="preprocessor">#define HFILE_TYPE_MAX          4</span>
00573 <span class="preprocessor"></span>
<a name="l00574"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a43">00574</a> <span class="preprocessor">#define HHIVE_LINEAR_INDEX      16  // All computed linear indices &lt; HHIVE_LINEAR_INDEX are valid</span>
<a name="l00575"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a44">00575</a> <span class="preprocessor"></span><span class="preprocessor">#define HHIVE_EXPONENTIAL_INDEX 23  // All computed exponential indices &lt; HHIVE_EXPONENTIAL_INDEX</span>
00576 <span class="preprocessor"></span>                                    <span class="comment">// and &gt;= HHIVE_LINEAR_INDEX are valid.</span>
<a name="l00577"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a45">00577</a> <span class="preprocessor">#define HHIVE_FREE_DISPLAY_SIZE 24</span>
00578 <span class="preprocessor"></span>
<a name="l00579"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a46">00579</a> <span class="preprocessor">#define HHIVE_FREE_DISPLAY_SHIFT 3  // This must be log2 of HCELL_PAD!</span>
<a name="l00580"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a47">00580</a> <span class="preprocessor"></span><span class="preprocessor">#define HHIVE_FREE_DISPLAY_BIAS  7  // Add to first set bit left of cell size to get exponential index</span>
00581 <span class="preprocessor"></span>
00582 
<a name="l00583"></a><a class="code" href="../../d0/d1/hivedata_8h.html#a48">00583</a> <span class="preprocessor">#define FREE_HBIN_DISCARDABLE 1</span>
00584 <span class="preprocessor"></span>
<a name="l00585"></a><a class="code" href="../../d6/d0/struct__FREE__HBIN.html">00585</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d6/d0/struct__FREE__HBIN.html">_FREE_HBIN</a> {
<a name="l00586"></a><a class="code" href="../../d6/d0/struct__FREE__HBIN.html#o0">00586</a>     LIST_ENTRY  <a class="code" href="../../d6/d0/struct__FREE__HBIN.html#o0">ListEntry</a>;
<a name="l00587"></a><a class="code" href="../../d6/d0/struct__FREE__HBIN.html#o1">00587</a>     ULONG       <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
<a name="l00588"></a><a class="code" href="../../d6/d0/struct__FREE__HBIN.html#o2">00588</a>     ULONG       FileOffset;
<a name="l00589"></a><a class="code" href="../../d6/d0/struct__FREE__HBIN.html#o3">00589</a>     ULONG       <a class="code" href="../../d6/d0/struct__FREE__HBIN.html#o3">Flags</a>;
00590 } <a class="code" href="../../d6/d0/struct__FREE__HBIN.html">FREE_HBIN</a>, *<a class="code" href="../../d6/d0/struct__FREE__HBIN.html">PFREE_HBIN</a>;
00591 
<a name="l00592"></a><a class="code" href="../../d7/d7/struct__HHIVE.html">00592</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d7/d7/struct__HHIVE.html">_HHIVE</a> {
<a name="l00593"></a><a class="code" href="../../d7/d7/struct__HHIVE.html#o0">00593</a>     ULONG                   <a class="code" href="../../d7/d7/struct__HHIVE.html#o0">Signature</a>;
00594 
<a name="l00595"></a><a class="code" href="../../d7/d7/struct__HHIVE.html#o1">00595</a>     <a class="code" href="../../d0/d1/hivedata_8h.html#a70">PGET_CELL_ROUTINE</a>       <a class="code" href="../../d7/d7/struct__HHIVE.html#o1">GetCellRoutine</a>;
00596 
<a name="l00597"></a><a class="code" href="../../d7/d7/struct__HHIVE.html#o2">00597</a>     <a class="code" href="../../d0/d1/hivedata_8h.html#a63">PALLOCATE_ROUTINE</a>       <a class="code" href="../../d7/d7/struct__HHIVE.html#o2">Allocate</a>;
<a name="l00598"></a><a class="code" href="../../d7/d7/struct__HHIVE.html#o3">00598</a>     <a class="code" href="../../d0/d1/hivedata_8h.html#a64">PFREE_ROUTINE</a>           <a class="code" href="../../d7/d7/struct__HHIVE.html#o3">Free</a>;
00599 
<a name="l00600"></a><a class="code" href="../../d7/d7/struct__HHIVE.html#o4">00600</a>     <a class="code" href="../../d0/d1/hivedata_8h.html#a65">PFILE_SET_SIZE_ROUTINE</a>  <a class="code" href="../../d7/d7/struct__HHIVE.html#o4">FileSetSize</a>;
<a name="l00601"></a><a class="code" href="../../d7/d7/struct__HHIVE.html#o5">00601</a>     <a class="code" href="../../d0/d1/hivedata_8h.html#a67">PFILE_WRITE_ROUTINE</a>     <a class="code" href="../../d7/d7/struct__HHIVE.html#o5">FileWrite</a>;
<a name="l00602"></a><a class="code" href="../../d7/d7/struct__HHIVE.html#o6">00602</a>     <a class="code" href="../../d0/d1/hivedata_8h.html#a68">PFILE_READ_ROUTINE</a>      <a class="code" href="../../d7/d7/struct__HHIVE.html#o6">FileRead</a>;
<a name="l00603"></a><a class="code" href="../../d7/d7/struct__HHIVE.html#o7">00603</a>     <a class="code" href="../../d0/d1/hivedata_8h.html#a69">PFILE_FLUSH_ROUTINE</a>     <a class="code" href="../../d7/d7/struct__HHIVE.html#o7">FileFlush</a>;
00604 
<a name="l00605"></a><a class="code" href="../../d7/d7/struct__HHIVE.html#o8">00605</a>     <span class="keyword">struct </span><a class="code" href="../../d6/d4/struct__HBASE__BLOCK.html">_HBASE_BLOCK</a>     *<a class="code" href="../../d7/d7/struct__HHIVE.html#o8">BaseBlock</a>;
00606 
<a name="l00607"></a><a class="code" href="../../d7/d7/struct__HHIVE.html#o9">00607</a>     RTL_BITMAP              <a class="code" href="../../d7/d7/struct__HHIVE.html#o9">DirtyVector</a>;    <span class="comment">// only for Stable bins</span>
<a name="l00608"></a><a class="code" href="../../d7/d7/struct__HHIVE.html#o10">00608</a>     ULONG                   <a class="code" href="../../d7/d7/struct__HHIVE.html#o10">DirtyCount</a>;
<a name="l00609"></a><a class="code" href="../../d7/d7/struct__HHIVE.html#o11">00609</a>     ULONG                   <a class="code" href="../../d7/d7/struct__HHIVE.html#o11">DirtyAlloc</a>;     <span class="comment">// allocated bytges for dirty vect</span>
<a name="l00610"></a><a class="code" href="../../d7/d7/struct__HHIVE.html#o12">00610</a>     ULONG                   <a class="code" href="../../d7/d7/struct__HHIVE.html#o12">Cluster</a>;        <span class="comment">// Usually 1 512 byte sector.</span>
00611                                             <span class="comment">// Set up force writes to be</span>
00612                                             <span class="comment">// done in larger units on</span>
00613                                             <span class="comment">// machines with larger sectors.</span>
00614                                             <span class="comment">// Is number of logical 512 sectors.</span>
00615 
<a name="l00616"></a><a class="code" href="../../d7/d7/struct__HHIVE.html#o13">00616</a>     BOOLEAN                 <a class="code" href="../../d7/d7/struct__HHIVE.html#o13">Flat</a>;               <span class="comment">// TRUE if FLAT</span>
<a name="l00617"></a><a class="code" href="../../d7/d7/struct__HHIVE.html#o14">00617</a>     BOOLEAN                 <a class="code" href="../../d7/d7/struct__HHIVE.html#o14">ReadOnly</a>;           <span class="comment">// TRUE if READONLY</span>
00618 
<a name="l00619"></a><a class="code" href="../../d7/d7/struct__HHIVE.html#o15">00619</a>     BOOLEAN                 <a class="code" href="../../d7/d7/struct__HHIVE.html#o15">Log</a>;
<a name="l00620"></a><a class="code" href="../../d7/d7/struct__HHIVE.html#o16">00620</a>     BOOLEAN                 <a class="code" href="../../d7/d7/struct__HHIVE.html#o16">Alternate</a>;
00621 
<a name="l00622"></a><a class="code" href="../../d7/d7/struct__HHIVE.html#o17">00622</a>     ULONG                   <a class="code" href="../../d7/d7/struct__HHIVE.html#o17">HiveFlags</a>;
00623 
<a name="l00624"></a><a class="code" href="../../d7/d7/struct__HHIVE.html#o18">00624</a>     ULONG                   <a class="code" href="../../d7/d7/struct__HHIVE.html#o18">LogSize</a>;
00625 
<a name="l00626"></a><a class="code" href="../../d7/d7/struct__HHIVE.html#o19">00626</a>     ULONG                   <a class="code" href="../../d7/d7/struct__HHIVE.html#o19">RefreshCount</a>;       <span class="comment">// debugging aid</span>
00627 
00628 
<a name="l00629"></a><a class="code" href="../../d7/d7/struct__HHIVE.html#o20">00629</a>     ULONG                   <a class="code" href="../../d7/d7/struct__HHIVE.html#o20">StorageTypeCount</a>;   <span class="comment">// 1 &gt; Number of largest valid</span>
00630                                                 <span class="comment">// type. (1 for Stable only,</span>
00631                                                 <span class="comment">// 2 for stable &amp; volatile)</span>
00632 
<a name="l00633"></a><a class="code" href="../../d7/d7/struct__HHIVE.html#o21">00633</a>     ULONG                   <a class="code" href="../../d7/d7/struct__HHIVE.html#o21">Version</a>;            <span class="comment">// hive version, to allow supporting multiple</span>
00634                                                 <span class="comment">// formats simultaneously.</span>
00635 
<a name="l00636"></a><a class="code" href="../../d8/d7/struct__HHIVE_1_1__DUAL.html">00636</a>     <span class="keyword">struct </span><a class="code" href="../../d8/d7/struct__HHIVE_1_1__DUAL.html">_DUAL</a> {
<a name="l00637"></a><a class="code" href="../../d8/d7/struct__HHIVE_1_1__DUAL.html#o0">00637</a>         ULONG               Length;
<a name="l00638"></a><a class="code" href="../../d8/d7/struct__HHIVE_1_1__DUAL.html#o1">00638</a>         <a class="code" href="../../d0/d1/hivedata_8h.html#a62">PHMAP_DIRECTORY</a>     <a class="code" href="../../d8/d7/struct__HHIVE_1_1__DUAL.html#o1">Map</a>;
<a name="l00639"></a><a class="code" href="../../d8/d7/struct__HHIVE_1_1__DUAL.html#o2">00639</a>         <a class="code" href="../../d0/d1/hivedata_8h.html#a60">PHMAP_TABLE</a>         <a class="code" href="../../d8/d7/struct__HHIVE_1_1__DUAL.html#o2">SmallDir</a>;
<a name="l00640"></a><a class="code" href="../../d8/d7/struct__HHIVE_1_1__DUAL.html#o3">00640</a>         ULONG               <a class="code" href="../../d8/d7/struct__HHIVE_1_1__DUAL.html#o3">Guard</a>;          <span class="comment">// Always == -1</span>
00641 
<a name="l00642"></a><a class="code" href="../../d8/d7/struct__HHIVE_1_1__DUAL.html#o4">00642</a>         <a class="code" href="../../d0/d1/hivedata_8h.html#a49">HCELL_INDEX</a>         <a class="code" href="../../d8/d7/struct__HHIVE_1_1__DUAL.html#o4">FreeDisplay</a>[<a class="code" href="../../d0/d1/hivedata_8h.html#a45">HHIVE_FREE_DISPLAY_SIZE</a>];
<a name="l00643"></a><a class="code" href="../../d8/d7/struct__HHIVE_1_1__DUAL.html#o5">00643</a>         ULONG               <a class="code" href="../../d8/d7/struct__HHIVE_1_1__DUAL.html#o5">FreeSummary</a>;
<a name="l00644"></a><a class="code" href="../../d8/d7/struct__HHIVE_1_1__DUAL.html#o6">00644</a>         LIST_ENTRY          <a class="code" href="../../d8/d7/struct__HHIVE_1_1__DUAL.html#o6">FreeBins</a>;           <span class="comment">// list of freed HBINs (FREE_HBIN)</span>
00645 
00646     }                       Storage[ <a class="code" href="../../d7/d7/struct__HHIVE.html#o22">HTYPE_COUNT</a> ];
00647 
00648     <span class="comment">//</span>
00649     <span class="comment">// Caller defined data goes here</span>
00650     <span class="comment">//</span>
00651 
00652 } <a class="code" href="../../d7/d7/struct__HHIVE.html">HHIVE</a>, *<a class="code" href="../../d7/d7/struct__HHIVE.html">PHHIVE</a>;
00653 
00654 
00655 <span class="preprocessor">#endif // __HIVE_DATA__</span>
00656 <span class="preprocessor"></span>
00657 
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:40:17 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
