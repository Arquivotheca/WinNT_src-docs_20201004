<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: vunwind.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>vunwind.c</h1><a href="../../d0/d7/ppc_2vunwind_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1993  IBM Corporation and Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    vunwind.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module contains the instruction classifying and virtual</span>
00012 <span class="comment">    unwinding routines for structured exception handling on PowerPC.</span>
00013 <span class="comment"></span>
00014 <span class="comment">    Virtual Unwind was moved to this file from exdsptch.c so that it</span>
00015 <span class="comment">    can be used directly in the kernel debugger.</span>
00016 <span class="comment"></span>
00017 <span class="comment">    WARNING!</span>
00018 <span class="comment"></span>
00019 <span class="comment">    The kernel debugger and windbg need to be modified if the number</span>
00020 <span class="comment">    and type of parameters for READ_ULONG and READ_DOUBLE are</span>
00021 <span class="comment">    modified.</span>
00022 <span class="comment"></span>
00023 <span class="comment">    Use CAUTION if you add include statements</span>
00024 <span class="comment"></span>
00025 <span class="comment">Author:</span>
00026 <span class="comment"></span>
00027 <span class="comment">    Rick Simpson  16-Aug-1993</span>
00028 <span class="comment"></span>
00029 <span class="comment">    based on MIPS version by David N. Cutler (davec) 11-Sep-1990</span>
00030 <span class="comment"></span>
00031 <span class="comment">Environment:</span>
00032 <span class="comment"></span>
00033 <span class="comment">    Any mode.</span>
00034 <span class="comment"></span>
00035 <span class="comment">Revision History:</span>
00036 <span class="comment"></span>
00037 <span class="comment">    Tom Wood (twood) 1-Nov-1993</span>
00038 <span class="comment">    Add back changes to RtlVirtualUnwind made when the MIPS version</span>
00039 <span class="comment">    was ported.</span>
00040 <span class="comment"></span>
00041 <span class="comment">    Tom Wood (twood) 1-Feb-1994</span>
00042 <span class="comment">    Change to using a function table entry for register save/restore</span>
00043 <span class="comment">    millicode.  Add forward execution of register restore millicode.</span>
00044 <span class="comment">    Add the ITERATOR abstraction.</span>
00045 <span class="comment"></span>
00046 <span class="comment">    Peter Johnston (plj@vnet.ibm.com) 14-Feb-1994</span>
00047 <span class="comment">    Added InstrGetOut classification to allow a simulated return from</span>
00048 <span class="comment">    dummy prologues such as those in system exception handling.</span>
00049 <span class="comment"></span>
00050 <span class="comment">    Tom Wood (twood) 28-Feb-1994</span>
00051 <span class="comment">    Added the WINDBG interface.</span>
00052 <span class="comment"></span>
00053 <span class="comment">    Tom Wood (twood) 8-Jun-1994</span>
00054 <span class="comment">    Added the _IMAGEHLP_SOURCE_ interface.</span>
00055 <span class="comment"></span>
00056 <span class="comment">    Tom Wood (twood) 8-Jun-1994</span>
00057 <span class="comment">    Removed the WINDBG interface.  Updated the _IMAGEHLP_SOURCE_</span>
00058 <span class="comment">    interface to deal with the fact that ExceptionHandler and HandlerData</span>
00059 <span class="comment">    cannot be relied upon.  Also, the FunctionEntry value may be a static</span>
00060 <span class="comment">    buffer returned by RtlLookupFunctionEntry (i.e. FunctionTableAccess).</span>
00061 <span class="comment">    The copy of vunwind.c in ntos/rtl/ppc is older and should be replaced</span>
00062 <span class="comment">    with this version.</span>
00063 <span class="comment"></span>
00064 <span class="comment">    Tom Wood (twood) 9-Aug-1994</span>
00065 <span class="comment">    Added support for the new glue code sequences.  Added InstrGlue and</span>
00066 <span class="comment">    InstrTocRestore.  The former replaces InstrGetOut.  RtlVirtualUnwind</span>
00067 <span class="comment">    is now required to be called when there is no function table entry.</span>
00068 <span class="comment"></span>
00069 <span class="comment"> --*/</span>
00070 
<a name="l00071"></a><a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a7">00071</a> <span class="keyword">typedef</span> DOUBLE *<a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a7">PDOUBLE</a>;
00072 
00073 <span class="preprocessor">#ifdef ROS_DEBUG</span>
00074 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="../../d5/d9/ntrtlp_8h.html">ntrtlp.h</a>"</span>
00075 <span class="preprocessor">#define READ_ULONG(addr,dest) dest = (*((PULONG)(addr)))</span>
00076 <span class="preprocessor"></span><span class="preprocessor">#define READ_DOUBLE(addr,dest) dest = (*((PDOUBLE)(addr)))</span>
00077 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00078 <span class="preprocessor"></span>
00079 <span class="preprocessor">#ifdef _IMAGEHLP_SOURCE_</span>
00080 <span class="preprocessor"></span><span class="preprocessor">#define FUNCTION_ENTRY_IS_IMAGE_STYLE</span>
00081 <span class="preprocessor"></span><span class="preprocessor">#define NOT_IMAGEHLP(E)</span>
00082 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00083"></a><a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a0">00083</a> <span class="preprocessor"></span><span class="preprocessor">#define NOT_IMAGEHLP(E) E</span>
00084 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00085 <span class="preprocessor"></span>
00086 <span class="preprocessor">#ifdef KERNEL_DEBUGGER</span>
00087 <span class="preprocessor"></span><span class="preprocessor">#define FUNCTION_ENTRY_IS_IMAGE_STYLE</span>
00088 <span class="preprocessor"></span><span class="preprocessor">#define RtlVirtualUnwind VirtualUnwind</span>
00089 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00090 <span class="preprocessor"></span>
00091 <span class="comment">//</span>
00092 <span class="comment">// The `ClassifyInstruction' function returns an enum that identifies</span>
00093 <span class="comment">// the type of processing needed for an instruction.</span>
00094 <span class="comment">//</span>
00095 
<a name="l00096"></a><a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39">00096</a> <span class="keyword">typedef</span> <span class="keyword">enum</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39">_INSTR_CLASS</a> {
00097     <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a14">InstrIgnore</a>,        <span class="comment">// Do not process</span>
00098     <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a15">InstrMFLR</a>,          <span class="comment">// Move from Link Register</span>
00099     <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a16">InstrMFCR</a>,          <span class="comment">// Move from Condition Register</span>
00100     <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a17">InstrSTW</a>,           <span class="comment">// Store word</span>
00101     <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a18">InstrSTWU</a>,          <span class="comment">// Store word with update</span>
00102     <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a19">InstrSTWUr12</a>,       <span class="comment">// Store word with update during UnwindR12</span>
00103     <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a20">InstrSTFD</a>,          <span class="comment">// Store float double</span>
00104     <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a21">InstrMR</a>,            <span class="comment">// Move register</span>
00105     <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a22">InstrMRr12</a>,         <span class="comment">// Move register during UnwindR12</span>
00106     <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a23">InstrMRfwd</a>,         <span class="comment">// Move register during UnwindForward</span>
00107     <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a24">InstrADDIr12</a>,       <span class="comment">// Add immediate during UnwindR12</span>
00108     <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a25">InstrADDIfwd</a>,       <span class="comment">// Add immediate during UnwindForward</span>
00109     <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a26">InstrSaveCode</a>,      <span class="comment">// Branch and link to GPR or FPR saving millicode</span>
00110     <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a27">InstrRestoreCode</a>,   <span class="comment">// Branch to GPR or FPR saving millicode</span>
00111     <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a28">InstrGlue</a>,          <span class="comment">// Branch or Branch and link to glue code</span>
00112     <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a29">InstrBLR</a>,           <span class="comment">// Branch to Link Register</span>
00113     <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a30">InstrTOCRestore</a>,    <span class="comment">// Load that restores the TOC [after a call to glue]</span>
00114     <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a31">InstrSetEstablisher</a> <span class="comment">// Special instruction used to set establisher frame</span>
00115 } <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a8">INSTR_CLASS</a>;
00116 
00117 <span class="comment">//</span>
00118 <span class="comment">// If `ClassifyInstruction' returns `InstrSaveCode' or `InstrRestoreCode',</span>
00119 <span class="comment">// the following information is completed.</span>
00120 <span class="comment">//</span>
00121 
<a name="l00122"></a><a class="code" href="../../d6/d9/struct__MILLICODE__INFO.html">00122</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d6/d9/struct__MILLICODE__INFO.html">_MILLICODE_INFO</a> {
<a name="l00123"></a><a class="code" href="../../d6/d9/struct__MILLICODE__INFO.html#o0">00123</a>     ULONG  <a class="code" href="../../d6/d9/struct__MILLICODE__INFO.html#o0">TargetPc</a>;    <span class="comment">// Millicode entry point</span>
<a name="l00124"></a><a class="code" href="../../d6/d9/struct__MILLICODE__INFO.html#o1">00124</a>     PRUNTIME_FUNCTION <a class="code" href="../../d6/d9/struct__MILLICODE__INFO.html#o1">FunctionEntry</a>; <span class="comment">// Millicode function table entry</span>
00125 } <a class="code" href="../../d6/d9/struct__MILLICODE__INFO.html">MILLICODE_INFO</a>, *<a class="code" href="../../d6/d9/struct__MILLICODE__INFO.html">PMILLICODE_INFO</a>;
00126 
00127 <span class="comment">//</span>
00128 <span class="comment">// `ClassifyInstruction' interprets the instruction based on the intent.</span>
00129 <span class="comment">//</span>
00130 
<a name="l00131"></a><a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a40">00131</a> <span class="keyword">typedef</span> <span class="keyword">enum</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a40">_UNWIND_INTENT</a> {
00132     <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a40a32">UnwindForward</a>,      <span class="comment">// Performing a forward execution</span>
00133     <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a40a33">UnwindR12</a>,          <span class="comment">// Performing a reverse execution to get r.12</span>
00134     <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a40a34">UnwindReverse</a>,      <span class="comment">// Performing a reverse execution</span>
00135     <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a40a35">UnwindReverseR12</a>    <span class="comment">// Performing a reverse execution allowing r.12</span>
00136 } <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a11">UNWIND_INTENT</a>;
00137 
00138 <span class="comment">//</span>
00139 <span class="comment">// The simulated execution by `RtlVirtualUnwind' is controlled by this</span>
00140 <span class="comment">// data type.</span>
00141 <span class="comment">//</span>
00142 
<a name="l00143"></a><a class="code" href="../../d6/d4/struct__ITERATOR.html">00143</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d6/d4/struct__ITERATOR.html">_ITERATOR</a> {
<a name="l00144"></a><a class="code" href="../../d6/d4/struct__ITERATOR.html#o0">00144</a>     ULONG <a class="code" href="../../d6/d4/struct__ITERATOR.html#o0">BeginPc</a>;      <span class="comment">// Address of first instruction to simulate</span>
<a name="l00145"></a><a class="code" href="../../d6/d4/struct__ITERATOR.html#o1">00145</a>     ULONG <a class="code" href="../../d6/d4/struct__ITERATOR.html#o1">EndPc</a>;        <span class="comment">// Address after the last instruction to simulate</span>
<a name="l00146"></a><a class="code" href="../../d6/d4/struct__ITERATOR.html#o2">00146</a>     LONG  <a class="code" href="../../d6/d4/struct__ITERATOR.html#o2">Increment</a>;    <span class="comment">// Simulation direction</span>
<a name="l00147"></a><a class="code" href="../../d6/d4/struct__ITERATOR.html#o3">00147</a>     <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a11">UNWIND_INTENT</a> <a class="code" href="../../d6/d4/struct__ITERATOR.html#o3">Intent</a>; <span class="comment">// Simulation intent</span>
00148 } <a class="code" href="../../d6/d4/struct__ITERATOR.html">ITERATOR</a>, *<a class="code" href="../../d6/d4/struct__ITERATOR.html">PITERATOR</a>;
00149 
<a name="l00150"></a><a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a1">00150</a> <span class="preprocessor">#define GPR1     1      // GPR 1 in an RA, RB, RT, etc. field</span>
<a name="l00151"></a><a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a2">00151</a> <span class="preprocessor"></span><span class="preprocessor">#define GPR2     2      // GPR 2 in an RA, RB, RT, etc. field</span>
<a name="l00152"></a><a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a3">00152</a> <span class="preprocessor"></span><span class="preprocessor">#define GPR12    12     // GPR 12 in an RA, RB, RT, etc. field</span>
<a name="l00153"></a><a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a4">00153</a> <span class="preprocessor"></span><span class="preprocessor">#define LINKREG  0x100  // Link Reg in a MFSPR instruction</span>
<a name="l00154"></a><a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a5">00154</a> <span class="preprocessor"></span><span class="preprocessor">#define COUNTREG 0x120  // Count Reg in a MFSPR instruction</span>
00155 <span class="preprocessor"></span>
00156 <span class="comment">//</span>
00157 <span class="comment">// TryReadUlong attempts to read memory from a possibly unsafe address.</span>
00158 <span class="comment">// It is in a seperate routine to avoid optimization deficiencies caused</span>
00159 <span class="comment">// by use of try/except.</span>
00160 <span class="comment">//</span>
00161 
00162 <span class="preprocessor">#ifndef _IMAGEHLP_SOURCE_</span>
00163 <span class="preprocessor"></span>
00164 <span class="keyword">static</span> <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00165"></a><a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a36">00165</a> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a36">TryReadUlong</a>(IN ULONG NextPc,
00166                OUT PULONG Value)
00167 {
00168     <span class="keywordflow">try</span> {
00169         <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a0">READ_ULONG</a> (NextPc, *Value);
00170     } except (<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
00171         <span class="keywordflow">return</span> GetExceptionCode();
00172     }
00173     <span class="keywordflow">return</span> STATUS_SUCCESS;
00174 }
00175 
00176 <span class="preprocessor">#endif</span>
00177 <span class="preprocessor"></span>
00178 <span class="keyword">static</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a8">INSTR_CLASS</a>
<a name="l00179"></a><a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a37">00179</a> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a37">ClassifyInstruction</a> (PPC_INSTRUCTION *I,
00180                      UNWIND_INTENT Intent,
00181 #ifdef _IMAGEHLP_SOURCE_
00182                      HANDLE hProcess,
00183                      PREAD_PROCESS_MEMORY_ROUTINE ReadMemory,
00184                      PFUNCTION_TABLE_ACCESS_ROUTINE FunctionTableAccess,
00185 #endif
00186                      ULONG Pc,
00187                      PMILLICODE_INFO Info)
00188 
00189 <span class="comment">/*++</span>
00190 <span class="comment"></span>
00191 <span class="comment">Routine description:</span>
00192 <span class="comment"></span>
00193 <span class="comment">    This function inspects the instruction identified by the "Pc"</span>
00194 <span class="comment">    argument and determines what sort of processing is needed in order</span>
00195 <span class="comment">    to simulate its execution.  Some instructions can be safely</span>
00196 <span class="comment">    ignored altogether, in which case "InstrIgnore" is returned.  For</span>
00197 <span class="comment">    others, a value is returned indicating what kind of instruction</span>
00198 <span class="comment">    was found.  The interpreation depends on the value of "Intent".</span>
00199 <span class="comment"></span>
00200 <span class="comment">Arguments:</span>
00201 <span class="comment"></span>
00202 <span class="comment">    I - Address of a struct containing the instruction to be examined.</span>
00203 <span class="comment">    Intent - Type of unwinding being performed.</span>
00204 <span class="comment">    Pc - Address of the instruction, used for computing relative branch</span>
00205 <span class="comment">        addresses.</span>
00206 <span class="comment">    Info - Address to store a description of the register save/restore</span>
00207 <span class="comment">        millicode.</span>
00208 <span class="comment"></span>
00209 <span class="comment">Return value:</span>
00210 <span class="comment"></span>
00211 <span class="comment">    One of the enum values defined above is returned.</span>
00212 <span class="comment"></span>
00213 <span class="comment"> --*/</span>
00214 
00215 {
00216 <span class="comment">// Unique value combining an opcode and an UNWIND_INTENT value.</span>
00217 <span class="preprocessor">#define OP_INTENT(OP,INTENT) ((OP) &lt;&lt; 2 | (INTENT))</span>
00218 <span class="preprocessor"></span>
00219 <span class="preprocessor">#ifdef _IMAGEHLP_SOURCE_</span>
00220 <span class="preprocessor"></span>    <a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a> ImagehlpCb = 0;
00221 <span class="preprocessor">#endif</span>
00222 <span class="preprocessor"></span>
00223     <span class="keywordflow">switch</span> (<a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a6">OP_INTENT</a> (I-&gt;Primary_Op, <a class="code" href="../../d3/d8/aug98_2test_2main_8c.html#a28">Intent</a>)) {
00224 
00225       <span class="comment">//</span>
00226       <span class="comment">// Store word: recognize "stw r.n, disp(r.1)".  Allow a base of</span>
00227       <span class="comment">// r.12 if we have computed its value.</span>
00228       <span class="comment">//</span>
00229       <span class="keywordflow">case</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a6">OP_INTENT</a> (STW_OP, <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a40a35">UnwindReverseR12</a>):
00230         <span class="keywordflow">if</span> (I-&gt;Dform_RA == <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a3">GPR12</a>)
00231             <span class="keywordflow">return</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a17">InstrSTW</a>;
00232         <span class="comment">// fall thru</span>
00233       <span class="keywordflow">case</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a6">OP_INTENT</a> (STW_OP, <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a40a34">UnwindReverse</a>):
00234         <span class="keywordflow">if</span> (I-&gt;Dform_RA == <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a1">GPR1</a>)
00235             <span class="keywordflow">return</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a17">InstrSTW</a>;
00236         <span class="keywordflow">break</span>;
00237 
00238       <span class="comment">//</span>
00239       <span class="comment">// Load word:  recognize "lwz r.n, disp(r.x)" in epilogue millicode.</span>
00240       <span class="comment">//</span>
00241       <span class="keywordflow">case</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a6">OP_INTENT</a> (LWZ_OP, <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a40a32">UnwindForward</a>):
00242         <span class="keywordflow">return</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a17">InstrSTW</a>;
00243 
00244       <span class="comment">//</span>
00245       <span class="comment">// Load word:  recognize "lwz r.toc, disp(r.1)" as TOC restore</span>
00246       <span class="comment">// instruction.</span>
00247       <span class="comment">//</span>
00248       <span class="keywordflow">case</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a6">OP_INTENT</a> (LWZ_OP, <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a40a34">UnwindReverse</a>):
00249         <span class="keywordflow">if</span> (I-&gt;Dform_RA == <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a1">GPR1</a> &amp;&amp;
00250             I-&gt;Dform_RS == <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a2">GPR2</a>)
00251         <span class="keywordflow">return</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a30">InstrTOCRestore</a>;
00252 
00253       <span class="comment">//</span>
00254       <span class="comment">// Store word with update:  recognize "stwu r.1, r.1, disp"</span>
00255       <span class="comment">//</span>
00256       <span class="keywordflow">case</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a6">OP_INTENT</a> (STWU_OP, <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a40a34">UnwindReverse</a>):
00257       <span class="keywordflow">case</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a6">OP_INTENT</a> (STWU_OP, <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a40a35">UnwindReverseR12</a>):
00258       <span class="keywordflow">case</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a6">OP_INTENT</a> (STWU_OP, <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a40a33">UnwindR12</a>):
00259         <span class="keywordflow">if</span> (I-&gt;Dform_RS == <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a1">GPR1</a> &amp;&amp;
00260             I-&gt;Dform_RA == <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a1">GPR1</a>)
00261             <span class="keywordflow">return</span> (<a class="code" href="../../d3/d8/aug98_2test_2main_8c.html#a28">Intent</a> == <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a40a33">UnwindR12</a> ? <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a19">InstrSTWUr12</a> : <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a18">InstrSTWU</a>);
00262         <span class="keywordflow">break</span>;
00263 
00264       <span class="comment">//</span>
00265       <span class="comment">// Store float double: recognize "stfd f.n, disp(r.1)".  Allow a</span>
00266       <span class="comment">// base of r.12 if we have computed its value.</span>
00267       <span class="comment">//</span>
00268       <span class="keywordflow">case</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a6">OP_INTENT</a> (STFD_OP, <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a40a35">UnwindReverseR12</a>):
00269         <span class="keywordflow">if</span> (I-&gt;Dform_RA == <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a3">GPR12</a>)
00270             <span class="keywordflow">return</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a20">InstrSTFD</a>;
00271         <span class="comment">// fall thru</span>
00272       <span class="keywordflow">case</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a6">OP_INTENT</a> (STFD_OP, <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a40a34">UnwindReverse</a>):
00273         <span class="keywordflow">if</span> (I-&gt;Dform_RA == <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a1">GPR1</a>)
00274             <span class="keywordflow">return</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a20">InstrSTFD</a>;
00275         <span class="keywordflow">break</span>;
00276 
00277       <span class="comment">//</span>
00278       <span class="comment">// Load float double:  recognize "lfd f.n, disp(r.x)"</span>
00279       <span class="comment">//</span>
00280       <span class="keywordflow">case</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a6">OP_INTENT</a> (LFD_OP, <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a40a32">UnwindForward</a>):
00281         <span class="keywordflow">return</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a20">InstrSTFD</a>;
00282 
00283       <span class="comment">//</span>
00284       <span class="comment">// Add immediate:  recognize "addi r.12, r.1, delta"</span>
00285       <span class="comment">//</span>
00286       <span class="keywordflow">case</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a6">OP_INTENT</a> (ADDI_OP, <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a40a33">UnwindR12</a>):
00287         <span class="keywordflow">if</span> (I-&gt;Dform_RS == <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a3">GPR12</a> &amp;&amp;
00288             I-&gt;Dform_RA == <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a1">GPR1</a>)
00289             <span class="keywordflow">return</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a24">InstrADDIr12</a>;
00290         <span class="keywordflow">break</span>;
00291       <span class="keywordflow">case</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a6">OP_INTENT</a> (ADDI_OP, <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a40a32">UnwindForward</a>):
00292         <span class="keywordflow">return</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a25">InstrADDIfwd</a>;
00293 
00294       <span class="comment">//</span>
00295       <span class="comment">// Branch (long form):  recognize "bl[a] saveregs"and "b[a] restregs"</span>
00296       <span class="comment">//</span>
00297       <span class="keywordflow">case</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a6">OP_INTENT</a> (B_OP, <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a40a34">UnwindReverse</a>):
00298         <span class="comment">//</span>
00299         <span class="comment">// Compute branch target address, allowing for branch-relative</span>
00300         <span class="comment">// and branch-absolute.</span>
00301         <span class="comment">//</span>
00302         Pc = ((LONG)(I-&gt;Iform_LI) &lt;&lt; 2) + (I-&gt;Iform_AA ? 0 : Pc);
00303 
00304         <span class="comment">//</span>
00305         <span class="comment">// Quickly distinguish "bl subroutine" from "bl[a] saveregs".</span>
00306         <span class="comment">// "mtlr" is not a valid instruction in register save millicode and</span>
00307         <span class="comment">// is usually the first instruction in "bl subroutine".</span>
00308         <span class="comment">//</span>
00309         <span class="keywordflow">if</span> (I-&gt;Iform_LK) {
00310             PPC_INSTRUCTION TempI;
00311             <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a0">READ_ULONG</a> (Pc, TempI.Long);
00312             <span class="keywordflow">if</span> (TempI.Primary_Op == X31_OP &amp;&amp;
00313                 TempI.Xform_XO == MFSPR_OP &amp;&amp;
00314                 TempI.XFXform_spr == <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a4">LINKREG</a>) {
00315                 <span class="keywordflow">break</span>;
00316             }
00317         }
00318 
00319         <span class="comment">//</span>
00320         <span class="comment">// Determine whether the target address is part of a register</span>
00321         <span class="comment">// save or register restore sequence or is a direct branch out</span>
00322         <span class="comment">// by checking it's function table entry.</span>
00323         <span class="comment">//</span>
00324         <span class="keywordflow">if</span> ((Info-&gt;<a class="code" href="../../d6/d9/struct__MILLICODE__INFO.html#o1">FunctionEntry</a> = (PRUNTIME_FUNCTION)<a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a8">RtlLookupFunctionEntry</a>(Pc)) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>
00325 <span class="preprocessor">#ifndef FUNCTION_ENTRY_IS_IMAGE_STYLE</span>
00326 <span class="preprocessor"></span>            &amp;&amp; Info-&gt;<a class="code" href="../../d6/d9/struct__MILLICODE__INFO.html#o1">FunctionEntry</a>-&gt;ExceptionHandler == 0
00327 <span class="preprocessor">#endif</span>
00328 <span class="preprocessor"></span>            ) {
00329             Info-&gt;<a class="code" href="../../d6/d9/struct__MILLICODE__INFO.html#o0">TargetPc</a> = Pc;
00330             <span class="keywordflow">switch</span> (
00331 <span class="preprocessor">#ifdef FUNCTION_ENTRY_IS_IMAGE_STYLE</span>
00332 <span class="preprocessor"></span>                    Info-&gt;<a class="code" href="../../d6/d9/struct__MILLICODE__INFO.html#o1">FunctionEntry</a>-&gt;BeginAddress -
00333                     Info-&gt;<a class="code" href="../../d6/d9/struct__MILLICODE__INFO.html#o1">FunctionEntry</a>-&gt;PrologEndAddress
00334 <span class="preprocessor">#else</span>
00335 <span class="preprocessor"></span>                    (ULONG)Info-&gt;<a class="code" href="../../d6/d9/struct__MILLICODE__INFO.html#o1">FunctionEntry</a>-&gt;HandlerData
00336 <span class="preprocessor">#endif</span>
00337 <span class="preprocessor"></span>                    ) {
00338             <span class="keywordflow">case</span> 1:
00339                 <span class="keywordflow">if</span> (I-&gt;Iform_LK)
00340                     <span class="keywordflow">return</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a26">InstrSaveCode</a>;
00341                 <span class="keywordflow">break</span>;
00342             <span class="keywordflow">case</span> 2:
00343                 <span class="keywordflow">if</span> (!I-&gt;Iform_LK)
00344                     <span class="keywordflow">return</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a27">InstrRestoreCode</a>;
00345                 <span class="keywordflow">break</span>;
00346 <span class="preprocessor">#ifdef FUNCTION_ENTRY_IS_IMAGE_STYLE</span>
00347 <span class="preprocessor"></span>            <span class="keywordflow">default</span>:
00348                 <span class="keywordflow">if</span> ((Info-&gt;<a class="code" href="../../d6/d9/struct__MILLICODE__INFO.html#o1">FunctionEntry</a>-&gt;PrologEndAddress &amp; 3) == 1)
00349 <span class="preprocessor">#else</span>
00350 <span class="preprocessor"></span>            <span class="keywordflow">case</span> 3:
00351 <span class="preprocessor">#endif</span>
00352 <span class="preprocessor"></span>                <span class="keywordflow">return</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a28">InstrGlue</a>;
00353                 <span class="keywordflow">break</span>;
00354             }
00355         }
00356         <span class="keywordflow">break</span>; <span class="comment">// unrecognized entry point</span>
00357 
00358       <span class="comment">//</span>
00359       <span class="comment">// Extended ops -- primary opcode 19</span>
00360       <span class="comment">//</span>
00361       <span class="keywordflow">case</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a6">OP_INTENT</a> (X19_OP, <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a40a32">UnwindForward</a>):
00362 
00363         <span class="comment">//</span>
00364         <span class="comment">// BLR: recognized "bclr 20,0".</span>
00365         <span class="comment">//</span>
00366         <span class="keywordflow">if</span> (I-&gt;Long == RETURN_INSTR)
00367             <span class="keywordflow">return</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a29">InstrBLR</a>;
00368 
00369         <span class="keywordflow">break</span>;
00370 
00371       <span class="keywordflow">case</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a6">OP_INTENT</a> (X19_OP, <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a40a33">UnwindR12</a>):
00372       <span class="keywordflow">case</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a6">OP_INTENT</a> (X19_OP, <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a40a34">UnwindReverse</a>):
00373       <span class="keywordflow">case</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a6">OP_INTENT</a> (X19_OP, <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a40a35">UnwindReverseR12</a>):
00374         <span class="comment">//</span>
00375         <span class="comment">// RFI: this instruction is used in special kernel fake prologues</span>
00376         <span class="comment">//      to indicate that the establisher frame address should be</span>
00377         <span class="comment">//      updated using the current value of sp.</span>
00378         <span class="comment">//</span>
00379         <span class="keywordflow">if</span> (I-&gt;Xform_XO == RFI_OP) {
00380             <span class="keywordflow">return</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a31">InstrSetEstablisher</a>;
00381         }
00382 
00383         <span class="keywordflow">break</span>;
00384 
00385       <span class="comment">//</span>
00386       <span class="comment">// Extended ops -- primary opcode 31</span>
00387       <span class="comment">//</span>
00388       <span class="keywordflow">case</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a6">OP_INTENT</a> (X31_OP, <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a40a32">UnwindForward</a>):
00389       <span class="keywordflow">case</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a6">OP_INTENT</a> (X31_OP, <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a40a33">UnwindR12</a>):
00390       <span class="keywordflow">case</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a6">OP_INTENT</a> (X31_OP, <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a40a34">UnwindReverse</a>):
00391       <span class="keywordflow">case</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a6">OP_INTENT</a> (X31_OP, <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a40a35">UnwindReverseR12</a>):
00392         <span class="keywordflow">switch</span> (<a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a6">OP_INTENT</a> (I-&gt;Xform_XO, <a class="code" href="../../d3/d8/aug98_2test_2main_8c.html#a28">Intent</a>)) {
00393 
00394           <span class="comment">//</span>
00395           <span class="comment">// OR register: recognize "or r.x, r.y, r.y" as move-reg</span>
00396           <span class="comment">//</span>
00397           <span class="keywordflow">case</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a6">OP_INTENT</a> (OR_OP, <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a40a33">UnwindR12</a>):
00398             <span class="keywordflow">if</span> (I-&gt;Xform_RS == I-&gt;Xform_RB &amp;&amp;
00399                 I-&gt;Xform_RA == <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a3">GPR12</a> &amp;&amp;
00400                 I-&gt;Xform_RB == <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a1">GPR1</a>)
00401                 <span class="keywordflow">return</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a22">InstrMRr12</a>;
00402             <span class="keywordflow">break</span>;
00403           <span class="keywordflow">case</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a6">OP_INTENT</a> (OR_OP, <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a40a34">UnwindReverse</a>):
00404           <span class="keywordflow">case</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a6">OP_INTENT</a> (OR_OP, <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a40a35">UnwindReverseR12</a>):
00405             <span class="keywordflow">if</span> (I-&gt;Xform_RS == I-&gt;Xform_RB &amp;&amp;
00406                 I-&gt;Xform_RB != <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a1">GPR1</a>)
00407                 <span class="keywordflow">return</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a21">InstrMR</a>;
00408             <span class="keywordflow">break</span>;
00409           <span class="keywordflow">case</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a6">OP_INTENT</a> (OR_OP, <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a40a32">UnwindForward</a>):
00410             <span class="keywordflow">if</span> (I-&gt;Xform_RS == I-&gt;Xform_RB)
00411                 <span class="keywordflow">return</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a23">InstrMRfwd</a>;
00412             <span class="keywordflow">break</span>;
00413 
00414           <span class="comment">//</span>
00415           <span class="comment">// Store word with update indexed:  recognize "stwux r.1, r.1, r.x"</span>
00416           <span class="comment">//</span>
00417           <span class="keywordflow">case</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a6">OP_INTENT</a> (STWUX_OP, <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a40a34">UnwindReverse</a>):
00418           <span class="keywordflow">case</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a6">OP_INTENT</a> (STWUX_OP, <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a40a35">UnwindReverseR12</a>):
00419           <span class="keywordflow">case</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a6">OP_INTENT</a> (STWUX_OP, <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a40a33">UnwindR12</a>):
00420             <span class="keywordflow">if</span> (I-&gt;Xform_RS == <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a1">GPR1</a> &amp;&amp; I-&gt;Xform_RA == <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a1">GPR1</a>)
00421                 <span class="keywordflow">return</span> (<a class="code" href="../../d3/d8/aug98_2test_2main_8c.html#a28">Intent</a> == <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a40a33">UnwindR12</a> ? <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a19">InstrSTWUr12</a> : <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a18">InstrSTWU</a>);
00422             <span class="keywordflow">break</span>;
00423 
00424           <span class="comment">//</span>
00425           <span class="comment">// Move to/from special-purpose reg:  recognize "mflr", "mtlr"</span>
00426           <span class="comment">//</span>
00427           <span class="keywordflow">case</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a6">OP_INTENT</a> (MFSPR_OP, <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a40a34">UnwindReverse</a>):
00428           <span class="keywordflow">case</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a6">OP_INTENT</a> (MTSPR_OP, <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a40a32">UnwindForward</a>):
00429             <span class="keywordflow">if</span> (I-&gt;XFXform_spr == <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a4">LINKREG</a>)
00430                 <span class="keywordflow">return</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a15">InstrMFLR</a>;
00431             <span class="keywordflow">break</span>;
00432 
00433           <span class="comment">//</span>
00434           <span class="comment">// Move from Condition Register:  "mfcr r.x"</span>
00435           <span class="comment">//</span>
00436           <span class="keywordflow">case</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a6">OP_INTENT</a> (MFCR_OP, <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a40a34">UnwindReverse</a>):
00437           <span class="keywordflow">case</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a6">OP_INTENT</a> (MFCR_OP, <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a40a35">UnwindReverseR12</a>):
00438             <span class="keywordflow">return</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a16">InstrMFCR</a>;
00439 
00440           <span class="comment">//</span>
00441           <span class="comment">// Move to Condition Register:  "mtcrf 255,r.x"</span>
00442           <span class="comment">//</span>
00443           <span class="keywordflow">case</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a6">OP_INTENT</a> (MTCRF_OP, <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a40a32">UnwindForward</a>):
00444             <span class="keywordflow">if</span> (I-&gt;XFXform_FXM == 255)
00445                 <span class="keywordflow">return</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a16">InstrMFCR</a>;
00446             <span class="keywordflow">break</span>;
00447 
00448           <span class="keywordflow">default</span>:              <span class="comment">// unrecognized</span>
00449             <span class="keywordflow">break</span>;
00450         }
00451 
00452       <span class="keywordflow">default</span>:                  <span class="comment">// unrecognized</span>
00453         <span class="keywordflow">break</span>;
00454     }
00455 
00456     <span class="comment">//</span>
00457     <span class="comment">// Instruction not recognized; just ignore it and carry on</span>
00458     <span class="comment">//</span>
00459     <span class="keywordflow">return</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a14">InstrIgnore</a>;
00460 <span class="preprocessor">#undef OP_INTENT</span>
00461 <span class="preprocessor"></span>}
00462 
00463 <span class="preprocessor">#ifdef _IMAGEHLP_SOURCE_</span>
00464 <span class="preprocessor"></span><span class="keyword">static</span>
00465 <span class="preprocessor">#endif</span>
00466 <span class="preprocessor"></span>ULONG
<a name="l00467"></a><a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a38">00467</a> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a38">RtlVirtualUnwind</a> (
00468 
00469 #ifdef _IMAGEHLP_SOURCE_
00470     HANDLE hProcess,
00471     DWORD  ControlPc,
00472     PRUNTIME_FUNCTION FunctionEntry,
00473     PCONTEXT ContextRecord,
00474     PREAD_PROCESS_MEMORY_ROUTINE ReadMemory,
00475     PFUNCTION_TABLE_ACCESS_ROUTINE FunctionTableAccess
00476 #define ContextPointers ((PKNONVOLATILE_CONTEXT_POINTERS)0)
00477 #<span class="keywordflow">else</span>
00478     IN ULONG ControlPc,
00479     IN PRUNTIME_FUNCTION FunctionEntry,
00480     IN OUT PCONTEXT ContextRecord,
00481     OUT PBOOLEAN InFunction,
00482     OUT PULONG EstablisherFrame,
00483     IN OUT PKNONVOLATILE_CONTEXT_POINTERS ContextPointers OPTIONAL,
00484     IN ULONG LowStackLimit,
00485     IN ULONG HighStackLimit
00486 #endif
00487     )
00488 
00489 <span class="comment">/*++</span>
00490 <span class="comment"></span>
00491 <span class="comment">Routine Description:</span>
00492 <span class="comment"></span>
00493 <span class="comment">    This function virtually unwinds the specfified function by executing its</span>
00494 <span class="comment">    prologue code backwards.</span>
00495 <span class="comment"></span>
00496 <span class="comment">    If the function is a leaf function, then the address where control left</span>
00497 <span class="comment">    the previous frame is obtained from the context record. If the function</span>
00498 <span class="comment">    is a nested function, but not an exception or interrupt frame, then the</span>
00499 <span class="comment">    prologue code is executed backwards and the address where control left</span>
00500 <span class="comment">    the previous frame is obtained from the updated context record.</span>
00501 <span class="comment"></span>
00502 <span class="comment">    If the function is register save millicode, it is treated as a leaf</span>
00503 <span class="comment">    function.  If the function is register restore millicode, the remaining</span>
00504 <span class="comment">    body is executed forwards and the address where control left the</span>
00505 <span class="comment">    previous frame is obtained from the final blr instruction.</span>
00506 <span class="comment"></span>
00507 <span class="comment">    If the function was called via glue code and is not that glue code,</span>
00508 <span class="comment">    the prologe of the glue code is executed backwards in addition to the</span>
00509 <span class="comment">    above actions.</span>
00510 <span class="comment"></span>
00511 <span class="comment">    Otherwise, an exception or interrupt entry to the system is being</span>
00512 <span class="comment">    unwound and a specially coded prologue restores the return address</span>
00513 <span class="comment">    twice. Once from the fault instruction address and once from the saved</span>
00514 <span class="comment">    return address register. The first restore is returned as the function</span>
00515 <span class="comment">    value and the second restore is place in the updated context record.</span>
00516 <span class="comment"></span>
00517 <span class="comment">    If a context pointers record is specified, then the address where each</span>
00518 <span class="comment">    nonvolatile registers is restored from is recorded in the appropriate</span>
00519 <span class="comment">    element of the context pointers record.</span>
00520 <span class="comment"></span>
00521 <span class="comment">Arguments:</span>
00522 <span class="comment"></span>
00523 <span class="comment">    ControlPc - Supplies the address where control left the specified</span>
00524 <span class="comment">        function.</span>
00525 <span class="comment"></span>
00526 <span class="comment">    FunctionEntry - Supplies the address of the function table entry for the</span>
00527 <span class="comment">        specified function or NULL if the function is a leaf function.</span>
00528 <span class="comment"></span>
00529 <span class="comment">    ContextRecord - Supplies the address of a context record.</span>
00530 <span class="comment"></span>
00531 <span class="comment">    InFunction - Supplies a pointer to a variable that receives whether the</span>
00532 <span class="comment">        control PC is within the current function.</span>
00533 <span class="comment"></span>
00534 <span class="comment">    EstablisherFrame - Supplies a pointer to a variable that receives the</span>
00535 <span class="comment">        the establisher frame pointer value.</span>
00536 <span class="comment"></span>
00537 <span class="comment">    ContextPointers - Supplies an optional pointer to a context pointers</span>
00538 <span class="comment">        record.</span>
00539 <span class="comment"></span>
00540 <span class="comment">    LowStackLimit, HighStackLimit - Range of valid values for the stack</span>
00541 <span class="comment">        pointer.  This indicates whether it is valid to examine NextPc.</span>
00542 <span class="comment"></span>
00543 <span class="comment">Return Value:</span>
00544 <span class="comment"></span>
00545 <span class="comment">    The address where control left the previous frame is returned as the</span>
00546 <span class="comment">    function value.</span>
00547 <span class="comment"></span>
00548 <span class="comment"> --*/</span>
00549 
00550 {
00551     <a class="code" href="../../d6/d4/struct__ITERATOR.html">ITERATOR</a> Iterator[8];
00552     <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a13">PITERATOR</a> Piterator;
00553     ULONG Address;
00554     <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a7">PDOUBLE</a> FloatingRegister;
00555     PPC_INSTRUCTION I;
00556     PULONG IntegerRegister;
00557     ULONG NextPc, Pc;
00558     BOOLEAN RestoredLr = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00559     BOOLEAN RestoredSp = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00560     BOOLEAN ComputedSp = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00561     ULONG Rt;
00562     <a class="code" href="../../d6/d9/struct__MILLICODE__INFO.html">MILLICODE_INFO</a> Info;
00563     <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a8">INSTR_CLASS</a> InstrClass;
00564 <span class="preprocessor">#ifdef _IMAGEHLP_SOURCE_</span>
00565 <span class="preprocessor"></span>    <a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a> ImagehlpCb = 0;
00566     RUNTIME_FUNCTION SavedFunctionEntry;
00567 <span class="preprocessor">#else</span>
00568 <span class="preprocessor"></span>    ULONG EstablisherFrameValue;
00569 <span class="preprocessor">#endif</span>
00570 <span class="preprocessor"></span>
00571     <span class="comment">//</span>
00572     <span class="comment">// Set the base address of the integer and floating register arrays.</span>
00573     <span class="comment">//</span>
00574 
00575     FloatingRegister = &amp;ContextRecord-&gt;Fpr0;
00576     IntegerRegister = &amp;ContextRecord-&gt;Gpr0;
00577 
00578     <span class="comment">//</span>
00579     <span class="comment">// If the function is a leaf function, perform the default unwinding</span>
00580     <span class="comment">// action and check to see if the function was called via glue.</span>
00581     <span class="comment">//</span>
00582     <span class="keywordflow">if</span> (FunctionEntry == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00583         <span class="comment">//</span>
00584         <span class="comment">// Set point at which control left the previous routine.</span>
00585         <span class="comment">//</span>
00586         NextPc = ContextRecord-&gt;Lr - 4;
00587 
00588         <span class="comment">//</span>
00589         <span class="comment">// If the next control PC is the same as the old control PC, then</span>
00590         <span class="comment">// the function table is not correctly formed.</span>
00591         <span class="comment">//</span>
00592         <span class="keywordflow">if</span> (NextPc == ControlPc)
00593             <span class="keywordflow">return</span> NextPc;
00594 
00595         <span class="keywordflow">goto</span> CheckForGlue;
00596     }
00597 <span class="preprocessor">#ifdef _IMAGEHLP_SOURCE_</span>
00598 <span class="preprocessor"></span>    <span class="keywordflow">else</span> {
00599         SavedFunctionEntry = *FunctionEntry;
00600         FunctionEntry = &amp;SavedFunctionEntry;
00601     }
00602 <span class="preprocessor">#endif</span>
00603 <span class="preprocessor"></span>    <span class="comment">//</span>
00604     <span class="comment">// Set initial values for EstablisherFrame and Offset.</span>
00605     <span class="comment">// (this may need more careful planning IBMPLJ).</span>
00606     <span class="comment">//</span>
00607 
00608     <a class="code" href="../../d9/d6/ia64_2vunwind_8c.html#a0">NOT_IMAGEHLP</a> (*EstablisherFrame =
00609                   EstablisherFrameValue = ContextRecord-&gt;Gpr1);
00610 
00611     <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a0">READ_ULONG</a> (ControlPc, I.Long);
00612     <span class="keywordflow">if</span> (I.Long == RETURN_INSTR) {
00613         <span class="comment">//</span>
00614         <span class="comment">// If the instruction at the point where control left the specified</span>
00615         <span class="comment">// function is a return, then any saved registers have been restored</span>
00616         <span class="comment">// and the control PC is not considered to be in the function</span>
00617         <span class="comment">// (i.e., in an epilogue).</span>
00618         <span class="comment">//</span>
00619         <a class="code" href="../../d9/d6/ia64_2vunwind_8c.html#a0">NOT_IMAGEHLP</a>(*InFunction = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
00620         NextPc = ContextRecord-&gt;Lr;
00621         <span class="keywordflow">goto</span> CheckForGlue;
00622     }
00623     InstrClass = <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a37">ClassifyInstruction</a>(&amp;I, <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a40a34">UnwindReverse</a>,
00624 #ifdef _IMAGEHLP_SOURCE_
00625                                      hProcess, ReadMemory, FunctionTableAccess,
00626 #endif
00627                                      ControlPc, &amp;Info);
00628     <span class="keywordflow">if</span> (InstrClass == <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a27">InstrRestoreCode</a>) {
00629         <span class="comment">//</span>
00630         <span class="comment">// If the instruction at the point where control left the</span>
00631         <span class="comment">// specified function is a branch to register restore</span>
00632         <span class="comment">// millicode, the state is restored by simulating the</span>
00633         <span class="comment">// execution of the restore millicode.  The control PC is in</span>
00634         <span class="comment">// an epilogue.</span>
00635         <span class="comment">//</span>
00636         Iterator[0].<a class="code" href="../../d6/d4/struct__ITERATOR.html#o0">BeginPc</a> = Info.<a class="code" href="../../d6/d9/struct__MILLICODE__INFO.html#o0">TargetPc</a>;
00637         Iterator[0].<a class="code" href="../../d6/d4/struct__ITERATOR.html#o1">EndPc</a> = Info.<a class="code" href="../../d6/d9/struct__MILLICODE__INFO.html#o1">FunctionEntry</a>-&gt;EndAddress;
00638         Iterator[0].<a class="code" href="../../d6/d4/struct__ITERATOR.html#o2">Increment</a> = 4;
00639         Iterator[0].<a class="code" href="../../d6/d4/struct__ITERATOR.html#o3">Intent</a> = <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a40a32">UnwindForward</a>;
00640         <a class="code" href="../../d9/d6/ia64_2vunwind_8c.html#a0">NOT_IMAGEHLP</a>(*InFunction = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
00641 
00642     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (
00643 <span class="preprocessor">#ifdef FUNCTION_ENTRY_IS_IMAGE_STYLE</span>
00644 <span class="preprocessor"></span>               (FunctionEntry-&gt;BeginAddress -
00645                 FunctionEntry-&gt;PrologEndAddress) == 2
00646 <span class="preprocessor">#else</span>
00647 <span class="preprocessor"></span>               FunctionEntry-&gt;ExceptionHandler == 0 &amp;&amp;
00648                (ULONG)FunctionEntry-&gt;HandlerData == 2
00649 <span class="preprocessor">#endif</span>
00650 <span class="preprocessor"></span>               ) {
00651         <span class="comment">//</span>
00652         <span class="comment">// If the address is in register restore millicode, the state</span>
00653         <span class="comment">// is restored by completing the execution of the restore</span>
00654         <span class="comment">// millicode.  The control PC is in an epilogue.</span>
00655         <span class="comment">//</span>
00656         Iterator[0].<a class="code" href="../../d6/d4/struct__ITERATOR.html#o0">BeginPc</a> = ControlPc;
00657         Iterator[0].<a class="code" href="../../d6/d4/struct__ITERATOR.html#o1">EndPc</a> = FunctionEntry-&gt;EndAddress;
00658         Iterator[0].<a class="code" href="../../d6/d4/struct__ITERATOR.html#o2">Increment</a> = 4;
00659         Iterator[0].<a class="code" href="../../d6/d4/struct__ITERATOR.html#o3">Intent</a> = <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a40a32">UnwindForward</a>;
00660         <a class="code" href="../../d9/d6/ia64_2vunwind_8c.html#a0">NOT_IMAGEHLP</a>(*InFunction = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
00661 
00662     } <span class="keywordflow">else</span> {
00663         <span class="comment">//</span>
00664         <span class="comment">// If the address where control left the specified function is a</span>
00665         <span class="comment">// TOC restore instruction and the previous instruction is a call</span>
00666         <span class="comment">// via glue instruction, we must forward execute the TOC restore</span>
00667         <span class="comment">// instruction.</span>
00668         <span class="comment">//</span>
00669         <span class="keywordflow">if</span> (InstrClass == <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a30">InstrTOCRestore</a>) {
00670             PPC_INSTRUCTION Iprev;
00671             <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a0">READ_ULONG</a> (ControlPc - 4, Iprev.Long);
00672             <span class="keywordflow">if</span> (<a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a37">ClassifyInstruction</a> (&amp;Iprev, <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a40a34">UnwindReverse</a>,
00673 #ifdef _IMAGEHLP_SOURCE_
00674                                      hProcess, ReadMemory, FunctionTableAccess,
00675 #endif
00676                                      ControlPc - 4, &amp;Info) == <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a28">InstrGlue</a>) {
00677                 <span class="comment">//</span>
00678                 <span class="comment">// Forward execute the TOC restore.  We assume (reasonably)</span>
00679                 <span class="comment">// that the next instruction is covered by the same function</span>
00680                 <span class="comment">// table entry and it isn't one of the above special cases</span>
00681                 <span class="comment">// (InstrRestoreCode or InstrBLR).</span>
00682                 <span class="comment">//</span>
00683                 ControlPc += 4;
00684                 Address = IntegerRegister[I.Dform_RA] + I.Dform_D;
00685                 Rt = I.Dform_RT;
00686                 <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a0">READ_ULONG</a> (Address, IntegerRegister[Rt]);
00687                 <span class="keywordflow">if</span> (ARGUMENT_PRESENT (ContextPointers))
00688                     ContextPointers-&gt;IntegerContext[Rt] = (PULONG) Address;
00689             }
00690         }
00691 
00692         <span class="comment">//</span>
00693         <span class="comment">// If the address where control left the specified function is</span>
00694         <span class="comment">// outside the limits of the prologue, then the control PC is</span>
00695         <span class="comment">// considered to be within the function and the control</span>
00696         <span class="comment">// address is set to the end of the prologue. Otherwise, the</span>
00697         <span class="comment">// control PC is not considered to be within the function</span>
00698         <span class="comment">// (i.e., in the prologue).</span>
00699         <span class="comment">//</span>
00700         Iterator[0].<a class="code" href="../../d6/d4/struct__ITERATOR.html#o1">EndPc</a> = FunctionEntry-&gt;BeginAddress - 4;
00701         Iterator[0].<a class="code" href="../../d6/d4/struct__ITERATOR.html#o2">Increment</a> = -4;
00702         Iterator[0].<a class="code" href="../../d6/d4/struct__ITERATOR.html#o3">Intent</a> = <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a40a34">UnwindReverse</a>;
00703         <span class="keywordflow">if</span> ((ControlPc &lt; FunctionEntry-&gt;BeginAddress) ||
00704             (ControlPc &gt;= (FunctionEntry-&gt;PrologEndAddress &amp; ~3))) {
00705             <a class="code" href="../../d9/d6/ia64_2vunwind_8c.html#a0">NOT_IMAGEHLP</a>(*InFunction = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
00706             Iterator[0].<a class="code" href="../../d6/d4/struct__ITERATOR.html#o0">BeginPc</a> = ((FunctionEntry-&gt;PrologEndAddress &amp; ~3) - 4);
00707         } <span class="keywordflow">else</span> {
00708             <a class="code" href="../../d9/d6/ia64_2vunwind_8c.html#a0">NOT_IMAGEHLP</a>(*InFunction = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
00709             Iterator[0].<a class="code" href="../../d6/d4/struct__ITERATOR.html#o0">BeginPc</a> = ControlPc - 4;
00710         }
00711     }
00712 
00713     <span class="comment">//</span>
00714     <span class="comment">// Scan through the given instructions and reload callee registers</span>
00715     <span class="comment">// as indicated.</span>
00716     <span class="comment">//</span>
00717     NextPc = ContextRecord-&gt;Lr - 4;
00718   UnwindGlue:
00719     <span class="keywordflow">for</span> (Piterator = Iterator; Piterator &gt;= Iterator; Piterator--) {
00720         <span class="keywordflow">for</span> (Pc = Piterator-&gt;<a class="code" href="../../d6/d4/struct__ITERATOR.html#o0">BeginPc</a>;
00721              Pc != Piterator-&gt;<a class="code" href="../../d6/d4/struct__ITERATOR.html#o1">EndPc</a>;
00722              Pc += Piterator-&gt;<a class="code" href="../../d6/d4/struct__ITERATOR.html#o2">Increment</a>) {
00723 
00724             <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a0">READ_ULONG</a> (Pc, I.Long);
00725             Address = IntegerRegister[I.Dform_RA] + I.Dform_D;
00726             Rt = I.Dform_RT;
00727             <span class="keywordflow">switch</span> (<a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a37">ClassifyInstruction</a> (&amp;I, Piterator-&gt;<a class="code" href="../../d6/d4/struct__ITERATOR.html#o3">Intent</a>,
00728 #ifdef _IMAGEHLP_SOURCE_
00729                                          hProcess, ReadMemory, FunctionTableAccess,
00730 #endif
00731                                          Pc, &amp;Info)) {
00732 
00733               <span class="comment">//</span>
00734               <span class="comment">// Move from Link Register (save LR in a GPR)</span>
00735               <span class="comment">//</span>
00736               <span class="comment">// In the usual case, the link register gets set by a call</span>
00737               <span class="comment">// instruction so the PC value should point to the</span>
00738               <span class="comment">// instruction that sets the link register.  In an interrupt</span>
00739               <span class="comment">// or exception frame, the link register and PC value are</span>
00740               <span class="comment">// independent.  By convention, fake prologues for these</span>
00741               <span class="comment">// frames store the link register twice: once to the link</span>
00742               <span class="comment">// register location, once to the faulting PC location.</span>
00743               <span class="comment">//</span>
00744               <span class="comment">// If this is the first time that RA is being restored,</span>
00745               <span class="comment">// then set the address of where control left the previous</span>
00746               <span class="comment">// frame. Otherwise, this is an interrupt or exception and</span>
00747               <span class="comment">// the return PC should be biased by 4 and the link register</span>
00748               <span class="comment">// value should be updated.</span>
00749               <span class="comment">//</span>
00750               <span class="keywordflow">case</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a15">InstrMFLR</a>:
00751                 ContextRecord-&gt;Lr = IntegerRegister[Rt];
00752                 <span class="keywordflow">if</span> ( RestoredLr == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> ) {
00753                     NextPc = ContextRecord-&gt;Lr - 4;
00754                     RestoredLr = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00755                 } <span class="keywordflow">else</span> {
00756                     NextPc += 4;
00757                 }
00758                 <span class="keywordflow">continue</span>; <span class="comment">// Next PC</span>
00759 
00760               <span class="comment">//</span>
00761               <span class="comment">// Branch to Link Register (forward execution).</span>
00762               <span class="comment">//</span>
00763               <span class="keywordflow">case</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a29">InstrBLR</a>:
00764                 NextPc = ContextRecord-&gt;Lr - 4;
00765                 <span class="keywordflow">break</span>; <span class="comment">// Terminate simulation--start next iterator.</span>
00766 
00767               <span class="comment">//</span>
00768               <span class="comment">// Move from Condition Register (save CR in a GPR)</span>
00769               <span class="comment">//</span>
00770               <span class="keywordflow">case</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a16">InstrMFCR</a>:
00771                 ContextRecord-&gt;Cr = IntegerRegister[Rt];
00772                 <span class="keywordflow">continue</span>; <span class="comment">// Next PC</span>
00773 
00774               <span class="comment">//</span>
00775               <span class="comment">// Store word (save a GPR)</span>
00776               <span class="comment">//</span>
00777               <span class="keywordflow">case</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a17">InstrSTW</a>:
00778               <span class="comment">//</span>
00779               <span class="comment">// Even though a stw  r.sp, xxxx in general is an invalid</span>
00780               <span class="comment">// proloque instruction there are places in the kernel</span>
00781               <span class="comment">// fake prologues (KiExceptionExit) where we must use this,</span>
00782               <span class="comment">// so handle it.</span>
00783               <span class="comment">//</span>
00784                 <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a0">READ_ULONG</a> (Address, IntegerRegister[Rt]);
00785                 <span class="keywordflow">if</span> (ARGUMENT_PRESENT (ContextPointers))
00786                     ContextPointers-&gt;IntegerContext[Rt] = (PULONG) Address;
00787                 <span class="keywordflow">continue</span>; <span class="comment">// Next PC</span>
00788 
00789               <span class="comment">//</span>
00790               <span class="comment">// Store word with update, Store word with update indexed</span>
00791               <span class="comment">// (buy stack frame, updating stack pointer and link</span>
00792               <span class="comment">// cell in storage)</span>
00793               <span class="comment">//</span>
00794               <span class="keywordflow">case</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a18">InstrSTWU</a>:
00795                 Address = IntegerRegister[<a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a1">GPR1</a>];
00796                 <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a0">READ_ULONG</a>(Address,IntegerRegister[<a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a1">GPR1</a>]);
00797                 <span class="keywordflow">if</span> (RestoredSp == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
00798                     <a class="code" href="../../d9/d6/ia64_2vunwind_8c.html#a0">NOT_IMAGEHLP</a> (*EstablisherFrame =
00799                                   EstablisherFrameValue = ContextRecord-&gt;Gpr1);
00800                     RestoredSp = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00801                 }
00802                 <span class="keywordflow">if</span> (ARGUMENT_PRESENT (ContextPointers))
00803                     ContextPointers-&gt;IntegerContext[Rt] = (PULONG) Address;
00804                 <span class="keywordflow">continue</span>; <span class="comment">// Next PC</span>
00805 
00806               <span class="comment">//</span>
00807               <span class="comment">// Store floating point double (save an FPR)</span>
00808               <span class="comment">//</span>
00809               <span class="keywordflow">case</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a20">InstrSTFD</a>:
00810                 <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a1">READ_DOUBLE</a> (Address, FloatingRegister[Rt]);
00811                 <span class="keywordflow">if</span> (ARGUMENT_PRESENT (ContextPointers))
00812                     ContextPointers-&gt;FloatingContext[Rt] = (<a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a7">PDOUBLE</a>) Address;
00813                 <span class="keywordflow">continue</span>; <span class="comment">// Next PC</span>
00814 
00815               <span class="comment">//</span>
00816               <span class="comment">// Move register.  Certain forms are ignored based on the intent.</span>
00817               <span class="comment">//</span>
00818               <span class="keywordflow">case</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a21">InstrMR</a>:
00819                 IntegerRegister[I.Xform_RA] = IntegerRegister[Rt];
00820                 <span class="keywordflow">continue</span>; <span class="comment">// Next PC</span>
00821               <span class="keywordflow">case</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a23">InstrMRfwd</a>:
00822                 IntegerRegister[Rt] = IntegerRegister[I.Xform_RA];
00823                 <span class="keywordflow">continue</span>; <span class="comment">// Next PC</span>
00824               <span class="keywordflow">case</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a22">InstrMRr12</a>:
00825                 IntegerRegister[Rt] = IntegerRegister[I.Xform_RA];
00826                 <span class="keywordflow">break</span>; <span class="comment">// Terminate search--start next iterator.</span>
00827 
00828               <span class="comment">//</span>
00829               <span class="comment">// Add immediate.  Certain forms are ignored based on the intent.</span>
00830               <span class="comment">//</span>
00831               <span class="keywordflow">case</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a25">InstrADDIfwd</a>:
00832                 IntegerRegister[Rt] = Address;
00833                 <span class="keywordflow">continue</span>; <span class="comment">// Next PC</span>
00834               <span class="keywordflow">case</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a24">InstrADDIr12</a>:
00835                 <span class="keywordflow">if</span> (!ComputedSp) {
00836                   <span class="comment">// No intervening instruction changes r.1, so compute</span>
00837                   <span class="comment">// addi r.12,r.1,N instead of addi r.12,r.12,N.</span>
00838                   IntegerRegister[Rt] = IntegerRegister[<a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a1">GPR1</a>];
00839                 }
00840                 IntegerRegister[Rt] += I.Dform_SI;
00841                 <span class="keywordflow">break</span>; <span class="comment">// Terminate search--start next iterator.</span>
00842 
00843               <span class="comment">//</span>
00844               <span class="comment">// Store with update while searching for the value of r.12</span>
00845               <span class="comment">//</span>
00846               <span class="keywordflow">case</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a19">InstrSTWUr12</a>:
00847                 ComputedSp = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00848                 Address = IntegerRegister[<a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a1">GPR1</a>];
00849                 <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a0">READ_ULONG</a>(Address,IntegerRegister[<a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a3">GPR12</a>]);
00850                 <span class="keywordflow">continue</span>; <span class="comment">// Next PC</span>
00851 
00852               <span class="comment">//</span>
00853               <span class="comment">// A call to a register save millicode.</span>
00854               <span class="comment">//</span>
00855               <span class="keywordflow">case</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a26">InstrSaveCode</a>:
00856                 <span class="comment">//</span>
00857                 <span class="comment">// Push an iterator to incorporate the actions of the</span>
00858                 <span class="comment">// millicode.</span>
00859                 <span class="comment">//</span>
00860                 Piterator++;
00861                 Piterator-&gt;<a class="code" href="../../d6/d4/struct__ITERATOR.html#o0">BeginPc</a> = Info.<a class="code" href="../../d6/d9/struct__MILLICODE__INFO.html#o1">FunctionEntry</a>-&gt;EndAddress - 4;
00862                 Piterator-&gt;<a class="code" href="../../d6/d4/struct__ITERATOR.html#o1">EndPc</a> = Info.<a class="code" href="../../d6/d9/struct__MILLICODE__INFO.html#o0">TargetPc</a> - 4;
00863                 Piterator-&gt;<a class="code" href="../../d6/d4/struct__ITERATOR.html#o2">Increment</a> = -4;
00864                 Piterator-&gt;<a class="code" href="../../d6/d4/struct__ITERATOR.html#o3">Intent</a> = <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a40a35">UnwindReverseR12</a>;
00865                 <span class="comment">//</span>
00866                 <span class="comment">// Push an iterator to determine the current value of r.12</span>
00867                 <span class="comment">//</span>
00868                 Piterator++;
00869                 Piterator-&gt;<a class="code" href="../../d6/d4/struct__ITERATOR.html#o0">BeginPc</a> = Pc - 4;
00870                 Piterator-&gt;<a class="code" href="../../d6/d4/struct__ITERATOR.html#o1">EndPc</a> = Piterator[-2].<a class="code" href="../../d6/d4/struct__ITERATOR.html#o1">EndPc</a>;
00871                 Piterator-&gt;<a class="code" href="../../d6/d4/struct__ITERATOR.html#o2">Increment</a> = -4;
00872                 Piterator-&gt;<a class="code" href="../../d6/d4/struct__ITERATOR.html#o3">Intent</a> = <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a40a33">UnwindR12</a>;
00873                 ComputedSp = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00874                 <span class="comment">//</span>
00875                 <span class="comment">// Update the start of the original iterator so it can later</span>
00876                 <span class="comment">// resume where it left off.</span>
00877                 <span class="comment">//</span>
00878                 Piterator[-2].<a class="code" href="../../d6/d4/struct__ITERATOR.html#o0">BeginPc</a> = Pc - 4;
00879                 Piterator++;
00880                 <span class="keywordflow">break</span>; <span class="comment">// Start the next iterator.</span>
00881 
00882               <span class="comment">//</span>
00883               <span class="comment">// A branch was encountered in the prologue to a routine</span>
00884               <span class="comment">// identified as glue code.  This should only happen from</span>
00885               <span class="comment">// fake prologues such as those in the system exception</span>
00886               <span class="comment">// handler.</span>
00887               <span class="comment">//</span>
00888               <span class="comment">// We handle it by pushing an iterator to incorporate</span>
00889               <span class="comment">// the actions of the glue code prologue.</span>
00890               <span class="comment">//</span>
00891               <span class="keywordflow">case</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a28">InstrGlue</a>:
00892                 <span class="comment">//</span>
00893                 <span class="comment">// Check that we don't nest too deeply.  Verify that</span>
00894                 <span class="comment">// we can push this iterator and the iterators for a</span>
00895                 <span class="comment">// glue sequence.  There's no need to make this check</span>
00896                 <span class="comment">// elsewhere because B_OP is only recognized during</span>
00897                 <span class="comment">// UnwindReverse.  Returing zero is the only error action</span>
00898                 <span class="comment">// we have.</span>
00899                 <span class="comment">//</span>
00900                 <span class="keywordflow">if</span> (Piterator - Iterator + 4
00901                     &gt; <span class="keyword">sizeof</span> (Iterator) / <span class="keyword">sizeof</span> (Iterator[0]))
00902                     <span class="keywordflow">return</span> 0;
00903                 <span class="comment">//</span>
00904                 <span class="comment">// Push an iterator to incorporate the actions of the glue</span>
00905                 <span class="comment">// code's prologue.  Check that we don't nest too deeply.</span>
00906                 <span class="comment">// Verify that we can push this iterator and the iterators</span>
00907                 <span class="comment">// for a glue sequence.</span>
00908                 <span class="comment">//</span>
00909                 Piterator++;
00910                 Piterator-&gt;<a class="code" href="../../d6/d4/struct__ITERATOR.html#o0">BeginPc</a>
00911                   = (Info.<a class="code" href="../../d6/d9/struct__MILLICODE__INFO.html#o1">FunctionEntry</a>-&gt;PrologEndAddress &amp; ~3) - 4;
00912                 Piterator-&gt;<a class="code" href="../../d6/d4/struct__ITERATOR.html#o1">EndPc</a> = Info.<a class="code" href="../../d6/d9/struct__MILLICODE__INFO.html#o1">FunctionEntry</a>-&gt;BeginAddress - 4;
00913                 Piterator-&gt;<a class="code" href="../../d6/d4/struct__ITERATOR.html#o2">Increment</a> = -4;
00914                 Piterator-&gt;<a class="code" href="../../d6/d4/struct__ITERATOR.html#o3">Intent</a> = <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a40a34">UnwindReverse</a>;
00915                 <span class="comment">//</span>
00916                 <span class="comment">// Update the start of the original iterator so it can later</span>
00917                 <span class="comment">// resume where it left off.</span>
00918                 <span class="comment">//</span>
00919                 Piterator[-1].<a class="code" href="../../d6/d4/struct__ITERATOR.html#o0">BeginPc</a> = Pc - 4;
00920                 Piterator++;
00921                 <span class="keywordflow">break</span>; <span class="comment">// Start the next iterator.</span>
00922 
00923               <span class="comment">//</span>
00924               <span class="comment">// Special "set establisher" instruction (rfi).</span>
00925               <span class="comment">//</span>
00926               <span class="comment">// Kernel fake prologues that can't use stwu (KiExceptionExit,</span>
00927               <span class="comment">// KiAlternateExit) use an rfi instruction to tell the</span>
00928               <span class="comment">// unwinder to update the establisher frame pointer using</span>
00929               <span class="comment">// the current value of sp.</span>
00930               <span class="comment">//</span>
00931               <span class="keywordflow">case</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a31">InstrSetEstablisher</a>:
00932                 <a class="code" href="../../d9/d6/ia64_2vunwind_8c.html#a0">NOT_IMAGEHLP</a> (*EstablisherFrame =
00933                                   EstablisherFrameValue = ContextRecord-&gt;Gpr1);
00934                 <span class="keywordflow">continue</span>; <span class="comment">// Next PC</span>
00935 
00936               <span class="comment">//</span>
00937               <span class="comment">// None of the above.  Just ignore the instruction.  It</span>
00938               <span class="comment">// is presumed to be non-prologue code that has been</span>
00939               <span class="comment">// merged into the prologue for scheduling purposes.  It</span>
00940               <span class="comment">// may also be improper code in a register save/restore</span>
00941               <span class="comment">// millicode routine or unimportant code when</span>
00942               <span class="comment">// determining the value of r.12.</span>
00943               <span class="comment">//</span>
00944               <span class="keywordflow">case</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a39a14">InstrIgnore</a>:
00945               <span class="keywordflow">default</span>:
00946                 <span class="keywordflow">continue</span>; <span class="comment">// Next PC</span>
00947             }
00948             <span class="keywordflow">break</span>; <span class="comment">// Start the next iterator.</span>
00949         } <span class="comment">// end foreach Pc</span>
00950     } <span class="comment">// end foreach Iterator</span>
00951 
00952   CheckForGlue:
00953     <span class="comment">//</span>
00954     <span class="comment">// Check that we aren't at the end of the call chain.  We now require</span>
00955     <span class="comment">// that the link register at program start-up be zero.  Unfortunately,</span>
00956     <span class="comment">// this isn't always true.  Also verify that the stack pointer remains</span>
00957     <span class="comment">// valid.</span>
00958     <span class="comment">//</span>
00959     <span class="keywordflow">if</span> (NextPc == 0 || NextPc + 4 == 0
00960 <span class="preprocessor">#ifdef _IMAGEHLP_SOURCE_</span>
00961 <span class="preprocessor"></span>        || NextPc == 1
00962 <span class="preprocessor">#else</span>
00963 <span class="preprocessor"></span>        || EstablisherFrameValue &lt; LowStackLimit
00964         || EstablisherFrameValue &gt; HighStackLimit
00965         || (EstablisherFrameValue &amp; 0x7) != 0
00966 <span class="preprocessor">#endif</span>
00967 <span class="preprocessor"></span>        )
00968         <span class="keywordflow">return</span> NextPc;
00969 
00970     <span class="comment">//</span>
00971     <span class="comment">// Is the instruction at NextPc an branch?</span>
00972     <span class="comment">//</span>
00973 <span class="preprocessor">#ifdef _IMAGEHLP_SOURCE_</span>
00974 <span class="preprocessor"></span>    <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a0">READ_ULONG</a> (NextPc, I.Long);
00975 <span class="preprocessor">#else</span>
00976 <span class="preprocessor"></span>    <span class="keywordflow">if</span> ( !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a36">TryReadUlong</a>(NextPc, &amp;I.Long)) ) {
00977         <span class="keywordflow">return</span> NextPc;
00978     }
00979 <span class="preprocessor">#endif</span>
00980 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (I.Primary_Op != B_OP)
00981         <span class="keywordflow">return</span> NextPc;
00982 
00983     <span class="comment">//</span>
00984     <span class="comment">// Compute branch target address, allowing for branch-relative</span>
00985     <span class="comment">// and branch-absolute.</span>
00986     <span class="comment">//</span>
00987     Pc = ((LONG)(I.Iform_LI) &lt;&lt; 2) + (I.Iform_AA ? 0 : NextPc);
00988 
00989     <span class="comment">//</span>
00990     <span class="comment">// If the branch target is contained in this function table entry,</span>
00991     <span class="comment">// either this function is glue or it wasn't called via glue.  This</span>
00992     <span class="comment">// is the usual case.</span>
00993     <span class="comment">//</span>
00994     <span class="keywordflow">if</span> (FunctionEntry != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>
00995         &amp;&amp; Pc &gt;= FunctionEntry-&gt;BeginAddress
00996         &amp;&amp; Pc &lt; FunctionEntry-&gt;EndAddress)
00997         <span class="keywordflow">return</span> NextPc;
00998 
00999     <span class="comment">//</span>
01000     <span class="comment">// Allow for a stub glue in the thunk and a common ptrgl function</span>
01001     <span class="comment">// where the stub glue does not have a function table entry.</span>
01002     <span class="comment">//</span>
01003 
01004     <span class="keywordflow">if</span> ((FunctionEntry = (PRUNTIME_FUNCTION)<a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a8">RtlLookupFunctionEntry</a>(Pc)) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01005         <span class="comment">//</span>
01006         <span class="comment">// The target instruction must be "lwz r.x,disp(r.2)".</span>
01007         <span class="comment">//</span>
01008         <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a0">READ_ULONG</a> (Pc, I.Long);
01009         <span class="keywordflow">if</span> (I.Primary_Op == LWZ_OP &amp;&amp; I.Dform_RA == <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a2">GPR2</a>) {
01010             <span class="comment">//</span>
01011             <span class="comment">// The next instruction must be "b glue-code".</span>
01012             <span class="comment">//</span>
01013             <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a0">READ_ULONG</a> (Pc + 4, I.Long);
01014             <span class="keywordflow">if</span> (I.Primary_Op == B_OP &amp;&amp; I.Iform_LK) {
01015                 <span class="comment">//</span>
01016                 <span class="comment">// Compute branch target address, allowing for</span>
01017                 <span class="comment">// branch-relative and branch-absolute.</span>
01018                 <span class="comment">//</span>
01019                 Pc = ((LONG)(I.Iform_LI) &lt;&lt; 2) + (I.Iform_AA ? 0 : Pc + 4);
01020                 FunctionEntry = (PRUNTIME_FUNCTION)<a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a8">RtlLookupFunctionEntry</a>(Pc);
01021             }
01022         }
01023     }
01024 
01025     <span class="comment">//</span>
01026     <span class="comment">// Determine whether the branch target is glue code.</span>
01027     <span class="comment">//</span>
01028     <span class="keywordflow">if</span> (!(FunctionEntry != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>
01029 <span class="preprocessor">#ifndef FUNCTION_ENTRY_IS_IMAGE_STYLE</span>
01030 <span class="preprocessor"></span>          &amp;&amp; FunctionEntry-&gt;ExceptionHandler == 0
01031           &amp;&amp; (ULONG)FunctionEntry-&gt;HandlerData == 3
01032 <span class="preprocessor">#else</span>
01033 <span class="preprocessor"></span>          &amp;&amp; (FunctionEntry-&gt;BeginAddress &lt;
01034               FunctionEntry-&gt;PrologEndAddress)
01035           &amp;&amp; (FunctionEntry-&gt;PrologEndAddress &amp; 3) == 1
01036 <span class="preprocessor">#endif</span>
01037 <span class="preprocessor"></span>          ))
01038         <span class="keywordflow">return</span> NextPc;
01039 
01040     <span class="comment">//</span>
01041     <span class="comment">// Unwind the glue code prologue.  We won't loop because</span>
01042     <span class="comment">// next time through, the branch target will be contained in</span>
01043     <span class="comment">// the function table entry.</span>
01044     <span class="comment">//</span>
01045 <span class="preprocessor">#ifdef _IMAGEHLP_SOURCE_</span>
01046 <span class="preprocessor"></span>    SavedFunctionEntry = *FunctionEntry;
01047     FunctionEntry = &amp;SavedFunctionEntry;
01048 <span class="preprocessor">#endif</span>
01049 <span class="preprocessor"></span>    Iterator[0].EndPc = FunctionEntry-&gt;BeginAddress - 4;
01050     Iterator[0].Increment = -4;
01051     Iterator[0].Intent = <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a40a34">UnwindReverse</a>;
01052     Iterator[0].BeginPc = ((FunctionEntry-&gt;PrologEndAddress &amp; ~3) - 4);
01053     <span class="keywordflow">goto</span> UnwindGlue;
01054 }
01055 
01056 <span class="preprocessor">#undef NOT_IMAGEHLP</span>
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:42:24 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
