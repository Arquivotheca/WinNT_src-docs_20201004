<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: cache.h File Reference</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>cache.h File Reference</h1>
<p>
<a href="../../d5/d1/cache_8h-source.html">Go to the source code of this file.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d8/d1/struct__PUBLIC__BCB.html">_PUBLIC_BCB</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d1/d9/struct__CC__FILE__SIZES.html">_CC_FILE_SIZES</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d3/d6/struct__CACHE__MANAGER__CALLBACKS.html">_CACHE_MANAGER_CALLBACKS</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d6/struct__CACHE__UNINITIALIZE__EVENT.html">_CACHE_UNINITIALIZE_EVENT</a></td></tr>

<tr><td colspan=2><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a0">VACB_MAPPING_GRANULARITY</a>&nbsp;&nbsp;&nbsp;(0x40000)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a1">VACB_OFFSET_SHIFT</a>&nbsp;&nbsp;&nbsp;(18)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a2">CcIsFileCached</a>(FO)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a3">CcGetFileSizePointer</a>(FO)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a4">CcCopyWriteWontFlush</a>(FO, FOFF, LEN)&nbsp;&nbsp;&nbsp;((LEN) &lt;= 0X10000)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a5">CcReadAhead</a>(FO, FOFF, LEN)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a6">PIN_WAIT</a>&nbsp;&nbsp;&nbsp;(1)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a7">PIN_EXCLUSIVE</a>&nbsp;&nbsp;&nbsp;(2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a8">PIN_NO_READ</a>&nbsp;&nbsp;&nbsp;(4)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a9">PIN_IF_BCB</a>&nbsp;&nbsp;&nbsp;(8)</td></tr>

<tr><td colspan=2><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef <a class="el" href="../../d8/d1/struct__PUBLIC__BCB.html">_PUBLIC_BCB</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a10">PUBLIC_BCB</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>typedef <a class="el" href="../../d8/d1/struct__PUBLIC__BCB.html">_PUBLIC_BCB</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a11">PPUBLIC_BCB</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>typedef <a class="el" href="../../d1/d9/struct__CC__FILE__SIZES.html">_CC_FILE_SIZES</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a12">CC_FILE_SIZES</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>typedef <a class="el" href="../../d1/d9/struct__CC__FILE__SIZES.html">_CC_FILE_SIZES</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a13">PCC_FILE_SIZES</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>typedef BOOLEAN(*&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a14">PACQUIRE_FOR_LAZY_WRITE</a> )(IN PVOID Context, IN BOOLEAN Wait)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>typedef VOID(*&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a15">PRELEASE_FROM_LAZY_WRITE</a> )(IN PVOID Context)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>typedef BOOLEAN(*&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a16">PACQUIRE_FOR_READ_AHEAD</a> )(IN PVOID Context, IN BOOLEAN Wait)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>typedef VOID(*&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a17">PRELEASE_FROM_READ_AHEAD</a> )(IN PVOID Context)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>typedef <a class="el" href="../../d3/d6/struct__CACHE__MANAGER__CALLBACKS.html">_CACHE_MANAGER_CALLBACKS</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a18">CACHE_MANAGER_CALLBACKS</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>typedef <a class="el" href="../../d3/d6/struct__CACHE__MANAGER__CALLBACKS.html">_CACHE_MANAGER_CALLBACKS</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a19">PCACHE_MANAGER_CALLBACKS</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>typedef <a class="el" href="../../d4/d6/struct__CACHE__UNINITIALIZE__EVENT.html">_CACHE_UNINITIALIZE_EVENT</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a20">CACHE_UNINITIALIZE_EVENT</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>typedef <a class="el" href="../../d4/d6/struct__CACHE__UNINITIALIZE__EVENT.html">_CACHE_UNINITIALIZE_EVENT</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a21">PCACHE_UNINITIALIZE_EVENT</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>typedef VOID(*&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a22">PDIRTY_PAGE_ROUTINE</a> )(IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject, IN PLARGE_INTEGER FileOffset, IN ULONG Length, IN PLARGE_INTEGER OldestLsn, IN PLARGE_INTEGER NewestLsn, IN PVOID <a class="el" href="../../d3/d1/threads_8h.html#a107">Context1</a>, IN PVOID <a class="el" href="../../d3/d1/threads_8h.html#a108">Context2</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>typedef VOID(*&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a23">PFLUSH_TO_LSN</a> )(IN PVOID LogHandle, IN LARGE_INTEGER Lsn)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>typedef VOID(*&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a56">PCC_POST_DEFERRED_WRITE</a> )(IN PVOID <a class="el" href="../../d3/d1/threads_8h.html#a107">Context1</a>, IN PVOID <a class="el" href="../../d3/d1/threads_8h.html#a108">Context2</a>)</td></tr>

<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>NTKERNELAPI BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a57">CcInitializeCacheManager</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTKERNELAPI VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a58">CcInitializeCacheMap</a> (IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject, IN <a class="el" href="../../d1/d9/struct__CC__FILE__SIZES.html">PCC_FILE_SIZES</a> FileSizes, IN BOOLEAN PinAccess, IN <a class="el" href="../../d3/d6/struct__CACHE__MANAGER__CALLBACKS.html">PCACHE_MANAGER_CALLBACKS</a> Callbacks, IN PVOID LazyWriteContext)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTKERNELAPI BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a59">CcUninitializeCacheMap</a> (IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject, IN PLARGE_INTEGER TruncateSize OPTIONAL, IN <a class="el" href="../../d4/d6/struct__CACHE__UNINITIALIZE__EVENT.html">PCACHE_UNINITIALIZE_EVENT</a> UninitializeCompleteEvent OPTIONAL)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTKERNELAPI VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a60">CcSetFileSizes</a> (IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject, IN <a class="el" href="../../d1/d9/struct__CC__FILE__SIZES.html">PCC_FILE_SIZES</a> FileSizes)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTKERNELAPI BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a61">CcPurgeCacheSection</a> (IN <a class="el" href="../../d7/d0/struct__SECTION__OBJECT__POINTERS.html">PSECTION_OBJECT_POINTERS</a> SectionObjectPointer, IN PLARGE_INTEGER FileOffset OPTIONAL, IN ULONG Length, IN BOOLEAN UninitializeCacheMaps)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTKERNELAPI VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a62">CcSetDirtyPageThreshold</a> (IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject, IN ULONG DirtyPageThreshold)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTKERNELAPI VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a63">CcFlushCache</a> (IN <a class="el" href="../../d7/d0/struct__SECTION__OBJECT__POINTERS.html">PSECTION_OBJECT_POINTERS</a> SectionObjectPointer, IN PLARGE_INTEGER FileOffset OPTIONAL, IN ULONG Length, OUT PIO_STATUS_BLOCK IoStatus OPTIONAL)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTKERNELAPI LARGE_INTEGER&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a64">CcGetFlushedValidData</a> (IN <a class="el" href="../../d7/d0/struct__SECTION__OBJECT__POINTERS.html">PSECTION_OBJECT_POINTERS</a> SectionObjectPointer, IN BOOLEAN BcbListHeld)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTKERNELAPI VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a65">CcZeroEndOfLastPage</a> (IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTKERNELAPI BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a66">CcZeroData</a> (IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject, IN PLARGE_INTEGER StartOffset, IN PLARGE_INTEGER EndOffset, IN BOOLEAN Wait)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTKERNELAPI PVOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a67">CcRemapBcb</a> (IN PVOID Bcb)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTKERNELAPI VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a68">CcRepinBcb</a> (IN PVOID Bcb)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTKERNELAPI VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a69">CcUnpinRepinnedBcb</a> (IN PVOID Bcb, IN BOOLEAN WriteThrough, OUT PIO_STATUS_BLOCK IoStatus)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTKERNELAPI <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a70">CcGetFileObjectFromSectionPtrs</a> (IN <a class="el" href="../../d7/d0/struct__SECTION__OBJECT__POINTERS.html">PSECTION_OBJECT_POINTERS</a> SectionObjectPointer)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTKERNELAPI <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a71">CcGetFileObjectFromBcb</a> (IN PVOID Bcb)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTKERNELAPI BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a72">CcCanIWrite</a> (IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject, IN ULONG BytesToWrite, IN BOOLEAN Wait, IN BOOLEAN Retrying)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTKERNELAPI VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a73">CcDeferWrite</a> (IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject, IN <a class="el" href="../../d4/d2/cache_8h.html#a56">PCC_POST_DEFERRED_WRITE</a> PostRoutine, IN PVOID <a class="el" href="../../d3/d1/threads_8h.html#a107">Context1</a>, IN PVOID <a class="el" href="../../d3/d1/threads_8h.html#a108">Context2</a>, IN ULONG BytesToWrite, IN BOOLEAN Retrying)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTKERNELAPI BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a74">CcCopyRead</a> (IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject, IN PLARGE_INTEGER FileOffset, IN ULONG Length, IN BOOLEAN Wait, OUT PVOID <a class="el" href="../../d8/d6/ttri_8c.html#a3">Buffer</a>, OUT PIO_STATUS_BLOCK IoStatus)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTKERNELAPI VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a75">CcFastCopyRead</a> (IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject, IN ULONG FileOffset, IN ULONG Length, IN ULONG PageCount, OUT PVOID <a class="el" href="../../d8/d6/ttri_8c.html#a3">Buffer</a>, OUT PIO_STATUS_BLOCK IoStatus)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTKERNELAPI BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a76">CcCopyWrite</a> (IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject, IN PLARGE_INTEGER FileOffset, IN ULONG Length, IN BOOLEAN Wait, IN PVOID <a class="el" href="../../d8/d6/ttri_8c.html#a3">Buffer</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTKERNELAPI VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a77">CcFastCopyWrite</a> (IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject, IN ULONG FileOffset, IN ULONG Length, IN PVOID <a class="el" href="../../d8/d6/ttri_8c.html#a3">Buffer</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTKERNELAPI VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a78">CcMdlRead</a> (IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject, IN PLARGE_INTEGER FileOffset, IN ULONG Length, OUT <a class="el" href="../../d6/d7/struct__MDL.html">PMDL</a> *MdlChain, OUT PIO_STATUS_BLOCK IoStatus)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTKERNELAPI VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a79">CcMdlReadComplete</a> (IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject, IN <a class="el" href="../../d6/d7/struct__MDL.html">PMDL</a> MdlChain)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTKERNELAPI VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a80">CcMdlReadComplete2</a> (IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject, IN <a class="el" href="../../d6/d7/struct__MDL.html">PMDL</a> MdlChain)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTKERNELAPI VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a81">CcPrepareMdlWrite</a> (IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject, IN PLARGE_INTEGER FileOffset, IN ULONG Length, OUT <a class="el" href="../../d6/d7/struct__MDL.html">PMDL</a> *MdlChain, OUT PIO_STATUS_BLOCK IoStatus)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTKERNELAPI VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a82">CcMdlWriteComplete</a> (IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject, IN PLARGE_INTEGER FileOffset, IN <a class="el" href="../../d6/d7/struct__MDL.html">PMDL</a> MdlChain)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTKERNELAPI VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a83">CcMdlWriteComplete2</a> (IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject, IN PLARGE_INTEGER FileOffset, IN <a class="el" href="../../d6/d7/struct__MDL.html">PMDL</a> MdlChain)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTKERNELAPI VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a84">CcScheduleReadAhead</a> (IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject, IN PLARGE_INTEGER FileOffset, IN ULONG Length)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a85">CcWaitForCurrentLazyWriterActivity</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTKERNELAPI VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a86">CcSetReadAheadGranularity</a> (IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject, IN ULONG Granularity)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTKERNELAPI BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a87">CcPinRead</a> (IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject, IN PLARGE_INTEGER FileOffset, IN ULONG Length, IN ULONG Flags, OUT PVOID *Bcb, OUT PVOID *<a class="el" href="../../d8/d6/ttri_8c.html#a3">Buffer</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTKERNELAPI BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a88">CcMapData</a> (IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject, IN PLARGE_INTEGER FileOffset, IN ULONG Length, IN BOOLEAN Wait, OUT PVOID *Bcb, OUT PVOID *<a class="el" href="../../d8/d6/ttri_8c.html#a3">Buffer</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTKERNELAPI BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a89">CcPinMappedData</a> (IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject, IN PLARGE_INTEGER FileOffset, IN ULONG Length, IN ULONG Flags, IN OUT PVOID *Bcb)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTKERNELAPI BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a90">CcPreparePinWrite</a> (IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject, IN PLARGE_INTEGER FileOffset, IN ULONG Length, IN BOOLEAN <a class="el" href="../../d6/d6/ttime_8c.html#a0">Zero</a>, IN ULONG Flags, OUT PVOID *Bcb, OUT PVOID *<a class="el" href="../../d8/d6/ttri_8c.html#a3">Buffer</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTKERNELAPI VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a91">CcSetDirtyPinnedData</a> (IN PVOID BcbVoid, IN PLARGE_INTEGER Lsn OPTIONAL)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTKERNELAPI VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a92">CcUnpinData</a> (IN PVOID Bcb)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTKERNELAPI VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a93">CcSetBcbOwnerPointer</a> (IN PVOID Bcb, IN PVOID OwnerPointer)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTKERNELAPI VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a94">CcUnpinDataForThread</a> (IN PVOID Bcb, IN <a class="el" href="../../d5/d8/ex_8h.html#a121">ERESOURCE_THREAD</a> ResourceThreadId)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTKERNELAPI VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a95">CcSetAdditionalCacheAttributes</a> (IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject, IN BOOLEAN DisableReadAhead, IN BOOLEAN DisableWriteBehind)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTKERNELAPI VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a96">CcSetLogHandleForFile</a> (IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject, IN PVOID LogHandle, IN <a class="el" href="../../d4/d2/cache_8h.html#a23">PFLUSH_TO_LSN</a> FlushToLsnRoutine)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTKERNELAPI LARGE_INTEGER&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a97">CcGetDirtyPages</a> (IN PVOID LogHandle, IN <a class="el" href="../../d4/d2/cache_8h.html#a22">PDIRTY_PAGE_ROUTINE</a> DirtyPageRoutine, IN PVOID <a class="el" href="../../d3/d1/threads_8h.html#a107">Context1</a>, IN PVOID <a class="el" href="../../d3/d1/threads_8h.html#a108">Context2</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTKERNELAPI BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a98">CcIsThereDirtyData</a> (IN <a class="el" href="../../d7/d7/struct__VPB.html">PVPB</a> Vpb)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTKERNELAPI LARGE_INTEGER&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a99">CcGetLsnForFileObject</a> (IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject, OUT PLARGE_INTEGER OldestLsn OPTIONAL)</td></tr>

<tr><td colspan=2><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>ULONG&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a24">CcThrowAway</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>ULONG&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a25">CcFastReadNoWait</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>ULONG&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a26">CcFastReadWait</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>ULONG&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a27">CcFastReadResourceMiss</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>ULONG&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a28">CcFastReadNotPossible</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>ULONG&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a29">CcFastMdlReadNoWait</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>ULONG&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a30">CcFastMdlReadWait</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>ULONG&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a31">CcFastMdlReadResourceMiss</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>ULONG&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a32">CcFastMdlReadNotPossible</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>ULONG&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a33">CcMapDataNoWait</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>ULONG&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a34">CcMapDataWait</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>ULONG&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a35">CcMapDataNoWaitMiss</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>ULONG&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a36">CcMapDataWaitMiss</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>ULONG&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a37">CcPinMappedDataCount</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>ULONG&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a38">CcPinReadNoWait</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>ULONG&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a39">CcPinReadWait</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>ULONG&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a40">CcPinReadNoWaitMiss</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>ULONG&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a41">CcPinReadWaitMiss</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>ULONG&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a42">CcCopyReadNoWait</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>ULONG&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a43">CcCopyReadWait</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>ULONG&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a44">CcCopyReadNoWaitMiss</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>ULONG&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a45">CcCopyReadWaitMiss</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>ULONG&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a46">CcMdlReadNoWait</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>ULONG&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a47">CcMdlReadWait</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>ULONG&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a48">CcMdlReadNoWaitMiss</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>ULONG&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a49">CcMdlReadWaitMiss</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>ULONG&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a50">CcReadAheadIos</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>ULONG&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a51">CcLazyWriteIos</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>ULONG&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a52">CcLazyWritePages</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>ULONG&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a53">CcDataFlushes</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>ULONG&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a54">CcDataPages</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>PULONG&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d2/cache_8h.html#a55">CcMissCounter</a></td></tr>

</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="a4" doxytag="cache.h::CcCopyWriteWontFlush" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define CcCopyWriteWontFlush          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">FO,         <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>FOFF,         <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>LEN&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;((LEN) &lt;= 0X10000)</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d1/cache_8h-source.html#l00375">375</a> of file <a class="el" href="../../d5/d1/cache_8h-source.html">cache.h</a>.
<p>
Referenced by <a class="el" href="../../d4/d0/fastio_8c-source.html#l00330">FsRtlCopyWrite()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="cache.h::CcGetFileSizePointer" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define CcGetFileSizePointer          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">FO&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><pre class="fragment"><div>(                                     \
    ((PLARGE_INTEGER)((FO)-&gt;SectionObjectPointer-&gt;SharedCacheMap) + 1) \
)
</div></pre>
<p>
Definition at line <a class="el" href="../../d5/d1/cache_8h-source.html#l00277">277</a> of file <a class="el" href="../../d5/d1/cache_8h-source.html">cache.h</a>.
<p>
Referenced by <a class="el" href="../../d4/d0/fastio_8c-source.html#l00330">FsRtlCopyWrite()</a>, and <a class="el" href="../../d4/d0/fastio_8c-source.html#l01474">FsRtlPrepareMdlWriteDev()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a2" doxytag="cache.h::CcIsFileCached" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define CcIsFileCached          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">FO&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><pre class="fragment"><div>(                                                         \
    ((FO)-&gt;SectionObjectPointer != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;                                          \
    (((<a class="code" href="../../d7/d0/struct__SECTION__OBJECT__POINTERS.html">PSECTION_OBJECT_POINTERS</a>)(FO)-&gt;SectionObjectPointer)-&gt;SharedCacheMap != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) \
)
</div></pre>
<p>
Definition at line <a class="el" href="../../d5/d1/cache_8h-source.html#l00173">173</a> of file <a class="el" href="../../d5/d1/cache_8h-source.html">cache.h</a>.
<p>
Referenced by <a class="el" href="../../d5/d5/iosubs_8c-source.html#l10957">IoSynchronousPageWrite()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="cache.h::CcReadAhead" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define CcReadAhead          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">FO,         <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>FOFF,         <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>LEN&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><pre class="fragment"><div>{                       \
    <span class="keywordflow">if</span> ((LEN) &gt;= 256) {                                  \
        <a class="code" href="../../d6/d2/cachesub_8c.html#a15">CcScheduleReadAhead</a>((FO),(FOFF),(LEN));          \
    }                                                    \
}
</div></pre>
<p>
Definition at line <a class="el" href="../../d5/d1/cache_8h-source.html#l00531">531</a> of file <a class="el" href="../../d5/d1/cache_8h-source.html">cache.h</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a7" doxytag="cache.h::PIN_EXCLUSIVE" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define PIN_EXCLUSIVE&nbsp;&nbsp;&nbsp;(2)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d1/cache_8h-source.html#l00590">590</a> of file <a class="el" href="../../d5/d1/cache_8h-source.html">cache.h</a>.
<p>
Referenced by <a class="el" href="../../d7/d1/cachesub_8c-source.html#l00116">CcPinFileData()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a9" doxytag="cache.h::PIN_IF_BCB" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define PIN_IF_BCB&nbsp;&nbsp;&nbsp;(8)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d1/cache_8h-source.html#l00609">609</a> of file <a class="el" href="../../d5/d1/cache_8h-source.html">cache.h</a>.
<p>
Referenced by <a class="el" href="../../d7/d1/cachesub_8c-source.html#l00116">CcPinFileData()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a8" doxytag="cache.h::PIN_NO_READ" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define PIN_NO_READ&nbsp;&nbsp;&nbsp;(4)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d1/cache_8h-source.html#l00600">600</a> of file <a class="el" href="../../d5/d1/cache_8h-source.html">cache.h</a>.
<p>
Referenced by <a class="el" href="../../d7/d1/cachesub_8c-source.html#l00116">CcPinFileData()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="cache.h::PIN_WAIT" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define PIN_WAIT&nbsp;&nbsp;&nbsp;(1)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d1/cache_8h-source.html#l00582">582</a> of file <a class="el" href="../../d5/d1/cache_8h-source.html">cache.h</a>.
<p>
Referenced by <a class="el" href="../../d7/d1/cachesub_8c-source.html#l00116">CcPinFileData()</a>, <a class="el" href="../../d3/d8/pinsup_8c-source.html#l00271">CcPinMappedData()</a>, and <a class="el" href="../../d3/d8/pinsup_8c-source.html#l00524">CcPinRead()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a0" doxytag="cache.h::VACB_MAPPING_GRANULARITY" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define VACB_MAPPING_GRANULARITY&nbsp;&nbsp;&nbsp;(0x40000)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d1/cache_8h-source.html#l00030">30</a> of file <a class="el" href="../../d5/d1/cache_8h-source.html">cache.h</a>.
<p>
Referenced by <a class="el" href="../../d6/d6/copysup_8c-source.html#l00031">CcCopyRead()</a>, <a class="el" href="../../d6/d6/copysup_8c-source.html#l01075">CcCopyWrite()</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l01208">CcCreateVacbArray()</a>, <a class="el" href="../../d6/d6/copysup_8c-source.html#l00588">CcFastCopyRead()</a>, <a class="el" href="../../d6/d6/copysup_8c-source.html#l01482">CcFastCopyWrite()</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l05885">CcFreeActiveVacb()</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00401">CcGetVacbMiss()</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00310">CcGetVirtualAddress()</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00230">CcGetVirtualAddressIfMapped()</a>, <a class="el" href="../../d6/d7/fssup_8c-source.html#l00387">CcInitializeCacheMap()</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l00116">CcPinFileData()</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l01784">CcUnmapVacbArray()</a>, <a class="el" href="../../d5/d7/dirsup_8c-source.html#l00916">UdfLookupDirEntryPostProcessing()</a>, and <a class="el" href="../../d5/d7/dirsup_8c-source.html#l00165">UdfLookupInitialDirEntry()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a1" doxytag="cache.h::VACB_OFFSET_SHIFT" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define VACB_OFFSET_SHIFT&nbsp;&nbsp;&nbsp;(18)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d1/cache_8h-source.html#l00031">31</a> of file <a class="el" href="../../d5/d1/cache_8h-source.html">cache.h</a>.
<p>
Referenced by <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l02335">CcAdjustVacbLevelLockCount()</a>, <a class="el" href="../../d6/d6/copysup_8c-source.html#l00031">CcCopyRead()</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l01208">CcCreateVacbArray()</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l01377">CcExtendVacbArray()</a>, <a class="el" href="../../d6/d6/copysup_8c-source.html#l00588">CcFastCopyRead()</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l02107">CcGetBcbListHeadLargeOffset()</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l02534">CcGetVacbLargeOffset()</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00188">CcInitializeVacbs()</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l02621">CcSetVacbLargeOffset()</a>, and <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00086">SetVacb()</a>.    </td>
  </tr>
</table>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="a18" doxytag="cache.h::CACHE_MANAGER_CALLBACKS" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef struct <a class="el" href="../../d3/d6/struct__CACHE__MANAGER__CALLBACKS.html">_CACHE_MANAGER_CALLBACKS</a>  <a class="el" href="../../d3/d6/struct__CACHE__MANAGER__CALLBACKS.html">CACHE_MANAGER_CALLBACKS</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a20" doxytag="cache.h::CACHE_UNINITIALIZE_EVENT" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef struct <a class="el" href="../../d4/d6/struct__CACHE__UNINITIALIZE__EVENT.html">_CACHE_UNINITIALIZE_EVENT</a>  <a class="el" href="../../d4/d6/struct__CACHE__UNINITIALIZE__EVENT.html">CACHE_UNINITIALIZE_EVENT</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a12" doxytag="cache.h::CC_FILE_SIZES" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef struct <a class="el" href="../../d1/d9/struct__CC__FILE__SIZES.html">_CC_FILE_SIZES</a>  <a class="el" href="../../d1/d9/struct__CC__FILE__SIZES.html">CC_FILE_SIZES</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a14" doxytag="cache.h::PACQUIRE_FOR_LAZY_WRITE" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef BOOLEAN(* <a class="el" href="../../d4/d2/cache_8h.html#a14">PACQUIRE_FOR_LAZY_WRITE</a>)(IN PVOID Context, IN BOOLEAN Wait)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d1/cache_8h-source.html#l00090">90</a> of file <a class="el" href="../../d5/d1/cache_8h-source.html">cache.h</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a16" doxytag="cache.h::PACQUIRE_FOR_READ_AHEAD" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef BOOLEAN(* <a class="el" href="../../d4/d2/cache_8h.html#a16">PACQUIRE_FOR_READ_AHEAD</a>)(IN PVOID Context, IN BOOLEAN Wait)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d1/cache_8h-source.html#l00109">109</a> of file <a class="el" href="../../d5/d1/cache_8h-source.html">cache.h</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a19" doxytag="cache.h::PCACHE_MANAGER_CALLBACKS" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef struct <a class="el" href="../../d3/d6/struct__CACHE__MANAGER__CALLBACKS.html">_CACHE_MANAGER_CALLBACKS</a> * <a class="el" href="../../d3/d6/struct__CACHE__MANAGER__CALLBACKS.html">PCACHE_MANAGER_CALLBACKS</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a21" doxytag="cache.h::PCACHE_UNINITIALIZE_EVENT" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef struct <a class="el" href="../../d4/d6/struct__CACHE__UNINITIALIZE__EVENT.html">_CACHE_UNINITIALIZE_EVENT</a> * <a class="el" href="../../d4/d6/struct__CACHE__UNINITIALIZE__EVENT.html">PCACHE_UNINITIALIZE_EVENT</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a13" doxytag="cache.h::PCC_FILE_SIZES" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef struct <a class="el" href="../../d1/d9/struct__CC__FILE__SIZES.html">_CC_FILE_SIZES</a> * <a class="el" href="../../d1/d9/struct__CC__FILE__SIZES.html">PCC_FILE_SIZES</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Referenced by <a class="el" href="../../d8/d4/udfs_2read_8c-source.html#l00068">UdfCommonRead()</a>, and <a class="el" href="../../d3/d5/allocsup_8c-source.html#l01177">UdfLookupMetaVsnOfExtent()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a56" doxytag="cache.h::PCC_POST_DEFERRED_WRITE" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef VOID(* <a class="el" href="../../d4/d2/cache_8h.html#a56">PCC_POST_DEFERRED_WRITE</a>)(IN PVOID <a class="el" href="../../d3/d1/threads_8h.html#a107">Context1</a>, IN PVOID <a class="el" href="../../d3/d1/threads_8h.html#a108">Context2</a>)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d1/cache_8h-source.html#l00387">387</a> of file <a class="el" href="../../d5/d1/cache_8h-source.html">cache.h</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a22" doxytag="cache.h::PDIRTY_PAGE_ROUTINE" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef VOID(* <a class="el" href="../../d4/d2/cache_8h.html#a22">PDIRTY_PAGE_ROUTINE</a>)(IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject, IN PLARGE_INTEGER FileOffset, IN ULONG Length, IN PLARGE_INTEGER OldestLsn, IN PLARGE_INTEGER NewestLsn, IN PVOID <a class="el" href="../../d3/d1/threads_8h.html#a107">Context1</a>, IN PVOID <a class="el" href="../../d3/d1/threads_8h.html#a108">Context2</a>)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d1/cache_8h-source.html#l00148">148</a> of file <a class="el" href="../../d5/d1/cache_8h-source.html">cache.h</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a23" doxytag="cache.h::PFLUSH_TO_LSN" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef VOID(* <a class="el" href="../../d4/d2/cache_8h.html#a23">PFLUSH_TO_LSN</a>)(IN PVOID LogHandle, IN LARGE_INTEGER Lsn)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d1/cache_8h-source.html#l00163">163</a> of file <a class="el" href="../../d5/d1/cache_8h-source.html">cache.h</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a11" doxytag="cache.h::PPUBLIC_BCB" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef struct <a class="el" href="../../d8/d1/struct__PUBLIC__BCB.html">_PUBLIC_BCB</a> * <a class="el" href="../../d8/d1/struct__PUBLIC__BCB.html">PPUBLIC_BCB</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a15" doxytag="cache.h::PRELEASE_FROM_LAZY_WRITE" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef VOID(* <a class="el" href="../../d4/d2/cache_8h.html#a15">PRELEASE_FROM_LAZY_WRITE</a>)(IN PVOID Context)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d1/cache_8h-source.html#l00100">100</a> of file <a class="el" href="../../d5/d1/cache_8h-source.html">cache.h</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a17" doxytag="cache.h::PRELEASE_FROM_READ_AHEAD" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef VOID(* <a class="el" href="../../d4/d2/cache_8h.html#a17">PRELEASE_FROM_READ_AHEAD</a>)(IN PVOID Context)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d1/cache_8h-source.html#l00119">119</a> of file <a class="el" href="../../d5/d1/cache_8h-source.html">cache.h</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a10" doxytag="cache.h::PUBLIC_BCB" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef struct <a class="el" href="../../d8/d1/struct__PUBLIC__BCB.html">_PUBLIC_BCB</a>  <a class="el" href="../../d8/d1/struct__PUBLIC__BCB.html">PUBLIC_BCB</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a72" doxytag="cache.h::CcCanIWrite" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTKERNELAPI BOOLEAN CcCanIWrite           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>FileObject</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>BytesToWrite</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN BOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>Wait</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN BOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>Retrying</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Referenced by <a class="el" href="../../d6/d0/lazyrite_8c-source.html#l00221">CcLazyWriteScan()</a>, <a class="el" href="../../d6/d6/copysup_8c-source.html#l02099">CcPostDeferredWrites()</a>, <a class="el" href="../../d4/d0/fastio_8c-source.html#l00330">FsRtlCopyWrite()</a>, and <a class="el" href="../../d4/d0/fastio_8c-source.html#l01474">FsRtlPrepareMdlWriteDev()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a74" doxytag="cache.h::CcCopyRead" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTKERNELAPI BOOLEAN CcCopyRead           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>FileObject</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PLARGE_INTEGER&nbsp;</td>
          <td class="mdname" nowrap> <em>FileOffset</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Length</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN BOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>Wait</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PIO_STATUS_BLOCK&nbsp;</td>
          <td class="mdname" nowrap> <em>IoStatus</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d6/copysup_8c-source.html#l00031">31</a> of file <a class="el" href="../../d6/d6/copysup_8c-source.html">copysup.c</a>.
<p>
References <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00583">_VACB::BaseAddress</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00662">_PRIVATE_CACHE_MAP::BeyondLastByte1</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00665">_PRIVATE_CACHE_MAP::BeyondLastByte2</a>, <a class="el" href="../../d7/d1/rtqkey_8c-source.html#l00042">Buffer</a>, <a class="el" href="../../d6/d6/copysup_8c-source.html#l01747">CcCopyReadExceptionFilter()</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00188">CcCopyReadNoWait</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00190">CcCopyReadNoWaitMiss</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00189">CcCopyReadWait</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00191">CcCopyReadWaitMiss</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l05885">CcFreeActiveVacb()</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00862">CcFreeVirtualAddress()</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00310">CcGetVirtualAddress()</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00206">CcMissCounter</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l00116">CcPinFileData()</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l01253">CcScheduleReadAhead()</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00160">CcThrowAway</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l00974">CcUnpinFileData()</a>, <a class="el" href="../../d3/d0/mm_8h-source.html#l00221">COMPUTE_PAGES_SPANNED</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02290">DebugTrace</a>, <a class="el" href="../../d1/d3/ex_2alpha_2raisests_8c-source.html#l00157">ExRaiseStatus()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00661">_PRIVATE_CACHE_MAP::FileOffset1</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00664">_PRIVATE_CACHE_MAP::FileOffset2</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00752">_SHARED_CACHE_MAP::FileSize</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00497">FlagOn</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01510">FO_RANDOM_ACCESS</a>, <a class="el" href="../../d8/d2/fsrtl_2filter_8c-source.html#l00049">FsRtlNormalizeNtstatus()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01577">GetActiveVacb</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00385">HOT_STATISTIC</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l00033">me</a>, <a class="el" href="../../d2/d4/mapcache_8c-source.html#l01016">MmCheckCachedPageState()</a>, <a class="el" href="../../d3/d0/mm_8h-source.html#l01053">MmResetPageFaultReadAhead</a>, <a class="el" href="../../d3/d0/mm_8h-source.html#l00983">MmSavePageFaultReadAhead</a>, <a class="el" href="../../d3/d0/mm_8h-source.html#l01018">MmSetPageFaultReadAhead</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00809">_SHARED_CACHE_MAP::NeedToZero</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00600">PAGE_SHIFT</a>, <a class="el" href="../../d2/d8/ps_8h-source.html#l00645">PsGetCurrentThread</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00713">_PRIVATE_CACHE_MAP::ReadAheadEnabled</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00677">_PRIVATE_CACHE_MAP::ReadAheadLength</a>, <a class="el" href="../../d3/d0/mm_8h-source.html#l00117">ROUND_TO_PAGES</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01619">SetActiveVacb</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, <a class="el" href="../../d5/d5/cc_8h.html#a211a171">UNPIN</a>, <a class="el" href="../../d5/d1/cache_8h-source.html#l00030">VACB_MAPPING_GRANULARITY</a>, and <a class="el" href="../../d5/d1/cache_8h-source.html#l00031">VACB_OFFSET_SHIFT</a>.
<p>
Referenced by <a class="el" href="../../d4/d0/fastio_8c-source.html#l00054">FsRtlCopyRead()</a>, and <a class="el" href="../../d8/d4/udfs_2read_8c-source.html#l00068">UdfCommonRead()</a>.
<p>
<pre class="fragment"><div>00042                    :
00043 
00044     This routine attempts to copy <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> data from <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> cache
00045     into <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> output buffer, and deliver <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> correct I/O status.  It <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> *not*
00046     safe to call <span class="keyword">this</span> routine from Dpc level.
00047 
00048     If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller does not want to block (such as <span class="keywordflow">for</span> disk I/O), then
00049     Wait should be supplied as <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>.  If Wait was supplied as <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> and
00050     <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> currently impossible to supply all of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> requested data without
00051     blocking, then <span class="keyword">this</span> routine will <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>.  However, <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
00052     data <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> immediately accessible in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> cache and no blocking <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a>
00053     required, <span class="keyword">this</span> routine copies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data and returns <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>.
00054 
00055     If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller supplies Wait as <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, then <span class="keyword">this</span> routine <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> guaranteed
00056     to copy <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data and <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>.  If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> immediately
00057     accessible in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> cache, then no blocking will occur.  Otherwise,
00058     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data transfer from <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> into <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> cache will be initiated,
00059     and <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller will be blocked until <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data can be returned.
00060 
00061     <a class="code" href="../../d1/d9/icmui_8def.html#a0">File</a> system Fsd's should typically supply Wait = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> <span class="keywordflow">if</span> they are
00062     processing a synchronous I/O requests, or Wait = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> <span class="keywordflow">if</span> they are
00063     processing an asynchronous request.
00064 
00065     <a class="code" href="../../d1/d9/icmui_8def.html#a0">File</a> system or <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a22">Server</a> Fsp threads should supply Wait = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>.
00066 
00067 Arguments:
00068 
00069     FileObject - Pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> object <span class="keywordflow">for</span> a <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> which was
00070                  opened with NO_INTERMEDIATE_BUFFERING clear, i.e., <span class="keywordflow">for</span>
00071                  which <a class="code" href="../../d5/d8/fssup_8c.html#a9">CcInitializeCacheMap</a> was called by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> system.
00072 
00073     FileOffset - Byte offset in <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> <span class="keywordflow">for</span> desired data.
00074 
00075     Length - Length of desired data in bytes.
00076 
00077     Wait - <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> <span class="keywordflow">if</span> caller may not block, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> otherwise (see description
00078            above)
00079 
00080     <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> - Pointer to output buffer to which data should be copied.
00081 
00082     IoStatus - Pointer to standard I/O status block to receive <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> status
00083                <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> transfer.  (STATUS_SUCCESS guaranteed <span class="keywordflow">for</span> cache
00084                hits, otherwise <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> actual I/O status <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> returned.)
00085 
00086                Note that even <span class="keywordflow">if</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> returned, <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> IoStatus.Information
00087                field will <span class="keywordflow">return</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> count of any bytes successfully
00088                transferred before a blocking condition occured.  The caller
00089                may either choose to ignore <span class="keyword">this</span> information, or resume
00090                <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> copy later accounting <span class="keywordflow">for</span> bytes transferred.
00091 
00092 Return Value:
00093 
00094     <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> - <span class="keywordflow">if</span> Wait was supplied as <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> and <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data was not delivered
00095 
00096     <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> - <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> being delivered
00097 
00098 --*/
00099 
00100 {
00101     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap;
00102     <a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html">PPRIVATE_CACHE_MAP</a> PrivateCacheMap;
00103     PVOID CacheBuffer;
00104     LARGE_INTEGER FOffset;
00105     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> Vacb;
00106     <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> Bcb;
00107     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> ActiveVacb;
00108     ULONG ActivePage;
00109     ULONG PageIsDirty;
00110     ULONG SavedState;
00111     ULONG PagesToGo;
00112     ULONG MoveLength;
00113     ULONG LengthToGo;
00114     KIRQL OldIrql;
00115     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00116     ULONG OriginalLength = Length;
00117     ULONG PageCount = <a class="code" href="../../d2/d1/mm_8h.html#a9">COMPUTE_PAGES_SPANNED</a>((ULongToPtr(FileOffset-&gt;LowPart)), Length);
00118     <a class="code" href="../../d5/d6/struct__ETHREAD.html">PETHREAD</a> Thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
00119     ULONG GotAMiss = 0;
00120 
00121     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, me, <span class="stringliteral">"CcCopyRead\n"</span>, 0 );
00122 
00123     <a class="code" href="../../d2/d1/mm_8h.html#a19">MmSavePageFaultReadAhead</a>( Thread, &amp;SavedState );
00124 
00125     <span class="comment">//</span>
00126     <span class="comment">//  Get pointer to shared and private cache maps</span>
00127     <span class="comment">//</span>
00128 
00129     SharedCacheMap = FileObject-&gt;SectionObjectPointer-&gt;SharedCacheMap;
00130     PrivateCacheMap = FileObject-&gt;PrivateCacheMap;
00131 
00132     <span class="comment">//</span>
00133     <span class="comment">//  Check for read past file size, the caller must filter this case out.</span>
00134     <span class="comment">//</span>
00135 
00136     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( ( FileOffset-&gt;QuadPart + (LONGLONG)Length) &lt;= SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o3">FileSize</a>.QuadPart );
00137 
00138     <span class="comment">//</span>
00139     <span class="comment">//  If read ahead is enabled, then do the read ahead here so it</span>
00140     <span class="comment">//  overlaps with the copy (otherwise we will do it below).</span>
00141     <span class="comment">//  Note that we are assuming that we will not get ahead of our</span>
00142     <span class="comment">//  current transfer - if read ahead is working it should either</span>
00143     <span class="comment">//  already be in memory or else underway.</span>
00144     <span class="comment">//</span>
00145 
00146     <span class="keywordflow">if</span> (PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o13">ReadAheadEnabled</a> &amp;&amp; (PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o8">ReadAheadLength</a>[1] == 0)) {
00147         <a class="code" href="../../d4/d2/cache_8h.html#a84">CcScheduleReadAhead</a>( FileObject, FileOffset, Length );
00148     }
00149 
00150     FOffset = *FileOffset;
00151 
00152     <span class="comment">//</span>
00153     <span class="comment">//  Increment performance counters</span>
00154     <span class="comment">//</span>
00155 
00156     <span class="keywordflow">if</span> (Wait) {
00157         <a class="code" href="../../d0/d9/ntosdef_8h.html#a11">HOT_STATISTIC</a>(CcCopyReadWait) += 1;
00158 
00159         <span class="comment">//</span>
00160         <span class="comment">//  This is not an exact solution, but when IoPageRead gets a miss,</span>
00161         <span class="comment">//  it cannot tell whether it was CcCopyRead or CcMdlRead, but since</span>
00162         <span class="comment">//  the miss should occur very soon, by loading the pointer here</span>
00163         <span class="comment">//  probably the right counter will get incremented, and in any case,</span>
00164         <span class="comment">//  we hope the errrors average out!</span>
00165         <span class="comment">//</span>
00166 
00167         <a class="code" href="../../d5/d2/cachedat_8c.html#a75">CcMissCounter</a> = &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a64">CcCopyReadWaitMiss</a>;
00168 
00169     } <span class="keywordflow">else</span> {
00170         <a class="code" href="../../d0/d9/ntosdef_8h.html#a11">HOT_STATISTIC</a>(CcCopyReadNoWait) += 1;
00171     }
00172 
00173     <span class="comment">//</span>
00174     <span class="comment">//  See if we have an active Vacb, that we can just copy to.</span>
00175     <span class="comment">//</span>
00176 
00177     <a class="code" href="../../d5/d5/cc_8h.html#a82">GetActiveVacb</a>( SharedCacheMap, OldIrql, ActiveVacb, ActivePage, PageIsDirty );
00178 
00179     <span class="keywordflow">if</span> (ActiveVacb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00180 
00181         <span class="keywordflow">if</span> ((ULONG)(FOffset.QuadPart &gt;&gt; <a class="code" href="../../d4/d2/cache_8h.html#a1">VACB_OFFSET_SHIFT</a>) == (ActivePage &gt;&gt; (<a class="code" href="../../d4/d2/cache_8h.html#a1">VACB_OFFSET_SHIFT</a> - <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>))) {
00182 
00183             ULONG LengthToCopy = <a class="code" href="../../d4/d2/cache_8h.html#a0">VACB_MAPPING_GRANULARITY</a> - (FOffset.LowPart &amp; (<a class="code" href="../../d4/d2/cache_8h.html#a0">VACB_MAPPING_GRANULARITY</a> - 1));
00184 
00185             <span class="keywordflow">if</span> (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o13">NeedToZero</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00186                 <a class="code" href="../../d5/d5/cc_8h.html#a182">CcFreeActiveVacb</a>( SharedCacheMap, NULL, 0, FALSE );
00187             }
00188 
00189             <span class="comment">//</span>
00190             <span class="comment">//  Get the starting point in the view.</span>
00191             <span class="comment">//</span>
00192 
00193             CacheBuffer = (PVOID)((PCHAR)ActiveVacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o0">BaseAddress</a> +
00194                                           (FOffset.LowPart &amp; (<a class="code" href="../../d4/d2/cache_8h.html#a0">VACB_MAPPING_GRANULARITY</a> - 1)));
00195 
00196             <span class="comment">//</span>
00197             <span class="comment">//  Reduce LengthToCopy if it is greater than our caller's length.</span>
00198             <span class="comment">//</span>
00199 
00200             <span class="keywordflow">if</span> (LengthToCopy &gt; Length) {
00201                 LengthToCopy = Length;
00202             }
00203 
00204             <span class="comment">//</span>
00205             <span class="comment">//  Like the logic for the normal case below, we want to spin around</span>
00206             <span class="comment">//  making sure Mm only reads the pages we will need.</span>
00207             <span class="comment">//</span>
00208             
00209             PagesToGo = <a class="code" href="../../d2/d1/mm_8h.html#a9">COMPUTE_PAGES_SPANNED</a>( CacheBuffer,
00210                                                LengthToCopy ) - 1;
00211 
00212             <span class="comment">//</span>
00213             <span class="comment">//  Copy the data to the user buffer.</span>
00214             <span class="comment">//</span>
00215 
00216             <span class="keywordflow">try</span> {
00217 
00218                 <span class="keywordflow">if</span> (PagesToGo != 0) {
00219     
00220                     LengthToGo = LengthToCopy;
00221     
00222                     <span class="keywordflow">while</span> (LengthToGo != 0) {
00223     
00224                         MoveLength = (ULONG)((PCHAR)(<a class="code" href="../../d2/d1/mm_8h.html#a4">ROUND_TO_PAGES</a>(((PCHAR)CacheBuffer + 1))) -
00225                                      (PCHAR)CacheBuffer);
00226     
00227                         <span class="keywordflow">if</span> (MoveLength &gt; LengthToGo) {
00228                             MoveLength = LengthToGo;
00229                         }
00230     
00231                         <span class="comment">//</span>
00232                         <span class="comment">//  Here's hoping that it is cheaper to call Mm to see if</span>
00233                         <span class="comment">//  the page is valid.  If not let Mm know how many pages</span>
00234                         <span class="comment">//  we are after before doing the move.</span>
00235                         <span class="comment">//</span>
00236     
00237                         <a class="code" href="../../d2/d1/mm_8h.html#a20">MmSetPageFaultReadAhead</a>( Thread, PagesToGo );
00238                         GotAMiss |= !<a class="code" href="../../d1/d5/mapcache_8c.html#a13">MmCheckCachedPageState</a>( CacheBuffer, FALSE );
00239     
00240                         RtlCopyBytes( Buffer, CacheBuffer, MoveLength );
00241     
00242                         PagesToGo -= 1;
00243     
00244                         LengthToGo -= MoveLength;
00245                         <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> = (PCHAR)<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> + MoveLength;
00246                         CacheBuffer = (PCHAR)CacheBuffer + MoveLength;
00247                     }
00248     
00249                 <span class="comment">//</span>
00250                 <span class="comment">//  Handle the read here that stays on a single page.</span>
00251                 <span class="comment">//</span>
00252     
00253                 } <span class="keywordflow">else</span> {
00254     
00255                     <span class="comment">//</span>
00256                     <span class="comment">//  Here's hoping that it is cheaper to call Mm to see if</span>
00257                     <span class="comment">//  the page is valid.  If not let Mm know how many pages</span>
00258                     <span class="comment">//  we are after before doing the move.</span>
00259                     <span class="comment">//</span>
00260     
00261                     <a class="code" href="../../d2/d1/mm_8h.html#a20">MmSetPageFaultReadAhead</a>( Thread, 0 );
00262                     GotAMiss |= !<a class="code" href="../../d1/d5/mapcache_8c.html#a13">MmCheckCachedPageState</a>( CacheBuffer, FALSE );
00263     
00264                     RtlCopyBytes( Buffer, CacheBuffer, LengthToCopy );
00265     
00266                     <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> = (PCHAR)<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> + LengthToCopy;
00267                 }
00268                 
00269             } except( <a class="code" href="../../d5/d7/copysup_8c.html#a5">CcCopyReadExceptionFilter</a>( GetExceptionInformation(),
00270                                                  &amp;Status ) ) {
00271 
00272                 <a class="code" href="../../d2/d1/mm_8h.html#a21">MmResetPageFaultReadAhead</a>( Thread, SavedState );
00273 
00274                 <a class="code" href="../../d5/d5/cc_8h.html#a84">SetActiveVacb</a>( SharedCacheMap, OldIrql, ActiveVacb, ActivePage, PageIsDirty );
00275 
00276                 <span class="comment">//</span>
00277                 <span class="comment">//  If we got an access violation, then the user buffer went</span>
00278                 <span class="comment">//  away.  Otherwise we must have gotten an I/O error trying</span>
00279                 <span class="comment">//  to bring the data in.</span>
00280                 <span class="comment">//</span>
00281 
00282                 <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_ACCESS_VIOLATION) {
00283                     <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INVALID_USER_BUFFER );
00284                 }
00285                 <span class="keywordflow">else</span> {
00286                     <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( <a class="code" href="../../d1/d8/fsrtl_8h.html#a136">FsRtlNormalizeNtstatus</a>( Status,
00287                                                            STATUS_UNEXPECTED_IO_ERROR ));
00288                 }
00289             }
00290 
00291             <span class="comment">//</span>
00292             <span class="comment">//  Now adjust FOffset and Length by what we copied.</span>
00293             <span class="comment">//</span>
00294 
00295             FOffset.QuadPart = FOffset.QuadPart + (LONGLONG)LengthToCopy;
00296             Length -= LengthToCopy;
00297 
00298         }
00299 
00300         <span class="comment">//</span>
00301         <span class="comment">//  If that was all the data, then remember the Vacb</span>
00302         <span class="comment">//</span>
00303 
00304         <span class="keywordflow">if</span> (Length == 0) {
00305 
00306             <a class="code" href="../../d5/d5/cc_8h.html#a84">SetActiveVacb</a>( SharedCacheMap, OldIrql, ActiveVacb, ActivePage, PageIsDirty );
00307 
00308         <span class="comment">//</span>
00309         <span class="comment">//  Otherwise we must free it because we will map other vacbs below.</span>
00310         <span class="comment">//</span>
00311 
00312         } <span class="keywordflow">else</span> {
00313 
00314             <a class="code" href="../../d5/d5/cc_8h.html#a182">CcFreeActiveVacb</a>( SharedCacheMap, ActiveVacb, ActivePage, PageIsDirty );
00315         }
00316     }
00317 
00318     <span class="comment">//</span>
00319     <span class="comment">//  Not all of the transfer will come back at once, so we have to loop</span>
00320     <span class="comment">//  until the entire transfer is complete.</span>
00321     <span class="comment">//</span>
00322 
00323     <span class="keywordflow">while</span> (Length != 0) {
00324 
00325         ULONG ReceivedLength;
00326         LARGE_INTEGER BeyondLastByte;
00327 
00328         <span class="comment">//</span>
00329         <span class="comment">//  Call local routine to Map or Access the file data, then move the data,</span>
00330         <span class="comment">//  then call another local routine to free the data.  If we cannot map</span>
00331         <span class="comment">//  the data because of a Wait condition, return FALSE.</span>
00332         <span class="comment">//</span>
00333         <span class="comment">//  Note that this call may result in an exception, however, if it</span>
00334         <span class="comment">//  does no Bcb is returned and this routine has absolutely no</span>
00335         <span class="comment">//  cleanup to perform.  Therefore, we do not have a try-finally</span>
00336         <span class="comment">//  and we allow the possibility that we will simply be unwound</span>
00337         <span class="comment">//  without notice.</span>
00338         <span class="comment">//</span>
00339 
00340         <span class="keywordflow">if</span> (Wait) {
00341 
00342             CacheBuffer = <a class="code" href="../../d5/d3/vacbsup_8c.html#a15">CcGetVirtualAddress</a>( SharedCacheMap,
00343                                                FOffset,
00344                                                &amp;Vacb,
00345                                                &amp;ReceivedLength );
00346 
00347             BeyondLastByte.QuadPart = FOffset.QuadPart + (LONGLONG)ReceivedLength;
00348 
00349         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/cc_8h.html#a175">CcPinFileData</a>( FileObject,
00350                                    &amp;FOffset,
00351                                    Length,
00352                                    TRUE,
00353                                    FALSE,
00354                                    FALSE,
00355                                    &amp;Bcb,
00356                                    &amp;CacheBuffer,
00357                                    &amp;BeyondLastByte )) {
00358 
00359             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, me, <span class="stringliteral">"CcCopyRead -&gt; FALSE\n"</span>, 0 );
00360 
00361             <a class="code" href="../../d0/d9/ntosdef_8h.html#a11">HOT_STATISTIC</a>(CcCopyReadNoWaitMiss) += 1;
00362 
00363             <span class="comment">//</span>
00364             <span class="comment">//  Enable ReadAhead if we missed.</span>
00365             <span class="comment">//</span>
00366 
00367             PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o13">ReadAheadEnabled</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00368 
00369             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00370 
00371         } <span class="keywordflow">else</span> {
00372 
00373             <span class="comment">//</span>
00374             <span class="comment">//  Calculate how much data is described by Bcb starting at our desired</span>
00375             <span class="comment">//  file offset.</span>
00376             <span class="comment">//</span>
00377 
00378             ReceivedLength = (ULONG)(BeyondLastByte.QuadPart - FOffset.QuadPart);
00379         }
00380 
00381         <span class="comment">//</span>
00382         <span class="comment">//  If we got more than we need, make sure to only transfer</span>
00383         <span class="comment">//  the right amount.</span>
00384         <span class="comment">//</span>
00385 
00386         <span class="keywordflow">if</span> (ReceivedLength &gt; Length) {
00387             ReceivedLength = Length;
00388         }
00389 
00390         <span class="comment">//</span>
00391         <span class="comment">//  It is possible for the user buffer to become no longer accessible</span>
00392         <span class="comment">//  since it was last checked by the I/O system.  If we fail to access</span>
00393         <span class="comment">//  the buffer we must raise a status that the caller's exception</span>
00394         <span class="comment">//  filter considers as "expected".  Also we unmap the Bcb here, since</span>
00395         <span class="comment">//  we otherwise would have no other reason to put a try-finally around</span>
00396         <span class="comment">//  this loop.</span>
00397         <span class="comment">//</span>
00398 
00399         <span class="keywordflow">try</span> {
00400 
00401             PagesToGo = <a class="code" href="../../d2/d1/mm_8h.html#a9">COMPUTE_PAGES_SPANNED</a>( CacheBuffer,
00402                                                ReceivedLength ) - 1;
00403 
00404             <span class="comment">//</span>
00405             <span class="comment">//  We know exactly how much we want to read here, and we do not</span>
00406             <span class="comment">//  want to read any more in case the caller is doing random access.</span>
00407             <span class="comment">//  Our read ahead logic takes care of detecting sequential reads,</span>
00408             <span class="comment">//  and tends to do large asynchronous read aheads.  So far we have</span>
00409             <span class="comment">//  only mapped the data and we have not forced any in.  What we</span>
00410             <span class="comment">//  do now is get into a loop where we copy a page at a time and</span>
00411             <span class="comment">//  just prior to each move, we tell MM how many additional pages</span>
00412             <span class="comment">//  we would like to have read in, in the event that we take a</span>
00413             <span class="comment">//  fault.  With this strategy, for cache hits we never make a single</span>
00414             <span class="comment">//  expensive call to MM to guarantee that the data is in, yet if we</span>
00415             <span class="comment">//  do take a fault, we are guaranteed to only take one fault because</span>
00416             <span class="comment">//  we will read all of the data in for the rest of the transfer.</span>
00417             <span class="comment">//</span>
00418             <span class="comment">//  We test first for the multiple page case, to keep the small</span>
00419             <span class="comment">//  reads faster.</span>
00420             <span class="comment">//</span>
00421 
00422             <span class="keywordflow">if</span> (PagesToGo != 0) {
00423 
00424                 LengthToGo = ReceivedLength;
00425 
00426                 <span class="keywordflow">while</span> (LengthToGo != 0) {
00427 
00428                     MoveLength = (ULONG)((PCHAR)(<a class="code" href="../../d2/d1/mm_8h.html#a4">ROUND_TO_PAGES</a>(((PCHAR)CacheBuffer + 1))) -
00429                                  (PCHAR)CacheBuffer);
00430 
00431                     <span class="keywordflow">if</span> (MoveLength &gt; LengthToGo) {
00432                         MoveLength = LengthToGo;
00433                     }
00434 
00435                     <span class="comment">//</span>
00436                     <span class="comment">//  Here's hoping that it is cheaper to call Mm to see if</span>
00437                     <span class="comment">//  the page is valid.  If not let Mm know how many pages</span>
00438                     <span class="comment">//  we are after before doing the move.</span>
00439                     <span class="comment">//</span>
00440 
00441                     <a class="code" href="../../d2/d1/mm_8h.html#a20">MmSetPageFaultReadAhead</a>( Thread, PagesToGo );
00442                     GotAMiss |= !<a class="code" href="../../d1/d5/mapcache_8c.html#a13">MmCheckCachedPageState</a>( CacheBuffer, FALSE );
00443 
00444                     RtlCopyBytes( Buffer, CacheBuffer, MoveLength );
00445 
00446                     PagesToGo -= 1;
00447 
00448                     LengthToGo -= MoveLength;
00449                     <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> = (PCHAR)<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> + MoveLength;
00450                     CacheBuffer = (PCHAR)CacheBuffer + MoveLength;
00451                 }
00452 
00453             <span class="comment">//</span>
00454             <span class="comment">//  Handle the read here that stays on a single page.</span>
00455             <span class="comment">//</span>
00456 
00457             } <span class="keywordflow">else</span> {
00458 
00459                 <span class="comment">//</span>
00460                 <span class="comment">//  Here's hoping that it is cheaper to call Mm to see if</span>
00461                 <span class="comment">//  the page is valid.  If not let Mm know how many pages</span>
00462                 <span class="comment">//  we are after before doing the move.</span>
00463                 <span class="comment">//</span>
00464 
00465                 <a class="code" href="../../d2/d1/mm_8h.html#a20">MmSetPageFaultReadAhead</a>( Thread, 0 );
00466                 GotAMiss |= !<a class="code" href="../../d1/d5/mapcache_8c.html#a13">MmCheckCachedPageState</a>( CacheBuffer, FALSE );
00467 
00468                 RtlCopyBytes( Buffer, CacheBuffer, ReceivedLength );
00469 
00470                 <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> = (PCHAR)<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> + ReceivedLength;
00471             }
00472 
00473         }
00474         except( <a class="code" href="../../d5/d7/copysup_8c.html#a5">CcCopyReadExceptionFilter</a>( GetExceptionInformation(),
00475                                            &amp;Status ) ) {
00476 
00477             <a class="code" href="../../d5/d2/cachedat_8c.html#a75">CcMissCounter</a> = &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a43">CcThrowAway</a>;
00478 
00479             <span class="comment">//</span>
00480             <span class="comment">//  If we get an exception, then we have to renable page fault</span>
00481             <span class="comment">//  clustering and unmap on the way out.</span>
00482             <span class="comment">//</span>
00483 
00484             <a class="code" href="../../d2/d1/mm_8h.html#a21">MmResetPageFaultReadAhead</a>( Thread, SavedState );
00485 
00486 
00487             <span class="keywordflow">if</span> (Wait) {
00488                 <a class="code" href="../../d5/d3/vacbsup_8c.html#a16">CcFreeVirtualAddress</a>( Vacb );
00489             } <span class="keywordflow">else</span> {
00490                 <a class="code" href="../../d5/d5/cc_8h.html#a176">CcUnpinFileData</a>( Bcb, TRUE, UNPIN );
00491             }
00492 
00493             <span class="comment">//</span>
00494             <span class="comment">//  If we got an access violation, then the user buffer went</span>
00495             <span class="comment">//  away.  Otherwise we must have gotten an I/O error trying</span>
00496             <span class="comment">//  to bring the data in.</span>
00497             <span class="comment">//</span>
00498 
00499             <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_ACCESS_VIOLATION) {
00500                 <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INVALID_USER_BUFFER );
00501             }
00502             <span class="keywordflow">else</span> {
00503                 <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( <a class="code" href="../../d1/d8/fsrtl_8h.html#a136">FsRtlNormalizeNtstatus</a>( Status,
00504                                                        STATUS_UNEXPECTED_IO_ERROR ));
00505             }
00506         }
00507 
00508         <span class="comment">//</span>
00509         <span class="comment">//  Update number of bytes transferred.</span>
00510         <span class="comment">//</span>
00511 
00512         Length -= ReceivedLength;
00513 
00514         <span class="comment">//</span>
00515         <span class="comment">//  Unmap the data now, and calculate length left to transfer.</span>
00516         <span class="comment">//</span>
00517 
00518         <span class="keywordflow">if</span> (Wait) {
00519 
00520             <span class="comment">//</span>
00521             <span class="comment">//  If there is more to go, just free this vacb.</span>
00522             <span class="comment">//</span>
00523 
00524             <span class="keywordflow">if</span> (Length != 0) {
00525 
00526                 <a class="code" href="../../d5/d3/vacbsup_8c.html#a16">CcFreeVirtualAddress</a>( Vacb );
00527 
00528             <span class="comment">//</span>
00529             <span class="comment">//  Otherwise save it for the next time through.</span>
00530             <span class="comment">//</span>
00531 
00532             } <span class="keywordflow">else</span> {
00533 
00534                 <a class="code" href="../../d5/d5/cc_8h.html#a84">SetActiveVacb</a>( SharedCacheMap, OldIrql, Vacb, (ULONG)(FOffset.QuadPart &gt;&gt; PAGE_SHIFT), 0 );
00535                 <span class="keywordflow">break</span>;
00536             }
00537 
00538         } <span class="keywordflow">else</span> {
00539             <a class="code" href="../../d5/d5/cc_8h.html#a176">CcUnpinFileData</a>( Bcb, TRUE, UNPIN );
00540         }
00541 
00542         <span class="comment">//</span>
00543         <span class="comment">//  Assume we did not get all the data we wanted, and set FOffset</span>
00544         <span class="comment">//  to the end of the returned data.</span>
00545         <span class="comment">//</span>
00546 
00547         FOffset = BeyondLastByte;
00548     }
00549 
00550     <a class="code" href="../../d2/d1/mm_8h.html#a21">MmResetPageFaultReadAhead</a>( Thread, SavedState );
00551 
00552     <a class="code" href="../../d5/d2/cachedat_8c.html#a75">CcMissCounter</a> = &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a43">CcThrowAway</a>;
00553 
00554     <span class="comment">//</span>
00555     <span class="comment">//  Now enable read ahead if it looks like we got any misses, and do</span>
00556     <span class="comment">//  the first one.</span>
00557     <span class="comment">//</span>
00558 
00559     <span class="keywordflow">if</span> (GotAMiss &amp;&amp;
00560         !<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( FileObject-&gt;Flags, FO_RANDOM_ACCESS ) &amp;&amp;
00561         !PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o13">ReadAheadEnabled</a>) {
00562 
00563         PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o13">ReadAheadEnabled</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00564         <a class="code" href="../../d4/d2/cache_8h.html#a84">CcScheduleReadAhead</a>( FileObject, FileOffset, OriginalLength );
00565     }
00566 
00567     <span class="comment">//</span>
00568     <span class="comment">//  Now that we have described our desired read ahead, let's</span>
00569     <span class="comment">//  shift the read history down.</span>
00570     <span class="comment">//</span>
00571 
00572     PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o3">FileOffset1</a> = PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o5">FileOffset2</a>;
00573     PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o4">BeyondLastByte1</a> = PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o6">BeyondLastByte2</a>;
00574     PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o5">FileOffset2</a> = *FileOffset;
00575     PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o6">BeyondLastByte2</a>.QuadPart =
00576                                 FileOffset-&gt;QuadPart + (LONGLONG)OriginalLength;
00577 
00578     IoStatus-&gt;Status = STATUS_SUCCESS;
00579     IoStatus-&gt;Information = OriginalLength;
00580 
00581     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, me, <span class="stringliteral">"CcCopyRead -&gt; TRUE\n"</span>, 0 );
00582 
00583     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00584 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a76" doxytag="cache.h::CcCopyWrite" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTKERNELAPI BOOLEAN CcCopyWrite           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>FileObject</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PLARGE_INTEGER&nbsp;</td>
          <td class="mdname" nowrap> <em>FileOffset</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Length</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN BOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>Wait</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>Buffer</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d6/copysup_8c-source.html#l01075">1075</a> of file <a class="el" href="../../d6/d6/copysup_8c-source.html">copysup.c</a>.
<p>
References <a class="el" href="../../d6/d4/cc_8h-source.html#l01065">ACTIVE_PAGE_IS_DIRTY</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00816">_SHARED_CACHE_MAP::ActiveVacbSpinLock</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00583">_VACB::BaseAddress</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00501">BooleanFlagOn</a>, <a class="el" href="../../d7/d1/rtqkey_8c-source.html#l00042">Buffer</a>, <a class="el" href="../../d6/d6/copysup_8c-source.html#l01747">CcCopyReadExceptionFilter()</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l05885">CcFreeActiveVacb()</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l06024">CcMapAndCopy()</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l00116">CcPinFileData()</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l02560">CcSetDirtyPinnedData()</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l00974">CcUnpinFileData()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02290">DebugTrace</a>, <a class="el" href="../../d1/d3/ex_2alpha_2raisests_8c-source.html#l00157">ExRaiseStatus()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00497">FlagOn</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01494">FO_WRITE_THROUGH</a>, <a class="el" href="../../d2/d7/fsrtl_8h-source.html#l00236">FSRTL_FLAG_ADVANCED_HEADER</a>, <a class="el" href="../../d8/d2/fsrtl_2filter_8c-source.html#l00049">FsRtlNormalizeNtstatus()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01577">GetActiveVacb</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l00033">me</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00809">_SHARED_CACHE_MAP::NeedToZero</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00957">_SHARED_CACHE_MAP::NeedToZeroVacb</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00600">PAGE_SHIFT</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00599">PAGE_SIZE</a>, <a class="el" href="../../d2/d7/fsrtl_8h-source.html#l00202">PFSRTL_ADVANCED_FCB_HEADER</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01619">SetActiveVacb</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, <a class="el" href="../../d5/d5/cc_8h.html#a211a171">UNPIN</a>, <a class="el" href="../../d5/d1/cache_8h-source.html#l00030">VACB_MAPPING_GRANULARITY</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01798">ZERO_FIRST_PAGE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01800">ZERO_LAST_PAGE</a>, and <a class="el" href="../../d6/d4/cc_8h-source.html#l01799">ZERO_MIDDLE_PAGES</a>.
<p>
Referenced by <a class="el" href="../../d4/d0/fastio_8c-source.html#l00330">FsRtlCopyWrite()</a>.
<p>
<pre class="fragment"><div>01085                    :
01086 
01087     This routine attempts to copy <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> data from <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified
01088     buffer into <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Cache, and deliver <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> correct I/O status.  It <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> *not*
01089     safe to call <span class="keyword">this</span> routine from Dpc level.
01090 
01091     If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller does not want to block (such as <span class="keywordflow">for</span> disk I/O), then
01092     Wait should be supplied as <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>.  If Wait was supplied as <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> and
01093     <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> currently impossible to receive all of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> requested data without
01094     blocking, then <span class="keyword">this</span> routine will <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>.  However, <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
01095     correct space <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> immediately accessible in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> cache and no blocking <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a>
01096     required, <span class="keyword">this</span> routine copies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data and returns <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>.
01097 
01098     If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller supplies Wait as <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, then <span class="keyword">this</span> routine <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> guaranteed
01099     to copy <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data and <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>.  If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> correct space <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> immediately
01100     accessible in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> cache, then no blocking will occur.  Otherwise,
01101     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> necessary work will be initiated to read and/or free cache data,
01102     and <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller will be blocked until <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data can be received.
01103 
01104     <a class="code" href="../../d1/d9/icmui_8def.html#a0">File</a> system Fsd's should typically supply Wait = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> <span class="keywordflow">if</span> they are
01105     processing a synchronous I/O requests, or Wait = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> <span class="keywordflow">if</span> they are
01106     processing an asynchronous request.
01107 
01108     <a class="code" href="../../d1/d9/icmui_8def.html#a0">File</a> system or <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a22">Server</a> Fsp threads should supply Wait = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>.
01109 
01110 Arguments:
01111 
01112     FileObject - Pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> object <span class="keywordflow">for</span> a <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> which was
01113                  opened with NO_INTERMEDIATE_BUFFERING clear, i.e., <span class="keywordflow">for</span>
01114                  which <a class="code" href="../../d5/d8/fssup_8c.html#a9">CcInitializeCacheMap</a> was called by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> system.
01115 
01116     FileOffset - Byte offset in <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> to receive <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data.
01117 
01118     Length - Length of data in bytes.
01119 
01120     Wait - <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> <span class="keywordflow">if</span> caller may not block, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> otherwise (see description
01121            above)
01122 
01123     <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> - Pointer to input buffer from which data should be copied.
01124 
01125 Return Value:
01126 
01127     <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> - <span class="keywordflow">if</span> Wait was supplied as <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> and <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data was not copied.
01128 
01129     <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> - <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data has been copied.
01130 
01131 Raises:
01132 
01133     STATUS_INSUFFICIENT_RESOURCES - If a <a class="code" href="../../d4/d6/regext_8c.html#a17">pool</a> allocation <a class="code" href="../../d8/d0/rtbatcr_8c.html#a1">failure</a> occurs.
01134         This can <a class="code" href="../../d3/d0/imm32_8def.html#a1">only</a> occur <span class="keywordflow">if</span> Wait was specified as <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>.  (If Wait <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a>
01135         specified as <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, and an allocation <a class="code" href="../../d8/d0/rtbatcr_8c.html#a1">failure</a> occurs, <span class="keyword">this</span>
01136         routine simply returns <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>.)
01137 
01138 --*/
01139 
01140 {
01141     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap;
01142     <a class="code" href="../../d9/d0/struct__FSRTL__ADVANCED__FCB__HEADER.html">PFSRTL_ADVANCED_FCB_HEADER</a> FcbHeader;
01143     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> ActiveVacb;
01144     ULONG ActivePage;
01145     PVOID ActiveAddress;
01146     ULONG PageIsDirty;
01147     KIRQL OldIrql;
01148     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01149     PVOID CacheBuffer;
01150     LARGE_INTEGER FOffset;
01151     <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> Bcb;
01152     ULONG ZeroFlags;
01153     LARGE_INTEGER Temp;
01154 
01155     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, me, <span class="stringliteral">"CcCopyWrite\n"</span>, 0 );
01156 
01157     <span class="comment">//</span>
01158     <span class="comment">//  If the caller specified Wait == FALSE, but the FileObject is WriteThrough,</span>
01159     <span class="comment">//  then we need to just get out.</span>
01160     <span class="comment">//</span>
01161 
01162     <span class="keywordflow">if</span> ((FileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a154">FO_WRITE_THROUGH</a>) &amp;&amp; !Wait) {
01163 
01164         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, me, <span class="stringliteral">"CcCopyWrite-&gt;FALSE (WriteThrough &amp;&amp; !Wait)\n"</span>, 0 );
01165 
01166         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01167     }
01168 
01169     <span class="comment">//</span>
01170     <span class="comment">//  Get pointer to shared cache map</span>
01171     <span class="comment">//</span>
01172 
01173     SharedCacheMap = FileObject-&gt;SectionObjectPointer-&gt;SharedCacheMap;
01174     FOffset = *FileOffset;
01175 
01176     <span class="comment">//</span>
01177     <span class="comment">//  See if we have an active Vacb, that we can just copy to.</span>
01178     <span class="comment">//</span>
01179 
01180     <a class="code" href="../../d5/d5/cc_8h.html#a82">GetActiveVacb</a>( SharedCacheMap, OldIrql, ActiveVacb, ActivePage, PageIsDirty );
01181 
01182     <span class="keywordflow">if</span> (ActiveVacb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01183 
01184         <span class="comment">//</span>
01185         <span class="comment">//  See if the request starts in the ActivePage.  WriteThrough requests must</span>
01186         <span class="comment">//  go the longer route through CcMapAndCopy, where WriteThrough flushes are</span>
01187         <span class="comment">//  implemented.</span>
01188         <span class="comment">//</span>
01189 
01190         <span class="keywordflow">if</span> (((ULONG)(FOffset.QuadPart &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>) == ActivePage) &amp;&amp; (Length != 0) &amp;&amp;
01191             !<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( FileObject-&gt;Flags, FO_WRITE_THROUGH )) {
01192 
01193             ULONG LengthToCopy = <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - (FOffset.LowPart &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1));
01194 
01195             <span class="comment">//</span>
01196             <span class="comment">//  Reduce LengthToCopy if it is greater than our caller's length.</span>
01197             <span class="comment">//</span>
01198 
01199             <span class="keywordflow">if</span> (LengthToCopy &gt; Length) {
01200                 LengthToCopy = Length;
01201             }
01202 
01203             <span class="comment">//</span>
01204             <span class="comment">//  Copy the data to the user buffer.</span>
01205             <span class="comment">//</span>
01206 
01207             <span class="keywordflow">try</span> {
01208 
01209                 <span class="comment">//</span>
01210                 <span class="comment">//  If we are copying to a page that is locked down, then</span>
01211                 <span class="comment">//  we have to do it under our spinlock, and update the</span>
01212                 <span class="comment">//  NeedToZero field.</span>
01213                 <span class="comment">//</span>
01214 
01215                 OldIrql = 0xFF;
01216 
01217                 CacheBuffer = (PVOID)((PCHAR)ActiveVacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o0">BaseAddress</a> +
01218                                       (FOffset.LowPart &amp; (<a class="code" href="../../d4/d2/cache_8h.html#a0">VACB_MAPPING_GRANULARITY</a> - 1)));
01219 
01220                 <span class="keywordflow">if</span> (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o13">NeedToZero</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01221 
01222                     <span class="comment">//</span>
01223                     <span class="comment">//  The FastLock may not write our "flag".</span>
01224                     <span class="comment">//</span>
01225 
01226                     OldIrql = 0;
01227 
01228                     ExAcquireFastLock( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o15">ActiveVacbSpinLock</a>, &amp;OldIrql );
01229 
01230                     <span class="comment">//</span>
01231                     <span class="comment">//  Note that the NeedToZero could be cleared, since we</span>
01232                     <span class="comment">//  tested it without the spinlock.</span>
01233                     <span class="comment">//</span>
01234 
01235                     ActiveAddress = SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o13">NeedToZero</a>;
01236                     <span class="keywordflow">if</span> ((ActiveAddress != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
01237                         (ActiveVacb == SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o35">NeedToZeroVacb</a>) &amp;&amp;
01238                         (((PCHAR)CacheBuffer + LengthToCopy) &gt; (PCHAR)ActiveAddress)) {
01239 
01240                         <span class="comment">//</span>
01241                         <span class="comment">//  If we are skipping some bytes in the page, then we need</span>
01242                         <span class="comment">//  to zero them.</span>
01243                         <span class="comment">//</span>
01244 
01245                         <span class="keywordflow">if</span> ((PCHAR)CacheBuffer &gt; (PCHAR)ActiveAddress) {
01246 
01247                             RtlZeroMemory( ActiveAddress, (PCHAR)CacheBuffer - (PCHAR)ActiveAddress );
01248                         }
01249                         SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o13">NeedToZero</a> = (PVOID)((PCHAR)CacheBuffer + LengthToCopy);
01250                     }
01251 
01252                     ExReleaseFastLock( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o15">ActiveVacbSpinLock</a>, OldIrql );
01253                 }
01254 
01255                 RtlCopyBytes( CacheBuffer, Buffer, LengthToCopy );
01256 
01257             } except( <a class="code" href="../../d5/d7/copysup_8c.html#a5">CcCopyReadExceptionFilter</a>( GetExceptionInformation(),
01258                                                  &amp;Status ) ) {
01259 
01260                 <span class="comment">//</span>
01261                 <span class="comment">//  If we failed to overwrite the uninitialized data,</span>
01262                 <span class="comment">//  zero it now (we cannot safely restore NeedToZero).</span>
01263                 <span class="comment">//</span>
01264 
01265                 <span class="keywordflow">if</span> (OldIrql != 0xFF) {
01266                     RtlZeroBytes( CacheBuffer, LengthToCopy );
01267                 }
01268 
01269                 <a class="code" href="../../d5/d5/cc_8h.html#a84">SetActiveVacb</a>( SharedCacheMap, OldIrql, ActiveVacb, ActivePage, ACTIVE_PAGE_IS_DIRTY );
01270 
01271                 <span class="comment">//</span>
01272                 <span class="comment">//  If we got an access violation, then the user buffer went</span>
01273                 <span class="comment">//  away.  Otherwise we must have gotten an I/O error trying</span>
01274                 <span class="comment">//  to bring the data in.</span>
01275                 <span class="comment">//</span>
01276 
01277                 <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_ACCESS_VIOLATION) {
01278                     <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INVALID_USER_BUFFER );
01279                 }
01280                 <span class="keywordflow">else</span> {
01281                     <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( <a class="code" href="../../d1/d8/fsrtl_8h.html#a136">FsRtlNormalizeNtstatus</a>( Status,
01282                                                            STATUS_UNEXPECTED_IO_ERROR ));
01283                 }
01284             }
01285 
01286             <span class="comment">//</span>
01287             <span class="comment">//  Now adjust FOffset and Length by what we copied.</span>
01288             <span class="comment">//</span>
01289 
01290             <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> = (PVOID)((PCHAR)<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> + LengthToCopy);
01291             FOffset.QuadPart = FOffset.QuadPart + (LONGLONG)LengthToCopy;
01292             Length -= LengthToCopy;
01293 
01294             <span class="comment">//</span>
01295             <span class="comment">//  If that was all the data, then get outski...</span>
01296             <span class="comment">//</span>
01297 
01298             <span class="keywordflow">if</span> (Length == 0) {
01299 
01300                 <a class="code" href="../../d5/d5/cc_8h.html#a84">SetActiveVacb</a>( SharedCacheMap, OldIrql, ActiveVacb, ActivePage, ACTIVE_PAGE_IS_DIRTY );
01301                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01302             }
01303 
01304             <span class="comment">//</span>
01305             <span class="comment">//  Remember that the page is dirty now.</span>
01306             <span class="comment">//</span>
01307 
01308             PageIsDirty |= <a class="code" href="../../d5/d5/cc_8h.html#a76">ACTIVE_PAGE_IS_DIRTY</a>;
01309         }
01310 
01311         <a class="code" href="../../d5/d5/cc_8h.html#a182">CcFreeActiveVacb</a>( SharedCacheMap, ActiveVacb, ActivePage, PageIsDirty );
01312 
01313     <span class="comment">//</span>
01314     <span class="comment">//  Else someone else could have the active page, and may want to zero</span>
01315     <span class="comment">//  the range we plan to write!</span>
01316     <span class="comment">//</span>
01317 
01318     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o13">NeedToZero</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01319 
01320         <a class="code" href="../../d5/d5/cc_8h.html#a182">CcFreeActiveVacb</a>( SharedCacheMap, NULL, 0, FALSE );
01321     }
01322 
01323     <span class="comment">//</span>
01324     <span class="comment">//  At this point we can calculate the ZeroFlags.</span>
01325     <span class="comment">//</span>
01326 
01327     <span class="comment">//</span>
01328     <span class="comment">//  We can always zero middle pages, if any.</span>
01329     <span class="comment">//</span>
01330 
01331     ZeroFlags = <a class="code" href="../../d5/d5/cc_8h.html#a86">ZERO_MIDDLE_PAGES</a>;
01332 
01333     <span class="keywordflow">if</span> (((FOffset.LowPart &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1)) == 0) &amp;&amp;
01334         (Length &gt;= <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>)) {
01335         ZeroFlags |= <a class="code" href="../../d5/d5/cc_8h.html#a85">ZERO_FIRST_PAGE</a>;
01336     }
01337 
01338     <span class="keywordflow">if</span> (((FOffset.LowPart + Length) &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1)) == 0) {
01339         ZeroFlags |= <a class="code" href="../../d5/d5/cc_8h.html#a87">ZERO_LAST_PAGE</a>;
01340     }
01341 
01342     Temp = FOffset;
01343     Temp.LowPart &amp;= ~(<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> -1);
01344 
01345     <span class="comment">//</span>
01346     <span class="comment">//  If there is an advanced header, then we can acquire the FastMutex to</span>
01347     <span class="comment">//  make capturing ValidDataLength atomic.  Currently our other file systems</span>
01348     <span class="comment">//  are either RO or do not really support 64-bits.</span>
01349     <span class="comment">//</span>
01350 
01351     FcbHeader = (<a class="code" href="../../d9/d0/struct__FSRTL__ADVANCED__FCB__HEADER.html">PFSRTL_ADVANCED_FCB_HEADER</a>)FileObject-&gt;FsContext;
01352     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(FcbHeader-&gt;Flags, FSRTL_FLAG_ADVANCED_HEADER)) {
01353         ExAcquireFastMutex( FcbHeader-&gt;FastMutex );
01354         Temp.QuadPart = ((<a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html">PFSRTL_COMMON_FCB_HEADER</a>)FileObject-&gt;FsContext)-&gt;ValidDataLength.QuadPart -
01355                         Temp.QuadPart;
01356         ExReleaseFastMutex( FcbHeader-&gt;FastMutex );
01357     } <span class="keywordflow">else</span> {
01358         Temp.QuadPart = ((<a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html">PFSRTL_COMMON_FCB_HEADER</a>)FileObject-&gt;FsContext)-&gt;ValidDataLength.QuadPart -
01359                         Temp.QuadPart;
01360     }
01361 
01362     <span class="keywordflow">if</span> (Temp.QuadPart &lt;= 0) {
01363         ZeroFlags |= <a class="code" href="../../d5/d5/cc_8h.html#a85">ZERO_FIRST_PAGE</a> | <a class="code" href="../../d5/d5/cc_8h.html#a86">ZERO_MIDDLE_PAGES</a> | <a class="code" href="../../d5/d5/cc_8h.html#a87">ZERO_LAST_PAGE</a>;
01364     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((Temp.HighPart == 0) &amp;&amp; (Temp.LowPart &lt;= <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>)) {
01365         ZeroFlags |= <a class="code" href="../../d5/d5/cc_8h.html#a86">ZERO_MIDDLE_PAGES</a> | <a class="code" href="../../d5/d5/cc_8h.html#a87">ZERO_LAST_PAGE</a>;
01366     }
01367 
01368     <span class="comment">//</span>
01369     <span class="comment">//  Call a routine to map and copy the data in Mm and get out.</span>
01370     <span class="comment">//</span>
01371 
01372     <span class="keywordflow">if</span> (Wait) {
01373 
01374         <a class="code" href="../../d5/d5/cc_8h.html#a183">CcMapAndCopy</a>( SharedCacheMap,
01375                       Buffer,
01376                       &amp;FOffset,
01377                       Length,
01378                       ZeroFlags,
01379                       <a class="code" href="../../d5/d5/cc_8h.html#a59">BooleanFlagOn</a>( FileObject-&gt;Flags, FO_WRITE_THROUGH ));
01380 
01381         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01382     }
01383 
01384     <span class="comment">//</span>
01385     <span class="comment">//  The rest of this routine is the Wait == FALSE case.</span>
01386     <span class="comment">//</span>
01387     <span class="comment">//  Not all of the transfer will come back at once, so we have to loop</span>
01388     <span class="comment">//  until the entire transfer is complete.</span>
01389     <span class="comment">//</span>
01390 
01391     <span class="keywordflow">while</span> (Length != 0) {
01392 
01393         ULONG ReceivedLength;
01394         LARGE_INTEGER BeyondLastByte;
01395 
01396         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/cc_8h.html#a175">CcPinFileData</a>( FileObject,
01397                             &amp;FOffset,
01398                             Length,
01399                             FALSE,
01400                             TRUE,
01401                             FALSE,
01402                             &amp;Bcb,
01403                             &amp;CacheBuffer,
01404                             &amp;BeyondLastByte )) {
01405 
01406             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, me, <span class="stringliteral">"CcCopyWrite -&gt; FALSE\n"</span>, 0 );
01407 
01408             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01409 
01410         } <span class="keywordflow">else</span> {
01411 
01412             <span class="comment">//</span>
01413             <span class="comment">//  Calculate how much data is described by Bcb starting at our desired</span>
01414             <span class="comment">//  file offset.</span>
01415             <span class="comment">//</span>
01416 
01417             ReceivedLength = (ULONG)(BeyondLastByte.QuadPart - FOffset.QuadPart);
01418 
01419             <span class="comment">//</span>
01420             <span class="comment">//  If we got more than we need, make sure to only transfer</span>
01421             <span class="comment">//  the right amount.</span>
01422             <span class="comment">//</span>
01423 
01424             <span class="keywordflow">if</span> (ReceivedLength &gt; Length) {
01425                 ReceivedLength = Length;
01426             }
01427         }
01428 
01429         <span class="comment">//</span>
01430         <span class="comment">//  It is possible for the user buffer to become no longer accessible</span>
01431         <span class="comment">//  since it was last checked by the I/O system.  If we fail to access</span>
01432         <span class="comment">//  the buffer we must raise a status that the caller's exception</span>
01433         <span class="comment">//  filter considers as "expected".  Also we unmap the Bcb here, since</span>
01434         <span class="comment">//  we otherwise would have no other reason to put a try-finally around</span>
01435         <span class="comment">//  this loop.</span>
01436         <span class="comment">//</span>
01437 
01438         <span class="keywordflow">try</span> {
01439 
01440             RtlCopyBytes( CacheBuffer, Buffer, ReceivedLength );
01441 
01442             <a class="code" href="../../d4/d2/cache_8h.html#a91">CcSetDirtyPinnedData</a>( Bcb, NULL );
01443             <a class="code" href="../../d5/d5/cc_8h.html#a176">CcUnpinFileData</a>( Bcb, FALSE, UNPIN );
01444         }
01445         except( <a class="code" href="../../d5/d7/copysup_8c.html#a5">CcCopyReadExceptionFilter</a>( GetExceptionInformation(),
01446                                            &amp;Status ) ) {
01447 
01448             <a class="code" href="../../d5/d5/cc_8h.html#a176">CcUnpinFileData</a>( Bcb, TRUE, UNPIN );
01449 
01450             <span class="comment">//</span>
01451             <span class="comment">//  If we got an access violation, then the user buffer went</span>
01452             <span class="comment">//  away.  Otherwise we must have gotten an I/O error trying</span>
01453             <span class="comment">//  to bring the data in.</span>
01454             <span class="comment">//</span>
01455 
01456             <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_ACCESS_VIOLATION) {
01457                 <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INVALID_USER_BUFFER );
01458             }
01459             <span class="keywordflow">else</span> {
01460 
01461                 <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>(<a class="code" href="../../d1/d8/fsrtl_8h.html#a136">FsRtlNormalizeNtstatus</a>( Status, STATUS_UNEXPECTED_IO_ERROR ));
01462             }
01463         }
01464 
01465         <span class="comment">//</span>
01466         <span class="comment">//  Assume we did not get all the data we wanted, and set FOffset</span>
01467         <span class="comment">//  to the end of the returned data and adjust the Buffer and Length.</span>
01468         <span class="comment">//</span>
01469 
01470         FOffset = BeyondLastByte;
01471         <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> = (PCHAR)<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> + ReceivedLength;
01472         Length -= ReceivedLength;
01473     }
01474 
01475     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, me, <span class="stringliteral">"CcCopyWrite -&gt; TRUE\n"</span>, 0 );
01476 
01477     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01478 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a73" doxytag="cache.h::CcDeferWrite" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTKERNELAPI VOID CcDeferWrite           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>FileObject</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d4/d2/cache_8h.html#a56">PCC_POST_DEFERRED_WRITE</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>PostRoutine</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>Context1</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>Context2</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>BytesToWrite</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN BOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>Retrying</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d6/copysup_8c-source.html#l01982">1982</a> of file <a class="el" href="../../d6/d6/copysup_8c-source.html">copysup.c</a>.
<p>
References <a class="el" href="../../d6/d4/cc_8h-source.html#l00501">BooleanFlagOn</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01400">_DEFERRED_WRITE::BytesToWrite</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00156">CACHE_NTC_DEFERRED_WRITE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00064">CcAcquireMasterLock</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00096">CcDeferredWrites</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00095">CcDeferredWriteSpinLock</a>, <a class="el" href="../../d6/d6/copysup_8c-source.html#l02099">CcPostDeferredWrites()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00067">CcReleaseMasterLock</a>, <a class="el" href="../../d6/d0/lazyrite_8c-source.html#l00049">CcScheduleLazyWriteScan()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01421">_DEFERRED_WRITE::Context1</a>, <a class="el" href="../../d4/d0/threads_8h-source.html#l00266">Context1</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01422">_DEFERRED_WRITE::Context2</a>, <a class="el" href="../../d4/d0/threads_8h-source.html#l00266">Context2</a>, <a class="el" href="../../d5/d5/cc_8h.html#a113">DEFERRED_WRITE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01406">_DEFERRED_WRITE::DeferredWriteLinks</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01414">_DEFERRED_WRITE::Event</a>, <a class="el" href="../../d6/d7/ex_8h-source.html#l00253">ExAllocatePoolWithTag</a>, <a class="el" href="../../d5/d8/ex_8h.html#a237">ExInterlockedInsertHeadList()</a>, <a class="el" href="../../d5/d8/ex_8h.html#a238">ExInterlockedInsertTailList()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01394">_DEFERRED_WRITE::FileObject</a>, <a class="el" href="../../d2/d7/fsrtl_8h-source.html#l00211">FSRTL_FLAG_LIMIT_MODIFIED_PAGES</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00129">LazyWriter</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01424">_DEFERRED_WRITE::LimitModifiedPages</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01388">_DEFERRED_WRITE::NodeByteSize</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01387">_DEFERRED_WRITE::NodeTypeCode</a>, <a class="el" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01420">_DEFERRED_WRITE::PostRoutine</a>, and <a class="el" href="../../d6/d4/cc_8h-source.html#l01464">_LAZY_WRITER::ScanActive</a>.
<p>
<pre class="fragment"><div>01993                    :
01994 
01995     This routine may be called to have <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Cache <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a79">Manager</a> defer posting
01996     of a write until <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Lazy <a class="code" href="../../d4/d0/tex_8c.html#a44">Writer</a> makes some progress writing, or
01997     there are more available pages.  <a class="code" href="../../d2/d1/bench_8h.html#a5">A</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> system would normally call
01998     <span class="keyword">this</span> routine after receiving <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> from <a class="code" href="../../d5/d7/copysup_8c.html#a6">CcCanIWrite</a>, and preparing
01999     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> request to be posted.
02000 
02001 Arguments:
02002 
02003     FileObject - <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> to be written
02004 
02005     PostRoutine - Address of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> PostRoutine that <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Cache <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a79">Manager</a> can
02006                   call to post <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> request when conditions are right.  Note
02007                   that <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> possible that <span class="keyword">this</span> routine will be called
02008                   immediately from <span class="keyword">this</span> routine.
02009 
02010     <a class="code" href="../../d3/d1/threads_8h.html#a107">Context1</a> - First context parameter <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> post routine.
02011 
02012     <a class="code" href="../../d3/d1/threads_8h.html#a108">Context2</a> - Secont parameter <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> post routine.
02013 
02014     BytesToWrite - Number of bytes that <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> request <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> trying to write
02015                    to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> cache.
02016 
02017     Retrying - Supplied as <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> request <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> being posted <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
02018                first time, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> otherwise.
02019 
02020 Return Value:
02021 
02022     None
02023 
02024 --*/
02025 
02026 {
02027     <a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html">PDEFERRED_WRITE</a> DeferredWrite;
02028     KIRQL OldIrql;
02029 
02030     <span class="comment">//</span>
02031     <span class="comment">//  Attempt to allocate a deferred write block, and if we do not get</span>
02032     <span class="comment">//  one, just post it immediately rather than gobbling up must succeed</span>
02033     <span class="comment">//  pool.</span>
02034     <span class="comment">//</span>
02035 
02036     DeferredWrite = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( NonPagedPool, <span class="keyword">sizeof</span>(<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html">DEFERRED_WRITE</a>), 'wDcC' );
02037 
02038     <span class="keywordflow">if</span> (DeferredWrite == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02039         (*PostRoutine)( <a class="code" href="../../d3/d1/threads_8h.html#a107">Context1</a>, <a class="code" href="../../d3/d1/threads_8h.html#a108">Context2</a> );
02040         <span class="keywordflow">return</span>;
02041     }
02042 
02043     <span class="comment">//</span>
02044     <span class="comment">//  Fill in the block.</span>
02045     <span class="comment">//</span>
02046 
02047     DeferredWrite-&gt;<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o0">NodeTypeCode</a> = <a class="code" href="../../d5/d5/cc_8h.html#a15">CACHE_NTC_DEFERRED_WRITE</a>;
02048     DeferredWrite-&gt;<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o1">NodeByteSize</a> = <span class="keyword">sizeof</span>(<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html">DEFERRED_WRITE</a>);
02049     DeferredWrite-&gt;<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o2">FileObject</a> = FileObject;
02050     DeferredWrite-&gt;<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o3">BytesToWrite</a> = BytesToWrite;
02051     DeferredWrite-&gt;<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o5">Event</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02052     DeferredWrite-&gt;<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o6">PostRoutine</a> = PostRoutine;
02053     DeferredWrite-&gt;<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o7">Context1</a> = <a class="code" href="../../d3/d1/threads_8h.html#a107">Context1</a>;
02054     DeferredWrite-&gt;<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o8">Context2</a> = <a class="code" href="../../d3/d1/threads_8h.html#a108">Context2</a>;
02055     DeferredWrite-&gt;<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o9">LimitModifiedPages</a> = <a class="code" href="../../d5/d5/cc_8h.html#a59">BooleanFlagOn</a>(((<a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html">PFSRTL_COMMON_FCB_HEADER</a>)(FileObject-&gt;FsContext))-&gt;Flags,
02056                                                       FSRTL_FLAG_LIMIT_MODIFIED_PAGES);
02057 
02058     <span class="comment">//</span>
02059     <span class="comment">//  Now insert at the appropriate end of the list</span>
02060     <span class="comment">//</span>
02061 
02062     <span class="keywordflow">if</span> (Retrying) {
02063         <a class="code" href="../../d5/d8/ex_8h.html#a237">ExInterlockedInsertHeadList</a>( &amp;CcDeferredWrites,
02064                                      &amp;DeferredWrite-&gt;<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o4">DeferredWriteLinks</a>,
02065                                      &amp;CcDeferredWriteSpinLock );
02066     } <span class="keywordflow">else</span> {
02067         <a class="code" href="../../d5/d8/ex_8h.html#a238">ExInterlockedInsertTailList</a>( &amp;CcDeferredWrites,
02068                                      &amp;DeferredWrite-&gt;<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o4">DeferredWriteLinks</a>,
02069                                      &amp;CcDeferredWriteSpinLock );
02070     }
02071 
02072     <span class="comment">//</span>
02073     <span class="comment">//  Now since we really didn't synchronize anything but the insertion,</span>
02074     <span class="comment">//  we call the post routine to make sure that in some wierd case we</span>
02075     <span class="comment">//  do not leave anyone hanging with no dirty bytes for the Lazy Writer.</span>
02076     <span class="comment">//</span>
02077 
02078     <a class="code" href="../../d5/d5/cc_8h.html#a174">CcPostDeferredWrites</a>();
02079 
02080     <span class="comment">//</span>
02081     <span class="comment">//  Schedule the lazy writer in case the reason we're blocking</span>
02082     <span class="comment">//  is that we're waiting for Mm (or some other external flag)</span>
02083     <span class="comment">//  to lower and let this write happen.  He will be the one to</span>
02084     <span class="comment">//  keep coming back and checking if this can proceed, even if</span>
02085     <span class="comment">//  there are no cache manager pages to write.</span>
02086     <span class="comment">//</span>
02087             
02088     <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql);
02089             
02090     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o5">ScanActive</a>) {
02091         <a class="code" href="../../d5/d5/cc_8h.html#a185">CcScheduleLazyWriteScan</a>();
02092     }
02093 
02094     <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql);
02095 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a75" doxytag="cache.h::CcFastCopyRead" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTKERNELAPI VOID CcFastCopyRead           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>FileObject</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>FileOffset</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Length</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>PageCount</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PIO_STATUS_BLOCK&nbsp;</td>
          <td class="mdname" nowrap> <em>IoStatus</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d6/copysup_8c-source.html#l00588">588</a> of file <a class="el" href="../../d6/d6/copysup_8c-source.html">copysup.c</a>.
<p>
References <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00583">_VACB::BaseAddress</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00662">_PRIVATE_CACHE_MAP::BeyondLastByte1</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00665">_PRIVATE_CACHE_MAP::BeyondLastByte2</a>, <a class="el" href="../../d7/d1/rtqkey_8c-source.html#l00042">Buffer</a>, <a class="el" href="../../d6/d6/copysup_8c-source.html#l01747">CcCopyReadExceptionFilter()</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00189">CcCopyReadWait</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00191">CcCopyReadWaitMiss</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l05885">CcFreeActiveVacb()</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00862">CcFreeVirtualAddress()</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00310">CcGetVirtualAddress()</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00206">CcMissCounter</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l01253">CcScheduleReadAhead()</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00160">CcThrowAway</a>, <a class="el" href="../../d3/d0/mm_8h-source.html#l00221">COMPUTE_PAGES_SPANNED</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02290">DebugTrace</a>, <a class="el" href="../../d1/d3/ex_2alpha_2raisests_8c-source.html#l00157">ExRaiseStatus()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00661">_PRIVATE_CACHE_MAP::FileOffset1</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00664">_PRIVATE_CACHE_MAP::FileOffset2</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00752">_SHARED_CACHE_MAP::FileSize</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00497">FlagOn</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01510">FO_RANDOM_ACCESS</a>, <a class="el" href="../../d8/d2/fsrtl_2filter_8c-source.html#l00049">FsRtlNormalizeNtstatus()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01577">GetActiveVacb</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00385">HOT_STATISTIC</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l00033">me</a>, <a class="el" href="../../d2/d4/mapcache_8c-source.html#l01016">MmCheckCachedPageState()</a>, <a class="el" href="../../d3/d0/mm_8h-source.html#l01053">MmResetPageFaultReadAhead</a>, <a class="el" href="../../d3/d0/mm_8h-source.html#l00983">MmSavePageFaultReadAhead</a>, <a class="el" href="../../d3/d0/mm_8h-source.html#l01018">MmSetPageFaultReadAhead</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00809">_SHARED_CACHE_MAP::NeedToZero</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00600">PAGE_SHIFT</a>, <a class="el" href="../../d2/d8/ps_8h-source.html#l00645">PsGetCurrentThread</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00713">_PRIVATE_CACHE_MAP::ReadAheadEnabled</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00677">_PRIVATE_CACHE_MAP::ReadAheadLength</a>, <a class="el" href="../../d3/d0/mm_8h-source.html#l00117">ROUND_TO_PAGES</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01619">SetActiveVacb</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, <a class="el" href="../../d5/d1/cache_8h-source.html#l00030">VACB_MAPPING_GRANULARITY</a>, and <a class="el" href="../../d5/d1/cache_8h-source.html#l00031">VACB_OFFSET_SHIFT</a>.
<p>
Referenced by <a class="el" href="../../d4/d0/fastio_8c-source.html#l00054">FsRtlCopyRead()</a>.
<p>
<pre class="fragment"><div>00599                    :
00600 
00601     This routine attempts to copy <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> data from <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> cache
00602     into <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> output buffer, and deliver <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> correct I/O status.
00603 
00604     This <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> a faster version of <a class="code" href="../../d5/d7/copysup_8c.html#a1">CcCopyRead</a> which <a class="code" href="../../d3/d0/imm32_8def.html#a1">only</a> supports 32-bit <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a>
00605     offsets and synchronicity (Wait = TRUE).
00606 
00607 Arguments:
00608 
00609     FileObject - Pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> object <span class="keywordflow">for</span> a <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> which was
00610                  opened with NO_INTERMEDIATE_BUFFERING clear, i.e., <span class="keywordflow">for</span>
00611                  which <a class="code" href="../../d5/d8/fssup_8c.html#a9">CcInitializeCacheMap</a> was called by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> system.
00612 
00613     FileOffset - Byte offset in <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> <span class="keywordflow">for</span> desired data.
00614 
00615     Length - Length of desired data in bytes.
00616 
00617     PageCount - Number of pages spanned by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> read.
00618 
00619     <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> - Pointer to output buffer to which data should be copied.
00620 
00621     IoStatus - Pointer to standard I/O status block to receive <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> status
00622                <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> transfer.  (STATUS_SUCCESS guaranteed <span class="keywordflow">for</span> cache
00623                hits, otherwise <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> actual I/O status <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> returned.)
00624 
00625                Note that even <span class="keywordflow">if</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> returned, <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> IoStatus.Information
00626                field will <span class="keywordflow">return</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> count of any bytes successfully
00627                transferred before a blocking condition occured.  The caller
00628                may either choose to ignore <span class="keyword">this</span> information, or resume
00629                <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> copy later accounting <span class="keywordflow">for</span> bytes transferred.
00630 
00631 Return Value:
00632 
00633     None
00634 
00635 --*/
00636 
00637 {
00638     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap;
00639     <a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html">PPRIVATE_CACHE_MAP</a> PrivateCacheMap;
00640     PVOID CacheBuffer;
00641     LARGE_INTEGER FOffset;
00642     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> Vacb;
00643     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> ActiveVacb;
00644     ULONG ActivePage;
00645     ULONG PageIsDirty;
00646     ULONG SavedState;
00647     ULONG PagesToGo;
00648     ULONG MoveLength;
00649     ULONG LengthToGo;
00650     KIRQL OldIrql;
00651     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00652     LARGE_INTEGER OriginalOffset;
00653     ULONG OriginalLength = Length;
00654     <a class="code" href="../../d5/d6/struct__ETHREAD.html">PETHREAD</a> Thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
00655     ULONG GotAMiss = 0;
00656 
00657     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, me, <span class="stringliteral">"CcFastCopyRead\n"</span>, 0 );
00658 
00659     <a class="code" href="../../d2/d1/mm_8h.html#a19">MmSavePageFaultReadAhead</a>( Thread, &amp;SavedState );
00660 
00661     <span class="comment">//</span>
00662     <span class="comment">//  Get pointer to shared and private cache maps</span>
00663     <span class="comment">//</span>
00664 
00665     SharedCacheMap = FileObject-&gt;SectionObjectPointer-&gt;SharedCacheMap;
00666     PrivateCacheMap = FileObject-&gt;PrivateCacheMap;
00667 
00668     <span class="comment">//</span>
00669     <span class="comment">//  Check for read past file size, the caller must filter this case out.</span>
00670     <span class="comment">//</span>
00671 
00672     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( (FileOffset + Length) &lt;= SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o3">FileSize</a>.LowPart );
00673 
00674     <span class="comment">//</span>
00675     <span class="comment">//  If read ahead is enabled, then do the read ahead here so it</span>
00676     <span class="comment">//  overlaps with the copy (otherwise we will do it below).</span>
00677     <span class="comment">//  Note that we are assuming that we will not get ahead of our</span>
00678     <span class="comment">//  current transfer - if read ahead is working it should either</span>
00679     <span class="comment">//  already be in memory or else underway.</span>
00680     <span class="comment">//</span>
00681 
00682     OriginalOffset.LowPart = FileOffset;
00683     OriginalOffset.HighPart = 0;
00684 
00685     <span class="keywordflow">if</span> (PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o13">ReadAheadEnabled</a> &amp;&amp; (PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o8">ReadAheadLength</a>[1] == 0)) {
00686         <a class="code" href="../../d4/d2/cache_8h.html#a84">CcScheduleReadAhead</a>( FileObject, &amp;OriginalOffset, Length );
00687     }
00688 
00689     <span class="comment">//</span>
00690     <span class="comment">//  This is not an exact solution, but when IoPageRead gets a miss,</span>
00691     <span class="comment">//  it cannot tell whether it was CcCopyRead or CcMdlRead, but since</span>
00692     <span class="comment">//  the miss should occur very soon, by loading the pointer here</span>
00693     <span class="comment">//  probably the right counter will get incremented, and in any case,</span>
00694     <span class="comment">//  we hope the errrors average out!</span>
00695     <span class="comment">//</span>
00696 
00697     <a class="code" href="../../d5/d2/cachedat_8c.html#a75">CcMissCounter</a> = &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a64">CcCopyReadWaitMiss</a>;
00698 
00699     <span class="comment">//</span>
00700     <span class="comment">//  Increment performance counters</span>
00701     <span class="comment">//</span>
00702 
00703     <a class="code" href="../../d0/d9/ntosdef_8h.html#a11">HOT_STATISTIC</a>(CcCopyReadWait) += 1;
00704 
00705     <span class="comment">//</span>
00706     <span class="comment">//  See if we have an active Vacb, that we can just copy to.</span>
00707     <span class="comment">//</span>
00708 
00709     <a class="code" href="../../d5/d5/cc_8h.html#a82">GetActiveVacb</a>( SharedCacheMap, OldIrql, ActiveVacb, ActivePage, PageIsDirty );
00710 
00711     <span class="keywordflow">if</span> (ActiveVacb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00712 
00713         <span class="keywordflow">if</span> ((FileOffset &gt;&gt; <a class="code" href="../../d4/d2/cache_8h.html#a1">VACB_OFFSET_SHIFT</a>) == (ActivePage &gt;&gt; (<a class="code" href="../../d4/d2/cache_8h.html#a1">VACB_OFFSET_SHIFT</a> - <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>))) {
00714 
00715             ULONG LengthToCopy = <a class="code" href="../../d4/d2/cache_8h.html#a0">VACB_MAPPING_GRANULARITY</a> - (FileOffset &amp; (<a class="code" href="../../d4/d2/cache_8h.html#a0">VACB_MAPPING_GRANULARITY</a> - 1));
00716 
00717             <span class="keywordflow">if</span> (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o13">NeedToZero</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00718                 <a class="code" href="../../d5/d5/cc_8h.html#a182">CcFreeActiveVacb</a>( SharedCacheMap, NULL, 0, FALSE );
00719             }
00720 
00721             <span class="comment">//</span>
00722             <span class="comment">//  Get the starting point in the view.</span>
00723             <span class="comment">//</span>
00724 
00725             CacheBuffer = (PVOID)((PCHAR)ActiveVacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o0">BaseAddress</a> +
00726                                           (FileOffset &amp; (<a class="code" href="../../d4/d2/cache_8h.html#a0">VACB_MAPPING_GRANULARITY</a> - 1)));
00727 
00728             <span class="comment">//</span>
00729             <span class="comment">//  Reduce LengthToCopy if it is greater than our caller's length.</span>
00730             <span class="comment">//</span>
00731 
00732             <span class="keywordflow">if</span> (LengthToCopy &gt; Length) {
00733                 LengthToCopy = Length;
00734             }
00735 
00736             <span class="comment">//</span>
00737             <span class="comment">//  Like the logic for the normal case below, we want to spin around</span>
00738             <span class="comment">//  making sure Mm only reads the pages we will need.</span>
00739             <span class="comment">//</span>
00740             
00741             PagesToGo = <a class="code" href="../../d2/d1/mm_8h.html#a9">COMPUTE_PAGES_SPANNED</a>( CacheBuffer,
00742                                                LengthToCopy ) - 1;
00743 
00744             <span class="comment">//</span>
00745             <span class="comment">//  Copy the data to the user buffer.</span>
00746             <span class="comment">//</span>
00747 
00748             <span class="keywordflow">try</span> {
00749 
00750                 <span class="keywordflow">if</span> (PagesToGo != 0) {
00751     
00752                     LengthToGo = LengthToCopy;
00753     
00754                     <span class="keywordflow">while</span> (LengthToGo != 0) {
00755     
00756                         MoveLength = (ULONG)((PCHAR)(<a class="code" href="../../d2/d1/mm_8h.html#a4">ROUND_TO_PAGES</a>(((PCHAR)CacheBuffer + 1))) -
00757                                      (PCHAR)CacheBuffer);
00758     
00759                         <span class="keywordflow">if</span> (MoveLength &gt; LengthToGo) {
00760                             MoveLength = LengthToGo;
00761                         }
00762     
00763                         <span class="comment">//</span>
00764                         <span class="comment">//  Here's hoping that it is cheaper to call Mm to see if</span>
00765                         <span class="comment">//  the page is valid.  If not let Mm know how many pages</span>
00766                         <span class="comment">//  we are after before doing the move.</span>
00767                         <span class="comment">//</span>
00768     
00769                         <a class="code" href="../../d2/d1/mm_8h.html#a20">MmSetPageFaultReadAhead</a>( Thread, PagesToGo );
00770                         GotAMiss |= !<a class="code" href="../../d1/d5/mapcache_8c.html#a13">MmCheckCachedPageState</a>( CacheBuffer, FALSE );
00771     
00772                         RtlCopyBytes( Buffer, CacheBuffer, MoveLength );
00773     
00774                         PagesToGo -= 1;
00775     
00776                         LengthToGo -= MoveLength;
00777                         <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> = (PCHAR)<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> + MoveLength;
00778                         CacheBuffer = (PCHAR)CacheBuffer + MoveLength;
00779                     }
00780     
00781                 <span class="comment">//</span>
00782                 <span class="comment">//  Handle the read here that stays on a single page.</span>
00783                 <span class="comment">//</span>
00784     
00785                 } <span class="keywordflow">else</span> {
00786     
00787                     <span class="comment">//</span>
00788                     <span class="comment">//  Here's hoping that it is cheaper to call Mm to see if</span>
00789                     <span class="comment">//  the page is valid.  If not let Mm know how many pages</span>
00790                     <span class="comment">//  we are after before doing the move.</span>
00791                     <span class="comment">//</span>
00792     
00793                     <a class="code" href="../../d2/d1/mm_8h.html#a20">MmSetPageFaultReadAhead</a>( Thread, 0 );
00794                     GotAMiss |= !<a class="code" href="../../d1/d5/mapcache_8c.html#a13">MmCheckCachedPageState</a>( CacheBuffer, FALSE );
00795     
00796                     RtlCopyBytes( Buffer, CacheBuffer, LengthToCopy );
00797     
00798                     <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> = (PCHAR)<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> + LengthToCopy;
00799                 }
00800                 
00801             } except( <a class="code" href="../../d5/d7/copysup_8c.html#a5">CcCopyReadExceptionFilter</a>( GetExceptionInformation(),
00802                                                  &amp;Status ) ) {
00803 
00804                 <a class="code" href="../../d2/d1/mm_8h.html#a21">MmResetPageFaultReadAhead</a>( Thread, SavedState );
00805 
00806 
00807                 <a class="code" href="../../d5/d5/cc_8h.html#a84">SetActiveVacb</a>( SharedCacheMap, OldIrql, ActiveVacb, ActivePage, PageIsDirty );
00808 
00809                 <span class="comment">//</span>
00810                 <span class="comment">//  If we got an access violation, then the user buffer went</span>
00811                 <span class="comment">//  away.  Otherwise we must have gotten an I/O error trying</span>
00812                 <span class="comment">//  to bring the data in.</span>
00813                 <span class="comment">//</span>
00814 
00815                 <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_ACCESS_VIOLATION) {
00816                     <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INVALID_USER_BUFFER );
00817                 }
00818                 <span class="keywordflow">else</span> {
00819                     <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( <a class="code" href="../../d1/d8/fsrtl_8h.html#a136">FsRtlNormalizeNtstatus</a>( Status,
00820                                                            STATUS_UNEXPECTED_IO_ERROR ));
00821                 }
00822             }
00823 
00824             <span class="comment">//</span>
00825             <span class="comment">//  Now adjust FileOffset and Length by what we copied.</span>
00826             <span class="comment">//</span>
00827 
00828             FileOffset += LengthToCopy;
00829             Length -= LengthToCopy;
00830         }
00831 
00832         <span class="comment">//</span>
00833         <span class="comment">//  If that was all the data, then remember the Vacb</span>
00834         <span class="comment">//</span>
00835 
00836         <span class="keywordflow">if</span> (Length == 0) {
00837 
00838             <a class="code" href="../../d5/d5/cc_8h.html#a84">SetActiveVacb</a>( SharedCacheMap, OldIrql, ActiveVacb, ActivePage, PageIsDirty );
00839 
00840         <span class="comment">//</span>
00841         <span class="comment">//  Otherwise we must free it because we will map other vacbs below.</span>
00842         <span class="comment">//</span>
00843 
00844         } <span class="keywordflow">else</span> {
00845 
00846             <a class="code" href="../../d5/d5/cc_8h.html#a182">CcFreeActiveVacb</a>( SharedCacheMap, ActiveVacb, ActivePage, PageIsDirty );
00847         }
00848     }
00849 
00850     <span class="comment">//</span>
00851     <span class="comment">//  Not all of the transfer will come back at once, so we have to loop</span>
00852     <span class="comment">//  until the entire transfer is complete.</span>
00853     <span class="comment">//</span>
00854 
00855     FOffset.HighPart = 0;
00856     FOffset.LowPart = FileOffset;
00857 
00858     <span class="keywordflow">while</span> (Length != 0) {
00859 
00860         ULONG ReceivedLength;
00861         ULONG BeyondLastByte;
00862 
00863         <span class="comment">//</span>
00864         <span class="comment">//  Call local routine to Map or Access the file data, then move the data,</span>
00865         <span class="comment">//  then call another local routine to free the data.  If we cannot map</span>
00866         <span class="comment">//  the data because of a Wait condition, return FALSE.</span>
00867         <span class="comment">//</span>
00868         <span class="comment">//  Note that this call may result in an exception, however, if it</span>
00869         <span class="comment">//  does no Bcb is returned and this routine has absolutely no</span>
00870         <span class="comment">//  cleanup to perform.  Therefore, we do not have a try-finally</span>
00871         <span class="comment">//  and we allow the possibility that we will simply be unwound</span>
00872         <span class="comment">//  without notice.</span>
00873         <span class="comment">//</span>
00874 
00875         CacheBuffer = <a class="code" href="../../d5/d3/vacbsup_8c.html#a15">CcGetVirtualAddress</a>( SharedCacheMap,
00876                                            FOffset,
00877                                            &amp;Vacb,
00878                                            &amp;ReceivedLength );
00879 
00880         BeyondLastByte = FOffset.LowPart + ReceivedLength;
00881 
00882         <span class="comment">//</span>
00883         <span class="comment">//  If we got more than we need, make sure to only transfer</span>
00884         <span class="comment">//  the right amount.</span>
00885         <span class="comment">//</span>
00886 
00887         <span class="keywordflow">if</span> (ReceivedLength &gt; Length) {
00888             ReceivedLength = Length;
00889         }
00890 
00891         <span class="comment">//</span>
00892         <span class="comment">//  It is possible for the user buffer to become no longer accessible</span>
00893         <span class="comment">//  since it was last checked by the I/O system.  If we fail to access</span>
00894         <span class="comment">//  the buffer we must raise a status that the caller's exception</span>
00895         <span class="comment">//  filter considers as "expected".  Also we unmap the Bcb here, since</span>
00896         <span class="comment">//  we otherwise would have no other reason to put a try-finally around</span>
00897         <span class="comment">//  this loop.</span>
00898         <span class="comment">//</span>
00899 
00900         <span class="keywordflow">try</span> {
00901 
00902             PagesToGo = <a class="code" href="../../d2/d1/mm_8h.html#a9">COMPUTE_PAGES_SPANNED</a>( CacheBuffer,
00903                                                ReceivedLength ) - 1;
00904 
00905             <span class="comment">//</span>
00906             <span class="comment">//  We know exactly how much we want to read here, and we do not</span>
00907             <span class="comment">//  want to read any more in case the caller is doing random access.</span>
00908             <span class="comment">//  Our read ahead logic takes care of detecting sequential reads,</span>
00909             <span class="comment">//  and tends to do large asynchronous read aheads.  So far we have</span>
00910             <span class="comment">//  only mapped the data and we have not forced any in.  What we</span>
00911             <span class="comment">//  do now is get into a loop where we copy a page at a time and</span>
00912             <span class="comment">//  just prior to each move, we tell MM how many additional pages</span>
00913             <span class="comment">//  we would like to have read in, in the event that we take a</span>
00914             <span class="comment">//  fault.  With this strategy, for cache hits we never make a single</span>
00915             <span class="comment">//  expensive call to MM to guarantee that the data is in, yet if we</span>
00916             <span class="comment">//  do take a fault, we are guaranteed to only take one fault because</span>
00917             <span class="comment">//  we will read all of the data in for the rest of the transfer.</span>
00918             <span class="comment">//</span>
00919             <span class="comment">//  We test first for the multiple page case, to keep the small</span>
00920             <span class="comment">//  reads faster.</span>
00921             <span class="comment">//</span>
00922 
00923             <span class="keywordflow">if</span> (PagesToGo != 0) {
00924 
00925                 LengthToGo = ReceivedLength;
00926 
00927                 <span class="keywordflow">while</span> (LengthToGo != 0) {
00928 
00929                     MoveLength = (ULONG)((PCHAR)(<a class="code" href="../../d2/d1/mm_8h.html#a4">ROUND_TO_PAGES</a>(((PCHAR)CacheBuffer + 1))) -
00930                                  (PCHAR)CacheBuffer);
00931 
00932                     <span class="keywordflow">if</span> (MoveLength &gt; LengthToGo) {
00933                         MoveLength = LengthToGo;
00934                     }
00935 
00936                     <span class="comment">//</span>
00937                     <span class="comment">//  Here's hoping that it is cheaper to call Mm to see if</span>
00938                     <span class="comment">//  the page is valid.  If not let Mm know how many pages</span>
00939                     <span class="comment">//  we are after before doing the move.</span>
00940                     <span class="comment">//</span>
00941 
00942                     <a class="code" href="../../d2/d1/mm_8h.html#a20">MmSetPageFaultReadAhead</a>( Thread, PagesToGo );
00943                     GotAMiss |= !<a class="code" href="../../d1/d5/mapcache_8c.html#a13">MmCheckCachedPageState</a>( CacheBuffer, FALSE );
00944 
00945                     RtlCopyBytes( Buffer, CacheBuffer, MoveLength );
00946 
00947                     PagesToGo -= 1;
00948 
00949                     LengthToGo -= MoveLength;
00950                     <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> = (PCHAR)<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> + MoveLength;
00951                     CacheBuffer = (PCHAR)CacheBuffer + MoveLength;
00952                 }
00953 
00954             <span class="comment">//</span>
00955             <span class="comment">//  Handle the read here that stays on a single page.</span>
00956             <span class="comment">//</span>
00957 
00958             } <span class="keywordflow">else</span> {
00959 
00960                 <span class="comment">//</span>
00961                 <span class="comment">//  Here's hoping that it is cheaper to call Mm to see if</span>
00962                 <span class="comment">//  the page is valid.  If not let Mm know how many pages</span>
00963                 <span class="comment">//  we are after before doing the move.</span>
00964                 <span class="comment">//</span>
00965 
00966                 <a class="code" href="../../d2/d1/mm_8h.html#a20">MmSetPageFaultReadAhead</a>( Thread, 0 );
00967                 GotAMiss |= !<a class="code" href="../../d1/d5/mapcache_8c.html#a13">MmCheckCachedPageState</a>( CacheBuffer, FALSE );
00968 
00969                 RtlCopyBytes( Buffer, CacheBuffer, ReceivedLength );
00970 
00971                 <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> = (PCHAR)<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> + ReceivedLength;
00972             }
00973         }
00974         except( <a class="code" href="../../d5/d7/copysup_8c.html#a5">CcCopyReadExceptionFilter</a>( GetExceptionInformation(),
00975                                            &amp;Status ) ) {
00976 
00977             <a class="code" href="../../d5/d2/cachedat_8c.html#a75">CcMissCounter</a> = &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a43">CcThrowAway</a>;
00978 
00979             <span class="comment">//</span>
00980             <span class="comment">//  If we get an exception, then we have to renable page fault</span>
00981             <span class="comment">//  clustering and unmap on the way out.</span>
00982             <span class="comment">//</span>
00983 
00984             <a class="code" href="../../d2/d1/mm_8h.html#a21">MmResetPageFaultReadAhead</a>( Thread, SavedState );
00985 
00986 
00987             <a class="code" href="../../d5/d3/vacbsup_8c.html#a16">CcFreeVirtualAddress</a>( Vacb );
00988 
00989             <span class="comment">//</span>
00990             <span class="comment">//  If we got an access violation, then the user buffer went</span>
00991             <span class="comment">//  away.  Otherwise we must have gotten an I/O error trying</span>
00992             <span class="comment">//  to bring the data in.</span>
00993             <span class="comment">//</span>
00994 
00995             <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_ACCESS_VIOLATION) {
00996                 <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INVALID_USER_BUFFER );
00997             }
00998             <span class="keywordflow">else</span> {
00999                 <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( <a class="code" href="../../d1/d8/fsrtl_8h.html#a136">FsRtlNormalizeNtstatus</a>( Status,
01000                                                        STATUS_UNEXPECTED_IO_ERROR ));
01001             }
01002         }
01003 
01004         <span class="comment">//</span>
01005         <span class="comment">//  Update number of bytes transferred.</span>
01006         <span class="comment">//</span>
01007 
01008         Length -= ReceivedLength;
01009 
01010         <span class="comment">//</span>
01011         <span class="comment">//  Unmap the data now, and calculate length left to transfer.</span>
01012         <span class="comment">//</span>
01013 
01014         <span class="keywordflow">if</span> (Length != 0) {
01015 
01016             <span class="comment">//</span>
01017             <span class="comment">//  If there is more to go, just free this vacb.</span>
01018             <span class="comment">//</span>
01019 
01020             <a class="code" href="../../d5/d3/vacbsup_8c.html#a16">CcFreeVirtualAddress</a>( Vacb );
01021 
01022         } <span class="keywordflow">else</span> {
01023 
01024             <span class="comment">//</span>
01025             <span class="comment">//  Otherwise save it for the next time through.</span>
01026             <span class="comment">//</span>
01027 
01028             <a class="code" href="../../d5/d5/cc_8h.html#a84">SetActiveVacb</a>( SharedCacheMap, OldIrql, Vacb, (FOffset.LowPart &gt;&gt; PAGE_SHIFT), 0 );
01029             <span class="keywordflow">break</span>;
01030         }
01031 
01032         <span class="comment">//</span>
01033         <span class="comment">//  Assume we did not get all the data we wanted, and set FOffset</span>
01034         <span class="comment">//  to the end of the returned data.</span>
01035         <span class="comment">//</span>
01036 
01037         FOffset.LowPart = BeyondLastByte;
01038     }
01039 
01040     <a class="code" href="../../d2/d1/mm_8h.html#a21">MmResetPageFaultReadAhead</a>( Thread, SavedState );
01041 
01042     <a class="code" href="../../d5/d2/cachedat_8c.html#a75">CcMissCounter</a> = &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a43">CcThrowAway</a>;
01043 
01044     <span class="comment">//</span>
01045     <span class="comment">//  Now enable read ahead if it looks like we got any misses, and do</span>
01046     <span class="comment">//  the first one.</span>
01047     <span class="comment">//</span>
01048 
01049     <span class="keywordflow">if</span> (GotAMiss &amp;&amp;
01050         !<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( FileObject-&gt;Flags, FO_RANDOM_ACCESS ) &amp;&amp;
01051         !PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o13">ReadAheadEnabled</a>) {
01052 
01053         PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o13">ReadAheadEnabled</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01054         <a class="code" href="../../d4/d2/cache_8h.html#a84">CcScheduleReadAhead</a>( FileObject, &amp;OriginalOffset, OriginalLength );
01055     }
01056 
01057     <span class="comment">//</span>
01058     <span class="comment">//  Now that we have described our desired read ahead, let's</span>
01059     <span class="comment">//  shift the read history down.</span>
01060     <span class="comment">//</span>
01061 
01062     PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o3">FileOffset1</a>.LowPart = PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o5">FileOffset2</a>.LowPart;
01063     PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o4">BeyondLastByte1</a>.LowPart = PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o6">BeyondLastByte2</a>.LowPart;
01064     PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o5">FileOffset2</a>.LowPart = OriginalOffset.LowPart;
01065     PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o6">BeyondLastByte2</a>.LowPart = OriginalOffset.LowPart + OriginalLength;
01066 
01067     IoStatus-&gt;Status = STATUS_SUCCESS;
01068     IoStatus-&gt;Information = OriginalLength;
01069 
01070     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, me, <span class="stringliteral">"CcFastCopyRead -&gt; VOID\n"</span>, 0 );
01071 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a77" doxytag="cache.h::CcFastCopyWrite" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTKERNELAPI VOID CcFastCopyWrite           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>FileObject</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>FileOffset</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Length</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>Buffer</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d6/copysup_8c-source.html#l01482">1482</a> of file <a class="el" href="../../d6/d6/copysup_8c-source.html">copysup.c</a>.
<p>
References <a class="el" href="../../d6/d4/cc_8h-source.html#l01065">ACTIVE_PAGE_IS_DIRTY</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00816">_SHARED_CACHE_MAP::ActiveVacbSpinLock</a>, <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00583">_VACB::BaseAddress</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00501">BooleanFlagOn</a>, <a class="el" href="../../d7/d1/rtqkey_8c-source.html#l00042">Buffer</a>, <a class="el" href="../../d6/d6/copysup_8c-source.html#l01747">CcCopyReadExceptionFilter()</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l05885">CcFreeActiveVacb()</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l06024">CcMapAndCopy()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02290">DebugTrace</a>, <a class="el" href="../../d1/d3/ex_2alpha_2raisests_8c-source.html#l00157">ExRaiseStatus()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00497">FlagOn</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01494">FO_WRITE_THROUGH</a>, <a class="el" href="../../d8/d2/fsrtl_2filter_8c-source.html#l00049">FsRtlNormalizeNtstatus()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01577">GetActiveVacb</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l00033">me</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00809">_SHARED_CACHE_MAP::NeedToZero</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00957">_SHARED_CACHE_MAP::NeedToZeroVacb</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00600">PAGE_SHIFT</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00599">PAGE_SIZE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01619">SetActiveVacb</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, <a class="el" href="../../d5/d1/cache_8h-source.html#l00030">VACB_MAPPING_GRANULARITY</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01798">ZERO_FIRST_PAGE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01800">ZERO_LAST_PAGE</a>, and <a class="el" href="../../d6/d4/cc_8h-source.html#l01799">ZERO_MIDDLE_PAGES</a>.
<p>
Referenced by <a class="el" href="../../d4/d0/fastio_8c-source.html#l00330">FsRtlCopyWrite()</a>.
<p>
<pre class="fragment"><div>01491                    :
01492 
01493     This routine attempts to copy <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> data from <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified
01494     buffer into <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Cache, and deliver <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> correct I/O status.
01495 
01496     This <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> a faster version of <a class="code" href="../../d5/d7/copysup_8c.html#a3">CcCopyWrite</a> which <a class="code" href="../../d3/d0/imm32_8def.html#a1">only</a> supports 32-bit <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a>
01497     offsets and synchronicity (Wait = TRUE) and no Write Through.
01498 
01499 Arguments:
01500 
01501     FileObject - Pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> object <span class="keywordflow">for</span> a <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> which was
01502                  opened with NO_INTERMEDIATE_BUFFERING clear, i.e., <span class="keywordflow">for</span>
01503                  which <a class="code" href="../../d5/d8/fssup_8c.html#a9">CcInitializeCacheMap</a> was called by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> system.
01504 
01505     FileOffset - Byte offset in <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> to receive <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data.
01506 
01507     Length - Length of data in bytes.
01508 
01509     <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> - Pointer to input buffer from which data should be copied.
01510 
01511 Return Value:
01512 
01513     None
01514 
01515 Raises:
01516 
01517     STATUS_INSUFFICIENT_RESOURCES - If a <a class="code" href="../../d4/d6/regext_8c.html#a17">pool</a> allocation <a class="code" href="../../d8/d0/rtbatcr_8c.html#a1">failure</a> occurs.
01518         This can <a class="code" href="../../d3/d0/imm32_8def.html#a1">only</a> occur <span class="keywordflow">if</span> Wait was specified as <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>.  (If Wait <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a>
01519         specified as <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, and an allocation <a class="code" href="../../d8/d0/rtbatcr_8c.html#a1">failure</a> occurs, <span class="keyword">this</span>
01520         routine simply returns <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>.)
01521 
01522 --*/
01523 
01524 {
01525     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap;
01526     PVOID CacheBuffer;
01527     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> ActiveVacb;
01528     ULONG ActivePage;
01529     PVOID ActiveAddress;
01530     ULONG PageIsDirty;
01531     KIRQL OldIrql;
01532     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01533     ULONG ZeroFlags;
01534     ULONG ValidDataLength;
01535     LARGE_INTEGER FOffset;
01536 
01537     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, me, <span class="stringliteral">"CcFastCopyWrite\n"</span>, 0 );
01538 
01539     <span class="comment">//</span>
01540     <span class="comment">//  Get pointer to shared cache map and a copy of valid data length</span>
01541     <span class="comment">//</span>
01542 
01543     SharedCacheMap = FileObject-&gt;SectionObjectPointer-&gt;SharedCacheMap;
01544 
01545     <span class="comment">//</span>
01546     <span class="comment">//  See if we have an active Vacb, that we can just copy to.</span>
01547     <span class="comment">//</span>
01548 
01549     <a class="code" href="../../d5/d5/cc_8h.html#a82">GetActiveVacb</a>( SharedCacheMap, OldIrql, ActiveVacb, ActivePage, PageIsDirty );
01550 
01551     <span class="keywordflow">if</span> (ActiveVacb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01552 
01553         <span class="comment">//</span>
01554         <span class="comment">//  See if the request starts in the ActivePage.  WriteThrough requests must</span>
01555         <span class="comment">//  go the longer route through CcMapAndCopy, where WriteThrough flushes are</span>
01556         <span class="comment">//  implemented.</span>
01557         <span class="comment">//</span>
01558 
01559         <span class="keywordflow">if</span> (((FileOffset &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>) == ActivePage) &amp;&amp; (Length != 0) &amp;&amp;
01560             !<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( FileObject-&gt;Flags, FO_WRITE_THROUGH )) {
01561 
01562             ULONG LengthToCopy = <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - (FileOffset &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1));
01563 
01564             <span class="comment">//</span>
01565             <span class="comment">//  Reduce LengthToCopy if it is greater than our caller's length.</span>
01566             <span class="comment">//</span>
01567 
01568             <span class="keywordflow">if</span> (LengthToCopy &gt; Length) {
01569                 LengthToCopy = Length;
01570             }
01571 
01572             <span class="comment">//</span>
01573             <span class="comment">//  Copy the data to the user buffer.</span>
01574             <span class="comment">//</span>
01575 
01576             <span class="keywordflow">try</span> {
01577 
01578                 <span class="comment">//</span>
01579                 <span class="comment">//  If we are copying to a page that is locked down, then</span>
01580                 <span class="comment">//  we have to do it under our spinlock, and update the</span>
01581                 <span class="comment">//  NeedToZero field.</span>
01582                 <span class="comment">//</span>
01583 
01584                 OldIrql = 0xFF;
01585 
01586                 CacheBuffer = (PVOID)((PCHAR)ActiveVacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o0">BaseAddress</a> +
01587                                       (FileOffset &amp; (<a class="code" href="../../d4/d2/cache_8h.html#a0">VACB_MAPPING_GRANULARITY</a> - 1)));
01588 
01589                 <span class="keywordflow">if</span> (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o13">NeedToZero</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01590 
01591                     <span class="comment">//</span>
01592                     <span class="comment">//  The FastLock may not write our "flag".</span>
01593                     <span class="comment">//</span>
01594 
01595                     OldIrql = 0;
01596 
01597                     ExAcquireFastLock( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o15">ActiveVacbSpinLock</a>, &amp;OldIrql );
01598 
01599                     <span class="comment">//</span>
01600                     <span class="comment">//  Note that the NeedToZero could be cleared, since we</span>
01601                     <span class="comment">//  tested it without the spinlock.</span>
01602                     <span class="comment">//</span>
01603 
01604                     ActiveAddress = SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o13">NeedToZero</a>;
01605                     <span class="keywordflow">if</span> ((ActiveAddress != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
01606                         (ActiveVacb == SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o35">NeedToZeroVacb</a>) &amp;&amp;
01607                         (((PCHAR)CacheBuffer + LengthToCopy) &gt; (PCHAR)ActiveAddress)) {
01608 
01609                         <span class="comment">//</span>
01610                         <span class="comment">//  If we are skipping some bytes in the page, then we need</span>
01611                         <span class="comment">//  to zero them.</span>
01612                         <span class="comment">//</span>
01613 
01614                         <span class="keywordflow">if</span> ((PCHAR)CacheBuffer &gt; (PCHAR)ActiveAddress) {
01615 
01616                             RtlZeroMemory( ActiveAddress, (PCHAR)CacheBuffer - (PCHAR)ActiveAddress );
01617                         }
01618                         SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o13">NeedToZero</a> = (PVOID)((PCHAR)CacheBuffer + LengthToCopy);
01619                     }
01620 
01621                     ExReleaseFastLock( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o15">ActiveVacbSpinLock</a>, OldIrql );
01622                 }
01623 
01624                 RtlCopyBytes( CacheBuffer, Buffer, LengthToCopy );
01625 
01626             } except( <a class="code" href="../../d5/d7/copysup_8c.html#a5">CcCopyReadExceptionFilter</a>( GetExceptionInformation(),
01627                                                  &amp;Status ) ) {
01628 
01629                 <span class="comment">//</span>
01630                 <span class="comment">//  If we failed to overwrite the uninitialized data,</span>
01631                 <span class="comment">//  zero it now (we cannot safely restore NeedToZero).</span>
01632                 <span class="comment">//</span>
01633 
01634                 <span class="keywordflow">if</span> (OldIrql != 0xFF) {
01635                     RtlZeroBytes( CacheBuffer, LengthToCopy );
01636                 }
01637 
01638                 <a class="code" href="../../d5/d5/cc_8h.html#a84">SetActiveVacb</a>( SharedCacheMap, OldIrql, ActiveVacb, ActivePage, ACTIVE_PAGE_IS_DIRTY );
01639 
01640                 <span class="comment">//</span>
01641                 <span class="comment">//  If we got an access violation, then the user buffer went</span>
01642                 <span class="comment">//  away.  Otherwise we must have gotten an I/O error trying</span>
01643                 <span class="comment">//  to bring the data in.</span>
01644                 <span class="comment">//</span>
01645 
01646                 <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_ACCESS_VIOLATION) {
01647                     <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INVALID_USER_BUFFER );
01648                 }
01649                 <span class="keywordflow">else</span> {
01650                     <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( <a class="code" href="../../d1/d8/fsrtl_8h.html#a136">FsRtlNormalizeNtstatus</a>( Status,
01651                                                            STATUS_UNEXPECTED_IO_ERROR ));
01652                 }
01653             }
01654 
01655             <span class="comment">//</span>
01656             <span class="comment">//  Now adjust FileOffset and Length by what we copied.</span>
01657             <span class="comment">//</span>
01658 
01659             <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> = (PVOID)((PCHAR)<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> + LengthToCopy);
01660             FileOffset += LengthToCopy;
01661             Length -= LengthToCopy;
01662 
01663             <span class="comment">//</span>
01664             <span class="comment">//  If that was all the data, then get outski...</span>
01665             <span class="comment">//</span>
01666 
01667             <span class="keywordflow">if</span> (Length == 0) {
01668 
01669                 <a class="code" href="../../d5/d5/cc_8h.html#a84">SetActiveVacb</a>( SharedCacheMap, OldIrql, ActiveVacb, ActivePage, ACTIVE_PAGE_IS_DIRTY );
01670                 <span class="keywordflow">return</span>;
01671             }
01672 
01673             <span class="comment">//</span>
01674             <span class="comment">//  Remember that the page is dirty now.</span>
01675             <span class="comment">//</span>
01676 
01677             PageIsDirty |= <a class="code" href="../../d5/d5/cc_8h.html#a76">ACTIVE_PAGE_IS_DIRTY</a>;
01678         }
01679 
01680         <a class="code" href="../../d5/d5/cc_8h.html#a182">CcFreeActiveVacb</a>( SharedCacheMap, ActiveVacb, ActivePage, PageIsDirty );
01681 
01682     <span class="comment">//</span>
01683     <span class="comment">//  Else someone else could have the active page, and may want to zero</span>
01684     <span class="comment">//  the range we plan to write!</span>
01685     <span class="comment">//</span>
01686 
01687     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o13">NeedToZero</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01688 
01689         <a class="code" href="../../d5/d5/cc_8h.html#a182">CcFreeActiveVacb</a>( SharedCacheMap, NULL, 0, FALSE );
01690     }
01691 
01692     <span class="comment">//</span>
01693     <span class="comment">//  Set up for call to CcMapAndCopy</span>
01694     <span class="comment">//</span>
01695 
01696     FOffset.LowPart = FileOffset;
01697     FOffset.HighPart = 0;
01698 
01699     ValidDataLength = ((<a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html">PFSRTL_COMMON_FCB_HEADER</a>)FileObject-&gt;FsContext)-&gt;ValidDataLength.LowPart;
01700 
01701     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>((ValidDataLength == MAXULONG) ||
01702            (((<a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html">PFSRTL_COMMON_FCB_HEADER</a>)FileObject-&gt;FsContext)-&gt;ValidDataLength.HighPart == 0));
01703 
01704     <span class="comment">//</span>
01705     <span class="comment">//  At this point we can calculate the ReadOnly flag for</span>
01706     <span class="comment">//  the purposes of whether to use the Bcb resource, and</span>
01707     <span class="comment">//  we can calculate the ZeroFlags.</span>
01708     <span class="comment">//</span>
01709 
01710     <span class="comment">//</span>
01711     <span class="comment">//  We can always zero middle pages, if any.</span>
01712     <span class="comment">//</span>
01713 
01714     ZeroFlags = <a class="code" href="../../d5/d5/cc_8h.html#a86">ZERO_MIDDLE_PAGES</a>;
01715 
01716     <span class="keywordflow">if</span> (((FileOffset &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1)) == 0) &amp;&amp;
01717         (Length &gt;= <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>)) {
01718         ZeroFlags |= <a class="code" href="../../d5/d5/cc_8h.html#a85">ZERO_FIRST_PAGE</a>;
01719     }
01720 
01721     <span class="keywordflow">if</span> (((FileOffset + Length) &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1)) == 0) {
01722         ZeroFlags |= <a class="code" href="../../d5/d5/cc_8h.html#a87">ZERO_LAST_PAGE</a>;
01723     }
01724 
01725     <span class="keywordflow">if</span> ((FileOffset &amp; ~(<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1)) &gt;= ValidDataLength) {
01726         ZeroFlags |= <a class="code" href="../../d5/d5/cc_8h.html#a85">ZERO_FIRST_PAGE</a> | <a class="code" href="../../d5/d5/cc_8h.html#a86">ZERO_MIDDLE_PAGES</a> | <a class="code" href="../../d5/d5/cc_8h.html#a87">ZERO_LAST_PAGE</a>;
01727     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (((FileOffset &amp; ~(<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1)) + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>) &gt;= ValidDataLength) {
01728         ZeroFlags |= <a class="code" href="../../d5/d5/cc_8h.html#a86">ZERO_MIDDLE_PAGES</a> | <a class="code" href="../../d5/d5/cc_8h.html#a87">ZERO_LAST_PAGE</a>;
01729     }
01730 
01731     <span class="comment">//</span>
01732     <span class="comment">//  Call a routine to map and copy the data in Mm and get out.</span>
01733     <span class="comment">//</span>
01734 
01735     <a class="code" href="../../d5/d5/cc_8h.html#a183">CcMapAndCopy</a>( SharedCacheMap,
01736                   Buffer,
01737                   &amp;FOffset,
01738                   Length,
01739                   ZeroFlags,
01740                   <a class="code" href="../../d5/d5/cc_8h.html#a59">BooleanFlagOn</a>( FileObject-&gt;Flags, FO_WRITE_THROUGH ));
01741 
01742     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, me, <span class="stringliteral">"CcFastCopyWrite -&gt; VOID\n"</span>, 0 );
01743 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a63" doxytag="cache.h::CcFlushCache" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTKERNELAPI VOID CcFlushCache           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d7/d0/struct__SECTION__OBJECT__POINTERS.html">PSECTION_OBJECT_POINTERS</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>SectionObjectPointer</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PLARGE_INTEGER FileOffset&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Length</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PIO_STATUS_BLOCK IoStatus&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d7/d1/cachesub_8c-source.html#l04411">4411</a> of file <a class="el" href="../../d7/d1/cachesub_8c-source.html">cachesub.c</a>.
<p>
References <a class="el" href="../../d6/d4/cc_8h-source.html#l00803">_SHARED_CACHE_MAP::ActivePage</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00802">_SHARED_CACHE_MAP::ActiveVacb</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00442">CC_REQUEUE</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l02861">CcAcquireByteRangeForWrite()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00064">CcAcquireMasterLock</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01010">CcDecrementOpenCount</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00096">CcDeferredWrites</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00031">CcDirtySharedCacheMapList</a>, <a class="el" href="../../d6/d0/lazyrite_8c-source.html#l00619">CcExceptionFilter()</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l05885">CcFreeActiveVacb()</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00862">CcFreeVirtualAddress()</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00230">CcGetVirtualAddressIfMapped()</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00063">CcIdleDelayTick</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01003">CcIncrementOpenCount</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00200">CcLazyWriteHotSpots</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00201">CcLazyWriteIos</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00202">CcLazyWritePages</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00064">CcNoDelay</a>, <a class="el" href="../../d6/d6/copysup_8c-source.html#l02099">CcPostDeferredWrites()</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l03758">CcReleaseByteRangeFromWrite()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00067">CcReleaseMasterLock</a>, <a class="el" href="../../d6/d0/lazyrite_8c-source.html#l00049">CcScheduleLazyWriteScan()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02290">DebugTrace</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02292">DebugTrace2</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00846">_SHARED_CACHE_MAP::DirtyPages</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00796">_SHARED_CACHE_MAP::FileObject</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00752">_SHARED_CACHE_MAP::FileSize</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00497">FlagOn</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00832">_SHARED_CACHE_MAP::Flags</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01519">_FILE_OBJECT::FsContext</a>, <a class="el" href="../../d2/d7/fsrtl_8h-source.html#l00229">FSRTL_FLAG_USER_MAPPED_FILE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01588">GetActiveVacbAtDpcLevel</a>, <a class="el" href="../../d8/d9/ke_2miscc_8c-source.html#l00182">KeQueryTickCount()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01083">LAZY_WRITE_OCCURRED</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00939">_SHARED_CACHE_MAP::LazyWritePassCount</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00129">LazyWriter</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l00033">me</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00462">mm</a>, <a class="el" href="../../d7/d4/flushsec_8c-source.html#l00668">MmFlushSection()</a>, <a class="el" href="../../d6/d5/iosup_8c-source.html#l05920">MmSetAddressRangeModified()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01077">MODIFIED_WRITE_DISABLED</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00809">_SHARED_CACHE_MAP::NeedToZero</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00810">_SHARED_CACHE_MAP::NeedToZeroPage</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l00033">Offset</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00740">_SHARED_CACHE_MAP::OpenCount</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01471">_LAZY_WRITER::OtherWork</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00600">PAGE_SHIFT</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00599">PAGE_SIZE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00886">_SHARED_CACHE_MAP::PagesToWrite</a>, <a class="el" href="../../d2/d7/fsrtl_8h-source.html#l00147">PFSRTL_COMMON_FCB_HEADER</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01038">PIN_ACCESS</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l00039">RetryError</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01464">_LAZY_WRITER::ScanActive</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01521">_FILE_OBJECT::SectionObjectPointer</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00505">SetFlag</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01113">_SHARED_CACHE_MAP_LIST_CURSOR::SharedCacheMapLinks</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00826">_SHARED_CACHE_MAP::SharedCacheMapLinks</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00780">_SHARED_CACHE_MAP::ValidDataGoal</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00773">_SHARED_CACHE_MAP::ValidDataLength</a>, and <a class="el" href="../../d6/d4/cc_8h-source.html#l01051">WRITE_QUEUED</a>.
<p>
Referenced by <a class="el" href="../../d7/d1/cachesub_8c-source.html#l03880">CcWriteBehind()</a>, <a class="el" href="../../d6/d7/fssup_8c-source.html#l02804">CcZeroEndOfLastPage()</a>, <a class="el" href="../../d8/d1/lfs_2cachesup_8c-source.html#l00551">LfsFlushLfcb()</a>, <a class="el" href="../../d1/d6/lfs_2registry_8c-source.html#l04321">LfsFlushLogPage()</a>, and <a class="el" href="../../d1/d7/creasect_8c-source.html#l04999">MiFlushDataSection()</a>.
<p>
<pre class="fragment"><div>04420                    :
04421 
04422     This routine may be called to flush dirty data from <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> cache to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
04423     cached <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> on disk.  Any byte range within <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> may be flushed,
04424     or <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> entire <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> may be flushed by omitting <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> FileOffset parameter.
04425 
04426     This routine does not take a Wait parameter; <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller should assume
04427     that <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> will always block.
04428 
04429 Arguments:
04430 
04431     SectionObjectPointer - <a class="code" href="../../d2/d1/bench_8h.html#a5">A</a> pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Section Object Pointers
04432                            structure in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> nonpaged Fcb.
04433 
04434     FileOffset - If <span class="keyword">this</span> parameter <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> supplied (not NULL), then <a class="code" href="../../d3/d0/imm32_8def.html#a1">only</a> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
04435                  byte range specified by FileOffset and Length are flushed.
04436                  If &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a13">CcNoDelay</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> specified, then <span class="keyword">this</span> signifies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> call
04437                  from <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Lazy <a class="code" href="../../d4/d0/tex_8c.html#a44">Writer</a>, and <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> lazy write scan should resume
04438                  as normal from <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> last spot where <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> left off in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a>.
04439 
04440     Length - Defines <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> length of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> byte range to flush, starting at
04441              FileOffset.  This parameter <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> ignored <span class="keywordflow">if</span> FileOffset <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a>
04442              specified as <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>.
04443 
04444     IoStatus - The I/O status resulting from <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> flush operation.
04445 
04446 Return Value:
04447 
04448     None.
04449 
04450 --*/
04451 
04452 {
04453     LARGE_INTEGER NextFileOffset, TargetOffset;
04454     ULONG NextLength;
04455     <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> FirstBcb;
04456     KIRQL OldIrql;
04457     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap;
04458     IO_STATUS_BLOCK TrashStatus;
04459     PVOID TempVa;
04460     ULONG RemainingLength, TempLength;
04461     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> PopupStatus;
04462     BOOLEAN HotSpot;
04463     ULONG BytesWritten = 0;
04464     BOOLEAN PopupRequired = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04465     BOOLEAN VerifyRequired = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04466     BOOLEAN IsLazyWriter = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04467     BOOLEAN FreeActiveVacb = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04468     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> ActiveVacb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04469     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
04470     LARGE_INTEGER EndTick, CurrentTick;
04471 
04472     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, me, <span class="stringliteral">"CcFlushCache:\n"</span>, 0 );
04473     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, mm, <span class="stringliteral">"    SectionObjectPointer = %08lx\n"</span>, SectionObjectPointer );
04474     <a class="code" href="../../d5/d5/cc_8h.html#a92">DebugTrace2</a>(0, me, <span class="stringliteral">"    FileOffset = %08lx, %08lx\n"</span>,
04475                             ARGUMENT_PRESENT(FileOffset) ? FileOffset-&gt;LowPart
04476                                                          : 0,
04477                             ARGUMENT_PRESENT(FileOffset) ? FileOffset-&gt;HighPart
04478                                                          : 0 );
04479     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, me, <span class="stringliteral">"    Length = %08lx\n"</span>, Length );
04480 
04481     <span class="comment">//</span>
04482     <span class="comment">//  If IoStatus passed a Null pointer, set up to through status away.</span>
04483     <span class="comment">//</span>
04484 
04485     <span class="keywordflow">if</span> (!ARGUMENT_PRESENT(IoStatus)) {
04486         IoStatus = &amp;TrashStatus;
04487     }
04488     IoStatus-&gt;Status = STATUS_SUCCESS;
04489     IoStatus-&gt;Information = 0;
04490 
04491     <span class="comment">//</span>
04492     <span class="comment">//  See if this is the Lazy Writer.  Since he wants to use this common</span>
04493     <span class="comment">//  routine, which is also a public routine callable by file systems,</span>
04494     <span class="comment">//  the Lazy Writer shows his call by specifying CcNoDelay as the file offset!</span>
04495     <span class="comment">//</span>
04496     <span class="comment">//  Also, in case we do not write anything because we see only HotSpot(s),</span>
04497     <span class="comment">//  initialize the Status to indicate a retryable error, so CcWorkerThread</span>
04498     <span class="comment">//  knows we did not make any progress.  Of course any actual flush will</span>
04499     <span class="comment">//  overwrite this code.</span>
04500     <span class="comment">//</span>
04501 
04502     <span class="keywordflow">if</span> (FileOffset == &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a13">CcNoDelay</a>) {
04503         IoStatus-&gt;Status = STATUS_VERIFY_REQUIRED;
04504         IsLazyWriter = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04505         FileOffset = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04506     }
04507 
04508     <span class="comment">//</span>
04509     <span class="comment">//  If there is nothing to do, return here.</span>
04510     <span class="comment">//</span>
04511 
04512     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(FileOffset) &amp;&amp; (Length == 0)) {
04513 
04514         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, me, <span class="stringliteral">"CcFlushCache -&gt; VOID\n"</span>, 0 );
04515         <span class="keywordflow">return</span>;
04516     }
04517 
04518     <span class="comment">//</span>
04519     <span class="comment">//  See if the file is cached.</span>
04520     <span class="comment">//</span>
04521 
04522     <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
04523 
04524     SharedCacheMap = SectionObjectPointer-&gt;SharedCacheMap;
04525 
04526     <span class="keywordflow">if</span> (SharedCacheMap != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
04527 
04528         <span class="comment">//</span>
04529         <span class="comment">//  Increment the open count to keep it from going away.</span>
04530         <span class="comment">//</span>
04531 
04532         <a class="code" href="../../d5/d5/cc_8h.html#a68">CcIncrementOpenCount</a>( SharedCacheMap, 'fcCS' );
04533 
04534         <span class="keywordflow">if</span> ((SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o13">NeedToZero</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) || (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o11">ActiveVacb</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
04535 
04536             ULONG FirstPage = 0;
04537             ULONG LastPage = MAXULONG;
04538 
04539             <span class="keywordflow">if</span> (ARGUMENT_PRESENT(FileOffset)) {
04540 
04541                 FirstPage = (ULONG)(FileOffset-&gt;QuadPart &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
04542                 LastPage = (ULONG)((FileOffset-&gt;QuadPart + Length - 1) &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
04543             }
04544 
04545             <span class="comment">//</span>
04546             <span class="comment">//  Make sure we do not flush the active page without zeroing any</span>
04547             <span class="comment">//  uninitialized data.  Also, it is very important to free the active</span>
04548             <span class="comment">//  page if it is the one to be flushed, so that we get the dirty</span>
04549             <span class="comment">//  bit out to the Pfn.</span>
04550             <span class="comment">//</span>
04551 
04552             <span class="keywordflow">if</span> (((((LONGLONG)LastPage + 1) &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>) &gt; SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o7">ValidDataGoal</a>.QuadPart) ||
04553 
04554                 ((SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o13">NeedToZero</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
04555                  (FirstPage &lt;= SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o14">NeedToZeroPage</a>) &amp;&amp;
04556                  (LastPage &gt;= SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o14">NeedToZeroPage</a>)) ||
04557 
04558                 ((SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o11">ActiveVacb</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
04559                  (FirstPage &lt;= SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o12">ActivePage</a>) &amp;&amp;
04560                  (LastPage &gt;= SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o12">ActivePage</a>))) {
04561 
04562                 <a class="code" href="../../d5/d5/cc_8h.html#a83">GetActiveVacbAtDpcLevel</a>( SharedCacheMap, ActiveVacb, RemainingLength, TempLength );
04563                 FreeActiveVacb = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04564             }
04565         }
04566     }
04567 
04568     <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
04569 
04570     <span class="keywordflow">if</span> (FreeActiveVacb) {
04571         <a class="code" href="../../d5/d5/cc_8h.html#a182">CcFreeActiveVacb</a>( SharedCacheMap, ActiveVacb, RemainingLength, TempLength );
04572     }
04573 
04574     <span class="comment">//</span>
04575     <span class="comment">//  If there is a user-mapped file, then we perform the "service" of</span>
04576     <span class="comment">//  flushing even data not written via the file system.  Note that this</span>
04577     <span class="comment">//  is pretty important for folks provoking the flush/purge of a coherency</span>
04578     <span class="comment">//  operation.</span>
04579     <span class="comment">//</span>
04580     <span class="comment">//  It is critical this happen before we examine our own hints.  In the course</span>
04581     <span class="comment">//  of this flush it is possible valid data length will be advanced by the</span>
04582     <span class="comment">//  underlying filesystem, with CcZero'ing behind - which will cause us to</span>
04583     <span class="comment">//  make some dirty zeroes in the cache.  Syscache bug!  Note how coherency</span>
04584     <span class="comment">//  flushing works ...</span>
04585     <span class="comment">//</span>
04586 
04587     <span class="keywordflow">if</span> ((SharedCacheMap == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)
04588 
04589             ||
04590 
04591         <a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(((<a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html">PFSRTL_COMMON_FCB_HEADER</a>)(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o10">FileObject</a>-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o4">FsContext</a>))-&gt;Flags,
04592                FSRTL_FLAG_USER_MAPPED_FILE) &amp;&amp; !IsLazyWriter) {
04593 
04594         <span class="comment">//</span>
04595         <span class="comment">//  Call MM to flush the section through our view.</span>
04596         <span class="comment">//</span>
04597 
04598         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, mm, <span class="stringliteral">"MmFlushSection:\n"</span>, 0 );
04599         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, mm, <span class="stringliteral">"    SectionObjectPointer = %08lx\n"</span>, SectionObjectPointer );
04600         <a class="code" href="../../d5/d5/cc_8h.html#a92">DebugTrace2</a>(0, me, <span class="stringliteral">"    FileOffset = %08lx, %08lx\n"</span>,
04601                                 ARGUMENT_PRESENT(FileOffset) ? FileOffset-&gt;LowPart
04602                                                              : 0,
04603                                 ARGUMENT_PRESENT(FileOffset) ? FileOffset-&gt;HighPart
04604                                                              : 0 );
04605         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, mm, <span class="stringliteral">"    RegionSize = %08lx\n"</span>, Length );
04606 
04607         <span class="keywordflow">try</span> {
04608 
04609             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d6/d5/flushsec_8c.html#a8">MmFlushSection</a>( SectionObjectPointer,
04610                                      FileOffset,
04611                                      Length,
04612                                      IoStatus,
04613                                      TRUE );
04614 
04615         } except( <a class="code" href="../../d5/d1/lazyrite_8c.html#a7">CcExceptionFilter</a>( IoStatus-&gt;Status = GetExceptionCode() )) {
04616 
04617             KdPrint((<span class="stringliteral">"CACHE MANAGER: MmFlushSection raised %08lx\n"</span>, IoStatus-&gt;Status));
04618         }
04619 
04620         <span class="keywordflow">if</span> ((!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(IoStatus-&gt;Status)) &amp;&amp; !<a class="code" href="../../d6/d2/cachesub_8c.html#a2">RetryError</a>(IoStatus-&gt;Status)) {
04621 
04622             PopupRequired = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04623             PopupStatus = IoStatus-&gt;Status;
04624         }
04625 
04626         <a class="code" href="../../d5/d5/cc_8h.html#a92">DebugTrace2</a>(0, mm, <span class="stringliteral">"    &lt;IoStatus = %08lx, %08lx\n"</span>,
04627                     IoStatus-&gt;Status, IoStatus-&gt;Information );
04628     }
04629 
04630     <span class="comment">//</span>
04631     <span class="comment">//  Scan for dirty pages if there is a shared cache map.</span>
04632     <span class="comment">//</span>
04633 
04634     <span class="keywordflow">if</span> (SharedCacheMap != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
04635 
04636         <span class="comment">//</span>
04637         <span class="comment">//  If FileOffset was not specified then set to flush entire region</span>
04638         <span class="comment">//  and set valid data length to the goal so that we will not get</span>
04639         <span class="comment">//  any more call backs.</span>
04640         <span class="comment">//</span>
04641 
04642         <span class="keywordflow">if</span> (!IsLazyWriter &amp;&amp; !ARGUMENT_PRESENT(FileOffset)) {
04643 
04644             SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o6">ValidDataLength</a> = SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o7">ValidDataGoal</a>;
04645         }
04646 
04647         <span class="comment">//</span>
04648         <span class="comment">//  If this is an explicit flush, initialize our offset to scan for.</span>
04649         <span class="comment">//</span>
04650 
04651         <span class="keywordflow">if</span> (ARGUMENT_PRESENT(FileOffset)) {
04652             TargetOffset = *FileOffset;
04653         }
04654 
04655         <span class="comment">//</span>
04656         <span class="comment">//  Assume we want to pass the explicit flush flag in Length.</span>
04657         <span class="comment">//  But overwrite it if a length really was specified.  On</span>
04658         <span class="comment">//  subsequent loops, NextLength will have some nonzero value.</span>
04659         <span class="comment">//</span>
04660 
04661         NextLength = 1;
04662         <span class="keywordflow">if</span> (Length != 0) {
04663             NextLength = Length;
04664         }
04665 
04666         <span class="comment">//</span>
04667         <span class="comment">//  Now calculate the tick that will signal the expiration of a</span>
04668         <span class="comment">//  lazy writer tick interval.</span>
04669         <span class="comment">//</span>
04670 
04671         <span class="keywordflow">if</span> (IsLazyWriter) {
04672 
04673             <a class="code" href="../../d7/d0/ke_2miscc_8c.html#a4">KeQueryTickCount</a>( &amp;EndTick );
04674             EndTick.QuadPart += <a class="code" href="../../d5/d2/cachedat_8c.html#a12">CcIdleDelayTick</a>;
04675         }
04676 
04677         <span class="comment">//</span>
04678         <span class="comment">//  Loop as long as we find buffers to flush for this</span>
04679         <span class="comment">//  SharedCacheMap, and we are not trying to delete the guy.</span>
04680         <span class="comment">//</span>
04681 
04682         <span class="keywordflow">while</span> (((SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o25">PagesToWrite</a> != 0) || !IsLazyWriter)
04683 
04684                     &amp;&amp;
04685                ((SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o3">FileSize</a>.QuadPart != 0) ||
04686                 <a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, PIN_ACCESS))
04687 
04688                     &amp;&amp;
04689 
04690                !VerifyRequired
04691 
04692                     &amp;&amp;
04693 
04694                <a class="code" href="../../d6/d2/cachesub_8c.html#a7">CcAcquireByteRangeForWrite</a> ( SharedCacheMap,
04695                                             IsLazyWriter ? NULL : (ARGUMENT_PRESENT(FileOffset) ?
04696                                                                     &amp;TargetOffset : NULL),
04697                                             IsLazyWriter ? 0: NextLength,
04698                                             &amp;NextFileOffset,
04699                                             &amp;NextLength,
04700                                             &amp;FirstBcb )) {
04701 
04702             <span class="comment">//</span>
04703             <span class="comment">//  Assume this range is not a hot spot.</span>
04704             <span class="comment">//</span>
04705 
04706             HotSpot = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04707 
04708             <span class="comment">//</span>
04709             <span class="comment">//  We defer calling Mm to set address range modified until here, to take</span>
04710             <span class="comment">//  overhead out of the main line path, and to reduce the number of TBIS</span>
04711             <span class="comment">//  on a multiprocessor.</span>
04712             <span class="comment">//</span>
04713 
04714             RemainingLength = NextLength;
04715 
04716             <span class="keywordflow">do</span> {
04717 
04718                 <span class="comment">//</span>
04719                 <span class="comment">//  See if the next file offset is mapped.  (If not, the dirty bit</span>
04720                 <span class="comment">//  was propagated on the unmap.)</span>
04721                 <span class="comment">//</span>
04722 
04723                 <span class="keywordflow">if</span> ((TempVa = <a class="code" href="../../d5/d3/vacbsup_8c.html#a14">CcGetVirtualAddressIfMapped</a>( SharedCacheMap,
04724                                                            NextFileOffset.QuadPart + NextLength - RemainingLength,
04725                                                            &amp;ActiveVacb,
04726                                                            &amp;TempLength)) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
04727 
04728                     <span class="comment">//</span>
04729                     <span class="comment">//  Reduce TempLength to RemainingLength if necessary, and</span>
04730                     <span class="comment">//  call MM.</span>
04731                     <span class="comment">//</span>
04732 
04733                     <span class="keywordflow">if</span> (TempLength &gt; RemainingLength) {
04734                         TempLength = RemainingLength;
04735                     }
04736 
04737                     <span class="comment">//</span>
04738                     <span class="comment">//  Clear the Dirty bit (if set) in the PTE and set the</span>
04739                     <span class="comment">//  Pfn modified.  Assume if the Pte was dirty, that this may</span>
04740                     <span class="comment">//  be a hot spot.  Do not do hot spots for metadata, and unless</span>
04741                     <span class="comment">//  they are within ValidDataLength as reported to the file system</span>
04742                     <span class="comment">//  via CcSetValidData.</span>
04743                     <span class="comment">//</span>
04744 
04745                     HotSpot = (BOOLEAN)((<a class="code" href="../../d5/d6/iosup_8c.html#a74">MmSetAddressRangeModified</a>(TempVa, TempLength) || HotSpot) &amp;&amp;
04746                                         ((NextFileOffset.QuadPart + NextLength) &lt;
04747                                          (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o6">ValidDataLength</a>.QuadPart)) &amp;&amp;
04748                                         ((SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o33">LazyWritePassCount</a> &amp; 0xF) != 0) &amp;&amp; IsLazyWriter) &amp;&amp;
04749                                         !<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, MODIFIED_WRITE_DISABLED);
04750 
04751                     <a class="code" href="../../d5/d3/vacbsup_8c.html#a16">CcFreeVirtualAddress</a>( ActiveVacb );
04752 
04753                 } <span class="keywordflow">else</span> {
04754 
04755                     <span class="comment">//</span>
04756                     <span class="comment">//  Reduce TempLength to RemainingLength if necessary.</span>
04757                     <span class="comment">//</span>
04758 
04759                     <span class="keywordflow">if</span> (TempLength &gt; RemainingLength) {
04760                         TempLength = RemainingLength;
04761                     }
04762                 }
04763 
04764                 <span class="comment">//</span>
04765                 <span class="comment">//  Reduce RemainingLength by what we processed.</span>
04766                 <span class="comment">//</span>
04767 
04768                 RemainingLength -= TempLength;
04769 
04770             <span class="comment">//</span>
04771             <span class="comment">//  Loop until done.</span>
04772             <span class="comment">//</span>
04773 
04774             } <span class="keywordflow">while</span> (RemainingLength != 0);
04775 
04776             <a class="code" href="../../d5/d2/cachedat_8c.html#a70">CcLazyWriteHotSpots</a> += HotSpot;
04777 
04778             <span class="comment">//</span>
04779             <span class="comment">//  Now flush, now flush if we do not think it is a hot spot.</span>
04780             <span class="comment">//</span>
04781 
04782             <span class="keywordflow">if</span> (!HotSpot) {
04783 
04784                 <a class="code" href="../../d6/d5/flushsec_8c.html#a8">MmFlushSection</a>( SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o10">FileObject</a>-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o6">SectionObjectPointer</a>,
04785                                 &amp;NextFileOffset,
04786                                 NextLength,
04787                                 IoStatus,
04788                                 !IsLazyWriter );
04789 
04790                 <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(IoStatus-&gt;Status)) {
04791 
04792                     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, LAZY_WRITE_OCCURRED)) {
04793 
04794                         <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
04795                         <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, LAZY_WRITE_OCCURRED);
04796                         <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
04797                     }
04798 
04799                     <span class="comment">//</span>
04800                     <span class="comment">//  Increment performance counters</span>
04801                     <span class="comment">//</span>
04802 
04803                     <span class="keywordflow">if</span> (IsLazyWriter) {
04804 
04805                         <a class="code" href="../../d5/d2/cachedat_8c.html#a71">CcLazyWriteIos</a> += 1;
04806                         <a class="code" href="../../d5/d2/cachedat_8c.html#a72">CcLazyWritePages</a> += (NextLength + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1) &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>;
04807                     }
04808 
04809                 } <span class="keywordflow">else</span> {
04810 
04811                     LARGE_INTEGER <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> = NextFileOffset;
04812                     ULONG RetryLength = NextLength;
04813 
04814                     <a class="code" href="../../d5/d5/cc_8h.html#a92">DebugTrace2</a>( 0, 0, <span class="stringliteral">"I/O Error on Cache Flush: %08lx, %08lx\n"</span>,
04815                                  IoStatus-&gt;Status, IoStatus-&gt;Information );
04816 
04817                     <span class="keywordflow">if</span> (<a class="code" href="../../d6/d2/cachesub_8c.html#a2">RetryError</a>(IoStatus-&gt;Status)) {
04818 
04819                         VerifyRequired = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04820 
04821                     <span class="comment">//</span>
04822                     <span class="comment">//  Loop to write each page individually, starting with one</span>
04823                     <span class="comment">//  more try on the page that got the error, in case that page</span>
04824                     <span class="comment">//  or any page beyond it can be successfully written</span>
04825                     <span class="comment">//  individually.  Note that Offset and RetryLength are</span>
04826                     <span class="comment">//  guaranteed to be in integral pages, but the Information</span>
04827                     <span class="comment">//  field from the failed request is not.</span>
04828                     <span class="comment">//</span>
04829                     <span class="comment">//  We ignore errors now, and give it one last shot, before</span>
04830                     <span class="comment">//  setting the pages clean (see below).</span>
04831                     <span class="comment">//</span>
04832 
04833                     } <span class="keywordflow">else</span> {
04834 
04835                         <span class="keywordflow">do</span> {
04836 
04837                             <a class="code" href="../../d5/d5/cc_8h.html#a92">DebugTrace2</a>( 0, 0, <span class="stringliteral">"Trying page at offset %08lx, %08lx\n"</span>,
04838                                          <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>.LowPart, <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>.HighPart );
04839 
04840                             <a class="code" href="../../d6/d5/flushsec_8c.html#a8">MmFlushSection</a> ( SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o10">FileObject</a>-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o6">SectionObjectPointer</a>,
04841                                              &amp;Offset,
04842                                              PAGE_SIZE,
04843                                              IoStatus,
04844                                              !IsLazyWriter );
04845 
04846                             <a class="code" href="../../d5/d5/cc_8h.html#a92">DebugTrace2</a>( 0, 0, <span class="stringliteral">"I/O status = %08lx, %08lx\n"</span>,
04847                                          IoStatus-&gt;Status, IoStatus-&gt;Information );
04848 
04849                             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(IoStatus-&gt;Status)) {
04850                                 <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
04851                                 <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, LAZY_WRITE_OCCURRED);
04852                                 <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
04853                             }
04854 
04855                             <span class="keywordflow">if</span> ((!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(IoStatus-&gt;Status)) &amp;&amp; !<a class="code" href="../../d6/d2/cachesub_8c.html#a2">RetryError</a>(IoStatus-&gt;Status)) {
04856 
04857                                 PopupRequired = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04858                                 PopupStatus = IoStatus-&gt;Status;
04859                             }
04860 
04861                             VerifyRequired = VerifyRequired || <a class="code" href="../../d6/d2/cachesub_8c.html#a2">RetryError</a>(IoStatus-&gt;Status);
04862 
04863                             <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>.QuadPart = <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>.QuadPart + (LONGLONG)<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
04864                             RetryLength -= <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
04865 
04866                         } <span class="keywordflow">while</span>(RetryLength &gt; 0);
04867                     }
04868                 }
04869             }
04870 
04871             <span class="comment">//</span>
04872             <span class="comment">//  Now release the Bcb resources and set them clean.  Note we do not check</span>
04873             <span class="comment">//  here for errors, and just returned in the I/O status.  Errors on writes</span>
04874             <span class="comment">//  are rare to begin with.  Nonetheless, our strategy is to rely on</span>
04875             <span class="comment">//  one or more of the following (depending on the file system) to prevent</span>
04876             <span class="comment">//  errors from getting to us.</span>
04877             <span class="comment">//</span>
04878             <span class="comment">//      - Retries and/or other forms of error recovery in the disk driver</span>
04879             <span class="comment">//      - Mirroring driver</span>
04880             <span class="comment">//      - Hot fixing in the noncached path of the file system</span>
04881             <span class="comment">//</span>
04882             <span class="comment">//  In the unexpected case that a write error does get through, we</span>
04883             <span class="comment">//  *currently* just set the Bcbs clean anyway, rather than let</span>
04884             <span class="comment">//  Bcbs and pages accumulate which cannot be written.  Note we did</span>
04885             <span class="comment">//  a popup above to at least notify the guy.</span>
04886             <span class="comment">//</span>
04887             <span class="comment">//  Set the pages dirty again if we either saw a HotSpot or got</span>
04888             <span class="comment">//  verify required.</span>
04889             <span class="comment">//</span>
04890 
04891             <a class="code" href="../../d6/d2/cachesub_8c.html#a8">CcReleaseByteRangeFromWrite</a> ( SharedCacheMap,
04892                                           &amp;NextFileOffset,
04893                                           NextLength,
04894                                           FirstBcb,
04895                                           (BOOLEAN)(HotSpot || VerifyRequired) );
04896 
04897             <span class="comment">//</span>
04898             <span class="comment">//  See if there is any deferred writes we should post.</span>
04899             <span class="comment">//</span>
04900 
04901             BytesWritten += NextLength;
04902             <span class="keywordflow">if</span> ((BytesWritten &gt;= 0x40000) &amp;&amp; !IsListEmpty(&amp;CcDeferredWrites)) {
04903                 <a class="code" href="../../d5/d5/cc_8h.html#a174">CcPostDeferredWrites</a>();
04904                 BytesWritten = 0;
04905             }
04906 
04907             <span class="comment">//</span>
04908             <span class="comment">//  If we're the lazy writer and have spent more than the active tick</span>
04909             <span class="comment">//  length in this loop, break out for a requeue so we share the</span>
04910             <span class="comment">//  file resources.</span>
04911             <span class="comment">//</span>
04912             
04913             <span class="keywordflow">if</span> (IsLazyWriter) {
04914 
04915                 <a class="code" href="../../d7/d0/ke_2miscc_8c.html#a4">KeQueryTickCount</a>( &amp;CurrentTick );
04916 
04917                 <span class="comment">//</span>
04918                 <span class="comment">//  Note that CcIdleDelay is a relative (negative) timestamp.</span>
04919                 <span class="comment">//</span>
04920 
04921                 <span class="keywordflow">if</span> (CurrentTick.QuadPart &gt; EndTick.QuadPart) {
04922 
04923                     IoStatus-&gt;Information = <a class="code" href="../../d5/d5/cc_8h.html#a56">CC_REQUEUE</a>;
04924                     <span class="keywordflow">break</span>;
04925                 }
04926             }
04927 
04928             <span class="comment">//</span>
04929             <span class="comment">//  Now for explicit flushes, we should advance our range.</span>
04930             <span class="comment">//</span>
04931 
04932             <span class="keywordflow">if</span> (ARGUMENT_PRESENT(FileOffset)) {
04933 
04934                 NextFileOffset.QuadPart += NextLength;
04935 
04936                 <span class="comment">//</span>
04937                 <span class="comment">//  Done yet?</span>
04938                 <span class="comment">//</span>
04939 
04940                 <span class="keywordflow">if</span> ((FileOffset-&gt;QuadPart + Length) &lt;= NextFileOffset.QuadPart) {
04941                     <span class="keywordflow">break</span>;
04942                 }
04943 
04944                 <span class="comment">//</span>
04945                 <span class="comment">//  Calculate new target range</span>
04946                 <span class="comment">//</span>
04947 
04948                 NextLength = (ULONG)((FileOffset-&gt;QuadPart + Length) - NextFileOffset.QuadPart);
04949                 TargetOffset = NextFileOffset;
04950             }
04951         }
04952     }
04953 
04954     <span class="comment">//</span>
04955     <span class="comment">//  See if there are any deferred writes we should post if</span>
04956     <span class="comment">//  we escaped the loop without checking after a series of</span>
04957     <span class="comment">//  flushes.</span>
04958     <span class="comment">//</span>
04959 
04960     <span class="keywordflow">if</span> (BytesWritten != 0 &amp;&amp; !IsListEmpty(&amp;CcDeferredWrites)) {
04961 
04962         <a class="code" href="../../d5/d5/cc_8h.html#a174">CcPostDeferredWrites</a>();
04963     }
04964 
04965     <span class="comment">//</span>
04966     <span class="comment">//  Now we can get rid of the open count, and clean up as required.</span>
04967     <span class="comment">//</span>
04968 
04969     <span class="keywordflow">if</span> (SharedCacheMap != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
04970 
04971         <span class="comment">//</span>
04972         <span class="comment">//  Serialize again to decrement the open count.</span>
04973         <span class="comment">//</span>
04974 
04975         <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
04976 
04977         <a class="code" href="../../d5/d5/cc_8h.html#a69">CcDecrementOpenCount</a>( SharedCacheMap, 'fcCF' );
04978 
04979         <span class="keywordflow">if</span> ((SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o2">OpenCount</a> == 0) &amp;&amp;
04980             !<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, WRITE_QUEUED) &amp;&amp;
04981             (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o20">DirtyPages</a> == 0)) {
04982 
04983             <span class="comment">//</span>
04984             <span class="comment">//  Move to the dirty list.</span>
04985             <span class="comment">//</span>
04986 
04987             RemoveEntryList( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a> );
04988             InsertTailList( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a2">CcDirtySharedCacheMapList</a>.<a class="code" href="../../d1/d3/struct__SHARED__CACHE__MAP__LIST__CURSOR.html#o0">SharedCacheMapLinks</a>,
04989                             &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a> );
04990 
04991             <span class="comment">//</span>
04992             <span class="comment">//  Make sure the Lazy Writer will wake up, because we</span>
04993             <span class="comment">//  want him to delete this SharedCacheMap.</span>
04994             <span class="comment">//</span>
04995 
04996             <a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o6">OtherWork</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04997             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o5">ScanActive</a>) {
04998                 <a class="code" href="../../d5/d5/cc_8h.html#a185">CcScheduleLazyWriteScan</a>();
04999             }
05000         }
05001 
05002         <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
05003     }
05004 
05005     <span class="comment">//</span>
05006     <span class="comment">//  Make sure and return the first error to our caller.  In the</span>
05007     <span class="comment">//  case of the Lazy Writer, a popup will be issued.</span>
05008     <span class="comment">//</span>
05009 
05010     <span class="keywordflow">if</span> (PopupRequired) {
05011         IoStatus-&gt;Status = PopupStatus;
05012     }
05013 
05014     <span class="comment">//</span>
05015     <span class="comment">//  Let the Lazy writer know if we did anything, so he can</span>
05016 
05017     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, me, <span class="stringliteral">"CcFlushCache -&gt; VOID\n"</span>, 0 );
05018 
05019     <span class="keywordflow">return</span>;
05020 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a97" doxytag="cache.h::CcGetDirtyPages" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTKERNELAPI LARGE_INTEGER CcGetDirtyPages           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>LogHandle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d4/d2/cache_8h.html#a22">PDIRTY_PAGE_ROUTINE</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>DirtyPageRoutine</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>Context1</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>Context2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d9/d4/logsup_8c-source.html#l00142">142</a> of file <a class="el" href="../../d9/d4/logsup_8c-source.html">logsup.c</a>.
<p>
References <a class="el" href="../../d6/d4/cc_8h-source.html#l01261">_BCB::BcbLinks</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00760">_SHARED_CACHE_MAP::BcbList</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00965">_SHARED_CACHE_MAP::BcbSpinLock</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01254">_BCB::ByteLength</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00155">CACHE_NTC_BCB</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00064">CcAcquireMasterLock</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01010">CcDecrementOpenCount</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00031">CcDirtySharedCacheMapList</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01003">CcIncrementOpenCount</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00067">CcReleaseMasterLock</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l00974">CcUnpinFileData()</a>, <a class="el" href="../../d4/d0/threads_8h-source.html#l00266">Context1</a>, <a class="el" href="../../d4/d0/threads_8h-source.html#l00266">Context2</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01335">_BCB::Dirty</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00846">_SHARED_CACHE_MAP::DirtyPages</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00796">_SHARED_CACHE_MAP::FileObject</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01255">_BCB::FileOffset</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00497">FlagOn</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00832">_SHARED_CACHE_MAP::Flags</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01090">IS_CURSOR</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00918">_SHARED_CACHE_MAP::LogHandle</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01280">_BCB::NewestLsn</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01247">_BCB::NodeTypeCode</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01273">_BCB::OldestLsn</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01304">_BCB::PinCount</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00826">_SHARED_CACHE_MAP::SharedCacheMapLinks</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01113">_SHARED_CACHE_MAP_LIST_CURSOR::SharedCacheMapLinks</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, <a class="el" href="../../d5/d5/cc_8h.html#a211a171">UNPIN</a>, and <a class="el" href="../../d5/d5/cc_8h.html#a211a172">UNREF</a>.
<p>
<pre class="fragment"><div>00151                    :
00152 
00153     This routine may be called to <span class="keywordflow">return</span> all of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> dirty pages in all files
00154     <span class="keywordflow">for</span> a given log handle.  Each page <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> returned by an individual call to
00155     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Dirty Page Routine.  The Dirty Page Routine <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> defined by a prototype
00156     in ntos\inc\cache.h.
00157 
00158 Arguments:
00159 
00160     LogHandle - Log <a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a> which must match <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> log handle previously stored
00161                 <span class="keywordflow">for</span> all files which are to be returned.
00162 
00163     DirtyPageRoutine -- The routine to call as each dirty page <span class="keywordflow">for</span> <span class="keyword">this</span> log
00164                         handle <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> found.
00165 
00166     <a class="code" href="../../d3/d1/threads_8h.html#a107">Context1</a> - First context parameter to be passed to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Dirty Page Routine.
00167 
00168     <a class="code" href="../../d3/d1/threads_8h.html#a108">Context2</a> - First context parameter to be passed to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Dirty Page Routine.
00169 
00170 Return Value:
00171 
00172     LARGE_INTEGER - Oldest Lsn found of all <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> dirty pages, or 0 <span class="keywordflow">if</span> no dirty pages
00173 
00174 --*/
00175 
00176 {
00177     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap;
00178     <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> Bcb, BcbToUnpin = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00179     KIRQL OldIrql;
00180     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> ExceptionStatus;
00181     LARGE_INTEGER SavedFileOffset, SavedOldestLsn, SavedNewestLsn;
00182     ULONG SavedByteLength;
00183     LARGE_INTEGER OldestLsn = {0,0};
00184 
00185     <span class="comment">//</span>
00186     <span class="comment">//  Synchronize with changes to the SharedCacheMap list.</span>
00187     <span class="comment">//</span>
00188 
00189     <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
00190 
00191     SharedCacheMap = CONTAINING_RECORD( <a class="code" href="../../d5/d2/cachedat_8c.html#a2">CcDirtySharedCacheMapList</a>.<a class="code" href="../../d1/d3/struct__SHARED__CACHE__MAP__LIST__CURSOR.html#o0">SharedCacheMapLinks</a>.Flink,
00192                                         <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">SHARED_CACHE_MAP</a>,
00193                                         SharedCacheMapLinks );
00194 
00195     <span class="comment">//</span>
00196     <span class="comment">//  Use try/finally for cleanup.  The only spot where we can raise is out of the</span>
00197     <span class="comment">//  filesystem callback, but we have the exception handler out here so we aren't</span>
00198     <span class="comment">//  constantly setting/unsetting it.</span>
00199     <span class="comment">//</span>
00200 
00201     <span class="keywordflow">try</span> {
00202 
00203         <span class="keywordflow">while</span> (&amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a> != &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a2">CcDirtySharedCacheMapList</a>.<a class="code" href="../../d1/d3/struct__SHARED__CACHE__MAP__LIST__CURSOR.html#o0">SharedCacheMapLinks</a>) {
00204 
00205             <span class="comment">//</span>
00206             <span class="comment">//  Skip over cursors, SharedCacheMaps for other LogHandles, and ones with</span>
00207             <span class="comment">//  no dirty pages</span>
00208             <span class="comment">//</span>
00209 
00210             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, IS_CURSOR) &amp;&amp; (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o30">LogHandle</a> == LogHandle) &amp;&amp;
00211                 (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o20">DirtyPages</a> != 0)) {
00212 
00213                 <span class="comment">//</span>
00214                 <span class="comment">//  This SharedCacheMap should stick around for a while in the dirty list.</span>
00215                 <span class="comment">//</span>
00216 
00217                 <a class="code" href="../../d5/d5/cc_8h.html#a68">CcIncrementOpenCount</a>( SharedCacheMap, 'pdGS' );
00218                 SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o20">DirtyPages</a> += 1;
00219                 <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
00220 
00221                 <span class="comment">//</span>
00222                 <span class="comment">//  Set our initial resume point and point to first Bcb in List.</span>
00223                 <span class="comment">//</span>
00224 
00225                 ExAcquireFastLock( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o36">BcbSpinLock</a>, &amp;OldIrql );
00226                 Bcb = CONTAINING_RECORD( SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o4">BcbList</a>.Flink, <a class="code" href="../../d4/d3/struct__BCB.html">BCB</a>, BcbLinks );
00227 
00228                 <span class="comment">//</span>
00229                 <span class="comment">//  Scan to the end of the Bcb list.</span>
00230                 <span class="comment">//</span>
00231 
00232                 <span class="keywordflow">while</span> (&amp;Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o4">BcbLinks</a> != &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o4">BcbList</a>) {
00233 
00234                     <span class="comment">//</span>
00235                     <span class="comment">//  If the Bcb is dirty, then capture the inputs for the</span>
00236                     <span class="comment">//  callback routine so we can call without holding a spinlock.</span>
00237                     <span class="comment">//</span>
00238 
00239                     <span class="keywordflow">if</span> ((Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o0">NodeTypeCode</a> == <a class="code" href="../../d5/d5/cc_8h.html#a14">CACHE_NTC_BCB</a>) &amp;&amp; Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o13">Dirty</a>) {
00240 
00241                         SavedFileOffset = Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o3">FileOffset</a>;
00242                         SavedByteLength = Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o2">ByteLength</a>;
00243                         SavedOldestLsn = Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o6">OldestLsn</a>;
00244                         SavedNewestLsn = Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o7">NewestLsn</a>;
00245 
00246                         <span class="comment">//</span>
00247                         <span class="comment">//  Increment PinCount so the Bcb sticks around</span>
00248                         <span class="comment">//</span>
00249 
00250                         Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o9">PinCount</a> += 1;
00251 
00252                         ExReleaseFastLock( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o36">BcbSpinLock</a>, OldIrql );
00253 
00254                         <span class="comment">//</span>
00255                         <span class="comment">//  Any Bcb to unpin from a previous loop?</span>
00256                         <span class="comment">//</span>
00257 
00258                         <span class="keywordflow">if</span> (BcbToUnpin != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00259                             <a class="code" href="../../d5/d5/cc_8h.html#a176">CcUnpinFileData</a>( BcbToUnpin, TRUE, UNREF );
00260                             BcbToUnpin = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00261                         }
00262 
00263                         <span class="comment">//</span>
00264                         <span class="comment">//  Call the file system.  This callback may raise status.</span>
00265                         <span class="comment">//</span>
00266 
00267                         (*DirtyPageRoutine)( SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o10">FileObject</a>,
00268                                              &amp;SavedFileOffset,
00269                                              SavedByteLength,
00270                                              &amp;SavedOldestLsn,
00271                                              &amp;SavedNewestLsn,
00272                                              <a class="code" href="../../d3/d1/threads_8h.html#a107">Context1</a>,
00273                                              <a class="code" href="../../d3/d1/threads_8h.html#a108">Context2</a> );
00274 
00275                         <span class="comment">//</span>
00276                         <span class="comment">//  Possibly update OldestLsn</span>
00277                         <span class="comment">//</span>
00278 
00279                         <span class="keywordflow">if</span> ((SavedOldestLsn.QuadPart != 0) &amp;&amp;
00280                             ((OldestLsn.QuadPart == 0) || (SavedOldestLsn.QuadPart &lt; OldestLsn.QuadPart ))) {
00281                             OldestLsn = SavedOldestLsn;
00282                         }
00283 
00284                         <span class="comment">//</span>
00285                         <span class="comment">//  Now reacquire the spinlock and scan from the resume point</span>
00286                         <span class="comment">//  point to the next Bcb to return in the descending list.</span>
00287                         <span class="comment">//</span>
00288 
00289                         ExAcquireFastLock( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o36">BcbSpinLock</a>, &amp;OldIrql );
00290 
00291                         <span class="comment">//</span>
00292                         <span class="comment">//  Normally the Bcb can stay around a while, but if not,</span>
00293                         <span class="comment">//  we will just remember it for the next time we do not</span>
00294                         <span class="comment">//  have the spin lock.  We cannot unpin it now, because</span>
00295                         <span class="comment">//  we would lose our place in the list.</span>
00296                         <span class="comment">//</span>
00297 
00298                         <span class="keywordflow">if</span> (Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o9">PinCount</a> &gt; 1) {
00299                             Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o9">PinCount</a> -= 1;
00300                         } <span class="keywordflow">else</span> {
00301                             BcbToUnpin = Bcb;
00302                         }
00303                     }
00304 
00305                     Bcb = CONTAINING_RECORD( Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o4">BcbLinks</a>.Flink, <a class="code" href="../../d4/d3/struct__BCB.html">BCB</a>, BcbLinks );
00306                 }
00307                 ExReleaseFastLock( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o36">BcbSpinLock</a>, OldIrql );
00308 
00309                 <span class="comment">//</span>
00310                 <span class="comment">//  We need to unpin any Bcb we are holding before moving on to</span>
00311                 <span class="comment">//  the next SharedCacheMap, or else CcDeleteSharedCacheMap will</span>
00312                 <span class="comment">//  also delete this Bcb.</span>
00313                 <span class="comment">//</span>
00314 
00315                 <span class="keywordflow">if</span> (BcbToUnpin != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00316 
00317                     <a class="code" href="../../d5/d5/cc_8h.html#a176">CcUnpinFileData</a>( BcbToUnpin, TRUE, UNREF );
00318                     BcbToUnpin = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00319                 }
00320 
00321                 <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
00322 
00323                 <span class="comment">//</span>
00324                 <span class="comment">//  Now release the SharedCacheMap, leaving it in the dirty list.</span>
00325                 <span class="comment">//</span>
00326 
00327                 <a class="code" href="../../d5/d5/cc_8h.html#a69">CcDecrementOpenCount</a>( SharedCacheMap, 'pdGF' );
00328                 SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o20">DirtyPages</a> -= 1;
00329             }
00330 
00331             <span class="comment">//</span>
00332             <span class="comment">//  Now loop back for the next cache map.</span>
00333             <span class="comment">//</span>
00334 
00335             SharedCacheMap =
00336                 CONTAINING_RECORD( SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a>.Flink,
00337                                    <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">SHARED_CACHE_MAP</a>,
00338                                    SharedCacheMapLinks );
00339         }
00340 
00341         <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
00342 
00343     } finally {
00344 
00345         <span class="comment">//</span>
00346         <span class="comment">//  Drop the Bcb if we are being ejected.  We are guaranteed that the</span>
00347         <span class="comment">//  only raise is from the callback, at which point we have an incremented</span>
00348         <span class="comment">//  pincount.</span>
00349         <span class="comment">//</span>
00350 
00351         <span class="keywordflow">if</span> (AbnormalTermination()) {
00352 
00353             <a class="code" href="../../d5/d5/cc_8h.html#a176">CcUnpinFileData</a>( Bcb, TRUE, UNPIN );
00354         }
00355     }
00356 
00357     <span class="keywordflow">return</span> OldestLsn;
00358 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a71" doxytag="cache.h::CcGetFileObjectFromBcb" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTKERNELAPI <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> CcGetFileObjectFromBcb           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>Bcb</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d7/fssup_8c-source.html#l03709">3709</a> of file <a class="el" href="../../d6/d7/fssup_8c-source.html">fssup.c</a>.
<p>
<pre class="fragment"><div>03722          :
03723 
03724     Bcb - <a class="code" href="../../d2/d1/bench_8h.html#a5">A</a> pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> pinned Bcb.
03725 
03726 Return Value:
03727 
03728     Pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d1/d9/icmui_8def.html#a0">File</a> Object, or <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> not cached or no
03729     longer cached
03730 
03731 --*/
03732 
03733 {
03734     <span class="keywordflow">return</span> ((<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)Bcb)-&gt;SharedCacheMap-&gt;FileObject;
03735 }
}
</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a70" doxytag="cache.h::CcGetFileObjectFromSectionPtrs" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTKERNELAPI <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> CcGetFileObjectFromSectionPtrs           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d7/d0/struct__SECTION__OBJECT__POINTERS.html">PSECTION_OBJECT_POINTERS</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>SectionObjectPointer</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d7/fssup_8c-source.html#l03658">3658</a> of file <a class="el" href="../../d6/d7/fssup_8c-source.html">fssup.c</a>.
<p>
References <a class="el" href="../../d6/d4/cc_8h-source.html#l00064">CcAcquireMasterLock</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00067">CcReleaseMasterLock</a>, and <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>.
<p>
<pre class="fragment"><div>03675          :
03676 
03677     SectionObjectPointer - <a class="code" href="../../d2/d1/bench_8h.html#a5">A</a> pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Section Object Pointers
03678                            structure in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> nonpaged Fcb.
03679 
03680 Return Value:
03681 
03682     Pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d1/d9/icmui_8def.html#a0">File</a> Object, or <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> not cached or no
03683     longer cached
03684 
03685 --*/
03686 
03687 {
03688     KIRQL OldIrql;
03689     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03690 
03691     <span class="comment">//</span>
03692     <span class="comment">//  Serialize with Creation/Deletion of all Shared CacheMaps</span>
03693     <span class="comment">//</span>
03694 
03695     <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
03696 
03697     <span class="keywordflow">if</span> (SectionObjectPointer-&gt;SharedCacheMap != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03698 
03699         FileObject = ((<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a>)SectionObjectPointer-&gt;SharedCacheMap)-&gt;FileObject;
03700     }
03701 
03702     <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
03703 
03704     <span class="keywordflow">return</span> FileObject;
03705 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a64" doxytag="cache.h::CcGetFlushedValidData" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTKERNELAPI LARGE_INTEGER CcGetFlushedValidData           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d7/d0/struct__SECTION__OBJECT__POINTERS.html">PSECTION_OBJECT_POINTERS</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>SectionObjectPointer</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN BOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>BcbListHeld</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d7/d1/cachesub_8c-source.html#l04232">4232</a> of file <a class="el" href="../../d7/d1/cachesub_8c-source.html">cachesub.c</a>.
<p>
References <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01144">_BITMAP_RANGE::BasePage</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01261">_BCB::BcbLinks</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00760">_SHARED_CACHE_MAP::BcbList</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00965">_SHARED_CACHE_MAP::BcbSpinLock</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00155">CACHE_NTC_BCB</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00064">CcAcquireMasterLock</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00070">CcAcquireMasterLockAtDpcLevel</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01010">CcDecrementOpenCount</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00031">CcDirtySharedCacheMapList</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l02157">CcFindBitmapRangeToClean()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01003">CcIncrementOpenCount</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00067">CcReleaseMasterLock</a>, <a class="el" href="../../d6/d0/lazyrite_8c-source.html#l00049">CcScheduleLazyWriteScan()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01335">_BCB::Dirty</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01194">_MBCB::DirtyPages</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00846">_SHARED_CACHE_MAP::DirtyPages</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01255">_BCB::FileOffset</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01150">_BITMAP_RANGE::FirstDirtyPage</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00497">FlagOn</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00832">_SHARED_CACHE_MAP::Flags</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00129">LazyWriter</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00839">_SHARED_CACHE_MAP::Mbcb</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01247">_BCB::NodeTypeCode</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00740">_SHARED_CACHE_MAP::OpenCount</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01471">_LAZY_WRITER::OtherWork</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00600">PAGE_SHIFT</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01464">_LAZY_WRITER::ScanActive</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01113">_SHARED_CACHE_MAP_LIST_CURSOR::SharedCacheMapLinks</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00826">_SHARED_CACHE_MAP::SharedCacheMapLinks</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00780">_SHARED_CACHE_MAP::ValidDataGoal</a>, and <a class="el" href="../../d6/d4/cc_8h-source.html#l01051">WRITE_QUEUED</a>.
<p>
Referenced by <a class="el" href="../../d7/d1/cachesub_8c-source.html#l03880">CcWriteBehind()</a>.
<p>
<pre class="fragment"><div>04239                    :
04240 
04241     This routine may be called by a <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> system to find <a class="code" href="../../d6/d0/wsprintf_8c.html#a0">out</a> how far <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Cache <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a79">Manager</a>
04242     has flushed in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> stream.  More accurately, <span class="keyword">this</span> routine returns either <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> FileOffset
04243     of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> lowest dirty page currently in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a>.
04244 
04245     NOTE that even though <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> routine takes SectionObjectPointer, <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller must insure
04246     that <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> stream <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> cached and stays cached <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> duration of <span class="keyword">this</span> routine, much like
04247     <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> copy <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a24">routines</a>, etc.
04248 
04249 Arguments:
04250 
04251     SectionObjectPointer - <a class="code" href="../../d2/d1/bench_8h.html#a5">A</a> pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Section Object Pointers
04252                            structure in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> nonpaged Fcb.
04253 
04254     CcInternalCaller - must be <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> coming from Cc, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> otherwise.
04255         <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> imples <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> need <span class="keywordflow">for</span> <span class="keyword">self</span>-synchronization.
04256 
04257 Return Value:
04258 
04259     The derived number <span class="keywordflow">for</span> flushed ValidData, or MAXLONGLONG in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> quad part <span class="keywordflow">if</span>
04260     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Section <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> not cached.  (Naturally <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller can guarantee that <span class="keyword">this</span> <span class="keywordflow">case</span>
04261     does not occur, and internal callers <span class="keywordflow">do</span>.)
04262 
04263 --*/
04264 
04265 {
04266     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap;
04267     KIRQL OldIrql;
04268     LARGE_INTEGER NewValidDataLength;
04269 
04270     <span class="comment">//</span>
04271     <span class="comment">//  External callers may be unsynchronized with this shared cache map</span>
04272     <span class="comment">//  perhaps going away underneath this call.  NTFS and his</span>
04273     <span class="comment">//  pair of streams for compression-on-the-wire is a good example of</span>
04274     <span class="comment">//  someone who may be synchronized in one stream but needs to peek at</span>
04275     <span class="comment">//  the other.</span>
04276     <span class="comment">//</span>
04277 
04278     <span class="keywordflow">if</span> (!CcInternalCaller) {
04279 
04280         <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
04281 
04282         SharedCacheMap = SectionObjectPointer-&gt;SharedCacheMap;
04283 
04284         <span class="keywordflow">if</span> (SharedCacheMap == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
04285             <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
04286             NewValidDataLength.QuadPart = MAXLONGLONG;
04287             <span class="keywordflow">return</span> NewValidDataLength;
04288         }
04289 
04290         <a class="code" href="../../d5/d5/cc_8h.html#a68">CcIncrementOpenCount</a>( SharedCacheMap, 'dfGS' );
04291         <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
04292         ExAcquireSpinLock( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o36">BcbSpinLock</a>, &amp;OldIrql );
04293 
04294     } <span class="keywordflow">else</span> {
04295 
04296         SharedCacheMap = SectionObjectPointer-&gt;SharedCacheMap;
04297     }
04298 
04299     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( SharedCacheMap != NULL );
04300 
04301     <span class="comment">//</span>
04302     <span class="comment">//  If the file is entirely clean, then we wish to return</span>
04303     <span class="comment">//  the new ValidDataLength as equal to ValidDataGoal.</span>
04304     <span class="comment">//</span>
04305 
04306     NewValidDataLength = SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o7">ValidDataGoal</a>;
04307 
04308     <span class="comment">//</span>
04309     <span class="comment">//  If there may be dirty pages we will look at the last Bcb in the</span>
04310     <span class="comment">//  descending-order Bcb list, and see if it describes data beyond</span>
04311     <span class="comment">//  ValidDataGoal.</span>
04312     <span class="comment">//</span>
04313     <span class="comment">//  It is important to note that since we use DirtyPages as a faux</span>
04314     <span class="comment">//  reference count over some short windows (+1, -1) the simple</span>
04315     <span class="comment">//  fact it is nonzero does *not* mean the file is dirty.</span>
04316     <span class="comment">//</span>
04317     <span class="comment">//  (This test is logically too conservative.  For example, the last Bcb</span>
04318     <span class="comment">//  may not even be dirty (in which case we should look at its</span>
04319     <span class="comment">//  predecessor), or we may have earlier written valid data to this</span>
04320     <span class="comment">//  byte range (which also means if we knew this we could look at</span>
04321     <span class="comment">//  the predessor).  This simply means that the Lazy Writer may not</span>
04322     <span class="comment">//  successfully get ValidDataLength updated in a file being randomly</span>
04323     <span class="comment">//  accessed until the level of file access dies down, or at the latest</span>
04324     <span class="comment">//  until the file is closed.  However, security will never be</span>
04325     <span class="comment">//  compromised.)</span>
04326     <span class="comment">//</span>
04327 
04328     <span class="keywordflow">if</span> (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o20">DirtyPages</a>) {
04329 
04330         <a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html">PBITMAP_RANGE</a> BitmapRange;
04331         <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> LastBcb;
04332         <a class="code" href="../../d9/d6/struct__MBCB.html">PMBCB</a> Mbcb = SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o19">Mbcb</a>;
04333 
04334         <span class="keywordflow">if</span> ((Mbcb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp; (Mbcb-&gt;<a class="code" href="../../d9/d6/struct__MBCB.html#o3">DirtyPages</a> != 0)) {
04335 
04336             BitmapRange = <a class="code" href="../../d6/d2/cachesub_8c.html#a10">CcFindBitmapRangeToClean</a>( Mbcb, 0 );
04337 
04338             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o2">FirstDirtyPage</a> != MAXULONG);
04339 
04340             NewValidDataLength.QuadPart = (BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o1">BasePage</a> + BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o2">FirstDirtyPage</a>)
04341                                             &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>;
04342         }
04343 
04344         LastBcb = CONTAINING_RECORD( SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o4">BcbList</a>.Flink,
04345                                      <a class="code" href="../../d4/d3/struct__BCB.html">BCB</a>,
04346                                      BcbLinks );
04347 
04348         <span class="keywordflow">while</span> (&amp;LastBcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o4">BcbLinks</a> != &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o4">BcbList</a>) {
04349 
04350             <span class="keywordflow">if</span> ((LastBcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o0">NodeTypeCode</a> == <a class="code" href="../../d5/d5/cc_8h.html#a14">CACHE_NTC_BCB</a>) &amp;&amp; LastBcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o13">Dirty</a>) {
04351                 <span class="keywordflow">break</span>;
04352             }
04353 
04354             LastBcb = CONTAINING_RECORD( LastBcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o4">BcbLinks</a>.Flink,
04355                                          <a class="code" href="../../d4/d3/struct__BCB.html">BCB</a>,
04356                                          BcbLinks );
04357         }
04358 
04359         <span class="comment">//</span>
04360         <span class="comment">//  Check the Base of the last entry.</span>
04361         <span class="comment">//</span>
04362 
04363         <span class="keywordflow">if</span> ((&amp;LastBcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o4">BcbLinks</a> != &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o4">BcbList</a>) &amp;&amp;
04364             (LastBcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o3">FileOffset</a>.QuadPart &lt; NewValidDataLength.QuadPart )) {
04365 
04366             NewValidDataLength = LastBcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o3">FileOffset</a>;
04367         }
04368     }
04369 
04370     <span class="keywordflow">if</span> (!CcInternalCaller) {
04371 
04372         <span class="comment">//</span>
04373         <span class="comment">//  Remove our reference.</span>
04374         <span class="comment">//</span>
04375 
04376         <a class="code" href="../../d5/d5/cc_8h.html#a2">CcAcquireMasterLockAtDpcLevel</a>();
04377         <a class="code" href="../../d5/d5/cc_8h.html#a69">CcDecrementOpenCount</a>( SharedCacheMap, 'dfGF' );
04378 
04379         <span class="keywordflow">if</span> ((SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o2">OpenCount</a> == 0) &amp;&amp;
04380             !<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, WRITE_QUEUED) &amp;&amp;
04381             (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o20">DirtyPages</a> == 0)) {
04382 
04383             <span class="comment">//</span>
04384             <span class="comment">//  Move to the dirty list.</span>
04385             <span class="comment">//</span>
04386 
04387             RemoveEntryList( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a> );
04388             InsertTailList( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a2">CcDirtySharedCacheMapList</a>.<a class="code" href="../../d1/d3/struct__SHARED__CACHE__MAP__LIST__CURSOR.html#o0">SharedCacheMapLinks</a>,
04389                         &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a> );
04390 
04391             <span class="comment">//</span>
04392             <span class="comment">//  Make sure the Lazy Writer will wake up, because we</span>
04393             <span class="comment">//  want him to delete this SharedCacheMap.</span>
04394             <span class="comment">//</span>
04395 
04396             <a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o6">OtherWork</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04397             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o5">ScanActive</a>) {
04398                 <a class="code" href="../../d5/d5/cc_8h.html#a185">CcScheduleLazyWriteScan</a>();
04399             }
04400         }
04401 
04402         ExReleaseSpinLockFromDpcLevel( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o36">BcbSpinLock</a> );
04403         <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
04404     }
04405 
04406     <span class="keywordflow">return</span> NewValidDataLength;
04407 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a99" doxytag="cache.h::CcGetLsnForFileObject" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTKERNELAPI LARGE_INTEGER CcGetLsnForFileObject           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>FileObject</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PLARGE_INTEGER OldestLsn&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d9/d4/logsup_8c-source.html#l00450">450</a> of file <a class="el" href="../../d9/d4/logsup_8c-source.html">logsup.c</a>.
<p>
References <a class="el" href="../../d6/d4/cc_8h-source.html#l01261">_BCB::BcbLinks</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00760">_SHARED_CACHE_MAP::BcbList</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00965">_SHARED_CACHE_MAP::BcbSpinLock</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00155">CACHE_NTC_BCB</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01335">_BCB::Dirty</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01280">_BCB::NewestLsn</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01247">_BCB::NodeTypeCode</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, and <a class="el" href="../../d6/d4/cc_8h-source.html#l01273">_BCB::OldestLsn</a>.
<p>
<pre class="fragment"><div>00457                    :
00458 
00459     This routine returns <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>  oldest and newest LSNs <span class="keywordflow">for</span> a <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> object.
00460 
00461 Arguments:
00462 
00463     FileObject - <a class="code" href="../../d1/d9/icmui_8def.html#a0">File</a> <span class="keywordflow">for</span> which <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> log handle should be stored.
00464 
00465     OldestLsn - pointer to location to store oldest <a class="code" href="../../d6/d3/lfs_8h.html#a10">LSN</a> <span class="keywordflow">for</span> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> object.
00466 
00467 Return Value:
00468 
00469     The newest <a class="code" href="../../d6/d3/lfs_8h.html#a10">LSN</a> <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> object.
00470 
00471 --*/
00472 
00473 {
00474     <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> Bcb;
00475     KIRQL OldIrql;
00476     LARGE_INTEGER Oldest, Newest;
00477     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap = FileObject-&gt;SectionObjectPointer-&gt;SharedCacheMap;
00478 
00479     <span class="comment">//</span>
00480     <span class="comment">// initialize lsn variables</span>
00481     <span class="comment">//</span>
00482 
00483     Oldest.LowPart = 0;
00484     Oldest.HighPart = 0;
00485     Newest.LowPart = 0;
00486     Newest.HighPart = 0;
00487 
00488     <span class="keywordflow">if</span>(SharedCacheMap == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00489         <span class="keywordflow">return</span> Oldest;
00490     }
00491 
00492     ExAcquireFastLock(&amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o36">BcbSpinLock</a>, &amp;OldIrql);
00493 
00494     <span class="comment">//</span>
00495     <span class="comment">//  Now point to first Bcb in List, and loop through it.</span>
00496     <span class="comment">//</span>
00497 
00498     Bcb = CONTAINING_RECORD( SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o4">BcbList</a>.Flink, <a class="code" href="../../d4/d3/struct__BCB.html">BCB</a>, BcbLinks );
00499 
00500     <span class="keywordflow">while</span> (&amp;Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o4">BcbLinks</a> != &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o4">BcbList</a>) {
00501 
00502         <span class="comment">//</span>
00503         <span class="comment">//  If the Bcb is dirty then capture the oldest and newest lsn</span>
00504         <span class="comment">//</span>
00505 
00506 
00507         <span class="keywordflow">if</span> ((Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o0">NodeTypeCode</a> == <a class="code" href="../../d5/d5/cc_8h.html#a14">CACHE_NTC_BCB</a>) &amp;&amp; Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o13">Dirty</a>) {
00508 
00509             LARGE_INTEGER BcbLsn, BcbNewest;
00510 
00511             BcbLsn = Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o6">OldestLsn</a>;
00512             BcbNewest = Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o7">NewestLsn</a>;
00513 
00514             <span class="keywordflow">if</span> ((BcbLsn.QuadPart != 0) &amp;&amp;
00515                 ((Oldest.QuadPart == 0) ||
00516                  (BcbLsn.QuadPart &lt; Oldest.QuadPart))) {
00517 
00518                  Oldest = BcbLsn;
00519             }
00520 
00521             <span class="keywordflow">if</span> ((BcbLsn.QuadPart != 0) &amp;&amp; (BcbNewest.QuadPart &gt; Newest.QuadPart)) {
00522 
00523                 Newest = BcbNewest;
00524             }
00525         }
00526 
00527 
00528         Bcb = CONTAINING_RECORD( Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o4">BcbLinks</a>.Flink, <a class="code" href="../../d4/d3/struct__BCB.html">BCB</a>, BcbLinks );
00529     }
00530 
00531     <span class="comment">//</span>
00532     <span class="comment">//  Now release the spin lock for this Bcb list and generate a callback</span>
00533     <span class="comment">//  if we got something.</span>
00534     <span class="comment">//</span>
00535 
00536     ExReleaseFastLock( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o36">BcbSpinLock</a>, OldIrql );
00537 
00538     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(OldestLsn)) {
00539 
00540         *OldestLsn = Oldest;
00541     }
00542 
00543     <span class="keywordflow">return</span> Newest;
00544 }
}
</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a57" doxytag="cache.h::CcInitializeCacheManager" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTKERNELAPI BOOLEAN CcInitializeCacheManager           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d7/fssup_8c-source.html#l00069">69</a> of file <a class="el" href="../../d6/d7/fssup_8c-source.html">fssup.c</a>.
<p>
References <a class="el" href="../../d6/d4/cc_8h-source.html#l01451">_LAZY_WRITER::BcbZone</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00116">CcAggressiveZeroCount</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00117">CcAggressiveZeroThreshold</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01998">CcBcbSpinLock</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00185">CcBugCheck</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00109">CcCapturedSystemSize</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00030">CcCleanSharedCacheMapList</a>, <a class="el" href="../../d5/d3/alpha_2splocks_8c-source.html#l00034">CcDebugTraceLock</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00096">CcDeferredWrites</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00095">CcDeferredWriteSpinLock</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00098">CcDirtyPageTarget</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00097">CcDirtyPageThreshold</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00031">CcDirtySharedCacheMapList</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00052">CcExpressWorkQueue</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00063">CcIdleDelayTick</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00051">CcIdleWorkerThreadList</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00188">CcInitializeVacbs()</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00032">CcLazyWriterCursor</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00029">CcMasterSpinLock</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00049">CcNumberWorkerThreads</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00054">CcPostTickWorkQueue</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00053">CcRegularWorkQueue</a>, <a class="el" href="../../d6/d0/lazyrite_8c-source.html#l00099">CcScanDpc()</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00131">CcTwilightLookasideList</a>, <a class="el" href="../../d6/d0/lazyrite_8c-source.html#l00738">CcWorkerThread()</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00048">CcWorkQueueSpinlock</a>, <a class="el" href="../../d6/d7/ex_8h-source.html#l00253">ExAllocatePoolWithTag</a>, <a class="el" href="../../d2/d8/worker_8c-source.html#l00095">ExCriticalWorkerThreads</a>, <a class="el" href="../../d0/d5/ex_2lookasid_8c-source.html#l00408">ExInitializeNPagedLookasideList()</a>, <a class="el" href="../../d6/d7/ex_8h-source.html#l01961">ExInitializeWorkItem</a>, <a class="el" href="../../d9/d0/zone_8c-source.html#l00048">ExInitializeZone()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01119">_SHARED_CACHE_MAP_LIST_CURSOR::Flags</a>, <a class="el" href="../../d2/d9/cmchek_8c-source.html#l00095">Index</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01090">IS_CURSOR</a>, <a class="el" href="../../d5/d0/dpcobj_8c-source.html#l00039">KeInitializeDpc()</a>, <a class="el" href="../../d4/d9/ke_8h.html#a354">KeInitializeSpinLock()</a>, <a class="el" href="../../d4/d1/timerobj_8c-source.html#l00043">KeInitializeTimer()</a>, <a class="el" href="../../d5/d8/ke_8h-source.html#l02776">KeNumberProcessors</a>, <a class="el" href="../../d8/d9/ke_2miscc_8c-source.html#l00211">KeQueryTimeIncrement()</a>, <a class="el" href="../../d5/d8/ke_8h-source.html#l02782">KiProcessorBlock</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00429">LAZY_WRITER_IDLE_DELAY</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00129">LazyWriter</a>, <a class="el" href="../../d6/d7/ex_8h-source.html#l01955">_WORK_QUEUE_ITEM::List</a>, <a class="el" href="../../d5/d8/ex_8h.html#a331a202">LookasideTwilightList</a>, <a class="el" href="../../d2/d8/ps_8h-source.html#l00063">_MMSUPPORT::MaximumWorkingSetSize</a>, <a class="el" href="../../d6/d0/mminit_8c-source.html#l03087">MmIsThisAnNtAsSystem()</a>, <a class="el" href="../../d2/d1/mm_8h.html#a343a167">MmLargeSystem</a>, <a class="el" href="../../d6/d7/fssup_8c-source.html#l00045">MmLargeSystemCache</a>, <a class="el" href="../../d2/d1/mm_8h.html#a343a166">MmMediumSystem</a>, <a class="el" href="../../d3/d0/mm_8h-source.html#l00399">MmNumberOfPhysicalPages</a>, <a class="el" href="../../d6/d0/mminit_8c-source.html#l03073">MmQuerySystemSize()</a>, <a class="el" href="../../d2/d1/mm_8h.html#a343a165">MmSmallSystem</a>, <a class="el" href="../../d7/d7/sysinfo_8c-source.html#l00064">MmSystemCacheWs</a>, <a class="el" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01439">_LAZY_WRITER::OurProcess</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00599">PAGE_SIZE</a>, <a class="el" href="../../d2/d8/ps_8h-source.html#l00643">PsGetCurrentProcess</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01457">_LAZY_WRITER::ScanDpc</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01458">_LAZY_WRITER::ScanTimer</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01113">_SHARED_CACHE_MAP_LIST_CURSOR::SharedCacheMapLinks</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, <a class="el" href="../../d5/d4/aug98_2dll32_2icc__i386_8h-source.html#l00064">USHORT</a>, <a class="el" href="../../d5/d5/cc_8h.html#a117">WORK_QUEUE_ENTRY</a>, and <a class="el" href="../../d6/d4/cc_8h-source.html#l01445">_LAZY_WRITER::WorkQueue</a>.
<p>
<pre class="fragment"><div>00074                    :
00075 
00076     This routine must be called during system initialization before <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
00077     first call to any <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> system, to allow <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Cache <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a79">Manager</a> to initialize
00078     its global data structures.  This routine has no dependencies on other
00079     system components being initialized.
00080 
00081 Arguments:
00082 
00083     None
00084 
00085 Return Value:
00086 
00087     <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> <span class="keywordflow">if</span> initialization was successful
00088 
00089 --*/
00090 
00091 {
00092     CLONG i;
00093     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
00094     <a class="code" href="../../d1/d4/struct__NPAGED__LOOKASIDE__LIST.html">PNPAGED_LOOKASIDE_LIST</a> Lookaside;
00095     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> NumberOfItems;
00096     PKPRCB Prcb;
00097     <a class="code" href="../../d7/d9/struct__WORK__QUEUE__ITEM.html">PWORK_QUEUE_ITEM</a> WorkItem;
00098 
00099 <span class="preprocessor">#ifdef CCDBG_LOCK</span>
00100 <span class="preprocessor"></span>    <a class="code" href="../../d4/d9/ke_8h.html#a354">KeInitializeSpinLock</a>( &amp;CcDebugTraceLock );
00101 <span class="preprocessor">#endif</span>
00102 <span class="preprocessor"></span>
00103 <span class="preprocessor">#if DBG</span>
00104 <span class="preprocessor"></span>    CcBcbCount = 0;
00105     InitializeListHead( &amp;CcBcbList );
00106     <a class="code" href="../../d4/d9/ke_8h.html#a354">KeInitializeSpinLock</a>( &amp;CcBcbSpinLock );
00107 <span class="preprocessor">#endif</span>
00108 <span class="preprocessor"></span>
00109     <span class="comment">//</span>
00110     <span class="comment">//  Figure out the timeout clock tick for the lazy writer.</span>
00111     <span class="comment">//</span>
00112 
00113     <a class="code" href="../../d5/d2/cachedat_8c.html#a12">CcIdleDelayTick</a> = <a class="code" href="../../d5/d5/cc_8h.html#a53">LAZY_WRITER_IDLE_DELAY</a> / <a class="code" href="../../d7/d0/ke_2miscc_8c.html#a5">KeQueryTimeIncrement</a>();
00114     
00115     <span class="comment">//</span>
00116     <span class="comment">//  Initialize shared cache map list structures</span>
00117     <span class="comment">//</span>
00118 
00119     <a class="code" href="../../d4/d9/ke_8h.html#a354">KeInitializeSpinLock</a>( &amp;CcMasterSpinLock );
00120     InitializeListHead( &amp;CcCleanSharedCacheMapList );
00121     InitializeListHead( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a2">CcDirtySharedCacheMapList</a>.<a class="code" href="../../d1/d3/struct__SHARED__CACHE__MAP__LIST__CURSOR.html#o0">SharedCacheMapLinks</a> );
00122     <a class="code" href="../../d5/d2/cachedat_8c.html#a2">CcDirtySharedCacheMapList</a>.<a class="code" href="../../d1/d3/struct__SHARED__CACHE__MAP__LIST__CURSOR.html#o1">Flags</a> = <a class="code" href="../../d5/d5/cc_8h.html#a80">IS_CURSOR</a>;
00123     InsertTailList( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a2">CcDirtySharedCacheMapList</a>.<a class="code" href="../../d1/d3/struct__SHARED__CACHE__MAP__LIST__CURSOR.html#o0">SharedCacheMapLinks</a>,
00124                     &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a3">CcLazyWriterCursor</a>.<a class="code" href="../../d1/d3/struct__SHARED__CACHE__MAP__LIST__CURSOR.html#o0">SharedCacheMapLinks</a> );
00125     <a class="code" href="../../d5/d2/cachedat_8c.html#a3">CcLazyWriterCursor</a>.<a class="code" href="../../d1/d3/struct__SHARED__CACHE__MAP__LIST__CURSOR.html#o1">Flags</a> = <a class="code" href="../../d5/d5/cc_8h.html#a80">IS_CURSOR</a>;
00126 
00127     <span class="comment">//</span>
00128     <span class="comment">//  Initialize worker thread structures</span>
00129     <span class="comment">//</span>
00130 
00131     <a class="code" href="../../d4/d9/ke_8h.html#a354">KeInitializeSpinLock</a>( &amp;CcWorkQueueSpinlock );
00132     InitializeListHead( &amp;CcIdleWorkerThreadList );
00133     InitializeListHead( &amp;CcExpressWorkQueue );
00134     InitializeListHead( &amp;CcRegularWorkQueue );
00135     InitializeListHead( &amp;CcPostTickWorkQueue );
00136 
00137     <span class="comment">//</span>
00138     <span class="comment">//  Set the number of worker threads based on the system size.</span>
00139     <span class="comment">//</span>
00140 
00141     <a class="code" href="../../d5/d2/cachedat_8c.html#a37">CcCapturedSystemSize</a> = <a class="code" href="../../d5/d1/mminit_8c.html#a57">MmQuerySystemSize</a>();
00142     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d2/cachedat_8c.html#a5">CcNumberWorkerThreads</a> == 0) {
00143 
00144         <span class="keywordflow">switch</span> (<a class="code" href="../../d5/d2/cachedat_8c.html#a37">CcCapturedSystemSize</a>) {
00145         <span class="keywordflow">case</span> <a class="code" href="../../d2/d1/mm_8h.html#a343a165">MmSmallSystem</a>:
00146             <a class="code" href="../../d5/d2/cachedat_8c.html#a5">CcNumberWorkerThreads</a> = <a class="code" href="../../d1/d9/worker_8c.html#a15">ExCriticalWorkerThreads</a> - 1;
00147             <a class="code" href="../../d5/d2/cachedat_8c.html#a30">CcDirtyPageThreshold</a> = <a class="code" href="../../d2/d1/mm_8h.html#a136">MmNumberOfPhysicalPages</a> / 8;
00148             <a class="code" href="../../d5/d2/cachedat_8c.html#a39">CcAggressiveZeroThreshold</a> = 1;
00149             <span class="keywordflow">break</span>;
00150 
00151         <span class="keywordflow">case</span> <a class="code" href="../../d2/d1/mm_8h.html#a343a166">MmMediumSystem</a>:
00152             <a class="code" href="../../d5/d2/cachedat_8c.html#a5">CcNumberWorkerThreads</a> = <a class="code" href="../../d1/d9/worker_8c.html#a15">ExCriticalWorkerThreads</a> - 1;
00153             <a class="code" href="../../d5/d2/cachedat_8c.html#a30">CcDirtyPageThreshold</a> = <a class="code" href="../../d2/d1/mm_8h.html#a136">MmNumberOfPhysicalPages</a> / 4;
00154             <a class="code" href="../../d5/d2/cachedat_8c.html#a39">CcAggressiveZeroThreshold</a> = 2;
00155             <span class="keywordflow">break</span>;
00156 
00157         <span class="keywordflow">case</span> <a class="code" href="../../d2/d1/mm_8h.html#a343a167">MmLargeSystem</a>:
00158             <a class="code" href="../../d5/d2/cachedat_8c.html#a5">CcNumberWorkerThreads</a> = <a class="code" href="../../d1/d9/worker_8c.html#a15">ExCriticalWorkerThreads</a> - 2;
00159             <a class="code" href="../../d5/d2/cachedat_8c.html#a30">CcDirtyPageThreshold</a> = <a class="code" href="../../d2/d1/mm_8h.html#a136">MmNumberOfPhysicalPages</a> / 4 +
00160                                     <a class="code" href="../../d2/d1/mm_8h.html#a136">MmNumberOfPhysicalPages</a> / 8;
00161             <a class="code" href="../../d5/d2/cachedat_8c.html#a39">CcAggressiveZeroThreshold</a> = 4;
00162 <span class="preprocessor">#if 0</span>
00163 <span class="preprocessor"></span>            <span class="comment">//</span>
00164             <span class="comment">//  Use more memory if we are a large server.</span>
00165             <span class="comment">//</span>
00166 
00167             <span class="keywordflow">if</span> ((<a class="code" href="../../d5/d8/fssup_8c.html#a4">MmLargeSystemCache</a> != 0) &amp;&amp;
00168                 (<a class="code" href="../../d5/d2/cachedat_8c.html#a30">CcDirtyPageThreshold</a> &lt; (<a class="code" href="../../d2/d1/mm_8h.html#a136">MmNumberOfPhysicalPages</a> - (0xE00000 / <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>)))) {
00169 
00170                 <a class="code" href="../../d5/d2/cachedat_8c.html#a30">CcDirtyPageThreshold</a> = <a class="code" href="../../d2/d1/mm_8h.html#a136">MmNumberOfPhysicalPages</a> - (0xE00000 / <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
00171             }
00172 <span class="preprocessor">#endif</span>
00173 <span class="preprocessor"></span>            <span class="keywordflow">break</span>;
00174 
00175         <span class="keywordflow">default</span>:
00176             <a class="code" href="../../d5/d2/cachedat_8c.html#a5">CcNumberWorkerThreads</a> = 1;
00177             <a class="code" href="../../d5/d2/cachedat_8c.html#a30">CcDirtyPageThreshold</a> = <a class="code" href="../../d2/d1/mm_8h.html#a136">MmNumberOfPhysicalPages</a> / 8;
00178         }
00179 
00180 <span class="comment">//        CcDirtyPageThreshold = (2*1024*1024)/PAGE_SIZE;</span>
00181 
00182         <span class="keywordflow">if</span> (<a class="code" href="../../d6/d8/sysinfo_8c.html#a21">MmSystemCacheWs</a>.<a class="code" href="../../d3/d6/struct__MMSUPPORT.html#o6">MaximumWorkingSetSize</a> &gt; ((4*1024*1024)/<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>)) {
00183             <a class="code" href="../../d5/d2/cachedat_8c.html#a30">CcDirtyPageThreshold</a> = <a class="code" href="../../d6/d8/sysinfo_8c.html#a21">MmSystemCacheWs</a>.<a class="code" href="../../d3/d6/struct__MMSUPPORT.html#o6">MaximumWorkingSetSize</a> -
00184                                                     ((2*1024*1024)/<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
00185         }
00186 
00187         <a class="code" href="../../d5/d2/cachedat_8c.html#a31">CcDirtyPageTarget</a> = <a class="code" href="../../d5/d2/cachedat_8c.html#a30">CcDirtyPageThreshold</a> / 2 +
00188                             <a class="code" href="../../d5/d2/cachedat_8c.html#a30">CcDirtyPageThreshold</a> / 4;
00189     }
00190 
00191     <a class="code" href="../../d5/d2/cachedat_8c.html#a38">CcAggressiveZeroCount</a> = 0;
00192 
00193     <span class="comment">//</span>
00194     <span class="comment">//  Now allocate and initialize the above number of worker thread</span>
00195     <span class="comment">//  items.</span>
00196     <span class="comment">//</span>
00197 
00198     <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="../../d5/d2/cachedat_8c.html#a5">CcNumberWorkerThreads</a>; i++) {
00199 
00200         WorkItem = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( NonPagedPool, <span class="keyword">sizeof</span>(<a class="code" href="../../d7/d9/struct__WORK__QUEUE__ITEM.html">WORK_QUEUE_ITEM</a>), 'qWcC' );
00201 
00202         <span class="keywordflow">if</span> (WorkItem == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00203             
00204             <a class="code" href="../../d5/d5/cc_8h.html#a28">CcBugCheck</a>( 0, 0, 0 );
00205         }
00206 
00207         <span class="comment">//</span>
00208         <span class="comment">//  Initialize the work queue item and insert in our queue</span>
00209         <span class="comment">//  of potential worker threads.</span>
00210         <span class="comment">//</span>
00211 
00212         <a class="code" href="../../d5/d8/ex_8h.html#a55">ExInitializeWorkItem</a>( WorkItem, CcWorkerThread, WorkItem );
00213         InsertTailList( &amp;CcIdleWorkerThreadList, &amp;WorkItem-&gt;<a class="code" href="../../d7/d9/struct__WORK__QUEUE__ITEM.html#o0">List</a> );
00214     }
00215 
00216     <span class="comment">//</span>
00217     <span class="comment">//  Initialize the Lazy Writer thread structure, and start him up.</span>
00218     <span class="comment">//</span>
00219 
00220     RtlZeroMemory( &amp;LazyWriter, <span class="keyword">sizeof</span>(<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html">LAZY_WRITER</a>) );
00221 
00222     <a class="code" href="../../d4/d9/ke_8h.html#a354">KeInitializeSpinLock</a>( &amp;CcWorkQueueSpinlock );
00223     InitializeListHead( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o1">WorkQueue</a> );
00224 
00225     <span class="comment">//</span>
00226     <span class="comment">//  Store process address</span>
00227     <span class="comment">//</span>
00228 
00229     <a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o0">OurProcess</a> = <a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a>();
00230 
00231     <span class="comment">//</span>
00232     <span class="comment">//  Initialize the Scan Dpc and Timer.</span>
00233     <span class="comment">//</span>
00234 
00235     <a class="code" href="../../d4/d1/dpcobj_8c.html#a1">KeInitializeDpc</a>( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o3">ScanDpc</a>, &amp;CcScanDpc, NULL );
00236     <a class="code" href="../../d3/d2/timerobj_8c.html#a1">KeInitializeTimer</a>( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o4">ScanTimer</a> );
00237 
00238     <span class="comment">//</span>
00239     <span class="comment">//  Now initialize the lookaside list for allocating Work Queue entries.</span>
00240     <span class="comment">//</span>
00241 
00242     <span class="keywordflow">switch</span> ( <a class="code" href="../../d5/d2/cachedat_8c.html#a37">CcCapturedSystemSize</a> ) {
00243 
00244         <span class="comment">//</span>
00245         <span class="comment">// ~512 bytes</span>
00246         <span class="comment">//</span>
00247 
00248     <span class="keywordflow">case</span> <a class="code" href="../../d2/d1/mm_8h.html#a343a165">MmSmallSystem</a> :
00249         NumberOfItems = 32;
00250         <span class="keywordflow">break</span>;
00251 
00252         <span class="comment">//</span>
00253         <span class="comment">// ~1k bytes</span>
00254         <span class="comment">//</span>
00255 
00256     <span class="keywordflow">case</span> <a class="code" href="../../d2/d1/mm_8h.html#a343a166">MmMediumSystem</a> :
00257         NumberOfItems = 64;
00258         <span class="keywordflow">break</span>;
00259 
00260         <span class="comment">//</span>
00261         <span class="comment">// ~2k bytes</span>
00262         <span class="comment">//</span>
00263 
00264     <span class="keywordflow">case</span> <a class="code" href="../../d2/d1/mm_8h.html#a343a167">MmLargeSystem</a> :
00265         NumberOfItems = 128;
00266         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d1/mminit_8c.html#a58">MmIsThisAnNtAsSystem</a>()) {
00267             NumberOfItems += 128;
00268         }
00269 
00270         <span class="keywordflow">break</span>;
00271     }
00272 
00273     <a class="code" href="../../d5/d8/ex_8h.html#a246">ExInitializeNPagedLookasideList</a>( &amp;CcTwilightLookasideList,
00274                                      NULL,
00275                                      NULL,
00276                                      0,
00277                                      <span class="keyword">sizeof</span>( <a class="code" href="../../d2/d9/struct__WORK__QUEUE__ENTRY.html">WORK_QUEUE_ENTRY</a> ),
00278                                      'kWcC',
00279                                      NumberOfItems );
00280 
00281     <span class="comment">//</span>
00282     <span class="comment">// Initialize the per processor nonpaged lookaside lists and descriptors.</span>
00283     <span class="comment">//</span>
00284 
00285     <span class="keywordflow">for</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = 0; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &lt; (ULONG)<a class="code" href="../../d4/d9/ke_8h.html#a133">KeNumberProcessors</a>; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> += 1) {
00286         Prcb = <a class="code" href="../../d4/d9/ke_8h.html#a139">KiProcessorBlock</a>[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>];
00287 
00288         <span class="comment">//</span>
00289         <span class="comment">// Initialize the large IRP per processor lookaside pointers.</span>
00290         <span class="comment">//</span>
00291 
00292         Prcb-&gt;PPLookasideList[<a class="code" href="../../d5/d8/ex_8h.html#a331a202">LookasideTwilightList</a>].L = &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a42">CcTwilightLookasideList</a>;
00293         Lookaside = (<a class="code" href="../../d1/d4/struct__NPAGED__LOOKASIDE__LIST.html">PNPAGED_LOOKASIDE_LIST</a>)<a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( NonPagedPool,
00294                                                                    <span class="keyword">sizeof</span>(<a class="code" href="../../d1/d4/struct__NPAGED__LOOKASIDE__LIST.html">NPAGED_LOOKASIDE_LIST</a>),
00295                                                                    'KWcC');
00296 
00297         <span class="keywordflow">if</span> (Lookaside != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00298             <a class="code" href="../../d5/d8/ex_8h.html#a246">ExInitializeNPagedLookasideList</a>( Lookaside,
00299                                              NULL,
00300                                              NULL,
00301                                              0,
00302                                              <span class="keyword">sizeof</span>( <a class="code" href="../../d2/d9/struct__WORK__QUEUE__ENTRY.html">WORK_QUEUE_ENTRY</a> ),
00303                                              'KWcC',
00304                                              NumberOfItems );
00305 
00306         } <span class="keywordflow">else</span> {
00307             Lookaside = &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a42">CcTwilightLookasideList</a>;
00308         }
00309 
00310         Prcb-&gt;PPLookasideList[<a class="code" href="../../d5/d8/ex_8h.html#a331a202">LookasideTwilightList</a>].P = Lookaside;
00311     }
00312 
00313     <span class="comment">//</span>
00314     <span class="comment">//  Now initialize the Bcb zone</span>
00315     <span class="comment">//</span>
00316 
00317     {
00318         PVOID InitialSegment;
00319         ULONG InitialSegmentSize;
00320         ULONG RoundedBcbSize = (<span class="keyword">sizeof</span>(<a class="code" href="../../d4/d3/struct__BCB.html">BCB</a>) + 7) &amp; ~7;
00321 
00322         <span class="keywordflow">switch</span> ( <a class="code" href="../../d5/d2/cachedat_8c.html#a37">CcCapturedSystemSize</a> ) {
00323 
00324                 <span class="comment">//</span>
00325                 <span class="comment">// ~1.5k bytes</span>
00326                 <span class="comment">//</span>
00327 
00328             <span class="keywordflow">case</span> <a class="code" href="../../d2/d1/mm_8h.html#a343a165">MmSmallSystem</a> :
00329                 InitialSegmentSize = <span class="keyword">sizeof</span>(<a class="code" href="../../d1/d0/struct__ZONE__SEGMENT__HEADER.html">ZONE_SEGMENT_HEADER</a>) + RoundedBcbSize * 8;
00330                 <span class="keywordflow">break</span>;
00331 
00332                 <span class="comment">//</span>
00333                 <span class="comment">// 1 Page</span>
00334                 <span class="comment">//</span>
00335 
00336             <span class="keywordflow">case</span> <a class="code" href="../../d2/d1/mm_8h.html#a343a166">MmMediumSystem</a> :
00337                 InitialSegmentSize = <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
00338                 <span class="keywordflow">break</span>;
00339 
00340                 <span class="comment">//</span>
00341                 <span class="comment">// 3 Pages</span>
00342                 <span class="comment">//</span>
00343 
00344             <span class="keywordflow">case</span> <a class="code" href="../../d2/d1/mm_8h.html#a343a167">MmLargeSystem</a> :
00345                 InitialSegmentSize = 3 * <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
00346                 <span class="keywordflow">break</span>;
00347             }
00348 
00349         <span class="comment">//</span>
00350         <span class="comment">//  Allocate the initial allocation for the zone.  If we cannot get it,</span>
00351         <span class="comment">//  something must really be wrong, so we will just bugcheck.</span>
00352         <span class="comment">//</span>
00353 
00354         <span class="keywordflow">if</span> ((InitialSegment = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( NonPagedPool,
00355                                                      InitialSegmentSize,
00356                                                      'zBcC' )) == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00357 
00358             <a class="code" href="../../d5/d5/cc_8h.html#a28">CcBugCheck</a>( 0, 0, 0 );
00359         }
00360 
00361         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d5/d8/ex_8h.html#a263">ExInitializeZone</a>( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o2">BcbZone</a>,
00362                                           RoundedBcbSize,
00363                                           InitialSegment,
00364                                           InitialSegmentSize ))) {
00365             <a class="code" href="../../d5/d5/cc_8h.html#a28">CcBugCheck</a>( 0, 0, 0 );
00366         }
00367     }
00368 
00369     <span class="comment">//</span>
00370     <span class="comment">//  Initialize the Deferred Write List.</span>
00371     <span class="comment">//</span>
00372 
00373     <a class="code" href="../../d4/d9/ke_8h.html#a354">KeInitializeSpinLock</a>( &amp;CcDeferredWriteSpinLock );
00374     InitializeListHead( &amp;CcDeferredWrites );
00375 
00376     <span class="comment">//</span>
00377     <span class="comment">//  Initialize the Vacbs.</span>
00378     <span class="comment">//</span>
00379 
00380     <a class="code" href="../../d5/d5/cc_8h.html#a192">CcInitializeVacbs</a>();
00381 
00382     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00383 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a58" doxytag="cache.h::CcInitializeCacheMap" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTKERNELAPI VOID CcInitializeCacheMap           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>FileObject</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d1/d9/struct__CC__FILE__SIZES.html">PCC_FILE_SIZES</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>FileSizes</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN BOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>PinAccess</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d3/d6/struct__CACHE__MANAGER__CALLBACKS.html">PCACHE_MANAGER_CALLBACKS</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>Callbacks</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>LazyWriteContext</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d7/fssup_8c-source.html#l00387">387</a> of file <a class="el" href="../../d6/d7/fssup_8c-source.html">fssup.c</a>.
<p>
References <a class="el" href="../../d6/d4/cc_8h-source.html#l00816">_SHARED_CACHE_MAP::ActiveVacbSpinLock</a>, <a class="el" href="../../d5/d1/cache_8h-source.html#l00062">_CC_FILE_SIZES::AllocationSize</a>, <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00760">_SHARED_CACHE_MAP::BcbList</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00965">_SHARED_CACHE_MAP::BcbSpinLock</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01071">BEING_CREATED</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00154">CACHE_NTC_PRIVATE_CACHE_MAP</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00153">CACHE_NTC_SHARED_CACHE_MAP</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00903">_SHARED_CACHE_MAP::Callbacks</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00064">CcAcquireMasterLock</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00030">CcCleanSharedCacheMapList</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l01208">CcCreateVacbArray()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01010">CcDecrementOpenCount</a>, <a class="el" href="../../d6/d7/fssup_8c-source.html#l01517">CcDeleteSharedCacheMap()</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00031">CcDirtySharedCacheMapList</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l01377">CcExtendVacbArray()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01003">CcIncrementOpenCount</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00067">CcReleaseMasterLock</a>, <a class="el" href="../../d6/d0/lazyrite_8c-source.html#l00049">CcScheduleLazyWriteScan()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00509">ClearFlag</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00871">_SHARED_CACHE_MAP::CreateEvent</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02290">DebugTrace</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02292">DebugTrace2</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00192">DEFAULT_CREATE_MODULO</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00846">_SHARED_CACHE_MAP::DirtyPages</a>, <a class="el" href="../../d5/d1/cache_8h-source.html#l00139">_CACHE_UNINITIALIZE_EVENT::Event</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00979">_SHARED_CACHE_MAP::Event</a>, <a class="el" href="../../d6/d7/ex_8h-source.html#l00253">ExAllocatePoolWithTag</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00623">Executive</a>, <a class="el" href="../../d7/d2/cmwraper_8c-source.html#l00304">ExFreePool()</a>, <a class="el" href="../../d1/d3/ex_2alpha_2raisests_8c-source.html#l00157">ExRaiseStatus()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00652">_PRIVATE_CACHE_MAP::FileObject</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00796">_SHARED_CACHE_MAP::FileObject</a>, <a class="el" href="../../d5/d1/cache_8h-source.html#l00063">_CC_FILE_SIZES::FileSize</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00752">_SHARED_CACHE_MAP::FileSize</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00497">FlagOn</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00832">_SHARED_CACHE_MAP::Flags</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01510">FO_RANDOM_ACCESS</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01495">FO_SEQUENTIAL_ONLY</a>, <a class="el" href="../../d2/d7/fsrtl_8h-source.html#l00256">FSRTL_FLAG2_DO_MODIFIED_WRITE</a>, <a class="el" href="../../d8/d2/fsrtl_2filter_8c-source.html#l00049">FsRtlNormalizeNtstatus()</a>, <a class="el" href="../../d5/d8/ke_8h-source.html#l01066">KeInitializeEvent</a>, <a class="el" href="../../d4/d9/ke_8h.html#a354">KeInitializeSpinLock()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00624">KernelMode</a>, <a class="el" href="../../d3/d7/eventobj_8c-source.html#l00343">KeSetEvent()</a>, <a class="el" href="../../d2/d6/wait_8c-source.html#l00810">KeWaitForSingleObject()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00905">_SHARED_CACHE_MAP::LazyWriteContext</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00129">LazyWriter</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00978">_SHARED_CACHE_MAP::LocalEvent</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l00033">me</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00462">mm</a>, <a class="el" href="../../d1/d7/creasect_8c-source.html#l00390">MmCreateSection()</a>, <a class="el" href="../../d7/d2/modwrite_8c-source.html#l04397">MmDisableModifiedWriteOfSection()</a>, <a class="el" href="../../d9/d9/extsect_8c-source.html#l00201">MmExtendSection()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01077">MODIFIED_WRITE_DISABLED</a>, <a class="el" href="../../d5/d1/cache_8h-source.html#l00138">_CACHE_UNINITIALIZE_EVENT::Next</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00646">_PRIVATE_CACHE_MAP::NodeByteSize</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00734">_SHARED_CACHE_MAP::NodeByteSize</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00645">_PRIVATE_CACHE_MAP::NodeTypeCode</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00733">_SHARED_CACHE_MAP::NodeTypeCode</a>, <a class="el" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d7/d9/obcreate_8c-source.html#l00713">ObDeleteCapturedInsertInfo()</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00514">ObReferenceObject</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01059">ONLY_SEQUENTIAL_ONLY_SEEN</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00740">_SHARED_CACHE_MAP::OpenCount</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01471">_LAZY_WRITER::OtherWork</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00599">PAGE_SIZE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01038">PIN_ACCESS</a>, <a class="el" href="../../d5/d5/cc_8h.html#a99">PRIVATE_CACHE_MAP</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00985">_SHARED_CACHE_MAP::PrivateCacheMap</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00696">_PRIVATE_CACHE_MAP::PrivateLinks</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00911">_SHARED_CACHE_MAP::PrivateList</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01098">RANDOM_ACCESS_SEEN</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00689">_PRIVATE_CACHE_MAP::ReadAheadMask</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00683">_PRIVATE_CACHE_MAP::ReadAheadSpinLock</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01464">_LAZY_WRITER::ScanActive</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00852">_SHARED_CACHE_MAP::Section</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00766">_SHARED_CACHE_MAP::SectionSize</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00505">SetFlag</a>, <a class="el" href="../../d5/d5/cc_8h.html#a101">SHARED_CACHE_MAP</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01113">_SHARED_CACHE_MAP_LIST_CURSOR::SharedCacheMapLinks</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00826">_SHARED_CACHE_MAP::SharedCacheMapLinks</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00858">_SHARED_CACHE_MAP::Status</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01045">TRUNCATE_REQUIRED</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02154">try_return</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00950">_SHARED_CACHE_MAP::UninitializeEvent</a>, <a class="el" href="../../d5/d1/cache_8h-source.html#l00030">VACB_MAPPING_GRANULARITY</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00789">_SHARED_CACHE_MAP::Vacbs</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00780">_SHARED_CACHE_MAP::ValidDataGoal</a>, <a class="el" href="../../d5/d1/cache_8h-source.html#l00064">_CC_FILE_SIZES::ValidDataLength</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00773">_SHARED_CACHE_MAP::ValidDataLength</a>, and <a class="el" href="../../d6/d4/cc_8h-source.html#l01051">WRITE_QUEUED</a>.
<p>
Referenced by <a class="el" href="../../d8/d4/udfs_2read_8c-source.html#l00068">UdfCommonRead()</a>, and <a class="el" href="../../d9/d1/udfs_2cachesup_8c-source.html#l00046">UdfCreateInternalStream()</a>.
<p>
<pre class="fragment"><div>00397                    :
00398 
00399     This routine <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> intended to be called by <a class="code" href="../../d1/d9/icmui_8def.html#a0">File</a> Systems <a class="code" href="../../d3/d0/imm32_8def.html#a1">only</a>.  It
00400     initializes <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> cache maps <span class="keywordflow">for</span> data caching.  It should be called
00401     every time a <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> open or created, and NO_INTERMEDIATE_BUFFERING
00402     was specified as <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>.
00403 
00404 Arguments:
00405 
00406     FileObject - <a class="code" href="../../d2/d1/bench_8h.html#a5">A</a> pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> newly-created <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> object.
00407 
00408     FileSizes - <a class="code" href="../../d2/d1/bench_8h.html#a5">A</a> pointer to AllocationSize, FileSize and ValidDataLength
00409                 <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a>.  ValidDataLength should contain MAXLONGLONG <span class="keywordflow">if</span>
00410                 valid data length tracking and callbacks are not desired.
00411 
00412     PinAccess - <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> <span class="keywordflow">if</span> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> will be used exclusively <span class="keywordflow">for</span> <a class="code" href="../../d9/d0/cmdata_8h.html#a104a97">Copy</a> and Mdl
00413                 access, or <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> <span class="keywordflow">if</span> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> will be used <span class="keywordflow">for</span> Pin access.
00414                 (Files <span class="keywordflow">for</span> Pin access are not limited in size as <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller
00415                 must access multiple areas of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> at once.)
00416 
00417     Callbacks - Structure of callbacks used by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Lazy <a class="code" href="../../d4/d0/tex_8c.html#a44">Writer</a>
00418 
00419     LazyWriteContext - Parameter to be passed in to above routine.
00420 
00421 Return Value:
00422 
00423     None.  If an error occurs, <span class="keyword">this</span> routine will Raise <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> status.
00424 
00425 --*/
00426 
00427 {
00428     KIRQL OldIrql;
00429     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00430     PVOID CacheMapToFree = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00431     <a class="code" href="../../d1/d9/struct__CC__FILE__SIZES.html">CC_FILE_SIZES</a> LocalSizes;
00432     BOOLEAN WeSetBeingCreated = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00433     BOOLEAN SharedListOwned = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00434     BOOLEAN MustUninitialize = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00435     BOOLEAN WeCreated = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00436 
00437     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, me, <span class="stringliteral">"CcInitializeCacheMap:\n"</span>, 0 );
00438     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, me, <span class="stringliteral">"    FileObject = %08lx\n"</span>, FileObject );
00439     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, me, <span class="stringliteral">"    FileSizes = %08lx\n"</span>, FileSizes );
00440 
00441     <span class="comment">//</span>
00442     <span class="comment">//  Make a local copy of the passed in file sizes before acquiring</span>
00443     <span class="comment">//  the spin lock.</span>
00444     <span class="comment">//</span>
00445 
00446     LocalSizes = *FileSizes;
00447 
00448     <span class="comment">//</span>
00449     <span class="comment">//  If no FileSize was given, set to one byte before maximizing below.</span>
00450     <span class="comment">//</span>
00451 
00452     <span class="keywordflow">if</span> (LocalSizes.<a class="code" href="../../d1/d9/struct__CC__FILE__SIZES.html#o0">AllocationSize</a>.QuadPart == 0) {
00453         LocalSizes.<a class="code" href="../../d1/d9/struct__CC__FILE__SIZES.html#o0">AllocationSize</a>.LowPart += 1;
00454     }
00455 
00456     <span class="comment">//</span>
00457     <span class="comment">//  If caller has Write access or will allow write, then round</span>
00458     <span class="comment">//  size to next create modulo.  (***Temp*** there may be too many</span>
00459     <span class="comment">//  apps that end up allowing shared write, thanks to our Dos heritage,</span>
00460     <span class="comment">//  to keep that part of the check in.)</span>
00461     <span class="comment">//</span>
00462 
00463     <span class="keywordflow">if</span> (FileObject-&gt;WriteAccess <span class="comment">/*|| FileObject-&gt;SharedWrite */</span>) {
00464 
00465         LocalSizes.<a class="code" href="../../d1/d9/struct__CC__FILE__SIZES.html#o0">AllocationSize</a>.QuadPart = LocalSizes.<a class="code" href="../../d1/d9/struct__CC__FILE__SIZES.html#o0">AllocationSize</a>.QuadPart + (LONGLONG)(<a class="code" href="../../d5/d5/cc_8h.html#a29">DEFAULT_CREATE_MODULO</a> - 1);
00466         LocalSizes.<a class="code" href="../../d1/d9/struct__CC__FILE__SIZES.html#o0">AllocationSize</a>.LowPart &amp;= ~(<a class="code" href="../../d5/d5/cc_8h.html#a29">DEFAULT_CREATE_MODULO</a> - 1);
00467 
00468     } <span class="keywordflow">else</span> {
00469 
00470         LocalSizes.<a class="code" href="../../d1/d9/struct__CC__FILE__SIZES.html#o0">AllocationSize</a>.QuadPart = LocalSizes.<a class="code" href="../../d1/d9/struct__CC__FILE__SIZES.html#o0">AllocationSize</a>.QuadPart + (LONGLONG)(<a class="code" href="../../d4/d2/cache_8h.html#a0">VACB_MAPPING_GRANULARITY</a> - 1);
00471         LocalSizes.<a class="code" href="../../d1/d9/struct__CC__FILE__SIZES.html#o0">AllocationSize</a>.LowPart &amp;= ~(<a class="code" href="../../d4/d2/cache_8h.html#a0">VACB_MAPPING_GRANULARITY</a> - 1);
00472     }
00473 
00474     <span class="comment">//</span>
00475     <span class="comment">//  Do the allocate of the SharedCacheMap, based on an unsafe test,</span>
00476     <span class="comment">//  while not holding a spinlock.  Allocation failures look like we</span>
00477     <span class="comment">//  never decided to allocate one here!</span>
00478     <span class="comment">//</span>
00479 
00480     <span class="keywordflow">if</span> (FileObject-&gt;SectionObjectPointer-&gt;SharedCacheMap == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00481         CacheMapToFree = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( NonPagedPool, <span class="keyword">sizeof</span>(<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">SHARED_CACHE_MAP</a>), 'cScC' );
00482     }
00483 
00484     <span class="comment">//</span>
00485     <span class="comment">//  Serialize Creation/Deletion of all Shared CacheMaps</span>
00486     <span class="comment">//</span>
00487 
00488     <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
00489     SharedListOwned = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00490 
00491     <span class="comment">//</span>
00492     <span class="comment">//  Insure release of our global resource</span>
00493     <span class="comment">//</span>
00494 
00495     <span class="keywordflow">try</span> {
00496 
00497         <span class="comment">//</span>
00498         <span class="comment">//  Check for second initialization of same file object</span>
00499         <span class="comment">//</span>
00500 
00501         <span class="keywordflow">if</span> (FileObject-&gt;PrivateCacheMap != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00502 
00503             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, 0, <span class="stringliteral">"CacheMap already initialized\n"</span>, 0 );
00504             <a class="code" href="../../d5/d5/cc_8h.html#a90">try_return</a>( NOTHING );
00505         }
00506 
00507         <span class="comment">//</span>
00508         <span class="comment">//  Get current Shared Cache Map pointer indirectly off of the file object.</span>
00509         <span class="comment">//  (The actual pointer is typically in a file system data structure, such</span>
00510         <span class="comment">//  as an Fcb.)</span>
00511         <span class="comment">//</span>
00512 
00513         SharedCacheMap = FileObject-&gt;SectionObjectPointer-&gt;SharedCacheMap;
00514 
00515         <span class="comment">//</span>
00516         <span class="comment">//  If there is no SharedCacheMap, then we must create a section and</span>
00517         <span class="comment">//  the SharedCacheMap structure.</span>
00518         <span class="comment">//</span>
00519 
00520         <span class="keywordflow">if</span> (SharedCacheMap == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00521 
00522             <span class="comment">//</span>
00523             <span class="comment">//  After successfully creating the section, allocate the SharedCacheMap.</span>
00524             <span class="comment">//</span>
00525 
00526             WeCreated = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00527 
00528             <span class="keywordflow">if</span> (CacheMapToFree == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00529                 CacheMapToFree = (<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a>)<a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( NonPagedPool,
00530                                                                            <span class="keyword">sizeof</span>(<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">SHARED_CACHE_MAP</a>),
00531                                                                            'cScC' );
00532             }
00533 
00534             SharedCacheMap = CacheMapToFree;
00535             CacheMapToFree = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00536 
00537             <span class="keywordflow">if</span> (SharedCacheMap == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00538 
00539                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, 0, <span class="stringliteral">"Failed to allocate SharedCacheMap\n"</span>, 0 );
00540 
00541                 <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
00542                 SharedListOwned = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00543 
00544                 <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INSUFFICIENT_RESOURCES );
00545             }
00546 
00547             <span class="comment">//</span>
00548             <span class="comment">//  Zero the SharedCacheMap and fill in the nonzero portions later.</span>
00549             <span class="comment">//</span>
00550 
00551             RtlZeroMemory( SharedCacheMap, <span class="keyword">sizeof</span>(<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">SHARED_CACHE_MAP</a>) );
00552 
00553 <span class="preprocessor">#if DANLO</span>
00554 <span class="preprocessor"></span>            SharedCacheMap-&gt;OpenCountLog.Size = <span class="keyword">sizeof</span>(SharedCacheMap-&gt;OpenCountLog.Log)/<span class="keyword">sizeof</span>(CC_LOG_ENTRY);
00555 <span class="preprocessor">#endif</span>
00556 <span class="preprocessor"></span>
00557             <span class="comment">//</span>
00558             <span class="comment">//  Now initialize the Shared Cache Map.</span>
00559             <span class="comment">//</span>
00560 
00561             SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o0">NodeTypeCode</a> = <a class="code" href="../../d5/d5/cc_8h.html#a12">CACHE_NTC_SHARED_CACHE_MAP</a>;
00562             SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o1">NodeByteSize</a> = <span class="keyword">sizeof</span>(<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">SHARED_CACHE_MAP</a>);
00563             SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o10">FileObject</a> = FileObject;
00564             SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o3">FileSize</a> = LocalSizes.<a class="code" href="../../d1/d9/struct__CC__FILE__SIZES.html#o1">FileSize</a>;
00565             SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o6">ValidDataLength</a> = LocalSizes.<a class="code" href="../../d1/d9/struct__CC__FILE__SIZES.html#o2">ValidDataLength</a>;
00566             SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o7">ValidDataGoal</a> = LocalSizes.<a class="code" href="../../d1/d9/struct__CC__FILE__SIZES.html#o2">ValidDataLength</a>;
00567             <span class="comment">//  SharedCacheMap-&gt;Section set below</span>
00568 
00569             <span class="comment">//</span>
00570             <span class="comment">//  Initialize the spin locks.</span>
00571             <span class="comment">//</span>
00572 
00573             <a class="code" href="../../d4/d9/ke_8h.html#a354">KeInitializeSpinLock</a>( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o15">ActiveVacbSpinLock</a> );
00574             <a class="code" href="../../d4/d9/ke_8h.html#a354">KeInitializeSpinLock</a>( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o36">BcbSpinLock</a> );
00575 
00576             <span class="keywordflow">if</span> (PinAccess) {
00577                 <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, PIN_ACCESS);
00578             }
00579 
00580             <span class="comment">//</span>
00581             <span class="comment">//  Initialize our allocation hint for the local event.</span>
00582             <span class="comment">//</span>
00583 
00584             SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o37">LocalEvent</a> = &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o38">Event</a>;
00585 
00586             <span class="comment">//</span>
00587             <span class="comment">//  If this file has FO_SEQUENTIAL_ONLY set, then remember that</span>
00588             <span class="comment">//  in the SharedCacheMap.</span>
00589             <span class="comment">//</span>
00590 
00591             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(FileObject-&gt;Flags, FO_SEQUENTIAL_ONLY)) {
00592                 <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, ONLY_SEQUENTIAL_ONLY_SEEN);
00593             }
00594 
00595             <span class="comment">//</span>
00596             <span class="comment">//  Do the round-robin allocation of the spinlock for the shared</span>
00597             <span class="comment">//  cache map.  Note the manipulation of the next</span>
00598             <span class="comment">//  counter is safe, since we have the CcMasterSpinLock</span>
00599             <span class="comment">//  exclusive.</span>
00600             <span class="comment">//</span>
00601 
00602             InitializeListHead( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o4">BcbList</a> );
00603             SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o27">Callbacks</a> = Callbacks;
00604             SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o28">LazyWriteContext</a> = LazyWriteContext;
00605 
00606             <span class="comment">//</span>
00607             <span class="comment">//  Initialize listhead for all PrivateCacheMaps</span>
00608             <span class="comment">//</span>
00609 
00610             InitializeListHead( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o29">PrivateList</a> );
00611 
00612             <span class="comment">//</span>
00613             <span class="comment">//  Insert the new Shared Cache Map in the global list</span>
00614             <span class="comment">//</span>
00615 
00616             InsertTailList( &amp;CcCleanSharedCacheMapList,
00617                             &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a> );
00618 
00619             <span class="comment">//</span>
00620             <span class="comment">//  Finally, store the pointer to the Shared Cache Map back</span>
00621             <span class="comment">//  via the indirect pointer in the File Object.</span>
00622             <span class="comment">//</span>
00623 
00624             FileObject-&gt;SectionObjectPointer-&gt;SharedCacheMap = SharedCacheMap;
00625 
00626             <span class="comment">//</span>
00627             <span class="comment">//  We must reference this file object so that it cannot go away</span>
00628             <span class="comment">//  until we do CcUninitializeCacheMap below.  Note we cannot</span>
00629             <span class="comment">//  find or rely on the FileObject that Memory Management has,</span>
00630             <span class="comment">//  although normally it will be this same one anyway.</span>
00631             <span class="comment">//</span>
00632 
00633             <a class="code" href="../../d4/d0/ob_8h.html#a15">ObReferenceObject</a> ( FileObject );
00634 
00635         } <span class="keywordflow">else</span> {
00636 
00637             <span class="comment">//</span>
00638             <span class="comment">//  If this file has FO_SEQUENTIAL_ONLY clear, then remember that</span>
00639             <span class="comment">//  in the SharedCacheMap.</span>
00640             <span class="comment">//</span>
00641 
00642             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(FileObject-&gt;Flags, FO_SEQUENTIAL_ONLY)) {
00643                 <a class="code" href="../../d5/d5/cc_8h.html#a61">ClearFlag</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, ONLY_SEQUENTIAL_ONLY_SEEN);
00644             }
00645         }
00646 
00647         <span class="comment">//</span>
00648         <span class="comment">//  If this file is opened for random access, remember this in</span>
00649         <span class="comment">//  the SharedCacheMap.</span>
00650         <span class="comment">//</span>
00651 
00652         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(FileObject-&gt;Flags, FO_RANDOM_ACCESS)) {
00653             <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, RANDOM_ACCESS_SEEN);
00654         }
00655 
00656         <span class="comment">//</span>
00657         <span class="comment">//  Make sure that no one is trying to lazy delete it in the case</span>
00658         <span class="comment">//  that the Cache Map was already there.</span>
00659         <span class="comment">//</span>
00660 
00661         <a class="code" href="../../d5/d5/cc_8h.html#a61">ClearFlag</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, TRUNCATE_REQUIRED);
00662 
00663         <span class="comment">//</span>
00664         <span class="comment">//  In case there has been a CcUnmapAndPurge call, we check here if we</span>
00665         <span class="comment">//  if we need to recreate the section and map it.</span>
00666         <span class="comment">//</span>
00667 
00668         <span class="keywordflow">if</span> ((SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o9">Vacbs</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
00669             !<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, BEING_CREATED)) {
00670 
00671             <span class="comment">//</span>
00672             <span class="comment">//  Increment the OpenCount on the CacheMap.</span>
00673             <span class="comment">//</span>
00674 
00675             <a class="code" href="../../d5/d5/cc_8h.html#a68">CcIncrementOpenCount</a>( SharedCacheMap, 'onnI' );
00676             MustUninitialize = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00677 
00678             <span class="comment">//</span>
00679             <span class="comment">//  We still want anyone else to wait.</span>
00680             <span class="comment">//</span>
00681 
00682             <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, BEING_CREATED);
00683             WeSetBeingCreated = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00684 
00685             <span class="comment">//</span>
00686             <span class="comment">//  If there is a create event, then this must be the path where we</span>
00687             <span class="comment">//  we were only unmapped.  We will just clear it here again in case</span>
00688             <span class="comment">//  someone needs to wait again this time too.</span>
00689             <span class="comment">//</span>
00690 
00691             <span class="keywordflow">if</span> (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o23">CreateEvent</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00692 
00693                 <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o23">CreateEvent</a>,
00694                                    NotificationEvent,
00695                                    FALSE );
00696             }
00697 
00698             <span class="comment">//</span>
00699             <span class="comment">//  Release global resource</span>
00700             <span class="comment">//</span>
00701 
00702             <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
00703             SharedListOwned = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00704 
00705             <span class="comment">//</span>
00706             <span class="comment">//  We have to test this, because the section may only be unmapped.</span>
00707             <span class="comment">//</span>
00708 
00709             <span class="keywordflow">if</span> (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o21">Section</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00710 
00711                 LARGE_INTEGER LargeZero = {0,0};
00712 
00713                 <span class="comment">//</span>
00714                 <span class="comment">//  Call MM to create a section for this file, for the calculated</span>
00715                 <span class="comment">//  section size.  Note that we have the choice in this service to</span>
00716                 <span class="comment">//  pass in a FileHandle or a FileObject pointer, but not both.</span>
00717                 <span class="comment">//  Naturally we want to pass in the handle.</span>
00718                 <span class="comment">//</span>
00719 
00720                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, mm, <span class="stringliteral">"MmCreateSection:\n"</span>, 0 );
00721                 <a class="code" href="../../d5/d5/cc_8h.html#a92">DebugTrace2</a>(0, mm, <span class="stringliteral">"    MaximumSize = %08lx, %08lx\n"</span>,
00722                             LocalSizes.<a class="code" href="../../d1/d9/struct__CC__FILE__SIZES.html#o0">AllocationSize</a>.LowPart,
00723                             LocalSizes.<a class="code" href="../../d1/d9/struct__CC__FILE__SIZES.html#o0">AllocationSize</a>.HighPart );
00724                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, mm, <span class="stringliteral">"    FileObject = %08lx\n"</span>, FileObject );
00725 
00726                 SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o22">Status</a> = <a class="code" href="../../d0/d8/creasect_8c.html#a20">MmCreateSection</a>( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o21">Section</a>,
00727                                                           SECTION_MAP_READ
00728                                                             | SECTION_MAP_WRITE
00729                                                             | SECTION_QUERY,
00730                                                           NULL,
00731                                                           &amp;LocalSizes.<a class="code" href="../../d1/d9/struct__CC__FILE__SIZES.html#o0">AllocationSize</a>,
00732                                                           PAGE_READWRITE,
00733                                                           SEC_COMMIT,
00734                                                           NULL,
00735                                                           FileObject );
00736 
00737                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, mm, <span class="stringliteral">"    &lt;Section = %08lx\n"</span>, SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o21">Section</a> );
00738 
00739                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o22">Status</a> )){
00740                     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, 0, <span class="stringliteral">"Error from MmCreateSection = %08lx\n"</span>,
00741                                 SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o22">Status</a> );
00742 
00743                     SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o21">Section</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00744                     <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( <a class="code" href="../../d1/d8/fsrtl_8h.html#a136">FsRtlNormalizeNtstatus</a>( SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o22">Status</a>,
00745                                                            STATUS_UNEXPECTED_MM_CREATE_ERR ));
00746                 }
00747 
00748                 <a class="code" href="../../d6/d0/obcreate_8c.html#a10">ObDeleteCapturedInsertInfo</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o21">Section</a>);
00749 
00750                 <span class="comment">//</span>
00751                 <span class="comment">//  If this is a stream file object, then no user can map it,</span>
00752                 <span class="comment">//  and we should keep the modified page writer out of it.</span>
00753                 <span class="comment">//</span>
00754 
00755                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(((<a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html">PFSRTL_COMMON_FCB_HEADER</a>)FileObject-&gt;FsContext)-&gt;Flags2,
00756                             FSRTL_FLAG2_DO_MODIFIED_WRITE) &amp;&amp;
00757                     (FileObject-&gt;FsContext2 == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
00758 
00759                     BOOLEAN Disabled;
00760 
00761                     Disabled = <a class="code" href="../../d6/d3/modwrite_8c.html#a54">MmDisableModifiedWriteOfSection</a>( FileObject-&gt;SectionObjectPointer );
00762                     <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
00763                     <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, MODIFIED_WRITE_DISABLED);
00764                     <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
00765 
00766                     <span class="comment">//**** ASSERT( Disabled );</span>
00767                 }
00768 
00769                 <span class="comment">//</span>
00770                 <span class="comment">//  Create the Vacb array.</span>
00771                 <span class="comment">//</span>
00772 
00773                 <a class="code" href="../../d5/d3/vacbsup_8c.html#a20">CcCreateVacbArray</a>( SharedCacheMap, LocalSizes.<a class="code" href="../../d1/d9/struct__CC__FILE__SIZES.html#o0">AllocationSize</a> );
00774             }
00775 
00776             <span class="comment">//</span>
00777             <span class="comment">//  If the section already exists, we still have to call MM to</span>
00778             <span class="comment">//  extend, in case it is not large enough.</span>
00779             <span class="comment">//</span>
00780 
00781             <span class="keywordflow">else</span> {
00782 
00783                 <span class="keywordflow">if</span> ( LocalSizes.<a class="code" href="../../d1/d9/struct__CC__FILE__SIZES.html#o0">AllocationSize</a>.QuadPart &gt; SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o5">SectionSize</a>.QuadPart ) {
00784 
00785                     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00786 
00787                     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, mm, <span class="stringliteral">"MmExtendSection:\n"</span>, 0 );
00788                     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, mm, <span class="stringliteral">"    Section = %08lx\n"</span>, SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o21">Section</a> );
00789                     <a class="code" href="../../d5/d5/cc_8h.html#a92">DebugTrace2</a>(0, mm, <span class="stringliteral">"    Size = %08lx, %08lx\n"</span>,
00790                                 LocalSizes.<a class="code" href="../../d1/d9/struct__CC__FILE__SIZES.html#o0">AllocationSize</a>.LowPart,
00791                                 LocalSizes.<a class="code" href="../../d1/d9/struct__CC__FILE__SIZES.html#o0">AllocationSize</a>.HighPart );
00792 
00793                     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d8/d0/extsect_8c.html#a1">MmExtendSection</a>( SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o21">Section</a>,
00794                                               &amp;LocalSizes.<a class="code" href="../../d1/d9/struct__CC__FILE__SIZES.html#o0">AllocationSize</a>,
00795                                               TRUE );
00796 
00797                     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(Status)) {
00798 
00799                         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, 0, <span class="stringliteral">"Error from MmExtendSection, Status = %08lx\n"</span>,
00800                                     Status );
00801 
00802                         <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( <a class="code" href="../../d1/d8/fsrtl_8h.html#a136">FsRtlNormalizeNtstatus</a>( Status,
00803                                                                STATUS_UNEXPECTED_MM_EXTEND_ERR ));
00804                     }
00805                 }
00806 
00807                 <span class="comment">//</span>
00808                 <span class="comment">//  Extend the Vacb array.</span>
00809                 <span class="comment">//</span>
00810 
00811                 <a class="code" href="../../d5/d3/vacbsup_8c.html#a21">CcExtendVacbArray</a>( SharedCacheMap, LocalSizes.<a class="code" href="../../d1/d9/struct__CC__FILE__SIZES.html#o0">AllocationSize</a> );
00812             }
00813 
00814             <span class="comment">//</span>
00815             <span class="comment">//  Now show that we are all done and resume any waiters.</span>
00816             <span class="comment">//</span>
00817 
00818             <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
00819             <a class="code" href="../../d5/d5/cc_8h.html#a61">ClearFlag</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, BEING_CREATED);
00820             WeSetBeingCreated = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00821             <span class="keywordflow">if</span> (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o23">CreateEvent</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00822                 <a class="code" href="../../d2/d8/eventobj_8c.html#a8">KeSetEvent</a>( SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o23">CreateEvent</a>, 0, FALSE );
00823             }
00824             <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
00825         }
00826 
00827         <span class="comment">//</span>
00828         <span class="comment">//  Else if the section is already there, we make sure it is large</span>
00829         <span class="comment">//  enough by calling CcExtendCacheSection.</span>
00830         <span class="comment">//</span>
00831 
00832         <span class="keywordflow">else</span> {
00833 
00834             <span class="comment">//</span>
00835             <span class="comment">//  If the SharedCacheMap is currently being created we have</span>
00836             <span class="comment">//  to optionally create and wait on an event for it.  Note that</span>
00837             <span class="comment">//  the only safe time to delete the event is in</span>
00838             <span class="comment">//  CcUninitializeCacheMap, because we otherwise have no way of</span>
00839             <span class="comment">//  knowing when everyone has reached the KeWaitForSingleObject.</span>
00840             <span class="comment">//</span>
00841 
00842             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, BEING_CREATED)) {
00843 
00844                 <span class="keywordflow">if</span> (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o23">CreateEvent</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00845 
00846                     <span class="comment">//</span>
00847                     <span class="comment">//  If the local event is not being used then we can grab it.</span>
00848                     <span class="comment">//  (Should be quite rare that it is in use.)</span>
00849                     <span class="comment">//</span>
00850 
00851                     SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o23">CreateEvent</a> = InterlockedExchangePointer( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o37">LocalEvent</a>, NULL );
00852                     
00853                     <span class="keywordflow">if</span> (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o23">CreateEvent</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00854 
00855                         SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o23">CreateEvent</a> = (<a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>)<a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( NonPagedPool,
00856                                                                                       <span class="keyword">sizeof</span>(<a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a>),
00857                                                                                       'vEcC' );
00858                     }
00859 
00860                     <span class="keywordflow">if</span> (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o23">CreateEvent</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00861                         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, 0, <span class="stringliteral">"Failed to allocate CreateEvent\n"</span>, 0 );
00862 
00863                         <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
00864                         SharedListOwned = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00865 
00866                         <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>(STATUS_INSUFFICIENT_RESOURCES);
00867                     }
00868 
00869                     <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o23">CreateEvent</a>,
00870                                        NotificationEvent,
00871                                        FALSE );
00872                 }
00873 
00874                 <span class="comment">//</span>
00875                 <span class="comment">//  Increment the OpenCount on the CacheMap.</span>
00876                 <span class="comment">//</span>
00877 
00878                 <a class="code" href="../../d5/d5/cc_8h.html#a68">CcIncrementOpenCount</a>( SharedCacheMap, 'ecnI' );
00879                 MustUninitialize = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00880 
00881                 <span class="comment">//</span>
00882                 <span class="comment">//  Release global resource before waiting</span>
00883                 <span class="comment">//</span>
00884 
00885                 <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
00886                 SharedListOwned = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00887 
00888                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, 0, <span class="stringliteral">"Waiting on CreateEvent\n"</span>, 0 );
00889 
00890                 <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o23">CreateEvent</a>,
00891                                        Executive,
00892                                        KernelMode,
00893                                        FALSE,
00894                                        (PLARGE_INTEGER)NULL);
00895 
00896                 <span class="comment">//</span>
00897                 <span class="comment">//  If the real creator got an error, then we must bomb</span>
00898                 <span class="comment">//  out too.</span>
00899                 <span class="comment">//</span>
00900 
00901                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o22">Status</a>)) {
00902                     <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( <a class="code" href="../../d1/d8/fsrtl_8h.html#a136">FsRtlNormalizeNtstatus</a>( SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o22">Status</a>,
00903                                                            STATUS_UNEXPECTED_MM_CREATE_ERR ));
00904                 }
00905             }
00906             <span class="keywordflow">else</span> {
00907 
00908                 <a class="code" href="../../d4/d6/struct__CACHE__UNINITIALIZE__EVENT.html">PCACHE_UNINITIALIZE_EVENT</a> CUEvent, EventNext;
00909 
00910                 <span class="comment">//</span>
00911                 <span class="comment">//  Increment the OpenCount on the CacheMap.</span>
00912                 <span class="comment">//</span>
00913 
00914                 <a class="code" href="../../d5/d5/cc_8h.html#a68">CcIncrementOpenCount</a>( SharedCacheMap, 'esnI' );
00915                 MustUninitialize = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00916 
00917                 <span class="comment">//</span>
00918                 <span class="comment">//  If there is a process waiting on an uninitialize on this</span>
00919                 <span class="comment">//  cache map to complete, let the thread that is waiting go,</span>
00920                 <span class="comment">//  since the uninitialize is now complete.</span>
00921                 <span class="comment">//</span>
00922                 CUEvent = SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o34">UninitializeEvent</a>;
00923 
00924                 <span class="keywordflow">while</span> (CUEvent != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00925                     EventNext = CUEvent-&gt;<a class="code" href="../../d4/d6/struct__CACHE__UNINITIALIZE__EVENT.html#o0">Next</a>;
00926                     <a class="code" href="../../d2/d8/eventobj_8c.html#a8">KeSetEvent</a>(&amp;CUEvent-&gt;<a class="code" href="../../d4/d6/struct__CACHE__UNINITIALIZE__EVENT.html#o1">Event</a>, 0, FALSE);
00927                     CUEvent = EventNext;
00928                 }
00929 
00930                 SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o34">UninitializeEvent</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00931 
00932                 <span class="comment">//</span>
00933                 <span class="comment">//  Release global resource</span>
00934                 <span class="comment">//</span>
00935 
00936                 <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
00937                 SharedListOwned = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00938             }
00939         }
00940 
00941         {
00942             <a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html">PPRIVATE_CACHE_MAP</a> PrivateCacheMap;
00943 
00944             <span class="comment">//</span>
00945             <span class="comment">//  Now allocate (if local one already in use) and initialize</span>
00946             <span class="comment">//  the Private Cache Map.</span>
00947             <span class="comment">//</span>
00948 
00949             PrivateCacheMap = &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o39">PrivateCacheMap</a>;
00950 
00951             <span class="comment">//</span>
00952             <span class="comment">//  See if we should allocate a PrivateCacheMap while not holding</span>
00953             <span class="comment">//  a spinlock.</span>
00954             <span class="comment">//</span>
00955 
00956             <span class="keywordflow">if</span> (CacheMapToFree != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00957                 <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( CacheMapToFree );
00958                 CacheMapToFree = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00959             }
00960 
00961             <span class="keywordflow">if</span> (PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o0">NodeTypeCode</a> != 0) {
00962                 CacheMapToFree = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( NonPagedPool, <span class="keyword">sizeof</span>(<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html">PRIVATE_CACHE_MAP</a>), 'cPcC' );
00963             }
00964 
00965             <span class="comment">//</span>
00966             <span class="comment">//  Insert the new PrivateCacheMap in the list off the SharedCacheMap.</span>
00967             <span class="comment">//</span>
00968 
00969             <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
00970             SharedListOwned = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00971 
00972             <span class="comment">//</span>
00973             <span class="comment">//  Now make sure there is still no PrivateCacheMap, and if so just get out.</span>
00974             <span class="comment">//</span>
00975 
00976             <span class="keywordflow">if</span> (FileObject-&gt;PrivateCacheMap == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00977 
00978                 <span class="comment">//</span>
00979                 <span class="comment">//  Is the local one already in use?</span>
00980                 <span class="comment">//</span>
00981 
00982                 <span class="keywordflow">if</span> (PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o0">NodeTypeCode</a> != 0) {
00983 
00984                     <span class="comment">//</span>
00985                     <span class="comment">//  Use the one allocated above, if there is one, else go to pool now.</span>
00986                     <span class="comment">//</span>
00987 
00988                     <span class="keywordflow">if</span> (CacheMapToFree == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00989                         CacheMapToFree =
00990                             (<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html">PPRIVATE_CACHE_MAP</a>)<a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( NonPagedPool,
00991                                                                        <span class="keyword">sizeof</span>(<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html">PRIVATE_CACHE_MAP</a>),
00992                                                                        'cPcC' );
00993                     }
00994                     PrivateCacheMap = CacheMapToFree;
00995                     CacheMapToFree = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00996                 }
00997 
00998                 <span class="keywordflow">if</span> (PrivateCacheMap == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00999 
01000                     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, 0, <span class="stringliteral">"Failed to allocate PrivateCacheMap\n"</span>, 0 );
01001 
01002                     <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
01003                     SharedListOwned = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01004 
01005                     <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>(STATUS_INSUFFICIENT_RESOURCES);
01006                 }
01007 
01008                 RtlZeroMemory( PrivateCacheMap, <span class="keyword">sizeof</span>(<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html">PRIVATE_CACHE_MAP</a>) );
01009 
01010                 PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o0">NodeTypeCode</a> = <a class="code" href="../../d5/d5/cc_8h.html#a13">CACHE_NTC_PRIVATE_CACHE_MAP</a>;
01011                 PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o1">NodeByteSize</a> = <span class="keyword">sizeof</span>(<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html">PRIVATE_CACHE_MAP</a>);
01012                 PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o2">FileObject</a> = FileObject;
01013                 PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o10">ReadAheadMask</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1;
01014 
01015                 <span class="comment">//</span>
01016                 <span class="comment">//  Initialize the spin lock.</span>
01017                 <span class="comment">//</span>
01018 
01019                 <a class="code" href="../../d4/d9/ke_8h.html#a354">KeInitializeSpinLock</a>( &amp;PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o9">ReadAheadSpinLock</a> );
01020 
01021                 InsertTailList( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o29">PrivateList</a>, &amp;PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o11">PrivateLinks</a> );
01022 
01023                 FileObject-&gt;PrivateCacheMap = PrivateCacheMap;
01024             
01025             } <span class="keywordflow">else</span> {
01026 
01027                 <span class="comment">//</span>
01028                 <span class="comment">//  We raced with another initializer for the same fileobject and must</span>
01029                 <span class="comment">//  drop our (to this point speculative) opencount.</span>
01030                 <span class="comment">//</span>
01031 
01032                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o2">OpenCount</a> &gt; 1 );
01033                 
01034                 <a class="code" href="../../d5/d5/cc_8h.html#a69">CcDecrementOpenCount</a>( SharedCacheMap, 'rpnI' );
01035                 SharedCacheMap = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01036             }
01037         }  
01038 
01039         MustUninitialize = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01040     try_exit: NOTHING;
01041     }
01042     finally {
01043 
01044         <span class="comment">//</span>
01045         <span class="comment">//  See if we got an error and must uninitialize the SharedCacheMap</span>
01046         <span class="comment">//</span>
01047 
01048         <span class="keywordflow">if</span> (MustUninitialize) {
01049 
01050             <span class="keywordflow">if</span> (!SharedListOwned) {
01051                 <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
01052             }
01053             <span class="keywordflow">if</span> (WeSetBeingCreated) {
01054                 <span class="keywordflow">if</span> (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o23">CreateEvent</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01055                     <a class="code" href="../../d2/d8/eventobj_8c.html#a8">KeSetEvent</a>( SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o23">CreateEvent</a>, 0, FALSE );
01056                 }
01057                 <a class="code" href="../../d5/d5/cc_8h.html#a61">ClearFlag</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, BEING_CREATED);
01058             }
01059 
01060             <span class="comment">//</span>
01061             <span class="comment">//  Now release our open count.</span>
01062             <span class="comment">//</span>
01063 
01064             <a class="code" href="../../d5/d5/cc_8h.html#a69">CcDecrementOpenCount</a>( SharedCacheMap, 'umnI' );
01065 
01066             <span class="keywordflow">if</span> ((SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o2">OpenCount</a> == 0) &amp;&amp;
01067                 !<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, WRITE_QUEUED) &amp;&amp;
01068                 (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o20">DirtyPages</a> == 0)) {
01069 
01070                 <span class="comment">//</span>
01071                 <span class="comment">//  On PinAccess it is safe and necessary to eliminate</span>
01072                 <span class="comment">//  the structure immediately.</span>
01073                 <span class="comment">//</span>
01074 
01075                 <span class="keywordflow">if</span> (PinAccess) {
01076 
01077                     <a class="code" href="../../d5/d8/fssup_8c.html#a11">CcDeleteSharedCacheMap</a>( SharedCacheMap, OldIrql, FALSE );
01078 
01079                 <span class="comment">//</span>
01080                 <span class="comment">//  If it is not PinAccess, we must lazy delete, because</span>
01081                 <span class="comment">//  we could get into a deadlock trying to acquire the</span>
01082                 <span class="comment">//  stream exclusive when we dereference the file object.</span>
01083                 <span class="comment">//</span>
01084 
01085                 } <span class="keywordflow">else</span> {
01086 
01087                     <span class="comment">//</span>
01088                     <span class="comment">//  Move it to the dirty list so the lazy write scan will</span>
01089                     <span class="comment">//  see it.</span>
01090                     <span class="comment">//</span>
01091 
01092                     RemoveEntryList( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a> );
01093                     InsertTailList( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a2">CcDirtySharedCacheMapList</a>.<a class="code" href="../../d1/d3/struct__SHARED__CACHE__MAP__LIST__CURSOR.html#o0">SharedCacheMapLinks</a>,
01094                                     &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a> );
01095 
01096                     <span class="comment">//</span>
01097                     <span class="comment">//  Make sure the Lazy Writer will wake up, because we</span>
01098                     <span class="comment">//  want him to delete this SharedCacheMap.</span>
01099                     <span class="comment">//</span>
01100 
01101                     <a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o6">OtherWork</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01102                     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o5">ScanActive</a>) {
01103                         <a class="code" href="../../d5/d5/cc_8h.html#a185">CcScheduleLazyWriteScan</a>();
01104                     }
01105 
01106                     <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
01107                 }
01108 
01109             } <span class="keywordflow">else</span> {
01110 
01111                 <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
01112             }
01113 
01114             SharedListOwned = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01115 
01116         <span class="comment">//</span>
01117         <span class="comment">//  If we did not create this SharedCacheMap, then there is a</span>
01118         <span class="comment">//  possibility that it is in the dirty list.  Once we are sure</span>
01119         <span class="comment">//  we have the spinlock, just make sure it is in the clean list</span>
01120         <span class="comment">//  if there are no dirty bytes and the open count is nonzero.</span>
01121         <span class="comment">//  (The latter test is almost guaranteed, of course, but we check</span>
01122         <span class="comment">//  it to be safe.)</span>
01123         <span class="comment">//</span>
01124 
01125         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!WeCreated &amp;&amp;
01126                    (SharedCacheMap != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
01127 
01128             <span class="keywordflow">if</span> (!SharedListOwned) {
01129 
01130                 <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
01131                 SharedListOwned = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01132             }
01133 
01134             <span class="keywordflow">if</span> ((SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o20">DirtyPages</a> == 0) &amp;&amp;
01135                 (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o2">OpenCount</a> != 0)) {
01136 
01137                 RemoveEntryList( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a> );
01138                 InsertTailList( &amp;CcCleanSharedCacheMapList,
01139                                 &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a> );
01140             }
01141         }
01142 
01143         <span class="comment">//</span>
01144         <span class="comment">//  Release global resource</span>
01145         <span class="comment">//</span>
01146 
01147         <span class="keywordflow">if</span> (SharedListOwned) {
01148             <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
01149         }
01150 
01151         <span class="keywordflow">if</span> (CacheMapToFree != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01152             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(CacheMapToFree);
01153         }
01154 
01155     }
01156 
01157     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, me, <span class="stringliteral">"CcInitializeCacheMap -&gt; VOID\n"</span>, 0 );
01158 
01159     <span class="keywordflow">return</span>;
01160 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a98" doxytag="cache.h::CcIsThereDirtyData" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTKERNELAPI BOOLEAN CcIsThereDirtyData           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d7/d7/struct__VPB.html">PVPB</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>Vpb</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d9/d4/logsup_8c-source.html#l00362">362</a> of file <a class="el" href="../../d9/d4/logsup_8c-source.html">logsup.c</a>.
<p>
References <a class="el" href="../../d6/d4/cc_8h-source.html#l00064">CcAcquireMasterLock</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00031">CcDirtySharedCacheMapList</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00067">CcReleaseMasterLock</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00509">ClearFlag</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00846">_SHARED_CACHE_MAP::DirtyPages</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00796">_SHARED_CACHE_MAP::FileObject</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00497">FlagOn</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01533">_FILE_OBJECT::Flags</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00832">_SHARED_CACHE_MAP::Flags</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01505">FO_TEMPORARY_FILE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01090">IS_CURSOR</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00505">SetFlag</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00826">_SHARED_CACHE_MAP::SharedCacheMapLinks</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01113">_SHARED_CACHE_MAP_LIST_CURSOR::SharedCacheMapLinks</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01518">_FILE_OBJECT::Vpb</a>, and <a class="el" href="../../d6/d4/cc_8h-source.html#l01051">WRITE_QUEUED</a>.
<p>
<pre class="fragment"><div>00368                    :
00369 
00370     This routine returns <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified Vcb has any unwritten dirty
00371     data in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> cache.
00372 
00373 Arguments:
00374 
00375     Vpb - specifies Vpb to check <span class="keywordflow">for</span>
00376 
00377 Return Value:
00378 
00379     <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> - <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Vpb has no dirty data
00380     <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> - <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Vpb has dirty data
00381 
00382 --*/
00383 
00384 {
00385     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap;
00386     KIRQL OldIrql;
00387     ULONG LoopsWithLockHeld = 0;
00388 
00389     <span class="comment">//</span>
00390     <span class="comment">//  Synchronize with changes to the SharedCacheMap list.</span>
00391     <span class="comment">//</span>
00392 
00393     <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
00394 
00395     SharedCacheMap = CONTAINING_RECORD( <a class="code" href="../../d5/d2/cachedat_8c.html#a2">CcDirtySharedCacheMapList</a>.<a class="code" href="../../d1/d3/struct__SHARED__CACHE__MAP__LIST__CURSOR.html#o0">SharedCacheMapLinks</a>.Flink,
00396                                         <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">SHARED_CACHE_MAP</a>,
00397                                         SharedCacheMapLinks );
00398 
00399     <span class="keywordflow">while</span> (&amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a> != &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a2">CcDirtySharedCacheMapList</a>.<a class="code" href="../../d1/d3/struct__SHARED__CACHE__MAP__LIST__CURSOR.html#o0">SharedCacheMapLinks</a>) {
00400 
00401         <span class="comment">//</span>
00402         <span class="comment">//  Look at this one if the Vpb matches and if there is dirty data.</span>
00403         <span class="comment">//  For what it's worth, don't worry about dirty data in temporary files,</span>
00404         <span class="comment">//  as that should not concern the caller if it wants to dismount.</span>
00405         <span class="comment">//</span>
00406 
00407         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, IS_CURSOR) &amp;&amp;
00408             (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o10">FileObject</a>-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o3">Vpb</a> == Vpb) &amp;&amp;
00409             (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o20">DirtyPages</a> != 0) &amp;&amp;
00410             !<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o10">FileObject</a>-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a>, FO_TEMPORARY_FILE)) {
00411 
00412             <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
00413             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00414         }
00415 
00416         <span class="comment">//</span>
00417         <span class="comment">//  Make sure we occassionally drop the lock.  Set WRITE_QUEUED</span>
00418         <span class="comment">//  to keep the guy from going away, and increment DirtyPages to</span>
00419         <span class="comment">//  keep in in this list.</span>
00420         <span class="comment">//</span>
00421 
00422         <span class="keywordflow">if</span> ((++LoopsWithLockHeld &gt;= 20) &amp;&amp;
00423             !<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, WRITE_QUEUED | IS_CURSOR)) {
00424 
00425             <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>( (<span class="keyword">volatile</span> ULONG) SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, WRITE_QUEUED);
00426             (<span class="keyword">volatile</span> ULONG) SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o20">DirtyPages</a> += 1;
00427             <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
00428             LoopsWithLockHeld = 0;
00429             <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
00430             <a class="code" href="../../d5/d5/cc_8h.html#a61">ClearFlag</a>( (<span class="keyword">volatile</span> ULONG) SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, WRITE_QUEUED);
00431             (<span class="keyword">volatile</span> ULONG) SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o20">DirtyPages</a> -= 1;
00432         }
00433 
00434         <span class="comment">//</span>
00435         <span class="comment">//  Now loop back for the next cache map.</span>
00436         <span class="comment">//</span>
00437 
00438         SharedCacheMap =
00439             CONTAINING_RECORD( SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a>.Flink,
00440                                <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">SHARED_CACHE_MAP</a>,
00441                                SharedCacheMapLinks );
00442     }
00443 
00444     <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
00445 
00446     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00447 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a88" doxytag="cache.h::CcMapData" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTKERNELAPI BOOLEAN CcMapData           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>FileObject</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PLARGE_INTEGER&nbsp;</td>
          <td class="mdname" nowrap> <em>FileOffset</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Length</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN BOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>Wait</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PVOID *&nbsp;</td>
          <td class="mdname" nowrap> <em>Bcb</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PVOID *&nbsp;</td>
          <td class="mdname" nowrap> <em>Buffer</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d3/d8/pinsup_8c-source.html#l00052">52</a> of file <a class="el" href="../../d3/d8/pinsup_8c-source.html">pinsup.c</a>.
<p>
References <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d7/d1/rtqkey_8c-source.html#l00042">Buffer</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01998">CcBcbSpinLock</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00310">CcGetVirtualAddress()</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00176">CcMapDataNoWait</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00178">CcMapDataNoWaitMiss</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00177">CcMapDataWait</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00179">CcMapDataWaitMiss</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00206">CcMissCounter</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l00116">CcPinFileData()</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00160">CcThrowAway</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l00974">CcUnpinFileData()</a>, <a class="el" href="../../d3/d0/mm_8h-source.html#l00221">COMPUTE_PAGES_SPANNED</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02290">DebugTrace</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l00033">me</a>, <a class="el" href="../../d3/d0/mm_8h-source.html#l01053">MmResetPageFaultReadAhead</a>, <a class="el" href="../../d3/d0/mm_8h-source.html#l00983">MmSavePageFaultReadAhead</a>, <a class="el" href="../../d3/d0/mm_8h-source.html#l01018">MmSetPageFaultReadAhead</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00599">PAGE_SIZE</a>, <a class="el" href="../../d2/d8/ps_8h-source.html#l00645">PsGetCurrentThread</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, and <a class="el" href="../../d5/d5/cc_8h.html#a211a171">UNPIN</a>.
<p>
Referenced by <a class="el" href="../../d8/d1/lfs_2cachesup_8c-source.html#l00551">LfsFlushLfcb()</a>, <a class="el" href="../../d8/d1/lfs_2cachesup_8c-source.html#l00084">LfsPinOrMapData()</a>, <a class="el" href="../../d5/d7/dirsup_8c-source.html#l00916">UdfLookupDirEntryPostProcessing()</a>, <a class="el" href="../../d5/d7/dirsup_8c-source.html#l00165">UdfLookupInitialDirEntry()</a>, <a class="el" href="../../d3/d5/allocsup_8c-source.html#l01017">UdfLookupPsnOfExtent()</a>, <a class="el" href="../../d9/d1/udfs_2cachesup_8c-source.html#l00337">UdfMapMetadataView()</a>, and <a class="el" href="../../d0/d7/udfs_2strucsup_8c-source.html#l00477">UdfUpdateVcbPhase0()</a>.
<p>
<pre class="fragment"><div>00063                    :
00064 
00065     This routine attempts to map <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> data in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> cache.
00066     <a class="code" href="../../d2/d1/bench_8h.html#a5">A</a> pointer <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> returned to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> desired data in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> cache.
00067 
00068     If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller does not want to block on <span class="keyword">this</span> call, then
00069     Wait should be supplied as <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>.  If Wait was supplied as <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> and
00070     <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> currently impossible to supply <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> requested data without
00071     blocking, then <span class="keyword">this</span> routine will <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>.  However, <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
00072     data <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> immediately accessible in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> cache and no blocking <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a>
00073     required, <span class="keyword">this</span> routine returns <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> with a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data.
00074 
00075     Note that a call to <span class="keyword">this</span> routine with Wait supplied as <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a>
00076     considerably faster than a call with Wait supplies as <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, because
00077     in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Wait <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> <span class="keywordflow">case</span> we <a class="code" href="../../d3/d0/imm32_8def.html#a1">only</a> have to make sure <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> mapped
00078     in order to <span class="keywordflow">return</span>.
00079 
00080     It <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> illegal to modify data that <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> <a class="code" href="../../d3/d0/imm32_8def.html#a1">only</a> mapped, and can in fact lead
00081     to serious problems.  It <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> impossible to check <span class="keywordflow">for</span> <span class="keyword">this</span> in all cases,
00082     however <a class="code" href="../../d6/d2/cachesub_8c.html#a18">CcSetDirtyPinnedData</a> may implement some Assertions to check <span class="keywordflow">for</span>
00083     <span class="keyword">this</span>.  If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller wishes to modify data that <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> has <a class="code" href="../../d3/d0/imm32_8def.html#a1">only</a> mapped, then
00084     <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> must *first* call <a class="code" href="../../d2/d9/pinsup_8c.html#a3">CcPinMappedData</a>.
00085 
00086     In any <span class="keywordflow">case</span>, <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller MUST subsequently call <a class="code" href="../../d2/d9/pinsup_8c.html#a6">CcUnpinData</a>.
00087     Naturally <span class="keywordflow">if</span> <a class="code" href="../../d2/d9/pinsup_8c.html#a4">CcPinRead</a> or <a class="code" href="../../d2/d9/pinsup_8c.html#a5">CcPreparePinWrite</a> were called multiple
00088     times <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> same data, <a class="code" href="../../d2/d9/pinsup_8c.html#a6">CcUnpinData</a> must be called <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> same number
00089     of times.
00090 
00091     The returned <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> pointer <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> valid until <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> unpinned, at
00092     which point <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> invalid to use <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> pointer further.  This buffer pointer
00093     will remain valid <span class="keywordflow">if</span> <a class="code" href="../../d2/d9/pinsup_8c.html#a3">CcPinMappedData</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> called.
00094 
00095     Note that under some circumstances (like Wait supplied as FALSE or more
00096     than a page is requested), <span class="keyword">this</span> routine may actually pin <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data, however
00097     <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> not necessary, and in fact not correct, <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller to be concerned
00098     about <span class="keyword">this</span>.
00099 
00100 Arguments:
00101 
00102     FileObject - Pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> object <span class="keywordflow">for</span> a <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> which was
00103                  opened with NO_INTERMEDIATE_BUFFERING clear, i.e., <span class="keywordflow">for</span>
00104                  which <a class="code" href="../../d5/d8/fssup_8c.html#a9">CcInitializeCacheMap</a> was called by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> system.
00105 
00106     FileOffset - Byte offset in <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> <span class="keywordflow">for</span> desired data.
00107 
00108     Length - Length of desired data in bytes.
00109 
00110     Wait - <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> <span class="keywordflow">if</span> caller may not block, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> otherwise (see description
00111            above)
00112 
00113     Bcb - On <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> first call <span class="keyword">this</span> returns a pointer to a Bcb
00114           parameter which must be supplied as input on all subsequent
00115           calls, <span class="keywordflow">for</span> <span class="keyword">this</span> buffer
00116 
00117     <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> - Returns pointer to desired data, valid until <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> buffer <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a>
00118              unpinned or freed.  This pointer will remain valid <span class="keywordflow">if</span> <a class="code" href="../../d2/d9/pinsup_8c.html#a3">CcPinMappedData</a>
00119              <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> called.
00120 
00121 Return Value:
00122 
00123     <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> - <span class="keywordflow">if</span> Wait was supplied as <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> and <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data was not delivered
00124 
00125     <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> - <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> being delivered
00126 
00127 --*/
00128 
00129 {
00130     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap;
00131     LARGE_INTEGER BeyondLastByte;
00132     ULONG ReceivedLength;
00133     ULONG SavedState;
00134     <span class="keyword">volatile</span> UCHAR ch;
00135     ULONG PageCount = <a class="code" href="../../d2/d1/mm_8h.html#a9">COMPUTE_PAGES_SPANNED</a>((ULongToPtr(FileOffset-&gt;LowPart)), Length);
00136     <a class="code" href="../../d5/d6/struct__ETHREAD.html">PETHREAD</a> Thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
00137 
00138     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, me, <span class="stringliteral">"CcMapData\n"</span>, 0 );
00139 
00140     <a class="code" href="../../d2/d1/mm_8h.html#a19">MmSavePageFaultReadAhead</a>( Thread, &amp;SavedState );
00141 
00142     <span class="comment">//</span>
00143     <span class="comment">//  Increment performance counters</span>
00144     <span class="comment">//</span>
00145 
00146     <span class="keywordflow">if</span> (Wait) {
00147 
00148         <a class="code" href="../../d5/d2/cachedat_8c.html#a53">CcMapDataWait</a> += 1;
00149 
00150         <span class="comment">//</span>
00151         <span class="comment">//  Initialize the indirect pointer to our miss counter.</span>
00152         <span class="comment">//</span>
00153 
00154         <a class="code" href="../../d5/d2/cachedat_8c.html#a75">CcMissCounter</a> = &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a55">CcMapDataWaitMiss</a>;
00155 
00156     } <span class="keywordflow">else</span> {
00157         <a class="code" href="../../d5/d2/cachedat_8c.html#a52">CcMapDataNoWait</a> += 1;
00158     }
00159 
00160     <span class="comment">//</span>
00161     <span class="comment">//  Get pointer to SharedCacheMap.</span>
00162     <span class="comment">//</span>
00163 
00164     SharedCacheMap = *(<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> *)((PCHAR)FileObject-&gt;SectionObjectPointer
00165                                             + <span class="keyword">sizeof</span>(PVOID));
00166 
00167     <span class="comment">//</span>
00168     <span class="comment">//  Call local routine to Map or Access the file data.  If we cannot map</span>
00169     <span class="comment">//  the data because of a Wait condition, return FALSE.</span>
00170     <span class="comment">//</span>
00171 
00172     <span class="keywordflow">if</span> (Wait) {
00173 
00174         *<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> = <a class="code" href="../../d5/d3/vacbsup_8c.html#a15">CcGetVirtualAddress</a>( SharedCacheMap,
00175                                        *FileOffset,
00176                                        (<a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> *)Bcb,
00177                                        &amp;ReceivedLength );
00178 
00179         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( ReceivedLength &gt;= Length );
00180 
00181     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/cc_8h.html#a175">CcPinFileData</a>( FileObject,
00182                                FileOffset,
00183                                Length,
00184                                TRUE,
00185                                FALSE,
00186                                Wait,
00187                                (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> *)Bcb,
00188                                Buffer,
00189                                &amp;BeyondLastByte )) {
00190 
00191         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, me, <span class="stringliteral">"CcMapData -&gt; FALSE\n"</span>, 0 );
00192 
00193         <a class="code" href="../../d5/d2/cachedat_8c.html#a54">CcMapDataNoWaitMiss</a> += 1;
00194 
00195         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00196 
00197     } <span class="keywordflow">else</span> {
00198 
00199         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( (BeyondLastByte.QuadPart - FileOffset-&gt;QuadPart) &gt;= Length );
00200 
00201 <span class="preprocessor">#if LIST_DBG</span>
00202 <span class="preprocessor"></span>        {
00203             KIRQL OldIrql;
00204             <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> BcbTemp = (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)*Bcb;
00205 
00206             ExAcquireSpinLock( &amp;CcBcbSpinLock, &amp;OldIrql );
00207 
00208             <span class="keywordflow">if</span> (BcbTemp-&gt;CcBcbLinks.Flink == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00209 
00210                 InsertTailList( &amp;CcBcbList, &amp;BcbTemp-&gt;CcBcbLinks );
00211                 CcBcbCount += 1;
00212                 ExReleaseSpinLock( &amp;CcBcbSpinLock, OldIrql );
00213                 SetCallersAddress( BcbTemp );
00214 
00215             } <span class="keywordflow">else</span> {
00216                 ExReleaseSpinLock( &amp;CcBcbSpinLock, OldIrql );
00217             }
00218 
00219         }
00220 <span class="preprocessor">#endif</span>
00221 <span class="preprocessor"></span>
00222     }
00223 
00224     <span class="comment">//</span>
00225     <span class="comment">//  Now let's just sit here and take the miss(es) like a man (and count them).</span>
00226     <span class="comment">//</span>
00227 
00228     <span class="keywordflow">try</span> {
00229 
00230         <span class="comment">//</span>
00231         <span class="comment">//  Loop to touch each page</span>
00232         <span class="comment">//</span>
00233 
00234         BeyondLastByte.LowPart = 0;
00235 
00236         <span class="keywordflow">while</span> (PageCount != 0) {
00237 
00238             <a class="code" href="../../d2/d1/mm_8h.html#a20">MmSetPageFaultReadAhead</a>( Thread, PageCount - 1 );
00239 
00240             ch = *((<span class="keyword">volatile</span> UCHAR *)(*Buffer) + BeyondLastByte.LowPart);
00241 
00242             BeyondLastByte.LowPart += <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
00243             PageCount -= 1;
00244         }
00245 
00246     } finally {
00247 
00248         <a class="code" href="../../d2/d1/mm_8h.html#a21">MmResetPageFaultReadAhead</a>( Thread, SavedState );
00249 
00250         <span class="keywordflow">if</span> (AbnormalTermination() &amp;&amp; (*Bcb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
00251             <a class="code" href="../../d5/d5/cc_8h.html#a176">CcUnpinFileData</a>( (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)*Bcb, TRUE, UNPIN );
00252             *Bcb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00253         }
00254     }
00255 
00256     <a class="code" href="../../d5/d2/cachedat_8c.html#a75">CcMissCounter</a> = &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a43">CcThrowAway</a>;
00257 
00258     <span class="comment">//</span>
00259     <span class="comment">// Increment the pointer as a reminder that it is read only.</span>
00260     <span class="comment">//</span>
00261 
00262     *(PCHAR *)Bcb += 1;
00263 
00264     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, me, <span class="stringliteral">"CcMapData -&gt; TRUE\n"</span>, 0 );
00265 
00266     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00267 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a78" doxytag="cache.h::CcMdlRead" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTKERNELAPI VOID CcMdlRead           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>FileObject</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PLARGE_INTEGER&nbsp;</td>
          <td class="mdname" nowrap> <em>FileOffset</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Length</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT <a class="el" href="../../d6/d7/struct__MDL.html">PMDL</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>MdlChain</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PIO_STATUS_BLOCK&nbsp;</td>
          <td class="mdname" nowrap> <em>IoStatus</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d8/d4/mdlsup_8c-source.html#l00030">30</a> of file <a class="el" href="../../d8/d4/mdlsup_8c-source.html">mdlsup.c</a>.
<p>
References <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00662">_PRIVATE_CACHE_MAP::BeyondLastByte1</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00665">_PRIVATE_CACHE_MAP::BeyondLastByte2</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l05885">CcFreeActiveVacb()</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00862">CcFreeVirtualAddress()</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00310">CcGetVirtualAddress()</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00194">CcMdlReadWait</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00196">CcMdlReadWaitMiss</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00206">CcMissCounter</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l01253">CcScheduleReadAhead()</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00160">CcThrowAway</a>, <a class="el" href="../../d3/d0/mm_8h-source.html#l00221">COMPUTE_PAGES_SPANNED</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02290">DebugTrace</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02292">DebugTrace2</a>, <a class="el" href="../../d1/d3/ex_2alpha_2raisests_8c-source.html#l00157">ExRaiseStatus()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00661">_PRIVATE_CACHE_MAP::FileOffset1</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00664">_PRIVATE_CACHE_MAP::FileOffset2</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00752">_SHARED_CACHE_MAP::FileSize</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00497">FlagOn</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01510">FO_RANDOM_ACCESS</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01577">GetActiveVacb</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l00805">IoAllocateMdl()</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l06744">IoFreeMdl()</a>, <a class="el" href="../../d2/d1/mm_8h.html#a344a168">IoReadAccess</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00624">KernelMode</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l00033">me</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00462">mm</a>, <a class="el" href="../../d6/d5/iosup_8c-source.html#l00238">MmProbeAndLockPages()</a>, <a class="el" href="../../d3/d0/mm_8h-source.html#l01053">MmResetPageFaultReadAhead</a>, <a class="el" href="../../d3/d0/mm_8h-source.html#l00983">MmSavePageFaultReadAhead</a>, <a class="el" href="../../d3/d0/mm_8h-source.html#l01018">MmSetPageFaultReadAhead</a>, <a class="el" href="../../d6/d5/iosup_8c-source.html#l01347">MmUnlockPages()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00809">_SHARED_CACHE_MAP::NeedToZero</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00414">_MDL::Next</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d2/d8/ps_8h-source.html#l00645">PsGetCurrentThread</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00713">_PRIVATE_CACHE_MAP::ReadAheadEnabled</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00677">_PRIVATE_CACHE_MAP::ReadAheadLength</a>, and <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>.
<p>
Referenced by <a class="el" href="../../d4/d0/fastio_8c-source.html#l01064">FsRtlMdlReadDev()</a>, and <a class="el" href="../../d8/d4/udfs_2read_8c-source.html#l00068">UdfCommonRead()</a>.
<p>
<pre class="fragment"><div>00040                    :
00041 
00042     This routine attempts to lock <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> data in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> cache
00043     and <span class="keywordflow">return</span> a description of <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> in an Mdl along with <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> correct
00044     I/O status.  It <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> *not* safe to call <span class="keyword">this</span> routine from Dpc level.
00045 
00046     This routine <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> synchronous, and raises on errors.
00047 
00048     As each call returns, <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> pages described by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Mdl are
00049     locked in memory, but not mapped in system space.  If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller
00050     needs <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> pages mapped in system space, then <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> must map them.
00051 
00052     Note that each call <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> a <span class="stringliteral">"single shot"</span> which should be followed by
00053     a call to <a class="code" href="../../d7/d5/mdlsup_8c.html#a2">CcMdlReadComplete</a>.  To resume an Mdl-based transfer, <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
00054     caller must form one or more subsequent calls to <a class="code" href="../../d7/d5/mdlsup_8c.html#a1">CcMdlRead</a> with
00055     appropriately adjusted parameters.
00056 
00057 Arguments:
00058 
00059     FileObject - Pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> object <span class="keywordflow">for</span> a <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> which was
00060                  opened with NO_INTERMEDIATE_BUFFERING clear, i.e., <span class="keywordflow">for</span>
00061                  which <a class="code" href="../../d5/d8/fssup_8c.html#a9">CcInitializeCacheMap</a> was called by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> system.
00062 
00063     FileOffset - Byte offset in <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> <span class="keywordflow">for</span> desired data.
00064 
00065     Length - Length of desired data in bytes.
00066 
00067     MdlChain - On output <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> returns a pointer to an Mdl chain describing
00068                <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> desired data.  Note that even <span class="keywordflow">if</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> returned,
00069                one or more Mdls may have been allocated, as may be ascertained
00070                by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> IoStatus.Information field (see below).
00071 
00072     IoStatus - Pointer to standard I/O status block to receive <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> status
00073                <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> transfer.  (STATUS_SUCCESS guaranteed <span class="keywordflow">for</span> cache
00074                hits, otherwise <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> actual I/O status <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> returned.)  The
00075                I/O Information Field indicates how many bytes have been
00076                successfully locked down in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Mdl Chain.
00077 
00078 Return Value:
00079 
00080     None
00081 
00082 Raises:
00083 
00084     STATUS_INSUFFICIENT_RESOURCES - If a <a class="code" href="../../d4/d6/regext_8c.html#a17">pool</a> allocation <a class="code" href="../../d8/d0/rtbatcr_8c.html#a1">failure</a> occurs.
00085 
00086 --*/
00087 
00088 {
00089     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap;
00090     <a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html">PPRIVATE_CACHE_MAP</a> PrivateCacheMap;
00091     PVOID CacheBuffer;
00092     LARGE_INTEGER FOffset;
00093     <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> Mdl = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00094     <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> MdlTemp;
00095     <a class="code" href="../../d5/d6/struct__ETHREAD.html">PETHREAD</a> Thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
00096     ULONG SavedState = 0;
00097     ULONG OriginalLength = Length;
00098     ULONG Information = 0;
00099     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> Vacb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00100     ULONG SavedMissCounter = 0;
00101 
00102     KIRQL OldIrql;
00103     ULONG ActivePage;
00104     ULONG PageIsDirty;
00105     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> ActiveVacb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00106 
00107     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, me, <span class="stringliteral">"CcMdlRead\n"</span>, 0 );
00108     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, me, <span class="stringliteral">"    FileObject = %08lx\n"</span>, FileObject );
00109     <a class="code" href="../../d5/d5/cc_8h.html#a92">DebugTrace2</a>(0, me, <span class="stringliteral">"    FileOffset = %08lx, %08lx\n"</span>, FileOffset-&gt;LowPart,
00110                                                           FileOffset-&gt;HighPart );
00111     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, me, <span class="stringliteral">"    Length = %08lx\n"</span>, Length );
00112 
00113     <span class="comment">//</span>
00114     <span class="comment">//  Save the current readahead hints.</span>
00115     <span class="comment">//</span>
00116 
00117     <a class="code" href="../../d2/d1/mm_8h.html#a19">MmSavePageFaultReadAhead</a>( Thread, &amp;SavedState );
00118 
00119     <span class="comment">//</span>
00120     <span class="comment">//  Get pointer to SharedCacheMap.</span>
00121     <span class="comment">//</span>
00122 
00123     SharedCacheMap = FileObject-&gt;SectionObjectPointer-&gt;SharedCacheMap;
00124     PrivateCacheMap = FileObject-&gt;PrivateCacheMap;
00125 
00126     <span class="comment">//</span>
00127     <span class="comment">//  See if we have an active Vacb, that we need to free.</span>
00128     <span class="comment">//</span>
00129 
00130     <a class="code" href="../../d5/d5/cc_8h.html#a82">GetActiveVacb</a>( SharedCacheMap, OldIrql, ActiveVacb, ActivePage, PageIsDirty );
00131 
00132     <span class="comment">//</span>
00133     <span class="comment">//  If there is an end of a page to be zeroed, then free that page now,</span>
00134     <span class="comment">//  so we don't send Greg the uninitialized data...</span>
00135     <span class="comment">//</span>
00136 
00137     <span class="keywordflow">if</span> ((ActiveVacb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) || (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o13">NeedToZero</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
00138 
00139         <a class="code" href="../../d5/d5/cc_8h.html#a182">CcFreeActiveVacb</a>( SharedCacheMap, ActiveVacb, ActivePage, PageIsDirty );
00140     }
00141 
00142     <span class="comment">//</span>
00143     <span class="comment">//  If read ahead is enabled, then do the read ahead here so it</span>
00144     <span class="comment">//  overlaps with the copy (otherwise we will do it below).</span>
00145     <span class="comment">//  Note that we are assuming that we will not get ahead of our</span>
00146     <span class="comment">//  current transfer - if read ahead is working it should either</span>
00147     <span class="comment">//  already be in memory or else underway.</span>
00148     <span class="comment">//</span>
00149 
00150     <span class="keywordflow">if</span> (PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o13">ReadAheadEnabled</a> &amp;&amp; (PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o8">ReadAheadLength</a>[1] == 0)) {
00151         <a class="code" href="../../d4/d2/cache_8h.html#a84">CcScheduleReadAhead</a>( FileObject, FileOffset, Length );
00152     }
00153 
00154     <span class="comment">//</span>
00155     <span class="comment">//  Increment performance counters</span>
00156     <span class="comment">//</span>
00157 
00158     <a class="code" href="../../d5/d2/cachedat_8c.html#a66">CcMdlReadWait</a> += 1;
00159 
00160     <span class="comment">//</span>
00161     <span class="comment">//  This is not an exact solution, but when IoPageRead gets a miss,</span>
00162     <span class="comment">//  it cannot tell whether it was CcCopyRead or CcMdlRead, but since</span>
00163     <span class="comment">//  the miss should occur very soon, by loading the pointer here</span>
00164     <span class="comment">//  probably the right counter will get incremented, and in any case,</span>
00165     <span class="comment">//  we hope the errrors average out!</span>
00166     <span class="comment">//</span>
00167 
00168     <a class="code" href="../../d5/d2/cachedat_8c.html#a75">CcMissCounter</a> = &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a68">CcMdlReadWaitMiss</a>;
00169 
00170     FOffset = *FileOffset;
00171 
00172     <span class="comment">//</span>
00173     <span class="comment">//  Check for read past file size, the caller must filter this case out.</span>
00174     <span class="comment">//</span>
00175 
00176     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( ( FOffset.QuadPart + (LONGLONG)Length ) &lt;= SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o3">FileSize</a>.QuadPart );
00177 
00178     <span class="comment">//</span>
00179     <span class="comment">//  Put try-finally around the loop to deal with any exceptions</span>
00180     <span class="comment">//</span>
00181 
00182     <span class="keywordflow">try</span> {
00183 
00184         <span class="comment">//</span>
00185         <span class="comment">//  Not all of the transfer will come back at once, so we have to loop</span>
00186         <span class="comment">//  until the entire transfer is complete.</span>
00187         <span class="comment">//</span>
00188 
00189         <span class="keywordflow">while</span> (Length != 0) {
00190 
00191             ULONG ReceivedLength;
00192             LARGE_INTEGER BeyondLastByte;
00193 
00194             <span class="comment">//</span>
00195             <span class="comment">//  Map the data and read it in (if necessary) with the</span>
00196             <span class="comment">//  MmProbeAndLockPages call below.</span>
00197             <span class="comment">//</span>
00198 
00199             CacheBuffer = <a class="code" href="../../d5/d3/vacbsup_8c.html#a15">CcGetVirtualAddress</a>( SharedCacheMap,
00200                                                FOffset,
00201                                                &amp;Vacb,
00202                                                &amp;ReceivedLength );
00203 
00204             <span class="keywordflow">if</span> (ReceivedLength &gt; Length) {
00205                 ReceivedLength = Length;
00206             }
00207 
00208             BeyondLastByte.QuadPart = FOffset.QuadPart + (LONGLONG)ReceivedLength;
00209 
00210             <span class="comment">//</span>
00211             <span class="comment">//  Now attempt to allocate an Mdl to describe the mapped data.</span>
00212             <span class="comment">//</span>
00213 
00214             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, mm, <span class="stringliteral">"IoAllocateMdl:\n"</span>, 0 );
00215             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, mm, <span class="stringliteral">"    BaseAddress = %08lx\n"</span>, CacheBuffer );
00216             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, mm, <span class="stringliteral">"    Length = %08lx\n"</span>, ReceivedLength );
00217 
00218             Mdl = <a class="code" href="../../d4/d6/iosubs_8c.html#a19">IoAllocateMdl</a>( CacheBuffer,
00219                                  ReceivedLength,
00220                                  FALSE,
00221                                  FALSE,
00222                                  NULL );
00223 
00224             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, mm, <span class="stringliteral">"    &lt;Mdl = %08lx\n"</span>, Mdl );
00225 
00226             <span class="keywordflow">if</span> (Mdl == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00227                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, 0, <span class="stringliteral">"Failed to allocate Mdl\n"</span>, 0 );
00228 
00229                 <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INSUFFICIENT_RESOURCES );
00230             }
00231 
00232             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, mm, <span class="stringliteral">"MmProbeAndLockPages:\n"</span>, 0 );
00233             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, mm, <span class="stringliteral">"    Mdl = %08lx\n"</span>, Mdl );
00234 
00235             <span class="comment">//</span>
00236             <span class="comment">//  Set to see if the miss counter changes in order to</span>
00237             <span class="comment">//  detect when we should turn on read ahead.</span>
00238             <span class="comment">//</span>
00239 
00240             SavedMissCounter += <a class="code" href="../../d5/d2/cachedat_8c.html#a68">CcMdlReadWaitMiss</a>;
00241 
00242             <a class="code" href="../../d2/d1/mm_8h.html#a20">MmSetPageFaultReadAhead</a>( Thread, <a class="code" href="../../d2/d1/mm_8h.html#a9">COMPUTE_PAGES_SPANNED</a>( CacheBuffer, ReceivedLength ) - 1);
00243             <a class="code" href="../../d5/d6/iosup_8c.html#a41">MmProbeAndLockPages</a>( Mdl, KernelMode, IoReadAccess );
00244 
00245             SavedMissCounter -= <a class="code" href="../../d5/d2/cachedat_8c.html#a68">CcMdlReadWaitMiss</a>;
00246 
00247             <span class="comment">//</span>
00248             <span class="comment">//  Unmap the data now, now that the pages are locked down.</span>
00249             <span class="comment">//</span>
00250 
00251             <a class="code" href="../../d5/d3/vacbsup_8c.html#a16">CcFreeVirtualAddress</a>( Vacb );
00252             Vacb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00253 
00254             <span class="comment">//</span>
00255             <span class="comment">//  Now link the Mdl into the caller's chain</span>
00256             <span class="comment">//</span>
00257 
00258             <span class="keywordflow">if</span> ( *MdlChain == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
00259                 *MdlChain = Mdl;
00260             } <span class="keywordflow">else</span> {
00261                 MdlTemp = CONTAINING_RECORD( *MdlChain, <a class="code" href="../../d6/d7/struct__MDL.html">MDL</a>, Next );
00262                 <span class="keywordflow">while</span> (MdlTemp-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o0">Next</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00263                     MdlTemp = MdlTemp-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o0">Next</a>;
00264                 }
00265                 MdlTemp-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o0">Next</a> = Mdl;
00266             }
00267             Mdl = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00268 
00269             <span class="comment">//</span>
00270             <span class="comment">//  Assume we did not get all the data we wanted, and set FOffset</span>
00271             <span class="comment">//  to the end of the returned data.</span>
00272             <span class="comment">//</span>
00273 
00274             FOffset = BeyondLastByte;
00275 
00276             <span class="comment">//</span>
00277             <span class="comment">//  Update number of bytes transferred.</span>
00278             <span class="comment">//</span>
00279 
00280             Information += ReceivedLength;
00281 
00282             <span class="comment">//</span>
00283             <span class="comment">//  Calculate length left to transfer.</span>
00284             <span class="comment">//</span>
00285 
00286             Length -= ReceivedLength;
00287         }
00288     }
00289     finally {
00290 
00291         <a class="code" href="../../d5/d2/cachedat_8c.html#a75">CcMissCounter</a> = &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a43">CcThrowAway</a>;
00292 
00293         <span class="comment">//</span>
00294         <span class="comment">//  Restore the readahead hints.</span>
00295         <span class="comment">//</span>
00296 
00297         <a class="code" href="../../d2/d1/mm_8h.html#a21">MmResetPageFaultReadAhead</a>( Thread, SavedState );
00298 
00299         <span class="keywordflow">if</span> (AbnormalTermination()) {
00300 
00301             <span class="comment">//</span>
00302             <span class="comment">//  We may have failed to allocate an Mdl while still having</span>
00303             <span class="comment">//  data mapped.</span>
00304             <span class="comment">//</span>
00305 
00306             <span class="keywordflow">if</span> (Vacb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00307                 <a class="code" href="../../d5/d3/vacbsup_8c.html#a16">CcFreeVirtualAddress</a>( Vacb );
00308             }
00309 
00310             <span class="keywordflow">if</span> (Mdl != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00311                 <a class="code" href="../../d4/d6/iosubs_8c.html#a65">IoFreeMdl</a>( Mdl );
00312             }
00313 
00314             <span class="comment">//</span>
00315             <span class="comment">//  Otherwise loop to deallocate the Mdls</span>
00316             <span class="comment">//</span>
00317 
00318             <span class="keywordflow">while</span> (*MdlChain != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00319                 MdlTemp = (*MdlChain)-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o0">Next</a>;
00320 
00321                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, mm, <span class="stringliteral">"MmUnlockPages/IoFreeMdl:\n"</span>, 0 );
00322                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, mm, <span class="stringliteral">"    Mdl = %08lx\n"</span>, *MdlChain );
00323 
00324                 <a class="code" href="../../d5/d6/iosup_8c.html#a45">MmUnlockPages</a>( *MdlChain );
00325                 <a class="code" href="../../d4/d6/iosubs_8c.html#a65">IoFreeMdl</a>( *MdlChain );
00326 
00327                 *MdlChain = MdlTemp;
00328             }
00329 
00330             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, me, <span class="stringliteral">"CcMdlRead -&gt; Unwinding\n"</span>, 0 );
00331 
00332         }
00333         <span class="keywordflow">else</span> {
00334 
00335             <span class="comment">//</span>
00336             <span class="comment">//  Now enable read ahead if it looks like we got any misses, and do</span>
00337             <span class="comment">//  the first one.</span>
00338             <span class="comment">//</span>
00339 
00340             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( FileObject-&gt;Flags, FO_RANDOM_ACCESS ) &amp;&amp;
00341                 !PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o13">ReadAheadEnabled</a> &amp;&amp;
00342                 (SavedMissCounter != 0)) {
00343 
00344                 PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o13">ReadAheadEnabled</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00345                 <a class="code" href="../../d4/d2/cache_8h.html#a84">CcScheduleReadAhead</a>( FileObject, FileOffset, OriginalLength );
00346             }
00347 
00348             <span class="comment">//</span>
00349             <span class="comment">//  Now that we have described our desired read ahead, let's</span>
00350             <span class="comment">//  shift the read history down.</span>
00351             <span class="comment">//</span>
00352 
00353             PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o3">FileOffset1</a> = PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o5">FileOffset2</a>;
00354             PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o4">BeyondLastByte1</a> = PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o6">BeyondLastByte2</a>;
00355             PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o5">FileOffset2</a> = *FileOffset;
00356             PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o6">BeyondLastByte2</a>.QuadPart =
00357                                 FileOffset-&gt;QuadPart + (LONGLONG)OriginalLength;
00358 
00359             IoStatus-&gt;Status = STATUS_SUCCESS;
00360             IoStatus-&gt;Information = Information;
00361         }
00362     }
00363 
00364 
00365     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, me, <span class="stringliteral">"    &lt;MdlChain = %08lx\n"</span>, *MdlChain );
00366     <a class="code" href="../../d5/d5/cc_8h.html#a92">DebugTrace2</a>(0, me, <span class="stringliteral">"    &lt;IoStatus = %08lx, %08lx\n"</span>, IoStatus-&gt;Status,
00367                                                          IoStatus-&gt;Information );
00368     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, me, <span class="stringliteral">"CcMdlRead -&gt; VOID\n"</span>, 0 );
00369 
00370     <span class="keywordflow">return</span>;
00371 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a79" doxytag="cache.h::CcMdlReadComplete" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTKERNELAPI VOID CcMdlReadComplete           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>FileObject</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d6/d7/struct__MDL.html">PMDL</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>MdlChain</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d8/d4/mdlsup_8c-source.html#l00381">381</a> of file <a class="el" href="../../d8/d4/mdlsup_8c-source.html">mdlsup.c</a>.
<p>
References <a class="el" href="../../d8/d4/mdlsup_8c-source.html#l00406">CcMdlReadComplete2()</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01179">_DEVICE_OBJECT::DriverObject</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01403">_DRIVER_OBJECT::FastIoDispatch</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l07247">IoGetRelatedDeviceObject()</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l00959">_FAST_IO_DISPATCH::MdlReadComplete</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, and <a class="el" href="../../d1/d4/io_8h-source.html#l00942">_FAST_IO_DISPATCH::SizeOfFastIoDispatch</a>.
<p>
Referenced by <a class="el" href="../../d9/d1/udfs_2cachesup_8c-source.html#l00285">UdfCompleteMdl()</a>.
<p>
<pre class="fragment"><div>00386 {
00387     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject;
00388     <a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html">PFAST_IO_DISPATCH</a> FastIoDispatch;
00389 
00390     DeviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a76">IoGetRelatedDeviceObject</a>( FileObject );
00391     FastIoDispatch = DeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o3">DriverObject</a>-&gt;<a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html#o10">FastIoDispatch</a>;
00392 
00393     <span class="keywordflow">if</span> ((FastIoDispatch != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
00394         (FastIoDispatch-&gt;<a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html#o0">SizeOfFastIoDispatch</a> &gt; FIELD_OFFSET(<a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html">FAST_IO_DISPATCH</a>, MdlWriteComplete)) &amp;&amp;
00395         (FastIoDispatch-&gt;<a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html#o17">MdlReadComplete</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
00396         FastIoDispatch-&gt;<a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html#o17">MdlReadComplete</a>( FileObject, MdlChain, DeviceObject )) {
00397 
00398         NOTHING;
00399 
00400     } <span class="keywordflow">else</span> {
00401         <a class="code" href="../../d4/d2/cache_8h.html#a80">CcMdlReadComplete2</a>( FileObject, MdlChain );
00402     }
00403 }
</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a80" doxytag="cache.h::CcMdlReadComplete2" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTKERNELAPI VOID CcMdlReadComplete2           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>FileObject</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d6/d7/struct__MDL.html">PMDL</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>MdlChain</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d8/d4/mdlsup_8c-source.html#l00406">406</a> of file <a class="el" href="../../d8/d4/mdlsup_8c-source.html">mdlsup.c</a>.
<p>
References <a class="el" href="../../d6/d4/cc_8h-source.html#l02290">DebugTrace</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l06744">IoFreeMdl()</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l00033">me</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00462">mm</a>, <a class="el" href="../../d6/d5/iosup_8c-source.html#l01347">MmUnlockPages()</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00414">_MDL::Next</a>, and <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>.
<p>
Referenced by <a class="el" href="../../d8/d4/mdlsup_8c-source.html#l00381">CcMdlReadComplete()</a>, and <a class="el" href="../../d4/d0/fastio_8c-source.html#l01438">FsRtlMdlReadCompleteDev()</a>.
<p>
<pre class="fragment"><div>00413                    :
00414 
00415     This routine must be called at IPL0 after a call to <a class="code" href="../../d7/d5/mdlsup_8c.html#a1">CcMdlRead</a>.  The
00416     caller must simply supply <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> address of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> MdlChain returned in
00417     <a class="code" href="../../d7/d5/mdlsup_8c.html#a1">CcMdlRead</a>.
00418 
00419     This call does <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> following:
00420 
00421         Deletes <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> MdlChain
00422 
00423 Arguments:
00424 
00425     FileObject - Pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> object <span class="keywordflow">for</span> a <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> which was
00426                  opened with NO_INTERMEDIATE_BUFFERING clear, i.e., <span class="keywordflow">for</span>
00427                  which <a class="code" href="../../d5/d8/fssup_8c.html#a9">CcInitializeCacheMap</a> was called by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> system.
00428 
00429     MdlChain - same as returned from corresponding call to <a class="code" href="../../d7/d5/mdlsup_8c.html#a1">CcMdlRead</a>.
00430 
00431 Return Value:
00432 
00433     None.
00434 --*/
00435 
00436 {
00437     <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> MdlNext;
00438 
00439     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, me, <span class="stringliteral">"CcMdlReadComplete\n"</span>, 0 );
00440     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, me, <span class="stringliteral">"    FileObject = %08lx\n"</span>, FileObject );
00441     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, me, <span class="stringliteral">"    MdlChain = %08lx\n"</span>, MdlChain );
00442 
00443     <span class="comment">//</span>
00444     <span class="comment">//  Deallocate the Mdls</span>
00445     <span class="comment">//</span>
00446 
00447     <span class="keywordflow">while</span> (MdlChain != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00448 
00449         MdlNext = MdlChain-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o0">Next</a>;
00450 
00451         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, mm, <span class="stringliteral">"MmUnlockPages/IoFreeMdl:\n"</span>, 0 );
00452         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, mm, <span class="stringliteral">"    Mdl = %08lx\n"</span>, MdlChain );
00453 
00454         <a class="code" href="../../d5/d6/iosup_8c.html#a45">MmUnlockPages</a>( MdlChain );
00455 
00456         <a class="code" href="../../d4/d6/iosubs_8c.html#a65">IoFreeMdl</a>( MdlChain );
00457 
00458         MdlChain = MdlNext;
00459     }
00460 
00461     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, me, <span class="stringliteral">"CcMdlReadComplete -&gt; VOID\n"</span>, 0 );
00462 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a82" doxytag="cache.h::CcMdlWriteComplete" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTKERNELAPI VOID CcMdlWriteComplete           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>FileObject</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PLARGE_INTEGER&nbsp;</td>
          <td class="mdname" nowrap> <em>FileOffset</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d6/d7/struct__MDL.html">PMDL</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>MdlChain</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d8/d4/mdlsup_8c-source.html#l00812">812</a> of file <a class="el" href="../../d8/d4/mdlsup_8c-source.html">mdlsup.c</a>.
<p>
References <a class="el" href="../../d8/d4/mdlsup_8c-source.html#l00838">CcMdlWriteComplete2()</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01179">_DEVICE_OBJECT::DriverObject</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01403">_DRIVER_OBJECT::FastIoDispatch</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l07247">IoGetRelatedDeviceObject()</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l00961">_FAST_IO_DISPATCH::MdlWriteComplete</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, and <a class="el" href="../../d1/d4/io_8h-source.html#l00942">_FAST_IO_DISPATCH::SizeOfFastIoDispatch</a>.
<p>
<pre class="fragment"><div>00818 {
00819     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject;
00820     <a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html">PFAST_IO_DISPATCH</a> FastIoDispatch;
00821 
00822     DeviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a76">IoGetRelatedDeviceObject</a>( FileObject );
00823     FastIoDispatch = DeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o3">DriverObject</a>-&gt;<a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html#o10">FastIoDispatch</a>;
00824 
00825     <span class="keywordflow">if</span> ((FastIoDispatch != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
00826         (FastIoDispatch-&gt;<a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html#o0">SizeOfFastIoDispatch</a> &gt; FIELD_OFFSET(<a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html">FAST_IO_DISPATCH</a>, MdlWriteComplete)) &amp;&amp;
00827         (FastIoDispatch-&gt;<a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html#o19">MdlWriteComplete</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
00828         FastIoDispatch-&gt;<a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html#o19">MdlWriteComplete</a>( FileObject, FileOffset, MdlChain, DeviceObject )) {
00829 
00830         NOTHING;
00831 
00832     } <span class="keywordflow">else</span> {
00833         <a class="code" href="../../d4/d2/cache_8h.html#a83">CcMdlWriteComplete2</a>( FileObject, FileOffset, MdlChain );
00834     }
00835 }
</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a83" doxytag="cache.h::CcMdlWriteComplete2" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTKERNELAPI VOID CcMdlWriteComplete2           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>FileObject</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PLARGE_INTEGER&nbsp;</td>
          <td class="mdname" nowrap> <em>FileOffset</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d6/d7/struct__MDL.html">PMDL</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>MdlChain</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d8/d4/mdlsup_8c-source.html#l00838">838</a> of file <a class="el" href="../../d8/d4/mdlsup_8c-source.html">mdlsup.c</a>.
<p>
References <a class="el" href="../../d6/d4/cc_8h-source.html#l00064">CcAcquireMasterLock</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01010">CcDecrementOpenCount</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00031">CcDirtySharedCacheMapList</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00067">CcReleaseMasterLock</a>, <a class="el" href="../../d6/d0/lazyrite_8c-source.html#l00049">CcScheduleLazyWriteScan()</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l02242">CcSetDirtyInMask()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02290">DebugTrace</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00846">_SHARED_CACHE_MAP::DirtyPages</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00497">FlagOn</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00832">_SHARED_CACHE_MAP::Flags</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01494">FO_WRITE_THROUGH</a>, <a class="el" href="../../d8/d2/fsrtl_2filter_8c-source.html#l00049">FsRtlNormalizeNtstatus()</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l06744">IoFreeMdl()</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00129">LazyWriter</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l00033">me</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00462">mm</a>, <a class="el" href="../../d7/d4/flushsec_8c-source.html#l00668">MmFlushSection()</a>, <a class="el" href="../../d6/d5/iosup_8c-source.html#l01347">MmUnlockPages()</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00414">_MDL::Next</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00740">_SHARED_CACHE_MAP::OpenCount</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01471">_LAZY_WRITER::OtherWork</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01464">_LAZY_WRITER::ScanActive</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01113">_SHARED_CACHE_MAP_LIST_CURSOR::SharedCacheMapLinks</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00826">_SHARED_CACHE_MAP::SharedCacheMapLinks</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, and <a class="el" href="../../d6/d4/cc_8h-source.html#l01051">WRITE_QUEUED</a>.
<p>
Referenced by <a class="el" href="../../d8/d4/mdlsup_8c-source.html#l00812">CcMdlWriteComplete()</a>, and <a class="el" href="../../d4/d0/fastio_8c-source.html#l02020">FsRtlMdlWriteCompleteDev()</a>.
<p>
<pre class="fragment"><div>00846                    :
00847 
00848     This routine must be called at IPL0 after a call to <a class="code" href="../../d7/d5/mdlsup_8c.html#a4">CcPrepareMdlWrite</a>.
00849     The caller supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> ActualLength of data that <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> actually wrote
00850     into <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> buffer, which may be less than or equal to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Length specified
00851     in <a class="code" href="../../d7/d5/mdlsup_8c.html#a4">CcPrepareMdlWrite</a>.
00852 
00853     This call does <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> following:
00854 
00855         Makes sure <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data up to ActualLength eventually gets written.
00856         If WriteThrough <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data will not be written immediately.
00857         If WriteThrough <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, then <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> written synchronously.
00858 
00859         Unmaps <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> pages (<span class="keywordflow">if</span> mapped), unlocks them and deletes <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> MdlChain
00860 
00861 Arguments:
00862 
00863     FileObject - Pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> object <span class="keywordflow">for</span> a <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> which was
00864                  opened with NO_INTERMEDIATE_BUFFERING clear, i.e., <span class="keywordflow">for</span>
00865                  which <a class="code" href="../../d5/d8/fssup_8c.html#a9">CcInitializeCacheMap</a> was called by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> system.
00866 
00867     FileOffset - Original <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> offset read above.
00868 
00869     MdlChain - same as returned from corresponding call to <a class="code" href="../../d7/d5/mdlsup_8c.html#a4">CcPrepareMdlWrite</a>.
00870 
00871 Return Value:
00872 
00873     None
00874 
00875 --*/
00876 
00877 {
00878     <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> MdlNext;
00879     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap;
00880     LARGE_INTEGER FOffset;
00881     IO_STATUS_BLOCK IoStatus;
00882     KIRQL OldIrql;
00883     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> StatusToRaise = STATUS_SUCCESS;
00884 
00885     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, me, <span class="stringliteral">"CcMdlWriteComplete\n"</span>, 0 );
00886     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, me, <span class="stringliteral">"    FileObject = %08lx\n"</span>, FileObject );
00887     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, me, <span class="stringliteral">"    MdlChain = %08lx\n"</span>, MdlChain );
00888 
00889     SharedCacheMap = FileObject-&gt;SectionObjectPointer-&gt;SharedCacheMap;
00890 
00891     <span class="comment">//</span>
00892     <span class="comment">//  Deallocate the Mdls</span>
00893     <span class="comment">//</span>
00894 
00895     FOffset.QuadPart = *(LONGLONG UNALIGNED *)FileOffset;
00896     <span class="keywordflow">while</span> (MdlChain != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00897 
00898         MdlNext = MdlChain-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o0">Next</a>;
00899 
00900         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, mm, <span class="stringliteral">"MmUnlockPages/IoFreeMdl:\n"</span>, 0 );
00901         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, mm, <span class="stringliteral">"    Mdl = %08lx\n"</span>, MdlChain );
00902 
00903         <span class="comment">//</span>
00904         <span class="comment">//  Now clear the dirty bits in the Pte and set them in the</span>
00905         <span class="comment">//  Pfn.</span>
00906         <span class="comment">//</span>
00907 
00908         <a class="code" href="../../d5/d6/iosup_8c.html#a45">MmUnlockPages</a>( MdlChain );
00909 
00910         <span class="comment">//</span>
00911         <span class="comment">//  Extract the File Offset for this part of the transfer.</span>
00912         <span class="comment">//</span>
00913 
00914         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(FileObject-&gt;Flags, FO_WRITE_THROUGH)) {
00915 
00916             <a class="code" href="../../d6/d5/flushsec_8c.html#a8">MmFlushSection</a> ( FileObject-&gt;SectionObjectPointer,
00917                              &amp;FOffset,
00918                              MdlChain-&gt;ByteCount,
00919                              &amp;IoStatus,
00920                              TRUE );
00921 
00922             <span class="comment">//</span>
00923             <span class="comment">//  If we got an I/O error, remember it.</span>
00924             <span class="comment">//</span>
00925 
00926             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(IoStatus.Status)) {
00927                 StatusToRaise = IoStatus.Status;
00928             }
00929 
00930         } <span class="keywordflow">else</span> {
00931 
00932             <span class="comment">//</span>
00933             <span class="comment">//  Ignore the only exception (allocation error), and console</span>
00934             <span class="comment">//  ourselves for having tried.</span>
00935             <span class="comment">//</span>
00936 
00937             <a class="code" href="../../d5/d5/cc_8h.html#a179">CcSetDirtyInMask</a>( SharedCacheMap, &amp;FOffset, MdlChain-&gt;ByteCount );
00938         }
00939 
00940         FOffset.QuadPart = FOffset.QuadPart + (LONGLONG)(MdlChain-&gt;ByteCount);
00941 
00942         <a class="code" href="../../d4/d6/iosubs_8c.html#a65">IoFreeMdl</a>( MdlChain );
00943 
00944         MdlChain = MdlNext;
00945     }
00946 
00947     <span class="comment">//</span>
00948     <span class="comment">//  Now release our open count.</span>
00949     <span class="comment">//</span>
00950 
00951     <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
00952 
00953     <a class="code" href="../../d5/d5/cc_8h.html#a69">CcDecrementOpenCount</a>( SharedCacheMap, 'ldmC' );
00954 
00955     <span class="keywordflow">if</span> ((SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o2">OpenCount</a> == 0) &amp;&amp;
00956         !<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, WRITE_QUEUED) &amp;&amp;
00957         (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o20">DirtyPages</a> == 0)) {
00958 
00959         <span class="comment">//</span>
00960         <span class="comment">//  Move to the dirty list.</span>
00961         <span class="comment">//</span>
00962 
00963         RemoveEntryList( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a> );
00964         InsertTailList( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a2">CcDirtySharedCacheMapList</a>.<a class="code" href="../../d1/d3/struct__SHARED__CACHE__MAP__LIST__CURSOR.html#o0">SharedCacheMapLinks</a>,
00965                         &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a> );
00966 
00967         <span class="comment">//</span>
00968         <span class="comment">//  Make sure the Lazy Writer will wake up, because we</span>
00969         <span class="comment">//  want him to delete this SharedCacheMap.</span>
00970         <span class="comment">//</span>
00971 
00972         <a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o6">OtherWork</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00973         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o5">ScanActive</a>) {
00974             <a class="code" href="../../d5/d5/cc_8h.html#a185">CcScheduleLazyWriteScan</a>();
00975         }
00976     }
00977 
00978     <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
00979 
00980     <span class="comment">//</span>
00981     <span class="comment">//  If we got an I/O error, raise it now.</span>
00982     <span class="comment">//</span>
00983 
00984     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(StatusToRaise)) {
00985         <a class="code" href="../../d1/d8/fsrtl_8h.html#a136">FsRtlNormalizeNtstatus</a>( StatusToRaise,
00986                                 STATUS_UNEXPECTED_IO_ERROR );
00987     }
00988 
00989     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, me, <span class="stringliteral">"CcMdlWriteComplete -&gt; TRUE\n"</span>, 0 );
00990 
00991     <span class="keywordflow">return</span>;
00992 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a89" doxytag="cache.h::CcPinMappedData" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTKERNELAPI BOOLEAN CcPinMappedData           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>FileObject</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PLARGE_INTEGER&nbsp;</td>
          <td class="mdname" nowrap> <em>FileOffset</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Length</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Flags</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN OUT PVOID *&nbsp;</td>
          <td class="mdname" nowrap> <em>Bcb</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d3/d8/pinsup_8c-source.html#l00271">271</a> of file <a class="el" href="../../d3/d8/pinsup_8c-source.html">pinsup.c</a>.
<p>
References <a class="el" href="../../d6/d4/cc_8h-source.html#l00501">BooleanFlagOn</a>, <a class="el" href="../../d7/d1/rtqkey_8c-source.html#l00042">Buffer</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00155">CACHE_NTC_BCB</a>, <a class="el" href="../../d3/d8/pinsup_8c-source.html#l01230">CcAllocateObcb()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01998">CcBcbSpinLock</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00862">CcFreeVirtualAddress()</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l00116">CcPinFileData()</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00181">CcPinMappedDataCount</a>, <a class="el" href="../../d3/d8/pinsup_8c-source.html#l01000">CcUnpinData()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02290">DebugTrace</a>, <a class="el" href="../../d9/d7/ex_2resource_8c-source.html#l01014">ExAcquireSharedStarveExclusive()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00497">FlagOn</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00832">_SHARED_CACHE_MAP::Flags</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l00033">me</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01077">MODIFIED_WRITE_DISABLED</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d5/d1/cache_8h-source.html#l00582">PIN_WAIT</a>, <a class="el" href="../../d5/d9/tex_8c-source.html#l01561">Resource</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, and <a class="el" href="../../d6/d4/cc_8h-source.html#l02154">try_return</a>.
<p>
<pre class="fragment"><div>00281                    :
00282 
00283     This routine attempts to pin data that was previously <a class="code" href="../../d3/d0/imm32_8def.html#a1">only</a> mapped.
00284     If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> routine determines that in fact <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> was necessary to actually
00285     pin <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data when <a class="code" href="../../d2/d9/pinsup_8c.html#a2">CcMapData</a> was called, then <span class="keyword">this</span> routine does not
00286     have to <span class="keywordflow">do</span> anything.
00287 
00288     If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller does not want to block on <span class="keyword">this</span> call, then
00289     Wait should be supplied as <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>.  If Wait was supplied as <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> and
00290     <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> currently impossible to supply <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> requested data without
00291     blocking, then <span class="keyword">this</span> routine will <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>.  However, <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
00292     data <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> immediately accessible in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> cache and no blocking <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a>
00293     required, <span class="keyword">this</span> routine returns <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> with a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data.
00294 
00295     If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> not returned in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> first call, <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller
00296     may request <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data later with Wait = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>.  It <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> not required
00297     that <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller request <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data later.
00298 
00299     If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller subsequently modifies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data, <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> should call
00300     <a class="code" href="../../d6/d2/cachesub_8c.html#a18">CcSetDirtyPinnedData</a>.
00301 
00302     In any <span class="keywordflow">case</span>, <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller MUST subsequently call <a class="code" href="../../d2/d9/pinsup_8c.html#a6">CcUnpinData</a>.
00303     Naturally <span class="keywordflow">if</span> <a class="code" href="../../d2/d9/pinsup_8c.html#a4">CcPinRead</a> or <a class="code" href="../../d2/d9/pinsup_8c.html#a5">CcPreparePinWrite</a> were called multiple
00304     times <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> same data, <a class="code" href="../../d2/d9/pinsup_8c.html#a6">CcUnpinData</a> must be called <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> same number
00305     of times.
00306 
00307     Note there are no performance counters in <span class="keyword">this</span> routine, as <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> misses
00308     will almost always occur on <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> map above, and there will seldom be a
00309     miss on <span class="keyword">this</span> conversion.
00310 
00311 Arguments:
00312 
00313     FileObject - Pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> object <span class="keywordflow">for</span> a <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> which was
00314                  opened with NO_INTERMEDIATE_BUFFERING clear, i.e., <span class="keywordflow">for</span>
00315                  which <a class="code" href="../../d5/d8/fssup_8c.html#a9">CcInitializeCacheMap</a> was called by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> system.
00316 
00317     FileOffset - Byte offset in <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> <span class="keywordflow">for</span> desired data.
00318 
00319     Length - Length of desired data in bytes.
00320 
00321     Flags - (<a class="code" href="../../d4/d2/cache_8h.html#a6">PIN_WAIT</a>, <a class="code" href="../../d4/d2/cache_8h.html#a7">PIN_EXCLUSIVE</a>, <a class="code" href="../../d4/d2/cache_8h.html#a8">PIN_NO_READ</a>, etc. as defined in cache.h)
00322             If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller specifies <a class="code" href="../../d4/d2/cache_8h.html#a8">PIN_NO_READ</a> and <a class="code" href="../../d4/d2/cache_8h.html#a7">PIN_EXCLUSIVE</a>, then he must
00323             guarantee that no one <span class="keywordflow">else</span> will be attempting to map <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> view, <span class="keywordflow">if</span> he
00324             wants to guarantee that <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Bcb <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> not mapped (view may be purged).
00325             If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller specifies <a class="code" href="../../d4/d2/cache_8h.html#a8">PIN_NO_READ</a> without <a class="code" href="../../d4/d2/cache_8h.html#a7">PIN_EXCLUSIVE</a>, <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data
00326             may or may not be mapped in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <span class="keywordflow">return</span> Bcb.
00327 
00328     Bcb - On <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> first call <span class="keyword">this</span> returns a pointer to a Bcb
00329           parameter which must be supplied as input on all subsequent
00330           calls, <span class="keywordflow">for</span> <span class="keyword">this</span> buffer
00331 
00332 Return Value:
00333 
00334     <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> - <span class="keywordflow">if</span> Wait was not set and <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data was not delivered
00335 
00336     <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> - <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> being delivered
00337 
00338 --*/
00339 
00340 {
00341     PVOID <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>;
00342     LARGE_INTEGER BeyondLastByte;
00343     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap;
00344     LARGE_INTEGER LocalFileOffset = *FileOffset;
00345     <a class="code" href="../../d6/d4/struct__OBCB.html">POBCB</a> MyBcb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00346     <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> *CurrentBcbPtr = (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> *)&amp;MyBcb;
00347     BOOLEAN Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00348 
00349     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, me, <span class="stringliteral">"CcPinMappedData\n"</span>, 0 );
00350 
00351     <span class="comment">//</span>
00352     <span class="comment">// If the Bcb is no longer ReadOnly, then just return.</span>
00353     <span class="comment">//</span>
00354 
00355     <span class="keywordflow">if</span> ((*(PULONG)Bcb &amp; 1) == 0) {
00356         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00357     }
00358 
00359     <span class="comment">//</span>
00360     <span class="comment">// Remove the Read Only flag</span>
00361     <span class="comment">//</span>
00362 
00363     *(PCHAR *)Bcb -= 1;
00364 
00365     <span class="comment">//</span>
00366     <span class="comment">//  Get pointer to SharedCacheMap.</span>
00367     <span class="comment">//</span>
00368 
00369     SharedCacheMap = *(<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> *)((PCHAR)FileObject-&gt;SectionObjectPointer
00370                                             + <span class="keyword">sizeof</span>(PVOID));
00371 
00372     <span class="comment">//</span>
00373     <span class="comment">//  We only count the calls to this routine, since they are almost guaranteed</span>
00374     <span class="comment">//  to be hits.</span>
00375     <span class="comment">//</span>
00376 
00377     <a class="code" href="../../d5/d2/cachedat_8c.html#a56">CcPinMappedDataCount</a> += 1;
00378 
00379     <span class="comment">//</span>
00380     <span class="comment">//  Guarantee we will put the flag back if required.</span>
00381     <span class="comment">//</span>
00382 
00383     <span class="keywordflow">try</span> {
00384 
00385         <span class="keywordflow">if</span> (((<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)*Bcb)-&gt;NodeTypeCode != <a class="code" href="../../d5/d5/cc_8h.html#a14">CACHE_NTC_BCB</a>) {
00386 
00387             <span class="comment">//</span>
00388             <span class="comment">//  Form loop to handle occassional overlapped Bcb case.</span>
00389             <span class="comment">//</span>
00390 
00391             <span class="keywordflow">do</span> {
00392 
00393                 <span class="comment">//</span>
00394                 <span class="comment">//  If we have already been through the loop, then adjust</span>
00395                 <span class="comment">//  our file offset and length from the last time.</span>
00396                 <span class="comment">//</span>
00397 
00398                 <span class="keywordflow">if</span> (MyBcb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00399 
00400                     <span class="comment">//</span>
00401                     <span class="comment">//  If this is the second time through the loop, then it is time</span>
00402                     <span class="comment">//  to handle the overlap case and allocate an OBCB.</span>
00403                     <span class="comment">//</span>
00404 
00405                     <span class="keywordflow">if</span> (CurrentBcbPtr == (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> *)&amp;MyBcb) {
00406 
00407                         MyBcb = <a class="code" href="../../d2/d9/pinsup_8c.html#a1">CcAllocateObcb</a>( FileOffset, Length, (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)MyBcb );
00408 
00409                         <span class="comment">//</span>
00410                         <span class="comment">//  Set CurrentBcbPtr to point at the first entry in</span>
00411                         <span class="comment">//  the vector (which is already filled in), before</span>
00412                         <span class="comment">//  advancing it below.</span>
00413                         <span class="comment">//</span>
00414 
00415                         CurrentBcbPtr = &amp;MyBcb-&gt;<a class="code" href="../../d6/d4/struct__OBCB.html#o4">Bcbs</a>[0];
00416                     }
00417 
00418                     Length -= (ULONG)(BeyondLastByte.QuadPart - LocalFileOffset.QuadPart);
00419                     LocalFileOffset.QuadPart = BeyondLastByte.QuadPart;
00420                     CurrentBcbPtr += 1;
00421                 }
00422 
00423                 <span class="comment">//</span>
00424                 <span class="comment">//  Call local routine to Map or Access the file data.  If we cannot map</span>
00425                 <span class="comment">//  the data because of a Wait condition, return FALSE.</span>
00426                 <span class="comment">//</span>
00427 
00428                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/cc_8h.html#a175">CcPinFileData</a>( FileObject,
00429                                     &amp;LocalFileOffset,
00430                                     Length,
00431                                     (BOOLEAN)!<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, MODIFIED_WRITE_DISABLED),
00432                                     FALSE,
00433                                     Flags,
00434                                     CurrentBcbPtr,
00435                                     &amp;Buffer,
00436                                     &amp;BeyondLastByte )) {
00437 
00438                     <a class="code" href="../../d5/d5/cc_8h.html#a90">try_return</a>( Result = FALSE );
00439                 }
00440 
00441             <span class="comment">//</span>
00442             <span class="comment">//  Continue looping if we did not get everything.</span>
00443             <span class="comment">//</span>
00444 
00445             } <span class="keywordflow">while</span>((BeyondLastByte.QuadPart - LocalFileOffset.QuadPart) &lt; Length);
00446 
00447             <span class="comment">//</span>
00448             <span class="comment">//  Free the Vacb before going on.</span>
00449             <span class="comment">//</span>
00450 
00451             <a class="code" href="../../d5/d3/vacbsup_8c.html#a16">CcFreeVirtualAddress</a>( (<a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a>)*Bcb );
00452 
00453             *Bcb = MyBcb;
00454 
00455             <span class="comment">//</span>
00456             <span class="comment">//  Debug routines used to insert and remove Bcbs from the global list</span>
00457             <span class="comment">//</span>
00458 
00459 <span class="preprocessor">#if LIST_DBG</span>
00460 <span class="preprocessor"></span>            {
00461                 KIRQL OldIrql;
00462                 <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> BcbTemp = (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)*Bcb;
00463 
00464                 ExAcquireSpinLock( &amp;CcBcbSpinLock, &amp;OldIrql );
00465 
00466                 <span class="keywordflow">if</span> (BcbTemp-&gt;CcBcbLinks.Flink == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00467 
00468                     InsertTailList( &amp;CcBcbList, &amp;BcbTemp-&gt;CcBcbLinks );
00469                     CcBcbCount += 1;
00470                     ExReleaseSpinLock( &amp;CcBcbSpinLock, OldIrql );
00471                     SetCallersAddress( BcbTemp );
00472 
00473                 } <span class="keywordflow">else</span> {
00474                     ExReleaseSpinLock( &amp;CcBcbSpinLock, OldIrql );
00475                 }
00476 
00477             }
00478 <span class="preprocessor">#endif</span>
00479 <span class="preprocessor"></span>        }
00480 
00481         <span class="comment">//</span>
00482         <span class="comment">//  If he really has a Bcb, all we have to do is acquire it shared since he is</span>
00483         <span class="comment">//  no longer ReadOnly.</span>
00484         <span class="comment">//</span>
00485 
00486         <span class="keywordflow">else</span> {
00487 
00488             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d8/ex_8h.html#a270">ExAcquireSharedStarveExclusive</a>( &amp;((<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)*Bcb)-&gt;Resource, <a class="code" href="../../d5/d5/cc_8h.html#a59">BooleanFlagOn</a>(Flags, PIN_WAIT))) {
00489 
00490                 <a class="code" href="../../d5/d5/cc_8h.html#a90">try_return</a>( Result = FALSE );
00491             }
00492         }
00493 
00494         Result = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00495 
00496     try_exit: NOTHING;
00497     }
00498     finally {
00499 
00500         <span class="keywordflow">if</span> (!Result) {
00501 
00502             <span class="comment">//</span>
00503             <span class="comment">//  Put the Read Only flag back</span>
00504             <span class="comment">//</span>
00505 
00506             *(PCHAR *)Bcb += 1;
00507 
00508             <span class="comment">//</span>
00509             <span class="comment">//  We may have gotten partway through</span>
00510             <span class="comment">//</span>
00511 
00512             <span class="keywordflow">if</span> (MyBcb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00513                 <a class="code" href="../../d4/d2/cache_8h.html#a92">CcUnpinData</a>( MyBcb );
00514             }
00515         }
00516 
00517         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, me, <span class="stringliteral">"CcPinMappedData -&gt; %02lx\n"</span>, Result );
00518     }
00519     <span class="keywordflow">return</span> Result;
00520 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a87" doxytag="cache.h::CcPinRead" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTKERNELAPI BOOLEAN CcPinRead           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>FileObject</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PLARGE_INTEGER&nbsp;</td>
          <td class="mdname" nowrap> <em>FileOffset</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Length</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Flags</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PVOID *&nbsp;</td>
          <td class="mdname" nowrap> <em>Bcb</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PVOID *&nbsp;</td>
          <td class="mdname" nowrap> <em>Buffer</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d3/d8/pinsup_8c-source.html#l00524">524</a> of file <a class="el" href="../../d3/d8/pinsup_8c-source.html">pinsup.c</a>.
<p>
References <a class="el" href="../../d7/d1/rtqkey_8c-source.html#l00042">Buffer</a>, <a class="el" href="../../d3/d8/pinsup_8c-source.html#l01230">CcAllocateObcb()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01998">CcBcbSpinLock</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00206">CcMissCounter</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l00116">CcPinFileData()</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00183">CcPinReadNoWait</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00185">CcPinReadNoWaitMiss</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00184">CcPinReadWait</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00186">CcPinReadWaitMiss</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00160">CcThrowAway</a>, <a class="el" href="../../d3/d8/pinsup_8c-source.html#l01000">CcUnpinData()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02290">DebugTrace</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00497">FlagOn</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00832">_SHARED_CACHE_MAP::Flags</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l00033">me</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01077">MODIFIED_WRITE_DISABLED</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d5/d1/cache_8h-source.html#l00582">PIN_WAIT</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, and <a class="el" href="../../d6/d4/cc_8h-source.html#l02154">try_return</a>.
<p>
Referenced by <a class="el" href="../../d8/d1/lfs_2cachesup_8c-source.html#l00084">LfsPinOrMapData()</a>.
<p>
<pre class="fragment"><div>00535                    :
00536 
00537     This routine attempts to pin <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> data in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> cache.
00538     <a class="code" href="../../d2/d1/bench_8h.html#a5">A</a> pointer <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> returned to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> desired data in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> cache.  This routine
00539     <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> intended <span class="keywordflow">for</span> <a class="code" href="../../d1/d9/icmui_8def.html#a0">File</a> System support and <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> not intended to be called
00540     from Dpc level.
00541 
00542     If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller does not want to block on <span class="keyword">this</span> call, then
00543     Wait should be supplied as <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>.  If Wait was supplied as <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> and
00544     <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> currently impossible to supply <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> requested data without
00545     blocking, then <span class="keyword">this</span> routine will <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>.  However, <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
00546     data <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> immediately accessible in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> cache and no blocking <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a>
00547     required, <span class="keyword">this</span> routine returns <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> with a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data.
00548 
00549     If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> not returned in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> first call, <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller
00550     may request <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data later with Wait = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>.  It <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> not required
00551     that <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller request <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data later.
00552 
00553     If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller subsequently modifies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data, <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> should call
00554     <a class="code" href="../../d6/d2/cachesub_8c.html#a18">CcSetDirtyPinnedData</a>.
00555 
00556     In any <span class="keywordflow">case</span>, <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller MUST subsequently call <a class="code" href="../../d2/d9/pinsup_8c.html#a6">CcUnpinData</a>.
00557     Naturally <span class="keywordflow">if</span> <a class="code" href="../../d2/d9/pinsup_8c.html#a4">CcPinRead</a> or <a class="code" href="../../d2/d9/pinsup_8c.html#a5">CcPreparePinWrite</a> were called multiple
00558     times <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> same data, <a class="code" href="../../d2/d9/pinsup_8c.html#a6">CcUnpinData</a> must be called <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> same number
00559     of times.
00560 
00561     The returned <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> pointer <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> valid until <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> unpinned, at
00562     which point <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> invalid to use <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> pointer further.
00563 
00564 Arguments:
00565 
00566     FileObject - Pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> object <span class="keywordflow">for</span> a <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> which was
00567                  opened with NO_INTERMEDIATE_BUFFERING clear, i.e., <span class="keywordflow">for</span>
00568                  which <a class="code" href="../../d5/d8/fssup_8c.html#a9">CcInitializeCacheMap</a> was called by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> system.
00569 
00570     FileOffset - Byte offset in <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> <span class="keywordflow">for</span> desired data.
00571 
00572     Length - Length of desired data in bytes.
00573 
00574     Flags - (<a class="code" href="../../d4/d2/cache_8h.html#a6">PIN_WAIT</a>, <a class="code" href="../../d4/d2/cache_8h.html#a7">PIN_EXCLUSIVE</a>, <a class="code" href="../../d4/d2/cache_8h.html#a8">PIN_NO_READ</a>, etc. as defined in cache.h)
00575             If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller specifies <a class="code" href="../../d4/d2/cache_8h.html#a8">PIN_NO_READ</a> and <a class="code" href="../../d4/d2/cache_8h.html#a7">PIN_EXCLUSIVE</a>, then he must
00576             guarantee that no one <span class="keywordflow">else</span> will be attempting to map <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> view, <span class="keywordflow">if</span> he
00577             wants to guarantee that <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Bcb <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> not mapped (view may be purged).
00578             If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller specifies <a class="code" href="../../d4/d2/cache_8h.html#a8">PIN_NO_READ</a> without <a class="code" href="../../d4/d2/cache_8h.html#a7">PIN_EXCLUSIVE</a>, <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data
00579             may or may not be mapped in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <span class="keywordflow">return</span> Bcb.
00580 
00581     Bcb - On <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> first call <span class="keyword">this</span> returns a pointer to a Bcb
00582           parameter which must be supplied as input on all subsequent
00583           calls, <span class="keywordflow">for</span> <span class="keyword">this</span> buffer
00584 
00585     <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> - Returns pointer to desired data, valid until <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> buffer <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a>
00586              unpinned or freed.
00587 
00588 Return Value:
00589 
00590     <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> - <span class="keywordflow">if</span> Wait was not set and <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data was not delivered
00591 
00592     <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> - <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> being delivered
00593 
00594 --*/
00595 
00596 {
00597     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap;
00598     PVOID LocalBuffer;
00599     LARGE_INTEGER BeyondLastByte;
00600     LARGE_INTEGER LocalFileOffset = *FileOffset;
00601     <a class="code" href="../../d6/d4/struct__OBCB.html">POBCB</a> MyBcb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00602     <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> *CurrentBcbPtr = (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> *)&amp;MyBcb;
00603     BOOLEAN Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00604 
00605     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, me, <span class="stringliteral">"CcPinRead\n"</span>, 0 );
00606 
00607     <span class="comment">//</span>
00608     <span class="comment">//  Increment performance counters</span>
00609     <span class="comment">//</span>
00610 
00611     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(Flags, PIN_WAIT)) {
00612 
00613         <a class="code" href="../../d5/d2/cachedat_8c.html#a58">CcPinReadWait</a> += 1;
00614 
00615         <span class="comment">//</span>
00616         <span class="comment">//  Initialize the indirect pointer to our miss counter.</span>
00617         <span class="comment">//</span>
00618 
00619         <a class="code" href="../../d5/d2/cachedat_8c.html#a75">CcMissCounter</a> = &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a60">CcPinReadWaitMiss</a>;
00620 
00621     } <span class="keywordflow">else</span> {
00622         <a class="code" href="../../d5/d2/cachedat_8c.html#a57">CcPinReadNoWait</a> += 1;
00623     }
00624 
00625     <span class="comment">//</span>
00626     <span class="comment">//  Get pointer to SharedCacheMap.</span>
00627     <span class="comment">//</span>
00628 
00629     SharedCacheMap = *(<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> *)((PCHAR)FileObject-&gt;SectionObjectPointer
00630                                             + <span class="keyword">sizeof</span>(PVOID));
00631 
00632     <span class="keywordflow">try</span> {
00633 
00634         <span class="comment">//</span>
00635         <span class="comment">//  Form loop to handle occassional overlapped Bcb case.</span>
00636         <span class="comment">//</span>
00637 
00638         <span class="keywordflow">do</span> {
00639 
00640             <span class="comment">//</span>
00641             <span class="comment">//  If we have already been through the loop, then adjust</span>
00642             <span class="comment">//  our file offset and length from the last time.</span>
00643             <span class="comment">//</span>
00644 
00645             <span class="keywordflow">if</span> (MyBcb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00646 
00647                 <span class="comment">//</span>
00648                 <span class="comment">//  If this is the second time through the loop, then it is time</span>
00649                 <span class="comment">//  to handle the overlap case and allocate an OBCB.</span>
00650                 <span class="comment">//</span>
00651 
00652                 <span class="keywordflow">if</span> (CurrentBcbPtr == (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> *)&amp;MyBcb) {
00653 
00654                     MyBcb = <a class="code" href="../../d2/d9/pinsup_8c.html#a1">CcAllocateObcb</a>( FileOffset, Length, (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)MyBcb );
00655 
00656                     <span class="comment">//</span>
00657                     <span class="comment">//  Set CurrentBcbPtr to point at the first entry in</span>
00658                     <span class="comment">//  the vector (which is already filled in), before</span>
00659                     <span class="comment">//  advancing it below.</span>
00660                     <span class="comment">//</span>
00661 
00662                     CurrentBcbPtr = &amp;MyBcb-&gt;<a class="code" href="../../d6/d4/struct__OBCB.html#o4">Bcbs</a>[0];
00663 
00664                     <span class="comment">//</span>
00665                     <span class="comment">//  Also on second time through, return starting Buffer</span>
00666                     <span class="comment">//</span>
00667 
00668                     *<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> = LocalBuffer;
00669                 }
00670 
00671                 Length -= (ULONG)(BeyondLastByte.QuadPart - LocalFileOffset.QuadPart);
00672                 LocalFileOffset.QuadPart = BeyondLastByte.QuadPart;
00673                 CurrentBcbPtr += 1;
00674             }
00675 
00676             <span class="comment">//</span>
00677             <span class="comment">//  Call local routine to Map or Access the file data.  If we cannot map</span>
00678             <span class="comment">//  the data because of a Wait condition, return FALSE.</span>
00679             <span class="comment">//</span>
00680 
00681             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/cc_8h.html#a175">CcPinFileData</a>( FileObject,
00682                                 &amp;LocalFileOffset,
00683                                 Length,
00684                                 (BOOLEAN)!<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, MODIFIED_WRITE_DISABLED),
00685                                 FALSE,
00686                                 Flags,
00687                                 CurrentBcbPtr,
00688                                 &amp;LocalBuffer,
00689                                 &amp;BeyondLastByte )) {
00690 
00691                 <a class="code" href="../../d5/d2/cachedat_8c.html#a59">CcPinReadNoWaitMiss</a> += 1;
00692 
00693                 <a class="code" href="../../d5/d5/cc_8h.html#a90">try_return</a>( Result = FALSE );
00694             }
00695 
00696         <span class="comment">//</span>
00697         <span class="comment">//  Continue looping if we did not get everything.</span>
00698         <span class="comment">//</span>
00699 
00700         } <span class="keywordflow">while</span>((BeyondLastByte.QuadPart - LocalFileOffset.QuadPart) &lt; Length);
00701 
00702         *Bcb = MyBcb;
00703 
00704         <span class="comment">//</span>
00705         <span class="comment">//  Debug routines used to insert and remove Bcbs from the global list</span>
00706         <span class="comment">//</span>
00707 
00708 <span class="preprocessor">#if LIST_DBG</span>
00709 <span class="preprocessor"></span>
00710         {
00711             KIRQL OldIrql;
00712             <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> BcbTemp = (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)*Bcb;
00713 
00714             ExAcquireSpinLock( &amp;CcBcbSpinLock, &amp;OldIrql );
00715 
00716             <span class="keywordflow">if</span> (BcbTemp-&gt;CcBcbLinks.Flink == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00717 
00718                 InsertTailList( &amp;CcBcbList, &amp;BcbTemp-&gt;CcBcbLinks );
00719                 CcBcbCount += 1;
00720                 ExReleaseSpinLock( &amp;CcBcbSpinLock, OldIrql );
00721                 SetCallersAddress( BcbTemp );
00722 
00723             } <span class="keywordflow">else</span> {
00724                 ExReleaseSpinLock( &amp;CcBcbSpinLock, OldIrql );
00725             }
00726 
00727         }
00728 
00729 <span class="preprocessor">#endif</span>
00730 <span class="preprocessor"></span>
00731         <span class="comment">//</span>
00732         <span class="comment">//  In the normal (nonoverlapping) case we return the</span>
00733         <span class="comment">//  correct buffer address here.</span>
00734         <span class="comment">//</span>
00735 
00736         <span class="keywordflow">if</span> (CurrentBcbPtr == (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> *)&amp;MyBcb) {
00737             *<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> = LocalBuffer;
00738         }
00739 
00740         Result = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00741 
00742     try_exit: NOTHING;
00743     }
00744     finally {
00745 
00746         <a class="code" href="../../d5/d2/cachedat_8c.html#a75">CcMissCounter</a> = &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a43">CcThrowAway</a>;
00747 
00748         <span class="keywordflow">if</span> (!Result) {
00749 
00750             <span class="comment">//</span>
00751             <span class="comment">//  We may have gotten partway through</span>
00752             <span class="comment">//</span>
00753 
00754             <span class="keywordflow">if</span> (MyBcb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00755                 <a class="code" href="../../d4/d2/cache_8h.html#a92">CcUnpinData</a>( MyBcb );
00756             }
00757         }
00758 
00759         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, me, <span class="stringliteral">"CcPinRead -&gt; %02lx\n"</span>, Result );
00760     }
00761 
00762     <span class="keywordflow">return</span> Result;
00763 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a81" doxytag="cache.h::CcPrepareMdlWrite" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTKERNELAPI VOID CcPrepareMdlWrite           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>FileObject</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PLARGE_INTEGER&nbsp;</td>
          <td class="mdname" nowrap> <em>FileOffset</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Length</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT <a class="el" href="../../d6/d7/struct__MDL.html">PMDL</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>MdlChain</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PIO_STATUS_BLOCK&nbsp;</td>
          <td class="mdname" nowrap> <em>IoStatus</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d8/d4/mdlsup_8c-source.html#l00466">466</a> of file <a class="el" href="../../d8/d4/mdlsup_8c-source.html">mdlsup.c</a>.
<p>
References <a class="el" href="../../d6/d4/cc_8h-source.html#l00965">_SHARED_CACHE_MAP::BcbSpinLock</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00064">CcAcquireMasterLock</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l05885">CcFreeActiveVacb()</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00862">CcFreeVirtualAddress()</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00310">CcGetVirtualAddress()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01003">CcIncrementOpenCount</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l05749">CcMapAndRead()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00067">CcReleaseMasterLock</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l02242">CcSetDirtyInMask()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02290">DebugTrace</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02292">DebugTrace2</a>, <a class="el" href="../../d1/d3/ex_2alpha_2raisests_8c-source.html#l00157">ExRaiseStatus()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01577">GetActiveVacb</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l00805">IoAllocateMdl()</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l06744">IoFreeMdl()</a>, <a class="el" href="../../d2/d1/mm_8h.html#a344a169">IoWriteAccess</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00624">KernelMode</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l00033">me</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00462">mm</a>, <a class="el" href="../../d3/d0/mm_8h-source.html#l00924">MmDisablePageFaultClustering</a>, <a class="el" href="../../d3/d0/mm_8h-source.html#l00953">MmEnablePageFaultClustering</a>, <a class="el" href="../../d6/d5/iosup_8c-source.html#l00238">MmProbeAndLockPages()</a>, <a class="el" href="../../d6/d5/iosup_8c-source.html#l01347">MmUnlockPages()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00809">_SHARED_CACHE_MAP::NeedToZero</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00414">_MDL::Next</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00599">PAGE_SIZE</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00780">_SHARED_CACHE_MAP::ValidDataGoal</a>, <a class="el" href="../../d2/d7/hal_8h.html#a212">VOID()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01798">ZERO_FIRST_PAGE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01800">ZERO_LAST_PAGE</a>, and <a class="el" href="../../d6/d4/cc_8h-source.html#l01799">ZERO_MIDDLE_PAGES</a>.
<p>
Referenced by <a class="el" href="../../d4/d0/fastio_8c-source.html#l01474">FsRtlPrepareMdlWriteDev()</a>.
<p>
<pre class="fragment"><div>00476                    :
00477 
00478     This routine attempts to lock <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> data in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> cache
00479     and <span class="keywordflow">return</span> a description of <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> in an Mdl along with <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> correct
00480     I/O status.  Pages to be completely overwritten may be satisfied
00481     with emtpy pages.  It <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> *not* safe to call <span class="keyword">this</span> routine from Dpc level.
00482 
00483     This call <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> synchronous and raises on error.
00484 
00485     When <span class="keyword">this</span> call returns, <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller may immediately begin
00486     to transfer data into <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> buffers via <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Mdl.
00487 
00488     When <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> call returns with <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> pages described by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Mdl are
00489     locked in memory, but not mapped in system space.  If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller
00490     needs <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> pages mapped in system space, then <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> must map them.
00491     On <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> subsequent call to <a class="code" href="../../d7/d5/mdlsup_8c.html#a5">CcMdlWriteComplete</a> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> pages will be
00492     unmapped <span class="keywordflow">if</span> they were mapped, and in any <span class="keywordflow">case</span> unlocked and <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Mdl
00493     deallocated.
00494 
00495 Arguments:
00496 
00497     FileObject - Pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> object <span class="keywordflow">for</span> a <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> which was
00498                  opened with NO_INTERMEDIATE_BUFFERING clear, i.e., <span class="keywordflow">for</span>
00499                  which <a class="code" href="../../d5/d8/fssup_8c.html#a9">CcInitializeCacheMap</a> was called by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> system.
00500 
00501     FileOffset - Byte offset in <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> <span class="keywordflow">for</span> desired data.
00502 
00503     Length - Length of desired data in bytes.
00504 
00505     MdlChain - On output <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> returns a pointer to an Mdl chain describing
00506                <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> desired data.  Note that even <span class="keywordflow">if</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> returned,
00507                one or more Mdls may have been allocated, as may be ascertained
00508                by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> IoStatus.Information field (see below).
00509 
00510     IoStatus - Pointer to standard I/O status block to receive <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> status
00511                <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> in-transfer of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data.  (STATUS_SUCCESS guaranteed
00512                <span class="keywordflow">for</span> cache hits, otherwise <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> actual I/O status <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> returned.)
00513                The I/O Information Field indicates how many bytes have been
00514                successfully locked down in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Mdl Chain.
00515 
00516 Return Value:
00517 
00518     None
00519 
00520 --*/
00521 
00522 {
00523     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap;
00524     PVOID CacheBuffer;
00525     LARGE_INTEGER FOffset;
00526     <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> Mdl = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00527     <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> MdlTemp;
00528     LARGE_INTEGER Temp;
00529     ULONG SavedState = 0;
00530     ULONG ZeroFlags = 0;
00531     ULONG Information = 0;
00532 
00533     KIRQL OldIrql;
00534     ULONG ActivePage;
00535     ULONG PageIsDirty;
00536     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> Vacb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00537 
00538     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, me, <span class="stringliteral">"CcPrepareMdlWrite\n"</span>, 0 );
00539     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, me, <span class="stringliteral">"    FileObject = %08lx\n"</span>, FileObject );
00540     <a class="code" href="../../d5/d5/cc_8h.html#a92">DebugTrace2</a>(0, me, <span class="stringliteral">"    FileOffset = %08lx, %08lx\n"</span>, FileOffset-&gt;LowPart,
00541                                                           FileOffset-&gt;HighPart );
00542     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, me, <span class="stringliteral">"    Length = %08lx\n"</span>, Length );
00543 
00544     <span class="comment">//</span>
00545     <span class="comment">//  Get pointer to SharedCacheMap.</span>
00546     <span class="comment">//</span>
00547 
00548     SharedCacheMap = FileObject-&gt;SectionObjectPointer-&gt;SharedCacheMap;
00549 
00550     <span class="comment">//</span>
00551     <span class="comment">//  See if we have an active Vacb, that we need to free.</span>
00552     <span class="comment">//</span>
00553 
00554     <a class="code" href="../../d5/d5/cc_8h.html#a82">GetActiveVacb</a>( SharedCacheMap, OldIrql, Vacb, ActivePage, PageIsDirty );
00555 
00556     <span class="comment">//</span>
00557     <span class="comment">//  If there is an end of a page to be zeroed, then free that page now,</span>
00558     <span class="comment">//  so it does not cause our data to get zeroed.  If there is an active</span>
00559     <span class="comment">//  page, free it so we have the correct ValidDataGoal.</span>
00560     <span class="comment">//</span>
00561 
00562     <span class="keywordflow">if</span> ((Vacb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) || (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o13">NeedToZero</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
00563 
00564         <a class="code" href="../../d5/d5/cc_8h.html#a182">CcFreeActiveVacb</a>( SharedCacheMap, Vacb, ActivePage, PageIsDirty );
00565         Vacb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00566     }
00567 
00568     FOffset = *FileOffset;
00569 
00570     <span class="comment">//</span>
00571     <span class="comment">//  Put try-finally around the loop to deal with exceptions</span>
00572     <span class="comment">//</span>
00573 
00574     <span class="keywordflow">try</span> {
00575 
00576         <span class="comment">//</span>
00577         <span class="comment">//  Not all of the transfer will come back at once, so we have to loop</span>
00578         <span class="comment">//  until the entire transfer is complete.</span>
00579         <span class="comment">//</span>
00580 
00581         <span class="keywordflow">while</span> (Length != 0) {
00582 
00583             ULONG ReceivedLength;
00584             LARGE_INTEGER BeyondLastByte;
00585 
00586             <span class="comment">//</span>
00587             <span class="comment">//  Map and see how much we could potentially access at this</span>
00588             <span class="comment">//  FileOffset, then cut it down if it is more than we need.</span>
00589             <span class="comment">//</span>
00590 
00591             CacheBuffer = <a class="code" href="../../d5/d3/vacbsup_8c.html#a15">CcGetVirtualAddress</a>( SharedCacheMap,
00592                                                FOffset,
00593                                                &amp;Vacb,
00594                                                &amp;ReceivedLength );
00595 
00596             <span class="keywordflow">if</span> (ReceivedLength &gt; Length) {
00597                 ReceivedLength = Length;
00598             }
00599 
00600             BeyondLastByte.QuadPart = FOffset.QuadPart + (LONGLONG)ReceivedLength;
00601 
00602             <span class="comment">//</span>
00603             <span class="comment">//  At this point we can calculate the ZeroFlags.</span>
00604             <span class="comment">//</span>
00605 
00606             <span class="comment">//</span>
00607             <span class="comment">//  We can always zero middle pages, if any.</span>
00608             <span class="comment">//</span>
00609 
00610             ZeroFlags = <a class="code" href="../../d5/d5/cc_8h.html#a86">ZERO_MIDDLE_PAGES</a>;
00611 
00612             <span class="comment">//</span>
00613             <span class="comment">//  See if we are completely overwriting the first or last page.</span>
00614             <span class="comment">//</span>
00615 
00616             <span class="keywordflow">if</span> (((FOffset.LowPart &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1)) == 0) &amp;&amp;
00617                 (ReceivedLength &gt;= <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>)) {
00618                 ZeroFlags |= <a class="code" href="../../d5/d5/cc_8h.html#a85">ZERO_FIRST_PAGE</a>;
00619             }
00620 
00621             <span class="keywordflow">if</span> ((BeyondLastByte.LowPart &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1)) == 0) {
00622                 ZeroFlags |= <a class="code" href="../../d5/d5/cc_8h.html#a87">ZERO_LAST_PAGE</a>;
00623             }
00624 
00625             <span class="comment">//</span>
00626             <span class="comment">//  See if the entire transfer is beyond valid data length,</span>
00627             <span class="comment">//  or at least starting from the second page.</span>
00628             <span class="comment">//</span>
00629 
00630             Temp = FOffset;
00631             Temp.LowPart &amp;= ~(<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> -1);
00632             ExAcquireFastLock( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o36">BcbSpinLock</a>, &amp;OldIrql );
00633             Temp.QuadPart = SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o7">ValidDataGoal</a>.QuadPart - Temp.QuadPart;
00634             ExReleaseFastLock( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o36">BcbSpinLock</a>, OldIrql );
00635 
00636             <span class="keywordflow">if</span> (Temp.QuadPart &lt;= 0) {
00637                 ZeroFlags |= <a class="code" href="../../d5/d5/cc_8h.html#a85">ZERO_FIRST_PAGE</a> | <a class="code" href="../../d5/d5/cc_8h.html#a86">ZERO_MIDDLE_PAGES</a> | <a class="code" href="../../d5/d5/cc_8h.html#a87">ZERO_LAST_PAGE</a>;
00638             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((Temp.HighPart == 0) &amp;&amp; (Temp.LowPart &lt;= <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>)) {
00639                 ZeroFlags |= <a class="code" href="../../d5/d5/cc_8h.html#a86">ZERO_MIDDLE_PAGES</a> | <a class="code" href="../../d5/d5/cc_8h.html#a87">ZERO_LAST_PAGE</a>;
00640             }
00641 
00642             (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>)<a class="code" href="../../d5/d5/cc_8h.html#a181">CcMapAndRead</a>( SharedCacheMap,
00643                                 &amp;FOffset,
00644                                 ReceivedLength,
00645                                 ZeroFlags,
00646                                 TRUE,
00647                                 CacheBuffer );
00648 
00649             <span class="comment">//</span>
00650             <span class="comment">//  Now attempt to allocate an Mdl to describe the mapped data.</span>
00651             <span class="comment">//</span>
00652 
00653             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, mm, <span class="stringliteral">"IoAllocateMdl:\n"</span>, 0 );
00654             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, mm, <span class="stringliteral">"    BaseAddress = %08lx\n"</span>, CacheBuffer );
00655             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, mm, <span class="stringliteral">"    Length = %08lx\n"</span>, ReceivedLength );
00656 
00657             Mdl = <a class="code" href="../../d4/d6/iosubs_8c.html#a19">IoAllocateMdl</a>( CacheBuffer,
00658                                  ReceivedLength,
00659                                  FALSE,
00660                                  FALSE,
00661                                  NULL );
00662 
00663             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, mm, <span class="stringliteral">"    &lt;Mdl = %08lx\n"</span>, Mdl );
00664 
00665             <span class="keywordflow">if</span> (Mdl == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00666                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, 0, <span class="stringliteral">"Failed to allocate Mdl\n"</span>, 0 );
00667 
00668                 <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INSUFFICIENT_RESOURCES );
00669             }
00670 
00671             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, mm, <span class="stringliteral">"MmProbeAndLockPages:\n"</span>, 0 );
00672             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, mm, <span class="stringliteral">"    Mdl = %08lx\n"</span>, Mdl );
00673 
00674             <a class="code" href="../../d2/d1/mm_8h.html#a17">MmDisablePageFaultClustering</a>(&amp;SavedState);
00675             <a class="code" href="../../d5/d6/iosup_8c.html#a41">MmProbeAndLockPages</a>( Mdl, KernelMode, IoWriteAccess );
00676             <a class="code" href="../../d2/d1/mm_8h.html#a18">MmEnablePageFaultClustering</a>(SavedState);
00677             SavedState = 0;
00678 
00679             <span class="comment">//</span>
00680             <span class="comment">//  Now that some data (maybe zeros) is locked in memory and</span>
00681             <span class="comment">//  set dirty, it is safe, and necessary for us to advance</span>
00682             <span class="comment">//  valid data goal, so that we will not subsequently ask</span>
00683             <span class="comment">//  for a zero page.  Note if we are extending valid data,</span>
00684             <span class="comment">//  our caller has the file exclusive.</span>
00685             <span class="comment">//</span>
00686 
00687             ExAcquireFastLock( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o36">BcbSpinLock</a>, &amp;OldIrql );
00688             <span class="keywordflow">if</span> (BeyondLastByte.QuadPart &gt; SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o7">ValidDataGoal</a>.QuadPart) {
00689                 SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o7">ValidDataGoal</a> = BeyondLastByte;
00690             }
00691             ExReleaseFastLock( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o36">BcbSpinLock</a>, OldIrql );
00692 
00693             <span class="comment">//</span>
00694             <span class="comment">//  Unmap the data now, now that the pages are locked down.</span>
00695             <span class="comment">//</span>
00696 
00697             <a class="code" href="../../d5/d3/vacbsup_8c.html#a16">CcFreeVirtualAddress</a>( Vacb );
00698             Vacb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00699 
00700             <span class="comment">//</span>
00701             <span class="comment">//  Now link the Mdl into the caller's chain</span>
00702             <span class="comment">//</span>
00703 
00704             <span class="keywordflow">if</span> ( *MdlChain == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
00705                 *MdlChain = Mdl;
00706             } <span class="keywordflow">else</span> {
00707                 MdlTemp = CONTAINING_RECORD( *MdlChain, <a class="code" href="../../d6/d7/struct__MDL.html">MDL</a>, Next );
00708                 <span class="keywordflow">while</span> (MdlTemp-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o0">Next</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00709                     MdlTemp = MdlTemp-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o0">Next</a>;
00710                 }
00711                 MdlTemp-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o0">Next</a> = Mdl;
00712             }
00713             Mdl = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00714 
00715             <span class="comment">//</span>
00716             <span class="comment">//  Assume we did not get all the data we wanted, and set FOffset</span>
00717             <span class="comment">//  to the end of the returned data.</span>
00718             <span class="comment">//</span>
00719 
00720             FOffset = BeyondLastByte;
00721 
00722             <span class="comment">//</span>
00723             <span class="comment">//  Update number of bytes transferred.</span>
00724             <span class="comment">//</span>
00725 
00726             Information += ReceivedLength;
00727 
00728             <span class="comment">//</span>
00729             <span class="comment">//  Calculate length left to transfer.</span>
00730             <span class="comment">//</span>
00731 
00732             Length -= ReceivedLength;
00733         }
00734     }
00735     finally {
00736 
00737         <span class="keywordflow">if</span> (AbnormalTermination()) {
00738 
00739             <span class="keywordflow">if</span> (SavedState != 0) {
00740                 <a class="code" href="../../d2/d1/mm_8h.html#a18">MmEnablePageFaultClustering</a>(SavedState);
00741             }
00742 
00743             <span class="keywordflow">if</span> (Vacb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00744                 <a class="code" href="../../d5/d3/vacbsup_8c.html#a16">CcFreeVirtualAddress</a>( Vacb );
00745             }
00746             
00747             <span class="keywordflow">if</span> (Mdl != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00748                 <a class="code" href="../../d4/d6/iosubs_8c.html#a65">IoFreeMdl</a>( Mdl );
00749             }
00750 
00751             <span class="comment">//</span>
00752             <span class="comment">//  Otherwise loop to deallocate the Mdls</span>
00753             <span class="comment">//</span>
00754 
00755             FOffset = *FileOffset;
00756             <span class="keywordflow">while</span> (*MdlChain != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00757                 MdlTemp = (*MdlChain)-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o0">Next</a>;
00758 
00759                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, mm, <span class="stringliteral">"MmUnlockPages/IoFreeMdl:\n"</span>, 0 );
00760                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, mm, <span class="stringliteral">"    Mdl = %08lx\n"</span>, *MdlChain );
00761 
00762                 <a class="code" href="../../d5/d6/iosup_8c.html#a45">MmUnlockPages</a>( *MdlChain );
00763 
00764                 <span class="comment">//</span>
00765                 <span class="comment">//  Extract the File Offset for this part of the transfer, and</span>
00766                 <span class="comment">//  tell the lazy writer to write these pages, since we have</span>
00767                 <span class="comment">//  marked them dirty.  Ignore the only exception (allocation</span>
00768                 <span class="comment">//  error), and console ourselves for having tried.</span>
00769                 <span class="comment">//</span>
00770 
00771                 <a class="code" href="../../d5/d5/cc_8h.html#a179">CcSetDirtyInMask</a>( SharedCacheMap, &amp;FOffset, (*MdlChain)-&gt;ByteCount );
00772 
00773                 FOffset.QuadPart = FOffset.QuadPart + (LONGLONG)((*MdlChain)-&gt;ByteCount);
00774 
00775                 <a class="code" href="../../d4/d6/iosubs_8c.html#a65">IoFreeMdl</a>( *MdlChain );
00776 
00777                 *MdlChain = MdlTemp;
00778             }
00779 
00780             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, me, <span class="stringliteral">"CcPrepareMdlWrite -&gt; Unwinding\n"</span>, 0 );
00781         }
00782         <span class="keywordflow">else</span> {
00783 
00784             IoStatus-&gt;Status = STATUS_SUCCESS;
00785             IoStatus-&gt;Information = Information;
00786 
00787             <span class="comment">//</span>
00788             <span class="comment">//  Make sure the SharedCacheMap does not go away while</span>
00789             <span class="comment">//  the Mdl write is in progress.  We decrment below.</span>
00790             <span class="comment">//</span>
00791 
00792             <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
00793             <a class="code" href="../../d5/d5/cc_8h.html#a68">CcIncrementOpenCount</a>( SharedCacheMap, 'ldmP' );
00794             <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
00795         }
00796     }
00797 
00798     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, me, <span class="stringliteral">"    &lt;MdlChain = %08lx\n"</span>, *MdlChain );
00799     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, me, <span class="stringliteral">"CcPrepareMdlWrite -&gt; VOID\n"</span>, 0 );
00800 
00801     <span class="keywordflow">return</span>;
00802 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a90" doxytag="cache.h::CcPreparePinWrite" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTKERNELAPI BOOLEAN CcPreparePinWrite           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>FileObject</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PLARGE_INTEGER&nbsp;</td>
          <td class="mdname" nowrap> <em>FileOffset</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Length</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN BOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>Zero</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Flags</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PVOID *&nbsp;</td>
          <td class="mdname" nowrap> <em>Bcb</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PVOID *&nbsp;</td>
          <td class="mdname" nowrap> <em>Buffer</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d3/d8/pinsup_8c-source.html#l00767">767</a> of file <a class="el" href="../../d3/d8/pinsup_8c-source.html">pinsup.c</a>.
<p>
References <a class="el" href="../../d7/d1/rtqkey_8c-source.html#l00042">Buffer</a>, <a class="el" href="../../d3/d8/pinsup_8c-source.html#l01230">CcAllocateObcb()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01998">CcBcbSpinLock</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00206">CcMissCounter</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l00116">CcPinFileData()</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l02560">CcSetDirtyPinnedData()</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00160">CcThrowAway</a>, <a class="el" href="../../d3/d8/pinsup_8c-source.html#l01000">CcUnpinData()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02290">DebugTrace</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l00033">me</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02154">try_return</a>, and <a class="el" href="../../d7/d5/ttime_8c-source.html#l00031">Zero</a>.
<p>
<pre class="fragment"><div>00779                    :
00780 
00781     This routine attempts to lock <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> data in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> cache
00782     and <span class="keywordflow">return</span> a pointer to <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> along with <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> correct
00783     I/O status.  Pages to be completely overwritten may be satisfied
00784     with emtpy pages.
00785 
00786     If not all of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> pages can be prepared, and Wait was supplied as
00787     <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, then <span class="keyword">this</span> routine will <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, and its outputs will
00788     be meaningless.  The caller may request <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data later with
00789     Wait = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>.  However, <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> not required that <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller request
00790     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data later.
00791 
00792     If Wait <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> supplied as <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, and all of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> pages can be prepared
00793     without blocking, <span class="keyword">this</span> call will <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> immediately.  Otherwise,
00794     <span class="keyword">this</span> call will block until all of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> pages can be prepared, and
00795     then <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>.
00796 
00797     When <span class="keyword">this</span> call returns with <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller may immediately begin
00798     to transfer data into <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> buffers via <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> pointer.  The
00799     buffer will already be marked dirty.
00800 
00801     The caller MUST subsequently call <a class="code" href="../../d2/d9/pinsup_8c.html#a6">CcUnpinData</a>.
00802     Naturally <span class="keywordflow">if</span> <a class="code" href="../../d2/d9/pinsup_8c.html#a4">CcPinRead</a> or <a class="code" href="../../d2/d9/pinsup_8c.html#a5">CcPreparePinWrite</a> were called multiple
00803     times <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> same data, <a class="code" href="../../d2/d9/pinsup_8c.html#a6">CcUnpinData</a> must be called <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> same number
00804     of times.
00805 
00806     The returned <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> pointer <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> valid until <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> unpinned, at
00807     which point <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> invalid to use <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> pointer further.
00808 
00809 Arguments:
00810 
00811     FileObject - Pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> object <span class="keywordflow">for</span> a <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> which was
00812                  opened with NO_INTERMEDIATE_BUFFERING clear, i.e., <span class="keywordflow">for</span>
00813                  which <a class="code" href="../../d5/d8/fssup_8c.html#a9">CcInitializeCacheMap</a> was called by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> system.
00814 
00815     FileOffset - Byte offset in <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> <span class="keywordflow">for</span> desired data.
00816 
00817     Length - Length of desired data in bytes.
00818 
00819     <a class="code" href="../../d6/d6/ttime_8c.html#a0">Zero</a> - If supplied as <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> buffer will be zeroed on <span class="keywordflow">return</span>.
00820 
00821     Flags - (<a class="code" href="../../d4/d2/cache_8h.html#a6">PIN_WAIT</a>, <a class="code" href="../../d4/d2/cache_8h.html#a7">PIN_EXCLUSIVE</a>, <a class="code" href="../../d4/d2/cache_8h.html#a8">PIN_NO_READ</a>, etc. as defined in cache.h)
00822             If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller specifies <a class="code" href="../../d4/d2/cache_8h.html#a8">PIN_NO_READ</a> and <a class="code" href="../../d4/d2/cache_8h.html#a7">PIN_EXCLUSIVE</a>, then he must
00823             guarantee that no one <span class="keywordflow">else</span> will be attempting to map <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> view, <span class="keywordflow">if</span> he
00824             wants to guarantee that <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Bcb <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> not mapped (view may be purged).
00825             If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller specifies <a class="code" href="../../d4/d2/cache_8h.html#a8">PIN_NO_READ</a> without <a class="code" href="../../d4/d2/cache_8h.html#a7">PIN_EXCLUSIVE</a>, <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data
00826             may or may not be mapped in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <span class="keywordflow">return</span> Bcb.
00827 
00828     Bcb - This returns a pointer to a Bcb parameter which must be
00829           supplied as input to CcPinWriteComplete.
00830 
00831     <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> - Returns pointer to desired data, valid until <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> buffer <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a>
00832              unpinned or freed.
00833 
00834 Return Value:
00835 
00836     <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> - <span class="keywordflow">if</span> Wait was not set and <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data was not delivered
00837 
00838     <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> - <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> pages are being delivered
00839 
00840 --*/
00841 
00842 {
00843     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap;
00844     PVOID LocalBuffer;
00845     LARGE_INTEGER BeyondLastByte;
00846     LARGE_INTEGER LocalFileOffset = *FileOffset;
00847     <a class="code" href="../../d6/d4/struct__OBCB.html">POBCB</a> MyBcb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00848     <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> *CurrentBcbPtr = (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> *)&amp;MyBcb;
00849     ULONG OriginalLength = Length;
00850     BOOLEAN Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00851 
00852     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, me, <span class="stringliteral">"CcPreparePinWrite\n"</span>, 0 );
00853 
00854     <span class="comment">//</span>
00855     <span class="comment">//  Get pointer to SharedCacheMap.</span>
00856     <span class="comment">//</span>
00857 
00858     SharedCacheMap = *(<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> *)((PCHAR)FileObject-&gt;SectionObjectPointer
00859                                             + <span class="keyword">sizeof</span>(PVOID));
00860 
00861     <span class="keywordflow">try</span> {
00862 
00863         <span class="comment">//</span>
00864         <span class="comment">//  Form loop to handle occassional overlapped Bcb case.</span>
00865         <span class="comment">//</span>
00866 
00867         <span class="keywordflow">do</span> {
00868 
00869             <span class="comment">//</span>
00870             <span class="comment">//  If we have already been through the loop, then adjust</span>
00871             <span class="comment">//  our file offset and length from the last time.</span>
00872             <span class="comment">//</span>
00873 
00874             <span class="keywordflow">if</span> (MyBcb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00875 
00876                 <span class="comment">//</span>
00877                 <span class="comment">//  If this is the second time through the loop, then it is time</span>
00878                 <span class="comment">//  to handle the overlap case and allocate an OBCB.</span>
00879                 <span class="comment">//</span>
00880 
00881                 <span class="keywordflow">if</span> (CurrentBcbPtr == (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> *)&amp;MyBcb) {
00882 
00883                     MyBcb = <a class="code" href="../../d2/d9/pinsup_8c.html#a1">CcAllocateObcb</a>( FileOffset, Length, (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)MyBcb );
00884 
00885                     <span class="comment">//</span>
00886                     <span class="comment">//  Set CurrentBcbPtr to point at the first entry in</span>
00887                     <span class="comment">//  the vector (which is already filled in), before</span>
00888                     <span class="comment">//  advancing it below.</span>
00889                     <span class="comment">//</span>
00890 
00891                     CurrentBcbPtr = &amp;MyBcb-&gt;<a class="code" href="../../d6/d4/struct__OBCB.html#o4">Bcbs</a>[0];
00892 
00893                     <span class="comment">//</span>
00894                     <span class="comment">//  Also on second time through, return starting Buffer</span>
00895                     <span class="comment">//</span>
00896 
00897                     *<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> = LocalBuffer;
00898                 }
00899 
00900                 Length -= (ULONG)(BeyondLastByte.QuadPart - LocalFileOffset.QuadPart);
00901                 LocalFileOffset.QuadPart = BeyondLastByte.QuadPart;
00902                 CurrentBcbPtr += 1;
00903             }
00904 
00905             <span class="comment">//</span>
00906             <span class="comment">//  Call local routine to Map or Access the file data.  If we cannot map</span>
00907             <span class="comment">//  the data because of a Wait condition, return FALSE.</span>
00908             <span class="comment">//</span>
00909 
00910             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/cc_8h.html#a175">CcPinFileData</a>( FileObject,
00911                                 &amp;LocalFileOffset,
00912                                 Length,
00913                                 FALSE,
00914                                 TRUE,
00915                                 Flags,
00916                                 CurrentBcbPtr,
00917                                 &amp;LocalBuffer,
00918                                 &amp;BeyondLastByte )) {
00919 
00920                 <a class="code" href="../../d5/d5/cc_8h.html#a90">try_return</a>( Result = FALSE );
00921             }
00922 
00923         <span class="comment">//</span>
00924         <span class="comment">//  Continue looping if we did not get everything.</span>
00925         <span class="comment">//</span>
00926 
00927         } <span class="keywordflow">while</span>((BeyondLastByte.QuadPart - LocalFileOffset.QuadPart) &lt; Length);
00928 
00929         *Bcb = MyBcb;
00930 
00931         <span class="comment">//</span>
00932         <span class="comment">//  Debug routines used to insert and remove Bcbs from the global list</span>
00933         <span class="comment">//</span>
00934 
00935 <span class="preprocessor">#if LIST_DBG</span>
00936 <span class="preprocessor"></span>
00937         {
00938             KIRQL OldIrql;
00939             <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> BcbTemp = (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)*Bcb;
00940 
00941             ExAcquireSpinLock( &amp;CcBcbSpinLock, &amp;OldIrql );
00942 
00943             <span class="keywordflow">if</span> (BcbTemp-&gt;CcBcbLinks.Flink == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00944 
00945                 InsertTailList( &amp;CcBcbList, &amp;BcbTemp-&gt;CcBcbLinks );
00946                 CcBcbCount += 1;
00947                 ExReleaseSpinLock( &amp;CcBcbSpinLock, OldIrql );
00948                 SetCallersAddress( BcbTemp );
00949 
00950             } <span class="keywordflow">else</span> {
00951                 ExReleaseSpinLock( &amp;CcBcbSpinLock, OldIrql );
00952             }
00953 
00954         }
00955 
00956 <span class="preprocessor">#endif</span>
00957 <span class="preprocessor"></span>
00958         <span class="comment">//</span>
00959         <span class="comment">//  In the normal (nonoverlapping) case we return the</span>
00960         <span class="comment">//  correct buffer address here.</span>
00961         <span class="comment">//</span>
00962 
00963         <span class="keywordflow">if</span> (CurrentBcbPtr == (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> *)&amp;MyBcb) {
00964             *<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> = LocalBuffer;
00965         }
00966 
00967         <span class="keywordflow">if</span> (<a class="code" href="../../d6/d6/ttime_8c.html#a0">Zero</a>) {
00968             RtlZeroMemory( *Buffer, OriginalLength );
00969         }
00970 
00971         <a class="code" href="../../d4/d2/cache_8h.html#a91">CcSetDirtyPinnedData</a>( MyBcb, NULL );
00972 
00973         Result = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00974 
00975     try_exit: NOTHING;
00976     }
00977     finally {
00978 
00979         <a class="code" href="../../d5/d2/cachedat_8c.html#a75">CcMissCounter</a> = &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a43">CcThrowAway</a>;
00980 
00981         <span class="keywordflow">if</span> (!Result) {
00982 
00983             <span class="comment">//</span>
00984             <span class="comment">//  We may have gotten partway through</span>
00985             <span class="comment">//</span>
00986 
00987             <span class="keywordflow">if</span> (MyBcb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00988                 <a class="code" href="../../d4/d2/cache_8h.html#a92">CcUnpinData</a>( MyBcb );
00989             }
00990         }
00991 
00992         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, me, <span class="stringliteral">"CcPreparePinWrite -&gt; %02lx\n"</span>, Result );
00993     }
00994 
00995     <span class="keywordflow">return</span> Result;
00996 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a61" doxytag="cache.h::CcPurgeCacheSection" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTKERNELAPI BOOLEAN CcPurgeCacheSection           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d7/d0/struct__SECTION__OBJECT__POINTERS.html">PSECTION_OBJECT_POINTERS</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>SectionObjectPointer</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PLARGE_INTEGER FileOffset&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Length</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN BOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>UninitializeCacheMaps</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d7/fssup_8c-source.html#l02331">2331</a> of file <a class="el" href="../../d6/d7/fssup_8c-source.html">fssup.c</a>.
<p>
References <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00064">CcAcquireMasterLock</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00067">CcCollisionDelay</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01010">CcDecrementOpenCount</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00031">CcDirtySharedCacheMapList</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l05885">CcFreeActiveVacb()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01003">CcIncrementOpenCount</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00067">CcReleaseMasterLock</a>, <a class="el" href="../../d6/d0/lazyrite_8c-source.html#l00049">CcScheduleLazyWriteScan()</a>, <a class="el" href="../../d4/d2/cache_8h.html#a59">CcUninitializeCacheMap()</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l01784">CcUnmapVacbArray()</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l01062">CcWaitOnActiveCount()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02290">DebugTrace</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02292">DebugTrace2</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00846">_SHARED_CACHE_MAP::DirtyPages</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00652">_PRIVATE_CACHE_MAP::FileObject</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00497">FlagOn</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00832">_SHARED_CACHE_MAP::Flags</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01588">GetActiveVacbAtDpcLevel</a>, <a class="el" href="../../d2/d6/wait_8c-source.html#l00140">KeDelayExecutionThread()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00624">KernelMode</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00129">LazyWriter</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l00033">me</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00462">mm</a>, <a class="el" href="../../d6/d4/sectsup_8c-source.html#l02552">MmCanFileBeTruncated()</a>, <a class="el" href="../../d7/d4/flushsec_8c-source.html#l01548">MmPurgeSection()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00740">_SHARED_CACHE_MAP::OpenCount</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01471">_LAZY_WRITER::OtherWork</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00599">PAGE_SIZE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00911">_SHARED_CACHE_MAP::PrivateList</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01464">_LAZY_WRITER::ScanActive</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01113">_SHARED_CACHE_MAP_LIST_CURSOR::SharedCacheMapLinks</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00826">_SHARED_CACHE_MAP::SharedCacheMapLinks</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00789">_SHARED_CACHE_MAP::Vacbs</a>, <a class="el" href="../../d2/d7/hal_8h.html#a212">VOID()</a>, and <a class="el" href="../../d6/d4/cc_8h-source.html#l01051">WRITE_QUEUED</a>.
<p>
Referenced by <a class="el" href="../../d6/d7/fssup_8c-source.html#l02194">CcPurgeAndClearCacheSection()</a>, <a class="el" href="../../d6/d7/fssup_8c-source.html#l01821">CcSetFileSizes()</a>, <a class="el" href="../../d6/d7/fssup_8c-source.html#l01164">CcUninitializeCacheMap()</a>, <a class="el" href="../../d6/d7/fssup_8c-source.html#l02563">CcUnmapAndPurge()</a>, <a class="el" href="../../d6/d7/fssup_8c-source.html#l02804">CcZeroEndOfLastPage()</a>, <a class="el" href="../../d9/d1/udfs_2cachesup_8c-source.html#l00417">UdfPurgeVolume()</a>, and <a class="el" href="../../d0/d7/udfs_2strucsup_8c-source.html#l00477">UdfUpdateVcbPhase0()</a>.
<p>
<pre class="fragment"><div>02340                    :
02341 
02342     This routine may be called to force a purge of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> cache section,
02343     even <span class="keywordflow">if</span> <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> cached.  Note, <span class="keywordflow">if</span> a user has <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> mapped, then <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> purge
02344     will *not* take effect, and <span class="keyword">this</span> must be considered part of normal application
02345     interaction.  The purpose of purge <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> to <span class="keywordflow">throw</span> away potentially nonzero
02346     data, so that <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> will be read in again and presumably zeroed.  This <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a>
02347     not really a security issue, but rather an effort to not confuse <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
02348     application when <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> sees nonzero data.  We cannot <a class="code" href="../../d7/d4/conexts_8c.html#a23">help</a> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> fact that
02349     a user-mapped view forces us to hang on to stale data.
02350 
02351     This routine <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> intended to be called whenever previously written
02352     data <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> being truncated from <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a>, and <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> not being
02353     deleted.
02354 
02355     The <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> must be acquired exclusive in order to call <span class="keyword">this</span> routine.
02356 
02357 Arguments:
02358 
02359     SectionObjectPointer - <a class="code" href="../../d2/d1/bench_8h.html#a5">A</a> pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Section Object Pointers
02360                            structure in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> nonpaged Fcb.
02361 
02362     FileOffset - <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> from which <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> should be purged - rounded down
02363                to page boundary.  If <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, purge <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> entire <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a>.
02364 
02365     Length - Defines <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> length of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> byte range to purge, starting at
02366              FileOffset.  This parameter <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> ignored <span class="keywordflow">if</span> FileOffset <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a>
02367              specified as <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>.  If FileOffset <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> specified and Length
02368              <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> 0, then purge from FileOffset to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> end of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a>.
02369 
02370     UninitializeCacheMaps - If <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, we should uninitialize all <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <span class="keyword">private</span>
02371                             cache maps before purging <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data.
02372 
02373 ReturnValue:
02374 
02375     <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> - <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> section was not successfully purged
02376     <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> - <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> section was successfully purged
02377 
02378 --*/
02379 
02380 {
02381     KIRQL OldIrql;
02382     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap;
02383     <a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html">PPRIVATE_CACHE_MAP</a> PrivateCacheMap;
02384     ULONG ActivePage;
02385     ULONG PageIsDirty;
02386     BOOLEAN PurgeWorked = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02387     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> Vacb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02388 
02389     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, me, <span class="stringliteral">"CcPurgeCacheSection:\n"</span>, 0 );
02390     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, mm, <span class="stringliteral">"    SectionObjectPointer = %08lx\n"</span>, SectionObjectPointer );
02391     <a class="code" href="../../d5/d5/cc_8h.html#a92">DebugTrace2</a>(0, me, <span class="stringliteral">"    FileOffset = %08lx, %08lx\n"</span>,
02392                             ARGUMENT_PRESENT(FileOffset) ? FileOffset-&gt;LowPart
02393                                                          : 0,
02394                             ARGUMENT_PRESENT(FileOffset) ? FileOffset-&gt;HighPart
02395                                                          : 0 );
02396     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, me, <span class="stringliteral">"    Length = %08lx\n"</span>, Length );
02397 
02398 
02399     <span class="comment">//</span>
02400     <span class="comment">//  If you want us to uninitialize cache maps, the RtlZeroMemory paths</span>
02401     <span class="comment">//  below depend on actually having to purge something after zeroing.</span>
02402     <span class="comment">//</span>
02403 
02404     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(!UninitializeCacheMaps || (Length == 0) || (Length &gt;= PAGE_SIZE * 2));
02405 
02406     <span class="comment">//</span>
02407     <span class="comment">//  Serialize Creation/Deletion of all Shared CacheMaps</span>
02408     <span class="comment">//</span>
02409 
02410     <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
02411 
02412     <span class="comment">//</span>
02413     <span class="comment">//  Get pointer to SharedCacheMap via File Object.</span>
02414     <span class="comment">//</span>
02415 
02416     SharedCacheMap = SectionObjectPointer-&gt;SharedCacheMap;
02417 
02418     <span class="comment">//</span>
02419     <span class="comment">//  Increment open count to make sure the SharedCacheMap stays around,</span>
02420     <span class="comment">//  then release the spinlock so that we can call Mm.</span>
02421     <span class="comment">//</span>
02422 
02423     <span class="keywordflow">if</span> (SharedCacheMap != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02424 
02425         <a class="code" href="../../d5/d5/cc_8h.html#a68">CcIncrementOpenCount</a>( SharedCacheMap, 'scPS' );
02426 
02427         <span class="comment">//</span>
02428         <span class="comment">//  If there is an active Vacb, then nuke it now (before waiting!).</span>
02429         <span class="comment">//</span>
02430 
02431         <a class="code" href="../../d5/d5/cc_8h.html#a83">GetActiveVacbAtDpcLevel</a>( SharedCacheMap, Vacb, ActivePage, PageIsDirty );
02432     }
02433 
02434     <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
02435 
02436     <span class="keywordflow">if</span> (Vacb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02437 
02438         <a class="code" href="../../d5/d5/cc_8h.html#a182">CcFreeActiveVacb</a>( SharedCacheMap, Vacb, ActivePage, PageIsDirty );
02439     }
02440 
02441     <span class="comment">//</span>
02442     <span class="comment">//  Use try-finally to insure cleanup of the Open Count and Vacb on the</span>
02443     <span class="comment">//  way out.</span>
02444     <span class="comment">//</span>
02445 
02446     <span class="keywordflow">try</span> {
02447 
02448         <span class="comment">//</span>
02449         <span class="comment">//  Increment open count to make sure the SharedCacheMap stays around,</span>
02450         <span class="comment">//  then release the spinlock so that we can call Mm.</span>
02451         <span class="comment">//</span>
02452 
02453         <span class="keywordflow">if</span> (SharedCacheMap != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02454 
02455             <span class="comment">//</span>
02456             <span class="comment">// Now loop to make sure that no one is currently caching the file.</span>
02457             <span class="comment">//</span>
02458 
02459             <span class="keywordflow">if</span> (UninitializeCacheMaps) {
02460 
02461                 <span class="keywordflow">while</span> (!IsListEmpty( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o29">PrivateList</a> )) {
02462 
02463                     PrivateCacheMap = CONTAINING_RECORD( SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o29">PrivateList</a>.Flink,
02464                                                          <a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html">PRIVATE_CACHE_MAP</a>,
02465                                                          PrivateLinks );
02466 
02467                     <a class="code" href="../../d4/d2/cache_8h.html#a59">CcUninitializeCacheMap</a>( PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o2">FileObject</a>, NULL, NULL );
02468                 }
02469             }
02470 
02471             <span class="comment">//</span>
02472             <span class="comment">//  Now, let's unmap and purge here.</span>
02473             <span class="comment">//</span>
02474             <span class="comment">//  We still need to wait for any dangling cache read or writes.</span>
02475             <span class="comment">//</span>
02476             <span class="comment">//  In fact we have to loop and wait because the lazy writer can</span>
02477             <span class="comment">//  sneak in and do an CcGetVirtualAddressIfMapped, and we are not</span>
02478             <span class="comment">//  synchronized.</span>
02479             <span class="comment">//</span>
02480 
02481             <span class="keywordflow">while</span> ((SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o9">Vacbs</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
02482                    !<a class="code" href="../../d5/d3/vacbsup_8c.html#a22">CcUnmapVacbArray</a>( SharedCacheMap, FileOffset, Length, FALSE )) {
02483 
02484                 <a class="code" href="../../d5/d3/vacbsup_8c.html#a19">CcWaitOnActiveCount</a>( SharedCacheMap );
02485             }
02486         }
02487 
02488         <span class="comment">//</span>
02489         <span class="comment">//  Purge failures are extremely rare if there are no user mapped sections.</span>
02490         <span class="comment">//  However, it is possible that we will get one from our own mapping, if</span>
02491         <span class="comment">//  the file is being lazy deleted from a previous open.  For that case</span>
02492         <span class="comment">//  we wait here until the purge succeeds, so that we are not left with</span>
02493         <span class="comment">//  old user file data.  Although Length is actually invariant in this loop,</span>
02494         <span class="comment">//  we do need to keep checking that we are allowed to truncate in case a</span>
02495         <span class="comment">//  user maps the file during a delay.</span>
02496         <span class="comment">//</span>
02497 
02498         <span class="keywordflow">while</span> (!(PurgeWorked = <a class="code" href="../../d6/d5/flushsec_8c.html#a12">MmPurgeSection</a>(SectionObjectPointer,
02499                                               FileOffset,
02500                                               Length,
02501                                               (BOOLEAN)((SharedCacheMap !=NULL) &amp;&amp;
02502                                                         ARGUMENT_PRESENT(FileOffset)))) &amp;&amp;
02503                (Length == 0) &amp;&amp;
02504                <a class="code" href="../../d5/d5/sectsup_8c.html#a30">MmCanFileBeTruncated</a>(SectionObjectPointer, FileOffset)) {
02505 
02506             (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>)<a class="code" href="../../d1/d7/wait_8c.html#a2">KeDelayExecutionThread</a>( KernelMode, FALSE, &amp;CcCollisionDelay );
02507         }
02508     
02509     } finally {
02510 
02511         <span class="comment">//</span>
02512         <span class="comment">//  Reduce the open count on the SharedCacheMap if there was one.</span>
02513         <span class="comment">//</span>
02514 
02515         <span class="keywordflow">if</span> (SharedCacheMap != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02516 
02517             <span class="comment">//</span>
02518             <span class="comment">//  Serialize again to decrement the open count.</span>
02519             <span class="comment">//</span>
02520 
02521             <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
02522 
02523             <a class="code" href="../../d5/d5/cc_8h.html#a69">CcDecrementOpenCount</a>( SharedCacheMap, 'scPF' );
02524 
02525             <span class="keywordflow">if</span> ((SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o2">OpenCount</a> == 0) &amp;&amp;
02526                 !<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, WRITE_QUEUED) &amp;&amp;
02527                 (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o20">DirtyPages</a> == 0)) {
02528 
02529                 <span class="comment">//</span>
02530                 <span class="comment">//  Move to the dirty list.</span>
02531                 <span class="comment">//</span>
02532 
02533                 RemoveEntryList( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a> );
02534                 InsertTailList( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a2">CcDirtySharedCacheMapList</a>.<a class="code" href="../../d1/d3/struct__SHARED__CACHE__MAP__LIST__CURSOR.html#o0">SharedCacheMapLinks</a>,
02535                                 &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a> );
02536 
02537                 <span class="comment">//</span>
02538                 <span class="comment">//  Make sure the Lazy Writer will wake up, because we</span>
02539                 <span class="comment">//  want him to delete this SharedCacheMap.</span>
02540                 <span class="comment">//</span>
02541 
02542                 <a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o6">OtherWork</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02543                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o5">ScanActive</a>) {
02544                     <a class="code" href="../../d5/d5/cc_8h.html#a185">CcScheduleLazyWriteScan</a>();
02545                 }
02546             }
02547 
02548             <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
02549         }
02550     }
02551 
02552     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, me, <span class="stringliteral">"CcPurgeCacheSection -&gt; %02lx\n"</span>, PurgeWorked );
02553 
02554     <span class="keywordflow">return</span> PurgeWorked;
02555 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a67" doxytag="cache.h::CcRemapBcb" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTKERNELAPI PVOID CcRemapBcb           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>Bcb</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d7/d1/cachesub_8c-source.html#l05024">5024</a> of file <a class="el" href="../../d7/d1/cachesub_8c-source.html">cachesub.c</a>.
<p>
References <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00155">CACHE_NTC_BCB</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00158">CACHE_NTC_OBCB</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00076">CcAcquireVacbLock</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00083">CcBeyondVacbs</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00079">CcReleaseVacbLock</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00082">CcVacbs</a>, and <a class="el" href="../../d2/d5/struct__VACB.html#o4">_VACB::Overlay</a>.
<p>
<pre class="fragment"><div>05030                    :
05031 
05032     This routine may be called by a <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> system to map a Bcb an additional
05033     time in order to preserve <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> through several calls that perform additional
05034     maps and unpins.
05035 
05036 
05037 Arguments:
05038 
05039     Bcb - Supplies a pointer to a previously returned Bcb.
05040 
05041 Return Value:
05042 
05043     Bcb with read-<a class="code" href="../../d3/d0/imm32_8def.html#a1">only</a> indicator.
05044 
05045 --*/
05046 
05047 {
05048     KIRQL OldIrql;
05049     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> Vacb;
05050 
05051     <span class="comment">//</span>
05052     <span class="comment">//  Remove read-only bit</span>
05053     <span class="comment">//</span>
05054 
05055     Bcb = (PVOID) ((ULONG_PTR)Bcb &amp; ~1);
05056 
05057     <span class="keywordflow">if</span> (((<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)Bcb)-&gt;NodeTypeCode == <a class="code" href="../../d5/d5/cc_8h.html#a17">CACHE_NTC_OBCB</a>) {
05058 
05059         <span class="comment">//</span>
05060         <span class="comment">//  If this is an overlapped BCB, use the first Vacb in the</span>
05061         <span class="comment">//  array</span>
05062         <span class="comment">//</span>
05063 
05064         Vacb = ((<a class="code" href="../../d6/d4/struct__OBCB.html">POBCB</a>)Bcb)-&gt;Bcbs[0]-&gt;Vacb;
05065 
05066     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (((<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)Bcb)-&gt;NodeTypeCode == <a class="code" href="../../d5/d5/cc_8h.html#a14">CACHE_NTC_BCB</a>) {
05067 
05068         <span class="comment">//</span>
05069         <span class="comment">//  If this is a BCB, extract the Vcb from it</span>
05070         <span class="comment">//</span>
05071 
05072         Vacb = ((<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)Bcb)-&gt;Vacb;
05073 
05074     } <span class="keywordflow">else</span> {
05075 
05076         <span class="comment">//</span>
05077         <span class="comment">//  Otherwise, there is no signature to match. Assume</span>
05078         <span class="comment">//  it is a Vacb.</span>
05079         <span class="comment">//</span>
05080 
05081         Vacb = (<a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a>) Bcb;
05082     }
05083 
05084     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>((Vacb &gt;= CcVacbs) &amp;&amp; (Vacb &lt; CcBeyondVacbs));
05085 
05086     <span class="comment">//</span>
05087     <span class="comment">//  Safely bump the active count</span>
05088     <span class="comment">//</span>
05089 
05090     <a class="code" href="../../d5/d5/cc_8h.html#a4">CcAcquireVacbLock</a>( &amp;OldIrql );
05091 
05092     Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o4">Overlay</a>.ActiveCount += 1;
05093 
05094     <a class="code" href="../../d5/d5/cc_8h.html#a5">CcReleaseVacbLock</a>( OldIrql );
05095 
05096     <span class="keywordflow">return</span> (PVOID) ((ULONG_PTR)Vacb | 1);
05097 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a68" doxytag="cache.h::CcRepinBcb" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTKERNELAPI VOID CcRepinBcb           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>Bcb</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d7/d1/cachesub_8c-source.html#l05101">5101</a> of file <a class="el" href="../../d7/d1/cachesub_8c-source.html">cachesub.c</a>.
<p>
<pre class="fragment"><div>05107                    :
05108 
05109     This routine may be called by a <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> system to pin a Bcb an additional
05110     time in order to reserve <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> <span class="keywordflow">for</span> Write Through or error recovery.
05111     Typically <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> system would <span class="keywordflow">do</span> <span class="keyword">this</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> first time that <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> sets a
05112     pinned buffer dirty <span class="keywordflow">while</span> processing a WriteThrough request, or any
05113     time that <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> determines that a buffer will be required <span class="keywordflow">for</span> WriteThrough.
05114 
05115     The call to <span class="keyword">this</span> routine must be followed by a call to <a class="code" href="../../d6/d2/cachesub_8c.html#a24">CcUnpinRepinnedBcb</a>.
05116     <a class="code" href="../../d6/d2/cachesub_8c.html#a24">CcUnpinRepinnedBcb</a> should normally be called during request completion
05117     after all other resources have been released.  <a class="code" href="../../d6/d2/cachesub_8c.html#a24">CcUnpinRepinnedBcb</a>
05118     synchronously writes <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> buffer (<span class="keywordflow">for</span> WriteThrough requests) and performs
05119     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d7/d1/genuedef_8c.html#a7">matching</a> unpin <span class="keywordflow">for</span> <span class="keyword">this</span> call.
05120 
05121 Arguments:
05122 
05123     Bcb - Supplies a pointer to a previously pinned Bcb
05124 
05125 Return Value:
05126 
05127     None.
05128 
05129 --*/
05130 
05131 {
05132     KIRQL OldIrql;
05133 
05134     ExAcquireFastLock( &amp;((<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)Bcb)-&gt;SharedCacheMap-&gt;BcbSpinLock, &amp;OldIrql );
05135 
05136     ((<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)Bcb)-&gt;PinCount += 1;
05137 
05138     ExReleaseFastLock( &amp;((<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)Bcb)-&gt;SharedCacheMap-&gt;BcbSpinLock, OldIrql );
05139 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a84" doxytag="cache.h::CcScheduleReadAhead" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTKERNELAPI VOID CcScheduleReadAhead           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>FileObject</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PLARGE_INTEGER&nbsp;</td>
          <td class="mdname" nowrap> <em>FileOffset</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Length</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d7/d1/cachesub_8c-source.html#l01253">1253</a> of file <a class="el" href="../../d7/d1/cachesub_8c-source.html">cachesub.c</a>.
<p>
References <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00662">_PRIVATE_CACHE_MAP::BeyondLastByte1</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00665">_PRIVATE_CACHE_MAP::BeyondLastByte2</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00064">CcAcquireMasterLock</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01847">CcAllocateWorkQueueEntry</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00052">CcExpressWorkQueue</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01003">CcIncrementOpenCount</a>, <a class="el" href="../../d6/d0/lazyrite_8c-source.html#l00662">CcPostWorkQueue()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00067">CcReleaseMasterLock</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02290">DebugTrace</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02292">DebugTrace2</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01025">DISABLE_READ_AHEAD</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00661">_PRIVATE_CACHE_MAP::FileOffset1</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00664">_PRIVATE_CACHE_MAP::FileOffset2</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00497">FlagOn</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00832">_SHARED_CACHE_MAP::Flags</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01495">FO_SEQUENTIAL_ONLY</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01535">_WORK_QUEUE_ENTRY::Function</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l00033">me</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00423">NOISE_BITS</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00514">ObReferenceObject</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00599">PAGE_SIZE</a>, <a class="el" href="../../d2/d9/struct__WORK__QUEUE__ENTRY.html#o7">_WORK_QUEUE_ENTRY::Parameters</a>, <a class="el" href="../../d5/d5/cc_8h.html#a118">PWORK_QUEUE_ENTRY</a>, <a class="el" href="../../d5/d5/cc_8h.html#a210a167">ReadAhead</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00705">_PRIVATE_CACHE_MAP::ReadAheadActive</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00677">_PRIVATE_CACHE_MAP::ReadAheadLength</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00689">_PRIVATE_CACHE_MAP::ReadAheadMask</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00676">_PRIVATE_CACHE_MAP::ReadAheadOffset</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00683">_PRIVATE_CACHE_MAP::ReadAheadSpinLock</a>, <a class="el" href="../../d3/d0/mm_8h-source.html#l00117">ROUND_TO_PAGES</a>, and <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>.
<p>
Referenced by <a class="el" href="../../d6/d6/copysup_8c-source.html#l00031">CcCopyRead()</a>, <a class="el" href="../../d6/d6/copysup_8c-source.html#l00588">CcFastCopyRead()</a>, and <a class="el" href="../../d8/d4/mdlsup_8c-source.html#l00030">CcMdlRead()</a>.
<p>
<pre class="fragment"><div>01261                    :
01262 
01263     This routine <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> called by <a class="code" href="../../d9/d0/cmdata_8h.html#a104a97">Copy</a> Read and Mdl Read <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> system <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a24">routines</a> to
01264     perform common Read Ahead processing.  The input parameters describe
01265     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> current read which has just been completed, or perhaps <a class="code" href="../../d3/d0/imm32_8def.html#a1">only</a> started
01266     in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <span class="keywordflow">case</span> of Mdl Reads.  Based on these parameters, an
01267     assessment <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> <a class="code" href="../../d3/d0/user32_8def.html#a107">made</a> on how much data should be read ahead, and whether
01268     that data has already been read ahead.
01269 
01270     The processing <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> divided into two parts:
01271 
01272         CALCULATE READ AHEAD REQUIREMENTS   (CcScheduleReadAhead)
01273 
01274         PERFORM READ AHEAD                  (CcPerformReadAhead)
01275 
01276     File systems should always call CcReadAhead, which will conditionally
01277     call CcScheduleReadAhead (if the read is large enough).  If such a call
01278     determines that there is read ahead work to do, and no read ahead is
01279     currently active, then it will set ReadAheadActive and schedule read
01280     ahead to be peformed by the Lazy Writer, who will call CcPeformReadAhead.
01281 
01282 Arguments:
01283 
01284     FileObject - supplies pointer to FileObject on which readahead should be
01285                  considered.
01286 
01287     FileOffset - supplies the FileOffset at which the last read just occurred.
01288 
01289     Length - supplies the length of the last read.
01290 
01291 Return Value:
01292 
01293     None
01294 --*/
01295 
01296 {
01297     LARGE_INTEGER NewOffset;
01298     LARGE_INTEGER NewBeyond;
01299     LARGE_INTEGER FileOffset1, FileOffset2;
01300     KIRQL OldIrql;
01301     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap;
01302     <a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html">PPRIVATE_CACHE_MAP</a> PrivateCacheMap;
01303     <a class="code" href="../../d2/d9/struct__WORK__QUEUE__ENTRY.html">PWORK_QUEUE_ENTRY</a> WorkQueueEntry;
01304     ULONG ReadAheadSize;
01305     BOOLEAN Changed = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01306 
01307     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, me, <span class="stringliteral">"CcScheduleReadAhead:\n"</span>, 0 );
01308     <a class="code" href="../../d5/d5/cc_8h.html#a92">DebugTrace2</a>(0, me, <span class="stringliteral">"    FileOffset = %08lx, %08lx\n"</span>, FileOffset-&gt;LowPart,
01309                                                           FileOffset-&gt;HighPart );
01310     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, me, <span class="stringliteral">"    Length = %08lx\n"</span>, Length );
01311 
01312     SharedCacheMap = *(<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> *)((PCHAR)FileObject-&gt;SectionObjectPointer
01313                                             + <span class="keyword">sizeof</span>(PVOID));
01314     PrivateCacheMap = FileObject-&gt;PrivateCacheMap;
01315 
01316     <span class="keywordflow">if</span> ((PrivateCacheMap == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) ||
01317         (SharedCacheMap == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) ||
01318         <a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, DISABLE_READ_AHEAD)) {
01319 
01320         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, me, <span class="stringliteral">"CcScheduleReadAhead -&gt; VOID (Nooped)\n"</span>, 0 );
01321 
01322         <span class="keywordflow">return</span>;
01323     }
01324 
01325     <span class="comment">//</span>
01326     <span class="comment">//  Round boundaries of transfer up to some greater granularity, so that</span>
01327     <span class="comment">//  sequential reads will be recognized even if a few bytes are skipped</span>
01328     <span class="comment">//  between records.</span>
01329     <span class="comment">//</span>
01330 
01331     NewOffset = *FileOffset;
01332     NewBeyond.QuadPart = FileOffset-&gt;QuadPart + (LONGLONG)Length;
01333 
01334     <span class="comment">//</span>
01335     <span class="comment">//  Find the next read ahead boundary beyond the current read.</span>
01336     <span class="comment">//</span>
01337 
01338     ReadAheadSize = (Length + PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o10">ReadAheadMask</a>) &amp; ~PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o10">ReadAheadMask</a>;
01339     FileOffset2.QuadPart = NewBeyond.QuadPart + (LONGLONG)ReadAheadSize;
01340     FileOffset2.LowPart &amp;= ~PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o10">ReadAheadMask</a>;
01341 
01342     <span class="comment">//</span>
01343     <span class="comment">//  CALCULATE READ AHEAD REQUIREMENTS</span>
01344     <span class="comment">//</span>
01345 
01346     <span class="comment">//</span>
01347     <span class="comment">//  Take out the ReadAhead spinlock to synchronize our read ahead decision.</span>
01348     <span class="comment">//</span>
01349 
01350     ExAcquireSpinLock( &amp;PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o9">ReadAheadSpinLock</a>, &amp;OldIrql );
01351 
01352     <span class="comment">//</span>
01353     <span class="comment">//  Read Ahead Case 0.</span>
01354     <span class="comment">//</span>
01355     <span class="comment">//  Sequential-only hint in the file object.  For this case we will</span>
01356     <span class="comment">//  try and always keep two read ahead granularities read ahead from</span>
01357     <span class="comment">//  and including the end of the current transfer.  This case has the</span>
01358     <span class="comment">//  lowest overhead, and the code is completely immune to how the</span>
01359     <span class="comment">//  caller skips around.  Sequential files use ReadAheadOffset[1] in</span>
01360     <span class="comment">//  the PrivateCacheMap as their "high water mark".</span>
01361     <span class="comment">//</span>
01362 
01363     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(FileObject-&gt;Flags, FO_SEQUENTIAL_ONLY)) {
01364 
01365         <span class="comment">//</span>
01366         <span class="comment">//  If the next boundary is greater than or equal to the high-water mark,</span>
01367         <span class="comment">//  then read ahead.</span>
01368         <span class="comment">//</span>
01369 
01370         <span class="keywordflow">if</span> (FileOffset2.QuadPart &gt;= PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o7">ReadAheadOffset</a>[1].QuadPart) {
01371 
01372             <span class="comment">//</span>
01373             <span class="comment">//  On the first read if we are using a large read ahead granularity,</span>
01374             <span class="comment">//  and the read did not get it all, we will just get the rest of the</span>
01375             <span class="comment">//  first data we want.</span>
01376             <span class="comment">//</span>
01377 
01378             <span class="keywordflow">if</span> ((FileOffset-&gt;QuadPart == 0)
01379 
01380                     &amp;&amp;
01381 
01382                 (PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o10">ReadAheadMask</a> &gt; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1))
01383 
01384                     &amp;&amp;
01385 
01386                 ((Length + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1) &lt;= PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o10">ReadAheadMask</a>)) {
01387 
01388                 FileOffset1.QuadPart = (LONGLONG)( <a class="code" href="../../d2/d1/mm_8h.html#a4">ROUND_TO_PAGES</a>(Length) );
01389                 PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o8">ReadAheadLength</a>[0] = ReadAheadSize - FileOffset1.LowPart;
01390                 FileOffset2.QuadPart = (LONGLONG)ReadAheadSize;
01391 
01392             <span class="comment">//</span>
01393             <span class="comment">//  Calculate the next read ahead boundary.</span>
01394             <span class="comment">//</span>
01395 
01396             } <span class="keywordflow">else</span> {
01397 
01398                 FileOffset1.QuadPart = PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o7">ReadAheadOffset</a>[1].QuadPart +
01399                                        (LONGLONG)ReadAheadSize;
01400 
01401                 <span class="comment">//</span>
01402                 <span class="comment">//  If the end of the current read is actually beyond where we would</span>
01403                 <span class="comment">//  normally do our read ahead, then we have fallen behind, and we must</span>
01404                 <span class="comment">//  advance to that spot.</span>
01405                 <span class="comment">//</span>
01406 
01407                 <span class="keywordflow">if</span> (FileOffset2.QuadPart &gt; FileOffset1.QuadPart) {
01408                     FileOffset1 = FileOffset2;
01409                 }
01410                 PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o8">ReadAheadLength</a>[0] = ReadAheadSize;
01411                 FileOffset2.QuadPart = FileOffset1.QuadPart + (LONGLONG)ReadAheadSize;
01412             }
01413 
01414             <span class="comment">//</span>
01415             <span class="comment">//  Now issue the next two read aheads.</span>
01416             <span class="comment">//</span>
01417 
01418             PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o7">ReadAheadOffset</a>[0] = FileOffset1;
01419 
01420             PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o7">ReadAheadOffset</a>[1] = FileOffset2;
01421             PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o8">ReadAheadLength</a>[1] = ReadAheadSize;
01422 
01423             Changed = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01424         }
01425 
01426     <span class="comment">//</span>
01427     <span class="comment">//  Read Ahead Case 1.</span>
01428     <span class="comment">//</span>
01429     <span class="comment">//  If this is the third of three sequential reads, then we will see if</span>
01430     <span class="comment">//  we can read ahead.  Note that if the first read to a file is to</span>
01431     <span class="comment">//  offset 0, it passes this test.</span>
01432     <span class="comment">//</span>
01433 
01434     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((NewOffset.HighPart == PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o6">BeyondLastByte2</a>.HighPart)
01435 
01436             &amp;&amp;
01437 
01438         ((NewOffset.LowPart &amp; ~<a class="code" href="../../d5/d5/cc_8h.html#a52">NOISE_BITS</a>)
01439            == (PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o6">BeyondLastByte2</a>.LowPart &amp; ~<a class="code" href="../../d5/d5/cc_8h.html#a52">NOISE_BITS</a>))
01440 
01441             &amp;&amp;
01442 
01443         (PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o5">FileOffset2</a>.HighPart
01444            == PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o4">BeyondLastByte1</a>.HighPart)
01445 
01446             &amp;&amp;
01447 
01448         ((PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o5">FileOffset2</a>.LowPart &amp; ~<a class="code" href="../../d5/d5/cc_8h.html#a52">NOISE_BITS</a>)
01449            == (PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o4">BeyondLastByte1</a>.LowPart &amp; ~<a class="code" href="../../d5/d5/cc_8h.html#a52">NOISE_BITS</a>))) {
01450 
01451         <span class="comment">//</span>
01452         <span class="comment">//  On the first read if we are using a large read ahead granularity,</span>
01453         <span class="comment">//  and the read did not get it all, we will just get the rest of the</span>
01454         <span class="comment">//  first data we want.</span>
01455         <span class="comment">//</span>
01456 
01457         <span class="keywordflow">if</span> ((FileOffset-&gt;QuadPart == 0)
01458 
01459                 &amp;&amp;
01460 
01461             (PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o10">ReadAheadMask</a> &gt; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1))
01462 
01463                 &amp;&amp;
01464 
01465             ((Length + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1) &lt;= PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o10">ReadAheadMask</a>)) {
01466 
01467             FileOffset2.QuadPart = (LONGLONG)( <a class="code" href="../../d2/d1/mm_8h.html#a4">ROUND_TO_PAGES</a>(Length) );
01468         }
01469 
01470         <span class="comment">//</span>
01471         <span class="comment">//  Round read offset to next read ahead boundary.</span>
01472         <span class="comment">//</span>
01473 
01474         <span class="keywordflow">else</span> {
01475             FileOffset2.QuadPart = NewBeyond.QuadPart + (LONGLONG)ReadAheadSize;
01476 
01477             FileOffset2.LowPart &amp;= ~PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o10">ReadAheadMask</a>;
01478         }
01479 
01480         <span class="comment">//</span>
01481         <span class="comment">//  Set read ahead length to be the same as for the most recent read,</span>
01482         <span class="comment">//  up to our max.</span>
01483         <span class="comment">//</span>
01484 
01485         <span class="keywordflow">if</span> (FileOffset2.QuadPart != PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o7">ReadAheadOffset</a>[1].QuadPart) {
01486 
01487             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( FileOffset2.HighPart &gt;= 0 );
01488 
01489             Changed = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01490             PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o7">ReadAheadOffset</a>[1] = FileOffset2;
01491             PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o8">ReadAheadLength</a>[1] = ReadAheadSize;
01492         }
01493     }
01494 
01495     <span class="comment">//</span>
01496     <span class="comment">//  Read Ahead Case 2.</span>
01497     <span class="comment">//</span>
01498     <span class="comment">//  If this is the third read following a particular stride, then we</span>
01499     <span class="comment">//  will see if we can read ahead.  One example of an application that</span>
01500     <span class="comment">//  might do this is a spreadsheet.  Note that this code even works</span>
01501     <span class="comment">//  for negative strides.</span>
01502     <span class="comment">//</span>
01503 
01504     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ( NewOffset.QuadPart -
01505                 PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o5">FileOffset2</a>.QuadPart ) ==
01506               ( PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o5">FileOffset2</a>.QuadPart -
01507                 PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o3">FileOffset1</a>.QuadPart )) {
01508 
01509         <span class="comment">//</span>
01510         <span class="comment">//  According to the current stride, the next offset will be:</span>
01511         <span class="comment">//</span>
01512         <span class="comment">//      NewOffset + (NewOffset - FileOffset2)</span>
01513         <span class="comment">//</span>
01514         <span class="comment">//  which is the same as:</span>
01515         <span class="comment">//</span>
01516         <span class="comment">//      (NewOffset * 2) - FileOffset2</span>
01517         <span class="comment">//</span>
01518 
01519         FileOffset2.QuadPart = ( NewOffset.QuadPart &lt;&lt; 1 ) - PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o5">FileOffset2</a>.QuadPart;
01520 
01521         <span class="comment">//</span>
01522         <span class="comment">//  If our stride is going backwards through the file, we</span>
01523         <span class="comment">//  have to detect the case where the next step would wrap.</span>
01524         <span class="comment">//</span>
01525 
01526         <span class="keywordflow">if</span> (FileOffset2.HighPart &gt;= 0) {
01527 
01528             <span class="comment">//</span>
01529             <span class="comment">//  The read ahead length must be extended by the same amount that</span>
01530             <span class="comment">//  we will round the PrivateCacheMap-&gt;ReadAheadOffset down.</span>
01531             <span class="comment">//</span>
01532 
01533             Length += FileOffset2.LowPart &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1);
01534 
01535             <span class="comment">//</span>
01536             <span class="comment">//  Now round the PrivateCacheMap-&gt;ReadAheadOffset down.</span>
01537             <span class="comment">//</span>
01538 
01539             FileOffset2.LowPart &amp;= ~(<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1);
01540             PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o7">ReadAheadOffset</a>[1] = FileOffset2;
01541 
01542             <span class="comment">//</span>
01543             <span class="comment">//  Round to page boundary.</span>
01544             <span class="comment">//</span>
01545 
01546             PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o8">ReadAheadLength</a>[1] = (ULONG) <a class="code" href="../../d2/d1/mm_8h.html#a4">ROUND_TO_PAGES</a>(Length);
01547             Changed = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01548         }
01549     }
01550 
01551     <span class="comment">//</span>
01552     <span class="comment">//  Get out if the ReadAhead requirements did not change.</span>
01553     <span class="comment">//</span>
01554 
01555     <span class="keywordflow">if</span> (!Changed || PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o12">ReadAheadActive</a>) {
01556 
01557         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, me, <span class="stringliteral">"Read ahead already in progress or no change\n"</span>, 0 );
01558 
01559         ExReleaseSpinLock( &amp;PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o9">ReadAheadSpinLock</a>, OldIrql );
01560         <span class="keywordflow">return</span>;
01561     }
01562 
01563     <span class="comment">//</span>
01564     <span class="comment">//  Otherwise, we will proceed and try to schedule the read ahead</span>
01565     <span class="comment">//  ourselves.</span>
01566     <span class="comment">//</span>
01567 
01568     PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o12">ReadAheadActive</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01569 
01570     <span class="comment">//</span>
01571     <span class="comment">//  Release spin lock on way out</span>
01572     <span class="comment">//</span>
01573 
01574     ExReleaseSpinLock( &amp;PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o9">ReadAheadSpinLock</a>, OldIrql );
01575 
01576     <span class="comment">//</span>
01577     <span class="comment">//  Queue the read ahead request to the Lazy Writer's work queue.</span>
01578     <span class="comment">//</span>
01579 
01580     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, me, <span class="stringliteral">"Queueing read ahead to worker thread\n"</span>, 0 );
01581 
01582     WorkQueueEntry = <a class="code" href="../../d5/d5/cc_8h.html#a88">CcAllocateWorkQueueEntry</a>();
01583 
01584     <span class="comment">//</span>
01585     <span class="comment">//  If we failed to allocate a work queue entry, then, we will</span>
01586     <span class="comment">//  quietly bag it.  Read ahead is only an optimization, and</span>
01587     <span class="comment">//  no one ever requires that it occur.</span>
01588     <span class="comment">//</span>
01589 
01590     <span class="keywordflow">if</span> (WorkQueueEntry != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01591 
01592         <span class="comment">//</span>
01593         <span class="comment">//  We must reference this file object so that it cannot go away</span>
01594         <span class="comment">//  until we finish Read Ahead processing in the Worker Thread.</span>
01595         <span class="comment">//</span>
01596 
01597         <a class="code" href="../../d4/d0/ob_8h.html#a15">ObReferenceObject</a> ( FileObject );
01598 
01599         <span class="comment">//</span>
01600         <span class="comment">//  Increment open count to make sure the SharedCacheMap stays around.</span>
01601         <span class="comment">//</span>
01602 
01603         <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
01604         <a class="code" href="../../d5/d5/cc_8h.html#a68">CcIncrementOpenCount</a>( SharedCacheMap, 'adRQ' );
01605         <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
01606 
01607         WorkQueueEntry-&gt;<a class="code" href="../../d2/d9/struct__WORK__QUEUE__ENTRY.html#o8">Function</a> = (UCHAR)<a class="code" href="../../d5/d5/cc_8h.html#a210a167">ReadAhead</a>;
01608         WorkQueueEntry-&gt;<a class="code" href="../../d2/d9/struct__WORK__QUEUE__ENTRY.html#o7">Parameters</a>.Read.FileObject = FileObject;
01609 
01610         <a class="code" href="../../d5/d1/lazyrite_8c.html#a8">CcPostWorkQueue</a>( WorkQueueEntry, &amp;CcExpressWorkQueue );
01611     }
01612 
01613     <span class="comment">//</span>
01614     <span class="comment">//  If we failed to allocate a Work Queue Entry, or all of the pages</span>
01615     <span class="comment">//  are resident we must set the active flag false.</span>
01616     <span class="comment">//</span>
01617 
01618     <span class="keywordflow">else</span> {
01619 
01620         ExAcquireFastLock( &amp;PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o9">ReadAheadSpinLock</a>, &amp;OldIrql );
01621         PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o12">ReadAheadActive</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01622         ExReleaseFastLock( &amp;PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o9">ReadAheadSpinLock</a>, OldIrql );
01623     }
01624 
01625     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, me, <span class="stringliteral">"CcScheduleReadAhead -&gt; VOID\n"</span>, 0 );
01626 
01627     <span class="keywordflow">return</span>;
01628 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a95" doxytag="cache.h::CcSetAdditionalCacheAttributes" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTKERNELAPI VOID CcSetAdditionalCacheAttributes           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>FileObject</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN BOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>DisableReadAhead</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN BOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>DisableWriteBehind</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d9/d4/logsup_8c-source.html#l00032">32</a> of file <a class="el" href="../../d9/d4/logsup_8c-source.html">logsup.c</a>.
<p>
References <a class="el" href="../../d6/d4/cc_8h-source.html#l00064">CcAcquireMasterLock</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00067">CcReleaseMasterLock</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00509">ClearFlag</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01025">DISABLE_READ_AHEAD</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01031">DISABLE_WRITE_BEHIND</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00832">_SHARED_CACHE_MAP::Flags</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01077">MODIFIED_WRITE_DISABLED</a>, and <a class="el" href="../../d6/d4/cc_8h-source.html#l00505">SetFlag</a>.
<p>
Referenced by <a class="el" href="../../d1/d6/lfs_2registry_8c-source.html#l00150">LfsInitializeLogFile()</a>, and <a class="el" href="../../d1/d6/lfs_2registry_8c-source.html#l00366">LfsOpenLogFile()</a>.
<p>
<pre class="fragment"><div>00040                    :
00041 
00042     This routine supports <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> setting of disable read ahead or disable write
00043     behind flags to <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a58">control</a> Cache <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a79">Manager</a> operation.  This routine may be
00044     called any time after calling <a class="code" href="../../d5/d8/fssup_8c.html#a9">CcInitializeCacheMap</a>.  Initially both
00045     read ahead and write behind are enabled.  Note that <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> state of both
00046     of these flags must be specified on each call to <span class="keyword">this</span> routine.
00047 
00048 Arguments:
00049 
00050     FileObject - <a class="code" href="../../d1/d9/icmui_8def.html#a0">File</a> object <span class="keywordflow">for</span> which <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> respective flags are to be set.
00051 
00052     DisableReadAhead - <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> to enable read ahead, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> to disable <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a>.
00053 
00054     DisableWriteBehind - <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> to enable write behind, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> to disable <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a>.
00055 
00056 Return Value:
00057 
00058     None.
00059 
00060 --*/
00061 
00062 {
00063     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap;
00064     KIRQL OldIrql;
00065 
00066     <span class="comment">//</span>
00067     <span class="comment">//  Get pointer to SharedCacheMap.</span>
00068     <span class="comment">//</span>
00069 
00070     SharedCacheMap = FileObject-&gt;SectionObjectPointer-&gt;SharedCacheMap;
00071 
00072     <span class="comment">//</span>
00073     <span class="comment">//  Now set the flags and return.</span>
00074     <span class="comment">//</span>
00075 
00076     <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
00077     <span class="keywordflow">if</span> (DisableReadAhead) {
00078         <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, DISABLE_READ_AHEAD);
00079     } <span class="keywordflow">else</span> {
00080         <a class="code" href="../../d5/d5/cc_8h.html#a61">ClearFlag</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, DISABLE_READ_AHEAD);
00081     }
00082     <span class="keywordflow">if</span> (DisableWriteBehind) {
00083         <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, DISABLE_WRITE_BEHIND | MODIFIED_WRITE_DISABLED);
00084     } <span class="keywordflow">else</span> {
00085         <a class="code" href="../../d5/d5/cc_8h.html#a61">ClearFlag</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, DISABLE_WRITE_BEHIND);
00086     }
00087     <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
00088 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a93" doxytag="cache.h::CcSetBcbOwnerPointer" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTKERNELAPI VOID CcSetBcbOwnerPointer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>Bcb</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>OwnerPointer</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d3/d8/pinsup_8c-source.html#l01078">1078</a> of file <a class="el" href="../../d3/d8/pinsup_8c-source.html">pinsup.c</a>.
<p>
References <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00158">CACHE_NTC_OBCB</a>, <a class="el" href="../../d9/d7/ex_2resource_8c-source.html#l01820">ExSetResourceOwnerPointer()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, and <a class="el" href="../../d5/d9/tex_8c-source.html#l01561">Resource</a>.
<p>
Referenced by <a class="el" href="../../d8/d0/lbcbsup_8c-source.html#l00311">LfsGetLbcb()</a>.
<p>
<pre class="fragment"><div>01085                    :
01086 
01087     This routine may be called to set <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> resource owner <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Bcb resource,
01088     <span class="keywordflow">for</span> cases where another thread will <span class="keywordflow">do</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> unpin *and* <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> current thread
01089     may <a class="code" href="../../d9/d1/fedefs_8h.html#a16">exit</a>.
01090 
01091 Arguments:
01092 
01093     Bcb - Bcb parameter returned from <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> last call to <a class="code" href="../../d2/d9/pinsup_8c.html#a4">CcPinRead</a>.
01094 
01095     OwnerPointer - <a class="code" href="../../d2/d1/bench_8h.html#a5">A</a> valid resource owner pointer, which means a pointer to
01096                    an allocated system address, with <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d3/fetypes_8h.html#a457a418">low</a>-order two bits
01097                    set.  The address may not be deallocated until after <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
01098                    unpin call.
01099 
01100 Return Value:
01101 
01102     None.
01103 
01104 --*/
01105 
01106 {
01107     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(((ULONG_PTR)Bcb &amp; 1) == 0);
01108 
01109     <span class="comment">//</span>
01110     <span class="comment">//  Handle the overlapped Bcb case.</span>
01111     <span class="comment">//</span>
01112 
01113     <span class="keywordflow">if</span> (((<a class="code" href="../../d6/d4/struct__OBCB.html">POBCB</a>)Bcb)-&gt;NodeTypeCode == <a class="code" href="../../d5/d5/cc_8h.html#a17">CACHE_NTC_OBCB</a>) {
01114 
01115         <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> *BcbPtrPtr = &amp;((<a class="code" href="../../d6/d4/struct__OBCB.html">POBCB</a>)Bcb)-&gt;Bcbs[0];
01116 
01117         <span class="comment">//</span>
01118         <span class="comment">//  Loop to set owner for all Bcbs.</span>
01119         <span class="comment">//</span>
01120 
01121         <span class="keywordflow">while</span> (*BcbPtrPtr != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01122             <a class="code" href="../../d5/d8/ex_8h.html#a275">ExSetResourceOwnerPointer</a>( &amp;(*BcbPtrPtr)-&gt;Resource, OwnerPointer );
01123             BcbPtrPtr++;
01124         }
01125 
01126     <span class="comment">//</span>
01127     <span class="comment">//  Otherwise, it is a normal Bcb</span>
01128     <span class="comment">//</span>
01129 
01130     } <span class="keywordflow">else</span> {
01131 
01132         <span class="comment">//</span>
01133         <span class="comment">//  Handle normal case.</span>
01134         <span class="comment">//</span>
01135 
01136         <a class="code" href="../../d5/d8/ex_8h.html#a275">ExSetResourceOwnerPointer</a>( &amp;((<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)Bcb)-&gt;Resource, OwnerPointer );
01137     }
01138 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a62" doxytag="cache.h::CcSetDirtyPageThreshold" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTKERNELAPI VOID CcSetDirtyPageThreshold           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>FileObject</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>DirtyPageThreshold</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d7/fssup_8c-source.html#l02747">2747</a> of file <a class="el" href="../../d6/d7/fssup_8c-source.html">fssup.c</a>.
<p>
References <a class="el" href="../../d6/d4/cc_8h-source.html#l00930">_SHARED_CACHE_MAP::DirtyPageThreshold</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00497">FlagOn</a>, <a class="el" href="../../d2/d7/fsrtl_8h-source.html#l00211">FSRTL_FLAG_LIMIT_MODIFIED_PAGES</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, and <a class="el" href="../../d6/d4/cc_8h-source.html#l00505">SetFlag</a>.
<p>
<pre class="fragment"><div>02754                    :
02755 
02756     This routine may be called to set a dirty page threshold <span class="keywordflow">for</span> <span class="keyword">this</span>
02757     stream.  The write throttling will kick in whenever <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> system
02758     attempts to exceed <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> dirty page threshold <span class="keywordflow">for</span> <span class="keyword">this</span> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a>.
02759 
02760 Arguments:
02761 
02762     FileObject - Supplies <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> object <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> stream
02763 
02764     DirtyPageThreshold - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> dirty page threshold <span class="keywordflow">for</span> <span class="keyword">this</span> stream,
02765                          or 0 <span class="keywordflow">for</span> no threshold.
02766 
02767 Return Value:
02768 
02769     None
02770 
02771 Environment:
02772 
02773     The caller must guarantee exclusive access to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> FsRtl header flags,
02774     <span class="keywordflow">for</span> example, by calling <span class="keyword">this</span> routine once during create of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> structure
02775     containing <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> header.  Then <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> would call <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> routine again when actually
02776     caching <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> stream.
02777 
02778 --*/
02779 
02780 {
02781     KIRQL OldIrql;
02782     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap = FileObject-&gt;SectionObjectPointer-&gt;SharedCacheMap;
02783 
02784     <span class="keywordflow">if</span> (SharedCacheMap != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02785 
02786         SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o32">DirtyPageThreshold</a> = DirtyPageThreshold;
02787     }
02788 
02789     <span class="comment">//</span>
02790     <span class="comment">//  Test the flag before setting, in case the caller is no longer properly</span>
02791     <span class="comment">//  synchronized.</span>
02792     <span class="comment">//</span>
02793 
02794     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(((<a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html">PFSRTL_COMMON_FCB_HEADER</a>)(FileObject-&gt;FsContext))-&gt;Flags,
02795                 FSRTL_FLAG_LIMIT_MODIFIED_PAGES)) {
02796 
02797         <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>(((<a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html">PFSRTL_COMMON_FCB_HEADER</a>)(FileObject-&gt;FsContext))-&gt;Flags,
02798                 FSRTL_FLAG_LIMIT_MODIFIED_PAGES);
02799     }
02800 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a91" doxytag="cache.h::CcSetDirtyPinnedData" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTKERNELAPI VOID CcSetDirtyPinnedData           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>BcbVoid</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PLARGE_INTEGER Lsn&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d7/d1/cachesub_8c-source.html#l02560">2560</a> of file <a class="el" href="../../d7/d1/cachesub_8c-source.html">cachesub.c</a>.
<p>
References <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00965">_SHARED_CACHE_MAP::BcbSpinLock</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00158">CACHE_NTC_OBCB</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00070">CcAcquireMasterLockAtDpcLevel</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00031">CcDirtySharedCacheMapList</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00073">CcReleaseMasterLockFromDpcLevel</a>, <a class="el" href="../../d6/d0/lazyrite_8c-source.html#l00049">CcScheduleLazyWriteScan()</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00103">CcTotalDirtyPages</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02290">DebugTrace</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00846">_SHARED_CACHE_MAP::DirtyPages</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01031">DISABLE_WRITE_BEHIND</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00497">FlagOn</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00832">_SHARED_CACHE_MAP::Flags</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00129">LazyWriter</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l00033">me</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00600">PAGE_SHIFT</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01374">POBCB</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01464">_LAZY_WRITER::ScanActive</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01113">_SHARED_CACHE_MAP_LIST_CURSOR::SharedCacheMapLinks</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00826">_SHARED_CACHE_MAP::SharedCacheMapLinks</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, and <a class="el" href="../../d6/d4/cc_8h-source.html#l00780">_SHARED_CACHE_MAP::ValidDataGoal</a>.
<p>
Referenced by <a class="el" href="../../d6/d6/copysup_8c-source.html#l01075">CcCopyWrite()</a>, <a class="el" href="../../d3/d8/pinsup_8c-source.html#l00767">CcPreparePinWrite()</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l03758">CcReleaseByteRangeFromWrite()</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l05143">CcUnpinRepinnedBcb()</a>, <a class="el" href="../../d6/d7/fssup_8c-source.html#l02952">CcZeroData()</a>, <a class="el" href="../../d8/d1/lfs_2cachesup_8c-source.html#l00551">LfsFlushLfcb()</a>, and <a class="el" href="../../d1/d6/lfs_2registry_8c-source.html#l04321">LfsFlushLogPage()</a>.
<p>
<pre class="fragment"><div>02567                    :
02568 
02569     This routine may be called to set a Bcb (returned by CcPinFileData)
02570     dirty, and a candidate <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Lazy <a class="code" href="../../d4/d0/tex_8c.html#a44">Writer</a>.  All Bcbs should be set
02571     dirty by calling <span class="keyword">this</span> routine, even <span class="keywordflow">if</span> they are to be flushed
02572     another way.
02573 
02574 Arguments:
02575 
02576     Bcb - Supplies a pointer to a pinned (by CcPinFileData) Bcb, to
02577           be set dirty.
02578 
02579     Lsn - Lsn to be remembered with page.
02580 
02581 Return Value:
02582 
02583     None
02584 
02585 --*/
02586 
02587 {
02588     <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> Bcbs[2];
02589     <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> *BcbPtrPtr;
02590     KIRQL OldIrql;
02591     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap;
02592 
02593     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, me, <span class="stringliteral">"CcSetDirtyPinnedData: Bcb = %08lx\n"</span>, BcbVoid );
02594 
02595     <span class="comment">//</span>
02596     <span class="comment">//  Assume this is a normal Bcb, and set up for loop below.</span>
02597     <span class="comment">//</span>
02598 
02599     Bcbs[0] = (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)BcbVoid;
02600     Bcbs[1] = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02601     BcbPtrPtr = &amp;Bcbs[0];
02602 
02603     <span class="comment">//</span>
02604     <span class="comment">//  If it is an overlap Bcb, then point into the Bcb vector</span>
02605     <span class="comment">//  for the loop.</span>
02606     <span class="comment">//</span>
02607 
02608     <span class="keywordflow">if</span> (Bcbs[0]-&gt;NodeTypeCode == <a class="code" href="../../d5/d5/cc_8h.html#a17">CACHE_NTC_OBCB</a>) {
02609         BcbPtrPtr = &amp;((<a class="code" href="../../d6/d4/struct__OBCB.html">POBCB</a>)Bcbs[0])-&gt;Bcbs[0];
02610     }
02611 
02612     <span class="comment">//</span>
02613     <span class="comment">//  Loop to set all Bcbs dirty</span>
02614     <span class="comment">//</span>
02615 
02616     <span class="keywordflow">while</span> (*BcbPtrPtr != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02617 
02618         Bcbs[0] = *(BcbPtrPtr++);
02619 
02620         <span class="comment">//</span>
02621         <span class="comment">//  Should be no ReadOnly Bcbs</span>
02622         <span class="comment">//</span>
02623 
02624         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(((ULONG_PTR)Bcbs[0] &amp; 1) != 1);
02625 
02626         SharedCacheMap = Bcbs[0]-&gt;SharedCacheMap;
02627 
02628         <span class="comment">//</span>
02629         <span class="comment">//  We have to acquire the shared cache map list, because we</span>
02630         <span class="comment">//  may be changing lists.</span>
02631         <span class="comment">//</span>
02632 
02633         ExAcquireSpinLock( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o36">BcbSpinLock</a>, &amp;OldIrql );
02634 
02635         <span class="keywordflow">if</span> (!Bcbs[0]-&gt;Dirty) {
02636 
02637             ULONG Pages = Bcbs[0]-&gt;ByteLength &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>;
02638 
02639             <span class="comment">//</span>
02640             <span class="comment">//  Set dirty to keep the Bcb from going away until</span>
02641             <span class="comment">//  it is set Undirty, and assign the next modification time stamp.</span>
02642             <span class="comment">//</span>
02643 
02644             Bcbs[0]-&gt;Dirty = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02645 
02646             <span class="comment">//</span>
02647             <span class="comment">//  Initialize the OldestLsn field.</span>
02648             <span class="comment">//</span>
02649 
02650             <span class="keywordflow">if</span> (ARGUMENT_PRESENT(Lsn)) {
02651                 Bcbs[0]-&gt;OldestLsn = *Lsn;
02652                 Bcbs[0]-&gt;NewestLsn = *Lsn;
02653             }
02654 
02655             <span class="comment">//</span>
02656             <span class="comment">//  Move it to the dirty list if these are the first dirty pages,</span>
02657             <span class="comment">//  and this is not disabled for write behind.</span>
02658             <span class="comment">//</span>
02659             <span class="comment">//  Increase the count of dirty bytes in the shared cache map.</span>
02660             <span class="comment">//</span>
02661 
02662             <a class="code" href="../../d5/d5/cc_8h.html#a2">CcAcquireMasterLockAtDpcLevel</a>();
02663             <span class="keywordflow">if</span> ((SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o20">DirtyPages</a> == 0) &amp;&amp;
02664                 !<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, DISABLE_WRITE_BEHIND)) {
02665 
02666                 <span class="comment">//</span>
02667                 <span class="comment">//  If the lazy write scan is not active, then start it.</span>
02668                 <span class="comment">//</span>
02669 
02670                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o5">ScanActive</a>) {
02671                     <a class="code" href="../../d5/d5/cc_8h.html#a185">CcScheduleLazyWriteScan</a>();
02672                 }
02673 
02674                 RemoveEntryList( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a> );
02675                 InsertTailList( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a2">CcDirtySharedCacheMapList</a>.<a class="code" href="../../d1/d3/struct__SHARED__CACHE__MAP__LIST__CURSOR.html#o0">SharedCacheMapLinks</a>,
02676                                 &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a> );
02677             }
02678 
02679             SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o20">DirtyPages</a> += Pages;
02680             <a class="code" href="../../d5/d2/cachedat_8c.html#a36">CcTotalDirtyPages</a> += Pages;
02681             <a class="code" href="../../d5/d5/cc_8h.html#a3">CcReleaseMasterLockFromDpcLevel</a>();
02682         }
02683 
02684         <span class="comment">//</span>
02685         <span class="comment">//  If this Lsn happens to be older/newer than the ones we have stored, then</span>
02686         <span class="comment">//  change it.</span>
02687         <span class="comment">//</span>
02688 
02689         <span class="keywordflow">if</span> (ARGUMENT_PRESENT(Lsn)) {
02690 
02691             <span class="keywordflow">if</span> ((Bcbs[0]-&gt;OldestLsn.QuadPart == 0) || (Lsn-&gt;QuadPart &lt; Bcbs[0]-&gt;OldestLsn.QuadPart)) {
02692                 Bcbs[0]-&gt;OldestLsn = *Lsn;
02693             }
02694 
02695             <span class="keywordflow">if</span> (Lsn-&gt;QuadPart &gt; Bcbs[0]-&gt;NewestLsn.QuadPart) {
02696                 Bcbs[0]-&gt;NewestLsn = *Lsn;
02697             }
02698         }
02699 
02700         <span class="comment">//</span>
02701         <span class="comment">//  See if we need to advance our goal for ValidDataLength.</span>
02702         <span class="comment">//</span>
02703 
02704         <span class="keywordflow">if</span> ( Bcbs[0]-&gt;BeyondLastByte.QuadPart &gt; SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o7">ValidDataGoal</a>.QuadPart ) {
02705 
02706             SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o7">ValidDataGoal</a> = Bcbs[0]-&gt;BeyondLastByte;
02707         }
02708 
02709         ExReleaseSpinLock( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o36">BcbSpinLock</a>, OldIrql );
02710     }
02711 
02712     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, me, <span class="stringliteral">"CcSetDirtyPinnedData -&gt; VOID\n"</span>, 0 );
02713 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a60" doxytag="cache.h::CcSetFileSizes" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTKERNELAPI VOID CcSetFileSizes           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>FileObject</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d1/d9/struct__CC__FILE__SIZES.html">PCC_FILE_SIZES</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>FileSizes</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d7/fssup_8c-source.html#l01821">1821</a> of file <a class="el" href="../../d6/d7/fssup_8c-source.html">fssup.c</a>.
<p>
References <a class="el" href="../../d6/d4/cc_8h-source.html#l00064">CcAcquireMasterLock</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01010">CcDecrementOpenCount</a>, <a class="el" href="../../d6/d7/fssup_8c-source.html#l02626">CcDeleteMbcb()</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00031">CcDirtySharedCacheMapList</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l01377">CcExtendVacbArray()</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l05885">CcFreeActiveVacb()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01003">CcIncrementOpenCount</a>, <a class="el" href="../../d6/d7/fssup_8c-source.html#l02194">CcPurgeAndClearCacheSection()</a>, <a class="el" href="../../d6/d7/fssup_8c-source.html#l02331">CcPurgeCacheSection()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00067">CcReleaseMasterLock</a>, <a class="el" href="../../d6/d0/lazyrite_8c-source.html#l00049">CcScheduleLazyWriteScan()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02290">DebugTrace</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02292">DebugTrace2</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00193">DEFAULT_EXTEND_MODULO</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00846">_SHARED_CACHE_MAP::DirtyPages</a>, <a class="el" href="../../d1/d3/ex_2alpha_2raisests_8c-source.html#l00157">ExRaiseStatus()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00752">_SHARED_CACHE_MAP::FileSize</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00497">FlagOn</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00832">_SHARED_CACHE_MAP::Flags</a>, <a class="el" href="../../d8/d2/fsrtl_2filter_8c-source.html#l00049">FsRtlNormalizeNtstatus()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01588">GetActiveVacbAtDpcLevel</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00129">LazyWriter</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00839">_SHARED_CACHE_MAP::Mbcb</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l00033">me</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00462">mm</a>, <a class="el" href="../../d9/d9/extsect_8c-source.html#l00201">MmExtendSection()</a>, <a class="el" href="../../d7/d4/flushsec_8c-source.html#l00668">MmFlushSection()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00809">_SHARED_CACHE_MAP::NeedToZero</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00740">_SHARED_CACHE_MAP::OpenCount</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01471">_LAZY_WRITER::OtherWork</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00599">PAGE_SIZE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01038">PIN_ACCESS</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01464">_LAZY_WRITER::ScanActive</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00852">_SHARED_CACHE_MAP::Section</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00766">_SHARED_CACHE_MAP::SectionSize</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01113">_SHARED_CACHE_MAP_LIST_CURSOR::SharedCacheMapLinks</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00826">_SHARED_CACHE_MAP::SharedCacheMapLinks</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00817">_SHARED_CACHE_MAP::VacbActiveCount</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00780">_SHARED_CACHE_MAP::ValidDataGoal</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00773">_SHARED_CACHE_MAP::ValidDataLength</a>, and <a class="el" href="../../d6/d4/cc_8h-source.html#l01051">WRITE_QUEUED</a>.
<p>
Referenced by <a class="el" href="../../d3/d5/allocsup_8c-source.html#l01177">UdfLookupMetaVsnOfExtent()</a>, and <a class="el" href="../../d0/d7/udfs_2strucsup_8c-source.html#l00477">UdfUpdateVcbPhase0()</a>.
<p>
<pre class="fragment"><div>01828                    :
01829 
01830     This routine must be called whenever a <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> has been extended to reflect
01831     <span class="keyword">this</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a6">extension</a> in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> cache maps and underlying section.  Calling <span class="keyword">this</span>
01832     routine has a benign effect <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> current size of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> section <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a>
01833     already greater than or equal to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <span class="keyword">new</span> AllocationSize.
01834 
01835     This routine must also be called whenever <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> FileSize <span class="keywordflow">for</span> a <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> changes
01836     to reflect these changes in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Cache <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a79">Manager</a>.
01837 
01838     This routine seems rather large, but in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> normal <span class="keywordflow">case</span> <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> <a class="code" href="../../d3/d0/imm32_8def.html#a1">only</a> acquires
01839     a spinlock, updates some fields, and exits.  Less often <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> will either
01840     extend <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> section, or truncate/purge <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a>, but <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> would be unexpected
01841     to <span class="keywordflow">do</span> both.  On <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> other hand, <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> idea of <span class="keyword">this</span> routine <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> that <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> does
01842     <span class="stringliteral">"everything"</span> required when AllocationSize or FileSize change.
01843 
01844 Arguments:
01845 
01846     FileObject - <a class="code" href="../../d2/d1/bench_8h.html#a5">A</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> object <span class="keywordflow">for</span> which <a class="code" href="../../d5/d8/fssup_8c.html#a9">CcInitializeCacheMap</a> has been
01847                  previously called.
01848 
01849     FileSizes - <a class="code" href="../../d2/d1/bench_8h.html#a5">A</a> pointer to AllocationSize, FileSize and ValidDataLength
01850                 <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a>.  AllocationSize <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> ignored <span class="keywordflow">if</span> <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> not larger
01851                 than <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> current section size (i.e., it is ignored unless it
01852                 has grown).  ValidDataLength <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> not used.
01853 
01854 
01855 Return Value:
01856 
01857     None
01858 
01859 --*/
01860 
01861 {
01862     LARGE_INTEGER NewSectionSize;
01863     LARGE_INTEGER NewFileSize;
01864     LARGE_INTEGER NewValidDataLength;
01865     IO_STATUS_BLOCK IoStatus;
01866     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap;
01867     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01868     KIRQL OldIrql;
01869     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> ActiveVacb;
01870     ULONG ActivePage;
01871     ULONG PageIsDirty;
01872 
01873     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, me, <span class="stringliteral">"CcSetFileSizes:\n"</span>, 0 );
01874     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, me, <span class="stringliteral">"    FileObject = %08lx\n"</span>, FileObject );
01875     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, me, <span class="stringliteral">"    FileSizes = %08lx\n"</span>, FileSizes );
01876 
01877     <span class="comment">//</span>
01878     <span class="comment">//  Make a local copy of the new file size and section size.</span>
01879     <span class="comment">//</span>
01880 
01881     NewSectionSize = FileSizes-&gt;AllocationSize;
01882     NewFileSize = FileSizes-&gt;FileSize;
01883     NewValidDataLength = FileSizes-&gt;ValidDataLength;
01884 
01885     <span class="comment">//</span>
01886     <span class="comment">//  Serialize Creation/Deletion of all Shared CacheMaps</span>
01887     <span class="comment">//</span>
01888 
01889     <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
01890 
01891     <span class="comment">//</span>
01892     <span class="comment">//  Get pointer to SharedCacheMap via File Object.</span>
01893     <span class="comment">//</span>
01894 
01895     SharedCacheMap = FileObject-&gt;SectionObjectPointer-&gt;SharedCacheMap;
01896 
01897     <span class="comment">//</span>
01898     <span class="comment">//  If the file is not cached, just get out.</span>
01899     <span class="comment">//</span>
01900 
01901     <span class="keywordflow">if</span> ((SharedCacheMap == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) || (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o21">Section</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
01902 
01903         <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
01904 
01905         <span class="comment">//</span>
01906         <span class="comment">//  Let's try to purge the file incase this is a truncate.  In the</span>
01907         <span class="comment">//  vast majority of cases when there is no shared cache map, there</span>
01908         <span class="comment">//  is no data section either, so this call will eventually be</span>
01909         <span class="comment">//  no-oped in Mm.</span>
01910         <span class="comment">//</span>
01911 
01912         <span class="comment">//</span>
01913         <span class="comment">//  First flush the first page we are keeping, if it has data, before</span>
01914         <span class="comment">//  we throw it away.</span>
01915         <span class="comment">//</span>
01916 
01917         <span class="keywordflow">if</span> (NewFileSize.LowPart &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1)) {
01918             <a class="code" href="../../d6/d5/flushsec_8c.html#a8">MmFlushSection</a>( FileObject-&gt;SectionObjectPointer, &amp;NewFileSize, 1, &amp;IoStatus, FALSE );
01919         }
01920 
01921         <a class="code" href="../../d4/d2/cache_8h.html#a61">CcPurgeCacheSection</a>( FileObject-&gt;SectionObjectPointer,
01922                              &amp;NewFileSize,
01923                              0,
01924                              FALSE );
01925 
01926         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, me, <span class="stringliteral">"CcSetFileSizes -&gt; VOID\n"</span>, 0 );
01927 
01928         <span class="keywordflow">return</span>;
01929     }
01930 
01931     <span class="comment">//</span>
01932     <span class="comment">//  Make call a Noop if file is not mapped, or section already big enough.</span>
01933     <span class="comment">//</span>
01934 
01935     <span class="keywordflow">if</span> ( NewSectionSize.QuadPart &gt; SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o5">SectionSize</a>.QuadPart ) {
01936 
01937         <span class="comment">//</span>
01938         <span class="comment">//  Increment open count to make sure the SharedCacheMap stays around,</span>
01939         <span class="comment">//  then release the spinlock so that we can call Mm.</span>
01940         <span class="comment">//</span>
01941 
01942         <a class="code" href="../../d5/d5/cc_8h.html#a68">CcIncrementOpenCount</a>( SharedCacheMap, '1fSS' );
01943         <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
01944 
01945         <span class="comment">//</span>
01946         <span class="comment">//  Round new section size to pages.</span>
01947         <span class="comment">//</span>
01948 
01949         NewSectionSize.QuadPart = NewSectionSize.QuadPart + (LONGLONG)(<a class="code" href="../../d5/d5/cc_8h.html#a30">DEFAULT_EXTEND_MODULO</a> - 1);
01950         NewSectionSize.LowPart &amp;= ~(<a class="code" href="../../d5/d5/cc_8h.html#a30">DEFAULT_EXTEND_MODULO</a> - 1);
01951 
01952         <span class="comment">//</span>
01953         <span class="comment">//  Use try-finally to make sure we get the open count decremented.</span>
01954         <span class="comment">//</span>
01955 
01956         <span class="keywordflow">try</span> {
01957 
01958             <span class="comment">//</span>
01959             <span class="comment">//  Call MM to extend the section.</span>
01960             <span class="comment">//</span>
01961 
01962             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, mm, <span class="stringliteral">"MmExtendSection:\n"</span>, 0 );
01963             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, mm, <span class="stringliteral">"    Section = %08lx\n"</span>, SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o21">Section</a> );
01964             <a class="code" href="../../d5/d5/cc_8h.html#a92">DebugTrace2</a>(0, mm, <span class="stringliteral">"    Size = %08lx, %08lx\n"</span>,
01965                         NewSectionSize.LowPart, NewSectionSize.HighPart );
01966 
01967             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d8/d0/extsect_8c.html#a1">MmExtendSection</a>( SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o21">Section</a>, &amp;NewSectionSize, TRUE );
01968 
01969             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(Status)) {
01970 
01971                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, 0, <span class="stringliteral">"Error from MmExtendSection, Status = %08lx\n"</span>,
01972                             Status );
01973 
01974                 <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( <a class="code" href="../../d1/d8/fsrtl_8h.html#a136">FsRtlNormalizeNtstatus</a>( Status,
01975                                                        STATUS_UNEXPECTED_MM_EXTEND_ERR ));
01976             }
01977 
01978             <span class="comment">//</span>
01979             <span class="comment">//  Extend the Vacb array.</span>
01980             <span class="comment">//</span>
01981 
01982             <a class="code" href="../../d5/d3/vacbsup_8c.html#a21">CcExtendVacbArray</a>( SharedCacheMap, NewSectionSize );
01983 
01984         } finally {
01985 
01986             <span class="comment">//</span>
01987             <span class="comment">//  Serialize again to decrement the open count.</span>
01988             <span class="comment">//</span>
01989 
01990             <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
01991 
01992             <a class="code" href="../../d5/d5/cc_8h.html#a69">CcDecrementOpenCount</a>( SharedCacheMap, '1fSF' );
01993 
01994             <span class="keywordflow">if</span> ((SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o2">OpenCount</a> == 0) &amp;&amp;
01995                 !<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, WRITE_QUEUED) &amp;&amp;
01996                 (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o20">DirtyPages</a> == 0)) {
01997 
01998                 <span class="comment">//</span>
01999                 <span class="comment">//  Move to the dirty list.</span>
02000                 <span class="comment">//</span>
02001 
02002                 RemoveEntryList( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a> );
02003                 InsertTailList( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a2">CcDirtySharedCacheMapList</a>.<a class="code" href="../../d1/d3/struct__SHARED__CACHE__MAP__LIST__CURSOR.html#o0">SharedCacheMapLinks</a>,
02004                                 &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a> );
02005 
02006                 <span class="comment">//</span>
02007                 <span class="comment">//  Make sure the Lazy Writer will wake up, because we</span>
02008                 <span class="comment">//  want him to delete this SharedCacheMap.</span>
02009                 <span class="comment">//</span>
02010 
02011                 <a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o6">OtherWork</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02012                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o5">ScanActive</a>) {
02013                     <a class="code" href="../../d5/d5/cc_8h.html#a185">CcScheduleLazyWriteScan</a>();
02014                 }
02015             }
02016 
02017             <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
02018         }
02019 
02020         <span class="comment">//</span>
02021         <span class="comment">//  It is now very unlikely that we have any more work to do, but just</span>
02022         <span class="comment">//  in case we reacquire the spinlock and check again if we are cached.</span>
02023         <span class="comment">//</span>
02024 
02025         <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
02026 
02027         <span class="comment">//</span>
02028         <span class="comment">//  Get pointer to SharedCacheMap via File Object.</span>
02029         <span class="comment">//</span>
02030 
02031         SharedCacheMap = FileObject-&gt;SectionObjectPointer-&gt;SharedCacheMap;
02032 
02033         <span class="comment">//</span>
02034         <span class="comment">//  If the file is not cached, just get out.</span>
02035         <span class="comment">//</span>
02036 
02037         <span class="keywordflow">if</span> (SharedCacheMap == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02038 
02039             <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
02040 
02041             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, me, <span class="stringliteral">"CcSetFileSizes -&gt; VOID\n"</span>, 0 );
02042 
02043             <span class="keywordflow">return</span>;
02044         }
02045     }
02046 
02047     <span class="comment">//</span>
02048     <span class="comment">//  If we are shrinking either of these two sizes, then we must free the</span>
02049     <span class="comment">//  active page, since it may be locked.</span>
02050     <span class="comment">//</span>
02051 
02052     <a class="code" href="../../d5/d5/cc_8h.html#a68">CcIncrementOpenCount</a>( SharedCacheMap, '2fSS' );
02053 
02054     <span class="keywordflow">try</span> {
02055 
02056         <span class="keywordflow">if</span> ( ( NewFileSize.QuadPart &lt; SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o7">ValidDataGoal</a>.QuadPart ) ||
02057              ( NewFileSize.QuadPart &lt; SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o3">FileSize</a>.QuadPart )) {
02058 
02059             <a class="code" href="../../d5/d5/cc_8h.html#a83">GetActiveVacbAtDpcLevel</a>( SharedCacheMap, ActiveVacb, ActivePage, PageIsDirty );
02060 
02061             <span class="keywordflow">if</span> ((ActiveVacb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) || (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o13">NeedToZero</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
02062 
02063                 <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
02064 
02065                 <a class="code" href="../../d5/d5/cc_8h.html#a182">CcFreeActiveVacb</a>( SharedCacheMap, ActiveVacb, ActivePage, PageIsDirty );
02066 
02067                 <span class="comment">//</span>
02068                 <span class="comment">//  Serialize again to reduce ValidDataLength.  It cannot change</span>
02069                 <span class="comment">//  because the caller must have the file exclusive.</span>
02070                 <span class="comment">//</span>
02071 
02072                 <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
02073             }
02074         }
02075 
02076         <span class="comment">//</span>
02077         <span class="comment">//  If the section did not grow, see if the file system supports ValidDataLength,</span>
02078         <span class="comment">//  then update the valid data length in the file system.</span>
02079         <span class="comment">//</span>
02080 
02081         <span class="keywordflow">if</span> ( SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o6">ValidDataLength</a>.QuadPart != MAXLONGLONG ) {
02082 
02083             <span class="keywordflow">if</span> ( NewFileSize.QuadPart &lt; SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o6">ValidDataLength</a>.QuadPart ) {
02084                 SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o6">ValidDataLength</a> = NewFileSize;
02085             }
02086 
02087             <span class="comment">//</span>
02088             <span class="comment">//  Update our notion of ValidDataGoal (how far the file has been written</span>
02089             <span class="comment">//  in the cache) with caller's ValidDataLength.  (Our ValidDataLength controls</span>
02090             <span class="comment">//  when we issue ValidDataLength callbacks.)  *** For now play it safe by</span>
02091             <span class="comment">//  only growing here, which is the historical problem at hand, as with</span>
02092             <span class="comment">//  compressed and uncompressed stream caches.</span>
02093             <span class="comment">//</span>
02094 
02095             <span class="keywordflow">if</span> (NewValidDataLength.QuadPart &gt; SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o7">ValidDataGoal</a>.QuadPart) {
02096                 SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o7">ValidDataGoal</a> = NewValidDataLength;
02097             }
02098         }
02099 
02100         <span class="comment">//</span>
02101         <span class="comment">//  On truncate, be nice guys and actually purge away user data from</span>
02102         <span class="comment">//  the cache.  However, the PinAccess check is important to avoid deadlocks</span>
02103         <span class="comment">//  in Ntfs.</span>
02104         <span class="comment">//</span>
02105         <span class="comment">//  It is also important to check the Vacb Active count.  The caller</span>
02106         <span class="comment">//  must have the file exclusive, therefore, no one else can be actively</span>
02107         <span class="comment">//  doing anything in the file.  Normally the Active count will be zero</span>
02108         <span class="comment">//  (like in a normal call from Set File Info), and we can go ahead and truncate.</span>
02109         <span class="comment">//  However, if the active count is nonzero, chances are this very thread has</span>
02110         <span class="comment">//  something pinned or mapped, and we will deadlock if we try to purge and</span>
02111         <span class="comment">//  wait for the count to go zero.  A rare case of this which deadlocked DaveC</span>
02112         <span class="comment">//  on Christmas Day of 1992, is where Ntfs was trying to convert an attribute</span>
02113         <span class="comment">//  from resident to nonresident - which is a good example of a case where the</span>
02114         <span class="comment">//  purge was not needed.</span>
02115         <span class="comment">//</span>
02116 
02117         <span class="keywordflow">if</span> ( (NewFileSize.QuadPart &lt; SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o3">FileSize</a>.QuadPart ) &amp;&amp;
02118             !<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, PIN_ACCESS) &amp;&amp;
02119             (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o16">VacbActiveCount</a> == 0)) {
02120 
02121             <span class="comment">//</span>
02122             <span class="comment">//  Release the spinlock so that we can call Mm.</span>
02123             <span class="comment">//</span>
02124 
02125             <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
02126 
02127             <span class="comment">//</span>
02128             <span class="comment">//  If we are actually truncating to zero (a size which has particular</span>
02129             <span class="comment">//  meaning to the Lazy Writer scan!), then we must reset the Mbcb if</span>
02130             <span class="comment">//  there is one, so that we do not keep dirty pages around forever.</span>
02131             <span class="comment">//</span>
02132 
02133             <span class="keywordflow">if</span> ((NewFileSize.QuadPart == 0) &amp;&amp; (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o19">Mbcb</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
02134                 <a class="code" href="../../d5/d8/fssup_8c.html#a6">CcDeleteMbcb</a>( SharedCacheMap );
02135             }
02136 
02137             <a class="code" href="../../d5/d8/fssup_8c.html#a7">CcPurgeAndClearCacheSection</a>( SharedCacheMap, &amp;NewFileSize );
02138 
02139             <span class="comment">//</span>
02140             <span class="comment">//  Serialize again to decrement the open count.</span>
02141             <span class="comment">//</span>
02142 
02143             <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
02144         }
02145 
02146     } finally {
02147 
02148         <span class="comment">//</span>
02149         <span class="comment">//  We should only be raising without owning the spinlock.</span>
02150         <span class="comment">//</span>
02151 
02152         <span class="keywordflow">if</span> (AbnormalTermination()) {
02153 
02154             <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
02155         }
02156 
02157         <a class="code" href="../../d5/d5/cc_8h.html#a69">CcDecrementOpenCount</a>( SharedCacheMap, '2fSF' );
02158 
02159         SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o3">FileSize</a> = NewFileSize;
02160 
02161         <span class="keywordflow">if</span> ((SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o2">OpenCount</a> == 0) &amp;&amp;
02162             !<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, WRITE_QUEUED) &amp;&amp;
02163             (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o20">DirtyPages</a> == 0)) {
02164 
02165             <span class="comment">//</span>
02166             <span class="comment">//  Move to the dirty list.</span>
02167             <span class="comment">//</span>
02168 
02169             RemoveEntryList( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a> );
02170             InsertTailList( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a2">CcDirtySharedCacheMapList</a>.<a class="code" href="../../d1/d3/struct__SHARED__CACHE__MAP__LIST__CURSOR.html#o0">SharedCacheMapLinks</a>,
02171                             &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a> );
02172 
02173             <span class="comment">//</span>
02174             <span class="comment">//  Make sure the Lazy Writer will wake up, because we</span>
02175             <span class="comment">//  want him to delete this SharedCacheMap.</span>
02176             <span class="comment">//</span>
02177 
02178             <a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o6">OtherWork</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02179             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o5">ScanActive</a>) {
02180                 <a class="code" href="../../d5/d5/cc_8h.html#a185">CcScheduleLazyWriteScan</a>();
02181             }
02182         }
02183 
02184         <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
02185     }
02186 
02187     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, me, <span class="stringliteral">"CcSetFileSizes -&gt; VOID\n"</span>, 0 );
02188 
02189     <span class="keywordflow">return</span>;
02190 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a96" doxytag="cache.h::CcSetLogHandleForFile" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTKERNELAPI VOID CcSetLogHandleForFile           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>FileObject</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>LogHandle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d4/d2/cache_8h.html#a23">PFLUSH_TO_LSN</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>FlushToLsnRoutine</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d9/d4/logsup_8c-source.html#l00092">92</a> of file <a class="el" href="../../d9/d4/logsup_8c-source.html">logsup.c</a>.
<p>
References <a class="el" href="../../d6/d4/cc_8h-source.html#l00924">_SHARED_CACHE_MAP::FlushToLsnRoutine</a>, and <a class="el" href="../../d6/d4/cc_8h-source.html#l00918">_SHARED_CACHE_MAP::LogHandle</a>.
<p>
<pre class="fragment"><div>00100                    :
00101 
00102     This routine may be called to instruct <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Cache <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a79">Manager</a> to store <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
00103     specified log handle with <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> shared cache map <span class="keywordflow">for</span> a <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a>, to support
00104     subsequent calls to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> other <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a24">routines</a> in <span class="keyword">this</span> module which effectively
00105     perform an associative search <span class="keywordflow">for</span> files by log handle.
00106 
00107 Arguments:
00108 
00109     FileObject - <a class="code" href="../../d1/d9/icmui_8def.html#a0">File</a> <span class="keywordflow">for</span> which <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> log handle should be stored.
00110 
00111     LogHandle - Log <a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a> to store.
00112 
00113     FlushToLsnRoutine - <a class="code" href="../../d2/d1/bench_8h.html#a5">A</a> routine to call before flushing buffers <span class="keywordflow">for</span> <span class="keyword">this</span>
00114                         <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a>, to insure a log <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> flushed to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> most
00115                         recent Lsn <span class="keywordflow">for</span> any Bcb being flushed.
00116 
00117 Return Value:
00118 
00119     None.
00120 
00121 --*/
00122 
00123 {
00124     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap;
00125 
00126     <span class="comment">//</span>
00127     <span class="comment">//  Get pointer to SharedCacheMap.</span>
00128     <span class="comment">//</span>
00129 
00130     SharedCacheMap = FileObject-&gt;SectionObjectPointer-&gt;SharedCacheMap;
00131 
00132     <span class="comment">//</span>
00133     <span class="comment">//  Now set the log file handle and flush routine</span>
00134     <span class="comment">//</span>
00135 
00136     SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o30">LogHandle</a> = LogHandle;
00137     SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o31">FlushToLsnRoutine</a> = FlushToLsnRoutine;
00138 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a86" doxytag="cache.h::CcSetReadAheadGranularity" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTKERNELAPI VOID CcSetReadAheadGranularity           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>FileObject</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Granularity</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d7/d1/cachesub_8c-source.html#l01222">1222</a> of file <a class="el" href="../../d7/d1/cachesub_8c-source.html">cachesub.c</a>.
<p>
References <a class="el" href="../../d6/d4/cc_8h-source.html#l00717">PPRIVATE_CACHE_MAP</a>.
<p>
Referenced by <a class="el" href="../../d8/d4/udfs_2read_8c-source.html#l00068">UdfCommonRead()</a>.
<p>
<pre class="fragment"><div>01229                    :
01230 
01231     This routine may be called to set <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> read ahead granularity used by
01232     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Cache <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a79">Manager</a>.  The <span class="keywordflow">default</span> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>.  The number <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> decremented
01233     and stored as a mask.
01234 
01235 Arguments:
01236 
01237     FileObject - <a class="code" href="../../d1/d9/icmui_8def.html#a0">File</a> Object <span class="keywordflow">for</span> which granularity shall be set
01238 
01239     Granularity - <span class="keyword">new</span> granularity, which must be an even power of 2 and
01240                   &gt;= <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>
01241 
01242 Return Value:
01243 
01244     None
01245 --*/
01246 
01247 {
01248     ((<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html">PPRIVATE_CACHE_MAP</a>)FileObject-&gt;PrivateCacheMap)-&gt;ReadAheadMask = Granularity - 1;
01249 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a59" doxytag="cache.h::CcUninitializeCacheMap" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTKERNELAPI BOOLEAN CcUninitializeCacheMap           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>FileObject</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PLARGE_INTEGER TruncateSize&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d4/d6/struct__CACHE__UNINITIALIZE__EVENT.html">PCACHE_UNINITIALIZE_EVENT</a> UninitializeCompleteEvent&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Referenced by <a class="el" href="../../d6/d7/fssup_8c-source.html#l02331">CcPurgeCacheSection()</a>, <a class="el" href="../../d9/d6/udfs_2cleanup_8c-source.html#l00042">UdfCommonCleanup()</a>, and <a class="el" href="../../d9/d1/udfs_2cachesup_8c-source.html#l00215">UdfDeleteInternalStream()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a92" doxytag="cache.h::CcUnpinData" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTKERNELAPI VOID CcUnpinData           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>Bcb</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d3/d8/pinsup_8c-source.html#l01000">1000</a> of file <a class="el" href="../../d3/d8/pinsup_8c-source.html">pinsup.c</a>.
<p>
References <a class="el" href="../../d6/d4/cc_8h-source.html#l00158">CACHE_NTC_OBCB</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l00974">CcUnpinFileData()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02290">DebugTrace</a>, <a class="el" href="../../d7/d2/cmwraper_8c-source.html#l00304">ExFreePool()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l00033">me</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, and <a class="el" href="../../d5/d5/cc_8h.html#a211a171">UNPIN</a>.
<p>
Referenced by <a class="el" href="../../d3/d8/pinsup_8c-source.html#l00271">CcPinMappedData()</a>, <a class="el" href="../../d3/d8/pinsup_8c-source.html#l00524">CcPinRead()</a>, <a class="el" href="../../d3/d8/pinsup_8c-source.html#l00767">CcPreparePinWrite()</a>, <a class="el" href="../../d8/d1/lfs_2cachesup_8c-source.html#l00339">LfsCopyReadLogRecord()</a>, <a class="el" href="../../d9/d6/lfs_2strucsup_8c-source.html#l00518">LfsDeallocateLcb()</a>, <a class="el" href="../../d1/d6/lfs_2registry_8c-source.html#l03193">LfsFindLastLsn()</a>, <a class="el" href="../../d0/d7/lsnsup_8c-source.html#l00148">LfsFindNextLsn()</a>, <a class="el" href="../../d8/d1/lfs_2cachesup_8c-source.html#l00551">LfsFlushLfcb()</a>, <a class="el" href="../../d1/d6/lfs_2registry_8c-source.html#l04321">LfsFlushLogPage()</a>, <a class="el" href="../../d8/d0/lbcbsup_8c-source.html#l00311">LfsGetLbcb()</a>, <a class="el" href="../../d1/d6/lfs_2registry_8c-source.html#l03065">LfsInitializeLogFilePriv()</a>, <a class="el" href="../../d8/d1/lfs_2cachesup_8c-source.html#l00084">LfsPinOrMapData()</a>, <a class="el" href="../../d4/d2/querylog_8c-source.html#l00299">LfsReadNextLogRecord()</a>, <a class="el" href="../../d8/d1/lfs_2cachesup_8c-source.html#l01402">LfsReadRestart()</a>, <a class="el" href="../../d6/d8/restart_8c-source.html#l00046">LfsReadRestartArea()</a>, <a class="el" href="../../d1/d6/lfs_2registry_8c-source.html#l01534">LfsRestartLogFile()</a>, and <a class="el" href="../../d4/d2/querylog_8c-source.html#l01116">LfsSearchForwardByClient()</a>.
<p>
<pre class="fragment"><div>01006                    :
01007 
01008     This routine must be called at IPL0, some time after calling <a class="code" href="../../d2/d9/pinsup_8c.html#a4">CcPinRead</a>
01009     or <a class="code" href="../../d2/d9/pinsup_8c.html#a5">CcPreparePinWrite</a>.  It performs any cleanup that <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> necessary.
01010 
01011 Arguments:
01012 
01013     Bcb - Bcb parameter returned from <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> last call to <a class="code" href="../../d2/d9/pinsup_8c.html#a4">CcPinRead</a>.
01014 
01015 Return Value:
01016 
01017     None.
01018 
01019 --*/
01020 
01021 {
01022     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, me, <span class="stringliteral">"CcUnpinData:\n"</span>, 0 );
01023     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, me, <span class="stringliteral">"    &gt;Bcb = %08lx\n"</span>, Bcb );
01024 
01025     <span class="comment">//</span>
01026     <span class="comment">//  Test for ReadOnly and unpin accordingly.</span>
01027     <span class="comment">//</span>
01028 
01029     <span class="keywordflow">if</span> (((ULONG_PTR)Bcb &amp; 1) != 0) {
01030 
01031         <span class="comment">//</span>
01032         <span class="comment">//  Remove the Read Only flag</span>
01033         <span class="comment">//</span>
01034 
01035         (PCHAR)Bcb -= 1;
01036 
01037         <a class="code" href="../../d5/d5/cc_8h.html#a176">CcUnpinFileData</a>( (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)Bcb, TRUE, UNPIN );
01038 
01039     } <span class="keywordflow">else</span> {
01040 
01041         <span class="comment">//</span>
01042         <span class="comment">//  Handle the overlapped Bcb case.</span>
01043         <span class="comment">//</span>
01044 
01045         <span class="keywordflow">if</span> (((<a class="code" href="../../d6/d4/struct__OBCB.html">POBCB</a>)Bcb)-&gt;NodeTypeCode == <a class="code" href="../../d5/d5/cc_8h.html#a17">CACHE_NTC_OBCB</a>) {
01046 
01047             <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> *BcbPtrPtr = &amp;((<a class="code" href="../../d6/d4/struct__OBCB.html">POBCB</a>)Bcb)-&gt;Bcbs[0];
01048 
01049             <span class="comment">//</span>
01050             <span class="comment">//  Loop to free all Bcbs with recursive calls</span>
01051             <span class="comment">//  (rather than dealing with RO for this uncommon case).</span>
01052             <span class="comment">//</span>
01053 
01054             <span class="keywordflow">while</span> (*BcbPtrPtr != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01055                 <a class="code" href="../../d4/d2/cache_8h.html#a92">CcUnpinData</a>(*(BcbPtrPtr++));
01056             }
01057 
01058             <span class="comment">//</span>
01059             <span class="comment">//  Then free the pool for the Obcb</span>
01060             <span class="comment">//</span>
01061 
01062             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( Bcb );
01063 
01064         <span class="comment">//</span>
01065         <span class="comment">//  Otherwise, it is a normal Bcb</span>
01066         <span class="comment">//</span>
01067 
01068         } <span class="keywordflow">else</span> {
01069             <a class="code" href="../../d5/d5/cc_8h.html#a176">CcUnpinFileData</a>( (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)Bcb, FALSE, UNPIN );
01070         }
01071     }
01072 
01073     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, me, <span class="stringliteral">"CcUnPinData -&gt; VOID\n"</span>, 0 );
01074 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a94" doxytag="cache.h::CcUnpinDataForThread" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTKERNELAPI VOID CcUnpinDataForThread           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>Bcb</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d5/d8/ex_8h.html#a121">ERESOURCE_THREAD</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>ResourceThreadId</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d3/d8/pinsup_8c-source.html#l01142">1142</a> of file <a class="el" href="../../d3/d8/pinsup_8c-source.html">pinsup.c</a>.
<p>
References <a class="el" href="../../d6/d4/cc_8h-source.html#l00158">CACHE_NTC_OBCB</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l00974">CcUnpinFileData()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02290">DebugTrace</a>, <a class="el" href="../../d7/d2/cmwraper_8c-source.html#l00304">ExFreePool()</a>, <a class="el" href="../../d6/d7/ex_8h-source.html#l02476">ExReleaseResourceForThread</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l00033">me</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d5/d9/tex_8c-source.html#l01561">Resource</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, and <a class="el" href="../../d5/d5/cc_8h.html#a211a171">UNPIN</a>.
<p>
Referenced by <a class="el" href="../../d1/d6/lfs_2registry_8c-source.html#l00706">LfsCloseLogFile()</a>, and <a class="el" href="../../d8/d1/lfs_2cachesup_8c-source.html#l00551">LfsFlushLfcb()</a>.
<p>
<pre class="fragment"><div>01149                    :
01150 
01151     This routine must be called at IPL0, some time after calling <a class="code" href="../../d2/d9/pinsup_8c.html#a4">CcPinRead</a>
01152     or <a class="code" href="../../d2/d9/pinsup_8c.html#a5">CcPreparePinWrite</a>.  It performs any cleanup that <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> necessary,
01153     releasing <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Bcb resource <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> given thread.
01154 
01155 Arguments:
01156 
01157     Bcb - Bcb parameter returned from <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> last call to <a class="code" href="../../d2/d9/pinsup_8c.html#a4">CcPinRead</a>.
01158 
01159 Return Value:
01160 
01161     None.
01162 
01163 --*/
01164 
01165 {
01166     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, me, <span class="stringliteral">"CcUnpinDataForThread:\n"</span>, 0 );
01167     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, me, <span class="stringliteral">"    &gt;Bcb = %08lx\n"</span>, Bcb );
01168     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, me, <span class="stringliteral">"    &gt;ResoureceThreadId = %08lx\n"</span>, ResoureceThreadId );
01169 
01170     <span class="comment">//</span>
01171     <span class="comment">//  Test for ReadOnly and unpin accordingly.</span>
01172     <span class="comment">//</span>
01173 
01174     <span class="keywordflow">if</span> (((ULONG_PTR)Bcb &amp; 1) != 0) {
01175 
01176         <span class="comment">//</span>
01177         <span class="comment">//  Remove the Read Only flag</span>
01178         <span class="comment">//</span>
01179 
01180         (PCHAR)Bcb -= 1;
01181 
01182         <a class="code" href="../../d5/d5/cc_8h.html#a176">CcUnpinFileData</a>( (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)Bcb, TRUE, UNPIN );
01183 
01184     } <span class="keywordflow">else</span> {
01185 
01186         <span class="comment">//</span>
01187         <span class="comment">//  Handle the overlapped Bcb case.</span>
01188         <span class="comment">//</span>
01189 
01190         <span class="keywordflow">if</span> (((<a class="code" href="../../d6/d4/struct__OBCB.html">POBCB</a>)Bcb)-&gt;NodeTypeCode == <a class="code" href="../../d5/d5/cc_8h.html#a17">CACHE_NTC_OBCB</a>) {
01191 
01192             <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> *BcbPtrPtr = &amp;((<a class="code" href="../../d6/d4/struct__OBCB.html">POBCB</a>)Bcb)-&gt;Bcbs[0];
01193 
01194             <span class="comment">//</span>
01195             <span class="comment">//  Loop to free all Bcbs with recursive calls</span>
01196             <span class="comment">//  (rather than dealing with RO for this uncommon case).</span>
01197             <span class="comment">//</span>
01198 
01199             <span class="keywordflow">while</span> (*BcbPtrPtr != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01200                 <a class="code" href="../../d4/d2/cache_8h.html#a94">CcUnpinDataForThread</a>( *(BcbPtrPtr++), ResourceThreadId );
01201             }
01202 
01203             <span class="comment">//</span>
01204             <span class="comment">//  Then free the pool for the Obcb</span>
01205             <span class="comment">//</span>
01206 
01207             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( Bcb );
01208 
01209         <span class="comment">//</span>
01210         <span class="comment">//  Otherwise, it is a normal Bcb</span>
01211         <span class="comment">//</span>
01212 
01213         } <span class="keywordflow">else</span> {
01214 
01215             <span class="comment">//</span>
01216             <span class="comment">//  If not readonly, we can release the resource for the thread first,</span>
01217             <span class="comment">//  and then call CcUnpinFileData.  Release resource first in case</span>
01218             <span class="comment">//  Bcb gets deallocated.</span>
01219             <span class="comment">//</span>
01220 
01221             <a class="code" href="../../d5/d8/ex_8h.html#a71">ExReleaseResourceForThread</a>( &amp;((<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)Bcb)-&gt;Resource, ResourceThreadId );
01222             <a class="code" href="../../d5/d5/cc_8h.html#a176">CcUnpinFileData</a>( (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)Bcb, TRUE, UNPIN );
01223         }
01224     }
01225     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, me, <span class="stringliteral">"CcUnpinDataForThread -&gt; VOID\n"</span>, 0 );
01226 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a69" doxytag="cache.h::CcUnpinRepinnedBcb" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTKERNELAPI VOID CcUnpinRepinnedBcb           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>Bcb</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN BOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>WriteThrough</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PIO_STATUS_BLOCK&nbsp;</td>
          <td class="mdname" nowrap> <em>IoStatus</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d7/d1/cachesub_8c-source.html#l05143">5143</a> of file <a class="el" href="../../d7/d1/cachesub_8c-source.html">cachesub.c</a>.
<p>
References <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00096">CcDeferredWrites</a>, <a class="el" href="../../d6/d6/copysup_8c-source.html#l02099">CcPostDeferredWrites()</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l02560">CcSetDirtyPinnedData()</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l00974">CcUnpinFileData()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02290">DebugTrace</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02292">DebugTrace2</a>, <a class="el" href="../../d6/d7/ex_8h-source.html#l02475">ExAcquireResourceExclusive</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00796">_SHARED_CACHE_MAP::FileObject</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00497">FlagOn</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00832">_SHARED_CACHE_MAP::Flags</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l00033">me</a>, <a class="el" href="../../d7/d4/flushsec_8c-source.html#l00668">MmFlushSection()</a>, <a class="el" href="../../d6/d5/iosup_8c-source.html#l05920">MmSetAddressRangeModified()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01077">MODIFIED_WRITE_DISABLED</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d5/d9/tex_8c-source.html#l01561">Resource</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l00039">RetryError</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01521">_FILE_OBJECT::SectionObjectPointer</a>, <a class="el" href="../../d5/d5/cc_8h.html#a211a173">SET_CLEAN</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, and <a class="el" href="../../d5/d5/cc_8h.html#a211a171">UNPIN</a>.
<p>
<pre class="fragment"><div>05151                    :
05152 
05153     This routine may be called to Write a previously pinned buffer
05154     through to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a>.  It must have been preceded by a call to
05155     <a class="code" href="../../d6/d2/cachesub_8c.html#a23">CcRepinBcb</a>.  As <span class="keyword">this</span> routine must acquire <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Bcb
05156     resource exclusive, <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller must be extremely careful to avoid
05157     deadlocks.  Ideally <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller owns no resources at all when <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a>
05158     calls <span class="keyword">this</span> routine, or <span class="keywordflow">else</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller should guarantee that <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a>
05159     has nothing <span class="keywordflow">else</span> pinned in <span class="keyword">this</span> same <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a>.  (The latter rule <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a>
05160     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> one used to avoid deadlocks in calls from <a class="code" href="../../d5/d7/copysup_8c.html#a3">CcCopyWrite</a> and
05161     CcMdlWrite.)
05162 
05163 Arguments:
05164 
05165     Bcb - Pointer to a Bcb which was previously specified in a call
05166           to <a class="code" href="../../d6/d2/cachesub_8c.html#a23">CcRepinBcb</a>.
05167 
05168     WriteThrough - <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Bcb should be written through.
05169 
05170     IoStatus - Returns <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> I/O status <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> operation.
05171 
05172 Return Value:
05173 
05174     None.
05175 
05176 --*/
05177 
05178 {
05179     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap = ((<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)Bcb)-&gt;SharedCacheMap;
05180 
05181     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, me, <span class="stringliteral">"CcUnpinRepinnedBcb\n"</span>, 0 );
05182     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, me, <span class="stringliteral">"    Bcb = %08lx\n"</span>, Bcb );
05183     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, me, <span class="stringliteral">"    WriteThrough = %02lx\n"</span>, WriteThrough );
05184 
05185     <span class="comment">//</span>
05186     <span class="comment">//  Set status to success for non write through case.</span>
05187     <span class="comment">//</span>
05188 
05189     IoStatus-&gt;Status = STATUS_SUCCESS;
05190 
05191     <span class="keywordflow">if</span> (WriteThrough) {
05192 
05193         <span class="comment">//</span>
05194         <span class="comment">//  Acquire Bcb exclusive to eliminate possible modifiers of the buffer,</span>
05195         <span class="comment">//  since we are about to write its buffer.</span>
05196         <span class="comment">//</span>
05197 
05198         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, MODIFIED_WRITE_DISABLED)) {
05199             <a class="code" href="../../d5/d8/ex_8h.html#a70">ExAcquireResourceExclusive</a>( &amp;((<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)Bcb)-&gt;Resource, TRUE );
05200         }
05201 
05202         <span class="comment">//</span>
05203         <span class="comment">//  Now, there is a chance that the LazyWriter has already written</span>
05204         <span class="comment">//  it, since the resource was free.  We will only write it if it</span>
05205         <span class="comment">//  is still dirty.</span>
05206         <span class="comment">//</span>
05207 
05208         <span class="keywordflow">if</span> (((<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)Bcb)-&gt;Dirty) {
05209 
05210             <span class="comment">//</span>
05211             <span class="comment">//  First we make sure that the dirty bit in the PFN database is set.</span>
05212             <span class="comment">//</span>
05213 
05214             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( ((<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)Bcb)-&gt;BaseAddress != NULL );
05215             <a class="code" href="../../d5/d6/iosup_8c.html#a74">MmSetAddressRangeModified</a>( ((<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)Bcb)-&gt;BaseAddress,
05216                                        ((<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)Bcb)-&gt;ByteLength );
05217 
05218             <span class="comment">//</span>
05219             <span class="comment">//  Now release the Bcb resource and set it clean.  Note we do not check</span>
05220             <span class="comment">//  here for errors, and just return the I/O status.  Errors on writes</span>
05221             <span class="comment">//  are rare to begin with.  Nonetheless, our strategy is to rely on</span>
05222             <span class="comment">//  one or more of the following (depending on the file system) to prevent</span>
05223             <span class="comment">//  errors from getting to us.</span>
05224             <span class="comment">//</span>
05225             <span class="comment">//      - Retries and/or other forms of error recovery in the disk driver</span>
05226             <span class="comment">//      - Mirroring driver</span>
05227             <span class="comment">//      - Hot fixing in the noncached path of the file system</span>
05228             <span class="comment">//</span>
05229             <span class="comment">//  In the unexpected case that a write error does get through, we</span>
05230             <span class="comment">//  report it to our caller, but go ahead and set the Bcb clean.  There</span>
05231             <span class="comment">//  seems to be no point in letting Bcbs (and pages in physical memory)</span>
05232             <span class="comment">//  accumulate which can never go away because we get an unrecoverable I/O</span>
05233             <span class="comment">//  error.</span>
05234             <span class="comment">//</span>
05235 
05236             <span class="comment">//</span>
05237             <span class="comment">//  We specify TRUE here for ReadOnly so that we will keep the</span>
05238             <span class="comment">//  resource during the flush.</span>
05239             <span class="comment">//</span>
05240 
05241             <a class="code" href="../../d5/d5/cc_8h.html#a176">CcUnpinFileData</a>( (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)Bcb, TRUE, SET_CLEAN );
05242 
05243             <span class="comment">//</span>
05244             <span class="comment">//  Write it out.</span>
05245             <span class="comment">//</span>
05246 
05247             <a class="code" href="../../d6/d5/flushsec_8c.html#a8">MmFlushSection</a>( ((<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)Bcb)-&gt;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o10">FileObject</a>-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o6">SectionObjectPointer</a>,
05248                             &amp;((<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)Bcb)-&gt;FileOffset,
05249                             ((<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)Bcb)-&gt;ByteLength,
05250                             IoStatus,
05251                             TRUE );
05252 
05253             <span class="comment">//</span>
05254             <span class="comment">//  If we got verify required, we have to mark the buffer dirty again</span>
05255             <span class="comment">//  so we will try again later.</span>
05256             <span class="comment">//</span>
05257 
05258             <span class="keywordflow">if</span> (<a class="code" href="../../d6/d2/cachesub_8c.html#a2">RetryError</a>(IoStatus-&gt;Status)) {
05259                 <a class="code" href="../../d4/d2/cache_8h.html#a91">CcSetDirtyPinnedData</a>( (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)Bcb, NULL );
05260             }
05261 
05262             <span class="comment">//</span>
05263             <span class="comment">//  Now remove the final pin count now that we have set it clean.</span>
05264             <span class="comment">//</span>
05265 
05266             <a class="code" href="../../d5/d5/cc_8h.html#a176">CcUnpinFileData</a>( (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)Bcb, FALSE, UNPIN );
05267 
05268             <span class="comment">//</span>
05269             <span class="comment">//  See if there is any deferred writes we can post.</span>
05270             <span class="comment">//</span>
05271 
05272             <span class="keywordflow">if</span> (!IsListEmpty(&amp;CcDeferredWrites)) {
05273                 <a class="code" href="../../d5/d5/cc_8h.html#a174">CcPostDeferredWrites</a>();
05274             }
05275         }
05276         <span class="keywordflow">else</span> {
05277 
05278             <span class="comment">//</span>
05279             <span class="comment">//  Lazy Writer got there first, just free the resource and unpin.</span>
05280             <span class="comment">//</span>
05281 
05282             <a class="code" href="../../d5/d5/cc_8h.html#a176">CcUnpinFileData</a>( (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)Bcb, FALSE, UNPIN );
05283 
05284         }
05285 
05286         <a class="code" href="../../d5/d5/cc_8h.html#a92">DebugTrace2</a>(0, me, <span class="stringliteral">"    &lt;IoStatus = %08lx, %08lx\n"</span>, IoStatus-&gt;Status,
05287                                                              IoStatus-&gt;Information );
05288     }
05289 
05290     <span class="comment">//</span>
05291     <span class="comment">//  Non-WriteThrough case</span>
05292     <span class="comment">//</span>
05293 
05294     <span class="keywordflow">else</span> {
05295 
05296         <a class="code" href="../../d5/d5/cc_8h.html#a176">CcUnpinFileData</a>( (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)Bcb, TRUE, UNPIN );
05297 
05298         <span class="comment">//</span>
05299         <span class="comment">//  Set status to success for non write through case.</span>
05300         <span class="comment">//</span>
05301 
05302         IoStatus-&gt;Status = STATUS_SUCCESS;
05303     }
05304 
05305     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, me, <span class="stringliteral">"CcUnpinRepinnedBcb -&gt; VOID\n"</span>, 0 );
05306 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a85" doxytag="cache.h::CcWaitForCurrentLazyWriterActivity" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS CcWaitForCurrentLazyWriterActivity           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d0/lazyrite_8c-source.html#l00158">158</a> of file <a class="el" href="../../d6/d0/lazyrite_8c-source.html">lazyrite.c</a>.
<p>
References <a class="el" href="../../d6/d4/cc_8h-source.html#l00064">CcAcquireMasterLock</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01847">CcAllocateWorkQueueEntry</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00054">CcPostTickWorkQueue</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00067">CcReleaseMasterLock</a>, <a class="el" href="../../d6/d0/lazyrite_8c-source.html#l00049">CcScheduleLazyWriteScan()</a>, <a class="el" href="../../d9/d8/client_2ntstubs_8c-source.html#l00086">Event()</a>, <a class="el" href="../../d5/d5/cc_8h.html#a210a170">EventSet</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00623">Executive</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01535">_WORK_QUEUE_ENTRY::Function</a>, <a class="el" href="../../d5/d8/ke_8h-source.html#l01066">KeInitializeEvent</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00624">KernelMode</a>, <a class="el" href="../../d2/d6/wait_8c-source.html#l00810">KeWaitForSingleObject()</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00129">LazyWriter</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01471">_LAZY_WRITER::OtherWork</a>, <a class="el" href="../../d2/d9/struct__WORK__QUEUE__ENTRY.html#o7">_WORK_QUEUE_ENTRY::Parameters</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01464">_LAZY_WRITER::ScanActive</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, and <a class="el" href="../../d6/d4/cc_8h-source.html#l01497">_WORK_QUEUE_ENTRY::WorkQueueLinks</a>.
<p>
Referenced by <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l00621">UdfLockVolumeInternal()</a>.
<p>
<pre class="fragment"><div>00163                    :
00164 
00165     This routine allows a thread to receive notification when <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> current tick
00166     of lazy writer work has completed.  It must not be called within a lazy
00167     writer workitem!  The caller must not be holding synchronization that could
00168     block a Cc workitem!
00169     
00170     In particular, <span class="keyword">this</span> lets a caller insure that all avaliable lazy closes at
00171     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> time of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> call have completed.
00172 
00173 Arguments:
00174 
00175     None.
00176 
00177 Return Value:
00178 
00179     Final result of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> wait.    
00180 
00181 --*/
00182 
00183 {
00184     KIRQL OldIrql;
00185     <a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a> <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>;
00186     <a class="code" href="../../d2/d9/struct__WORK__QUEUE__ENTRY.html">PWORK_QUEUE_ENTRY</a> WorkQueueEntry;
00187 
00188     WorkQueueEntry = <a class="code" href="../../d5/d5/cc_8h.html#a88">CcAllocateWorkQueueEntry</a>();
00189 
00190     <span class="keywordflow">if</span> (WorkQueueEntry == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00191         <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
00192     }
00193 
00194     WorkQueueEntry-&gt;<a class="code" href="../../d2/d9/struct__WORK__QUEUE__ENTRY.html#o8">Function</a> = (UCHAR)<a class="code" href="../../d5/d5/cc_8h.html#a210a170">EventSet</a>;
00195     <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( &amp;Event, NotificationEvent, FALSE );
00196     WorkQueueEntry-&gt;<a class="code" href="../../d2/d9/struct__WORK__QUEUE__ENTRY.html#o7">Parameters</a>.Event.Event = &amp;<a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>;
00197 
00198     <span class="comment">//</span>
00199     <span class="comment">//  Add this to the post-tick work queue and wake the lazy writer for it.</span>
00200     <span class="comment">//  The lazy writer will add this to the end of the next batch of work</span>
00201     <span class="comment">//  he issues.</span>
00202     <span class="comment">//</span>
00203 
00204     <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
00205 
00206     InsertTailList( &amp;CcPostTickWorkQueue, &amp;WorkQueueEntry-&gt;<a class="code" href="../../d2/d9/struct__WORK__QUEUE__ENTRY.html#o0">WorkQueueLinks</a> );
00207 
00208     <a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o6">OtherWork</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00209     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o5">ScanActive</a>) {
00210         <a class="code" href="../../d5/d5/cc_8h.html#a185">CcScheduleLazyWriteScan</a>();
00211     }
00212 
00213     <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
00214 
00215     <span class="keywordflow">return</span> <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;Event, Executive, KernelMode, FALSE, NULL );
00216 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a66" doxytag="cache.h::CcZeroData" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTKERNELAPI BOOLEAN CcZeroData           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>FileObject</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PLARGE_INTEGER&nbsp;</td>
          <td class="mdname" nowrap> <em>StartOffset</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PLARGE_INTEGER&nbsp;</td>
          <td class="mdname" nowrap> <em>EndOffset</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN BOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>Wait</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d7/fssup_8c-source.html#l02952">2952</a> of file <a class="el" href="../../d6/d7/fssup_8c-source.html">fssup.c</a>.
<p>
References <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00420">_MDL::ByteCount</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00116">CcAggressiveZeroCount</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00117">CcAggressiveZeroThreshold</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l00116">CcPinFileData()</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l02560">CcSetDirtyPinnedData()</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l00974">CcUnpinFileData()</a>, <a class="el" href="../../d3/d0/mm_8h-source.html#l00221">COMPUTE_PAGES_SPANNED</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02290">DebugTrace</a>, <a class="el" href="../../d9/d8/client_2ntstubs_8c-source.html#l00086">Event()</a>, <a class="el" href="../../d6/d7/ex_8h-source.html#l00253">ExAllocatePoolWithTag</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00623">Executive</a>, <a class="el" href="../../d7/d2/cmwraper_8c-source.html#l00304">ExFreePool()</a>, <a class="el" href="../../d1/d3/ex_2alpha_2raisests_8c-source.html#l00157">ExRaiseStatus()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00497">FlagOn</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01494">FO_WRITE_THROUGH</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l00805">IoAllocateMdl()</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l06744">IoFreeMdl()</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l07247">IoGetRelatedDeviceObject()</a>, <a class="el" href="../../d2/d1/mm_8h.html#a344a168">IoReadAccess</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l10957">IoSynchronousPageWrite()</a>, <a class="el" href="../../d5/d8/ke_8h-source.html#l01066">KeInitializeEvent</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00624">KernelMode</a>, <a class="el" href="../../d4/d4/ppc_2flush_8c-source.html#l00220">KeSweepDcache()</a>, <a class="el" href="../../d2/d6/wait_8c-source.html#l00810">KeWaitForSingleObject()</a>, <a class="el" href="../../d2/d1/mm_8h.html#a347a181">LowPagePriority</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00418">_MDL::MappedSystemVa</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00288">MAX_ZERO_TRANSFER</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00290">MAX_ZEROS_IN_CACHE</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00425">MDL_PAGES_LOCKED</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00426">MDL_SOURCE_IS_NONPAGED_POOL</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00416">_MDL::MdlFlags</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l00033">me</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00289">MIN_ZERO_TRANSFER</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00134">MmAvailablePages</a>, <a class="el" href="../../d6/d5/iosup_8c-source.html#l01500">MmBuildMdlForNonPagedPool()</a>, <a class="el" href="../../d3/d0/mm_8h-source.html#l00924">MmDisablePageFaultClustering</a>, <a class="el" href="../../d3/d0/mm_8h-source.html#l00953">MmEnablePageFaultClustering</a>, <a class="el" href="../../d3/d0/mm_8h-source.html#l00275">MmGetMdlPfnArray</a>, <a class="el" href="../../d3/d0/mm_8h-source.html#l01874">MmGetSystemAddressForMdl</a>, <a class="el" href="../../d3/d0/mm_8h-source.html#l01833">MmGetSystemAddressForMdlSafe</a>, <a class="el" href="../../d6/d5/iosup_8c-source.html#l00238">MmProbeAndLockPages()</a>, <a class="el" href="../../d6/d5/iosup_8c-source.html#l05920">MmSetAddressRangeModified()</a>, <a class="el" href="../../d6/d5/iosup_8c-source.html#l01347">MmUnlockPages()</a>, <a class="el" href="../../d6/d5/iosup_8c-source.html#l03124">MmUnmapLockedPages()</a>, <a class="el" href="../../d5/d8/ex_8h.html#a329a177">NonPagedPoolCacheAligned</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00599">PAGE_SIZE</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01207">_DEVICE_OBJECT::SectorSize</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02154">try_return</a>, and <a class="el" href="../../d5/d5/cc_8h.html#a211a171">UNPIN</a>.
<p>
Referenced by <a class="el" href="../../d4/d0/fastio_8c-source.html#l00330">FsRtlCopyWrite()</a>, and <a class="el" href="../../d4/d0/fastio_8c-source.html#l01474">FsRtlPrepareMdlWriteDev()</a>.
<p>
<pre class="fragment"><div>02961                    :
02962 
02963     This routine attempts to zero <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> data and deliver <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
02964     correct I/O status.
02965 
02966     If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller does not want to block (such as <span class="keywordflow">for</span> disk I/O), then
02967     Wait should be supplied as <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>.  If Wait was supplied as <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> and
02968     <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> currently impossible to zero all of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> requested data without
02969     blocking, then <span class="keyword">this</span> routine will <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>.  However, <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
02970     required space <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> immediately accessible in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> cache and no blocking <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a>
02971     required, <span class="keyword">this</span> routine zeros <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data and returns <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>.
02972 
02973     If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller supplies Wait as <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, then <span class="keyword">this</span> routine <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> guaranteed
02974     to zero <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data and <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>.  If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> correct space <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> immediately
02975     accessible in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> cache, then no blocking will occur.  Otherwise,
02976     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> necessary work will be initiated to read and/or free cache data,
02977     and <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller will be blocked until <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data can be received.
02978 
02979     <a class="code" href="../../d1/d9/icmui_8def.html#a0">File</a> system Fsd's should typically supply Wait = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> <span class="keywordflow">if</span> they are
02980     processing a synchronous I/O requests, or Wait = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> <span class="keywordflow">if</span> they are
02981     processing an asynchronous request.
02982 
02983     <a class="code" href="../../d1/d9/icmui_8def.html#a0">File</a> system threads should supply Wait = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>.
02984 
02985     IMPORTANT NOTE: <a class="code" href="../../d1/d9/icmui_8def.html#a0">File</a> systems which call <span class="keyword">this</span> routine must be prepared
02986     to handle a special form of a write call where <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Mdl <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> already
02987     supplied.  Namely, <span class="keywordflow">if</span> <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o2">MdlAddress</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> supplied, <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> system
02988     must check <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d3/fetypes_8h.html#a457a418">low</a> order bit of <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o2">MdlAddress</a>-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o7">ByteOffset</a>.  If <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a>
02989     <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> set, that means that <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> was generated in <span class="keyword">this</span> routine and
02990     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> system must <span class="keywordflow">do</span> two things:
02991 
02992         Decrement <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o2">MdlAddress</a>-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o7">ByteOffset</a> and <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o26">UserBuffer</a>
02993 
02994         Clear <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o2">MdlAddress</a> immediately prior to completing <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
02995         request, as <span class="keyword">this</span> routine expects to reuse <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Mdl and
02996         ultimately deallocate <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Mdl itself.
02997 
02998 Arguments:
02999 
03000     FileObject - pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> FileObject <span class="keywordflow">for</span> which a range of bytes
03001                  <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> to be zeroed.  This FileObject may either be <span class="keywordflow">for</span>
03002                  a cached <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> or a noncached <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a>.  If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a>
03003                  not cached, then WriteThrough must be <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> and
03004                  StartOffset and EndOffset must be on sector boundaries.
03005 
03006     StartOffset - <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a18">Start</a> offset in <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> to be zeroed.
03007 
03008     EndOffset - <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a19">End</a> offset in <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> to be zeroed.
03009 
03010     Wait - <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> <span class="keywordflow">if</span> caller may not block, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> otherwise (see description
03011            above)
03012 
03013 Return Value:
03014 
03015     <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> - <span class="keywordflow">if</span> Wait was supplied as <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> and <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data was not zeroed.
03016 
03017     <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> - <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data has been zeroed.
03018 
03019 Raises:
03020 
03021     STATUS_INSUFFICIENT_RESOURCES - If a <a class="code" href="../../d4/d6/regext_8c.html#a17">pool</a> allocation <a class="code" href="../../d8/d0/rtbatcr_8c.html#a1">failure</a> occurs.
03022         This can <a class="code" href="../../d3/d0/imm32_8def.html#a1">only</a> occur <span class="keywordflow">if</span> Wait was specified as <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>.  (If Wait <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a>
03023         specified as <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, and an allocation <a class="code" href="../../d8/d0/rtbatcr_8c.html#a1">failure</a> occurs, <span class="keyword">this</span>
03024         routine simply returns <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>.)
03025 
03026 --*/
03027 
03028 {
03029     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap;
03030     PVOID CacheBuffer;
03031     LARGE_INTEGER FOffset;
03032     LARGE_INTEGER ToGo;
03033     ULONG ZeroBytes, ZeroTransfer;
03034     ULONG SectorMask;
03035     ULONG i;
03036     BOOLEAN WriteThrough;
03037     BOOLEAN AggressiveZero = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03038     ULONG SavedState = 0;
03039     ULONG MaxZerosInCache = <a class="code" href="../../d5/d5/cc_8h.html#a37">MAX_ZEROS_IN_CACHE</a>;
03040     ULONG NumberOfColors = 1;
03041 
03042     <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> Bcb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03043     PCHAR Zeros = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03044     <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> ZeroMdl = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03045     ULONG MaxBytesMappedInMdl = 0;
03046     BOOLEAN Result = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03047 
03048     PPFN_NUMBER Page;
03049     ULONG SavedByteCount;
03050     LARGE_INTEGER SizeLeft;
03051 
03052     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, me, <span class="stringliteral">"CcZeroData\n"</span>, 0 );
03053 
03054     WriteThrough = (BOOLEAN)(((FileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a154">FO_WRITE_THROUGH</a>) != 0) ||
03055                    (FileObject-&gt;PrivateCacheMap == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>));
03056 
03057     <span class="comment">//</span>
03058     <span class="comment">//  If the caller specified Wait, but the FileObject is WriteThrough,</span>
03059     <span class="comment">//  then we need to just get out.</span>
03060     <span class="comment">//</span>
03061 
03062     <span class="keywordflow">if</span> (WriteThrough &amp;&amp; !Wait) {
03063 
03064         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, me, <span class="stringliteral">"CcZeroData-&gt;FALSE (WriteThrough &amp;&amp; !Wait)\n"</span>, 0 );
03065 
03066         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03067     }
03068 
03069     SharedCacheMap = FileObject-&gt;SectionObjectPointer-&gt;SharedCacheMap;
03070 
03071     SectorMask = <a class="code" href="../../d4/d6/iosubs_8c.html#a76">IoGetRelatedDeviceObject</a>(FileObject)-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o23">SectorSize</a> - 1;
03072 
03073     FOffset = *StartOffset;
03074 
03075     <span class="comment">//</span>
03076     <span class="comment">//  Calculate how much to zero this time.</span>
03077     <span class="comment">//</span>
03078 
03079     ToGo.QuadPart = EndOffset-&gt;QuadPart - FOffset.QuadPart;
03080 
03081     <span class="comment">//</span>
03082     <span class="comment">//  This magic number is what the fastpaths throttle on, and they will present</span>
03083     <span class="comment">//  non-sector aligned zeroing requests. As long as we will always handle them</span>
03084     <span class="comment">//  on the cached path, we are OK.</span>
03085     <span class="comment">//</span>
03086     <span class="comment">//  If we will not make the cached path, the request must be aligned.</span>
03087     <span class="comment">//</span>
03088     
03089     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( ToGo.QuadPart &lt;= 0x2000 ||
03090             ((ToGo.LowPart &amp; SectorMask) == 0  &amp;&amp;
03091              (FOffset.LowPart &amp; SectorMask) == 0));
03092 
03093     <span class="comment">//</span>
03094     <span class="comment">//  We will only do zeroing in the cache if the caller is using a</span>
03095     <span class="comment">//  cached file object, and did not specify WriteThrough.  We are</span>
03096     <span class="comment">//  willing to zero some data in the cache if our total is not too</span>
03097     <span class="comment">//  much, or there is sufficient available pages.</span>
03098     <span class="comment">//</span>
03099 
03100     <span class="keywordflow">if</span> (((ToGo.QuadPart &lt;= 0x2000) ||
03101          (<a class="code" href="../../d5/d5/cc_8h.html#a94">MmAvailablePages</a> &gt;= ((<a class="code" href="../../d5/d5/cc_8h.html#a37">MAX_ZEROS_IN_CACHE</a> / <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>) * 4))) &amp;&amp; !WriteThrough) {
03102 
03103         <span class="keywordflow">try</span> {
03104 
03105             <span class="keywordflow">while</span> (MaxZerosInCache != 0) {
03106 
03107                 ULONG ReceivedLength;
03108                 LARGE_INTEGER BeyondLastByte;
03109 
03110                 <span class="keywordflow">if</span> ( ToGo.QuadPart &gt; (LONGLONG)MaxZerosInCache ) {
03111 
03112                     <span class="comment">//</span>
03113                     <span class="comment">//  If Wait == FALSE, then there is no point in getting started,</span>
03114                     <span class="comment">//  because we would have to start all over again zeroing with</span>
03115                     <span class="comment">//  Wait == TRUE, since we would fall out of this loop and</span>
03116                     <span class="comment">//  start synchronously writing pages to disk.</span>
03117                     <span class="comment">//</span>
03118 
03119                     <span class="keywordflow">if</span> (!Wait) {
03120 
03121                         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, me, <span class="stringliteral">"CcZeroData -&gt; FALSE\n"</span>, 0 );
03122 
03123                         <a class="code" href="../../d5/d5/cc_8h.html#a90">try_return</a>( Result = FALSE );
03124                     }
03125                 }
03126                 <span class="keywordflow">else</span> {
03127                     MaxZerosInCache = ToGo.LowPart;
03128                 }
03129 
03130                 <span class="comment">//</span>
03131                 <span class="comment">//  Call local routine to Map or Access the file data, then zero the data,</span>
03132                 <span class="comment">//  then call another local routine to free the data.  If we cannot map</span>
03133                 <span class="comment">//  the data because of a Wait condition, return FALSE.</span>
03134                 <span class="comment">//</span>
03135                 <span class="comment">//  Note that this call may result in an exception, however, if it</span>
03136                 <span class="comment">//  does no Bcb is returned and this routine has absolutely no</span>
03137                 <span class="comment">//  cleanup to perform.  Therefore, we do not have a try-finally</span>
03138                 <span class="comment">//  and we allow the possibility that we will simply be unwound</span>
03139                 <span class="comment">//  without notice.</span>
03140                 <span class="comment">//</span>
03141 
03142                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/cc_8h.html#a175">CcPinFileData</a>( FileObject,
03143                                     &amp;FOffset,
03144                                     MaxZerosInCache,
03145                                     FALSE,
03146                                     TRUE,
03147                                     Wait,
03148                                     &amp;Bcb,
03149                                     &amp;CacheBuffer,
03150                                     &amp;BeyondLastByte )) {
03151 
03152                     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, me, <span class="stringliteral">"CcZeroData -&gt; FALSE\n"</span>, 0 );
03153 
03154                     <a class="code" href="../../d5/d5/cc_8h.html#a90">try_return</a>( Result = FALSE );
03155                 }
03156 
03157                 <span class="comment">//</span>
03158                 <span class="comment">//  Calculate how much data is described by Bcb starting at our desired</span>
03159                 <span class="comment">//  file offset.  If it is more than we need, we will zero the whole thing</span>
03160                 <span class="comment">//  anyway.</span>
03161                 <span class="comment">//</span>
03162 
03163                 ReceivedLength = (ULONG)(BeyondLastByte.QuadPart - FOffset.QuadPart );
03164 
03165                 <span class="comment">//</span>
03166                 <span class="comment">//  Now attempt to allocate an Mdl to describe the mapped data.</span>
03167                 <span class="comment">//</span>
03168 
03169                 ZeroMdl = <a class="code" href="../../d4/d6/iosubs_8c.html#a19">IoAllocateMdl</a>( CacheBuffer,
03170                                          ReceivedLength,
03171                                          FALSE,
03172                                          FALSE,
03173                                          NULL );
03174 
03175                 <span class="keywordflow">if</span> (ZeroMdl == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03176 
03177                     <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INSUFFICIENT_RESOURCES );
03178                 }
03179 
03180                 <span class="comment">//</span>
03181                 <span class="comment">//  It is necessary to probe and lock the pages, or else</span>
03182                 <span class="comment">//  the pages may not still be in memory when we do the</span>
03183                 <span class="comment">//  MmSetAddressRangeModified for the dirty Bcb.</span>
03184                 <span class="comment">//</span>
03185 
03186                 <a class="code" href="../../d2/d1/mm_8h.html#a17">MmDisablePageFaultClustering</a>(&amp;SavedState);
03187                 <a class="code" href="../../d5/d6/iosup_8c.html#a41">MmProbeAndLockPages</a>( ZeroMdl, KernelMode, IoReadAccess );
03188                 <a class="code" href="../../d2/d1/mm_8h.html#a18">MmEnablePageFaultClustering</a>(SavedState);
03189                 SavedState = 0;
03190 
03191                 <span class="comment">//</span>
03192                 <span class="comment">//  Assume we did not get all the data we wanted, and set FOffset</span>
03193                 <span class="comment">//  to the end of the returned data, and advance buffer pointer.</span>
03194                 <span class="comment">//</span>
03195 
03196                 FOffset = BeyondLastByte;
03197 
03198                 <span class="comment">//</span>
03199                 <span class="comment">//  Figure out how many bytes we are allowed to zero in the cache.</span>
03200                 <span class="comment">//  Note it is possible we have zeroed a little more than our maximum,</span>
03201                 <span class="comment">//  because we hit an existing Bcb that extended beyond the range.</span>
03202                 <span class="comment">//</span>
03203 
03204                 <span class="keywordflow">if</span> (MaxZerosInCache &lt;= ReceivedLength) {
03205                     MaxZerosInCache = 0;
03206                 }
03207                 <span class="keywordflow">else</span> {
03208                     MaxZerosInCache -= ReceivedLength;
03209                 }
03210 
03211                 <span class="comment">//</span>
03212                 <span class="comment">//  Now set the Bcb dirty.  We have to explicitly set the address</span>
03213                 <span class="comment">//  range modified here, because that work otherwise gets deferred</span>
03214                 <span class="comment">//  to the Lazy Writer.</span>
03215                 <span class="comment">//</span>
03216 
03217                 <a class="code" href="../../d5/d6/iosup_8c.html#a74">MmSetAddressRangeModified</a>( CacheBuffer, ReceivedLength );
03218                 <a class="code" href="../../d4/d2/cache_8h.html#a91">CcSetDirtyPinnedData</a>( Bcb, NULL );
03219 
03220                 <span class="comment">//</span>
03221                 <span class="comment">//  Unmap the data now</span>
03222                 <span class="comment">//</span>
03223 
03224                 <a class="code" href="../../d5/d5/cc_8h.html#a176">CcUnpinFileData</a>( Bcb, FALSE, UNPIN );
03225                 Bcb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03226 
03227                 <span class="comment">//</span>
03228                 <span class="comment">//  Unlock and free the Mdl (we only loop back if we crossed</span>
03229                 <span class="comment">//  a 256KB boundary.</span>
03230                 <span class="comment">//</span>
03231 
03232                 <a class="code" href="../../d5/d6/iosup_8c.html#a45">MmUnlockPages</a>( ZeroMdl );
03233                 <a class="code" href="../../d4/d6/iosubs_8c.html#a65">IoFreeMdl</a>( ZeroMdl );
03234                 ZeroMdl = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03235             }
03236 
03237         try_exit: NOTHING;
03238         } finally {
03239 
03240             <span class="keywordflow">if</span> (SavedState != 0) {
03241                 <a class="code" href="../../d2/d1/mm_8h.html#a18">MmEnablePageFaultClustering</a>(SavedState);
03242             }
03243 
03244             <span class="comment">//</span>
03245             <span class="comment">//  Clean up only necessary in abnormal termination.</span>
03246             <span class="comment">//</span>
03247 
03248             <span class="keywordflow">if</span> (Bcb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03249 
03250                 <a class="code" href="../../d5/d5/cc_8h.html#a176">CcUnpinFileData</a>( Bcb, FALSE, UNPIN );
03251             }
03252 
03253             <span class="comment">//</span>
03254             <span class="comment">//  Since the last thing in the above loop which can</span>
03255             <span class="comment">//  fail is the MmProbeAndLockPages, we only need to</span>
03256             <span class="comment">//  free the Mdl here.</span>
03257             <span class="comment">//</span>
03258 
03259             <span class="keywordflow">if</span> (ZeroMdl != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03260 
03261                 <a class="code" href="../../d4/d6/iosubs_8c.html#a65">IoFreeMdl</a>( ZeroMdl );
03262             }
03263         }
03264 
03265         <span class="comment">//</span>
03266         <span class="comment">//  If hit a wait condition above, return it now.</span>
03267         <span class="comment">//</span>
03268 
03269         <span class="keywordflow">if</span> (!Result) {
03270             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03271         }
03272 
03273         <span class="comment">//</span>
03274         <span class="comment">//  If we finished, get out nbow.</span>
03275         <span class="comment">//</span>
03276 
03277         <span class="keywordflow">if</span> ( FOffset.QuadPart &gt;= EndOffset-&gt;QuadPart ) {
03278             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03279         }
03280     }
03281 
03282     <span class="comment">//</span>
03283     <span class="comment">//  We either get here because we decided above not to zero anything in</span>
03284     <span class="comment">//  the cache directly, or else we zeroed up to our maximum and still</span>
03285     <span class="comment">//  have some left to zero direct to the file on disk.  In either case,</span>
03286     <span class="comment">//  we will now zero from FOffset to *EndOffset, and then flush this</span>
03287     <span class="comment">//  range in case the file is cached/mapped, and there are modified</span>
03288     <span class="comment">//  changes in memory.</span>
03289     <span class="comment">//</span>
03290 
03291     <span class="comment">//</span>
03292     <span class="comment">//  Round FOffset and EndOffset up to sector boundaries, since</span>
03293     <span class="comment">//  we will be doing disk I/O, and calculate size left.</span>
03294     <span class="comment">//</span>
03295 
03296     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( (FOffset.LowPart &amp; SectorMask) == 0 );
03297 
03298     FOffset.QuadPart += (LONGLONG)SectorMask;
03299     FOffset.LowPart &amp;= ~SectorMask;
03300     SizeLeft.QuadPart = EndOffset-&gt;QuadPart + (LONGLONG)SectorMask;
03301     SizeLeft.LowPart &amp;= ~SectorMask;
03302     SizeLeft.QuadPart -= FOffset.QuadPart;
03303 
03304     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( (FOffset.LowPart &amp; SectorMask) == 0 );
03305     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( (SizeLeft.LowPart &amp; SectorMask) == 0 );
03306 
03307     <span class="keywordflow">if</span> (SizeLeft.QuadPart == 0) {
03308         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03309     }
03310 
03311     <span class="comment">//</span>
03312     <span class="comment">//  try-finally to guarantee cleanup.</span>
03313     <span class="comment">//</span>
03314 
03315     <span class="keywordflow">try</span> {
03316         
03317         <span class="comment">//</span>
03318         <span class="comment">//  Allocate a page to hold the zeros we will write, and</span>
03319         <span class="comment">//  zero it.</span>
03320         <span class="comment">//</span>
03321 
03322         ZeroBytes = NumberOfColors * <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
03323 
03324         <span class="keywordflow">if</span> (SizeLeft.HighPart == 0 &amp;&amp; SizeLeft.LowPart &lt; ZeroBytes) {
03325             ZeroBytes = SizeLeft.LowPart;
03326         }
03327 
03328         Zeros = (PCHAR)<a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( NonPagedPoolCacheAligned, ZeroBytes, 'eZcC' );
03329 
03330         <span class="keywordflow">if</span> (Zeros != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03331 
03332             <span class="comment">//</span>
03333             <span class="comment">//  Allocate and initialize an Mdl to describe the zeros</span>
03334             <span class="comment">//  we need to transfer.  Allocate to cover the maximum</span>
03335             <span class="comment">//  size required, and we will use and reuse it in the</span>
03336             <span class="comment">//  loop below, initialized correctly.</span>
03337             <span class="comment">//</span>
03338 
03339             <span class="keywordflow">if</span> (SizeLeft.HighPart == 0 &amp;&amp; SizeLeft.LowPart &lt; <a class="code" href="../../d5/d5/cc_8h.html#a35">MAX_ZERO_TRANSFER</a>) {
03340 
03341                 ZeroTransfer = SizeLeft.LowPart;
03342 
03343             } <span class="keywordflow">else</span> {
03344 
03345                 <span class="comment">//</span>
03346                 <span class="comment">//  See how aggressive we can afford to be.</span>
03347                 <span class="comment">//</span>
03348 
03349                 <span class="keywordflow">if</span> (InterlockedIncrement( &amp;CcAggressiveZeroCount ) &lt;= <a class="code" href="../../d5/d2/cachedat_8c.html#a39">CcAggressiveZeroThreshold</a>) {
03350                     AggressiveZero = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03351                     ZeroTransfer = <a class="code" href="../../d5/d5/cc_8h.html#a35">MAX_ZERO_TRANSFER</a>;
03352                 } <span class="keywordflow">else</span> {
03353                     InterlockedDecrement( &amp;CcAggressiveZeroCount );
03354                     ZeroTransfer = <a class="code" href="../../d5/d5/cc_8h.html#a36">MIN_ZERO_TRANSFER</a>;
03355                 }
03356             }
03357 
03358             <span class="comment">//</span>
03359             <span class="comment">//  Since the maximum zero may start at a very aggresive level, fall back</span>
03360             <span class="comment">//  until we really have to give up.  Since filter drivers, filesystems and</span>
03361             <span class="comment">//  even storage drivers may need to map this Mdl, we have to pre-map it</span>
03362             <span class="comment">//  into system space so that we know enough PTEs are avaliable.  We also</span>
03363             <span class="comment">//  need to throttle our consumption of virtual addresses based on the size</span>
03364             <span class="comment">//  of the system and the number of parallel instances of this work outstanding.</span>
03365             <span class="comment">//  This may be a bit of overkill, but since running out of PTEs is a fatal</span>
03366             <span class="comment">//  event for the rest of the system, try to help out while still being fast.</span>
03367             <span class="comment">//</span>
03368 
03369             <span class="keywordflow">while</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
03370 
03371                 <span class="comment">//</span>
03372                 <span class="comment">//  Spin down trying to get an MDL which can describe our operation.</span>
03373                 <span class="comment">//</span>
03374                 
03375                 <span class="keywordflow">while</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
03376 
03377                     ZeroMdl = <a class="code" href="../../d4/d6/iosubs_8c.html#a19">IoAllocateMdl</a>( Zeros, ZeroTransfer, FALSE, FALSE, NULL );
03378                     
03379                     <span class="comment">//</span>
03380                     <span class="comment">//  Throttle ourselves to what we've physically allocated.  Note that</span>
03381                     <span class="comment">//  we could have started with an odd multiple of this number.  If we</span>
03382                     <span class="comment">//  tried for exactly that size and failed, we're toast.</span>
03383                     <span class="comment">//</span>
03384                     
03385                     <span class="keywordflow">if</span> (ZeroMdl || ZeroTransfer == ZeroBytes) {
03386                         
03387                         <span class="keywordflow">break</span>;
03388                     }
03389                     
03390                     Fall_Back:
03391                     
03392                     <span class="comment">//</span>
03393                     <span class="comment">//  Fallback by half and round down to a sector multiple.</span>
03394                     <span class="comment">//</span>
03395                         
03396                     ZeroTransfer /= 2;
03397                     ZeroTransfer &amp;= ~SectorMask;
03398                     <span class="keywordflow">if</span> (ZeroTransfer &lt; ZeroBytes) {
03399                         ZeroTransfer = ZeroBytes;
03400                     }
03401 
03402                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( (ZeroTransfer &amp; SectorMask) == 0 &amp;&amp; ZeroTransfer != 0);
03403                 }
03404 
03405                 <span class="keywordflow">if</span> (ZeroMdl == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03406                     
03407                     <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INSUFFICIENT_RESOURCES );
03408                 }
03409 
03410                 <span class="comment">//</span>
03411                 <span class="comment">//  If we have throttled all the way down, stop and just build a</span>
03412                 <span class="comment">//  simple MDL describing our previous allocation.</span>
03413                 <span class="comment">//</span>
03414 
03415                 <span class="keywordflow">if</span> (ZeroTransfer == ZeroBytes) {
03416 
03417                     <a class="code" href="../../d5/d6/iosup_8c.html#a46">MmBuildMdlForNonPagedPool</a>( ZeroMdl );
03418                     <span class="keywordflow">break</span>;
03419                 }
03420 
03421                 <span class="comment">//</span>
03422                 <span class="comment">//  Now we will temporarily lock the allocated pages</span>
03423                 <span class="comment">//  only, and then replicate the page frame numbers through</span>
03424                 <span class="comment">//  the entire Mdl to keep writing the same pages of zeros.</span>
03425                 <span class="comment">//</span>
03426                 <span class="comment">//  It would be nice if Mm exported a way for us to not have</span>
03427                 <span class="comment">//  to pull the Mdl apart and rebuild it ourselves, but this</span>
03428                 <span class="comment">//  is so bizzare a purpose as to be tolerable.</span>
03429                 <span class="comment">//</span>
03430 
03431                 SavedByteCount = ZeroMdl-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o6">ByteCount</a>;
03432                 ZeroMdl-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o6">ByteCount</a> = ZeroBytes;
03433                 <a class="code" href="../../d5/d6/iosup_8c.html#a46">MmBuildMdlForNonPagedPool</a>( ZeroMdl );
03434 
03435                 ZeroMdl-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o2">MdlFlags</a> &amp;= ~<a class="code" href="../../d0/d9/ntosdef_8h.html#a14">MDL_SOURCE_IS_NONPAGED_POOL</a>;
03436                 ZeroMdl-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o2">MdlFlags</a> |= <a class="code" href="../../d0/d9/ntosdef_8h.html#a13">MDL_PAGES_LOCKED</a>;
03437                 ZeroMdl-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o4">MappedSystemVa</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03438                 ZeroMdl-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o6">ByteCount</a> = SavedByteCount;
03439                 Page = <a class="code" href="../../d2/d1/mm_8h.html#a11">MmGetMdlPfnArray</a>( ZeroMdl );
03440                 <span class="keywordflow">for</span> (i = NumberOfColors;
03441                      i &lt; (<a class="code" href="../../d2/d1/mm_8h.html#a9">COMPUTE_PAGES_SPANNED</a>( 0, SavedByteCount ));
03442                      i++) {
03443 
03444                     *(Page + i) = *(Page + i - NumberOfColors);
03445                 }
03446 
03447                 <span class="keywordflow">if</span> (<a class="code" href="../../d2/d1/mm_8h.html#a25">MmGetSystemAddressForMdlSafe</a>( ZeroMdl, LowPagePriority ) == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03448 
03449                     <span class="comment">//</span>
03450                     <span class="comment">//  Blow away this Mdl and trim for the retry.  Since it didn't</span>
03451                     <span class="comment">//  get mapped, there is nothing fancy to do. </span>
03452                     <span class="comment">//</span>
03453 
03454                     <a class="code" href="../../d4/d6/iosubs_8c.html#a65">IoFreeMdl</a>( ZeroMdl );
03455                     <span class="keywordflow">goto</span> Fall_Back;
03456                 }
03457 
03458                 <span class="keywordflow">break</span>;
03459             }
03460 
03461         <span class="comment">//</span>
03462         <span class="comment">//  We failed to allocate the space we wanted, so we will go to</span>
03463         <span class="comment">//  half of a page and limp along.</span>
03464         <span class="comment">//</span>
03465 
03466         } <span class="keywordflow">else</span> {
03467 
03468             <span class="comment">//</span>
03469             <span class="comment">//  Of course, if we have a device which has large sectors, that defines</span>
03470             <span class="comment">//  the lower limit of our attempt.</span>
03471             <span class="comment">//</span>
03472 
03473             <span class="keywordflow">if</span> (<a class="code" href="../../d4/d6/iosubs_8c.html#a76">IoGetRelatedDeviceObject</a>(FileObject)-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o23">SectorSize</a> &lt; <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> / 2) {
03474                 
03475                 ZeroBytes = <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> / 2;
03476                 Zeros = (PCHAR)<a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( NonPagedPoolCacheAligned, ZeroBytes, 'eZcC' );
03477             }
03478 
03479             <span class="comment">//</span>
03480             <span class="comment">//  If we cannot get even that much, then let's write a sector at a time.</span>
03481             <span class="comment">//</span>
03482 
03483             <span class="keywordflow">if</span> (Zeros == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03484                 
03485                 ZeroBytes = <a class="code" href="../../d4/d6/iosubs_8c.html#a76">IoGetRelatedDeviceObject</a>(FileObject)-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o23">SectorSize</a>;
03486                 Zeros = (PCHAR)<a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( NonPagedPoolCacheAligned, ZeroBytes, 'eZcC' );
03487 
03488                 <span class="comment">//</span>
03489                 <span class="comment">//  If we cannot get even the minimum, we have to give up.</span>
03490                 <span class="comment">//</span>
03491 
03492                 <span class="keywordflow">if</span> (Zeros == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03493                     <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INSUFFICIENT_RESOURCES );
03494                 }
03495             }
03496 
03497             <span class="comment">//</span>
03498             <span class="comment">//  Allocate and initialize an Mdl to describe the zeros</span>
03499             <span class="comment">//  we need to transfer.  Allocate to cover the maximum</span>
03500             <span class="comment">//  size required, and we will use and reuse it in the</span>
03501             <span class="comment">//  loop below, initialized correctly.</span>
03502             <span class="comment">//</span>
03503 
03504             ZeroTransfer = ZeroBytes;
03505             ZeroMdl = <a class="code" href="../../d4/d6/iosubs_8c.html#a19">IoAllocateMdl</a>( Zeros, ZeroBytes, FALSE, FALSE, NULL );
03506 
03507             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( (ZeroTransfer &amp; SectorMask) == 0 );
03508 
03509             <span class="keywordflow">if</span> (ZeroMdl == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03510                 <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INSUFFICIENT_RESOURCES );
03511             }
03512 
03513             <span class="comment">//</span>
03514             <span class="comment">//  Now we will lock and map the allocated pages.</span>
03515             <span class="comment">//</span>
03516 
03517             <a class="code" href="../../d5/d6/iosup_8c.html#a46">MmBuildMdlForNonPagedPool</a>( ZeroMdl );
03518 
03519             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( ZeroMdl-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o4">MappedSystemVa</a> == Zeros );
03520         }
03521 
03522 <span class="preprocessor">#ifdef MIPS</span>
03523 <span class="preprocessor"></span><span class="preprocessor">#ifdef MIPS_PREFILL</span>
03524 <span class="preprocessor"></span>        RtlFillMemory( Zeros, ZeroBytes, 0xDD );
03525         <a class="code" href="../../d3/d5/ppc_2flush_8c.html#a6">KeSweepDcache</a>( TRUE );
03526 <span class="preprocessor">#endif</span>
03527 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
03528 <span class="preprocessor"></span>
03529         <span class="comment">//</span>
03530         <span class="comment">//  Zero the buffer now.</span>
03531         <span class="comment">//</span>
03532 
03533         RtlZeroMemory( Zeros, ZeroBytes );
03534 
03535         <span class="comment">//</span>
03536         <span class="comment">//  We have a mapped and zeroed range back by an MDL to use.  Note the</span>
03537         <span class="comment">//  size we have for cleanup, since we will possibly wind this down</span>
03538         <span class="comment">//  over the operation.</span>
03539         <span class="comment">//</span>
03540 
03541         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d2/d1/mm_8h.html#a26">MmGetSystemAddressForMdl</a>(ZeroMdl) );
03542         MaxBytesMappedInMdl = ZeroMdl-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o6">ByteCount</a>;
03543 
03544         <span class="comment">//</span>
03545         <span class="comment">//  Now loop to write buffers full of zeros through to the file</span>
03546         <span class="comment">//  until we reach the starting Vbn for the transfer.</span>
03547         <span class="comment">//</span>
03548 
03549         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( ZeroTransfer != 0 &amp;&amp;
03550                 (ZeroTransfer &amp; SectorMask) == 0 &amp;&amp;
03551                 (SizeLeft.LowPart &amp; SectorMask) == 0 );
03552 
03553         <span class="keywordflow">while</span> ( SizeLeft.QuadPart != 0 ) {
03554 
03555             IO_STATUS_BLOCK IoStatus;
03556             <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
03557             <a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a> <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>;
03558 
03559             <span class="comment">//</span>
03560             <span class="comment">//  See if we really need to write that many zeros, and</span>
03561             <span class="comment">//  trim the size back if not.</span>
03562             <span class="comment">//</span>
03563 
03564             <span class="keywordflow">if</span> ( (LONGLONG)ZeroTransfer &gt; SizeLeft.QuadPart ) {
03565 
03566                 ZeroTransfer = SizeLeft.LowPart;
03567             }
03568 
03569             <span class="comment">//</span>
03570             <span class="comment">//  (Re)initialize the kernel event to FALSE.</span>
03571             <span class="comment">//</span>
03572 
03573             <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( &amp;Event, NotificationEvent, FALSE );
03574 
03575             <span class="comment">//</span>
03576             <span class="comment">//  Initiate and wait for the synchronous transfer.</span>
03577             <span class="comment">//</span>
03578 
03579             ZeroMdl-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o6">ByteCount</a> = ZeroTransfer;
03580 
03581             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d4/d6/iosubs_8c.html#a116">IoSynchronousPageWrite</a>( FileObject,
03582                                              ZeroMdl,
03583                                              &amp;FOffset,
03584                                              &amp;Event,
03585                                              &amp;IoStatus );
03586 
03587             <span class="comment">//</span>
03588             <span class="comment">//  If pending is returned (which is a successful status),</span>
03589             <span class="comment">//  we must wait for the request to complete.</span>
03590             <span class="comment">//</span>
03591 
03592             <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_PENDING) {
03593                 <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;Event,
03594                                        Executive,
03595                                        KernelMode,
03596                                        FALSE,
03597                                        (PLARGE_INTEGER)NULL);
03598             }
03599 
03600 
03601             <span class="comment">//</span>
03602             <span class="comment">//  If we got an error back in Status, then the Iosb</span>
03603             <span class="comment">//  was not written, so we will just copy the status</span>
03604             <span class="comment">//  there, then test the final status after that.</span>
03605             <span class="comment">//</span>
03606 
03607             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(Status)) {
03608                 <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( Status );
03609             }
03610 
03611             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(IoStatus.Status)) {
03612                 <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( IoStatus.Status );
03613             }
03614 
03615             <span class="comment">//</span>
03616             <span class="comment">//  If we succeeded, then update where we are at by how much</span>
03617             <span class="comment">//  we wrote, and loop back to see if there is more.</span>
03618             <span class="comment">//</span>
03619 
03620             FOffset.QuadPart = FOffset.QuadPart + (LONGLONG)ZeroTransfer;
03621             SizeLeft.QuadPart = SizeLeft.QuadPart - (LONGLONG)ZeroTransfer;
03622         }
03623     }
03624     finally{
03625 
03626         <span class="comment">//</span>
03627         <span class="comment">//  Clean up anything from zeroing pages on a noncached</span>
03628         <span class="comment">//  write.</span>
03629         <span class="comment">//</span>
03630 
03631         <span class="keywordflow">if</span> (ZeroMdl != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03632 
03633             <span class="keywordflow">if</span> ((MaxBytesMappedInMdl != 0) &amp;&amp;
03634                 !<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(ZeroMdl-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o2">MdlFlags</a>, MDL_SOURCE_IS_NONPAGED_POOL)) {
03635                 ZeroMdl-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o6">ByteCount</a> = MaxBytesMappedInMdl;
03636                 <a class="code" href="../../d5/d6/iosup_8c.html#a56">MmUnmapLockedPages</a> (ZeroMdl-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o4">MappedSystemVa</a>, ZeroMdl);
03637             }
03638 
03639             <a class="code" href="../../d4/d6/iosubs_8c.html#a65">IoFreeMdl</a>( ZeroMdl );
03640         }
03641 
03642         <span class="keywordflow">if</span> (AggressiveZero) {
03643             InterlockedDecrement( &amp;CcAggressiveZeroCount );
03644         }
03645 
03646         <span class="keywordflow">if</span> (Zeros != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03647             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( Zeros );
03648         }
03649 
03650         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, me, <span class="stringliteral">"CcZeroData -&gt; TRUE\n"</span>, 0 );
03651     }
03652 
03653     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03654 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a65" doxytag="cache.h::CcZeroEndOfLastPage" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTKERNELAPI VOID CcZeroEndOfLastPage           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>FileObject</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d7/fssup_8c-source.html#l02804">2804</a> of file <a class="el" href="../../d6/d7/fssup_8c-source.html">fssup.c</a>.
<p>
References <a class="el" href="../../d6/d4/cc_8h-source.html#l00802">_SHARED_CACHE_MAP::ActiveVacb</a>, <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00064">CcAcquireMasterLock</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01010">CcDecrementOpenCount</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00031">CcDirtySharedCacheMapList</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l04411">CcFlushCache()</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l05885">CcFreeActiveVacb()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01003">CcIncrementOpenCount</a>, <a class="el" href="../../d6/d7/fssup_8c-source.html#l02331">CcPurgeCacheSection()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00067">CcReleaseMasterLock</a>, <a class="el" href="../../d6/d0/lazyrite_8c-source.html#l00049">CcScheduleLazyWriteScan()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00846">_SHARED_CACHE_MAP::DirtyPages</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00497">FlagOn</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00832">_SHARED_CACHE_MAP::Flags</a>, <a class="el" href="../../d2/d7/fsrtl_8h-source.html#l00272">FSRTL_FLAG2_PURGE_WHEN_MAPPED</a>, <a class="el" href="../../d2/d7/fsrtl_8h-source.html#l00236">FSRTL_FLAG_ADVANCED_HEADER</a>, <a class="el" href="../../d2/d7/fsrtl_8h-source.html#l00229">FSRTL_FLAG_USER_MAPPED_FILE</a>, <a class="el" href="../../d4/d0/fastio_8c-source.html#l02555">FsRtlAcquireFileExclusive()</a>, <a class="el" href="../../d4/d0/fastio_8c-source.html#l02628">FsRtlReleaseFile()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01588">GetActiveVacbAtDpcLevel</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00129">LazyWriter</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00809">_SHARED_CACHE_MAP::NeedToZero</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00740">_SHARED_CACHE_MAP::OpenCount</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01471">_LAZY_WRITER::OtherWork</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01464">_LAZY_WRITER::ScanActive</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00505">SetFlag</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01113">_SHARED_CACHE_MAP_LIST_CURSOR::SharedCacheMapLinks</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00826">_SHARED_CACHE_MAP::SharedCacheMapLinks</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, and <a class="el" href="../../d6/d4/cc_8h-source.html#l01051">WRITE_QUEUED</a>.
<p>
Referenced by <a class="el" href="../../d1/d7/creasect_8c-source.html#l01424">MiCreateImageFileMap()</a>, and <a class="el" href="../../d1/d7/creasect_8c-source.html#l00134">NtCreateSection()</a>.
<p>
<pre class="fragment"><div>02810                    :
02811 
02812     This routine <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> <a class="code" href="../../d3/d0/imm32_8def.html#a1">only</a> called by Mm before mapping a user view to
02813     a section.  If there <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> an uninitialized page at <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> end of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
02814     <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a>, we zero <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> by freeing that page.
02815 
02816 Parameters:
02817 
02818     FileObject - <a class="code" href="../../d1/d9/icmui_8def.html#a0">File</a> object <span class="keywordflow">for</span> section to be mapped
02819 
02820 Return Value:
02821 
02822     None
02823 --*/
02824 
02825 {
02826     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap;
02827     ULONG ActivePage;
02828     ULONG PageIsDirty;
02829     KIRQL OldIrql;
02830     PVOID NeedToZero = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02831     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> ActiveVacb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02832     IO_STATUS_BLOCK Iosb;
02833     BOOLEAN PurgeResult;
02834 
02835     <span class="comment">//</span>
02836     <span class="comment">//  See if we have an active Vacb, that we need to free.</span>
02837     <span class="comment">//</span>
02838 
02839     <a class="code" href="../../d1/d8/fsrtl_8h.html#a107">FsRtlAcquireFileExclusive</a>( FileObject );
02840     <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
02841     SharedCacheMap = FileObject-&gt;SectionObjectPointer-&gt;SharedCacheMap;
02842 
02843     <span class="keywordflow">if</span> (SharedCacheMap != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02844 
02845         <span class="comment">//</span>
02846         <span class="comment">//  See if there is an active vacb.</span>
02847         <span class="comment">//</span>
02848 
02849         <span class="keywordflow">if</span> ((SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o11">ActiveVacb</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) || ((NeedToZero = SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o13">NeedToZero</a>) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
02850 
02851             <a class="code" href="../../d5/d5/cc_8h.html#a68">CcIncrementOpenCount</a>( SharedCacheMap, 'peZS' );
02852             <a class="code" href="../../d5/d5/cc_8h.html#a83">GetActiveVacbAtDpcLevel</a>( SharedCacheMap, ActiveVacb, ActivePage, PageIsDirty );
02853         }
02854     }
02855 
02856     <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
02857 
02858     <span class="comment">//</span>
02859     <span class="comment">//  Remember in FsRtl header is there is a user section.</span>
02860     <span class="comment">//  If this is an advanced header then also acquire the mutex to access</span>
02861     <span class="comment">//  this field.</span>
02862     <span class="comment">//</span>
02863 
02864     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( ((<a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html">PFSRTL_COMMON_FCB_HEADER</a>)FileObject-&gt;FsContext)-&gt;Flags,
02865                 FSRTL_FLAG_ADVANCED_HEADER )) {
02866 
02867         ExAcquireFastMutex( ((<a class="code" href="../../d9/d0/struct__FSRTL__ADVANCED__FCB__HEADER.html">PFSRTL_ADVANCED_FCB_HEADER</a>)FileObject-&gt;FsContext)-&gt;FastMutex );
02868 
02869         <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>( ((<a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html">PFSRTL_COMMON_FCB_HEADER</a>)FileObject-&gt;FsContext)-&gt;Flags,
02870                  FSRTL_FLAG_USER_MAPPED_FILE );
02871 
02872         ExReleaseFastMutex( ((<a class="code" href="../../d9/d0/struct__FSRTL__ADVANCED__FCB__HEADER.html">PFSRTL_ADVANCED_FCB_HEADER</a>)FileObject-&gt;FsContext)-&gt;FastMutex );
02873 
02874     } <span class="keywordflow">else</span> {
02875 
02876         <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>( ((<a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html">PFSRTL_COMMON_FCB_HEADER</a>)FileObject-&gt;FsContext)-&gt;Flags,
02877                  FSRTL_FLAG_USER_MAPPED_FILE );
02878     }
02879 
02880     <span class="comment">//</span>
02881     <span class="comment">//  Free the active vacb now so we don't deadlock if we have to purge</span>
02882     <span class="comment">//</span>
02883 
02884 
02885     <span class="keywordflow">if</span> ((ActiveVacb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) || (NeedToZero != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
02886         <a class="code" href="../../d5/d5/cc_8h.html#a182">CcFreeActiveVacb</a>( SharedCacheMap, ActiveVacb, ActivePage, PageIsDirty );
02887     }
02888 
02889 
02890     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( ((<a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html">PFSRTL_COMMON_FCB_HEADER</a>)FileObject-&gt;FsContext)-&gt;Flags2, FSRTL_FLAG2_PURGE_WHEN_MAPPED )) {
02891 
02892         <span class="keywordflow">if</span> (FileObject-&gt;SectionObjectPointer-&gt;SharedCacheMap) {
02893             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( ((<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a>)(FileObject-&gt;SectionObjectPointer-&gt;SharedCacheMap))-&gt;VacbActiveCount == 0 );
02894         }
02895 
02896         <a class="code" href="../../d4/d2/cache_8h.html#a63">CcFlushCache</a>( FileObject-&gt;SectionObjectPointer, NULL, 0, &amp;Iosb );
02897         PurgeResult = <a class="code" href="../../d4/d2/cache_8h.html#a61">CcPurgeCacheSection</a>( FileObject-&gt;SectionObjectPointer, NULL, 0, FALSE );
02898 
02899         <span class="keywordflow">if</span> (FileObject-&gt;SectionObjectPointer-&gt;SharedCacheMap) {
02900             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( ((<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a>)(FileObject-&gt;SectionObjectPointer-&gt;SharedCacheMap))-&gt;VacbActiveCount == 0 );
02901         }
02902     }
02903 
02904 
02905     <a class="code" href="../../d1/d8/fsrtl_8h.html#a108">FsRtlReleaseFile</a>( FileObject );
02906 
02907     <span class="comment">//</span>
02908     <span class="comment">//  If the file is cached and we have a Vacb to free, we need to</span>
02909     <span class="comment">//  use the lazy writer callback to synchronize so no one will be</span>
02910     <span class="comment">//  extending valid data.</span>
02911     <span class="comment">//</span>
02912 
02913     <span class="keywordflow">if</span> ((ActiveVacb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) || (NeedToZero != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
02914 
02915         <span class="comment">//</span>
02916         <span class="comment">//  Serialize again to decrement the open count.</span>
02917         <span class="comment">//</span>
02918 
02919         <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
02920 
02921         <a class="code" href="../../d5/d5/cc_8h.html#a69">CcDecrementOpenCount</a>( SharedCacheMap, 'peZF' );
02922 
02923         <span class="keywordflow">if</span> ((SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o2">OpenCount</a> == 0) &amp;&amp;
02924             !<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, WRITE_QUEUED) &amp;&amp;
02925             (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o20">DirtyPages</a> == 0)) {
02926 
02927             <span class="comment">//</span>
02928             <span class="comment">//  Move to the dirty list.</span>
02929             <span class="comment">//</span>
02930 
02931             RemoveEntryList( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a> );
02932             InsertTailList( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a2">CcDirtySharedCacheMapList</a>.<a class="code" href="../../d1/d3/struct__SHARED__CACHE__MAP__LIST__CURSOR.html#o0">SharedCacheMapLinks</a>,
02933                             &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a> );
02934 
02935             <span class="comment">//</span>
02936             <span class="comment">//  Make sure the Lazy Writer will wake up, because we</span>
02937             <span class="comment">//  want him to delete this SharedCacheMap.</span>
02938             <span class="comment">//</span>
02939 
02940             <a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o6">OtherWork</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02941             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o5">ScanActive</a>) {
02942                 <a class="code" href="../../d5/d5/cc_8h.html#a185">CcScheduleLazyWriteScan</a>();
02943             }
02944         }
02945 
02946         <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
02947     }
02948 }

</div></pre>    </td>
  </tr>
</table>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="a42" doxytag="cache.h::CcCopyReadNoWait" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ULONG <a class="el" href="../../d4/d2/cache_8h.html#a42">CcCopyReadNoWait</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d1/cache_8h-source.html#l00211">211</a> of file <a class="el" href="../../d5/d1/cache_8h-source.html">cache.h</a>.
<p>
Referenced by <a class="el" href="../../d6/d6/copysup_8c-source.html#l00031">CcCopyRead()</a>, and <a class="el" href="../../d7/d7/sysinfo_8c-source.html#l00941">NtQuerySystemInformation()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a44" doxytag="cache.h::CcCopyReadNoWaitMiss" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ULONG <a class="el" href="../../d4/d2/cache_8h.html#a44">CcCopyReadNoWaitMiss</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d1/cache_8h-source.html#l00213">213</a> of file <a class="el" href="../../d5/d1/cache_8h-source.html">cache.h</a>.
<p>
Referenced by <a class="el" href="../../d6/d6/copysup_8c-source.html#l00031">CcCopyRead()</a>, and <a class="el" href="../../d7/d7/sysinfo_8c-source.html#l00941">NtQuerySystemInformation()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a43" doxytag="cache.h::CcCopyReadWait" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ULONG <a class="el" href="../../d4/d2/cache_8h.html#a43">CcCopyReadWait</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d1/cache_8h-source.html#l00212">212</a> of file <a class="el" href="../../d5/d1/cache_8h-source.html">cache.h</a>.
<p>
Referenced by <a class="el" href="../../d6/d6/copysup_8c-source.html#l00031">CcCopyRead()</a>, <a class="el" href="../../d6/d6/copysup_8c-source.html#l00588">CcFastCopyRead()</a>, and <a class="el" href="../../d7/d7/sysinfo_8c-source.html#l00941">NtQuerySystemInformation()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a45" doxytag="cache.h::CcCopyReadWaitMiss" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ULONG <a class="el" href="../../d4/d2/cache_8h.html#a45">CcCopyReadWaitMiss</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d1/cache_8h-source.html#l00214">214</a> of file <a class="el" href="../../d5/d1/cache_8h-source.html">cache.h</a>.
<p>
Referenced by <a class="el" href="../../d6/d6/copysup_8c-source.html#l00031">CcCopyRead()</a>, <a class="el" href="../../d6/d6/copysup_8c-source.html#l00588">CcFastCopyRead()</a>, and <a class="el" href="../../d7/d7/sysinfo_8c-source.html#l00941">NtQuerySystemInformation()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a53" doxytag="cache.h::CcDataFlushes" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ULONG <a class="el" href="../../d4/d2/cache_8h.html#a53">CcDataFlushes</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d1/cache_8h-source.html#l00225">225</a> of file <a class="el" href="../../d5/d1/cache_8h-source.html">cache.h</a>.
<p>
Referenced by <a class="el" href="../../d5/d5/iosubs_8c-source.html#l10957">IoSynchronousPageWrite()</a>, and <a class="el" href="../../d7/d7/sysinfo_8c-source.html#l00941">NtQuerySystemInformation()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a54" doxytag="cache.h::CcDataPages" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ULONG <a class="el" href="../../d4/d2/cache_8h.html#a54">CcDataPages</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d1/cache_8h-source.html#l00226">226</a> of file <a class="el" href="../../d5/d1/cache_8h-source.html">cache.h</a>.
<p>
Referenced by <a class="el" href="../../d5/d5/iosubs_8c-source.html#l10957">IoSynchronousPageWrite()</a>, and <a class="el" href="../../d7/d7/sysinfo_8c-source.html#l00941">NtQuerySystemInformation()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a32" doxytag="cache.h::CcFastMdlReadNotPossible" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ULONG <a class="el" href="../../d4/d2/cache_8h.html#a32">CcFastMdlReadNotPossible</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d1/cache_8h-source.html#l00197">197</a> of file <a class="el" href="../../d5/d1/cache_8h-source.html">cache.h</a>.
<p>
Referenced by <a class="el" href="../../d4/d0/fastio_8c-source.html#l01064">FsRtlMdlReadDev()</a>, and <a class="el" href="../../d7/d7/sysinfo_8c-source.html#l00941">NtQuerySystemInformation()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a29" doxytag="cache.h::CcFastMdlReadNoWait" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ULONG <a class="el" href="../../d4/d2/cache_8h.html#a29">CcFastMdlReadNoWait</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d1/cache_8h-source.html#l00194">194</a> of file <a class="el" href="../../d5/d1/cache_8h-source.html">cache.h</a>.
<p>
Referenced by <a class="el" href="../../d7/d7/sysinfo_8c-source.html#l00941">NtQuerySystemInformation()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a31" doxytag="cache.h::CcFastMdlReadResourceMiss" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ULONG <a class="el" href="../../d4/d2/cache_8h.html#a31">CcFastMdlReadResourceMiss</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d1/cache_8h-source.html#l00196">196</a> of file <a class="el" href="../../d5/d1/cache_8h-source.html">cache.h</a>.
<p>
Referenced by <a class="el" href="../../d7/d7/sysinfo_8c-source.html#l00941">NtQuerySystemInformation()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a30" doxytag="cache.h::CcFastMdlReadWait" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ULONG <a class="el" href="../../d4/d2/cache_8h.html#a30">CcFastMdlReadWait</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d1/cache_8h-source.html#l00195">195</a> of file <a class="el" href="../../d5/d1/cache_8h-source.html">cache.h</a>.
<p>
Referenced by <a class="el" href="../../d4/d0/fastio_8c-source.html#l01064">FsRtlMdlReadDev()</a>, and <a class="el" href="../../d7/d7/sysinfo_8c-source.html#l00941">NtQuerySystemInformation()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a28" doxytag="cache.h::CcFastReadNotPossible" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ULONG <a class="el" href="../../d4/d2/cache_8h.html#a28">CcFastReadNotPossible</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d1/cache_8h-source.html#l00192">192</a> of file <a class="el" href="../../d5/d1/cache_8h-source.html">cache.h</a>.
<p>
Referenced by <a class="el" href="../../d4/d0/fastio_8c-source.html#l00054">FsRtlCopyRead()</a>, and <a class="el" href="../../d7/d7/sysinfo_8c-source.html#l00941">NtQuerySystemInformation()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a25" doxytag="cache.h::CcFastReadNoWait" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ULONG <a class="el" href="../../d4/d2/cache_8h.html#a25">CcFastReadNoWait</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d1/cache_8h-source.html#l00189">189</a> of file <a class="el" href="../../d5/d1/cache_8h-source.html">cache.h</a>.
<p>
Referenced by <a class="el" href="../../d4/d0/fastio_8c-source.html#l00054">FsRtlCopyRead()</a>, and <a class="el" href="../../d7/d7/sysinfo_8c-source.html#l00941">NtQuerySystemInformation()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a27" doxytag="cache.h::CcFastReadResourceMiss" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ULONG <a class="el" href="../../d4/d2/cache_8h.html#a27">CcFastReadResourceMiss</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d1/cache_8h-source.html#l00191">191</a> of file <a class="el" href="../../d5/d1/cache_8h-source.html">cache.h</a>.
<p>
Referenced by <a class="el" href="../../d4/d0/fastio_8c-source.html#l00054">FsRtlCopyRead()</a>, and <a class="el" href="../../d7/d7/sysinfo_8c-source.html#l00941">NtQuerySystemInformation()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a26" doxytag="cache.h::CcFastReadWait" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ULONG <a class="el" href="../../d4/d2/cache_8h.html#a26">CcFastReadWait</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d1/cache_8h-source.html#l00190">190</a> of file <a class="el" href="../../d5/d1/cache_8h-source.html">cache.h</a>.
<p>
Referenced by <a class="el" href="../../d4/d0/fastio_8c-source.html#l00054">FsRtlCopyRead()</a>, and <a class="el" href="../../d7/d7/sysinfo_8c-source.html#l00941">NtQuerySystemInformation()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a51" doxytag="cache.h::CcLazyWriteIos" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ULONG <a class="el" href="../../d4/d2/cache_8h.html#a51">CcLazyWriteIos</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d1/cache_8h-source.html#l00223">223</a> of file <a class="el" href="../../d5/d1/cache_8h-source.html">cache.h</a>.
<p>
Referenced by <a class="el" href="../../d7/d1/cachesub_8c-source.html#l04411">CcFlushCache()</a>, and <a class="el" href="../../d7/d7/sysinfo_8c-source.html#l00941">NtQuerySystemInformation()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a52" doxytag="cache.h::CcLazyWritePages" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ULONG <a class="el" href="../../d4/d2/cache_8h.html#a52">CcLazyWritePages</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d1/cache_8h-source.html#l00224">224</a> of file <a class="el" href="../../d5/d1/cache_8h-source.html">cache.h</a>.
<p>
Referenced by <a class="el" href="../../d7/d1/cachesub_8c-source.html#l04411">CcFlushCache()</a>, and <a class="el" href="../../d7/d7/sysinfo_8c-source.html#l00941">NtQuerySystemInformation()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a33" doxytag="cache.h::CcMapDataNoWait" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ULONG <a class="el" href="../../d4/d2/cache_8h.html#a33">CcMapDataNoWait</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d1/cache_8h-source.html#l00199">199</a> of file <a class="el" href="../../d5/d1/cache_8h-source.html">cache.h</a>.
<p>
Referenced by <a class="el" href="../../d3/d8/pinsup_8c-source.html#l00052">CcMapData()</a>, and <a class="el" href="../../d7/d7/sysinfo_8c-source.html#l00941">NtQuerySystemInformation()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a35" doxytag="cache.h::CcMapDataNoWaitMiss" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ULONG <a class="el" href="../../d4/d2/cache_8h.html#a35">CcMapDataNoWaitMiss</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d1/cache_8h-source.html#l00201">201</a> of file <a class="el" href="../../d5/d1/cache_8h-source.html">cache.h</a>.
<p>
Referenced by <a class="el" href="../../d3/d8/pinsup_8c-source.html#l00052">CcMapData()</a>, and <a class="el" href="../../d7/d7/sysinfo_8c-source.html#l00941">NtQuerySystemInformation()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a34" doxytag="cache.h::CcMapDataWait" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ULONG <a class="el" href="../../d4/d2/cache_8h.html#a34">CcMapDataWait</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d1/cache_8h-source.html#l00200">200</a> of file <a class="el" href="../../d5/d1/cache_8h-source.html">cache.h</a>.
<p>
Referenced by <a class="el" href="../../d3/d8/pinsup_8c-source.html#l00052">CcMapData()</a>, and <a class="el" href="../../d7/d7/sysinfo_8c-source.html#l00941">NtQuerySystemInformation()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a36" doxytag="cache.h::CcMapDataWaitMiss" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ULONG <a class="el" href="../../d4/d2/cache_8h.html#a36">CcMapDataWaitMiss</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d1/cache_8h-source.html#l00202">202</a> of file <a class="el" href="../../d5/d1/cache_8h-source.html">cache.h</a>.
<p>
Referenced by <a class="el" href="../../d3/d8/pinsup_8c-source.html#l00052">CcMapData()</a>, and <a class="el" href="../../d7/d7/sysinfo_8c-source.html#l00941">NtQuerySystemInformation()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a46" doxytag="cache.h::CcMdlReadNoWait" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ULONG <a class="el" href="../../d4/d2/cache_8h.html#a46">CcMdlReadNoWait</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d1/cache_8h-source.html#l00216">216</a> of file <a class="el" href="../../d5/d1/cache_8h-source.html">cache.h</a>.
<p>
Referenced by <a class="el" href="../../d7/d7/sysinfo_8c-source.html#l00941">NtQuerySystemInformation()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a48" doxytag="cache.h::CcMdlReadNoWaitMiss" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ULONG <a class="el" href="../../d4/d2/cache_8h.html#a48">CcMdlReadNoWaitMiss</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d1/cache_8h-source.html#l00218">218</a> of file <a class="el" href="../../d5/d1/cache_8h-source.html">cache.h</a>.
<p>
Referenced by <a class="el" href="../../d7/d7/sysinfo_8c-source.html#l00941">NtQuerySystemInformation()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a47" doxytag="cache.h::CcMdlReadWait" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ULONG <a class="el" href="../../d4/d2/cache_8h.html#a47">CcMdlReadWait</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d1/cache_8h-source.html#l00217">217</a> of file <a class="el" href="../../d5/d1/cache_8h-source.html">cache.h</a>.
<p>
Referenced by <a class="el" href="../../d8/d4/mdlsup_8c-source.html#l00030">CcMdlRead()</a>, and <a class="el" href="../../d7/d7/sysinfo_8c-source.html#l00941">NtQuerySystemInformation()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a49" doxytag="cache.h::CcMdlReadWaitMiss" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ULONG <a class="el" href="../../d4/d2/cache_8h.html#a49">CcMdlReadWaitMiss</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d1/cache_8h-source.html#l00219">219</a> of file <a class="el" href="../../d5/d1/cache_8h-source.html">cache.h</a>.
<p>
Referenced by <a class="el" href="../../d8/d4/mdlsup_8c-source.html#l00030">CcMdlRead()</a>, and <a class="el" href="../../d7/d7/sysinfo_8c-source.html#l00941">NtQuerySystemInformation()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a55" doxytag="cache.h::CcMissCounter" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> PULONG <a class="el" href="../../d4/d2/cache_8h.html#a55">CcMissCounter</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d1/cache_8h-source.html#l00228">228</a> of file <a class="el" href="../../d5/d1/cache_8h-source.html">cache.h</a>.
<p>
Referenced by <a class="el" href="../../d6/d6/copysup_8c-source.html#l00031">CcCopyRead()</a>, <a class="el" href="../../d6/d6/copysup_8c-source.html#l00588">CcFastCopyRead()</a>, <a class="el" href="../../d3/d8/pinsup_8c-source.html#l00052">CcMapData()</a>, <a class="el" href="../../d8/d4/mdlsup_8c-source.html#l00030">CcMdlRead()</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l01633">CcPerformReadAhead()</a>, <a class="el" href="../../d3/d8/pinsup_8c-source.html#l00524">CcPinRead()</a>, <a class="el" href="../../d3/d8/pinsup_8c-source.html#l00767">CcPreparePinWrite()</a>, and <a class="el" href="../../d5/d5/iosubs_8c-source.html#l08509">IoPageRead()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a37" doxytag="cache.h::CcPinMappedDataCount" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ULONG <a class="el" href="../../d4/d2/cache_8h.html#a37">CcPinMappedDataCount</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d1/cache_8h-source.html#l00204">204</a> of file <a class="el" href="../../d5/d1/cache_8h-source.html">cache.h</a>.
<p>
Referenced by <a class="el" href="../../d3/d8/pinsup_8c-source.html#l00271">CcPinMappedData()</a>, and <a class="el" href="../../d7/d7/sysinfo_8c-source.html#l00941">NtQuerySystemInformation()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a38" doxytag="cache.h::CcPinReadNoWait" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ULONG <a class="el" href="../../d4/d2/cache_8h.html#a38">CcPinReadNoWait</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d1/cache_8h-source.html#l00206">206</a> of file <a class="el" href="../../d5/d1/cache_8h-source.html">cache.h</a>.
<p>
Referenced by <a class="el" href="../../d3/d8/pinsup_8c-source.html#l00524">CcPinRead()</a>, and <a class="el" href="../../d7/d7/sysinfo_8c-source.html#l00941">NtQuerySystemInformation()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a40" doxytag="cache.h::CcPinReadNoWaitMiss" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ULONG <a class="el" href="../../d4/d2/cache_8h.html#a40">CcPinReadNoWaitMiss</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d1/cache_8h-source.html#l00208">208</a> of file <a class="el" href="../../d5/d1/cache_8h-source.html">cache.h</a>.
<p>
Referenced by <a class="el" href="../../d3/d8/pinsup_8c-source.html#l00524">CcPinRead()</a>, and <a class="el" href="../../d7/d7/sysinfo_8c-source.html#l00941">NtQuerySystemInformation()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a39" doxytag="cache.h::CcPinReadWait" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ULONG <a class="el" href="../../d4/d2/cache_8h.html#a39">CcPinReadWait</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d1/cache_8h-source.html#l00207">207</a> of file <a class="el" href="../../d5/d1/cache_8h-source.html">cache.h</a>.
<p>
Referenced by <a class="el" href="../../d3/d8/pinsup_8c-source.html#l00524">CcPinRead()</a>, and <a class="el" href="../../d7/d7/sysinfo_8c-source.html#l00941">NtQuerySystemInformation()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a41" doxytag="cache.h::CcPinReadWaitMiss" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ULONG <a class="el" href="../../d4/d2/cache_8h.html#a41">CcPinReadWaitMiss</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d1/cache_8h-source.html#l00209">209</a> of file <a class="el" href="../../d5/d1/cache_8h-source.html">cache.h</a>.
<p>
Referenced by <a class="el" href="../../d3/d8/pinsup_8c-source.html#l00524">CcPinRead()</a>, and <a class="el" href="../../d7/d7/sysinfo_8c-source.html#l00941">NtQuerySystemInformation()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a50" doxytag="cache.h::CcReadAheadIos" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ULONG <a class="el" href="../../d4/d2/cache_8h.html#a50">CcReadAheadIos</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d1/cache_8h-source.html#l00221">221</a> of file <a class="el" href="../../d5/d1/cache_8h-source.html">cache.h</a>.
<p>
Referenced by <a class="el" href="../../d7/d1/cachesub_8c-source.html#l01633">CcPerformReadAhead()</a>, and <a class="el" href="../../d7/d7/sysinfo_8c-source.html#l00941">NtQuerySystemInformation()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a24" doxytag="cache.h::CcThrowAway" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ULONG <a class="el" href="../../d4/d2/cache_8h.html#a24">CcThrowAway</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d1/cache_8h-source.html#l00183">183</a> of file <a class="el" href="../../d5/d1/cache_8h-source.html">cache.h</a>.
<p>
Referenced by <a class="el" href="../../d6/d6/copysup_8c-source.html#l00031">CcCopyRead()</a>, <a class="el" href="../../d6/d6/copysup_8c-source.html#l00588">CcFastCopyRead()</a>, <a class="el" href="../../d3/d8/pinsup_8c-source.html#l00052">CcMapData()</a>, <a class="el" href="../../d8/d4/mdlsup_8c-source.html#l00030">CcMdlRead()</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l01633">CcPerformReadAhead()</a>, <a class="el" href="../../d3/d8/pinsup_8c-source.html#l00524">CcPinRead()</a>, and <a class="el" href="../../d3/d8/pinsup_8c-source.html#l00767">CcPreparePinWrite()</a>.    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:42:59 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
