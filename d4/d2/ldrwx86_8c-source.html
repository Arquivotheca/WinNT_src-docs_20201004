<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: ldrwx86.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>ldrwx86.c</h1><a href="../../d3/d3/ldrwx86_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1989  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    ldrwx86.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module implements the wx86 specific ldr functions.</span>
00012 <span class="comment"></span>
00013 <span class="comment">Author:</span>
00014 <span class="comment"></span>
00015 <span class="comment">    13-Jan-1995 Jonle , created</span>
00016 <span class="comment"></span>
00017 <span class="comment">Revision History:</span>
00018 <span class="comment"></span>
00019 <span class="comment">    15-Oct-1998 CBiks   Modified the code that throws the architecture</span>
00020 <span class="comment">                        mismatch exception so the exception is only</span>
00021 <span class="comment">                        thrown for NT 3,0 and lower executables.  This was</span>
00022 <span class="comment">                        changed to make the Wx86 loader behave like the</span>
00023 <span class="comment">                        real loader, which does not throw this exception.</span>
00024 <span class="comment"></span>
00025 <span class="comment">                        Also added a call to the cleanup function when</span>
00026 <span class="comment">                        LdrpWx86LoadDll() fails.  There were cases where the</span>
00027 <span class="comment">                        CPU failed to initialize but the Wx86 global pointers</span>
00028 <span class="comment">                        were not cleared and pointed to a invalid memory because</span>
00029 <span class="comment">                        wx86.dll was unloaded.</span>
00030 <span class="comment">--*/</span>
00031 
00032 <span class="preprocessor">#include "<a class="code" href="../../d9/d8/ntos_8h.html">ntos.h</a>"</span>
00033 <span class="preprocessor">#include "<a class="code" href="../../d9/d2/ldrp_8h.html">ldrp.h</a>"</span>
00034 
<a name="l00035"></a><a class="code" href="../../d3/d3/ldrwx86_8c.html#a0">00035</a> <span class="preprocessor">#define PAGE_SIZE_X86   (0x1000)</span>
00036 <span class="preprocessor"></span>
00037 <span class="preprocessor">#if defined (WX86)</span>
00038 <span class="preprocessor"></span>
00039 BOOLEAN (*Wx86ProcessInit)(PVOID, BOOLEAN) = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00040 BOOLEAN (*Wx86DllMapNotify)(PVOID, BOOLEAN) = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00041 BOOLEAN (*Wx86DllEntryPoint)(PDLL_INIT_ROUTINE, PVOID, ULONG, PCONTEXT) = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00042 ULONG (*Wx86ProcessStartRoutine)(<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00043 ULONG (*Wx86ThreadStartRoutine)(PVOID) = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00044 BOOLEAN (*Wx86KnownDllName)(PUNICODE_STRING, PUNICODE_STRING) = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00045 BOOLEAN (*Wx86KnownNativeDll)(PUNICODE_STRING) = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00046 BOOLEAN (*Wx86KnownRedistDll)(PUNICODE_STRING) = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00047 
00048 BOOLEAN Wx86OnTheFly=<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00049 ULONG Wx86ProviderUnloadCount = 0;
00050 
00051 WCHAR Wx86Dir[]=<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="stringliteral">"\\sys32x86"</span>;
00052 UNICODE_STRING Wx86SystemDir={0,0,<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>};
00053 UNICODE_STRING <a class="code" href="../../d8/d1/init_8h.html#a3">NtSystemRoot</a>={0,0,<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>};
00054 
00055 <span class="preprocessor">#if defined(BUILD_WOW6432)</span>
00056 <span class="preprocessor"></span>    <span class="comment">//</span>
00057     <span class="comment">// We want to accept only Alpha32 images as native.  USER_SHARED_DATA</span>
00058     <span class="comment">// will only include AXP64.</span>
00059     <span class="comment">//</span>
00060 <span class="preprocessor">    #define IsNativeMachineType(m)                  \</span>
00061 <span class="preprocessor">         ((m) == IMAGE_FILE_MACHINE_ALPHA)</span>
00062 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00063 <span class="preprocessor"></span><span class="preprocessor">    #define IsNativeMachineType(m)                  \</span>
00064 <span class="preprocessor">        ((m) &gt;= USER_SHARED_DATA-&gt;ImageNumberLow &amp;&amp; \</span>
00065 <span class="preprocessor">         (m) &lt;= USER_SHARED_DATA-&gt;ImageNumberHigh)</span>
00066 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00067 <span class="preprocessor"></span>
00068 
00069 <span class="comment">//</span>
00070 <span class="comment">// Wx86 plugin support</span>
00071 <span class="comment">//</span>
00072 
00073 <span class="keyword">typedef</span> <span class="keyword">struct </span>_Wx86Plugin {
00074   LIST_ENTRY Links;                         <span class="comment">// plugin list links</span>
00075   PVOID DllBase;                            <span class="comment">// plugin dll base</span>
00076   ULONG <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a>;                              <span class="comment">// number of providers</span>
00077   PVOID Provider[WX86PLUGIN_MAXPROVIDER];   <span class="comment">// dll base of providers for this plugin</span>
00078 } WX86PLUGIN, *PWX86PLUGIN;                 <span class="comment">// plugin list entry</span>
00079 
00080 LIST_ENTRY Wx86PluginList= {                <span class="comment">// plugin list head</span>
00081     &amp;Wx86PluginList,
00082     &amp;Wx86PluginList
00083     };
00084 
00085 <span class="comment">// Prototypes for plugin provider interfaces</span>
00086 
00087 <span class="keyword">typedef</span> BOOLEAN (*WX86IDENTIFYPLUGIN)(PVOID PluginDll,
00088                                       WCHAR *FullFileName,
00089                                       BOOLEAN NativeToX86
00090                                       );
00091 
00092 <span class="keyword">typedef</span> BOOLEAN (*WX86THUNKEXPORT)(PVOID PluginDll,
00093                                    PCHAR ExportName,
00094                                    ULONG Ordinal,
00095                                    PVOID ExportAddress,
00096                                    PVOID *ExportThunk,
00097                                    BOOLEAN NativeToX86
00098                                    ); 
00099 
00100 BOOLEAN
00101 DllHasExports(
00102     PVOID DllBase
00103     )
00104 {
00105    ULONG ExportSize;
00106    PIMAGE_EXPORT_DIRECTORY ExportDir;
00107 
00108 
00109    ExportDir = <a class="code" href="../../d8/d9/imagedir_8c.html#a5">RtlImageDirectoryEntryToData</a>(DllBase,
00110                                             TRUE,
00111                                             IMAGE_DIRECTORY_ENTRY_EXPORT,
00112                                             &amp;ExportSize
00113                                             );
00114 
00115    <span class="keywordflow">return</span> ExportDir &amp;&amp; ExportSize &amp;&amp;
00116           (ExportDir-&gt;NumberOfFunctions || ExportDir-&gt;NumberOfNames);
00117 
00118 }
00119 
00120 BOOLEAN
00121 DllNameMatchesLdrEntry(
00122      PUNICODE_STRING BaseDllName,
00123      PUNICODE_STRING FullDllName,
00124      PLDR_DATA_TABLE_ENTRY LdrEntry,
00125      BOOLEAN ImporterX86
00126      )
00127 <span class="comment">/*++</span>
00128 <span class="comment"></span>
00129 <span class="comment">Routine Description:</span>
00130 <span class="comment"></span>
00131 <span class="comment">    Verifies that the LdrEntry matches the specifed dll.</span>
00132 <span class="comment"></span>
00133 <span class="comment">Arguments:</span>
00134 <span class="comment"></span>
00135 <span class="comment">    BaseDllName  - Unicode string describing Base Name of the Dll.</span>
00136 <span class="comment"></span>
00137 <span class="comment">    FullDllName  - Unicode string describing full path Name of the Dll.</span>
00138 <span class="comment">                   Set FullDllName length to zero for no full path matching.</span>
00139 <span class="comment"></span>
00140 <span class="comment">    LdrEntry     - loader information for dll found by basename compare.</span>
00141 <span class="comment"></span>
00142 <span class="comment">    ImporterX86  - TRUE if Importer is X86.</span>
00143 <span class="comment"></span>
00144 <span class="comment"></span>
00145 <span class="comment">Return Value:</span>
00146 <span class="comment"></span>
00147 <span class="comment">    TRUE if any of the following conditions are met.</span>
00148 <span class="comment">       - FullDllName is same as LdrEntry FullDllName.</span>
00149 <span class="comment">       - Machine Type is the same.</span>
00150 <span class="comment">       - x86 importer AND LdrEntry is a Wx86 Risc thunk dll.</span>
00151 <span class="comment"></span>
00152 <span class="comment">--*/</span>
00153 
00154 {
00155     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> MachineType;
00156     BOOLEAN FullNameMatches = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00157     PIMAGE_NT_HEADERS NtHeaders;
00158 
00159 
00160     <span class="comment">//</span>
00161     <span class="comment">// The Base name must match.</span>
00162     <span class="comment">//</span>
00163 
00164     <span class="keywordflow">if</span> (!<a class="code" href="../../d6/d6/nls_8c.html#a42">RtlEqualUnicodeString</a>(BaseDllName, &amp;LdrEntry-&gt;BaseDllName, TRUE)) {
00165         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00166         }
00167 
00168 
00169     <span class="keywordflow">if</span> (!FullDllName-&gt;Length ||
00170         (FullDllName-&gt;Length &amp;&amp;
00171          <a class="code" href="../../d6/d6/nls_8c.html#a42">RtlEqualUnicodeString</a>(FullDllName, &amp;LdrEntry-&gt;FullDllName, TRUE)))
00172        {
00173         FullNameMatches = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00174         }
00175 
00176     <span class="comment">//</span>
00177     <span class="comment">// if we are not checking Machine Type, return based</span>
00178     <span class="comment">// on FullName matching.</span>
00179     <span class="comment">// LDRP_WX86_IGNORE_MACHINETYPE is used for images with no exports</span>
00180     <span class="comment">// LDRP_WX86_PLUGIN is used when there's a plug provider that will</span>
00181     <span class="comment">// dynamically generate thunks when GetProcAddress() is called.</span>
00182     <span class="comment">//</span>
00183 
00184     <span class="keywordflow">if</span> ((LdrEntry-&gt;Flags &amp; LDRP_WX86_IGNORE_MACHINETYPE) ||
00185         (LdrEntry-&gt;Flags &amp; LDRP_WX86_PLUGIN) ) {
00186         <span class="keywordflow">return</span> FullNameMatches;
00187         }
00188 
00189     NtHeaders = <a class="code" href="../../d8/d9/imagedir_8c.html#a0">RtlImageNtHeader</a>(LdrEntry-&gt;DllBase);
00190     MachineType = NtHeaders-&gt;FileHeader.Machine;
00191 
00192     <span class="keywordflow">if</span> (ImporterX86) {
00193         <span class="keywordflow">if</span> (MachineType == IMAGE_FILE_MACHINE_I386) {
00194             <span class="keywordflow">return</span> FullNameMatches;
00195             }
00196 
00197             <span class="comment">//</span>
00198             <span class="comment">// Allow cross platform linking for x86 to risc Wx86 thunk</span>
00199             <span class="comment">// dlls. All risc Wx86 Thunk dlls are marked as Wx86 Thunk dlls</span>
00200             <span class="comment">// in the ntheader.</span>
00201             <span class="comment">//</span>
00202         <span class="keywordflow">if</span> (FullNameMatches) {
00203             <span class="keywordflow">return</span> (NtHeaders-&gt;OptionalHeader.DllCharacteristics
00204                     &amp; IMAGE_DLLCHARACTERISTICS_X86_THUNK) != 0;
00205             }
00206 
00207             <span class="comment">//</span>
00208             <span class="comment">// The full name doesn't match, we can still allow matches</span>
00209             <span class="comment">// for loads which were redirected from system32 to wx86</span>
00210             <span class="comment">// system dir (See LdrpWx86MapDll).</span>
00211             <span class="comment">//</span>
00212         <span class="keywordflow">else</span> {
00213 
00214             UNICODE_STRING PathPart;
00215 
00216             PathPart = LdrEntry-&gt;FullDllName;
00217             PathPart.Length = LdrEntry-&gt;FullDllName.Length - LdrEntry-&gt;BaseDllName.Length - <span class="keyword">sizeof</span>(WCHAR);
00218             <span class="keywordflow">if</span> (!<a class="code" href="../../d6/d6/nls_8c.html#a42">RtlEqualUnicodeString</a>(&amp;PathPart, &amp;Wx86SystemDir, TRUE)) {
00219                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00220                 }
00221 
00222             PathPart = *FullDllName;
00223             PathPart.Length = FullDllName-&gt;Length - BaseDllName-&gt;Length - <span class="keyword">sizeof</span>(WCHAR);
00224             <span class="keywordflow">if</span> (!<a class="code" href="../../d6/d6/nls_8c.html#a42">RtlEqualUnicodeString</a>(&amp;PathPart, &amp;LdrpKnownDllPath, TRUE)) {
00225                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00226                 }
00227 
00228             <a class="code" href="../../d6/d6/nls_8c.html#a44">RtlCopyUnicodeString</a>(FullDllName, &amp;LdrEntry-&gt;FullDllName);
00229 
00230             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00231             }
00232 
00233         }
00234 
00235 
00236 
00237     <span class="comment">//</span>
00238     <span class="comment">// Importer is Risc.</span>
00239     <span class="comment">//</span>
00240 
00241     <span class="keywordflow">if</span> (IsNativeMachineType(MachineType))
00242       {
00243         <span class="keywordflow">return</span> FullNameMatches;
00244         }
00245 
00246     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00247 }
00248 
00249 
00250 
00251 BOOLEAN
00252 SearchWx86Dll(
00253     IN  PWSTR DllPath,
00254     IN  PUNICODE_STRING BaseName,
00255     OUT PUNICODE_STRING FileName,
00256     OUT PWSTR *pNextDllPath
00257     )
00258 
00259 <span class="comment">/*++</span>
00260 <span class="comment"></span>
00261 <span class="comment">Routine Description:</span>
00262 <span class="comment"></span>
00263 <span class="comment">    Search the path for a dll, based on Wx86 altered search path rules.</span>
00264 <span class="comment"></span>
00265 <span class="comment">Arguments:</span>
00266 <span class="comment"></span>
00267 <span class="comment">    DllPath - search path to use.</span>
00268 <span class="comment"></span>
00269 <span class="comment">    BaseName - Name of dll to search for.</span>
00270 <span class="comment"></span>
00271 <span class="comment">    FileName - addr of Unicode string to fill in the found dll path name.</span>
00272 <span class="comment"></span>
00273 <span class="comment">    pNextDllPath - addr to fill in next path component to be searched.</span>
00274 <span class="comment"></span>
00275 <span class="comment">Return Value:</span>
00276 <span class="comment"></span>
00277 <span class="comment">--*/</span>
00278 
00279 {
00280     PWCHAR pwch;
00281     ULONG Length;
00282 
00283     <span class="comment">//</span>
00284     <span class="comment">// formulate the name for each path component,</span>
00285     <span class="comment">// and see if it exists.</span>
00286     <span class="comment">//</span>
00287 
00288     Length = <a class="code" href="../../d8/d0/rtbatcr_8c.html#a6">BaseName</a>-&gt;Length + 2*<span class="keyword">sizeof</span>(WCHAR);
00289 
00290     <span class="keywordflow">do</span> {
00291         pwch = <a class="code" href="../../d2/d2/rtload_8c.html#a3">FileName</a>-&gt;Buffer;
00292 
00293         <span class="comment">//</span>
00294         <span class="comment">// copy up till next semicolon</span>
00295         <span class="comment">//</span>
00296         <a class="code" href="../../d2/d2/rtload_8c.html#a3">FileName</a>-&gt;Length = 0;
00297 
00298         <span class="keywordflow">while</span> (*DllPath) {
00299             <span class="keywordflow">if</span> (<a class="code" href="../../d2/d2/rtload_8c.html#a3">FileName</a>-&gt;MaximumLength &lt;= <a class="code" href="../../d2/d2/rtload_8c.html#a3">FileName</a>-&gt;Length + Length) {
00300                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00301                 }
00302 
00303 
00304             <span class="keywordflow">if</span> (*DllPath == (WCHAR)<span class="charliteral">';'</span>) {
00305                 DllPath++;
00306                 <span class="keywordflow">break</span>;
00307                 }
00308 
00309             *pwch++ = *DllPath++;
00310             <a class="code" href="../../d2/d2/rtload_8c.html#a3">FileName</a>-&gt;Length += <span class="keyword">sizeof</span>(WCHAR);
00311             }
00312 
00313 
00314         <span class="comment">//</span>
00315         <span class="comment">//  if we got a path component, append the basename</span>
00316         <span class="comment">//  and return if it exists.</span>
00317         <span class="comment">//</span>
00318 
00319         <span class="keywordflow">if</span> (<a class="code" href="../../d2/d2/rtload_8c.html#a3">FileName</a>-&gt;Length) {
00320             <span class="keywordflow">if</span> (*(pwch -1) !=  <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span>) {
00321                 *pwch = <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span>;
00322                 <a class="code" href="../../d2/d2/rtload_8c.html#a3">FileName</a>-&gt;Length += <span class="keyword">sizeof</span>(WCHAR);
00323                 }
00324             }
00325 
00326         <a class="code" href="../../d6/d6/nls_8c.html#a46">RtlAppendUnicodeStringToString</a>(FileName, BaseName);
00327 
00328         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d1/curdir_8c.html#a31">RtlDoesFileExists_U</a>(<a class="code" href="../../d2/d2/rtload_8c.html#a3">FileName</a>-&gt;Buffer)) {
00329             *pNextDllPath = DllPath;
00330             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00331             }
00332 
00333       } <span class="keywordflow">while</span> (*DllPath);
00334 
00335     *pNextDllPath = DllPath;
00336 
00337     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00338 }
00339 
00340 
00341 
00342 BOOLEAN
00343 LdrpWx86DllMapNotify(
00344      PVOID DllBase,
00345      BOOLEAN Mapped
00346      )
00347 <span class="comment">/*++</span>
00348 <span class="comment"></span>
00349 <span class="comment">Routine Description:</span>
00350 <span class="comment"></span>
00351 <span class="comment">    Invoked by the nt loader immediately after an x86 Dll is Mapped or</span>
00352 <span class="comment">    unmapped from memory. This routine is not called at a point where</span>
00353 <span class="comment">    it is safe to load other dlls. That work should be deferred till</span>
00354 <span class="comment">    as late as possible before the x86 code is actually going to be executed.</span>
00355 <span class="comment"></span>
00356 <span class="comment">Arguments:</span>
00357 <span class="comment"></span>
00358 <span class="comment">    DllBase - Base address of the DLL</span>
00359 <span class="comment"></span>
00360 <span class="comment">    Mapped - TRUE if the DLL is being mapped, FALSE if it is being unmapped.</span>
00361 <span class="comment"></span>
00362 <span class="comment">Return Value:</span>
00363 <span class="comment"></span>
00364 <span class="comment">    FALSE on failure, TRUE on success.</span>
00365 <span class="comment"></span>
00366 <span class="comment">--*/</span>
00367 {
00368     <span class="keywordflow">return</span> Wx86DllMapNotify &amp;&amp; (*Wx86DllMapNotify)(DllBase, Mapped);
00369 }
00370 
00371 
00372 
00373 
00374 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00375 LdrpWx86MapDll(
00376     IN PWSTR DllPath OPTIONAL,
00377     IN PULONG DllCharacteristics OPTIONAL,
00378     IN BOOLEAN Wx86KnownDll,
00379     IN BOOLEAN StaticLink,
00380     OUT PUNICODE_STRING DllName,
00381     OUT PLDR_DATA_TABLE_ENTRY *pEntry,
00382     OUT ULONG_PTR *pViewSize,
00383     OUT HANDLE *pSection
00384     )
00385 <span class="comment">/*++</span>
00386 <span class="comment"></span>
00387 <span class="comment">Routine Description:</span>
00388 <span class="comment"></span>
00389 <span class="comment">    Resolves dll name, creates image section and maps image into memory.</span>
00390 <span class="comment"></span>
00391 <span class="comment"></span>
00392 <span class="comment">Arguments:</span>
00393 <span class="comment"></span>
00394 <span class="comment">    DllPath - Supplies the DLL search path.</span>
00395 <span class="comment"></span>
00396 <span class="comment">    DllCharacteristics - Supplies an optional DLL characteristics flag,</span>
00397 <span class="comment">        that if specified is used to match against the dll being loaded.</span>
00398 <span class="comment">        (IMAGE_FILE_HEADER Characteristics)</span>
00399 <span class="comment"></span>
00400 <span class="comment">    Wx86KnownDll - if true, Importer is x86.</span>
00401 <span class="comment"></span>
00402 <span class="comment">    StaticLink - TRUE, if static link and not dynamic.</span>
00403 <span class="comment"></span>
00404 <span class="comment">    DllName - Name of Dll to map.</span>
00405 <span class="comment"></span>
00406 <span class="comment">    pEntry    - returns filled LdrEntry allocated off of the process heap.</span>
00407 <span class="comment"></span>
00408 <span class="comment">    pViewSize - returns the View Size of mapped image.</span>
00409 <span class="comment"></span>
00410 <span class="comment">    pSection  - returns the section handle.</span>
00411 <span class="comment"></span>
00412 <span class="comment"></span>
00413 <span class="comment"></span>
00414 <span class="comment">Return Value:</span>
00415 <span class="comment"></span>
00416 <span class="comment">    Status</span>
00417 <span class="comment"></span>
00418 <span class="comment">--*/</span>
00419 
00420 {
00421     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> st;
00422     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> stMapSection;
00423     PWCHAR pwch;
00424     PVOID  ViewBase = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00425     PTEB Teb = NtCurrentTeb();
00426     PIMAGE_NT_HEADERS NtHeaders;
00427     PVOID ArbitraryUserPointer;
00428     PLDR_DATA_TABLE_ENTRY Entry;
00429     BOOLEAN Wx86DirOverride=<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00430     BOOLEAN Wx86DirUndone=<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00431     BOOLEAN ContainsNoExports = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00432     UNICODE_STRING NameUnicode;
00433     UNICODE_STRING FreeUnicode;
00434     UNICODE_STRING FullNameUnicode;
00435     UNICODE_STRING BaseNameUnicode;
00436     UNICODE_STRING FullName;
00437     HANDLE MismatchSection;
00438     WCHAR FullNameBuffer[((DOS_MAX_PATH_LENGTH*2+20)+<span class="keyword">sizeof</span>(UNICODE_NULL))/2];
00439     BOOLEAN Wx86Plugin;
00440     BOOLEAN MismatchEncountered;
00441     UNICODE_STRING ThunkDllName;
00442     SECTION_IMAGE_INFORMATION SectionInfo;
00443 
00444     UNICODE_STRING  LocalDllName;
00445     PUNICODE_STRING pLocalDllName;
00446     PWSTR           DllSearchPath;
00447     PUNICODE_STRING ForcedDllName = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00448     PUNICODE_STRING ForcedDllPath = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00449 
00450     MismatchEncountered = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00451     FullName.Buffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00452     Wx86Plugin = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00453     Entry = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00454 
00455     FullNameUnicode.Buffer = FullNameBuffer;
00456     FullNameUnicode.MaximumLength = <span class="keyword">sizeof</span>(FullNameBuffer);
00457     FullNameUnicode.Length = 0;
00458 
00459 
00460     <span class="comment">//</span>
00461     <span class="comment">// If DllPath is not supplied, use the loader's default path</span>
00462     <span class="comment">//</span>
00463 
00464     <span class="keywordflow">if</span> (!DllPath) {
00465         DllPath = <a class="code" href="../../d9/d2/ldrp_8h.html#a22">LdrpDefaultPath</a>.Buffer;
00466         }
00467 
00468     <span class="comment">//</span>
00469     <span class="comment">// DllPath can be ignored if:</span>
00470     <span class="comment">//    1) DllPath is the null string</span>
00471     <span class="comment">// or 2) DllName contains a hard coded path</span>
00472     <span class="comment">//</span>
00473 
00474     <span class="keywordflow">if</span> (!*DllPath ||
00475         <a class="code" href="../../d5/d1/curdir_8c.html#a23">RtlDetermineDosPathNameType_U</a>(DllName-&gt;Buffer) != RtlPathTypeRelative)
00476       {
00477         DllPath = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00478         }
00479 
00480 
00481 
00482     <span class="comment">//</span>
00483     <span class="comment">// Alloc a chunk of memory to use in constructing the full</span>
00484     <span class="comment">// dll name from the path and file name. Note that because</span>
00485     <span class="comment">// a path component may contain relative references, it may</span>
00486     <span class="comment">// exceed MAX_PATH.</span>
00487     <span class="comment">//</span>
00488 
00489     FreeUnicode.Length = 0;
00490     FreeUnicode.MaximumLength = (DOS_MAX_PATH_LENGTH*2+20) + <span class="keyword">sizeof</span>(UNICODE_NULL);
00491     <span class="keywordflow">if</span> (DllPath) {
00492         FreeUnicode.MaximumLength += wcslen(DllPath) * <span class="keyword">sizeof</span>(WCHAR);
00493         }
00494 
00495     FreeUnicode.Buffer = <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a0">RtlAllocateHeap</a>(RtlProcessHeap(),
00496                                          <a class="code" href="../../d9/d2/ldrp_8h.html#a11">MAKE_TAG</a>( TEMP_TAG ),
00497                                          FreeUnicode.MaximumLength
00498                                          );
00499     <span class="keywordflow">if</span> (!FreeUnicode.Buffer) {
00500         <span class="keywordflow">return</span> STATUS_NO_MEMORY;
00501         }
00502 
00503 
00504     *pSection = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00505     MismatchSection = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00506 
00507     pLocalDllName = &amp;LocalDllName;
00508     DllSearchPath = DllPath;
00509 
00510     <span class="comment">//</span>
00511     <span class="comment">// If we are looking for an x86 dll and it's base name is one of the</span>
00512     <span class="comment">// Wx86 thunk dlls, map the Wx86 thunk dll instead</span>
00513     <span class="comment">//</span>
00514     <span class="comment">//</span>
00515     <span class="comment">// X86 importers: force Wx86 system32 path before NtSystem32 path.</span>
00516     <span class="comment">//</span>
00517 
00518     LocalDllName.Buffer = wcsrchr(DllName-&gt;Buffer, L<span class="charliteral">'\\'</span>);       
00519     LocalDllName.Buffer = LocalDllName.Buffer ?  &amp;LocalDllName.Buffer[1] : DllName-&gt;Buffer;
00520     
00521     LocalDllName.Length = wcslen(LocalDllName.Buffer) * <span class="keyword">sizeof</span>(WCHAR);
00522     LocalDllName.MaximumLength = LocalDllName.Length + <span class="keyword">sizeof</span>(WCHAR);
00523 
00524     pLocalDllName = DllName;
00525 
00526     <span class="keywordflow">if</span> (Wx86KnownDll) {
00527         <span class="comment">// Looking for x86 dll ...</span>
00528 
00529         <span class="keywordflow">if</span> (Wx86KnownDllName(&amp;LocalDllName, &amp;ThunkDllName)) {
00530             <span class="comment">// It's a thunked dll. Redirect to system32&lt;thunk dll&gt;</span>
00531             ForcedDllPath = &amp;<a class="code" href="../../d9/d2/ldrp_8h.html#a25">LdrpKnownDllPath</a>;
00532             ForcedDllName = &amp;ThunkDllName;       <span class="comment">// use the thunked dll</span>
00533         
00534         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Wx86KnownRedistDll(&amp;LocalDllName)) {
00535             <span class="comment">// It's a redistributed x86 dll. Redirect to sys32x86&lt;dll name&gt;</span>
00536             ForcedDllPath = &amp;Wx86SystemDir;
00537             ForcedDllName = &amp;LocalDllName;       <span class="comment">// use the input dll name</span>
00538         
00539         }
00540     }
00541 
00542     <span class="comment">// if ForcedDllPath is not NULL, disable path searching and retries.</span>
00543     
00544     <span class="keywordflow">if</span> (ForcedDllPath) {
00545         <span class="keywordflow">if</span> (<a class="code" href="../../d9/d2/ldrp_8h.html#a30">ShowSnaps</a>) {
00546             <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"LDRWX86: %s %wZ - force load from %wZ\\%wZ\n"</span>,
00547                     Wx86KnownDll? <span class="stringliteral">"x86"</span> : <span class="stringliteral">"native"</span>, DllName, ForcedDllPath, ForcedDllName );
00548         }
00549 
00550         <a class="code" href="../../d6/d6/nls_8c.html#a44">RtlCopyUnicodeString</a>(&amp;FreeUnicode, ForcedDllPath);
00551         FreeUnicode.Buffer[FreeUnicode.Length&gt;&gt;1] = <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span>;
00552         FreeUnicode.Length += <span class="keyword">sizeof</span>(WCHAR);
00553         <a class="code" href="../../d6/d6/nls_8c.html#a46">RtlAppendUnicodeStringToString</a>(&amp;FreeUnicode, ForcedDllName);
00554         pLocalDllName = &amp;FreeUnicode;
00555         DllSearchPath = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;               <span class="comment">// disable path searching</span>
00556         Wx86DirOverride = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;             <span class="comment">// don't retry the load</span>
00557     }
00558 
00559     <span class="comment">// Loop as long as there are more directories in DllSearchPath</span>
00560     <span class="comment">// or at least once if path searching is disabled.</span>
00561     
00562     <span class="keywordflow">while</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
00563 
00564         <span class="comment">// Find the next occurance of the dll in the DllPath directories.</span>
00565         <span class="comment">// If no DllPath then use DllName as provided</span>
00566 
00567         <span class="keywordflow">if</span> (DllSearchPath) {
00568             <span class="keywordflow">if</span> (!SearchWx86Dll(DllSearchPath,
00569                                pLocalDllName,
00570                                &amp;FreeUnicode,
00571                                &amp;DllSearchPath
00572                                ))
00573               {
00574                st = STATUS_DLL_NOT_FOUND;
00575                <span class="keywordflow">break</span>;
00576                }
00577 
00578             pwch = FreeUnicode.Buffer;
00579             }
00580         <span class="keywordflow">else</span> {
00581             pwch = pLocalDllName-&gt;Buffer;
00582             }
00583 
00584         <span class="comment">//</span>
00585         <span class="comment">// Setup FullNameUnicode, BaseNameUnicode strings</span>
00586         <span class="comment">//</span>
00587 
00588         FullNameUnicode.Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)<a class="code" href="../../d5/d1/curdir_8c.html#a27">RtlGetFullPathName_U</a>(
00589                                                pwch,
00590                                                FullNameUnicode.MaximumLength,
00591                                                FullNameUnicode.Buffer,
00592                                                &amp;BaseNameUnicode.Buffer
00593                                                );
00594 
00595         <span class="keywordflow">if</span> (!FullNameUnicode.Length ||
00596             FullNameUnicode.Length &gt;= FullNameUnicode.MaximumLength)
00597           {
00598             st = STATUS_OBJECT_PATH_SYNTAX_BAD;
00599             <span class="keywordflow">break</span>;
00600             }
00601 
00602 
00603         BaseNameUnicode.Length = FullNameUnicode.Length -
00604                                  (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)((ULONG_PTR)BaseNameUnicode.Buffer -
00605                                           (ULONG_PTR)FullNameUnicode.Buffer);
00606 
00607         BaseNameUnicode.MaximumLength = BaseNameUnicode.Length + <span class="keyword">sizeof</span>(WCHAR);
00608 
00609         <span class="keywordflow">if</span> (DllSearchPath &amp;&amp; Wx86KnownDll &amp;&amp; !Wx86DirOverride) {
00610             NameUnicode = FullNameUnicode;
00611             NameUnicode.Length -= BaseNameUnicode.Length + <span class="keyword">sizeof</span>(WCHAR);
00612             <span class="keywordflow">if</span> (<a class="code" href="../../d6/d6/nls_8c.html#a42">RtlEqualUnicodeString</a>(&amp;NameUnicode, &amp;LdrpKnownDllPath, TRUE)) {
00613                 <a class="code" href="../../d6/d6/nls_8c.html#a44">RtlCopyUnicodeString</a>(&amp;FreeUnicode, &amp;Wx86SystemDir);
00614                 FreeUnicode.Buffer[FreeUnicode.Length &gt;&gt; 1] = <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span>;
00615                 FreeUnicode.Length += <span class="keyword">sizeof</span>(WCHAR);
00616                 pwch = &amp;FullNameUnicode.Buffer[FreeUnicode.Length &gt;&gt; 1];
00617                 <a class="code" href="../../d6/d6/nls_8c.html#a46">RtlAppendUnicodeStringToString</a>(&amp;FreeUnicode, &amp;BaseNameUnicode);
00618                 Wx86DirOverride = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00619 
00620                 <span class="keywordflow">if</span> (<a class="code" href="../../d5/d1/curdir_8c.html#a31">RtlDoesFileExists_U</a>(FreeUnicode.Buffer)) {
00621                     <a class="code" href="../../d6/d6/nls_8c.html#a44">RtlCopyUnicodeString</a>(&amp;FullNameUnicode, &amp;FreeUnicode);
00622                     BaseNameUnicode.Buffer = pwch;
00623                     }
00624                 <span class="keywordflow">else</span> {
00625                     Wx86DirUndone = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00626                     }
00627                 }
00628             }
00629 
00630 
00631 RetryWx86SystemDir:
00632 
00633 
00634 
00635         <span class="comment">//</span>
00636         <span class="comment">// Create the image section.</span>
00637         <span class="comment">//</span>
00638 
00639         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d1/curdir_8c.html#a29">RtlDosPathNameToNtPathName_U</a>(FullNameUnicode.Buffer,
00640                                           &amp;NameUnicode,
00641                                           NULL,
00642                                           NULL
00643                                           ))
00644            {
00645             st = STATUS_OBJECT_PATH_SYNTAX_BAD;
00646             <span class="keywordflow">break</span>;
00647             }
00648 
00649         <span class="keywordflow">if</span> (<a class="code" href="../../d9/d2/ldrp_8h.html#a30">ShowSnaps</a>) {
00650             <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"LDR: Loading (%s) %wZ\n"</span>,
00651                      StaticLink ? <span class="stringliteral">"STATIC"</span> : <span class="stringliteral">"DYNAMIC"</span>,
00652                      &amp;FullNameUnicode
00653                      );
00654             }
00655 
00656         st = <a class="code" href="../../d2/d3/ldrsnap_8c.html#a47">LdrpCreateDllSection</a>(&amp;NameUnicode,
00657                                   NULL,
00658                                   pLocalDllName,
00659                                   DllCharacteristics,
00660                                   pSection
00661                                   );
00662 
00663         <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>(RtlProcessHeap(), 0, NameUnicode.Buffer);
00664 
00665         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(st)) {
00666             <span class="keywordflow">break</span>;
00667             }
00668 
00669         <span class="comment">//</span>
00670         <span class="comment">// Query the section info to discover its attributes</span>
00671         <span class="comment">//</span>
00672         st = <a class="code" href="../../d4/d3/querysec_8c.html#a0">NtQuerySection</a>(*pSection,
00673                             SectionImageInformation,
00674                             &amp;SectionInfo,
00675                             <span class="keyword">sizeof</span>(SectionInfo),
00676                             NULL);
00677         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(st)) {
00678             <span class="keywordflow">break</span>;
00679         }
00680 
00681 
00682             <span class="comment">//</span>
00683             <span class="comment">// MachineType is native type, allow:</span>
00684             <span class="comment">// - if risc importer</span>
00685             <span class="comment">// - if Wx86 thunk dlls</span>
00686             <span class="comment">// - if image contains no exports,</span>
00687             <span class="comment">//      since Wx86 thunk dll not required (richedt32.dll).</span>
00688             <span class="comment">//</span>
00689 
00690         <span class="keywordflow">if</span> (IsNativeMachineType(SectionInfo.Machine)) {
00691 
00692             <span class="keywordflow">if</span> (!Wx86KnownDll ||
00693                 (SectionInfo.DllCharacteristics
00694                    &amp; IMAGE_DLLCHARACTERISTICS_X86_THUNK)) {
00695                 <span class="keywordflow">break</span>;
00696                 }
00697 
00698 
00699             <span class="keywordflow">if</span> (!SectionInfo.ImageContainsCode) {
00700                 ContainsNoExports = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00701                 <span class="keywordflow">break</span>;
00702                 }
00703 
00704             }
00705 
00706 
00707             <span class="comment">//</span>
00708             <span class="comment">// Machine Type is not native, allow:</span>
00709             <span class="comment">// - if x86 importer, and machine type is x86</span>
00710             <span class="comment">// - if image doesn't contain code,</span>
00711             <span class="comment">//      since its probably a resource\data dll only.</span>
00712             <span class="comment">//</span>
00713 
00714         <span class="keywordflow">else</span> {
00715 
00716             <span class="keywordflow">if</span> (SectionInfo.Machine == IMAGE_FILE_MACHINE_I386) {
00717                 <span class="keywordflow">if</span> (Wx86KnownDll) {
00718                     <span class="keywordflow">break</span>;
00719                     }
00720                 }
00721 
00722 
00723             <span class="keywordflow">if</span> (!SectionInfo.ImageContainsCode) {
00724                 ContainsNoExports = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00725                 <span class="keywordflow">break</span>;
00726                 }
00727             }
00728 
00729 
00730         <span class="comment">//</span>
00731         <span class="comment">// Failure because of an image machine mismatch.</span>
00732         <span class="comment">// Save the mapped dll information for plugin processing or a hard</span>
00733         <span class="comment">// error in case we can't find an image with matching machine type.</span>
00734         <span class="comment">//</span>
00735 
00736         <span class="keywordflow">if</span> (!MismatchEncountered) {
00737             FullName.MaximumLength = FullNameUnicode.MaximumLength;
00738             FullName.Buffer = <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a0">RtlAllocateHeap</a>(RtlProcessHeap(),
00739                                               <a class="code" href="../../d9/d2/ldrp_8h.html#a11">MAKE_TAG</a>(TEMP_TAG),
00740                                               FullName.MaximumLength
00741                                               );
00742             <span class="keywordflow">if</span> (!FullName.Buffer) {
00743                 st = STATUS_NO_MEMORY;
00744                 <span class="keywordflow">break</span>;
00745                 }
00746             st = <a class="code" href="../../d9/d0/obhandle_8c.html#a4">NtDuplicateObject</a>(NtCurrentProcess(),
00747                                    *pSection,
00748                                    NtCurrentProcess(),
00749                                    &amp;MismatchSection,
00750                                    0,
00751                                    FALSE,
00752                                    DUPLICATE_SAME_ACCESS);
00753             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(st)) {
00754                 <span class="keywordflow">break</span>;
00755                 }
00756             <a class="code" href="../../d6/d6/nls_8c.html#a44">RtlCopyUnicodeString</a>(&amp;FullName, &amp;FullNameUnicode);
00757             st = STATUS_INVALID_IMAGE_FORMAT;
00758             MismatchEncountered = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00759             }
00760 
00761         <a class="code" href="../../d5/d0/obclose_8c.html#a1">NtClose</a>(*pSection);
00762         *pSection = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00763 
00764         <span class="comment">//</span>
00765         <span class="comment">// If we previously overid system32 with wx86 sys dir</span>
00766         <span class="comment">// undo the override by retrying with system32.</span>
00767         <span class="comment">//</span>
00768 
00769         <span class="keywordflow">if</span> (DllSearchPath) {
00770             <span class="keywordflow">if</span> (Wx86DirOverride &amp;&amp; !Wx86DirUndone) {
00771                 <a class="code" href="../../d6/d6/nls_8c.html#a44">RtlCopyUnicodeString</a>(&amp;FullNameUnicode, &amp;LdrpKnownDllPath);
00772                 FullNameUnicode.Buffer[FullNameUnicode.Length &gt;&gt; 1] = <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span>;
00773                 FullNameUnicode.Length += <span class="keyword">sizeof</span>(WCHAR);
00774                 pwch = &amp;FullNameUnicode.Buffer[FullNameUnicode.Length &gt;&gt; 1];
00775                 <a class="code" href="../../d6/d6/nls_8c.html#a46">RtlAppendUnicodeStringToString</a>(&amp;FullNameUnicode, &amp;BaseNameUnicode);
00776                 BaseNameUnicode.Buffer = pwch;
00777                 Wx86DirUndone = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00778                 <span class="keywordflow">goto</span> RetryWx86SystemDir;
00779                 }
00780             }
00781 
00782         <span class="comment">//</span>
00783         <span class="comment">// if x86 Importer, with hardcoded path to system32, retry with</span>
00784         <span class="comment">// the Wx86 system directory. This is because some apps, erroneously</span>
00785         <span class="comment">// derive the system32 path by appending system32 to WinDir, instead</span>
00786         <span class="comment">// of calling GetSystemDir().</span>
00787         <span class="comment">//</span>
00788 
00789         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Wx86KnownDll &amp;&amp; !Wx86DirOverride) {
00790             NameUnicode = FullNameUnicode;
00791             NameUnicode.Length -= BaseNameUnicode.Length + <span class="keyword">sizeof</span>(WCHAR);
00792             <span class="keywordflow">if</span> (<a class="code" href="../../d6/d6/nls_8c.html#a42">RtlEqualUnicodeString</a>(&amp;NameUnicode, &amp;LdrpKnownDllPath, TRUE)) {
00793                 <a class="code" href="../../d6/d6/nls_8c.html#a44">RtlCopyUnicodeString</a>(&amp;FreeUnicode, &amp;BaseNameUnicode);
00794                 <a class="code" href="../../d6/d6/nls_8c.html#a44">RtlCopyUnicodeString</a>(&amp;FullNameUnicode, &amp;Wx86SystemDir);
00795                 FullNameUnicode.Buffer[FullNameUnicode.Length &gt;&gt; 1] = <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span>;
00796                 FullNameUnicode.Length += <span class="keyword">sizeof</span>(WCHAR);
00797                 BaseNameUnicode.Buffer = &amp;FullNameUnicode.Buffer[FullNameUnicode.Length &gt;&gt; 1];
00798                 <a class="code" href="../../d6/d6/nls_8c.html#a46">RtlAppendUnicodeStringToString</a>(&amp;FullNameUnicode, &amp;FreeUnicode);
00799                 Wx86DirUndone = Wx86DirOverride = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00800                 <span class="keywordflow">goto</span> RetryWx86SystemDir;
00801                 }
00802             }
00803 
00804 
00805 
00806         <span class="comment">//</span>
00807         <span class="comment">// Try further down the path, for a matching machine type</span>
00808         <span class="comment">// if no more path to search, we fail.</span>
00809         <span class="comment">//</span>
00810 
00811         <span class="keywordflow">if</span> (!DllSearchPath || !*DllSearchPath) {
00812             <span class="keywordflow">break</span>;
00813             }
00814 
00815         } <span class="comment">// while (TRUE)</span>
00816 
00817 
00818 
00819     <span class="comment">//</span>
00820     <span class="comment">// Cleanup the temporary allocated buffers.</span>
00821     <span class="comment">//</span>
00822 
00823     <span class="keywordflow">if</span> (FreeUnicode.Buffer) {
00824         <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>(RtlProcessHeap(), 0, FreeUnicode.Buffer);
00825         }
00826 
00827     <span class="keywordflow">if</span> (MismatchEncountered &amp;&amp; !StaticLink) {
00828         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(st)) {
00829             <span class="comment">//</span>
00830             <span class="comment">// Mismatch was encountered, but a DLL further along the path</span>
00831             <span class="comment">// did match.  Cleanup the mismatch stuff.</span>
00832             <span class="comment">//</span>
00833             <a class="code" href="../../d5/d0/obclose_8c.html#a1">NtClose</a>(MismatchSection);
00834             MismatchSection = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00835             MismatchEncountered = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00836         } <span class="keywordflow">else</span> {
00837             <span class="comment">//</span>
00838             <span class="comment">// No matching DLL found.  Revert back to the image that gave the</span>
00839             <span class="comment">// image type mismatch.</span>
00840             <span class="comment">//</span>
00841             <span class="keywordflow">if</span> (pSection) <a class="code" href="../../d5/d0/obclose_8c.html#a1">NtClose</a>(*pSection);
00842             *pSection = MismatchSection;
00843             MismatchSection = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00844             st = STATUS_SUCCESS;
00845         }
00846     }
00847 
00848     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(st)) {
00849         <span class="comment">//</span>
00850         <span class="comment">// Map the section into memory</span>
00851         <span class="comment">//</span>
00852         *pViewSize = 0;
00853         ViewBase = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00854         ArbitraryUserPointer = Teb-&gt;NtTib.ArbitraryUserPointer;
00855         Teb-&gt;NtTib.ArbitraryUserPointer = FullNameUnicode.Buffer;
00856         st = <a class="code" href="../../d3/d5/mapview_8c.html#a20">NtMapViewOfSection</a>(*pSection,
00857                                 NtCurrentProcess(),
00858                                 &amp;ViewBase,
00859                                 0L,
00860                                 0L,
00861                                 NULL,
00862                                 pViewSize,
00863                                 ViewShare,
00864                                 0L,
00865                                 PAGE_READWRITE
00866                                 );
00867         <span class="comment">// Save this return code because it may be STATUS_IMAGE_NOT_AT_BASE.</span>
00868         <span class="comment">// This status must be returned so the dll will be relocated by the caller.</span>
00869         stMapSection = st;
00870         Teb-&gt;NtTib.ArbitraryUserPointer = ArbitraryUserPointer;
00871         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(st)) {
00872             <span class="keywordflow">goto</span> LWMDGiveUp;
00873             }
00874 
00875         NtHeaders = <a class="code" href="../../d8/d9/imagedir_8c.html#a0">RtlImageNtHeader</a>(ViewBase);
00876         <span class="keywordflow">if</span> (NtHeaders == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00877             st = STATUS_INVALID_IMAGE_FORMAT;
00878             <span class="keywordflow">goto</span> LWMDGiveUp;
00879             }
00880 
00881 <span class="preprocessor">#if defined (_ALPHA_)</span>
00882 <span class="preprocessor"></span>        <span class="comment">//</span>
00883         <span class="comment">// Fix up non alpha compatible images</span>
00884         <span class="comment">//</span>
00885 
00886         <span class="keywordflow">if</span> (NtHeaders-&gt;OptionalHeader.SectionAlignment &lt; <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>) {
00887             <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>    formatStatus = LdrpWx86FormatVirtualImage((PIMAGE_NT_HEADERS32)NtHeaders, ViewBase);
00888             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(formatStatus)) {
00889                 st = formatStatus;            
00890                 <span class="keywordflow">goto</span> LWMDGiveUp;
00891             }
00892         }
00893 <span class="preprocessor">#endif</span>
00894 <span class="preprocessor"></span>    }
00895 
00896     <span class="keywordflow">if</span> (MismatchEncountered) {
00897 
00898 <span class="preprocessor">#if defined (_ALPHA_)</span>
00899 <span class="preprocessor"></span>
00900        <span class="keywordflow">if</span> (!StaticLink) {
00901 
00902            <span class="comment">// Encountered a mismatch image type and didn't find another</span>
00903            <span class="comment">// that matches.  Attempt to find a plugin provider dll that</span>
00904            <span class="comment">// can thunk this interface.</span>
00905            <span class="comment">// If there are no errors in plugin processing:</span>
00906            <span class="comment">//      st = STATUS_SUCCESS if plugin was thunked</span>
00907            <span class="comment">//      st = STATUS_IMAGE_MACHINE_TYPE_MISMATCH if not thunked</span>
00908            <span class="comment">// Otherwise st will contain the error from the plugin code</span>
00909 
00910            PLDR_DATA_TABLE_ENTRY Temp;
00911 
00912            <span class="comment">// temporarily insert the image in the loaded-module-list</span>
00913 
00914            Temp = <a class="code" href="../../d2/d3/ldrsnap_8c.html#a52">LdrpAllocateDataTableEntry</a>(ViewBase);
00915            <span class="keywordflow">if</span> (!Temp) {
00916                st = STATUS_NO_MEMORY;
00917            } <span class="keywordflow">else</span> {
00918                Temp-&gt;Flags = 0;
00919                Temp-&gt;LoadCount = 0;
00920                Temp-&gt;FullDllName = FullNameUnicode;
00921                Temp-&gt;BaseDllName = BaseNameUnicode;
00922                Temp-&gt;EntryPoint = <a class="code" href="../../d2/d3/ldrsnap_8c.html#a55">LdrpFetchAddressOfEntryPoint</a>(Temp-&gt;DllBase);
00923                <a class="code" href="../../d2/d3/ldrsnap_8c.html#a53">LdrpInsertMemoryTableEntry</a>(Temp);
00924 
00925                <span class="comment">// Determine if this dll can be thunked using a plugin</span>
00926 
00927                st = Wx86IdentifyPlugin(ViewBase, &amp;FullNameUnicode );
00928 
00929                <span class="comment">// remove the image from the loaded-module-list.</span>
00930                <span class="comment">// It will be added again in the main-line path.</span>
00931 
00932                RemoveEntryList(&amp;Temp-&gt;InLoadOrderLinks);
00933                RemoveEntryList(&amp;Temp-&gt;InMemoryOrderLinks);
00934                RemoveEntryList(&amp;Temp-&gt;HashLinks);
00935                <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>(RtlProcessHeap(), 0, Temp);
00936                Temp = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00937 
00938                <span class="keywordflow">if</span> (<a class="code" href="../../d9/d2/ldrp_8h.html#a30">ShowSnaps</a>) {
00939                    PCHAR <a class="code" href="../../d7/d0/cmdat2_8c.html#a18">Action</a>;
00940 
00941                    <span class="keywordflow">if</span> (st == STATUS_SUCCESS) {
00942                        <a class="code" href="../../d7/d0/cmdat2_8c.html#a18">Action</a> = <span class="stringliteral">"Loaded"</span>;
00943                    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (st == STATUS_IMAGE_MACHINE_TYPE_MISMATCH) {
00944                        <a class="code" href="../../d7/d0/cmdat2_8c.html#a18">Action</a> = <span class="stringliteral">"Unsupported"</span>;
00945                    } <span class="keywordflow">else</span> {
00946                        <a class="code" href="../../d7/d0/cmdat2_8c.html#a18">Action</a> = <span class="stringliteral">"Failed"</span>;
00947                    }
00948 
00949                    <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"LDRWx86: Plugin: %wZ %s.\n"</span>,
00950                        &amp;FullNameUnicode, Action
00951                        );
00952                }
00953                
00954                <span class="comment">// If plug provider supports this dll flag it and restore</span>
00955                <span class="comment">// status to the return code from original NtMapViewOfSection.</span>
00956                <span class="comment">// Howver, don't revert to STATUS_IMAGE_MACHINE_TYPE_MISMATCH -</span>
00957                <span class="comment">// that's what we just fixed up.</span>
00958                
00959                <span class="keywordflow">if</span> (st == STATUS_SUCCESS) {
00960                    Wx86Plugin = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00961                    <span class="keywordflow">if</span> (stMapSection != STATUS_IMAGE_MACHINE_TYPE_MISMATCH) {
00962                    st = stMapSection;
00963                    }
00964                }
00965            }
00966        }
00967 <span class="preprocessor">#endif</span>
00968 <span class="preprocessor"></span>       <span class="keywordflow">if</span> (st == STATUS_IMAGE_MACHINE_TYPE_MISMATCH) {
00969 
00970            <span class="comment">// Encountered a mismatch image type.</span>
00971            <span class="comment">// Raise a Hard Error for the machine mismatch.</span>
00972 
00973            <span class="keywordflow">if</span> (<a class="code" href="../../d9/d2/ldrp_8h.html#a30">ShowSnaps</a>) {
00974                <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"Wx86 image type mismatch loading %ws (expected %s)\n"</span>,
00975                        FullName.Buffer,
00976                        Wx86KnownDll? <span class="stringliteral">"x86"</span> : <span class="stringliteral">"RISC"</span>
00977                        );
00978                }
00979 
00980            <span class="keywordflow">if</span> ( NtHeaders-&gt;OptionalHeader.MajorSubsystemVersion &lt;= 3 ) {
00981 
00982                ULONG_PTR ErrorParameters[2];
00983                ULONG ErrorResponse;
00984 
00985                ErrorResponse = ResponseOk;
00986 
00987                ErrorParameters[0] = (ULONG_PTR)&amp;FullName;
00988 
00989                <a class="code" href="../../d6/d8/ex_2harderr_8c.html#a11">NtRaiseHardError</a>(STATUS_IMAGE_MACHINE_TYPE_MISMATCH_EXE,
00990                                 1,
00991                                 1,
00992                                 ErrorParameters,
00993                                 OptionOk,
00994                                 &amp;ErrorResponse
00995                                 );
00996 
00997            }
00998 
00999            st = STATUS_INVALID_IMAGE_FORMAT;
01000        }
01001     }
01002 
01003     <span class="comment">//</span>
01004     <span class="comment">// if we were successfull,</span>
01005     <span class="comment">// allocate and fill FullDllName, BaseDllName for the caller.</span>
01006     <span class="comment">//</span>
01007 
01008     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(st)) {
01009         PUNICODE_STRING <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a96">Unicode</a>;
01010 
01011 
01012         <span class="keywordflow">if</span> (st == STATUS_IMAGE_MACHINE_TYPE_MISMATCH) {
01013             st = NtHeaders-&gt;OptionalHeader.ImageBase == (ULONG_PTR)ViewBase
01014                     ? STATUS_SUCCESS : STATUS_IMAGE_NOT_AT_BASE;
01015             }
01016 
01017         *pEntry = Entry = <a class="code" href="../../d2/d3/ldrsnap_8c.html#a52">LdrpAllocateDataTableEntry</a>(ViewBase);
01018         <span class="keywordflow">if</span> (!Entry) {
01019             st = STATUS_NO_MEMORY;
01020             <span class="keywordflow">goto</span> LWMDGiveUp;
01021             }
01022 
01023         <span class="comment">//</span>
01024         <span class="comment">// Fil in loader entry</span>
01025         <span class="comment">//</span>
01026 
01027         Entry-&gt;Flags = StaticLink ? LDRP_STATIC_LINK : 0;
01028         <span class="keywordflow">if</span> (ContainsNoExports) {
01029             Entry-&gt;Flags |= LDRP_WX86_IGNORE_MACHINETYPE;
01030             }
01031         <span class="keywordflow">if</span> (Wx86Plugin) {
01032             Entry-&gt;Flags |= LDRP_WX86_PLUGIN;
01033         }
01034 
01035         Entry-&gt;LoadCount = 0;
01036         Entry-&gt;EntryPoint = <a class="code" href="../../d2/d3/ldrsnap_8c.html#a55">LdrpFetchAddressOfEntryPoint</a>(ViewBase);
01037         Entry-&gt;FullDllName.Buffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01038         Entry-&gt;BaseDllName.Buffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01039 
01040 
01041         <span class="comment">//</span>
01042         <span class="comment">// Copy in the full dll name</span>
01043         <span class="comment">//</span>
01044 
01045         <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a96">Unicode</a> = &amp;Entry-&gt;FullDllName;
01046         <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a96">Unicode</a>-&gt;Length = FullNameUnicode.Length;
01047         <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a96">Unicode</a>-&gt;MaximumLength = <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a96">Unicode</a>-&gt;Length + <span class="keyword">sizeof</span>(UNICODE_NULL);
01048         <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a96">Unicode</a>-&gt;Buffer = <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a0">RtlAllocateHeap</a>(RtlProcessHeap(),
01049                                           <a class="code" href="../../d9/d2/ldrp_8h.html#a11">MAKE_TAG</a>( LDR_TAG ),
01050                                           <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a96">Unicode</a>-&gt;MaximumLength
01051                                           );
01052         <span class="keywordflow">if</span> (!<a class="code" href="../../d2/d0/nt6_2user32_8def.html#a96">Unicode</a>-&gt;Buffer) {
01053             st = STATUS_NO_MEMORY;
01054             <span class="keywordflow">goto</span> LWMDGiveUp;
01055             }
01056 
01057         RtlCopyMemory(<a class="code" href="../../d2/d0/nt6_2user32_8def.html#a96">Unicode</a>-&gt;Buffer,
01058                       FullNameUnicode.Buffer,
01059                       <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a96">Unicode</a>-&gt;MaximumLength
01060                       );
01061 
01062 
01063         <span class="comment">//</span>
01064         <span class="comment">// Copy in the basename</span>
01065         <span class="comment">//</span>
01066 
01067         <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a96">Unicode</a> = &amp;Entry-&gt;BaseDllName;
01068         <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a96">Unicode</a>-&gt;Length = BaseNameUnicode.Length;
01069         <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a96">Unicode</a>-&gt;MaximumLength = <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a96">Unicode</a>-&gt;Length + <span class="keyword">sizeof</span>(UNICODE_NULL);
01070         <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a96">Unicode</a>-&gt;Buffer = <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a0">RtlAllocateHeap</a>(RtlProcessHeap(),
01071                                               <a class="code" href="../../d9/d2/ldrp_8h.html#a11">MAKE_TAG</a>( LDR_TAG ),
01072                                               <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a96">Unicode</a>-&gt;MaximumLength
01073                                               );
01074 
01075         <span class="keywordflow">if</span> (<a class="code" href="../../d2/d0/nt6_2user32_8def.html#a96">Unicode</a>-&gt;Buffer) {
01076             RtlCopyMemory(<a class="code" href="../../d2/d0/nt6_2user32_8def.html#a96">Unicode</a>-&gt;Buffer,
01077                           BaseNameUnicode.Buffer,
01078                           <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a96">Unicode</a>-&gt;MaximumLength
01079                           );
01080             }
01081         <span class="keywordflow">else</span> {
01082             st = STATUS_NO_MEMORY;
01083             }
01084 
01085 
01086         }
01087 
01088 
01089 LWMDGiveUp:
01090 
01091     <span class="comment">// cleanup items saved from mismatched images</span>
01092 
01093     <span class="keywordflow">if</span> (MismatchSection) {
01094         <a class="code" href="../../d5/d0/obclose_8c.html#a1">NtClose</a>(MismatchSection);
01095     }
01096 
01097     <span class="keywordflow">if</span> (FullName.Buffer) {
01098         <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>(RtlProcessHeap(), 0, FullName.Buffer);
01099     }
01100 
01101     <span class="comment">//</span>
01102     <span class="comment">// If failure, cleanup mapview and section.</span>
01103     <span class="comment">//</span>
01104 
01105     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(st)) {
01106 
01107         <span class="keywordflow">if</span> (ViewBase) {
01108             <a class="code" href="../../d4/d9/umapview_8c.html#a0">NtUnmapViewOfSection</a>( NtCurrentProcess(), ViewBase);
01109             }
01110 
01111         <span class="keywordflow">if</span> (*pSection) {
01112             <a class="code" href="../../d5/d0/obclose_8c.html#a1">NtClose</a>(*pSection);
01113             }
01114 
01115         <span class="keywordflow">if</span> (Entry) {
01116             <span class="keywordflow">if</span> (Entry-&gt;FullDllName.Buffer) {
01117                 <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>(RtlProcessHeap(), 0, Entry-&gt;FullDllName.Buffer);
01118                 }
01119 
01120             <span class="keywordflow">if</span> (Entry-&gt;BaseDllName.Buffer) {
01121                 <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>(RtlProcessHeap(), 0, Entry-&gt;BaseDllName.Buffer);
01122                 }
01123 
01124             <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>(RtlProcessHeap(), 0, Entry);
01125 
01126             *pEntry = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01127 
01128             }
01129 
01130         }
01131     <span class="keywordflow">return</span> st;
01132 }
01133 
01134 
01135 
01136 
01137 PLDR_DATA_TABLE_ENTRY
01138 LdrpWx86CheckForLoadedDll(
01139     IN PWSTR DllPath OPTIONAL,
01140     IN PUNICODE_STRING DllName,
01141     IN BOOLEAN Wx86KnownDll,
01142     OUT PUNICODE_STRING FullDllName
01143     )
01144 <span class="comment">/*++</span>
01145 <span class="comment"></span>
01146 <span class="comment">Routine Description:</span>
01147 <span class="comment"></span>
01148 <span class="comment">    Checks for loaded dlls, ensuring that duplicate module</span>
01149 <span class="comment">    base names are resolved correctly</span>
01150 <span class="comment"></span>
01151 <span class="comment">Arguments:</span>
01152 <span class="comment"></span>
01153 <span class="comment">    DllPath      - optional search path used to locate the DLL.</span>
01154 <span class="comment"></span>
01155 <span class="comment">    DllName      - Name of Dll</span>
01156 <span class="comment"></span>
01157 <span class="comment">    Wx86KnownDll - if true, Importer is x86.</span>
01158 <span class="comment"></span>
01159 <span class="comment">    FullDllName  - buffer to receive full path name,</span>
01160 <span class="comment">                   assumes STATIC_UNICODE_BUFFER_LENGTH</span>
01161 <span class="comment"></span>
01162 <span class="comment">Return Value:</span>
01163 <span class="comment"></span>
01164 <span class="comment">    LdrEntry for dllname if found, otherwise NULL.</span>
01165 <span class="comment"></span>
01166 <span class="comment">--*/</span>
01167 {
01168     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01169     <span class="keywordtype">int</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>, Length;
01170     PWCHAR pwch;
01171     PLIST_ENTRY Head, Next;
01172     PLDR_DATA_TABLE_ENTRY LdrEntry;
01173     BOOLEAN HardCodedPath= <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01174     UNICODE_STRING BaseDllName;
01175     UNICODE_STRING FreeUnicode;
01176     UNICODE_STRING ThunkDllName;
01177     UNICODE_STRING LocalDllName;
01178     PUNICODE_STRING ForcedDllPath;
01179     PUNICODE_STRING ForcedDllName;
01180 
01181     <span class="comment">//</span>
01182     <span class="comment">// If DllPath is not supplied, use the loader's default path</span>
01183     <span class="comment">//</span>
01184 
01185     <span class="keywordflow">if</span> (!DllPath) {
01186         DllPath = <a class="code" href="../../d9/d2/ldrp_8h.html#a22">LdrpDefaultPath</a>.Buffer;
01187         }
01188 
01189     <span class="comment">//</span>
01190     <span class="comment">// DllPath can be ignored if:</span>
01191     <span class="comment">//    1) DllPath is unusable (=1)</span>
01192     <span class="comment">// or 2) DllPath is the null string</span>
01193     <span class="comment">// or 3) DllName contains a hard coded path</span>
01194     <span class="comment">//</span>
01195 
01196     <span class="keywordflow">if</span> ((UINT_PTR)DllPath == 1 || !*DllPath ||
01197         <a class="code" href="../../d5/d1/curdir_8c.html#a23">RtlDetermineDosPathNameType_U</a>(DllName-&gt;Buffer) != RtlPathTypeRelative)
01198       {
01199         DllPath = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01200         }
01201 
01202     <span class="comment">//</span>
01203     <span class="comment">// Alloc a chunk of memory to use in constructing the full</span>
01204     <span class="comment">// dll name from the path and file name. Note that because</span>
01205     <span class="comment">// a path component may contain relative references, it may</span>
01206     <span class="comment">// exceed MAX_PATH.</span>
01207     <span class="comment">//</span>
01208 
01209     FreeUnicode.Length = 0;
01210     FreeUnicode.MaximumLength = (DOS_MAX_PATH_LENGTH*2+20)*<span class="keyword">sizeof</span>(UNICODE_NULL);
01211     <span class="keywordflow">if</span> (DllPath) {
01212         FreeUnicode.MaximumLength = wcslen(DllPath) * <span class="keyword">sizeof</span>(WCHAR);
01213         }
01214 
01215     FreeUnicode.Buffer = <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a0">RtlAllocateHeap</a>(RtlProcessHeap(),
01216                                          <a class="code" href="../../d9/d2/ldrp_8h.html#a11">MAKE_TAG</a>( TEMP_TAG ),
01217                                          FreeUnicode.MaximumLength
01218                                          );
01219     <span class="keywordflow">if</span> (!FreeUnicode.Buffer) {
01220         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01221         }
01222  
01223     <span class="comment">// Checking for known dlls before searching for the file improves performance</span>
01224     <span class="comment">// This code was moved from the do loop.  </span>
01225     FullDllName-&gt;Length = 0;
01226     BaseDllName = *DllName;
01227    
01228     LocalDllName.Buffer = wcsrchr(BaseDllName.Buffer, L<span class="charliteral">'\\'</span>);       
01229     LocalDllName.Buffer = LocalDllName.Buffer ?  &amp;LocalDllName.Buffer[1] : BaseDllName.Buffer;
01230 
01231     LocalDllName.Length = wcslen(LocalDllName.Buffer) * <span class="keyword">sizeof</span>(WCHAR);
01232     LocalDllName.MaximumLength = LocalDllName.Length + <span class="keyword">sizeof</span>(WCHAR);
01233     ForcedDllPath = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01234     ForcedDllName = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01235 
01236     <span class="keywordflow">if</span> (Wx86KnownDll) {                         <span class="comment">// if the call is from x86 apps</span>
01237         <span class="comment">// Looking for x86 dll ...</span>
01238         
01239         <span class="keywordflow">if</span> (Wx86KnownDllName(&amp;LocalDllName, &amp;ThunkDllName)) {
01240             <span class="comment">// It's a thunked dll. Redirect to system32&lt;thunk dll&gt;</span>
01241             ForcedDllPath = &amp;<a class="code" href="../../d9/d2/ldrp_8h.html#a25">LdrpKnownDllPath</a>;
01242             ForcedDllName = &amp;ThunkDllName;       <span class="comment">// use the thunked dll</span>
01243         
01244         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Wx86KnownRedistDll(&amp;LocalDllName)) {
01245             <span class="comment">// It's a redistributed x86 dll. Redirect to sys32x86&lt;dll name&gt;</span>
01246             ForcedDllPath = &amp;Wx86SystemDir;
01247             ForcedDllName = &amp;LocalDllName;       <span class="comment">// use the input dll name</span>
01248 
01249         }
01250                 
01251     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Wx86KnownNativeDll(&amp;LocalDllName)) {
01252        <span class="comment">// It's a native known dll. Redirect to system32&lt;dll name&gt;</span>
01253        ForcedDllPath = &amp;<a class="code" href="../../d9/d2/ldrp_8h.html#a25">LdrpKnownDllPath</a>;
01254        ForcedDllName = &amp;LocalDllName;
01255     }
01256 
01257     <span class="comment">// If ForcedDllPath is not null, then we either need to find the dll at the</span>
01258     <span class="comment">// predetermined path or we return failed.</span>
01259 
01260     <span class="keywordflow">if</span> (ForcedDllPath) {
01261         <a class="code" href="../../d6/d6/nls_8c.html#a44">RtlCopyUnicodeString</a>(FullDllName, ForcedDllPath );
01262         FullDllName-&gt;Buffer[FullDllName-&gt;Length/2] = <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span>;
01263         FullDllName-&gt;Length += <span class="keyword">sizeof</span>(WCHAR);
01264         BaseDllName.Buffer = &amp;FullDllName-&gt;Buffer[FullDllName-&gt;Length/2];
01265         BaseDllName.Length = ForcedDllName-&gt;Length;
01266         BaseDllName.MaximumLength = BaseDllName.Length + <span class="keyword">sizeof</span>(WCHAR);
01267         <a class="code" href="../../d6/d6/nls_8c.html#a46">RtlAppendUnicodeStringToString</a>(FullDllName, ForcedDllName);
01268         
01269         <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = <a class="code" href="../../d9/d2/ldrp_8h.html#a7">LDRP_COMPUTE_HASH_INDEX</a>(BaseDllName.Buffer[0]);
01270         Head = &amp;<a class="code" href="../../d9/d2/ldrp_8h.html#a26">LdrpHashTable</a>[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>];
01271         Next = Head-&gt;Flink;
01272         <span class="keywordflow">while</span> ( Next != Head ) {
01273             LdrEntry = CONTAINING_RECORD(Next, LDR_DATA_TABLE_ENTRY, HashLinks);
01274             <span class="keywordflow">if</span> (DllNameMatchesLdrEntry(&amp;BaseDllName,
01275                                        FullDllName,
01276                                        LdrEntry,
01277                                        Wx86KnownDll
01278                                        ))
01279             {
01280                 <span class="keywordflow">goto</span> FoundMatch;
01281             }
01282             Next = Next-&gt;Flink;
01283             <span class="comment">// not a Wx86 Known dll or Wx86 Known dll is not loaded.</span>
01284         }
01285       
01286         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01287     }
01288     
01289     <span class="comment">//</span>
01290     <span class="comment">// Search the DllPath, and verify that fullpath and machine type match.</span>
01291     <span class="comment">//</span>
01292 
01293     <span class="keywordflow">do</span> {
01294         <span class="keywordflow">if</span> (DllPath) {
01295             <span class="keywordflow">if</span> (!SearchWx86Dll(DllPath,
01296                                DllName,
01297                                &amp;FreeUnicode,
01298                                &amp;DllPath
01299                                ))
01300             {
01301                FullDllName-&gt;Length = 0;
01302                FullDllName-&gt;Buffer[0] = <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\0'</span>;
01303                BaseDllName = *DllName;
01304 
01305                <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = <a class="code" href="../../d9/d2/ldrp_8h.html#a7">LDRP_COMPUTE_HASH_INDEX</a>(BaseDllName.Buffer[0]);
01306                Head = &amp;<a class="code" href="../../d9/d2/ldrp_8h.html#a26">LdrpHashTable</a>[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>];
01307                Next = Head-&gt;Flink;
01308                <span class="keywordflow">while</span> ( Next != Head ) {
01309                    LdrEntry = CONTAINING_RECORD(Next, LDR_DATA_TABLE_ENTRY, HashLinks);
01310                    <span class="keywordflow">if</span> (DllNameMatchesLdrEntry(&amp;BaseDllName,
01311                                               FullDllName,
01312                                               LdrEntry,
01313                                               Wx86KnownDll
01314                                               ))
01315                      {
01316                        <span class="keywordflow">goto</span> FoundMatch;
01317                        }
01318                    Next = Next-&gt;Flink;
01319                    }
01320 
01321                <span class="keywordflow">break</span>;
01322                }
01323 
01324             pwch = FreeUnicode.Buffer;
01325             }
01326         <span class="keywordflow">else</span> {
01327             pwch = DllName-&gt;Buffer;
01328             }
01329 
01330        <span class="comment">//</span>
01331        <span class="comment">// Form the fullpathname</span>
01332        <span class="comment">//</span>
01333 
01334        FullDllName-&gt;Length = 0;
01335        Length = <a class="code" href="../../d5/d1/curdir_8c.html#a27">RtlGetFullPathName_U</a>(pwch,
01336                                      FullDllName-&gt;MaximumLength,
01337                                      FullDllName-&gt;Buffer,
01338                                      &amp;pwch  <span class="comment">// receives address of file name portion</span>
01339                                      );
01340 
01341        <span class="keywordflow">if</span> (Length &amp;&amp; Length &lt; FullDllName-&gt;MaximumLength) {
01342            UNICODE_STRING PathPart;
01343 
01344            <span class="comment">// Setup BaseDllName as the file name portion of FullDllName</span>
01345 
01346            FullDllName-&gt;Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)Length;
01347            <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;BaseDllName, pwch);
01348 
01349            <span class="comment">// Setup PathPart as the path portion of FullDllName</span>
01350 
01351            PathPart = *FullDllName;
01352            PathPart.Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)((ULONG_PTR)BaseDllName.Buffer  -
01353                                       (ULONG_PTR)FullDllName-&gt;Buffer -
01354                                       <span class="keyword">sizeof</span>(WCHAR)
01355                                       );
01356            <span class="comment">//</span>
01357            <span class="comment">// Search Loader HashTable by BaseName.</span>
01358            <span class="comment">// For each matching basename, verify the full path and machine type.</span>
01359            <span class="comment">//</span>
01360 
01361            <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = <a class="code" href="../../d9/d2/ldrp_8h.html#a7">LDRP_COMPUTE_HASH_INDEX</a>(BaseDllName.Buffer[0]);
01362            Head = &amp;<a class="code" href="../../d9/d2/ldrp_8h.html#a26">LdrpHashTable</a>[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>];
01363            Next = Head-&gt;Flink;
01364            <span class="keywordflow">while</span> ( Next != Head ) {
01365                LdrEntry = CONTAINING_RECORD(Next, LDR_DATA_TABLE_ENTRY, HashLinks);
01366                <span class="keywordflow">if</span> (DllNameMatchesLdrEntry(&amp;BaseDllName,
01367                                           FullDllName,
01368                                           LdrEntry,
01369                                           Wx86KnownDll
01370                                           ))
01371                  {
01372                    <span class="keywordflow">goto</span> FoundMatch;
01373                    }
01374                Next = Next-&gt;Flink;
01375                }
01376 
01377 
01378            <span class="comment">//</span>
01379            <span class="comment">// TBD: need to add code from LdrpCheckForLoadedDll</span>
01380         <span class="comment">//</span>
01381         <span class="comment">// no names matched. This might be a long short name mismatch or</span>
01382         <span class="comment">// any kind of alias pathname. Deal with this by opening and mapping</span>
01383         <span class="comment">// full dll name and then repeat the scan this time checking for</span>
01384         <span class="comment">// timedatestamp matches</span>
01385         <span class="comment">//</span>
01386            <span class="comment">//</span>
01387 
01388            }
01389 
01390 
01391     } <span class="keywordflow">while</span> (DllPath &amp;&amp; *DllPath);
01392 
01393     LdrEntry = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01394 
01395 FoundMatch:
01396     <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>(RtlProcessHeap(), 0, FreeUnicode.Buffer);
01397     <span class="keywordflow">return</span> LdrEntry;
01398 }
01399 
01400 
01401 
01402 
01403 
01404 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01405 LdrpWx86DllProcessDetach(
01406     IN PLDR_DATA_TABLE_ENTRY LdrDataTableEntry
01407     )
01408 <span class="comment">/*++</span>
01409 <span class="comment"></span>
01410 <span class="comment">Routine Description:</span>
01411 <span class="comment"></span>
01412 <span class="comment">    Handles process detach for LdrUnload</span>
01413 <span class="comment"></span>
01414 <span class="comment">Arguments:</span>
01415 <span class="comment"></span>
01416 <span class="comment">    InitRoutine     - address of i386 dll entry point</span>
01417 <span class="comment">    DllBase         - standard dll entry point parameters</span>
01418 <span class="comment"></span>
01419 <span class="comment"></span>
01420 <span class="comment">Return Value:</span>
01421 <span class="comment"></span>
01422 <span class="comment">    SUCCESS or reason</span>
01423 <span class="comment"></span>
01424 <span class="comment">--*/</span>
01425 {
01426     PIMAGE_NT_HEADERS NtHeader;
01427     PDLL_INIT_ROUTINE InitRoutine;
01428 
01429 
01430     <span class="comment">//</span>
01431     <span class="comment">// check for all x86dlls unloaded</span>
01432     <span class="comment">//</span>
01433 
01434     NtHeader = <a class="code" href="../../d8/d9/imagedir_8c.html#a0">RtlImageNtHeader</a>(LdrDataTableEntry-&gt;DllBase);
01435     InitRoutine = (PDLL_INIT_ROUTINE)LdrDataTableEntry-&gt;EntryPoint;
01436     <span class="keywordflow">if</span> (InitRoutine &amp;&amp; (LdrDataTableEntry-&gt;Flags &amp; LDRP_PROCESS_ATTACH_CALLED)) {
01437         <span class="keywordflow">if</span> (<a class="code" href="../../d9/d2/ldrp_8h.html#a30">ShowSnaps</a>) {
01438             <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"WX86LDR: Calling deinit %lx\n"</span>, InitRoutine);
01439             }
01440 
01441         <span class="keywordflow">if</span> (NtHeader-&gt;FileHeader.Machine == IMAGE_FILE_MACHINE_I386) {
01442             (Wx86DllEntryPoint)(InitRoutine,
01443                                 LdrDataTableEntry-&gt;DllBase,
01444                                 DLL_PROCESS_DETACH,
01445                                 <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>
01446                                 );
01447 
01448             }
01449         <span class="keywordflow">else</span> {
01450             <a class="code" href="../../d9/d2/ldrp_8h.html#a20">LdrpCallInitRoutine</a>(InitRoutine,
01451                                 LdrDataTableEntry-&gt;DllBase,
01452                                 DLL_PROCESS_DETACH,
01453                                 NULL);
01454             }
01455 
01456         }
01457 }
01458 
01459 
01460 
01461 
01462 
01463 
01464 
01465 
01466 
01467 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01468 LdrpRunWx86DllEntryPoint(
01469     IN PDLL_INIT_ROUTINE InitRoutine,
01470     OUT BOOLEAN *pInitStatus,
01471     IN PVOID DllBase,
01472     IN ULONG Reason,
01473     IN PCONTEXT Context
01474     )
01475 <span class="comment">/*++</span>
01476 <span class="comment"></span>
01477 <span class="comment">Routine Description:</span>
01478 <span class="comment"></span>
01479 <span class="comment">    Invokes the i386 emulator (wx86.dll) to run dll entry points.</span>
01480 <span class="comment"></span>
01481 <span class="comment">Arguments:</span>
01482 <span class="comment"></span>
01483 <span class="comment">    InitRoutine     - address of i386 dll entry point</span>
01484 <span class="comment"></span>
01485 <span class="comment">    pInitStatus     - receives return code from the InitRoutine</span>
01486 <span class="comment"></span>
01487 <span class="comment">    DllBase         - standard dll entry point parameters</span>
01488 <span class="comment">    Reason</span>
01489 <span class="comment">    Context</span>
01490 <span class="comment"></span>
01491 <span class="comment"></span>
01492 <span class="comment">Return Value:</span>
01493 <span class="comment"></span>
01494 <span class="comment">    SUCCESS or reason</span>
01495 <span class="comment"></span>
01496 <span class="comment">--*/</span>
01497 
01498 {
01499     PIMAGE_NT_HEADERS NtHeader = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01500     BOOLEAN InitStatus;
01501     PWX86TIB Wx86Tib;
01502 
01503     NtHeader = <a class="code" href="../../d8/d9/imagedir_8c.html#a0">RtlImageNtHeader</a>(DllBase);
01504     <span class="keywordflow">if</span> (NtHeader &amp;&amp; NtHeader-&gt;FileHeader.Machine == IMAGE_FILE_MACHINE_I386) {
01505 
01506         InitStatus  =  (Wx86DllEntryPoint)(InitRoutine,
01507                                            DllBase,
01508                                            Reason,
01509                                            Context
01510                                            );
01511 
01512         <span class="keywordflow">if</span> (pInitStatus) {
01513             *pInitStatus = InitStatus;
01514             }
01515 
01516         <span class="keywordflow">return</span> STATUS_SUCCESS;
01517 
01518         }
01519 
01520     <span class="keywordflow">return</span> STATUS_IMAGE_MACHINE_TYPE_MISMATCH;
01521 }
01522 
01523 
01524 
01525 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01526 LoaderWx86Unload(
01527     VOID
01528     )
01529 <span class="comment">/*++</span>
01530 <span class="comment"></span>
01531 <span class="comment">Routine Description:</span>
01532 <span class="comment"></span>
01533 <span class="comment">   When Wx86.dll process detach routine executes, Wx86.dll invokes this routine</span>
01534 <span class="comment">   so that the loader can cleanup Wx86 specific stuff.</span>
01535 <span class="comment"></span>
01536 <span class="comment"></span>
01537 <span class="comment">Arguments:</span>
01538 <span class="comment"></span>
01539 <span class="comment">   none</span>
01540 <span class="comment"></span>
01541 <span class="comment">Return Value:</span>
01542 <span class="comment"></span>
01543 <span class="comment">    SUCCESS or reason</span>
01544 <span class="comment"></span>
01545 <span class="comment">--*/</span>
01546 
01547 {
01548      Wx86ProcessInit = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01549      Wx86DllMapNotify = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01550      Wx86DllEntryPoint = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01551      Wx86ProcessStartRoutine= <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01552      Wx86ThreadStartRoutine= <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01553      Wx86KnownDllName = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01554      Wx86KnownNativeDll = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01555      Wx86KnownRedistDll = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01556      Wx86OnTheFly=<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01557 
01558 
01559      <span class="keywordflow">if</span> (Wx86SystemDir.Buffer) {
01560          <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>(RtlProcessHeap(), 0, Wx86SystemDir.Buffer);
01561          Wx86SystemDir.Buffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01562          }
01563 
01564      <span class="keywordflow">return</span> STATUS_SUCCESS;
01565 
01566 }
01567 
01568 
01569 
01570 
01571 
01572 
01573 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01574 LdrpLoadWx86Dll(
01575     PCONTEXT Context
01576     )
01577 <span class="comment">/*++</span>
01578 <span class="comment"></span>
01579 <span class="comment">Routine Description:</span>
01580 <span class="comment"></span>
01581 <span class="comment">   Loads in the i386 emulator (wx86.dll) and performs process initialization</span>
01582 <span class="comment">   for wx86 specific ldr code.</span>
01583 <span class="comment"></span>
01584 <span class="comment">Arguments:</span>
01585 <span class="comment"></span>
01586 <span class="comment">   Context, initial process context,</span>
01587 <span class="comment">   if hibit set this is ofly init after process initialzation is complete</span>
01588 <span class="comment">   (Wx86 on the fly), and the PCONTEXT == Wx86DllHandle | 0x80000000</span>
01589 <span class="comment"></span>
01590 <span class="comment">Return Value:</span>
01591 <span class="comment"></span>
01592 <span class="comment">   SUCCESS or reason</span>
01593 <span class="comment"></span>
01594 <span class="comment">--*/</span>
01595 {
01596     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> st;
01597     ULONG Length;
01598     PVOID DllHandle;
01599     ANSI_STRING ProcName;
01600     UNICODE_STRING DllName;
01601     WCHAR <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>[STATIC_UNICODE_BUFFER_LENGTH];
01602 
01603     <span class="comment">//</span>
01604     <span class="comment">// Retrieve the dll handle for the ofly case</span>
01605     <span class="comment">//</span>
01606 
01607     DllHandle = (PVOID)((UINT_PTR)Context &amp; ~0x80000000);
01608 
01609     <span class="keywordflow">if</span> (DllHandle != Context) {
01610         Context = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01611         }
01612     <span class="keywordflow">else</span> {
01613         DllHandle = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01614         }
01615 
01616     <span class="comment">//</span>
01617     <span class="comment">// initialize Wx86SystemDir</span>
01618     <span class="comment">//</span>
01619 
01620     <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>( &amp;NtSystemRoot, USER_SHARED_DATA-&gt;NtSystemRoot );
01621     Wx86SystemDir.MaximumLength = <a class="code" href="../../d8/d1/init_8h.html#a3">NtSystemRoot</a>.Length + <span class="keyword">sizeof</span>(Wx86Dir);
01622     Wx86SystemDir.Buffer = <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a0">RtlAllocateHeap</a>(RtlProcessHeap(),
01623                                            <a class="code" href="../../d9/d2/ldrp_8h.html#a11">MAKE_TAG</a>( LDR_TAG ),
01624                                            Wx86SystemDir.MaximumLength
01625                                            );
01626     <span class="keywordflow">if</span> (!Wx86SystemDir.Buffer) {
01627         st = STATUS_NO_MEMORY;
01628         <span class="keywordflow">goto</span> LWx86DllError;
01629         }
01630 
01631     <a class="code" href="../../d6/d6/nls_8c.html#a44">RtlCopyUnicodeString</a>(&amp;Wx86SystemDir, &amp;NtSystemRoot);
01632     st = <a class="code" href="../../d6/d6/nls_8c.html#a45">RtlAppendUnicodeToString</a>(&amp;Wx86SystemDir, Wx86Dir);
01633     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(st)) {
01634         <span class="keywordflow">goto</span> LWx86DllError;
01635         }
01636 
01637 
01638 
01639     <span class="comment">//</span>
01640     <span class="comment">// Load Wx86.dll, wintdll.dll. This must be done before the app binary is</span>
01641     <span class="comment">// snapped to ensure wx86.dll is ready for emulation.</span>
01642     <span class="comment">//</span>
01643 
01644     <span class="keywordflow">if</span> (!DllHandle) {
01645         DllName.Buffer = <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>;
01646         DllName.MaximumLength = <span class="keyword">sizeof</span>(<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>);
01647         <a class="code" href="../../d6/d6/nls_8c.html#a44">RtlCopyUnicodeString</a>(&amp;DllName, &amp;LdrpKnownDllPath);
01648         DllName.Buffer[DllName.Length / <span class="keyword">sizeof</span>(WCHAR)] = <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span>;
01649         DllName.Length += <span class="keyword">sizeof</span>(WCHAR);
01650         <a class="code" href="../../d6/d6/nls_8c.html#a45">RtlAppendUnicodeToString</a>(&amp;DllName, L<span class="stringliteral">"wx86.dll"</span>);
01651 
01652         st = <a class="code" href="../../d9/d2/ldrp_8h.html#a82">LdrpLoadDll</a>(NULL, NULL, &amp;DllName, &amp;DllHandle, TRUE);
01653         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(st)) {
01654             <span class="keywordflow">goto</span> LWx86DllError;
01655             }
01656         }
01657 
01658     <span class="comment">//</span>
01659     <span class="comment">// Get fn address from Wx86.dll</span>
01660     <span class="comment">//</span>
01661 
01662     <a class="code" href="../../d2/d7/string_8c.html#a6">RtlInitAnsiString</a> (&amp;ProcName,<span class="stringliteral">"Wx86KnownDllName"</span>);
01663     st = <a class="code" href="../../d4/d2/ldrapi_8c.html#a7">LdrGetProcedureAddress</a>(DllHandle,
01664                                 &amp;ProcName,
01665                                 0,
01666                                 (PVOID *)&amp;Wx86KnownDllName
01667                                 );
01668     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(st)) {
01669         <span class="keywordflow">goto</span> LWx86DllError;
01670         }
01671 
01672 
01673     <a class="code" href="../../d2/d7/string_8c.html#a6">RtlInitAnsiString</a> (&amp;ProcName,<span class="stringliteral">"Wx86KnownNativeDll"</span>);
01674     st = <a class="code" href="../../d4/d2/ldrapi_8c.html#a7">LdrGetProcedureAddress</a>(DllHandle,
01675                                 &amp;ProcName,
01676                                 0,
01677                                 (PVOID *)&amp;Wx86KnownNativeDll
01678                                 );
01679     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(st)) {
01680         <span class="keywordflow">goto</span> LWx86DllError;
01681         }
01682 
01683     <a class="code" href="../../d2/d7/string_8c.html#a6">RtlInitAnsiString</a> (&amp;ProcName,<span class="stringliteral">"Wx86KnownRedistDll"</span>);
01684     st = <a class="code" href="../../d4/d2/ldrapi_8c.html#a7">LdrGetProcedureAddress</a>(DllHandle,
01685                                 &amp;ProcName,
01686                                 0,
01687                                 (PVOID *)&amp;Wx86KnownRedistDll
01688                                 );
01689     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(st)) {
01690         <span class="keywordflow">goto</span> LWx86DllError;
01691         }
01692 
01693     <a class="code" href="../../d2/d7/string_8c.html#a6">RtlInitAnsiString</a> (&amp;ProcName,<span class="stringliteral">"RunWx86DllEntryPoint"</span>);
01694     st = <a class="code" href="../../d4/d2/ldrapi_8c.html#a7">LdrGetProcedureAddress</a>(DllHandle,
01695                                 &amp;ProcName,
01696                                 0,
01697                                 (PVOID *)&amp;Wx86DllEntryPoint
01698                                 );
01699     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(st)) {
01700         <span class="keywordflow">goto</span> LWx86DllError;
01701         }
01702 
01703     <a class="code" href="../../d2/d7/string_8c.html#a6">RtlInitAnsiString</a> (&amp;ProcName,<span class="stringliteral">"Wx86ThreadStartRoutine"</span>);
01704     st = <a class="code" href="../../d4/d2/ldrapi_8c.html#a7">LdrGetProcedureAddress</a>(DllHandle,
01705                                 &amp;ProcName,
01706                                 0,
01707                                 (PVOID *)&amp;Wx86ThreadStartRoutine
01708                                 );
01709     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(st)) {
01710         <span class="keywordflow">goto</span> LWx86DllError;
01711         }
01712 
01713     <a class="code" href="../../d2/d7/string_8c.html#a6">RtlInitAnsiString</a> (&amp;ProcName,<span class="stringliteral">"Wx86ProcessStartRoutine"</span>);
01714     st = <a class="code" href="../../d4/d2/ldrapi_8c.html#a7">LdrGetProcedureAddress</a>(DllHandle,
01715                                 &amp;ProcName,
01716                                 0,
01717                                 (PVOID *)&amp;Wx86ProcessStartRoutine
01718                                 );
01719     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(st)) {
01720         <span class="keywordflow">goto</span> LWx86DllError;
01721         }
01722 
01723     <a class="code" href="../../d2/d7/string_8c.html#a6">RtlInitAnsiString</a> (&amp;ProcName,<span class="stringliteral">"Wx86DllMapNotify"</span>);
01724     st = <a class="code" href="../../d4/d2/ldrapi_8c.html#a7">LdrGetProcedureAddress</a>(DllHandle,
01725                                 &amp;ProcName,
01726                                 0,
01727                                 (PVOID *)&amp;Wx86DllMapNotify
01728                                 );
01729     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(st)) {
01730         <span class="keywordflow">goto</span> LWx86DllError;
01731         }
01732 
01733 
01734     <a class="code" href="../../d2/d7/string_8c.html#a6">RtlInitAnsiString</a> (&amp;ProcName,<span class="stringliteral">"Wx86ProcessInit"</span>);
01735     st = <a class="code" href="../../d4/d2/ldrapi_8c.html#a7">LdrGetProcedureAddress</a>(DllHandle,
01736                                 &amp;ProcName,
01737                                 0,
01738                                 (PVOID *)&amp;Wx86ProcessInit
01739                                 );
01740     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(st)) {
01741         <span class="keywordflow">goto</span> LWx86DllError;
01742         }
01743 
01744 
01745     <span class="keywordflow">if</span> (Context) {
01746         st = LdrpInitWx86(NtCurrentTeb()-&gt;Vdm, Context, FALSE);
01747         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(st)) {
01748             <span class="keywordflow">goto</span> LWx86DllError;
01749             }
01750         }
01751     <span class="keywordflow">else</span> {
01752         Wx86OnTheFly=<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01753         }
01754 
01755 
01756 
01757     <span class="keywordflow">if</span> (!(*Wx86ProcessInit)(LoaderWx86Unload, Wx86OnTheFly)) {
01758         st = STATUS_ENTRYPOINT_NOT_FOUND;
01759         }
01760 
01761 
01762 LWx86DllError:
01763 
01764     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(st)) {
01765         <span class="comment">// If the load failed make sure we clean-up.</span>
01766         LoaderWx86Unload();
01767         }
01768 
01769     <span class="keywordflow">return</span> st;
01770 }
01771 
01772 
01773 
01774 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01775 LdrpInitWx86(
01776     PWX86TIB Wx86Tib,
01777     PCONTEXT Context,
01778     BOOLEAN NewThread
01779     )
01780 <span class="comment">/*++</span>
01781 <span class="comment"></span>
01782 <span class="comment">Routine Description:</span>
01783 <span class="comment"></span>
01784 <span class="comment">    Per thread wx86 specific initialization.</span>
01785 <span class="comment"></span>
01786 <span class="comment">Arguments:</span>
01787 <span class="comment"></span>
01788 <span class="comment">Return Value:</span>
01789 <span class="comment"></span>
01790 <span class="comment">    SUCCESS or reason</span>
01791 <span class="comment"></span>
01792 <span class="comment">--*/</span>
01793 {
01794     PTEB Teb;
01795     MEMORY_BASIC_INFORMATION MemBasicInfo;
01796 
01797     <span class="keywordflow">if</span> (Wx86Tib != Wx86CurrentTib()) {
01798         <span class="keywordflow">return</span> STATUS_APP_INIT_FAILURE;
01799         }
01800 
01801     <span class="keywordflow">if</span> (<a class="code" href="../../d9/d2/ldrp_8h.html#a30">ShowSnaps</a>) {
01802         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"LDRWX86: %x Pc %x Base %x Limit %x DeallocationStack %x\n"</span>,
01803                   Wx86Tib,
01804                   Wx86Tib-&gt;InitialPc,
01805                   Wx86Tib-&gt;StackBase,
01806                   Wx86Tib-&gt;StackLimit,
01807                   Wx86Tib-&gt;DeallocationStack
01808                   );
01809         }
01810 
01811 
01812     <span class="keywordflow">if</span> (Wx86Tib-&gt;EmulateInitialPc) {
01813         Wx86Tib-&gt;EmulateInitialPc = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01814 
01815         <span class="keywordflow">if</span> (NewThread) {
01816 
01817 <span class="preprocessor">#if defined(_MIPS_)</span>
01818 <span class="preprocessor"></span>            Context-&gt;XIntA0 = (LONG)Wx86ThreadStartRoutine;
01819 <span class="preprocessor">#elif defined(_ALPHA_)</span>
01820 <span class="preprocessor"></span>            Context-&gt;IntA0 = (ULONG_PTR)Wx86ThreadStartRoutine;
01821 <span class="preprocessor">#elif defined(_PPC_)</span>
01822 <span class="preprocessor"></span>            Context-&gt;Gpr3  = (ULONG)Wx86ThreadStartRoutine;
01823 <span class="preprocessor">#elif defined(_IA64_)</span>
01824 <span class="preprocessor"></span>            Context-&gt;IntS0 = Context-&gt;StIIP = (ULONG_PTR)Wx86ThreadStartRoutine;
01825 <span class="preprocessor">#else</span>
01826 <span class="preprocessor"></span><span class="preprocessor">#error Need to set instruction pointer to Wx86ThreadStartRoutine</span>
01827 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
01828 <span class="preprocessor"></span>            }
01829         <span class="keywordflow">else</span> {
01830 
01831 <span class="preprocessor">#if defined(_MIPS_)</span>
01832 <span class="preprocessor"></span>            Context-&gt;XIntA1 = (LONG)Wx86ProcessStartRoutine;
01833 <span class="preprocessor">#elif defined(_ALPHA_)</span>
01834 <span class="preprocessor"></span>            Context-&gt;IntA0 = (ULONG_PTR)Wx86ProcessStartRoutine;
01835 <span class="preprocessor">#elif defined(_PPC_)</span>
01836 <span class="preprocessor"></span>            Context-&gt;Gpr3  = (ULONG)Wx86ProcessStartRoutine;
01837 <span class="preprocessor">#elif defined(_IA64_)</span>
01838 <span class="preprocessor"></span>            Context-&gt;IntS0 = Context-&gt;StIIP = (ULONG_PTR)Wx86ProcessStartRoutine;
01839 <span class="preprocessor">#else</span>
01840 <span class="preprocessor"></span><span class="preprocessor">#error Need to set instruction pointer to Wx86ProcessStartRoutine</span>
01841 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
01842 <span class="preprocessor"></span>
01843             }
01844 
01845         }
01846 
01847 
01848     <span class="keywordflow">return</span> STATUS_SUCCESS;
01849 }
01850 <span class="preprocessor">#endif</span>
01851 <span class="preprocessor"></span>
01852 
01853 
01854 <span class="preprocessor">#if defined (_ALPHA_) || defined(BUILD_WOW6432)</span>
01855 <span class="preprocessor"></span>
01856 
01857    <span class="comment">// From mi\mi.h:</span>
01858 <span class="preprocessor">#define MI_ROUND_TO_SIZE(LENGTH,ALIGNMENT)     \</span>
01859 <span class="preprocessor">                    (((LENGTH) + ((ALIGNMENT) - 1)) &amp; ~((ALIGNMENT) - 1))</span>
01860 <span class="preprocessor"></span>
01861 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01862 Wx86SetRelocatedSharedProtection (
01863     IN PVOID Base,
01864     IN BOOLEAN Reset
01865     )
01866 
01867 <span class="comment">/*++</span>
01868 <span class="comment"></span>
01869 <span class="comment">Routine Description:</span>
01870 <span class="comment"></span>
01871 <span class="comment"></span>
01872 <span class="comment">    This function loops thru the images sections/objects, setting</span>
01873 <span class="comment">    all relocated shared sections/objects marked r/o to r/w. It also resets the</span>
01874 <span class="comment">    original section/object protections.</span>
01875 <span class="comment"></span>
01876 <span class="comment">Arguments:</span>
01877 <span class="comment"></span>
01878 <span class="comment">    Base - Base of image.</span>
01879 <span class="comment"></span>
01880 <span class="comment">    Reset - If TRUE, reset section/object protection to original</span>
01881 <span class="comment">            protection described by the section/object headers.</span>
01882 <span class="comment">            If FALSE, then set all sections/objects to r/w.</span>
01883 <span class="comment"></span>
01884 <span class="comment">Return Value:</span>
01885 <span class="comment"></span>
01886 <span class="comment">    SUCCESS or reason NtProtectVirtualMemory failed.</span>
01887 <span class="comment"></span>
01888 <span class="comment">--*/</span>
01889 
01890 {
01891     HANDLE CurrentProcessHandle;
01892     SIZE_T RegionSize;
01893     ULONG NewProtect, OldProtect;
01894     PVOID VirtualAddress;
01895     ULONG i;
01896     PIMAGE_NT_HEADERS NtHeaders;
01897     PIMAGE_SECTION_HEADER SectionHeader;
01898     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> st;
01899     ULONG NumberOfSharedDataPages;
01900     SIZE_T NumberOfNativePagesForImage;
01901 
01902     CurrentProcessHandle = NtCurrentProcess();
01903 
01904     NtHeaders = <a class="code" href="../../d8/d9/imagedir_8c.html#a0">RtlImageNtHeader</a>(Base);
01905 
01906     SectionHeader = (PIMAGE_SECTION_HEADER)((ULONG_PTR)NtHeaders + <span class="keyword">sizeof</span>(ULONG) +
01907                         <span class="keyword">sizeof</span>(IMAGE_FILE_HEADER) +
01908                         NtHeaders-&gt;FileHeader.SizeOfOptionalHeader
01909                         );
01910 
01911     NumberOfSharedDataPages = 0;
01912     NumberOfNativePagesForImage =
01913         <a class="code" href="../../d9/d2/ldrp_8h.html#a4">NATIVE_BYTES_TO_PAGES</a> (NtHeaders-&gt;OptionalHeader.SizeOfImage);
01914 
01915     <span class="keywordflow">for</span> (i=0; i&lt;NtHeaders-&gt;FileHeader.NumberOfSections; i++, SectionHeader++) {
01916         <span class="keywordflow">if</span> ((SectionHeader-&gt;Characteristics &amp; IMAGE_SCN_MEM_SHARED) &amp;&amp; 
01917             (!(SectionHeader-&gt;Characteristics &amp; IMAGE_SCN_MEM_EXECUTE) ||
01918              (SectionHeader-&gt;Characteristics &amp; IMAGE_SCN_MEM_WRITE))) {
01919             RegionSize = SectionHeader-&gt;SizeOfRawData;
01920             VirtualAddress = (PVOID)((ULONG_PTR)Base + 
01921                                     ((NumberOfNativePagesForImage + NumberOfSharedDataPages) &lt;&lt; <a class="code" href="../../d9/d2/ldrp_8h.html#a3">NATIVE_PAGE_SHIFT</a>));
01922             NumberOfNativePagesForImage +=  <a class="code" href="../../d4/d8/mi_8h.html#a90">MI_ROUND_TO_SIZE</a> (RegionSize, NATIVE_PAGE_SIZE) &gt;&gt; <a class="code" href="../../d9/d2/ldrp_8h.html#a3">NATIVE_PAGE_SHIFT</a>;
01923 
01924             <span class="keywordflow">if</span> (!(SectionHeader-&gt;Characteristics &amp; IMAGE_SCN_MEM_WRITE)) {
01925                 <span class="comment">//</span>
01926                 <span class="comment">// Object isn't writeable, so change it.</span>
01927                 <span class="comment">//</span>
01928                 <span class="keywordflow">if</span> (Reset) {
01929                     <span class="keywordflow">if</span> (SectionHeader-&gt;Characteristics &amp; IMAGE_SCN_MEM_EXECUTE) {
01930                         NewProtect = PAGE_EXECUTE;
01931                     } 
01932                     <span class="keywordflow">else</span> {
01933                         NewProtect = PAGE_READONLY;
01934                     }
01935                     NewProtect |= (SectionHeader-&gt;Characteristics &amp; IMAGE_SCN_MEM_NOT_CACHED) ? PAGE_NOCACHE : 0;
01936                 } 
01937                 <span class="keywordflow">else</span> {
01938                     NewProtect = PAGE_READWRITE;
01939                 }
01940 
01941                 st = <a class="code" href="../../d0/d9/protect_8c.html#a4">NtProtectVirtualMemory</a>(CurrentProcessHandle, &amp;VirtualAddress,
01942                                             &amp;RegionSize, NewProtect, &amp;OldProtect);
01943 
01944                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(st)) {
01945                     <span class="keywordflow">return</span> st;
01946                 }
01947             }
01948         }
01949     }
01950 
01951     <span class="keywordflow">if</span> (Reset) {
01952         <a class="code" href="../../d5/d5/flushbuf_8c.html#a2">NtFlushInstructionCache</a>(NtCurrentProcess(), NULL, 0);
01953     }
01954 
01955     <span class="keywordflow">return</span> STATUS_SUCCESS;
01956 }
01957 
01958 
01959 PIMAGE_BASE_RELOCATION LdrpWx86ProcessRelocationBlock(
01960     IN ULONG_PTR VA,
01961     IN PUCHAR ImageBase,
01962     IN ULONG SizeOfBlock,
01963     IN PUSHORT NextOffset,
01964     IN ULONG Diff,
01965     IN ULONG_PTR SectionStartVA,
01966     IN ULONG_PTR SectionEndVA);
01967 
01968 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> 
01969 FixupBlockList(
01970     IN PUCHAR ImageBase);
01971 
01972 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a> 
01973 FixupSectionHeader(
01974     IN PUCHAR ImageBase);
01975 
01976 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01977 LdrpWx86FormatVirtualImage(
01978     IN PIMAGE_NT_HEADERS32 NtHeaders,
01979     IN PVOID DllBase
01980     )
01981 {
01982    PIMAGE_SECTION_HEADER SectionTable, Section, LastSection, FirstSection;
01983    ULONG VirtualImageSize;
01984    PUCHAR NextVirtualAddress, SrcVirtualAddress, DestVirtualAddress;
01985    PUCHAR ImageBase= DllBase;
01986    LONG <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
01987    ULONG NumberOfSharedDataPages;
01988    ULONG NumberOfNativePagesForImage;
01989    ULONG NumberOfExtraPagesForImage;
01990    ULONG_PTR PreferredImageBase;
01991    BOOLEAN ImageHasRelocatedSharedSection = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01992    ULONG SubSectionSize;
01993 
01994    <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> st = Wx86SetRelocatedSharedProtection(DllBase, FALSE);
01995    <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(st)) {
01996        <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"Wx86SetRelocatedSharedProtection failed with return status %x\n"</span>, st);
01997        Wx86SetRelocatedSharedProtection(DllBase, TRUE);
01998        <span class="keywordflow">return</span> st;
01999    }
02000 
02001    <span class="comment">//</span>
02002    <span class="comment">// Copy each section from its raw file address to its virtual address</span>
02003    <span class="comment">//</span>
02004 
02005    SectionTable = IMAGE_FIRST_SECTION(NtHeaders);
02006    LastSection = SectionTable + NtHeaders-&gt;FileHeader.NumberOfSections;
02007 
02008    <span class="keywordflow">if</span> (SectionTable-&gt;PointerToRawData == SectionTable-&gt;VirtualAddress) {
02009        <span class="comment">// If the first section does not need to be moved then we exclude it</span>
02010        <span class="comment">// from condideration in passes 1 and 2</span>
02011        FirstSection = SectionTable + 1;
02012        }
02013    <span class="keywordflow">else</span> {
02014        FirstSection = SectionTable;
02015        }
02016 
02017    <span class="comment">//</span>
02018    <span class="comment">// First pass starts at the top and works down moving up each section that</span>
02019    <span class="comment">// is to be moved up.</span>
02020    <span class="comment">//</span>
02021    Section = FirstSection;
02022    <span class="keywordflow">while</span> (Section &lt; LastSection) {
02023        SrcVirtualAddress = ImageBase + Section-&gt;PointerToRawData;
02024        DestVirtualAddress = Section-&gt;VirtualAddress + ImageBase;
02025 
02026        <span class="keywordflow">if</span> (DestVirtualAddress &gt; SrcVirtualAddress) {
02027            <span class="comment">// Section needs to be moved down</span>
02028            <span class="keywordflow">break</span>;
02029            }
02030 
02031        <span class="comment">// Section needs to be moved up</span>
02032       <span class="keywordflow">if</span> (Section-&gt;SizeOfRawData != 0) {
02033           <span class="keywordflow">if</span> (Section-&gt;PointerToRawData != 0) {
02034               RtlMoveMemory(DestVirtualAddress,
02035                      SrcVirtualAddress,
02036                      Section-&gt;SizeOfRawData);
02037               }
02038           }
02039       <span class="keywordflow">else</span> {
02040           Section-&gt;PointerToRawData = 0;
02041           }
02042 
02043        Section++;
02044        }
02045 
02046    <span class="comment">//</span>
02047    <span class="comment">// Second pass is from the end of the image and work backwards since src and</span>
02048    <span class="comment">// dst overlap</span>
02049    <span class="comment">//</span>
02050    Section = --LastSection;
02051    NextVirtualAddress = ImageBase + NtHeaders-&gt;OptionalHeader.SizeOfImage;
02052 
02053    <span class="keywordflow">while</span> (Section &gt;= FirstSection) {
02054        SrcVirtualAddress = ImageBase + Section-&gt;PointerToRawData;
02055        DestVirtualAddress = Section-&gt;VirtualAddress + ImageBase;
02056 
02057        <span class="comment">//</span>
02058        <span class="comment">// Compute the subsection size.  The mm is really flexible here...</span>
02059        <span class="comment">// it will allow a SizeOfRawData that far exceeds the virtual size,</span>
02060        <span class="comment">// so we can't trust that.  If that happens, just use the page-aligned</span>
02061        <span class="comment">// virtual size, since that is all that the mm will map in.</span>
02062        <span class="comment">//</span>
02063        SubSectionSize = Section-&gt;SizeOfRawData;
02064        <span class="keywordflow">if</span> (Section-&gt;Misc.VirtualSize &amp;&amp;
02065            SubSectionSize &gt; <a class="code" href="../../d4/d8/mi_8h.html#a90">MI_ROUND_TO_SIZE</a>(Section-&gt;Misc.VirtualSize, PAGE_SIZE_X86)) {
02066           SubSectionSize = <a class="code" href="../../d4/d8/mi_8h.html#a90">MI_ROUND_TO_SIZE</a>(Section-&gt;Misc.VirtualSize, PAGE_SIZE_X86);
02067        }
02068 
02069       <span class="comment">//</span>
02070       <span class="comment">// ensure Virtual section doesn't overlap the next section</span>
02071       <span class="comment">//</span>
02072       <span class="keywordflow">if</span> (DestVirtualAddress + SubSectionSize &gt; NextVirtualAddress) {
02073           Wx86SetRelocatedSharedProtection(DllBase, TRUE);
02074           <span class="keywordflow">return</span> STATUS_INVALID_IMAGE_FORMAT;
02075           }
02076 
02077        <span class="keywordflow">if</span> (DestVirtualAddress &lt; SrcVirtualAddress) {
02078            <span class="comment">// Section needs to be moved up</span>
02079            <span class="keywordflow">break</span>;
02080            }
02081 
02082        <span class="comment">// Section needs to be moved down</span>
02083       <span class="keywordflow">if</span> (Section-&gt;SizeOfRawData != 0) {
02084           <span class="keywordflow">if</span> (Section-&gt;PointerToRawData != 0) {
02085               RtlMoveMemory(DestVirtualAddress,
02086                      SrcVirtualAddress,
02087                      SubSectionSize);
02088               }
02089           }
02090       <span class="keywordflow">else</span> {
02091           Section-&gt;PointerToRawData = 0;
02092           }
02093 
02094        NextVirtualAddress = DestVirtualAddress;
02095        Section--;
02096        }
02097 
02098    <span class="comment">//</span>
02099    <span class="comment">// Third pass is for zeroing out any memory left between the end of a</span>
02100    <span class="comment">// section and the end of the page. We'll do this from end to top</span>
02101    <span class="comment">//</span>
02102    Section = LastSection;
02103    NextVirtualAddress = ImageBase + NtHeaders-&gt;OptionalHeader.SizeOfImage;
02104 
02105    NumberOfSharedDataPages = 0;  
02106    <span class="keywordflow">while</span> (Section &gt;= SectionTable) {
02107        DestVirtualAddress = Section-&gt;VirtualAddress + ImageBase;
02108 
02109       <span class="comment">//</span>
02110       <span class="comment">// Shared Data sections cannot be shared, because of</span>
02111       <span class="comment">// page misalignment, and are treated as Exec- Copy on Write.</span>
02112       <span class="comment">//</span>
02113        <span class="keywordflow">if</span> ((Section-&gt;Characteristics &amp; IMAGE_SCN_MEM_SHARED) &amp;&amp; 
02114            (!(Section-&gt;Characteristics &amp; IMAGE_SCN_MEM_EXECUTE) ||
02115             (Section-&gt;Characteristics &amp; IMAGE_SCN_MEM_WRITE))) {
02116           ImageHasRelocatedSharedSection = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02117 <span class="preprocessor">#if 0</span>
02118 <span class="preprocessor"></span>          <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"Unsuported IMAGE_SCN_MEM_SHARED %x\n"</span>,
02119                    Section-&gt;Characteristics
02120                    );
02121 <span class="preprocessor">#endif</span>
02122 <span class="preprocessor"></span>      }
02123 
02124       <span class="comment">//</span>
02125       <span class="comment">// If section was empty zero it out</span>
02126       <span class="comment">//</span>
02127       <span class="keywordflow">if</span> (Section-&gt;SizeOfRawData != 0) {
02128           <span class="keywordflow">if</span> (Section-&gt;PointerToRawData == 0) {
02129               RtlZeroMemory(DestVirtualAddress,
02130                             Section-&gt;SizeOfRawData
02131                             );
02132               }
02133           }
02134 
02135       <span class="comment">//</span>
02136       <span class="comment">// Zero out remaining bytes up to the next section</span>
02137       <span class="comment">//</span>
02138       RtlZeroMemory(DestVirtualAddress + Section-&gt;SizeOfRawData,
02139                     (ULONG)(NextVirtualAddress - DestVirtualAddress - Section-&gt;SizeOfRawData)
02140                     );
02141 
02142        NextVirtualAddress = DestVirtualAddress;
02143        Section--;
02144        }
02145 
02146    <span class="comment">// Pass 4: if the dll has any shared sections, change the shared data</span>
02147    <span class="comment">// references to point to additional shared pages at the end of the image.</span>
02148    <span class="comment">//</span>
02149    <span class="comment">// Note that our fixups are applied assuming that the dll is loaded at</span>
02150    <span class="comment">// its preferred base; if it is loaded at some other address, it will</span>
02151    <span class="comment">// be relocated again along will al other addresses.</span>
02152 
02153 
02154    <span class="keywordflow">if</span> (!ImageHasRelocatedSharedSection) {
02155        <span class="keywordflow">goto</span> LdrwWx86FormatVirtualImageDone;
02156    }
02157 
02158    st = FixupBlockList(DllBase);   
02159    <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(st)) {
02160        Wx86SetRelocatedSharedProtection(DllBase, TRUE);
02161        <span class="keywordflow">return</span> st;
02162    }
02163 
02164    NumberOfNativePagesForImage =
02165         <a class="code" href="../../d9/d2/ldrp_8h.html#a4">NATIVE_BYTES_TO_PAGES</a> (NtHeaders-&gt;OptionalHeader.SizeOfImage);
02166    NumberOfExtraPagesForImage = 0;
02167 
02168    <span class="comment">// Account for raw data that extends beyond SizeOfImage</span>
02169 
02170    <span class="keywordflow">for</span> (Section = SectionTable; Section &lt;= LastSection; Section++)
02171    {
02172        ULONG EndOfSection;
02173        ULONG ExtraPages;
02174        
02175        EndOfSection = Section-&gt;PointerToRawData + Section-&gt;SizeOfRawData;
02176        
02177        <span class="keywordflow">if</span> (EndOfSection &gt; NtHeaders-&gt;OptionalHeader.SizeOfImage) {
02178            
02179            ExtraPages = <a class="code" href="../../d9/d2/ldrp_8h.html#a4">NATIVE_BYTES_TO_PAGES</a>(EndOfSection - NtHeaders-&gt;OptionalHeader.SizeOfImage);
02180            <span class="keywordflow">if</span> (ExtraPages &gt; NumberOfExtraPagesForImage) {
02181                NumberOfExtraPagesForImage = ExtraPages;
02182            }
02183        }
02184    }
02185 
02186    PreferredImageBase = NtHeaders-&gt;OptionalHeader.ImageBase;
02187 
02188    NumberOfNativePagesForImage += NumberOfExtraPagesForImage;
02189    NumberOfSharedDataPages = 0;
02190    <span class="keywordflow">for</span> (Section = SectionTable; Section &lt;= LastSection; Section++)
02191    {
02192         ULONG bFirst = 1;
02193 
02194         <span class="keywordflow">if</span> ((Section-&gt;Characteristics &amp; IMAGE_SCN_MEM_SHARED) &amp;&amp; 
02195             (!(Section-&gt;Characteristics &amp; IMAGE_SCN_MEM_EXECUTE) ||
02196              (Section-&gt;Characteristics &amp; IMAGE_SCN_MEM_WRITE))) 
02197         {
02198             PIMAGE_BASE_RELOCATION NextBlock;
02199             <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a> NextOffset;
02200             ULONG TotalBytes;
02201             ULONG SizeOfBlock;
02202             ULONG_PTR VA;
02203             ULONG_PTR SectionStartVA;
02204             ULONG_PTR SectionEndVA;
02205             ULONG SectionVirtualSize;
02206             ULONG Diff;
02207 
02208             SectionVirtualSize = Section-&gt;Misc.VirtualSize;
02209             <span class="keywordflow">if</span> (SectionVirtualSize == 0)
02210             {
02211                 SectionVirtualSize = Section-&gt;SizeOfRawData;
02212             }
02213 
02214             SectionStartVA = PreferredImageBase + Section-&gt;VirtualAddress;
02215             SectionEndVA = SectionStartVA + SectionVirtualSize;
02216 
02217 
02218             NextBlock = <a class="code" href="../../d8/d9/imagedir_8c.html#a5">RtlImageDirectoryEntryToData</a>(DllBase, TRUE,
02219                                         IMAGE_DIRECTORY_ENTRY_BASERELOC,
02220                                         &amp;TotalBytes);
02221             <span class="keywordflow">if</span> (!NextBlock || !TotalBytes)
02222             {
02223                 <span class="comment">// Note that if this fails, it should fail in the very</span>
02224                 <span class="comment">// first iteration and no fixups would have been performed</span>
02225 
02226                 <span class="keywordflow">if</span> (!bFirst)
02227                 {
02228                     <span class="comment">// Trouble</span>
02229                     <span class="keywordflow">if</span> (<a class="code" href="../../d9/d2/ldrp_8h.html#a30">ShowSnaps</a>)
02230                     {
02231                         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"LdrpWx86FormatVirtualImage: failure "</span>
02232                         <span class="stringliteral">"after relocating some sections for image at %x\n"</span>,
02233                                 DllBase);
02234                     }
02235                     Wx86SetRelocatedSharedProtection(DllBase, TRUE);
02236                     <span class="keywordflow">return</span> STATUS_INVALID_IMAGE_FORMAT;
02237                 }
02238 
02239                 <span class="keywordflow">if</span> (<a class="code" href="../../d9/d2/ldrp_8h.html#a30">ShowSnaps</a>)
02240                 {
02241                     <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"LdrpWx86FormatVirtualImage: No fixup info "</span>
02242                                 <span class="stringliteral">"for image at %x; private sections will be "</span>
02243                                 <span class="stringliteral">"used for shared data sections.\n"</span>,
02244                             DllBase);
02245                 }
02246                 <span class="keywordflow">break</span>;
02247             }
02248 
02249             bFirst = 0;
02250 
02251             Diff = (NumberOfNativePagesForImage +
02252                                 NumberOfSharedDataPages) &lt;&lt; <a class="code" href="../../d9/d2/ldrp_8h.html#a3">NATIVE_PAGE_SHIFT</a>;
02253             Diff -= (ULONG) (SectionStartVA - PreferredImageBase);
02254 
02255             <span class="keywordflow">if</span> (<a class="code" href="../../d9/d2/ldrp_8h.html#a30">ShowSnaps</a>)
02256             {
02257                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"LdrpWx86FormatVirtualImage: Relocating shared "</span>
02258                          <span class="stringliteral">"data for shared data section 0x%x of image "</span>
02259                          <span class="stringliteral">"at %x by 0x%lx bytes\n"</span>,
02260                          Section - SectionTable + 1, DllBase, Diff);
02261             }
02262 
02263             <span class="keywordflow">while</span> (TotalBytes)
02264             {
02265                 SizeOfBlock = NextBlock-&gt;SizeOfBlock;
02266                 TotalBytes -= SizeOfBlock;
02267                 SizeOfBlock -= <span class="keyword">sizeof</span>(IMAGE_BASE_RELOCATION);
02268                 SizeOfBlock /= <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>);
02269                 NextOffset = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>) ((PCHAR)NextBlock +
02270                                         <span class="keyword">sizeof</span>(IMAGE_BASE_RELOCATION));
02271                 VA = (ULONG_PTR) DllBase + NextBlock-&gt;VirtualAddress;
02272 
02273                 NextBlock = LdrpWx86ProcessRelocationBlock(VA, DllBase, SizeOfBlock,
02274                                                         NextOffset,
02275                                                         Diff,
02276                                                         SectionStartVA,
02277                                                         SectionEndVA);
02278                 <span class="keywordflow">if</span> (NextBlock == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)
02279                 {
02280                     <span class="comment">// Trouble</span>
02281                     <span class="keywordflow">if</span> (<a class="code" href="../../d9/d2/ldrp_8h.html#a30">ShowSnaps</a>)
02282                     {
02283                         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"LdrpWx86FormatVirtualImage: failure "</span>
02284                         <span class="stringliteral">"after relocating some sections for image at %x; "</span>
02285                         <span class="stringliteral">"Relocation information invalid\n"</span>,
02286                                 DllBase);
02287                     }
02288                     Wx86SetRelocatedSharedProtection(DllBase, TRUE);
02289                     <span class="keywordflow">return</span> STATUS_INVALID_IMAGE_FORMAT;
02290                 }
02291             }
02292             NumberOfSharedDataPages += <a class="code" href="../../d4/d8/mi_8h.html#a90">MI_ROUND_TO_SIZE</a> (SectionVirtualSize,
02293                                                         NATIVE_PAGE_SIZE) &gt;&gt;
02294                                                         <a class="code" href="../../d9/d2/ldrp_8h.html#a3">NATIVE_PAGE_SHIFT</a>;
02295 
02296         }
02297    }
02298 
02299 LdrwWx86FormatVirtualImageDone:
02300    <span class="comment">//</span>
02301    <span class="comment">// Zero out first section's Raw Data up to its VirtualAddress</span>
02302    <span class="comment">//</span>
02303    <span class="keywordflow">if</span> (SectionTable-&gt;PointerToRawData != 0) {
02304        DestVirtualAddress = SectionTable-&gt;PointerToRawData + ImageBase;
02305        <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> = (LONG)(NextVirtualAddress - DestVirtualAddress);
02306        <span class="keywordflow">if</span> (<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> &gt; 0) {
02307            RtlZeroMemory(DestVirtualAddress,
02308                      (ULONG)Size
02309                      );
02310            }
02311    }
02312 
02313    Wx86SetRelocatedSharedProtection(DllBase, TRUE);
02314    <span class="keywordflow">return</span> STATUS_SUCCESS;
02315 
02316 }
02317 
02318 
02320 
02321 ULONG
02322 LdrpWx86RelocatedFixupDiff(
02323     IN PUCHAR ImageBase,
02324     IN ULONG  Offset
02325     )
02326 {
02327    PIMAGE_SECTION_HEADER SectionHeader;
02328    ULONG i;
02329    ULONG NumberOfSharedDataPages;
02330    ULONG NumberOfNativePagesForImage;
02331    PIMAGE_NT_HEADERS32 NtHeaders = (PIMAGE_NT_HEADERS32)<a class="code" href="../../d8/d9/imagedir_8c.html#a0">RtlImageNtHeader</a>(ImageBase);
02332    ULONG Diff = 0;
02333    ULONG_PTR FixupAddr = (ULONG_PTR)(ImageBase + <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>);
02334 
02335    SectionHeader = (PIMAGE_SECTION_HEADER)((ULONG_PTR)NtHeaders + <span class="keyword">sizeof</span>(ULONG) +
02336                     <span class="keyword">sizeof</span>(IMAGE_FILE_HEADER) +
02337                     NtHeaders-&gt;FileHeader.SizeOfOptionalHeader
02338                     );
02339 
02340    NumberOfNativePagesForImage =
02341         <a class="code" href="../../d9/d2/ldrp_8h.html#a4">NATIVE_BYTES_TO_PAGES</a> (NtHeaders-&gt;OptionalHeader.SizeOfImage);
02342    NumberOfSharedDataPages = 0;
02343 
02344    <span class="keywordflow">for</span> (i=0; i&lt;NtHeaders-&gt;FileHeader.NumberOfSections; i++, SectionHeader++) 
02345    {
02346        ULONG_PTR SectionStartVA;
02347        ULONG_PTR SectionEndVA;
02348        ULONG SectionVirtualSize;
02349 
02350        SectionVirtualSize = SectionHeader-&gt;Misc.VirtualSize;
02351        <span class="keywordflow">if</span> (SectionVirtualSize == 0) {
02352            SectionVirtualSize = SectionHeader-&gt;SizeOfRawData;
02353        }
02354 
02355        SectionStartVA = (ULONG_PTR)ImageBase + SectionHeader-&gt;VirtualAddress;
02356        SectionEndVA = SectionStartVA + SectionVirtualSize;
02357 
02358        <span class="keywordflow">if</span> (((ULONG_PTR)FixupAddr &gt;= SectionStartVA) &amp;&amp; ((ULONG_PTR)FixupAddr &lt;= SectionEndVA)) {
02359            <span class="keywordflow">if</span> ((SectionHeader-&gt;Characteristics &amp; IMAGE_SCN_MEM_SHARED) &amp;&amp; 
02360                (!(SectionHeader-&gt;Characteristics &amp; IMAGE_SCN_MEM_EXECUTE) ||
02361                 (SectionHeader-&gt;Characteristics &amp; IMAGE_SCN_MEM_WRITE))) {
02362                Diff = (NumberOfNativePagesForImage +
02363                        NumberOfSharedDataPages) &lt;&lt; <a class="code" href="../../d9/d2/ldrp_8h.html#a3">NATIVE_PAGE_SHIFT</a>;
02364                Diff -= (ULONG)SectionHeader-&gt;VirtualAddress;
02365            }
02366            <span class="keywordflow">break</span>;
02367        }
02368  
02369        <span class="keywordflow">if</span> ((SectionHeader-&gt;Characteristics &amp; IMAGE_SCN_MEM_SHARED) &amp;&amp; 
02370            (!(SectionHeader-&gt;Characteristics &amp; IMAGE_SCN_MEM_EXECUTE) ||
02371             (SectionHeader-&gt;Characteristics &amp; IMAGE_SCN_MEM_WRITE))) {
02372            NumberOfSharedDataPages += <a class="code" href="../../d4/d8/mi_8h.html#a90">MI_ROUND_TO_SIZE</a> (SectionVirtualSize,
02373                                                         NATIVE_PAGE_SIZE) &gt;&gt;
02374                                                         <a class="code" href="../../d9/d2/ldrp_8h.html#a3">NATIVE_PAGE_SHIFT</a>;
02375        }
02376    }
02377 
02378    <span class="keywordflow">return</span> Diff;
02379 }
02380 
02381 
02382 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> 
02383 FixupBlockList(
02384     IN PUCHAR ImageBase)
02385 {
02386    PIMAGE_BASE_RELOCATION NextBlock;
02387    <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a> NextOffset;
02388    ULONG TotalBytes;
02389    ULONG SizeOfBlock;
02390 
02391    <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> st;
02392 
02393    NextBlock = <a class="code" href="../../d8/d9/imagedir_8c.html#a5">RtlImageDirectoryEntryToData</a>(ImageBase, TRUE,
02394                                             IMAGE_DIRECTORY_ENTRY_BASERELOC,
02395                                             &amp;TotalBytes);
02396 
02397    <span class="keywordflow">if</span> (!NextBlock || !TotalBytes) {
02398        <span class="keywordflow">if</span> (<a class="code" href="../../d9/d2/ldrp_8h.html#a30">ShowSnaps</a>) {
02399            <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"LdrpWx86FixupBlockList: No fixup info "</span>
02400                     <span class="stringliteral">"for image at %x; private sections will be "</span>
02401                     <span class="stringliteral">"used for shared data sections.\n"</span>,
02402                     ImageBase);
02403        }
02404        <span class="keywordflow">return</span> STATUS_SUCCESS;
02405    }
02406 
02407 
02408    <span class="keywordflow">while</span> (TotalBytes) {
02409        SizeOfBlock = NextBlock-&gt;SizeOfBlock;
02410        TotalBytes -= SizeOfBlock;
02411        SizeOfBlock -= <span class="keyword">sizeof</span>(IMAGE_BASE_RELOCATION);
02412        SizeOfBlock /= <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>);
02413        NextOffset = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>) ((PCHAR)NextBlock +
02414                                <span class="keyword">sizeof</span>(IMAGE_BASE_RELOCATION));
02415        
02416        NextBlock-&gt;VirtualAddress += LdrpWx86RelocatedFixupDiff(ImageBase, NextBlock-&gt;VirtualAddress);
02417 
02418        <span class="keywordflow">while</span> (SizeOfBlock--) {
02419            <span class="keywordflow">switch</span> ((*NextOffset) &gt;&gt; 12) {
02420                <span class="keywordflow">case</span> IMAGE_REL_BASED_HIGHLOW :
02421                <span class="keywordflow">case</span> IMAGE_REL_BASED_HIGH :
02422                <span class="keywordflow">case</span> IMAGE_REL_BASED_LOW :
02423                    <span class="keywordflow">break</span>;
02424 
02425                <span class="keywordflow">case</span> IMAGE_REL_BASED_HIGHADJ :
02426                    ++NextOffset;
02427                    --SizeOfBlock;
02428                    <span class="keywordflow">break</span>;
02429 
02430                <span class="keywordflow">case</span> IMAGE_REL_BASED_IA64_IMM64:
02431                <span class="keywordflow">case</span> IMAGE_REL_BASED_DIR64:
02432                <span class="keywordflow">case</span> IMAGE_REL_BASED_MIPS_JMPADDR :
02433                <span class="keywordflow">case</span> IMAGE_REL_BASED_ABSOLUTE :
02434                <span class="keywordflow">case</span> IMAGE_REL_BASED_SECTION :
02435                <span class="keywordflow">case</span> IMAGE_REL_BASED_REL32 :
02436                    <span class="keywordflow">break</span>;
02437 
02438                <span class="keywordflow">case</span> IMAGE_REL_BASED_HIGH3ADJ :
02439                    ++NextOffset;
02440                    --SizeOfBlock;
02441                    ++NextOffset;
02442                    --SizeOfBlock;
02443                    <span class="keywordflow">break</span>;
02444 
02445                <span class="keywordflow">default</span> :
02446                    <span class="keywordflow">return</span> STATUS_INVALID_IMAGE_FORMAT;
02447            }
02448            ++NextOffset;
02449        }
02450 
02451        NextBlock = (PIMAGE_BASE_RELOCATION)NextOffset;
02452 
02453        <span class="keywordflow">if</span> (NextBlock == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02454            <span class="comment">// Trouble</span>
02455            <span class="keywordflow">if</span> (<a class="code" href="../../d9/d2/ldrp_8h.html#a30">ShowSnaps</a>) {
02456                <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"LdrpWx86FixupBlockList: failure "</span>
02457                         <span class="stringliteral">"after relocating some sections for image at %x; "</span>
02458                         <span class="stringliteral">"Relocation information invalid\n"</span>,
02459                         ImageBase);
02460            }
02461            <span class="keywordflow">return</span> STATUS_INVALID_IMAGE_FORMAT;
02462       }
02463    }
02464 
02465    <span class="keywordflow">return</span> STATUS_SUCCESS;
02466 }
02467 
02468 
02469 BOOLEAN
02470 LdrpWx86DllHasRelocatedSharedSection(
02471     IN PUCHAR ImageBase)
02472 {
02473    PIMAGE_SECTION_HEADER SectionHeader;
02474    ULONG i;
02475    PIMAGE_NT_HEADERS32 NtHeaders = (PIMAGE_NT_HEADERS32)<a class="code" href="../../d8/d9/imagedir_8c.html#a0">RtlImageNtHeader</a>(ImageBase);
02476 
02477    SectionHeader = (PIMAGE_SECTION_HEADER)((ULONG_PTR)NtHeaders + <span class="keyword">sizeof</span>(ULONG) +
02478                     <span class="keyword">sizeof</span>(IMAGE_FILE_HEADER) +
02479                     NtHeaders-&gt;FileHeader.SizeOfOptionalHeader
02480                     );
02481 
02482    <span class="keywordflow">for</span> (i=0; i&lt;NtHeaders-&gt;FileHeader.NumberOfSections; i++, SectionHeader++) 
02483    {
02484        <span class="keywordflow">if</span> ((SectionHeader-&gt;Characteristics &amp; IMAGE_SCN_MEM_SHARED) &amp;&amp; 
02485            (!(SectionHeader-&gt;Characteristics &amp; IMAGE_SCN_MEM_EXECUTE) ||
02486             (SectionHeader-&gt;Characteristics &amp; IMAGE_SCN_MEM_WRITE))) {
02487            <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02488        }
02489    }
02490 
02491    <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02492 }
02493 
02494 
02496 
02497 <span class="comment">// Following fn is adapted from rtl\ldrreloc.c; it should be updated when</span>
02498 <span class="comment">// that function changes. Eliminated 64 bit address relocations.</span>
02499 <span class="comment">//</span>
02500 <span class="comment">// Note: Instead of calling this routine, we could call</span>
02501 <span class="comment">//     LdrpProcessRelocationBlock(VA, 1, NextOffset, Diff)</span>
02502 <span class="comment">//</span>
02503 <span class="comment">// but we should do that only if the address to be relocated is between</span>
02504 <span class="comment">// SectionStartVA and SectionEndVA. So we would have to replicate all the</span>
02505 <span class="comment">// code in the switch stmt below that computes the address of the data item -</span>
02506 <span class="comment">// which is pretty much the entire function. So we chose to replicate the</span>
02507 <span class="comment">// function as it was and change it to make the test.</span>
02508 
02509 PIMAGE_BASE_RELOCATION LdrpWx86ProcessRelocationBlock(
02510     IN ULONG_PTR VA,
02511     IN PUCHAR ImageBase,
02512     IN ULONG SizeOfBlock,
02513     IN PUSHORT NextOffset,
02514     IN ULONG Diff,
02515     IN ULONG_PTR SectionStartVA,
02516     IN ULONG_PTR SectionEndVA)
02517 {
02518     PUCHAR FixupVA;
02519     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>;
02520     LONG Temp;
02521     ULONG_PTR DataVA;
02522 
02523 
02524     <span class="keywordflow">while</span> (SizeOfBlock--) {
02525 
02526        <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> = *NextOffset &amp; (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)0xfff;
02527        FixupVA = (PUCHAR)(VA + <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>);
02528        <span class="comment">//</span>
02529        <span class="comment">// Apply the fixups.</span>
02530        <span class="comment">//</span>
02531 
02532        <span class="keywordflow">switch</span> ((*NextOffset) &gt;&gt; 12) {
02533 
02534             <span class="keywordflow">case</span> IMAGE_REL_BASED_HIGHLOW :
02535                 <span class="comment">//</span>
02536                 <span class="comment">// HighLow - (32-bits) relocate the high and low half</span>
02537                 <span class="comment">//      of an address.</span>
02538                 <span class="comment">//</span>
02539                 Temp = *(LONG UNALIGNED *)FixupVA;
02540                 DataVA = (ULONG_PTR) Temp;
02541                 <span class="keywordflow">if</span> (DataVA &gt;= SectionStartVA &amp;&amp; DataVA &lt;= SectionEndVA)
02542                 {
02543                     Temp += (ULONG) Diff;
02544                     *(LONG UNALIGNED *)FixupVA = Temp;
02545                 }
02546 
02547                 <span class="keywordflow">break</span>;
02548 
02549             <span class="keywordflow">case</span> IMAGE_REL_BASED_HIGH :
02550                 <span class="comment">//</span>
02551                 <span class="comment">// High - (16-bits) relocate the high half of an address.</span>
02552                 <span class="comment">//</span>
02553                 Temp = *(<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>)FixupVA &lt;&lt; 16;
02554                 DataVA = (ULONG_PTR) Temp;
02555                 <span class="keywordflow">if</span> (DataVA &gt;= SectionStartVA &amp;&amp; DataVA &lt;= SectionEndVA)
02556                 {
02557                     Temp += (ULONG) Diff;
02558                     *(<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>)FixupVA = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(Temp &gt;&gt; 16);
02559                 }
02560                 <span class="keywordflow">break</span>;
02561 
02562             <span class="keywordflow">case</span> IMAGE_REL_BASED_HIGHADJ :
02563                 <span class="comment">//</span>
02564                 <span class="comment">// Adjust high - (16-bits) relocate the high half of an</span>
02565                 <span class="comment">//      address and adjust for sign extension of low half.</span>
02566                 <span class="comment">//</span>
02567                 Temp = *(<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>)FixupVA &lt;&lt; 16;
02568                 ++NextOffset;
02569                 --SizeOfBlock;
02570                 Temp += (LONG)(*(<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a21">PSHORT</a>)NextOffset);
02571                 DataVA = (ULONG_PTR) Temp;
02572                 <span class="keywordflow">if</span> (DataVA &gt;= SectionStartVA &amp;&amp; DataVA &lt;= SectionEndVA)
02573                 {
02574                     Temp += (ULONG) Diff;
02575                     Temp += 0x8000;
02576                     *(<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>)FixupVA = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(Temp &gt;&gt; 16);
02577                 }
02578                 <span class="keywordflow">break</span>;
02579 
02580             <span class="keywordflow">case</span> IMAGE_REL_BASED_LOW :
02581                 <span class="comment">//</span>
02582                 <span class="comment">// Low - (16-bit) relocate the low half of an address.</span>
02583                 <span class="comment">//</span>
02584                 Temp = *(<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a21">PSHORT</a>)FixupVA;
02585                 DataVA = (ULONG_PTR) Temp;
02586                 <span class="keywordflow">if</span> (DataVA &gt;= SectionStartVA &amp;&amp; DataVA &lt;= SectionEndVA)
02587                 {
02588                     Temp += (ULONG) Diff;
02589                     *(<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>)FixupVA = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)Temp;
02590                 }
02591                 <span class="keywordflow">break</span>;
02592 
02593             <span class="keywordflow">case</span> IMAGE_REL_BASED_IA64_IMM64:
02594 
02595                 <span class="comment">//</span>
02596                 <span class="comment">// Align it to bundle address before fixing up the</span>
02597                 <span class="comment">// 64-bit immediate value of the movl instruction.</span>
02598                 <span class="comment">//</span>
02599 
02600                 <span class="comment">// No need to support</span>
02601 
02602                 <span class="keywordflow">break</span>;
02603 
02604             <span class="keywordflow">case</span> IMAGE_REL_BASED_DIR64:
02605 
02606                 <span class="comment">//</span>
02607                 <span class="comment">// Update 32-bit address</span>
02608                 <span class="comment">//</span>
02609 
02610                 <span class="comment">// No need to support</span>
02611 
02612                 <span class="keywordflow">break</span>;
02613 
02614             <span class="keywordflow">case</span> IMAGE_REL_BASED_MIPS_JMPADDR :
02615                 <span class="comment">//</span>
02616                 <span class="comment">// JumpAddress - (32-bits) relocate a MIPS jump address.</span>
02617                 <span class="comment">//</span>
02618 
02619                 <span class="comment">// No need to support</span>
02620                 <span class="keywordflow">break</span>;
02621 
02622             <span class="keywordflow">case</span> IMAGE_REL_BASED_ABSOLUTE :
02623                 <span class="comment">//</span>
02624                 <span class="comment">// Absolute - no fixup required.</span>
02625                 <span class="comment">//</span>
02626                 <span class="keywordflow">break</span>;
02627 
02628             <span class="keywordflow">case</span> IMAGE_REL_BASED_SECTION :
02629                 <span class="comment">//</span>
02630                 <span class="comment">// Section Relative reloc.  Ignore for now.</span>
02631                 <span class="comment">//</span>
02632                 <span class="keywordflow">break</span>;
02633 
02634             <span class="keywordflow">case</span> IMAGE_REL_BASED_REL32 :
02635                 <span class="comment">//</span>
02636                 <span class="comment">// Relative intrasection. Ignore for now.</span>
02637                 <span class="comment">//</span>
02638                 <span class="keywordflow">break</span>;
02639 
02640            <span class="keywordflow">case</span> IMAGE_REL_BASED_HIGH3ADJ :
02641                <span class="comment">//</span>
02642                <span class="comment">// Similar to HIGHADJ except this is the third word.</span>
02643                <span class="comment">//  Adjust low half of high dword of an address and adjust for</span>
02644                <span class="comment">//   sign extension of the low dword.</span>
02645                <span class="comment">//</span>
02646 
02647                <span class="comment">// No need to support</span>
02648                 ++NextOffset;
02649                 --SizeOfBlock;
02650                 ++NextOffset;
02651                 --SizeOfBlock;
02652 
02653                <span class="keywordflow">break</span>;
02654 
02655             <span class="keywordflow">default</span> :
02656                 <span class="comment">//</span>
02657                 <span class="comment">// Illegal - illegal relocation type.</span>
02658                 <span class="comment">//</span>
02659 
02660                 <span class="keywordflow">return</span> (PIMAGE_BASE_RELOCATION)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02661        }
02662        ++NextOffset;
02663     }
02664     <span class="keywordflow">return</span> (PIMAGE_BASE_RELOCATION)NextOffset;
02665 }
02666 
02667 <span class="preprocessor">#endif  // ALPHA or BUILD_WOW6432</span>
02668 <span class="preprocessor"></span>
02669 <span class="preprocessor">#if defined (_ALPHA_) &amp;&amp; defined (WX86)</span>
02670 <span class="preprocessor"></span><a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
02671 Wx86IdentifyPlugin(
02672     IN PVOID DllBase,
02673     IN PUNICODE_STRING FullDllName
02674     )
02675 <span class="comment">/*++</span>
02676 <span class="comment"></span>
02677 <span class="comment">Routine Description:</span>
02678 <span class="comment"></span>
02679 <span class="comment">    Determine which (if any) plugin provider dlls support this plugin.</span>
02680 <span class="comment"></span>
02681 <span class="comment">    All registered plugin provider dlls are loaded sequentially and given</span>
02682 <span class="comment">    an opportunity to examine the the plugin dll. Provider dlls that support</span>
02683 <span class="comment">    the plugin are stored in a WX86PLUGIN object and linked into Wx86PluginList.</span>
02684 <span class="comment"></span>
02685 <span class="comment">    Note: This routine may be invoked before Wx86 has been loaded so the</span>
02686 <span class="comment">    global values initialized by LdrpLoadWx86 cannot be used.</span>
02687 <span class="comment"></span>
02688 <span class="comment">Return Value:</span>
02689 <span class="comment"></span>
02690 <span class="comment">    STATUS_SUCCESS - The dll is supported by at least one plugin provider.</span>
02691 <span class="comment"></span>
02692 <span class="comment">    STATUS_IMAGE_MACHINE_TYPE_MISMATCH - There are no plugin providers that support this dll.</span>
02693 <span class="comment"></span>
02694 <span class="comment">    Other - failure in Wx86IdentifyPlugIn</span>
02695 <span class="comment">--*/</span>
02696 {
02697     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> st;
02698     PVOID Provider[WX86PLUGIN_MAXPROVIDER];
02699     ULONG <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a>;
02700     ULONG Length;
02701     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
02702     ULONG NumProviders;
02703     ULONG Disposition;
02704     HANDLE hProviderKey = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02705     HANDLE hProviderIdKey = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02706     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> ProviderLength;
02707     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> MachineType;
02708     BOOLEAN CanThunk;
02709     UNICODE_STRING <a class="code" href="../../d8/d0/rtbatcr_8c.html#a3">KeyName</a>;
02710     UNICODE_STRING DllName;
02711     UNICODE_STRING ProviderName;
02712     ANSI_STRING ProcName;
02713     OBJECT_ATTRIBUTES Obja;
02714     PKEY_VALUE_PARTIAL_INFORMATION ValPartInfo;
02715     PKEY_FULL_INFORMATION KeyFullInfo;
02716     PKEY_BASIC_INFORMATION KeyBasicInfo;
02717     WCHAR ProviderPath[DOS_MAX_PATH_LENGTH];
02718     WCHAR DataBuffer[STATIC_UNICODE_BUFFER_LENGTH];
02719     WX86IDENTIFYPLUGIN IdentifyPlugin = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02720     PIMAGE_NT_HEADERS NtHeaders;
02721 
02722     NtHeaders = <a class="code" href="../../d8/d9/imagedir_8c.html#a0">RtlImageNtHeader</a>(DllBase);
02723     <span class="keywordflow">if</span> (NtHeaders == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02724         <span class="keywordflow">return</span> STATUS_INVALID_IMAGE_FORMAT;
02725     }
02726     MachineType = NtHeaders-&gt;FileHeader.Machine;
02727 
02728     <span class="comment">// Identify the plugin by trying each plugin provider in turn.</span>
02729     <span class="comment">// The absence of the Provider registry key is a switch to turn off plugin support.</span>
02730 
02731     <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> = 0;
02732     <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a> ( &amp;KeyName, L<span class="stringliteral">"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Wx86\\Provider"</span> );
02733     InitializeObjectAttributes (&amp;Obja, &amp;KeyName, OBJ_CASE_INSENSITIVE, NULL, NULL );
02734     st = <a class="code" href="../../d7/d7/ntapi_8c.html#a23">NtOpenKey</a> (&amp;hProviderKey, KEY_READ | KEY_WRITE, &amp;Obja);
02735     <span class="keywordflow">if</span> (st == STATUS_OBJECT_NAME_NOT_FOUND) {
02736         st = STATUS_IMAGE_MACHINE_TYPE_MISMATCH;
02737         <span class="keywordflow">goto</span> Wx86IdentifyDone;
02738     }
02739     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a3">NT_ERROR</a>(st)) {
02740         <span class="keywordflow">goto</span> Wx86IdentifyDone;
02741     }
02742 
02743     ValPartInfo = (PKEY_VALUE_PARTIAL_INFORMATION)DataBuffer;
02744     KeyFullInfo = (PKEY_FULL_INFORMATION)DataBuffer;
02745     st = <a class="code" href="../../d7/d7/ntapi_8c.html#a24">NtQueryKey</a>(hProviderKey,
02746                     KeyFullInformation,
02747                     KeyFullInfo,
02748                     <span class="keyword">sizeof</span>(DataBuffer),
02749                     &amp;Length
02750                     );
02751     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a3">NT_ERROR</a>(st)) {
02752         <span class="keywordflow">goto</span> Wx86IdentifyDone;
02753     }
02754 
02755     NumProviders = KeyFullInfo-&gt;SubKeys;
02756 
02757     <span class="comment">// Initialize the base path of the provider dlls</span>
02758 
02759     ProviderName.Buffer = ProviderPath;
02760     ProviderName.MaximumLength = <span class="keyword">sizeof</span>(ProviderPath);
02761     ProviderName.Length = 0;
02762     <a class="code" href="../../d6/d6/nls_8c.html#a45">RtlAppendUnicodeToString</a>(&amp;ProviderName, USER_SHARED_DATA-&gt;NtSystemRoot );
02763     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(st)) {
02764         st = <a class="code" href="../../d6/d6/nls_8c.html#a45">RtlAppendUnicodeToString</a>(&amp;ProviderName, Wx86Dir);
02765     }
02766     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(st)) {
02767         st = <a class="code" href="../../d6/d6/nls_8c.html#a45">RtlAppendUnicodeToString</a>( &amp;ProviderName, L<span class="stringliteral">"\\Provider\\"</span>);
02768     }
02769     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a3">NT_ERROR</a>(st)) {
02770         <span class="keywordflow">goto</span> Wx86IdentifyDone;
02771     }
02772     ProviderLength = ProviderName.Length;
02773 
02774     <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = 0;
02775     st = STATUS_SUCCESS;
02776     KeyBasicInfo = (PKEY_BASIC_INFORMATION)DataBuffer;
02777     <span class="keywordflow">do</span> {
02778         st = <a class="code" href="../../d7/d7/ntapi_8c.html#a17">NtEnumerateKey</a>( hProviderKey, Index, KeyBasicInformation, DataBuffer, <span class="keyword">sizeof</span>(DataBuffer)-2, &amp;Length );
02779         <span class="keywordflow">if</span> (st == STATUS_NO_MORE_ENTRIES) {
02780             st = STATUS_SUCCESS;
02781             <span class="keywordflow">break</span>;
02782         }
02783         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a3">NT_ERROR</a>(st)) {
02784             <span class="keywordflow">goto</span> Wx86IdentifyDone;
02785         }
02786 
02787         <span class="comment">// Get the name of the next plugin provider dll</span>
02788 
02789         KeyBasicInfo-&gt;Name[KeyBasicInfo-&gt;NameLength/2] = UNICODE_NULL;
02790         <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>( &amp;KeyName, KeyBasicInfo-&gt;Name );
02791         InitializeObjectAttributes (&amp;Obja, &amp;KeyName, OBJ_CASE_INSENSITIVE, hProviderKey, NULL );
02792         st = <a class="code" href="../../d7/d7/ntapi_8c.html#a23">NtOpenKey</a> (&amp;hProviderIdKey, KEY_READ, &amp;Obja);
02793         <span class="keywordflow">if</span> (st == STATUS_OBJECT_NAME_NOT_FOUND) {
02794             <span class="keywordflow">goto</span> Wx86IdentifyDone;
02795         }
02796 
02797         <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a> ( &amp;KeyName, L<span class="stringliteral">"DllName"</span> );
02798         st = <a class="code" href="../../d7/d7/ntapi_8c.html#a25">NtQueryValueKey</a>( hProviderIdKey, &amp;KeyName, KeyValuePartialInformation, DataBuffer, <span class="keyword">sizeof</span>(DataBuffer)-2, &amp;Length );
02799         <span class="keywordflow">if</span> (st == STATUS_SUCCESS) {
02800 
02801             <span class="comment">// Get the full provider dll path by appending the name to the base provider path</span>
02802 
02803             *(PWCHAR)(&amp;ValPartInfo-&gt;Data[ValPartInfo-&gt;DataLength]) = UNICODE_NULL;
02804             ProviderName.Length = ProviderLength;
02805             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(st)) {
02806                 st = <a class="code" href="../../d6/d6/nls_8c.html#a45">RtlAppendUnicodeToString</a>( &amp;ProviderName, (PWSTR)ValPartInfo-&gt;Data);
02807             }
02808             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a3">NT_ERROR</a>(st)) {
02809                 <span class="keywordflow">goto</span> Wx86IdentifyDone;
02810             }
02811 
02812             <span class="comment">// Get the name of an export this provider requires (if any). If the plugin dll doesn't</span>
02813             <span class="comment">// have this export then it's not possible for this provider to support it. This</span>
02814             <span class="comment">// is a quick check which excludes most false tests for plug providers.</span>
02815 
02816             <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a> ( &amp;KeyName, L<span class="stringliteral">"Export"</span> );
02817             st = <a class="code" href="../../d7/d7/ntapi_8c.html#a25">NtQueryValueKey</a>( hProviderIdKey, &amp;KeyName, KeyValuePartialInformation, DataBuffer, <span class="keyword">sizeof</span>(DataBuffer)-2, &amp;Length );
02818             <span class="keywordflow">if</span> (st == STATUS_SUCCESS) {
02819                 ANSI_STRING ExportName;
02820                 UNICODE_STRING UnicodeExportName;
02821                 PVOID ExportAddress;
02822                 <a class="code" href="../../d1/d1/bench_8c.html#a16">CHAR</a> ExportNameBuffer[64];
02823 
02824                 ExportName.Buffer = ExportNameBuffer;
02825                 ExportName.MaximumLength = <span class="keyword">sizeof</span>(ExportNameBuffer);
02826                 ExportName.Length = 0;
02827 
02828                 *(PWCHAR)(&amp;ValPartInfo-&gt;Data[ValPartInfo-&gt;DataLength]) = UNICODE_NULL;
02829                 <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>( &amp;UnicodeExportName, (PWCHAR)(ValPartInfo-&gt;Data) );
02830                 st = <a class="code" href="../../d6/d6/nls_8c.html#a23">RtlUnicodeStringToAnsiString</a>( &amp;ExportName, &amp;UnicodeExportName, FALSE );
02831                 <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a3">NT_ERROR</a>(st)) {
02832                     <span class="keywordflow">goto</span> Wx86IdentifyDone;
02833                 }
02834                 st = <a class="code" href="../../d4/d2/ldrapi_8c.html#a7">LdrGetProcedureAddress</a>( DllBase, &amp;ExportName, 0, &amp;ExportAddress );
02835                 <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a3">NT_ERROR</a>(st)) {
02836                     st = STATUS_IMAGE_MACHINE_TYPE_MISMATCH;
02837                     <span class="keywordflow">continue</span>;
02838                 }
02839             }
02840 
02841             <span class="comment">// The required export exists so it's time to load the provider and do the full check</span>
02842             <span class="comment">// On error skip to the next provider</span>
02843 
02844             st = <a class="code" href="../../d9/d2/ldrp_8h.html#a82">LdrpLoadDll</a>( NULL, NULL, &amp;ProviderName, &amp;Provider[Count], TRUE );
02845 
02846             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(st)) {
02847                 <a class="code" href="../../d2/d7/string_8c.html#a6">RtlInitAnsiString</a>(&amp;ProcName,<span class="stringliteral">"Wx86IdentifyPlugin"</span>);
02848                 st = <a class="code" href="../../d4/d2/ldrapi_8c.html#a7">LdrGetProcedureAddress</a>( Provider[Count], &amp;ProcName, 0, (PVOID *)&amp;IdentifyPlugin);
02849                 CanThunk = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02850                 <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(st) &amp;&amp; IdentifyPlugin) {
02851                     <span class="keywordflow">try</span> {
02852                         CanThunk = IdentifyPlugin(DllBase,
02853                                                   FullDllName-&gt;Buffer,
02854                                                   MachineType == IMAGE_FILE_MACHINE_I386
02855                                                   );
02856                     } except(EXCEPTION_EXECUTE_HANDLER) {
02857                     }
02858                 }
02859 
02860                 <span class="keywordflow">if</span> (CanThunk) {
02861                     <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a>++;
02862                 } <span class="keywordflow">else</span> {
02863                     <a class="code" href="../../d4/d2/ldrapi_8c.html#a6">LdrUnloadDll</a>( Provider[Count] );
02864                     Provider[<a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a>] = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02865                 }
02866             } <span class="comment">// loaded provder dll</span>
02867         }  <span class="comment">// opened provider key</span>
02868     } <span class="keywordflow">while</span> ((++<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &lt; NumProviders) &amp;&amp; (<a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> &lt; WX86PLUGIN_MAXPROVIDER));
02869 
02870     <span class="comment">// Return success if we found at least on plugin provider. Allocate a WX86PLUGIN</span>
02871     <span class="comment">// list entry to keep track of which provders were loaded for this plugin</span>
02872 
02873     <span class="keywordflow">if</span> (<a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a>) {
02874         PWX86PLUGIN Wx86Plugin;
02875 
02876         Wx86Plugin = <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a0">RtlAllocateHeap</a>(RtlProcessHeap(),<a class="code" href="../../d9/d2/ldrp_8h.html#a11">MAKE_TAG</a>( LDR_TAG ),<span class="keyword">sizeof</span>(WX86PLUGIN));
02877         <span class="keywordflow">if</span> ( !Wx86Plugin ) {
02878             st = STATUS_NO_MEMORY;
02879             <span class="keywordflow">goto</span> Wx86IdentifyDone;
02880             }
02881         Wx86Plugin-&gt;DllBase = DllBase;
02882         Wx86Plugin-&gt;Count = <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a>;
02883         RtlMoveMemory( Wx86Plugin-&gt;Provider, Provider, Count*<span class="keyword">sizeof</span>(PVOID) );
02884         InsertTailList( &amp;Wx86PluginList, &amp;Wx86Plugin-&gt;Links );
02885 
02886         st = STATUS_SUCCESS;
02887     } <span class="keywordflow">else</span> {
02888         st = STATUS_IMAGE_MACHINE_TYPE_MISMATCH;
02889     }
02890     st = <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a>? STATUS_SUCCESS : STATUS_IMAGE_MACHINE_TYPE_MISMATCH;
02891 
02892 Wx86IdentifyDone:
02893 
02894     <span class="comment">// On error exit release any provider dlls that were loaded</span>
02895 
02896     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a3">NT_ERROR</a>(st)) {
02897         <span class="keywordflow">for</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = 0; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &lt; <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a>; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>++) {
02898             <a class="code" href="../../d4/d2/ldrapi_8c.html#a6">LdrUnloadDll</a>( Provider[Count] );
02899         }
02900     }
02901 
02902     <span class="keywordflow">if</span> (hProviderKey) {
02903         <a class="code" href="../../d5/d0/obclose_8c.html#a1">NtClose</a>(hProviderKey);
02904     }
02905     <span class="keywordflow">if</span> (hProviderIdKey) {
02906         <a class="code" href="../../d5/d0/obclose_8c.html#a1">NtClose</a>(hProviderIdKey);
02907     }
02908 
02909     <span class="keywordflow">return</span> st;
02910 }
02911 
02912 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
02913 Wx86ThunkPluginExport(
02914     IN PVOID DllBase,
02915     IN PCHAR ExportName,
02916     IN ULONG Ordinal,
02917     IN PVOID ExportAddress,
02918     OUT PVOID *ExportThunk
02919     )
02920 <span class="comment">/*++</span>
02921 <span class="comment"></span>
02922 <span class="comment">Routine Description:</span>
02923 <span class="comment"></span>
02924 <span class="comment">    This procedure is called during GetProcAddress() processing when</span>
02925 <span class="comment">    the request if for a cross-architecure procedure address in an</span>
02926 <span class="comment">    image which was loaded as a plugin dll (LDRP_WX86_PLUGIN flag).</span>
02927 <span class="comment"></span>
02928 <span class="comment">    The providers associated with this plugin dll are called in order</span>
02929 <span class="comment">    to provide a thunk for the specified plugin export. The thunk attempt</span>
02930 <span class="comment">    stops when a provider successfully thunks the export.</span>
02931 <span class="comment"></span>
02932 <span class="comment">Return Value:</span>
02933 <span class="comment"></span>
02934 <span class="comment">    STATUS_SUCCESS - if export is successfully thunked</span>
02935 <span class="comment"></span>
02936 <span class="comment">    STATUS_PROCEDURE_NOT_FOUND - if export cannot be thunked</span>
02937 <span class="comment"></span>
02938 <span class="comment">    STATUS_INVALID_IMAGE_FORMAT - DllBase is invalid</span>
02939 <span class="comment"></span>
02940 <span class="comment">--*/</span>
02941 {
02942     PLIST_ENTRY Head, Next;
02943     PWX86PLUGIN Wx86Plugin;
02944     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
02945     WX86THUNKEXPORT ThunkExport;
02946     ANSI_STRING ProcName;
02947     PIMAGE_NT_HEADERS NtHeaders;
02948     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> MachineType;
02949     BOOLEAN Thunked;
02950     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> st;
02951 
02952     NtHeaders = <a class="code" href="../../d8/d9/imagedir_8c.html#a0">RtlImageNtHeader</a>(DllBase);
02953     <span class="keywordflow">if</span> (NtHeaders == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02954         <span class="keywordflow">return</span> STATUS_INVALID_IMAGE_FORMAT;
02955     }
02956     MachineType = NtHeaders-&gt;FileHeader.Machine;
02957 
02958     <span class="comment">// Find the Wx86Plugin entry with a matching DllBase</span>
02959 
02960     Head = &amp;Wx86PluginList;
02961     Next = Head-&gt;Flink;
02962     <span class="keywordflow">while</span> ( Next != Head ) {
02963         Wx86Plugin = CONTAINING_RECORD(Next, WX86PLUGIN, Links);
02964         <span class="keywordflow">if</span> (Wx86Plugin-&gt;DllBase == DllBase) {
02965             <span class="keywordflow">break</span>;
02966         }
02967         Next = Next-&gt;Flink;
02968     }
02969 
02970     <span class="comment">// No Wx86Plugin entry for this Dll</span>
02971 
02972     <span class="keywordflow">if</span> (Next == Head) {
02973         <span class="keywordflow">return</span> STATUS_PROCEDURE_NOT_FOUND;
02974     }
02975 
02976     <span class="comment">// Get the address of the routine to thunk exports for each provider</span>
02977 
02978     <a class="code" href="../../d2/d7/string_8c.html#a6">RtlInitAnsiString</a>(&amp;ProcName,<span class="stringliteral">"Wx86ThunkExport"</span>);
02979     <span class="keywordflow">for</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = 0; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &lt; Wx86Plugin-&gt;Count; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>++) {
02980         st = <a class="code" href="../../d4/d2/ldrapi_8c.html#a7">LdrGetProcedureAddress</a>(Wx86Plugin-&gt;Provider[Index],
02981                                     &amp;ProcName,
02982                                     0,
02983                                     (PVOID *)&amp;ThunkExport
02984                                     );
02985         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(st) &amp;&amp; ThunkExport != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02986             <span class="keywordflow">try</span> {
02987                 Thunked = ThunkExport(DllBase,
02988                                       ExportName,
02989                                       Ordinal,
02990                                       ExportAddress,
02991                                       ExportThunk,
02992                                       MachineType == IMAGE_FILE_MACHINE_I386
02993                                       );
02994             } except (EXCEPTION_EXECUTE_HANDLER) {
02995                 Thunked = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02996             }
02997 
02998             <span class="keywordflow">if</span> (Thunked) {
02999                 <span class="keywordflow">if</span> (<a class="code" href="../../d9/d2/ldrp_8h.html#a30">ShowSnaps</a>) {
03000                     <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"LDRWx86: thunk export for %08X Ord=%04X Addr=%08X Name=%s Thunk=%08X\n"</span>,
03001                              DllBase, Ordinal, ExportAddress,
03002                              ExportName? ExportName : <span class="stringliteral">"&lt;noname&gt;"</span>, *ExportThunk );
03003                 <span class="keywordflow">break</span>;
03004                 }
03005             }
03006         }
03007     }
03008 
03009     <span class="keywordflow">return</span> st;
03010 }
03011 
03012 BOOLEAN
03013 Wx86UnloadProviders(
03014     IN PVOID DllBase
03015     )
03016 <span class="comment">/*++</span>
03017 <span class="comment"></span>
03018 <span class="comment">Routine Description:</span>
03019 <span class="comment"></span>
03020 <span class="comment">    Handle unloading of plugin dlls.</span>
03021 <span class="comment"></span>
03022 <span class="comment">    The DllBase passed in may have already been unloaded. However, it is used here</span>
03023 <span class="comment">    only to find the associated plugin provider dll.</span>
03024 <span class="comment"></span>
03025 <span class="comment">Return Value:</span>
03026 <span class="comment"></span>
03027 <span class="comment">    FALSE on failure, TRUE on success.</span>
03028 <span class="comment"></span>
03029 <span class="comment">--*/</span>
03030 {
03031     PLDR_DATA_TABLE_ENTRY PluginEntry;
03032     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
03033     PLIST_ENTRY Head, Next;
03034     PWX86PLUGIN Wx86Plugin;
03035     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
03036 
03037     <span class="comment">// Prevent recursion - Only perform this at the top level.</span>
03038     <span class="comment">// This is relevant when being called from LdrUnloadDll</span>
03039 
03040     <span class="keywordflow">if</span> (Wx86ProviderUnloadCount == 0) {
03041         <span class="keywordflow">try</span> {
03042             Wx86ProviderUnloadCount++;
03043 
03044             <span class="comment">// Find the the entry for this plugin dll</span>
03045 
03046     Head = &amp;Wx86PluginList;
03047     Next = Head-&gt;Flink;
03048     <span class="keywordflow">while</span> ( Next != Head ) {
03049         Wx86Plugin = CONTAINING_RECORD(Next, WX86PLUGIN, Links);
03050                 <span class="keywordflow">if</span> (Wx86Plugin-&gt;DllBase == DllBase) {
03051                     
03052                     <span class="comment">// If the plugin dll is no longer mapped then unload the providers</span>
03053                     <span class="comment">// and free the Wx86PluginList entry</span>
03054 
03055                     <span class="keywordflow">if</span> (!<a class="code" href="../../d2/d3/ldrsnap_8c.html#a45">LdrpCheckForLoadedDllHandle</a>( DllBase, &amp;PluginEntry )) {
03056             <span class="keywordflow">for</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = 0; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &lt; Wx86Plugin-&gt;Count; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>++) {
03057                             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d4/d2/ldrapi_8c.html#a6">LdrUnloadDll</a>( Wx86Plugin-&gt;Provider[Index] );
03058             }
03059             RemoveEntryList( &amp;Wx86Plugin-&gt;Links );
03060             <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>(RtlProcessHeap(), 0, Wx86Plugin );
03061                         <span class="keywordflow">break</span>;
03062                     }
03063                 }
03064         Next = Next-&gt;Flink;
03065             }
03066         } finally {
03067             Wx86ProviderUnloadCount--;
03068         }
03069     }
03070     
03071     <span class="keywordflow">return</span> <a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(Status);
03072 }
03073 
03074 <span class="preprocessor">#endif</span>
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:40:38 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
