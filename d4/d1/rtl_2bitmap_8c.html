<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: rtl/bitmap.c File Reference</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>bitmap.c File Reference</h1><code>#include "<a class="el" href="../../d6/d8/ntrtlp_8h-source.html">ntrtlp.h</a>"</code><br>

<p>
<a href="../../d5/d0/rtl_2bitmap_8c-source.html">Go to the source code of this file.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d1/rtl_2bitmap_8c.html#a0">RightShiftUlong</a>(E1, E2)&nbsp;&nbsp;&nbsp;((E2) &lt; 32 ? (E1) &gt;&gt; (E2) : 0)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d1/rtl_2bitmap_8c.html#a1">LeftShiftUlong</a>(E1, E2)&nbsp;&nbsp;&nbsp;((E2) &lt; 32 ? (E1) &lt;&lt; (E2) : 0)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d1/rtl_2bitmap_8c.html#a2">GET_BYTE_DECLARATIONS</a>()&nbsp;&nbsp;&nbsp;PUCHAR _CURRENT_POSITION;</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d1/rtl_2bitmap_8c.html#a3">GET_BYTE_INITIALIZATION</a>(RTL_BITMAP, BYTE_INDEX)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d1/rtl_2bitmap_8c.html#a4">GET_BYTE</a>(THIS_BYTE)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d1/rtl_2bitmap_8c.html#a5">BM_4567</a>&nbsp;&nbsp;&nbsp;0xFFFFFFFF00000000UI64</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d1/rtl_2bitmap_8c.html#a6">BM_67</a>&nbsp;&nbsp;&nbsp;0xFFFF000000000000UI64</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d1/rtl_2bitmap_8c.html#a7">BM_7</a>&nbsp;&nbsp;&nbsp;0xFF00000000000000UI64</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d1/rtl_2bitmap_8c.html#a8">BM_5</a>&nbsp;&nbsp;&nbsp;0x0000FF0000000000UI64</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d1/rtl_2bitmap_8c.html#a9">BM_23</a>&nbsp;&nbsp;&nbsp;0x00000000FFFF0000UI64</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d1/rtl_2bitmap_8c.html#a10">BM_3</a>&nbsp;&nbsp;&nbsp;0x00000000FF000000UI64</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d1/rtl_2bitmap_8c.html#a11">BM_1</a>&nbsp;&nbsp;&nbsp;0x000000000000FF00UI64</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d1/rtl_2bitmap_8c.html#a12">BM_0123</a>&nbsp;&nbsp;&nbsp;0x00000000FFFFFFFFUI64</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d1/rtl_2bitmap_8c.html#a13">BM_01</a>&nbsp;&nbsp;&nbsp;0x000000000000FFFFUI64</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d1/rtl_2bitmap_8c.html#a14">BM_0</a>&nbsp;&nbsp;&nbsp;0x00000000000000FFUI64</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d1/rtl_2bitmap_8c.html#a15">BM_2</a>&nbsp;&nbsp;&nbsp;0x0000000000FF0000UI64</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d1/rtl_2bitmap_8c.html#a16">BM_45</a>&nbsp;&nbsp;&nbsp;0x0000FFFF00000000UI64</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d1/rtl_2bitmap_8c.html#a17">BM_4</a>&nbsp;&nbsp;&nbsp;0x000000FF00000000UI64</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d1/rtl_2bitmap_8c.html#a18">BM_6</a>&nbsp;&nbsp;&nbsp;0x00FF000000000000UI64</td></tr>

<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d1/rtl_2bitmap_8c.html#a26">RtlInitializeBitMap</a> (IN PRTL_BITMAP <a class="el" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>, IN PULONG BitMapBuffer, IN ULONG SizeOfBitMap)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d1/rtl_2bitmap_8c.html#a27">RtlClearAllBits</a> (IN PRTL_BITMAP <a class="el" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d1/rtl_2bitmap_8c.html#a28">RtlSetAllBits</a> (IN PRTL_BITMAP <a class="el" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>ULONG&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d1/rtl_2bitmap_8c.html#a29">RtlFindClearBits</a> (IN PRTL_BITMAP <a class="el" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>, IN ULONG NumberToFind, IN ULONG HintIndex)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>ULONG&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d1/rtl_2bitmap_8c.html#a30">RtlFindSetBits</a> (IN PRTL_BITMAP <a class="el" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>, IN ULONG NumberToFind, IN ULONG HintIndex)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>ULONG&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d1/rtl_2bitmap_8c.html#a31">RtlFindClearBitsAndSet</a> (IN PRTL_BITMAP <a class="el" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>, IN ULONG NumberToFind, IN ULONG HintIndex)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>ULONG&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d1/rtl_2bitmap_8c.html#a32">RtlFindSetBitsAndClear</a> (IN PRTL_BITMAP <a class="el" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>, IN ULONG NumberToFind, IN ULONG HintIndex)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d1/rtl_2bitmap_8c.html#a33">RtlClearBits</a> (IN PRTL_BITMAP <a class="el" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>, IN ULONG StartingIndex, IN ULONG NumberToClear)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d1/rtl_2bitmap_8c.html#a34">RtlSetBits</a> (IN PRTL_BITMAP <a class="el" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>, IN ULONG StartingIndex, IN ULONG NumberToSet)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>ULONG&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d1/rtl_2bitmap_8c.html#a35">RtlFindClearRuns</a> (IN PRTL_BITMAP <a class="el" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>, PRTL_BITMAP_RUN RunArray, ULONG SizeOfRunArray, BOOLEAN LocateLongestRuns)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>ULONG&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d1/rtl_2bitmap_8c.html#a36">RtlFindLongestRunClear</a> (IN PRTL_BITMAP <a class="el" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>, OUT PULONG StartingIndex)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>ULONG&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d1/rtl_2bitmap_8c.html#a37">RtlFindFirstRunClear</a> (IN PRTL_BITMAP <a class="el" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>, OUT PULONG StartingIndex)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>ULONG&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d1/rtl_2bitmap_8c.html#a38">RtlNumberOfClearBits</a> (IN PRTL_BITMAP <a class="el" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>ULONG&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d1/rtl_2bitmap_8c.html#a39">RtlNumberOfSetBits</a> (IN PRTL_BITMAP <a class="el" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d1/rtl_2bitmap_8c.html#a40">RtlAreBitsClear</a> (IN PRTL_BITMAP <a class="el" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>, IN ULONG StartingIndex, IN ULONG Length)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d1/rtl_2bitmap_8c.html#a41">RtlAreBitsSet</a> (IN PRTL_BITMAP <a class="el" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>, IN ULONG StartingIndex, IN ULONG Length)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>ULONG&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d1/rtl_2bitmap_8c.html#a42">RtlFindNextForwardRunClear</a> (IN PRTL_BITMAP <a class="el" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>, IN ULONG FromIndex, IN PULONG StartingRunIndex)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>ULONG&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d1/rtl_2bitmap_8c.html#a43">RtlFindLastBackwardRunClear</a> (IN PRTL_BITMAP <a class="el" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>, IN ULONG FromIndex, IN PULONG StartingRunIndex)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>CCHAR&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d1/rtl_2bitmap_8c.html#a44">RtlFindMostSignificantBit</a> (IN ULONGLONG Set)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>CCHAR&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d1/rtl_2bitmap_8c.html#a45">RtlFindLeastSignificantBit</a> (IN ULONGLONG Set)</td></tr>

<tr><td colspan=2><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>CONST CCHAR&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d1/rtl_2bitmap_8c.html#a19">RtlpBitsClearAnywhere</a> []</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>CONST CCHAR&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d1/rtl_2bitmap_8c.html#a20">RtlpBitsClearLow</a> []</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>CONST CCHAR&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d1/rtl_2bitmap_8c.html#a21">RtlpBitsClearHigh</a> []</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>CONST CCHAR&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d1/rtl_2bitmap_8c.html#a22">RtlpBitsClearTotal</a> []</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>CONST UCHAR&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d1/rtl_2bitmap_8c.html#a23">FillMask</a> [] = { 0x00, 0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x7F, 0xFF }</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>CONST UCHAR&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d1/rtl_2bitmap_8c.html#a24">ZeroMask</a> [] = { 0xFF, 0xFE, 0xFC, 0xF8, 0xf0, 0xe0, 0xc0, 0x80, 0x00 }</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>CONST ULONG&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d1/rtl_2bitmap_8c.html#a25">FillMaskUlong</a> []</td></tr>

</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="a14" doxytag="rtl/bitmap.c::BM_0" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define BM_0&nbsp;&nbsp;&nbsp;0x00000000000000FFUI64          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02916">2916</a> of file <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html">rtl/bitmap.c</a>.
<p>
Referenced by <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02999">RtlFindLeastSignificantBit()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a13" doxytag="rtl/bitmap.c::BM_01" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define BM_01&nbsp;&nbsp;&nbsp;0x000000000000FFFFUI64          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02915">2915</a> of file <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html">rtl/bitmap.c</a>.
<p>
Referenced by <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02999">RtlFindLeastSignificantBit()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a12" doxytag="rtl/bitmap.c::BM_0123" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define BM_0123&nbsp;&nbsp;&nbsp;0x00000000FFFFFFFFUI64          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02914">2914</a> of file <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html">rtl/bitmap.c</a>.
<p>
Referenced by <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02999">RtlFindLeastSignificantBit()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a11" doxytag="rtl/bitmap.c::BM_1" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define BM_1&nbsp;&nbsp;&nbsp;0x000000000000FF00UI64          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02912">2912</a> of file <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html">rtl/bitmap.c</a>.
<p>
Referenced by <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02923">RtlFindMostSignificantBit()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a15" doxytag="rtl/bitmap.c::BM_2" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define BM_2&nbsp;&nbsp;&nbsp;0x0000000000FF0000UI64          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02917">2917</a> of file <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html">rtl/bitmap.c</a>.
<p>
Referenced by <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02999">RtlFindLeastSignificantBit()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a9" doxytag="rtl/bitmap.c::BM_23" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define BM_23&nbsp;&nbsp;&nbsp;0x00000000FFFF0000UI64          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02910">2910</a> of file <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html">rtl/bitmap.c</a>.
<p>
Referenced by <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02923">RtlFindMostSignificantBit()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a10" doxytag="rtl/bitmap.c::BM_3" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define BM_3&nbsp;&nbsp;&nbsp;0x00000000FF000000UI64          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02911">2911</a> of file <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html">rtl/bitmap.c</a>.
<p>
Referenced by <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02923">RtlFindMostSignificantBit()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a17" doxytag="rtl/bitmap.c::BM_4" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define BM_4&nbsp;&nbsp;&nbsp;0x000000FF00000000UI64          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02919">2919</a> of file <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html">rtl/bitmap.c</a>.
<p>
Referenced by <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02999">RtlFindLeastSignificantBit()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a16" doxytag="rtl/bitmap.c::BM_45" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define BM_45&nbsp;&nbsp;&nbsp;0x0000FFFF00000000UI64          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02918">2918</a> of file <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html">rtl/bitmap.c</a>.
<p>
Referenced by <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02999">RtlFindLeastSignificantBit()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="rtl/bitmap.c::BM_4567" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define BM_4567&nbsp;&nbsp;&nbsp;0xFFFFFFFF00000000UI64          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02906">2906</a> of file <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html">rtl/bitmap.c</a>.
<p>
Referenced by <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02923">RtlFindMostSignificantBit()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a8" doxytag="rtl/bitmap.c::BM_5" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define BM_5&nbsp;&nbsp;&nbsp;0x0000FF0000000000UI64          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02909">2909</a> of file <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html">rtl/bitmap.c</a>.
<p>
Referenced by <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02923">RtlFindMostSignificantBit()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a18" doxytag="rtl/bitmap.c::BM_6" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define BM_6&nbsp;&nbsp;&nbsp;0x00FF000000000000UI64          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02920">2920</a> of file <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html">rtl/bitmap.c</a>.
<p>
Referenced by <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02999">RtlFindLeastSignificantBit()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="rtl/bitmap.c::BM_67" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define BM_67&nbsp;&nbsp;&nbsp;0xFFFF000000000000UI64          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02907">2907</a> of file <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html">rtl/bitmap.c</a>.
<p>
Referenced by <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02923">RtlFindMostSignificantBit()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a7" doxytag="rtl/bitmap.c::BM_7" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define BM_7&nbsp;&nbsp;&nbsp;0xFF00000000000000UI64          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02908">2908</a> of file <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html">rtl/bitmap.c</a>.
<p>
Referenced by <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02923">RtlFindMostSignificantBit()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="rtl/bitmap.c::GET_BYTE" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define GET_BYTE          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">THIS_BYTE&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><pre class="fragment"><div>(         \
    THIS_BYTE = *(_CURRENT_POSITION++) \
)
</div></pre>
<p>
Definition at line <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00112">112</a> of file <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html">rtl/bitmap.c</a>.
<p>
Referenced by <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02305">RtlAreBitsClear()</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02464">RtlAreBitsSet()</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00345">RtlFindClearBits()</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l01764">RtlFindClearRuns()</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00866">RtlFindSetBits()</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02149">RtlNumberOfClearBits()</a>, and <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02227">RtlNumberOfSetBits()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a2" doxytag="rtl/bitmap.c::GET_BYTE_DECLARATIONS" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define GET_BYTE_DECLARATIONS          </td>
          <td class="md" valign="top">(&nbsp;</td>
&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;PUCHAR _CURRENT_POSITION;</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00105">105</a> of file <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html">rtl/bitmap.c</a>.
<p>
Referenced by <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02305">RtlAreBitsClear()</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02464">RtlAreBitsSet()</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00345">RtlFindClearBits()</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l01764">RtlFindClearRuns()</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00866">RtlFindSetBits()</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02149">RtlNumberOfClearBits()</a>, and <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02227">RtlNumberOfSetBits()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="rtl/bitmap.c::GET_BYTE_INITIALIZATION" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define GET_BYTE_INITIALIZATION          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RTL_BITMAP,         <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>BYTE_INDEX&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><pre class="fragment"><div>{               \
    _CURRENT_POSITION = &amp;((PUCHAR)((RTL_BITMAP)-&gt;Buffer))[BYTE_INDEX]; \
}
</div></pre>
<p>
Definition at line <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00108">108</a> of file <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html">rtl/bitmap.c</a>.
<p>
Referenced by <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02305">RtlAreBitsClear()</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02464">RtlAreBitsSet()</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00345">RtlFindClearBits()</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l01764">RtlFindClearRuns()</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00866">RtlFindSetBits()</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02149">RtlNumberOfClearBits()</a>, and <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02227">RtlNumberOfSetBits()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a1" doxytag="rtl/bitmap.c::LeftShiftUlong" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define LeftShiftUlong          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">E1,         <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>E2&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;((E2) &lt; 32 ? (E1) &lt;&lt; (E2) : 0)</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00037">37</a> of file <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html">rtl/bitmap.c</a>.
<p>
Referenced by <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l01508">RtlClearBits()</a>, and <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l01634">RtlSetBits()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a0" doxytag="rtl/bitmap.c::RightShiftUlong" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define RightShiftUlong          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">E1,         <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>E2&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;((E2) &lt; 32 ? (E1) &gt;&gt; (E2) : 0)</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00036">36</a> of file <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html">rtl/bitmap.c</a>.
<p>
Referenced by <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l01508">RtlClearBits()</a>, and <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l01634">RtlSetBits()</a>.    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a40" doxytag="rtl/bitmap.c::RtlAreBitsClear" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> BOOLEAN RtlAreBitsClear           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PRTL_BITMAP&nbsp;</td>
          <td class="mdname" nowrap> <em>BitMapHeader</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>StartingIndex</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Length</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02305">2305</a> of file <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html">rtl/bitmap.c</a>.
<p>
References <a class="el" href="../../d9/d8/tbitmap_8c-source.html#l00027">BitMapHeader</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00213">FillMask</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00112">GET_BYTE</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00105">GET_BYTE_DECLARATIONS</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00108">GET_BYTE_INITIALIZATION</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, and <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00215">ZeroMask</a>.
<p>
Referenced by <a class="el" href="../../d2/d2/cmsysini_8c-source.html#l00726">CmpInitializeHiveList()</a>, <a class="el" href="../../d9/d8/tbitmap_8c-source.html#l00031">main()</a>, and <a class="el" href="../../d7/d2/modwrite_8c-source.html#l01940">MiAttemptPageFileReduction()</a>.
<p>
<pre class="fragment"><div>02313                    :
02314 
02315     This <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a69">procedure</a> determines <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> range of specified bits are all clear.
02316 
02317 Arguments:
02318 
02319     <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a> - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> previously initialized bitmap.
02320 
02321     StartingIndex - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> starting bit index to examine
02322 
02323     Length - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> number of bits to examine
02324 
02325 Return Value:
02326 
02327     BOOLEAN - <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified bits in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> bitmap are all clear, and
02328         <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> <span class="keywordflow">if</span> any are set or <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> range <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> outside <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> bitmap or <span class="keywordflow">if</span>
02329         Length <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> zero.
02330 
02331 --*/
02332 
02333 {
02334     ULONG SizeOfBitMap;
02335     ULONG SizeInBytes;
02336 
02337     ULONG EndingIndex;
02338 
02339     ULONG StartingByte;
02340     ULONG EndingByte;
02341 
02342     ULONG StartingOffset;
02343     ULONG EndingOffset;
02344 
02345     ULONG i;
02346     UCHAR Byte;
02347 
02348     <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a2">GET_BYTE_DECLARATIONS</a>();
02349 
02350     <span class="comment">//</span>
02351     <span class="comment">//  To make the loops in our test run faster we'll extract the fields</span>
02352     <span class="comment">//  from the bitmap header</span>
02353     <span class="comment">//</span>
02354 
02355     SizeOfBitMap = <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;SizeOfBitMap;
02356     SizeInBytes = (SizeOfBitMap + 7) / 8;
02357 
02358     <span class="comment">//</span>
02359     <span class="comment">//  First make sure that the specified range is contained within the</span>
02360     <span class="comment">//  bitmap, and the length is not zero.</span>
02361     <span class="comment">//</span>
02362 
02363     <span class="keywordflow">if</span> ((StartingIndex + Length &gt; SizeOfBitMap) || (Length == 0)) {
02364 
02365         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02366     }
02367 
02368     <span class="comment">//</span>
02369     <span class="comment">//  Compute the ending index, starting and ending byte, and the starting</span>
02370     <span class="comment">//  and ending offset within each byte</span>
02371     <span class="comment">//</span>
02372 
02373     EndingIndex = StartingIndex + Length - 1;
02374 
02375     StartingByte = StartingIndex / 8;
02376     EndingByte = EndingIndex / 8;
02377 
02378     StartingOffset = StartingIndex % 8;
02379     EndingOffset = EndingIndex % 8;
02380 
02381     <span class="comment">//</span>
02382     <span class="comment">//  Set ourselves up to get the next byte</span>
02383     <span class="comment">//</span>
02384 
02385     <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a3">GET_BYTE_INITIALIZATION</a>( BitMapHeader, StartingByte );
02386 
02387     <span class="comment">//</span>
02388     <span class="comment">//  Special case the situation where the starting byte and ending</span>
02389     <span class="comment">//  byte are one in the same</span>
02390     <span class="comment">//</span>
02391 
02392     <span class="keywordflow">if</span> (StartingByte == EndingByte) {
02393 
02394         <span class="comment">//</span>
02395         <span class="comment">//  Get the single byte we are to look at</span>
02396         <span class="comment">//</span>
02397 
02398         <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a4">GET_BYTE</a>( Byte );
02399 
02400         <span class="comment">//</span>
02401         <span class="comment">//  Now we compute the mask of bits we're after and then AND it with</span>
02402         <span class="comment">//  the byte.  If it is zero then the bits in question are all clear</span>
02403         <span class="comment">//  otherwise at least one of them is set.</span>
02404         <span class="comment">//</span>
02405 
02406         <span class="keywordflow">if</span> ((<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a24">ZeroMask</a>[StartingOffset] &amp; <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a23">FillMask</a>[EndingOffset+1] &amp; Byte) == 0) {
02407 
02408             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02409 
02410         } <span class="keywordflow">else</span> {
02411 
02412             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02413         }
02414 
02415     } <span class="keywordflow">else</span> {
02416 
02417         <span class="comment">//</span>
02418         <span class="comment">//  Get the first byte that we're after, and then</span>
02419         <span class="comment">//  compute the mask of bits we're after for the first byte then</span>
02420         <span class="comment">//  AND it with the byte itself.</span>
02421         <span class="comment">//</span>
02422 
02423         <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a4">GET_BYTE</a>( Byte );
02424 
02425         <span class="keywordflow">if</span> ((<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a24">ZeroMask</a>[StartingOffset] &amp; Byte) != 0) {
02426 
02427             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02428         }
02429 
02430         <span class="comment">//</span>
02431         <span class="comment">//  Now for every whole byte inbetween read in the byte,</span>
02432         <span class="comment">//  and make sure it is all zeros</span>
02433         <span class="comment">//</span>
02434 
02435         <span class="keywordflow">for</span> (i = StartingByte+1; i &lt; EndingByte; i += 1) {
02436 
02437             <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a4">GET_BYTE</a>( Byte );
02438 
02439             <span class="keywordflow">if</span> (Byte != 0) {
02440 
02441                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02442             }
02443         }
02444 
02445         <span class="comment">//</span>
02446         <span class="comment">//  Get the last byte we're after, and then</span>
02447         <span class="comment">//  compute the mask of bits we're after for the last byte then</span>
02448         <span class="comment">//  AND it with the byte itself.</span>
02449         <span class="comment">//</span>
02450 
02451         <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a4">GET_BYTE</a>( Byte );
02452 
02453         <span class="keywordflow">if</span> ((<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a23">FillMask</a>[EndingOffset+1] &amp; Byte) != 0) {
02454 
02455             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02456         }
02457     }
02458 
02459     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02460 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a41" doxytag="rtl/bitmap.c::RtlAreBitsSet" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> BOOLEAN RtlAreBitsSet           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PRTL_BITMAP&nbsp;</td>
          <td class="mdname" nowrap> <em>BitMapHeader</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>StartingIndex</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Length</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02464">2464</a> of file <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html">rtl/bitmap.c</a>.
<p>
References <a class="el" href="../../d9/d8/tbitmap_8c-source.html#l00027">BitMapHeader</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00213">FillMask</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00112">GET_BYTE</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00105">GET_BYTE_DECLARATIONS</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00108">GET_BYTE_INITIALIZATION</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, and <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00215">ZeroMask</a>.
<p>
Referenced by <a class="el" href="../../d9/d8/tbitmap_8c-source.html#l00031">main()</a>.
<p>
<pre class="fragment"><div>02472                    :
02473 
02474     This <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a69">procedure</a> determines <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> range of specified bits are all set.
02475 
02476 Arguments:
02477 
02478     <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a> - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> previously initialized bitmap.
02479 
02480     StartingIndex - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> starting bit index to examine
02481 
02482     Length - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> number of bits to examine
02483 
02484 Return Value:
02485 
02486     BOOLEAN - <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified bits in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> bitmap are all set, and
02487         <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> <span class="keywordflow">if</span> any are clear or <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> range <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> outside <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> bitmap or <span class="keywordflow">if</span>
02488         Length <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> zero.
02489 
02490 --*/
02491 
02492 {
02493     ULONG SizeOfBitMap;
02494     ULONG SizeInBytes;
02495 
02496     ULONG EndingIndex;
02497 
02498     ULONG StartingByte;
02499     ULONG EndingByte;
02500 
02501     ULONG StartingOffset;
02502     ULONG EndingOffset;
02503 
02504     ULONG i;
02505     UCHAR Byte;
02506 
02507     <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a2">GET_BYTE_DECLARATIONS</a>();
02508 
02509     <span class="comment">//</span>
02510     <span class="comment">//  To make the loops in our test run faster we'll extract the fields</span>
02511     <span class="comment">//  from the bitmap header</span>
02512     <span class="comment">//</span>
02513 
02514     SizeOfBitMap = <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;SizeOfBitMap;
02515     SizeInBytes = (SizeOfBitMap + 7) / 8;
02516 
02517     <span class="comment">//</span>
02518     <span class="comment">//  First make sure that the specified range is contained within the</span>
02519     <span class="comment">//  bitmap, and the length is not zero.</span>
02520     <span class="comment">//</span>
02521 
02522     <span class="keywordflow">if</span> ((StartingIndex + Length &gt; SizeOfBitMap) || (Length == 0)) {
02523 
02524         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02525     }
02526 
02527     <span class="comment">//</span>
02528     <span class="comment">//  Compute the ending index, starting and ending byte, and the starting</span>
02529     <span class="comment">//  and ending offset within each byte</span>
02530     <span class="comment">//</span>
02531 
02532     EndingIndex = StartingIndex + Length - 1;
02533 
02534     StartingByte = StartingIndex / 8;
02535     EndingByte = EndingIndex / 8;
02536 
02537     StartingOffset = StartingIndex % 8;
02538     EndingOffset = EndingIndex % 8;
02539 
02540     <span class="comment">//</span>
02541     <span class="comment">//  Set ourselves up to get the next byte</span>
02542     <span class="comment">//</span>
02543 
02544     <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a3">GET_BYTE_INITIALIZATION</a>( BitMapHeader, StartingByte );
02545 
02546     <span class="comment">//</span>
02547     <span class="comment">//  Special case the situation where the starting byte and ending</span>
02548     <span class="comment">//  byte are one in the same</span>
02549     <span class="comment">//</span>
02550 
02551     <span class="keywordflow">if</span> (StartingByte == EndingByte) {
02552 
02553         <span class="comment">//</span>
02554         <span class="comment">//  Get the single byte we are to look at</span>
02555         <span class="comment">//</span>
02556 
02557         <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a4">GET_BYTE</a>( Byte );
02558 
02559         <span class="comment">//</span>
02560         <span class="comment">//  Now we compute the mask of bits we're after and then AND it with</span>
02561         <span class="comment">//  the complement of the byte If it is zero then the bits in question</span>
02562         <span class="comment">//  are all clear otherwise at least one of them is clear.</span>
02563         <span class="comment">//</span>
02564 
02565         <span class="keywordflow">if</span> ((<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a24">ZeroMask</a>[StartingOffset] &amp; <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a23">FillMask</a>[EndingOffset+1] &amp; ~Byte) == 0) {
02566 
02567             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02568 
02569         } <span class="keywordflow">else</span> {
02570 
02571             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02572         }
02573 
02574     } <span class="keywordflow">else</span> {
02575 
02576         <span class="comment">//</span>
02577         <span class="comment">//  Get the first byte that we're after, and then</span>
02578         <span class="comment">//  compute the mask of bits we're after for the first byte then</span>
02579         <span class="comment">//  AND it with the complement of the byte itself.</span>
02580         <span class="comment">//</span>
02581 
02582         <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a4">GET_BYTE</a>( Byte );
02583 
02584         <span class="keywordflow">if</span> ((<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a24">ZeroMask</a>[StartingOffset] &amp; ~Byte) != 0) {
02585 
02586             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02587         }
02588 
02589         <span class="comment">//</span>
02590         <span class="comment">//  Now for every whole byte inbetween read in the byte,</span>
02591         <span class="comment">//  and make sure it is all ones</span>
02592         <span class="comment">//</span>
02593 
02594         <span class="keywordflow">for</span> (i = StartingByte+1; i &lt; EndingByte; i += 1) {
02595 
02596             <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a4">GET_BYTE</a>( Byte );
02597 
02598             <span class="keywordflow">if</span> (Byte != 0xff) {
02599 
02600                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02601             }
02602         }
02603 
02604         <span class="comment">//</span>
02605         <span class="comment">//  Get the last byte we're after, and then</span>
02606         <span class="comment">//  compute the mask of bits we're after for the last byte then</span>
02607         <span class="comment">//  AND it with the complement of the byte itself.</span>
02608         <span class="comment">//</span>
02609 
02610         <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a4">GET_BYTE</a>( Byte );
02611 
02612         <span class="keywordflow">if</span> ((<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a23">FillMask</a>[EndingOffset+1] &amp; ~Byte) != 0) {
02613 
02614             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02615         }
02616     }
02617 
02618     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02619 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a27" doxytag="rtl/bitmap.c::RtlClearAllBits" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID RtlClearAllBits           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PRTL_BITMAP&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>BitMapHeader</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00266">266</a> of file <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html">rtl/bitmap.c</a>.
<p>
References <a class="el" href="../../d9/d8/tbitmap_8c-source.html#l00027">BitMapHeader</a>.
<p>
Referenced by <a class="el" href="../../d5/d9/tex_8c-source.html#l01781">DoBitMapTest()</a>, <a class="el" href="../../d6/d0/hiveinit_8c-source.html#l00158">HvInitializeHive()</a>, <a class="el" href="../../d1/d1/hivesync_8c-source.html#l01584">HvRefreshHive()</a>, <a class="el" href="../../d1/d1/hivesync_8c-source.html#l00647">HvSyncHive()</a>, <a class="el" href="../../d3/d2/dumpctl_8c-source.html#l03815">IopCreateSummaryDump()</a>, <a class="el" href="../../d9/d8/tbitmap_8c-source.html#l00031">main()</a>, <a class="el" href="../../d6/d0/mminit_8c-source.html#l02184">MiBuildPagedPool()</a>, <a class="el" href="../../d4/d6/session_8c-source.html#l00350">MiInitializeSessionIds()</a>, <a class="el" href="../../d2/d5/allocpag_8c-source.html#l04222">MiInitializeSessionPool()</a>, <a class="el" href="../../d4/d4/mapview_8c-source.html#l03967">MiInitializeSystemSpaceMap()</a>, <a class="el" href="../../d2/d1/mm_2i386_2init386_8c-source.html#l00058">MiInitMachineDependent()</a>, <a class="el" href="../../d9/d4/physical_8c-source.html#l00970">NtAllocateUserPhysicalPages()</a>, and <a class="el" href="../../d4/d5/allocvm_8c-source.html#l00075">NtAllocateVirtualMemory()</a>.
<p>
<pre class="fragment"><div>00272                    :
00273 
00274     This <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a69">procedure</a> clears all bits in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified Bit Map.
00275 
00276 Arguments:
00277 
00278     <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a> - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> previously initialized <a class="code" href="../../d2/d1/structBitMap.html">BitMap</a>
00279 
00280 Return Value:
00281 
00282     None.
00283 
00284 --*/
00285 
00286 {
00287     <span class="comment">//</span>
00288     <span class="comment">//  Clear all the bits</span>
00289     <span class="comment">//</span>
00290 
00291     RtlZeroMemory( <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;Buffer,
00292                    ((<a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;SizeOfBitMap + 31) / 32) * 4
00293                  );
00294 
00295     <span class="comment">//</span>
00296     <span class="comment">//  And return to our caller</span>
00297     <span class="comment">//</span>
00298 
00299     <span class="comment">//DbgPrint("ClearAllBits"); DumpBitMap(BitMapHeader);</span>
00300     <span class="keywordflow">return</span>;
00301 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a33" doxytag="rtl/bitmap.c::RtlClearBits" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID RtlClearBits           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PRTL_BITMAP&nbsp;</td>
          <td class="mdname" nowrap> <em>BitMapHeader</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>StartingIndex</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>NumberToClear</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l01508">1508</a> of file <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html">rtl/bitmap.c</a>.
<p>
References <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d9/d8/tbitmap_8c-source.html#l00027">BitMapHeader</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00037">LeftShiftUlong</a>, and <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00036">RightShiftUlong</a>.
<p>
Referenced by <a class="el" href="../../d5/d9/tex_8c-source.html#l01781">DoBitMapTest()</a>, <a class="el" href="../../d3/d0/hivefree_8c-source.html#l00160">HvFreeHivePartial()</a>, <a class="el" href="../../d1/d1/hivesync_8c-source.html#l00401">HvMarkClean()</a>, <a class="el" href="../../d1/d1/hivesync_8c-source.html#l01584">HvRefreshHive()</a>, <a class="el" href="../../d3/d2/dumpctl_8c-source.html#l02193">IopRemovePageFromPageMap()</a>, <a class="el" href="../../d9/d8/tbitmap_8c-source.html#l00031">main()</a>, <a class="el" href="../../d2/d5/allocpag_8c-source.html#l00807">MiAllocatePoolPages()</a>, <a class="el" href="../../d7/d2/modwrite_8c-source.html#l01485">MiAttemptPageFileExtension()</a>, <a class="el" href="../../d7/d2/modwrite_8c-source.html#l01940">MiAttemptPageFileReduction()</a>, <a class="el" href="../../d6/d0/mminit_8c-source.html#l02184">MiBuildPagedPool()</a>, <a class="el" href="../../d4/d6/session_8c-source.html#l01544">MiDereferenceSession()</a>, <a class="el" href="../../d2/d5/allocpag_8c-source.html#l01778">MiFreePoolPages()</a>, <a class="el" href="../../d7/d2/modwrite_8c-source.html#l03701">MiGatherPagefilePages()</a>, <a class="el" href="../../d2/d5/allocpag_8c-source.html#l04222">MiInitializeSessionPool()</a>, <a class="el" href="../../d4/d4/mapview_8c-source.html#l03268">MiMapViewInSystemSpace()</a>, <a class="el" href="../../d9/d5/deleteva_8c-source.html#l01014">MiReleasePageFileSpace()</a>, <a class="el" href="../../d4/d6/session_8c-source.html#l00394">MiSessionCreateInternal()</a>, <a class="el" href="../../d4/d4/mapview_8c-source.html#l03683">MiUnmapViewInSystemSpace()</a>, <a class="el" href="../../d9/d4/physical_8c-source.html#l00970">NtAllocateUserPhysicalPages()</a>, <a class="el" href="../../d7/d2/modwrite_8c-source.html#l00297">NtCreatePagingFile()</a>, <a class="el" href="../../d9/d4/physical_8c-source.html#l01624">NtFreeUserPhysicalPages()</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l01448">RtlFindSetBitsAndClear()</a>, and <a class="el" href="../../d0/d6/desktop_8c-source.html#l04494">SetHandleFlag()</a>.
<p>
<pre class="fragment"><div>01516                    :
01517 
01518     This <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a69">procedure</a> clears <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified range of bits within <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
01519     specified bit map.
01520 
01521 Arguments:
01522 
01523     <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a> - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> previously initialized Bit Map.
01524 
01525     StartingIndex - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> index (zero based) of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> first bit to clear.
01526 
01527     NumberToClear - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> number of bits to clear.
01528 
01529 Return Value:
01530 
01531     None.
01532 
01533 --*/
01534 
01535 {
01536     ULONG BitOffset;
01537     PULONG CurrentLong;
01538 
01539     <span class="comment">//DbgPrint("ClearBits %08lx, ", NumberToClear);</span>
01540     <span class="comment">//DbgPrint("%08lx", StartingIndex);</span>
01541 
01542     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( StartingIndex + NumberToClear &lt;= BitMapHeader-&gt;SizeOfBitMap );
01543 
01544     <span class="comment">//</span>
01545     <span class="comment">//  Special case the situation where the number of bits to clear is</span>
01546     <span class="comment">//  zero.  Turn this into a noop.</span>
01547     <span class="comment">//</span>
01548 
01549     <span class="keywordflow">if</span> (NumberToClear == 0) {
01550 
01551         <span class="keywordflow">return</span>;
01552     }
01553 
01554     BitOffset = StartingIndex % 32;
01555 
01556     <span class="comment">//</span>
01557     <span class="comment">//  Get a pointer to the first longword that needs to be zeroed out</span>
01558     <span class="comment">//</span>
01559 
01560     CurrentLong = &amp;<a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;Buffer[ StartingIndex / 32 ];
01561 
01562     <span class="comment">//</span>
01563     <span class="comment">//  Check if we can only need to clear out one longword.</span>
01564     <span class="comment">//</span>
01565 
01566     <span class="keywordflow">if</span> ((BitOffset + NumberToClear) &lt;= 32) {
01567 
01568         <span class="comment">//</span>
01569         <span class="comment">//  To build a mask of bits to clear we shift left to get the number</span>
01570         <span class="comment">//  of bits we're clearing and then shift right to put it in position.</span>
01571         <span class="comment">//  We'll typecast the right shift to ULONG to make sure it doesn't</span>
01572         <span class="comment">//  do a sign extend.</span>
01573         <span class="comment">//</span>
01574 
01575         *CurrentLong &amp;= ~<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a1">LeftShiftUlong</a>(<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a0">RightShiftUlong</a>(((ULONG)0xFFFFFFFF),(32 - NumberToClear)),
01576                                                                     BitOffset);
01577 
01578         <span class="comment">//</span>
01579         <span class="comment">//  And return to our caller</span>
01580         <span class="comment">//</span>
01581 
01582         <span class="comment">//DumpBitMap(BitMapHeader);</span>
01583 
01584         <span class="keywordflow">return</span>;
01585     }
01586 
01587     <span class="comment">//</span>
01588     <span class="comment">//  We can clear out to the end of the first longword so we'll</span>
01589     <span class="comment">//  do that right now.</span>
01590     <span class="comment">//</span>
01591 
01592     *CurrentLong &amp;= ~<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a1">LeftShiftUlong</a>(0xFFFFFFFF, BitOffset);
01593 
01594     <span class="comment">//</span>
01595     <span class="comment">//  And indicate what the next longword to clear is and how many</span>
01596     <span class="comment">//  bits are left to clear</span>
01597     <span class="comment">//</span>
01598 
01599     CurrentLong += 1;
01600     NumberToClear -= 32 - BitOffset;
01601 
01602     <span class="comment">//</span>
01603     <span class="comment">//  The bit position is now long aligned, so we can continue</span>
01604     <span class="comment">//  clearing longwords until the number to clear is less than 32</span>
01605     <span class="comment">//</span>
01606 
01607     <span class="keywordflow">while</span> (NumberToClear &gt;= 32) {
01608 
01609         *CurrentLong = 0;
01610         CurrentLong += 1;
01611         NumberToClear -= 32;
01612     }
01613 
01614     <span class="comment">//</span>
01615     <span class="comment">//  And now we can clear the remaining bits, if there are any, in the</span>
01616     <span class="comment">//  last longword</span>
01617     <span class="comment">//</span>
01618 
01619     <span class="keywordflow">if</span> (NumberToClear &gt; 0) {
01620 
01621         *CurrentLong &amp;= <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a1">LeftShiftUlong</a>(0xFFFFFFFF, NumberToClear);
01622     }
01623 
01624     <span class="comment">//</span>
01625     <span class="comment">//  And return to our caller</span>
01626     <span class="comment">//</span>
01627 
01628     <span class="comment">//DumpBitMap(BitMapHeader);</span>
01629 
01630     <span class="keywordflow">return</span>;
01631 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a29" doxytag="rtl/bitmap.c::RtlFindClearBits" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ULONG RtlFindClearBits           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PRTL_BITMAP&nbsp;</td>
          <td class="mdname" nowrap> <em>BitMapHeader</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>NumberToFind</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>HintIndex</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00345">345</a> of file <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html">rtl/bitmap.c</a>.
<p>
References <a class="el" href="../../d9/d8/tbitmap_8c-source.html#l00027">BitMapHeader</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00213">FillMask</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00112">GET_BYTE</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00105">GET_BYTE_DECLARATIONS</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00108">GET_BYTE_INITIALIZATION</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00122">RtlpBitsClearAnywhere</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00168">RtlpBitsClearHigh</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00145">RtlpBitsClearLow</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, and <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00215">ZeroMask</a>.
<p>
Referenced by <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l01382">RtlFindClearBitsAndSet()</a>.
<p>
<pre class="fragment"><div>00353                    :
00354 
00355     This <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a69">procedure</a> searches <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified bit map <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified
00356     contiguous region of clear bits.  If a run <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> not found from <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
00357     hint to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> end of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> bitmap, we will search again from <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
00358     beginning of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> bitmap.
00359 
00360 Arguments:
00361 
00362     <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a> - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> previously initialized <a class="code" href="../../d2/d1/structBitMap.html">BitMap</a>.
00363 
00364     NumberToFind - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> size of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> contiguous region to find.
00365 
00366     HintIndex - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> index (zero based) of where we should start
00367         <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> search from within <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> bitmap.
00368 
00369 Return Value:
00370 
00371     ULONG - Receives <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> starting index (zero based) of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> contiguous
00372         region of clear bits found.  If not such a region cannot be found
00373         a -1 (i.e. 0xffffffff) <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> returned.
00374 
00375 --*/
00376 
00377 {
00378     ULONG SizeOfBitMap;
00379     ULONG SizeInBytes;
00380 
00381     ULONG HintBit;
00382     ULONG MainLoopIndex;
00383 
00384     <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a2">GET_BYTE_DECLARATIONS</a>();
00385 
00386     <span class="comment">//</span>
00387     <span class="comment">//  To make the loops in our test run faster we'll extract the</span>
00388     <span class="comment">//  fields from the bitmap header</span>
00389     <span class="comment">//</span>
00390 
00391     SizeOfBitMap = <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;SizeOfBitMap;
00392     SizeInBytes = (SizeOfBitMap + 7) / 8;
00393 
00394     <span class="comment">//</span>
00395     <span class="comment">//  Set any unused bits in the last byte so we won't count them.  We do</span>
00396     <span class="comment">//  this by first checking if there is any odd bits in the last byte.</span>
00397     <span class="comment">//</span>
00398 
00399     <span class="keywordflow">if</span> ((SizeOfBitMap % 8) != 0) {
00400 
00401         <span class="comment">//</span>
00402         <span class="comment">//  The last byte has some odd bits so we'll set the high unused</span>
00403         <span class="comment">//  bits in the last byte to 1's</span>
00404         <span class="comment">//</span>
00405 
00406         ((PUCHAR)<a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;Buffer)[SizeInBytes - 1] |=
00407                                                     <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a24">ZeroMask</a>[SizeOfBitMap % 8];
00408     }
00409 
00410     <span class="comment">//</span>
00411     <span class="comment">//  Calculate from the hint index where the hint byte is and set ourselves</span>
00412     <span class="comment">//  up to read the hint on the next call to GET_BYTE.  To make the</span>
00413     <span class="comment">//  algorithm run fast we'll only honor hints down to the byte level of</span>
00414     <span class="comment">//  granularity.  There is a possibility that we'll need to execute</span>
00415     <span class="comment">//  our main logic twice.  Once to test from the hint byte to the end of</span>
00416     <span class="comment">//  the bitmap and the other to test from the start of the bitmap.  First</span>
00417     <span class="comment">//  we need to make sure the Hint Index is within range.</span>
00418     <span class="comment">//</span>
00419 
00420     <span class="keywordflow">if</span> (HintIndex &gt;= SizeOfBitMap) {
00421 
00422         HintIndex = 0;
00423     }
00424 
00425     HintBit = HintIndex % 8;
00426 
00427     <span class="keywordflow">for</span> (MainLoopIndex = 0; MainLoopIndex &lt; 2; MainLoopIndex += 1) {
00428 
00429         ULONG StartByteIndex;
00430         ULONG EndByteIndex;
00431 
00432         UCHAR CurrentByte;
00433 
00434         <span class="comment">//</span>
00435         <span class="comment">//  Check for the first time through the main loop, which indicates</span>
00436         <span class="comment">//  that we are going to start our search at our hint byte</span>
00437         <span class="comment">//</span>
00438 
00439         <span class="keywordflow">if</span> (MainLoopIndex == 0) {
00440 
00441             StartByteIndex = HintIndex / 8;
00442             EndByteIndex = SizeInBytes;
00443 
00444         <span class="comment">//</span>
00445         <span class="comment">//  This is the second time through the loop, make sure there is</span>
00446         <span class="comment">//  actually something to check before the hint byte</span>
00447         <span class="comment">//</span>
00448 
00449         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (HintIndex != 0) {
00450 
00451             <span class="comment">//</span>
00452             <span class="comment">//  The end index for the second time around is based on the</span>
00453             <span class="comment">//  number of bits we need to find.  We need to use this inorder</span>
00454             <span class="comment">//  to take the case where the preceding byte to the hint byte</span>
00455             <span class="comment">//  is the start of our run, and the run includes the hint byte</span>
00456             <span class="comment">//  and some following bytes, based on the number of bits needed</span>
00457             <span class="comment">//  The computation is to take the number of bits needed minus</span>
00458             <span class="comment">//  2 divided by 8 and then add 2.  This will take in to account</span>
00459             <span class="comment">//  the worst possible case where we have one bit hanging off</span>
00460             <span class="comment">//  of each end byte, and all intervening bytes are all zero.</span>
00461             <span class="comment">//</span>
00462 
00463             <span class="keywordflow">if</span> (NumberToFind &lt; 2) {
00464 
00465                 EndByteIndex = HintIndex / 8;
00466 
00467             } <span class="keywordflow">else</span> {
00468 
00469                 EndByteIndex = (HintIndex / 8) + ((NumberToFind - 2) / 8) + 2;
00470 
00471                 <span class="comment">//</span>
00472                 <span class="comment">//  Make sure we don't overrun the end of the bitmap</span>
00473                 <span class="comment">//</span>
00474 
00475                 <span class="keywordflow">if</span> (EndByteIndex &gt; SizeInBytes) {
00476 
00477                     EndByteIndex = SizeInBytes;
00478                 }
00479             }
00480 
00481             HintIndex = 0;
00482             HintBit = 0;
00483             StartByteIndex = 0;
00484 
00485         <span class="comment">//</span>
00486         <span class="comment">//  Otherwise we already did a complete loop through the bitmap</span>
00487         <span class="comment">//  so we should simply return -1 to say nothing was found</span>
00488         <span class="comment">//</span>
00489 
00490         } <span class="keywordflow">else</span> {
00491 
00492             <span class="keywordflow">return</span> 0xffffffff;
00493         }
00494 
00495         <span class="comment">//</span>
00496         <span class="comment">//  Set ourselves up to get the next byte</span>
00497         <span class="comment">//</span>
00498 
00499         <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a3">GET_BYTE_INITIALIZATION</a>(BitMapHeader, StartByteIndex);
00500 
00501         <span class="comment">//</span>
00502         <span class="comment">//  Get the first byte, and set any bits before the hint bit.</span>
00503         <span class="comment">//</span>
00504 
00505         <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a4">GET_BYTE</a>( CurrentByte );
00506 
00507         CurrentByte |= <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a23">FillMask</a>[HintBit];
00508 
00509         <span class="comment">//</span>
00510         <span class="comment">//  If the number of bits can only fit in 1 or 2 bytes (i.e., 9 bits or</span>
00511         <span class="comment">//  less) we do the following test case.</span>
00512         <span class="comment">//</span>
00513 
00514         <span class="keywordflow">if</span> (NumberToFind &lt;= 9) {
00515 
00516             ULONG CurrentBitIndex;
00517             UCHAR PreviousByte;
00518 
00519             PreviousByte = 0xff;
00520 
00521             <span class="comment">//</span>
00522             <span class="comment">//  Examine all the bytes within our test range searching</span>
00523             <span class="comment">//  for a fit</span>
00524             <span class="comment">//</span>
00525 
00526             CurrentBitIndex = StartByteIndex * 8;
00527 
00528             <span class="keywordflow">while</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
00529 
00530                 <span class="comment">//</span>
00531                 <span class="comment">//  If this is the first itteration of the loop, mask Current</span>
00532                 <span class="comment">//  byte with the real hint.</span>
00533                 <span class="comment">//</span>
00534 
00535                 <span class="comment">//</span>
00536                 <span class="comment">//  Check to see if the current byte coupled with the previous</span>
00537                 <span class="comment">//  byte will satisfy the requirement. The check uses the high</span>
00538                 <span class="comment">//  part of the previous byte and low part of the current byte.</span>
00539                 <span class="comment">//</span>
00540 
00541                 <span class="keywordflow">if</span> (((ULONG)<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a21">RtlpBitsClearHigh</a>[PreviousByte] +
00542                            (ULONG)<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a20">RtlpBitsClearLow</a>[CurrentByte]) &gt;= NumberToFind) {
00543 
00544                     ULONG StartingIndex;
00545 
00546                     <span class="comment">//</span>
00547                     <span class="comment">//  It all fits in these two bytes, so we can compute</span>
00548                     <span class="comment">//  the starting index.  This is done by taking the</span>
00549                     <span class="comment">//  index of the current byte (bit 0) and subtracting the</span>
00550                     <span class="comment">//  number of bits its takes to get to the first cleared</span>
00551                     <span class="comment">//  high bit.</span>
00552                     <span class="comment">//</span>
00553 
00554                     StartingIndex = CurrentBitIndex -
00555                                              (LONG)<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a21">RtlpBitsClearHigh</a>[PreviousByte];
00556 
00557                     <span class="comment">//</span>
00558                     <span class="comment">//  Now make sure the total size isn't beyond the bitmap</span>
00559                     <span class="comment">//</span>
00560 
00561                     <span class="keywordflow">if</span> ((StartingIndex + NumberToFind) &lt;= SizeOfBitMap) {
00562 
00563                         <span class="keywordflow">return</span> StartingIndex;
00564                     }
00565                 }
00566 
00567                 <span class="comment">//</span>
00568                 <span class="comment">//  The previous byte does not help, so check the current byte.</span>
00569                 <span class="comment">//</span>
00570 
00571                 <span class="keywordflow">if</span> ((ULONG)<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a19">RtlpBitsClearAnywhere</a>[CurrentByte] &gt;= NumberToFind) {
00572 
00573                     UCHAR BitMask;
00574                     ULONG i;
00575 
00576                     <span class="comment">//</span>
00577                     <span class="comment">//  It all fits in a single byte, so calculate the bit</span>
00578                     <span class="comment">//  number.  We do this by taking a mask of the appropriate</span>
00579                     <span class="comment">//  size and shifting it over until it fits.  It fits when</span>
00580                     <span class="comment">//  we can bitwise-and the current byte with the bitmask</span>
00581                     <span class="comment">//  and get a zero back.</span>
00582                     <span class="comment">//</span>
00583 
00584                     BitMask = <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a23">FillMask</a>[ NumberToFind ];
00585                     <span class="keywordflow">for</span> (i = 0; (BitMask &amp; CurrentByte) != 0; i += 1) {
00586 
00587                         BitMask &lt;&lt;= 1;
00588                     }
00589 
00590                     <span class="comment">//</span>
00591                     <span class="comment">//  return to our caller the located bit index, and the</span>
00592                     <span class="comment">//  number that we found.</span>
00593                     <span class="comment">//</span>
00594 
00595                     <span class="keywordflow">return</span> CurrentBitIndex + i;
00596                 }
00597 
00598                 <span class="comment">//</span>
00599                 <span class="comment">//  For the next iteration through our loop we need to make</span>
00600                 <span class="comment">//  the current byte into the previous byte, and go to the</span>
00601                 <span class="comment">//  top of the loop again.</span>
00602                 <span class="comment">//</span>
00603 
00604                 PreviousByte = CurrentByte;
00605 
00606                 <span class="comment">//</span>
00607                 <span class="comment">//  Increment our Bit Index, and either exit, or get the</span>
00608                 <span class="comment">//  next byte.</span>
00609                 <span class="comment">//</span>
00610 
00611                 CurrentBitIndex += 8;
00612 
00613                 <span class="keywordflow">if</span> ( CurrentBitIndex &lt; EndByteIndex * 8 ) {
00614 
00615                     <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a4">GET_BYTE</a>( CurrentByte );
00616 
00617                 } <span class="keywordflow">else</span> {
00618 
00619                     <span class="keywordflow">break</span>;
00620                 }
00621 
00622             } <span class="comment">// end loop CurrentBitIndex</span>
00623 
00624         <span class="comment">//</span>
00625         <span class="comment">//  The number to find is greater than 9 but if it is less than 15</span>
00626         <span class="comment">//  then we know it can be satisfied with at most 2 bytes, or 3 bytes</span>
00627         <span class="comment">//  if the middle byte (of the 3) is all zeros.</span>
00628         <span class="comment">//</span>
00629 
00630         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (NumberToFind &lt; 15) {
00631 
00632             ULONG CurrentBitIndex;
00633 
00634             UCHAR PreviousPreviousByte;
00635             UCHAR PreviousByte;
00636 
00637             PreviousByte = 0xff;
00638 
00639             <span class="comment">//</span>
00640             <span class="comment">//  Examine all the bytes within our test range searching</span>
00641             <span class="comment">//  for a fit</span>
00642             <span class="comment">//</span>
00643 
00644             CurrentBitIndex = StartByteIndex * 8;
00645 
00646             <span class="keywordflow">while</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
00647 
00648                 <span class="comment">//</span>
00649                 <span class="comment">//  For the next iteration through our loop we need to make</span>
00650                 <span class="comment">//  the current byte into the previous byte, the previous</span>
00651                 <span class="comment">//  byte into the previous previous byte, and go forward.</span>
00652                 <span class="comment">//</span>
00653 
00654                 PreviousPreviousByte = PreviousByte;
00655                 PreviousByte = CurrentByte;
00656 
00657                 <span class="comment">//</span>
00658                 <span class="comment">//  Increment our Bit Index, and either exit, or get the</span>
00659                 <span class="comment">//  next byte.</span>
00660                 <span class="comment">//</span>
00661 
00662                 CurrentBitIndex += 8;
00663 
00664                 <span class="keywordflow">if</span> ( CurrentBitIndex &lt; EndByteIndex * 8 ) {
00665 
00666                     <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a4">GET_BYTE</a>( CurrentByte );
00667 
00668                 } <span class="keywordflow">else</span> {
00669 
00670                     <span class="keywordflow">break</span>;
00671                 }
00672 
00673                 <span class="comment">//</span>
00674                 <span class="comment">//  if the previous byte is all zeros then maybe the</span>
00675                 <span class="comment">//  request can be satisfied using the Previous Previous Byte</span>
00676                 <span class="comment">//  Previous Byte, and the Current Byte.</span>
00677                 <span class="comment">//</span>
00678 
00679                 <span class="keywordflow">if</span> ((PreviousByte == 0)
00680                     
00681                     &amp;&amp;
00682 
00683                     (((ULONG)<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a21">RtlpBitsClearHigh</a>[PreviousPreviousByte] + 8 +
00684                           (ULONG)<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a20">RtlpBitsClearLow</a>[CurrentByte]) &gt;= NumberToFind)) {
00685 
00686                     ULONG StartingIndex;
00687 
00688                     <span class="comment">//</span>
00689                     <span class="comment">//  It all fits in these three bytes, so we can compute</span>
00690                     <span class="comment">//  the starting index.  This is done by taking the</span>
00691                     <span class="comment">//  index of the previous byte (bit 0) and subtracting</span>
00692                     <span class="comment">//  the number of bits its takes to get to the first</span>
00693                     <span class="comment">//  cleared high bit.</span>
00694                     <span class="comment">//</span>
00695 
00696                     StartingIndex = (CurrentBitIndex - 8) -
00697                                      (LONG)<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a21">RtlpBitsClearHigh</a>[PreviousPreviousByte];
00698 
00699                     <span class="comment">//</span>
00700                     <span class="comment">//  Now make sure the total size isn't beyond the bitmap</span>
00701                     <span class="comment">//</span>
00702 
00703                     <span class="keywordflow">if</span> ((StartingIndex + NumberToFind) &lt;= SizeOfBitMap) {
00704 
00705                         <span class="keywordflow">return</span> StartingIndex;
00706                     }
00707                 }
00708 
00709                 <span class="comment">//</span>
00710                 <span class="comment">//  Check to see if the Previous byte and current byte</span>
00711                 <span class="comment">//  together satisfy the request.</span>
00712                 <span class="comment">//</span>
00713 
00714                 <span class="keywordflow">if</span> (((ULONG)<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a21">RtlpBitsClearHigh</a>[PreviousByte] +
00715                            (ULONG)<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a20">RtlpBitsClearLow</a>[CurrentByte]) &gt;= NumberToFind) {
00716 
00717                     ULONG StartingIndex;
00718 
00719                     <span class="comment">//</span>
00720                     <span class="comment">//  It all fits in these two bytes, so we can compute</span>
00721                     <span class="comment">//  the starting index.  This is done by taking the</span>
00722                     <span class="comment">//  index of the current byte (bit 0) and subtracting the</span>
00723                     <span class="comment">//  number of bits its takes to get to the first cleared</span>
00724                     <span class="comment">//  high bit.</span>
00725                     <span class="comment">//</span>
00726 
00727                     StartingIndex = CurrentBitIndex -
00728                                              (LONG)<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a21">RtlpBitsClearHigh</a>[PreviousByte];
00729 
00730                     <span class="comment">//</span>
00731                     <span class="comment">//  Now make sure the total size isn't beyond the bitmap</span>
00732                     <span class="comment">//</span>
00733 
00734                     <span class="keywordflow">if</span> ((StartingIndex + NumberToFind) &lt;= SizeOfBitMap) {
00735 
00736                         <span class="keywordflow">return</span> StartingIndex;
00737                     }
00738                 }
00739 
00740             } <span class="comment">// end loop CurrentBitIndex</span>
00741 
00742         <span class="comment">//</span>
00743         <span class="comment">//  The number to find is greater than or equal to 15.  This request</span>
00744         <span class="comment">//  has to have at least one byte of all zeros to be satisfied</span>
00745         <span class="comment">//</span>
00746 
00747         } <span class="keywordflow">else</span> {
00748 
00749             ULONG CurrentByteIndex;
00750 
00751             ULONG ZeroBytesNeeded;
00752             ULONG ZeroBytesFound;
00753 
00754             UCHAR StartOfRunByte;
00755             LONG StartOfRunIndex;
00756 
00757             <span class="comment">//</span>
00758             <span class="comment">//  First precalculate how many zero bytes we're going to need</span>
00759             <span class="comment">//</span>
00760 
00761             ZeroBytesNeeded = (NumberToFind - 7) / 8;
00762 
00763             <span class="comment">//</span>
00764             <span class="comment">//  Indicate for the first time through our loop that we haven't</span>
00765             <span class="comment">//  found a zero byte yet, and indicate that the start of the</span>
00766             <span class="comment">//  run is the byte just before the start byte index</span>
00767             <span class="comment">//</span>
00768 
00769             ZeroBytesFound = 0;
00770             StartOfRunByte = 0xff;
00771             StartOfRunIndex = StartByteIndex - 1;
00772 
00773             <span class="comment">//</span>
00774             <span class="comment">//  Examine all the bytes in our test range searching for a fit</span>
00775             <span class="comment">//</span>
00776 
00777             CurrentByteIndex = StartByteIndex;
00778 
00779             <span class="keywordflow">while</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
00780 
00781                 <span class="comment">//</span>
00782                 <span class="comment">//  If the number of zero bytes fits our minimum requirements</span>
00783                 <span class="comment">//  then we can do the additional test to see if we</span>
00784                 <span class="comment">//  actually found a fit</span>
00785                 <span class="comment">//</span>
00786 
00787                 <span class="keywordflow">if</span> ((ZeroBytesFound &gt;= ZeroBytesNeeded)
00788 
00789                         &amp;&amp;
00790 
00791                     ((ULONG)<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a21">RtlpBitsClearHigh</a>[StartOfRunByte] + ZeroBytesFound*8 +
00792                      (ULONG)<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a20">RtlpBitsClearLow</a>[CurrentByte]) &gt;= NumberToFind) {
00793 
00794                     ULONG StartingIndex;
00795 
00796                     <span class="comment">//</span>
00797                     <span class="comment">//  It all fits in these bytes, so we can compute</span>
00798                     <span class="comment">//  the starting index.  This is done by taking the</span>
00799                     <span class="comment">//  StartOfRunIndex times 8 and adding the number of bits</span>
00800                     <span class="comment">//  it takes to get to the first cleared high bit.</span>
00801                     <span class="comment">//</span>
00802 
00803                     StartingIndex = (StartOfRunIndex * 8) +
00804                                      (8 - (LONG)<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a21">RtlpBitsClearHigh</a>[StartOfRunByte]);
00805 
00806                     <span class="comment">//</span>
00807                     <span class="comment">//  Now make sure the total size isn't beyond the bitmap</span>
00808                     <span class="comment">//</span>
00809 
00810                     <span class="keywordflow">if</span> ((StartingIndex + NumberToFind) &lt;= SizeOfBitMap) {
00811 
00812                         <span class="keywordflow">return</span> StartingIndex;
00813                     }
00814                 }
00815 
00816                 <span class="comment">//</span>
00817                 <span class="comment">//  Check to see if the byte is zero and increment</span>
00818                 <span class="comment">//  the number of zero bytes found</span>
00819                 <span class="comment">//</span>
00820 
00821                 <span class="keywordflow">if</span> (CurrentByte == 0) {
00822 
00823                     ZeroBytesFound += 1;
00824 
00825                 <span class="comment">//</span>
00826                 <span class="comment">//  The byte isn't a zero so we need to start over again</span>
00827                 <span class="comment">//  looking for zero bytes.</span>
00828                 <span class="comment">//</span>
00829 
00830                 } <span class="keywordflow">else</span> {
00831 
00832                     ZeroBytesFound = 0;
00833                     StartOfRunByte = CurrentByte;
00834                     StartOfRunIndex = CurrentByteIndex;
00835                 }
00836 
00837                 <span class="comment">//</span>
00838                 <span class="comment">//  Increment our Byte Index, and either exit, or get the</span>
00839                 <span class="comment">//  next byte.</span>
00840                 <span class="comment">//</span>
00841 
00842                 CurrentByteIndex += 1;
00843 
00844                 <span class="keywordflow">if</span> ( CurrentByteIndex &lt; EndByteIndex ) {
00845 
00846                     <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a4">GET_BYTE</a>( CurrentByte );
00847 
00848                 } <span class="keywordflow">else</span> {
00849 
00850                     <span class="keywordflow">break</span>;
00851                 }
00852 
00853             } <span class="comment">// end loop CurrentByteIndex</span>
00854         }
00855     }
00856 
00857     <span class="comment">//</span>
00858     <span class="comment">//  We never found a fit so we'll return -1</span>
00859     <span class="comment">//</span>
00860 
00861     <span class="keywordflow">return</span> 0xffffffff;
00862 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a31" doxytag="rtl/bitmap.c::RtlFindClearBitsAndSet" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ULONG RtlFindClearBitsAndSet           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PRTL_BITMAP&nbsp;</td>
          <td class="mdname" nowrap> <em>BitMapHeader</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>NumberToFind</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>HintIndex</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l01382">1382</a> of file <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html">rtl/bitmap.c</a>.
<p>
References <a class="el" href="../../d9/d8/tbitmap_8c-source.html#l00027">BitMapHeader</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00345">RtlFindClearBits()</a>, and <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l01634">RtlSetBits()</a>.
<p>
Referenced by <a class="el" href="../../d5/d9/tex_8c-source.html#l01781">DoBitMapTest()</a>, <a class="el" href="../../d9/d8/tbitmap_8c-source.html#l00031">main()</a>, <a class="el" href="../../d2/d5/allocpag_8c-source.html#l00807">MiAllocatePoolPages()</a>, <a class="el" href="../../d7/d2/modwrite_8c-source.html#l03701">MiGatherPagefilePages()</a>, <a class="el" href="../../d4/d4/mapview_8c-source.html#l03757">MiInsertInSystemSpace()</a>, and <a class="el" href="../../d4/d6/session_8c-source.html#l00394">MiSessionCreateInternal()</a>.
<p>
<pre class="fragment"><div>01390                    :
01391 
01392     This <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a69">procedure</a> searches <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified bit map <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified
01393     contiguous region of clear bits, sets <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> bits and returns <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
01394     number of bits found, and <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> starting bit number which was clear
01395     then set.
01396 
01397 Arguments:
01398 
01399     <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a> - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> previously initialized <a class="code" href="../../d2/d1/structBitMap.html">BitMap</a>.
01400 
01401     NumberToFind - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> size of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> contiguous region to find.
01402 
01403     HintIndex - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> index (zero based) of where we should start
01404         <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> search from within <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> bitmap.
01405 
01406 Return Value:
01407 
01408     ULONG - Receives <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> starting index (zero based) of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> contiguous
01409         region found.  If such a region cannot be located a -1 (i.e.,
01410         0xffffffff) <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> returned.
01411 
01412 --*/
01413 
01414 {
01415     ULONG StartingIndex;
01416 
01417     <span class="comment">//</span>
01418     <span class="comment">//  First look for a run of clear bits that equals the size requested</span>
01419     <span class="comment">//</span>
01420 
01421     StartingIndex = <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a29">RtlFindClearBits</a>( BitMapHeader,
01422                                       NumberToFind,
01423                                       HintIndex );
01424 
01425     <span class="comment">//DbgPrint("FindClearBits %08lx, ", NumberToFind);</span>
01426     <span class="comment">//DbgPrint("%08lx", StartingIndex);</span>
01427     <span class="comment">//DumpBitMap(BitMapHeader);</span>
01428 
01429     <span class="keywordflow">if</span> (StartingIndex != 0xffffffff) {
01430 
01431         <span class="comment">//</span>
01432         <span class="comment">//  We found a large enough run of clear bits so now set them</span>
01433         <span class="comment">//</span>
01434 
01435         <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a34">RtlSetBits</a>( BitMapHeader, StartingIndex, NumberToFind );
01436     }
01437 
01438     <span class="comment">//</span>
01439     <span class="comment">//  And return to our caller</span>
01440     <span class="comment">//</span>
01441 
01442     <span class="keywordflow">return</span> StartingIndex;
01443 
01444 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a35" doxytag="rtl/bitmap.c::RtlFindClearRuns" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ULONG RtlFindClearRuns           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PRTL_BITMAP&nbsp;</td>
          <td class="mdname" nowrap> <em>BitMapHeader</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>PRTL_BITMAP_RUN&nbsp;</td>
          <td class="mdname" nowrap> <em>RunArray</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>SizeOfRunArray</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>BOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>LocateLongestRuns</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l01764">1764</a> of file <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html">rtl/bitmap.c</a>.
<p>
References <a class="el" href="../../d9/d8/tbitmap_8c-source.html#l00027">BitMapHeader</a>, <a class="el" href="../../d7/d5/memprint_8h-source.html#l00079">DbgPrint</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00213">FillMask</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00112">GET_BYTE</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00105">GET_BYTE_DECLARATIONS</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00108">GET_BYTE_INITIALIZATION</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00122">RtlpBitsClearAnywhere</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00168">RtlpBitsClearHigh</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00145">RtlpBitsClearLow</a>, and <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00215">ZeroMask</a>.
<p>
Referenced by <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02071">RtlFindLongestRunClear()</a>.
<p>
<pre class="fragment"><div>01773                    :
01774 
01775     This <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a69">procedure</a> finds N contiguous runs of clear bits
01776     within <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified bit map.
01777 
01778 Arguments:
01779 
01780     <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a> - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> previously initialized <a class="code" href="../../d2/d1/structBitMap.html">BitMap</a>.
01781 
01782     RunArray - Receives <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> bit position, and length of each of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> free runs
01783         that <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a69">procedure</a> locates.  The array will be sorted according to
01784         length.
01785 
01786     SizeOfRunArray - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> maximum number of entries <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller wants
01787         returned in RunArray
01788 
01789     LocateLongestRuns - Indicates <span class="keywordflow">if</span> <span class="keyword">this</span> routine <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> to <span class="keywordflow">return</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> longest runs
01790         <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> can find or just <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> first N runs.
01791 
01792 
01793 Return Value:
01794 
01795     ULONG - Receives <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> number of runs that <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a69">procedure</a> has located and
01796         returned in RunArray
01797 
01798 --*/
01799 
01800 {
01801     ULONG RunIndex;
01802     ULONG i;
01803     LONG j;
01804 
01805     ULONG SizeOfBitMap;
01806     ULONG SizeInBytes;
01807 
01808     ULONG CurrentRunSize;
01809     ULONG CurrentRunIndex;
01810     ULONG CurrentByteIndex;
01811     UCHAR CurrentByte;
01812 
01813     UCHAR BitMask;
01814     UCHAR TempNumber;
01815 
01816     <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a2">GET_BYTE_DECLARATIONS</a>();
01817 
01818     <span class="comment">//</span>
01819     <span class="comment">//  Reference the bitmap header to make the loop run faster</span>
01820     <span class="comment">//</span>
01821 
01822     SizeOfBitMap = <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;SizeOfBitMap;
01823     SizeInBytes = (SizeOfBitMap + 7) / 8;
01824 
01825     <span class="comment">//</span>
01826     <span class="comment">//  Set any unused bits in the last byte so we won't count them.  We do</span>
01827     <span class="comment">//  this by first checking if there is any odd bits in the last byte.</span>
01828     <span class="comment">//</span>
01829 
01830     <span class="keywordflow">if</span> ((SizeOfBitMap % 8) != 0) {
01831 
01832         <span class="comment">//</span>
01833         <span class="comment">//  The last byte has some odd bits so we'll set the high unused</span>
01834         <span class="comment">//  bits in the last byte to 1's</span>
01835         <span class="comment">//</span>
01836 
01837         ((PUCHAR)<a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;Buffer)[SizeInBytes - 1] |= <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a24">ZeroMask</a>[SizeOfBitMap % 8];
01838     }
01839 
01840     <span class="comment">//</span>
01841     <span class="comment">//  Set it up so we can the use GET_BYTE macro</span>
01842     <span class="comment">//</span>
01843 
01844     <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a3">GET_BYTE_INITIALIZATION</a>( BitMapHeader, 0);
01845 
01846     <span class="comment">//</span>
01847     <span class="comment">//  Set our RunIndex and current run variables.  Run Index allays is the index</span>
01848     <span class="comment">//  of the next location to fill in or it could be one beyond the end of the</span>
01849     <span class="comment">//  array.</span>
01850     <span class="comment">//</span>
01851 
01852     RunIndex = 0;
01853     <span class="keywordflow">for</span> (i = 0; i &lt; SizeOfRunArray; i += 1) { RunArray[i].NumberOfBits = 0; }
01854 
01855     CurrentRunSize = 0;
01856     CurrentRunIndex = 0;
01857 
01858     <span class="comment">//</span>
01859     <span class="comment">//  Examine every byte in the BitMap</span>
01860     <span class="comment">//</span>
01861 
01862     <span class="keywordflow">for</span> (CurrentByteIndex = 0;
01863          CurrentByteIndex &lt; SizeInBytes;
01864          CurrentByteIndex += 1) {
01865 
01866         <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a4">GET_BYTE</a>( CurrentByte );
01867 
01868 <span class="preprocessor">#if DBG</span>
01869 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (NtfsDebugIt) { <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"%d: %08lx %08lx %08lx %08lx %08lx\n"</span>,__LINE__,RunIndex,CurrentRunSize,CurrentRunIndex,CurrentByteIndex,CurrentByte); }
01870 <span class="preprocessor">#endif</span>
01871 <span class="preprocessor"></span>
01872         <span class="comment">//</span>
01873         <span class="comment">//  If the current byte is not all zeros we need to (1) check if</span>
01874         <span class="comment">//  the current run is big enough to be inserted in the output</span>
01875         <span class="comment">//  array, and (2) check if the current byte inside of itself can</span>
01876         <span class="comment">//  be inserted, and (3) start a new current run</span>
01877         <span class="comment">//</span>
01878 
01879         <span class="keywordflow">if</span> (CurrentByte != 0x00) {
01880 
01881             <span class="comment">//</span>
01882             <span class="comment">//  Compute the final size of the current run</span>
01883             <span class="comment">//</span>
01884 
01885             CurrentRunSize += <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a20">RtlpBitsClearLow</a>[CurrentByte];
01886 
01887             <span class="comment">//</span>
01888             <span class="comment">//  Check if the current run be stored in the output array by either</span>
01889             <span class="comment">//  there being room in the array or the last entry is smaller than</span>
01890             <span class="comment">//  the current entry</span>
01891             <span class="comment">//</span>
01892 
01893             <span class="keywordflow">if</span> (CurrentRunSize &gt; 0) {
01894 
01895                 <span class="keywordflow">if</span> ((RunIndex &lt; SizeOfRunArray) ||
01896                     (RunArray[RunIndex-1].NumberOfBits &lt; CurrentRunSize)) {
01897 
01898                     <span class="comment">//</span>
01899                     <span class="comment">//  If necessary increment the RunIndex and shift over the output</span>
01900                     <span class="comment">//  array until we find the slot where the new run belongs.  We only</span>
01901                     <span class="comment">//  do the shifting if we're returning longest runs.</span>
01902                     <span class="comment">//</span>
01903 
01904                     <span class="keywordflow">if</span> (RunIndex &lt; SizeOfRunArray) { RunIndex += 1; }
01905 
01906                     <span class="keywordflow">for</span> (j = RunIndex-2; LocateLongestRuns &amp;&amp; (j &gt;= 0) &amp;&amp; (RunArray[j].NumberOfBits &lt; CurrentRunSize); j -= 1) {
01907 
01908                         RunArray[j+1] = RunArray[j];
01909                     }
01910 
01911                     RunArray[j+1].NumberOfBits = CurrentRunSize;
01912                     RunArray[j+1].StartingIndex = CurrentRunIndex;
01913 
01914 <span class="preprocessor">#if DBG</span>
01915 <span class="preprocessor"></span>                    <span class="keywordflow">if</span> (NtfsDebugIt) { <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"%d: %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n"</span>,
01916                         __LINE__,RunIndex,CurrentRunSize,CurrentRunIndex,CurrentByteIndex,CurrentByte,j,RunArray[j+1].NumberOfBits,RunArray[j+1].StartingIndex); }
01917 <span class="preprocessor">#endif</span>
01918 <span class="preprocessor"></span>
01919                     <span class="comment">//</span>
01920                     <span class="comment">//  Now if the array is full and we are not doing longest runs return</span>
01921                     <span class="comment">//  to our caller</span>
01922                     <span class="comment">//</span>
01923 
01924                     <span class="keywordflow">if</span> (!LocateLongestRuns &amp;&amp; (RunIndex &gt;= SizeOfRunArray)) {
01925 
01926                         <span class="keywordflow">return</span> RunIndex;
01927                     }
01928                 }
01929             }
01930 
01931             <span class="comment">//</span>
01932             <span class="comment">//  The next run starts with the remaining clear bits in the</span>
01933             <span class="comment">//  current byte.  We set this up before we check inside the</span>
01934             <span class="comment">//  current byte for a longer run, because the latter test</span>
01935             <span class="comment">//  might require extra work.</span>
01936             <span class="comment">//</span>
01937 
01938             CurrentRunSize = <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a21">RtlpBitsClearHigh</a>[ CurrentByte ];
01939             CurrentRunIndex = (CurrentByteIndex * 8) + (8 - CurrentRunSize);
01940 
01941             <span class="comment">//</span>
01942             <span class="comment">//  Set the low and high bits, otherwise we'll wind up thinking that we have a</span>
01943             <span class="comment">//  small run that needs to get added to the array, but these bits have</span>
01944             <span class="comment">//  just been accounting for</span>
01945             <span class="comment">//</span>
01946 
01947             CurrentByte |= <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a23">FillMask</a>[<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a20">RtlpBitsClearLow</a>[CurrentByte]] |
01948                            <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a24">ZeroMask</a>[8-<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a21">RtlpBitsClearHigh</a>[CurrentByte]];
01949 
01950             <span class="comment">//</span>
01951             <span class="comment">//  Check if the current byte contains a run inside of it that</span>
01952             <span class="comment">//  should go into the output array.  There may be multiple</span>
01953             <span class="comment">//  runs in the byte that we need to insert.</span>
01954             <span class="comment">//</span>
01955 
01956             <span class="keywordflow">while</span> ((CurrentByte != 0xff)
01957 
01958                         &amp;&amp;
01959 
01960                    ((RunIndex &lt; SizeOfRunArray) ||
01961                     (RunArray[RunIndex-1].NumberOfBits &lt; (ULONG)<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a19">RtlpBitsClearAnywhere</a>[CurrentByte]))) {
01962 
01963                 TempNumber = <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a19">RtlpBitsClearAnywhere</a>[CurrentByte];
01964 
01965                 <span class="comment">//</span>
01966                 <span class="comment">//  Somewhere in the current byte is a run to be inserted of</span>
01967                 <span class="comment">//  size TempNumber.  All we need to do is find the index for this run.</span>
01968                 <span class="comment">//</span>
01969 
01970                 BitMask = <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a23">FillMask</a>[ TempNumber ];
01971 
01972                 <span class="keywordflow">for</span> (i = 0; (BitMask &amp; CurrentByte) != 0; i += 1) {
01973 
01974                     BitMask &lt;&lt;= 1;
01975                 }
01976 
01977                 <span class="comment">//</span>
01978                 <span class="comment">//  If necessary increment the RunIndex and shift over the output</span>
01979                 <span class="comment">//  array until we find the slot where the new run belongs.  We only</span>
01980                 <span class="comment">//  do the shifting if we're returning longest runs.</span>
01981                 <span class="comment">//</span>
01982 
01983                 <span class="keywordflow">if</span> (RunIndex &lt; SizeOfRunArray) { RunIndex += 1; }
01984 
01985                 <span class="keywordflow">for</span> (j = RunIndex-2; LocateLongestRuns &amp;&amp; (j &gt;= 0) &amp;&amp; (RunArray[j].NumberOfBits &lt; TempNumber); j -= 1) {
01986 
01987                     RunArray[j+1] = RunArray[j];
01988                 }
01989 
01990                 RunArray[j+1].NumberOfBits = TempNumber;
01991                 RunArray[j+1].StartingIndex = (CurrentByteIndex * 8) + i;
01992 
01993 <span class="preprocessor">#if DBG</span>
01994 <span class="preprocessor"></span>                <span class="keywordflow">if</span> (NtfsDebugIt) { <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"%d: %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n"</span>,
01995                     __LINE__,RunIndex,CurrentRunSize,CurrentRunIndex,CurrentByteIndex,CurrentByte,j,RunArray[j+1].NumberOfBits,RunArray[j+1].StartingIndex); }
01996 <span class="preprocessor">#endif</span>
01997 <span class="preprocessor"></span>
01998                 <span class="comment">//</span>
01999                 <span class="comment">//  Now if the array is full and we are not doing longest runs return</span>
02000                 <span class="comment">//  to our caller</span>
02001                 <span class="comment">//</span>
02002 
02003                 <span class="keywordflow">if</span> (!LocateLongestRuns &amp;&amp; (RunIndex &gt;= SizeOfRunArray)) {
02004 
02005                     <span class="keywordflow">return</span> RunIndex;
02006                 }
02007 
02008                 <span class="comment">//</span>
02009                 <span class="comment">//  Mask out the bits and look for another run in the current byte</span>
02010                 <span class="comment">//</span>
02011 
02012                 CurrentByte |= BitMask;
02013             }
02014 
02015         <span class="comment">//</span>
02016         <span class="comment">//  Otherwise the current byte is all zeros and</span>
02017         <span class="comment">//  we simply continue with the current run</span>
02018         <span class="comment">//</span>
02019 
02020         } <span class="keywordflow">else</span> {
02021 
02022             CurrentRunSize += 8;
02023         }
02024     }
02025 
02026 <span class="preprocessor">#if DBG</span>
02027 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (NtfsDebugIt) { <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"%d: %08lx %08lx %08lx %08lx %08lx\n"</span>,__LINE__,RunIndex,CurrentRunSize,CurrentRunIndex,CurrentByteIndex,CurrentByte); }
02028 <span class="preprocessor">#endif</span>
02029 <span class="preprocessor"></span>
02030     <span class="comment">//</span>
02031     <span class="comment">//  See if we finished looking over the bitmap with an open current</span>
02032     <span class="comment">//  run that should be inserted in the output array</span>
02033     <span class="comment">//</span>
02034 
02035     <span class="keywordflow">if</span> (CurrentRunSize &gt; 0) {
02036 
02037         <span class="keywordflow">if</span> ((RunIndex &lt; SizeOfRunArray) ||
02038             (RunArray[RunIndex-1].NumberOfBits &lt; CurrentRunSize)) {
02039 
02040             <span class="comment">//</span>
02041             <span class="comment">//  If necessary increment the RunIndex and shift over the output</span>
02042             <span class="comment">//  array until we find the slot where the new run belongs.</span>
02043             <span class="comment">//</span>
02044 
02045             <span class="keywordflow">if</span> (RunIndex &lt; SizeOfRunArray) { RunIndex += 1; }
02046 
02047             <span class="keywordflow">for</span> (j = RunIndex-2; LocateLongestRuns &amp;&amp; (j &gt;= 0) &amp;&amp; (RunArray[j].NumberOfBits &lt; CurrentRunSize); j -= 1) {
02048 
02049                 RunArray[j+1] = RunArray[j];
02050             }
02051 
02052             RunArray[j+1].NumberOfBits = CurrentRunSize;
02053             RunArray[j+1].StartingIndex = CurrentRunIndex;
02054 
02055 <span class="preprocessor">#if DBG</span>
02056 <span class="preprocessor"></span>            <span class="keywordflow">if</span> (NtfsDebugIt) { <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"%d: %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n"</span>,
02057                 __LINE__,RunIndex,CurrentRunSize,CurrentRunIndex,CurrentByteIndex,CurrentByte,j,RunArray[j+1].NumberOfBits,RunArray[j+1].StartingIndex); }
02058 <span class="preprocessor">#endif</span>
02059 <span class="preprocessor"></span>        }
02060     }
02061 
02062     <span class="comment">//</span>
02063     <span class="comment">//  Return to our caller</span>
02064     <span class="comment">//</span>
02065 
02066     <span class="keywordflow">return</span> RunIndex;
02067 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a37" doxytag="rtl/bitmap.c::RtlFindFirstRunClear" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ULONG RtlFindFirstRunClear           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PRTL_BITMAP&nbsp;</td>
          <td class="mdname" nowrap> <em>BitMapHeader</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>StartingIndex</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02117">2117</a> of file <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html">rtl/bitmap.c</a>.
<p>
References <a class="el" href="../../d9/d8/tbitmap_8c-source.html#l00027">BitMapHeader</a>, and <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02635">RtlFindNextForwardRunClear()</a>.
<p>
<pre class="fragment"><div>02124                    :
02125 
02126     This <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a69">procedure</a> finds <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> first contiguous range of clear bits
02127     within <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified bit map.
02128 
02129 Arguments:
02130 
02131     <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a> - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> previously initialized <a class="code" href="../../d2/d1/structBitMap.html">BitMap</a>.
02132 
02133     StartingIndex - Receives <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> index (zero based) of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> first run
02134         equal to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> longest run of clear bits in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d1/structBitMap.html">BitMap</a>.
02135 
02136 Return Value:
02137 
02138     ULONG - Receives <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> number of bits contained in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> first contiguous
02139         run of clear bits.
02140 
02141 --*/
02142 
02143 {
02144     <span class="keywordflow">return</span> <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a42">RtlFindNextForwardRunClear</a>(BitMapHeader, 0, StartingIndex);
02145 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a43" doxytag="rtl/bitmap.c::RtlFindLastBackwardRunClear" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ULONG RtlFindLastBackwardRunClear           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PRTL_BITMAP&nbsp;</td>
          <td class="mdname" nowrap> <em>BitMapHeader</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>FromIndex</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>StartingRunIndex</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02779">2779</a> of file <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html">rtl/bitmap.c</a>.
<p>
References <a class="el" href="../../d9/d8/tbitmap_8c-source.html#l00027">BitMapHeader</a>, <a class="el" href="../../d0/d1/config_2i386_2init386_8c-source.html#l00050">End</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02621">FillMaskUlong</a>, <a class="el" href="../../d6/d8/ntrtlp_8h-source.html#l00246">RTL_PAGED_CODE</a>, and <a class="el" href="../../d0/d1/config_2i386_2init386_8c-source.html#l00049">Start</a>.
<p>
<pre class="fragment"><div>02784 {
02785     ULONG <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a18">Start</a>;
02786     ULONG <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a19">End</a>;
02787     PULONG PHunk;
02788     ULONG Hunk;
02789 
02790     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
02791 
02792     <span class="comment">//</span>
02793     <span class="comment">//  Take care of the boundary case of the null bitmap</span>
02794     <span class="comment">//</span>
02795 
02796     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;SizeOfBitMap == 0) {
02797 
02798         *StartingRunIndex = FromIndex;
02799         <span class="keywordflow">return</span> 0;
02800     }
02801 
02802     <span class="comment">//</span>
02803     <span class="comment">//  Scan backwards for the first clear bit</span>
02804     <span class="comment">//</span>
02805 
02806     <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a19">End</a> = FromIndex;
02807 
02808     <span class="comment">//</span>
02809     <span class="comment">//  Build pointer to the ULONG word in the bitmap</span>
02810     <span class="comment">//  containing the End bit, then read in the bitmap</span>
02811     <span class="comment">//  hunk. Set the rest of the bits in this word, NOT</span>
02812     <span class="comment">//  inclusive of the FromIndex bit.</span>
02813     <span class="comment">//</span>
02814 
02815     PHunk = <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;Buffer + (<a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a19">End</a> / 32);
02816     Hunk = *PHunk | ~<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a25">FillMaskUlong</a>[(<a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a19">End</a> % 32) + 1];
02817 
02818     <span class="comment">//</span>
02819     <span class="comment">//  If the first subword is set then we can proceed to</span>
02820     <span class="comment">//  take big steps in the bitmap since we are now ULONG</span>
02821     <span class="comment">//  aligned in the search</span>
02822     <span class="comment">//</span>
02823 
02824     <span class="keywordflow">if</span> (Hunk == (ULONG)~0) {
02825 
02826         <span class="comment">//</span>
02827         <span class="comment">//  Adjust the pointers backwards</span>
02828         <span class="comment">//</span>
02829 
02830         <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a19">End</a> -= (<a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a19">End</a> % 32) + 1;
02831         PHunk--;
02832 
02833         <span class="keywordflow">while</span> ( PHunk &gt; <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;Buffer ) {
02834 
02835             <span class="comment">//</span>
02836             <span class="comment">//  Stop at first word with set bits</span>
02837             <span class="comment">//</span>
02838 
02839             <span class="keywordflow">if</span> (*PHunk != (ULONG)~0) <span class="keywordflow">break</span>;
02840 
02841             PHunk--;
02842             <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a19">End</a> -= 32;
02843         }
02844     }
02845 
02846     <span class="comment">//</span>
02847     <span class="comment">//  Bitwise search backward for the clear bit</span>
02848     <span class="comment">//</span>
02849 
02850     <span class="keywordflow">while</span> ((<a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a19">End</a> != MAXULONG) &amp;&amp; (RtlCheckBit( BitMapHeader, End ) == 1)) { <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a19">End</a> -= 1; }
02851 
02852     <span class="comment">//</span>
02853     <span class="comment">//  Scan backwards for the first set bit</span>
02854     <span class="comment">//</span>
02855 
02856     <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a18">Start</a> = <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a19">End</a>;
02857 
02858     <span class="comment">//</span>
02859     <span class="comment">//  We know that the clear bit was in the last word we looked at,</span>
02860     <span class="comment">//  so continue from there to find the next set bit, clearing the</span>
02861     <span class="comment">//  previous bits in the word.</span>
02862     <span class="comment">//</span>
02863 
02864     Hunk = *PHunk &amp; <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a25">FillMaskUlong</a>[<a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a18">Start</a> % 32];
02865 
02866     <span class="comment">//</span>
02867     <span class="comment">//  If the subword is unset then we can proceed in big steps</span>
02868     <span class="comment">//</span>
02869 
02870     <span class="keywordflow">if</span> (Hunk == (ULONG)0) {
02871 
02872         <span class="comment">//</span>
02873         <span class="comment">//  Adjust the pointers backward</span>
02874         <span class="comment">//</span>
02875 
02876         <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a18">Start</a> -= (<a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a18">Start</a> % 32) + 1;
02877         PHunk--;
02878 
02879         <span class="keywordflow">while</span> ( PHunk &gt; <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;Buffer ) {
02880 
02881             <span class="comment">//</span>
02882             <span class="comment">//  Stop at first word with set bits</span>
02883             <span class="comment">//</span>
02884 
02885             <span class="keywordflow">if</span> (*PHunk != (ULONG)0) <span class="keywordflow">break</span>;
02886 
02887             PHunk--;
02888             <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a18">Start</a> -= 32;
02889         }
02890     }
02891 
02892     <span class="comment">//</span>
02893     <span class="comment">//  Bitwise search backward for the set bit</span>
02894     <span class="comment">//</span>
02895 
02896     <span class="keywordflow">while</span> ((<a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a18">Start</a> != MAXULONG) &amp;&amp; (RtlCheckBit( BitMapHeader, Start ) == 0)) { <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a18">Start</a> -= 1; }
02897 
02898     <span class="comment">//</span>
02899     <span class="comment">//  Compute the index and return the length</span>
02900     <span class="comment">//</span>
02901 
02902     *StartingRunIndex = <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a18">Start</a> + 1;
02903     <span class="keywordflow">return</span> (<a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a19">End</a> - <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a18">Start</a>);
02904 }
</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a45" doxytag="rtl/bitmap.c::RtlFindLeastSignificantBit" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> CCHAR RtlFindLeastSignificantBit           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN ULONGLONG&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>Set</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02999">2999</a> of file <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html">rtl/bitmap.c</a>.
<p>
References <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02916">BM_0</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02915">BM_01</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02914">BM_0123</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02917">BM_2</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02919">BM_4</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02918">BM_45</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02920">BM_6</a>, and <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00145">RtlpBitsClearLow</a>.
<p>
<pre class="fragment"><div>03004                    :
03005 
03006     This <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a69">procedure</a> finds <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> least significant non-zero bit in Set and
03007     returns <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a>'s zero-based position.
03008 
03009 Arguments:
03010 
03011     Set - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> 64-bit bitmap.
03012 
03013 Return Value:
03014 
03015     Set != 0:
03016         Bit position of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> least significant non-zero bit in Set.
03017 
03018     Set == 0:
03019         -1.
03020 
03021 --*/
03022 {
03023     UCHAR index;
03024     UCHAR bitOffset;
03025     UCHAR lookup;
03026 
03027     <span class="keywordflow">if</span> ((Set &amp; <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a12">BM_0123</a>) != 0) {
03028         <span class="keywordflow">if</span> ((Set &amp; <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a13">BM_01</a>) != 0) {
03029             <span class="keywordflow">if</span> ((Set &amp; <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a14">BM_0</a>) != 0) {
03030                 bitOffset = 0 * 8;
03031             } <span class="keywordflow">else</span> {
03032                 bitOffset = 1 * 8;
03033             }
03034         } <span class="keywordflow">else</span> {
03035             <span class="keywordflow">if</span> ((Set &amp; <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a15">BM_2</a>) != 0) {
03036                 bitOffset = 2 * 8;
03037             } <span class="keywordflow">else</span> {
03038                 bitOffset = 3 * 8;
03039             }
03040         }
03041     } <span class="keywordflow">else</span> {
03042         <span class="keywordflow">if</span> ((Set &amp; <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a16">BM_45</a>) != 0) {
03043             <span class="keywordflow">if</span> ((Set &amp; <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a17">BM_4</a>) != 0) {
03044                 bitOffset = 4 * 8;
03045             } <span class="keywordflow">else</span> {
03046                 bitOffset = 5 * 8;
03047             }
03048         } <span class="keywordflow">else</span> {
03049             <span class="keywordflow">if</span> ((Set &amp; <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a18">BM_6</a>) != 0) {
03050                 bitOffset = 6 * 8;
03051             } <span class="keywordflow">else</span> {
03052 
03053                 <span class="comment">//</span>
03054                 <span class="comment">// The test for Set == 0 is postponed to here, it is expected</span>
03055                 <span class="comment">// to be rare.  Note that if we had our own version of</span>
03056                 <span class="comment">// RtlpBitsClearHigh[] we could eliminate this test entirely,</span>
03057                 <span class="comment">// reducing the average number of tests from 3.125 to 3.</span>
03058                 <span class="comment">//</span>
03059 
03060                 <span class="keywordflow">if</span> (Set == 0) {
03061                     <span class="keywordflow">return</span> -1;
03062                 }
03063 
03064                 bitOffset = 7 * 8;
03065             }
03066         }
03067     }
03068 
03069     lookup = (UCHAR)(Set &gt;&gt; bitOffset);
03070     index = <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a20">RtlpBitsClearLow</a>[lookup] + bitOffset;
03071     <span class="keywordflow">return</span> index;
03072 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a36" doxytag="rtl/bitmap.c::RtlFindLongestRunClear" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ULONG RtlFindLongestRunClear           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PRTL_BITMAP&nbsp;</td>
          <td class="mdname" nowrap> <em>BitMapHeader</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>StartingIndex</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02071">2071</a> of file <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html">rtl/bitmap.c</a>.
<p>
References <a class="el" href="../../d9/d8/tbitmap_8c-source.html#l00027">BitMapHeader</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l01764">RtlFindClearRuns()</a>, and <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>.
<p>
<pre class="fragment"><div>02078                    :
02079 
02080     This <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a69">procedure</a> finds <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> largest contiguous range of clear bits
02081     within <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified bit map.
02082 
02083 Arguments:
02084 
02085     <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a> - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> previously initialized <a class="code" href="../../d2/d1/structBitMap.html">BitMap</a>.
02086 
02087     StartingIndex - Receives <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> index (zero based) of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> first run
02088         equal to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> longest run of clear bits in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d1/structBitMap.html">BitMap</a>.
02089 
02090 Return Value:
02091 
02092     ULONG - Receives <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> number of bits contained in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> largest contiguous
02093         run of clear bits.
02094 
02095 --*/
02096 
02097 {
02098     RTL_BITMAP_RUN RunArray[1];
02099 
02100     <span class="comment">//</span>
02101     <span class="comment">//  Locate the longest run in the bitmap.  If there is one then</span>
02102     <span class="comment">//  return that run otherwise return the error condition.</span>
02103     <span class="comment">//</span>
02104 
02105     <span class="keywordflow">if</span> (<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a35">RtlFindClearRuns</a>( BitMapHeader, RunArray, 1, TRUE ) == 1) {
02106 
02107         *StartingIndex = RunArray[0].StartingIndex;
02108         <span class="keywordflow">return</span> RunArray[0].NumberOfBits;
02109     }
02110 
02111     *StartingIndex = 0;
02112     <span class="keywordflow">return</span> 0;
02113 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a44" doxytag="rtl/bitmap.c::RtlFindMostSignificantBit" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> CCHAR RtlFindMostSignificantBit           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN ULONGLONG&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>Set</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02923">2923</a> of file <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html">rtl/bitmap.c</a>.
<p>
References <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02912">BM_1</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02910">BM_23</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02911">BM_3</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02906">BM_4567</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02909">BM_5</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02907">BM_67</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02908">BM_7</a>, and <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00168">RtlpBitsClearHigh</a>.
<p>
Referenced by <a class="el" href="../../d4/d5/allocvm_8c-source.html#l00075">NtAllocateVirtualMemory()</a>, and <a class="el" href="../../d4/d4/mapview_8c-source.html#l00199">NtMapViewOfSection()</a>.
<p>
<pre class="fragment"><div>02928                    :
02929 
02930     This <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a69">procedure</a> finds <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> most significant non-zero bit in Set and
02931     returns <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a>'s zero-based position.
02932 
02933 Arguments:
02934 
02935     Set - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> 64-bit bitmap.
02936 
02937 Return Value:
02938 
02939     Set != 0:
02940         Bit position of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> most significant set bit in Set.
02941 
02942     Set == 0:
02943         -1.
02944 
02945 --*/
02946 {
02947     UCHAR index;
02948     UCHAR bitOffset;
02949     UCHAR lookup;
02950 
02951     <span class="keywordflow">if</span> ((Set &amp; <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a5">BM_4567</a>) != 0) {
02952         <span class="keywordflow">if</span> ((Set &amp; <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a6">BM_67</a>) != 0) {
02953             <span class="keywordflow">if</span> ((Set &amp; <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a7">BM_7</a>) != 0) {
02954                 bitOffset = 7 * 8;
02955             } <span class="keywordflow">else</span> {
02956                 bitOffset = 6 * 8;
02957             }
02958         } <span class="keywordflow">else</span> {
02959             <span class="keywordflow">if</span> ((Set &amp; <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a8">BM_5</a>) != 0) {
02960                 bitOffset = 5 * 8;
02961             } <span class="keywordflow">else</span> {
02962                 bitOffset = 4 * 8;
02963             }
02964         }
02965     } <span class="keywordflow">else</span> {
02966         <span class="keywordflow">if</span> ((Set &amp; <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a9">BM_23</a>) != 0) {
02967             <span class="keywordflow">if</span> ((Set &amp; <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a10">BM_3</a>) != 0) {
02968                 bitOffset = 3 * 8;
02969             } <span class="keywordflow">else</span> {
02970                 bitOffset = 2 * 8;
02971             }
02972         } <span class="keywordflow">else</span> {
02973             <span class="keywordflow">if</span> ((Set &amp; <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a11">BM_1</a>) != 0) {
02974                 bitOffset = 1 * 8;
02975             } <span class="keywordflow">else</span> {
02976 
02977                 <span class="comment">//</span>
02978                 <span class="comment">// The test for Set == 0 is postponed to here, it is expected</span>
02979                 <span class="comment">// to be rare.  Note that if we had our own version of</span>
02980                 <span class="comment">// RtlpBitsClearHigh[] we could eliminate this test entirely,</span>
02981                 <span class="comment">// reducing the average number of tests from 3.125 to 3.</span>
02982                 <span class="comment">//</span>
02983 
02984                 <span class="keywordflow">if</span> (Set == 0) {
02985                     <span class="keywordflow">return</span> -1;
02986                 }
02987 
02988                 bitOffset = 0 * 8;
02989             }
02990         }
02991     }
02992 
02993     lookup = (UCHAR)(Set &gt;&gt; bitOffset);
02994     index = (7 - <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a21">RtlpBitsClearHigh</a>[lookup]) + bitOffset;
02995     <span class="keywordflow">return</span> index;
02996 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a42" doxytag="rtl/bitmap.c::RtlFindNextForwardRunClear" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ULONG RtlFindNextForwardRunClear           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PRTL_BITMAP&nbsp;</td>
          <td class="mdname" nowrap> <em>BitMapHeader</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>FromIndex</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>StartingRunIndex</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02635">2635</a> of file <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html">rtl/bitmap.c</a>.
<p>
References <a class="el" href="../../d9/d8/tbitmap_8c-source.html#l00027">BitMapHeader</a>, <a class="el" href="../../d0/d1/config_2i386_2init386_8c-source.html#l00050">End</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02621">FillMaskUlong</a>, and <a class="el" href="../../d0/d1/config_2i386_2init386_8c-source.html#l00049">Start</a>.
<p>
Referenced by <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02117">RtlFindFirstRunClear()</a>.
<p>
<pre class="fragment"><div>02640 {
02641     ULONG <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a18">Start</a>;
02642     ULONG <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a19">End</a>;
02643     PULONG PHunk, BitMapEnd;
02644     ULONG Hunk;
02645 
02646     <span class="comment">//</span>
02647     <span class="comment">// Take care of the boundary case of the null bitmap</span>
02648     <span class="comment">//</span>
02649 
02650     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;SizeOfBitMap == 0) {
02651 
02652         *StartingRunIndex = FromIndex;
02653         <span class="keywordflow">return</span> 0;
02654     }
02655 
02656     <span class="comment">//</span>
02657     <span class="comment">//  Compute the last word address in the bitmap</span>
02658     <span class="comment">//</span>
02659 
02660     BitMapEnd = <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;Buffer + ((<a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;SizeOfBitMap - 1) / 32);
02661 
02662     <span class="comment">//</span>
02663     <span class="comment">//  Scan forward for the first clear bit</span>
02664     <span class="comment">//</span>
02665 
02666     <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a18">Start</a> = FromIndex;
02667 
02668     <span class="comment">//</span>
02669     <span class="comment">//  Build pointer to the ULONG word in the bitmap</span>
02670     <span class="comment">//  containing the Start bit</span>
02671     <span class="comment">//</span>
02672 
02673     PHunk = <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;Buffer + (<a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a18">Start</a> / 32);
02674 
02675     <span class="comment">//</span>
02676     <span class="comment">//  If the first subword is set then we can proceed to</span>
02677     <span class="comment">//  take big steps in the bitmap since we are now ULONG</span>
02678     <span class="comment">//  aligned in the search. Make sure we aren't improperly</span>
02679     <span class="comment">//  looking at the last word in the bitmap.</span>
02680     <span class="comment">//</span>
02681 
02682     <span class="keywordflow">if</span> (PHunk != BitMapEnd) {
02683 
02684         <span class="comment">//</span>
02685         <span class="comment">//  Read in the bitmap hunk. Set the previous bits in this word.</span>
02686         <span class="comment">//</span>
02687 
02688         Hunk = *PHunk | <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a25">FillMaskUlong</a>[<a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a18">Start</a> % 32];
02689 
02690         <span class="keywordflow">if</span> (Hunk == (ULONG)~0) {
02691 
02692             <span class="comment">//</span>
02693             <span class="comment">//  Adjust the pointers forward</span>
02694             <span class="comment">//</span>
02695 
02696             <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a18">Start</a> += 32 - (<a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a18">Start</a> % 32);
02697             PHunk++;
02698 
02699             <span class="keywordflow">while</span> ( PHunk &lt; BitMapEnd ) {
02700 
02701                 <span class="comment">//</span>
02702                 <span class="comment">//  Stop at first word with unset bits</span>
02703                 <span class="comment">//</span>
02704 
02705                 <span class="keywordflow">if</span> (*PHunk != (ULONG)~0) <span class="keywordflow">break</span>;
02706 
02707                 PHunk++;
02708                 <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a18">Start</a> += 32;
02709             }
02710         }
02711     }
02712 
02713     <span class="comment">//</span>
02714     <span class="comment">//  Bitwise search forward for the clear bit</span>
02715     <span class="comment">//</span>
02716 
02717     <span class="keywordflow">while</span> ((<a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a18">Start</a> &lt; <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;SizeOfBitMap) &amp;&amp; (RtlCheckBit( BitMapHeader, Start ) == 1)) { <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a18">Start</a> += 1; }
02718 
02719     <span class="comment">//</span>
02720     <span class="comment">//  Scan forward for the first set bit</span>
02721     <span class="comment">//</span>
02722 
02723     <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a19">End</a> = <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a18">Start</a>;
02724 
02725     <span class="comment">//</span>
02726     <span class="comment">//  If we aren't in the last word of the bitmap we may be</span>
02727     <span class="comment">//  able to keep taking big steps</span>
02728     <span class="comment">//</span>
02729 
02730     <span class="keywordflow">if</span> (PHunk != BitMapEnd) {
02731 
02732         <span class="comment">//</span>
02733         <span class="comment">//  We know that the clear bit was in the last word we looked at,</span>
02734         <span class="comment">//  so continue from there to find the next set bit, clearing the</span>
02735         <span class="comment">//  previous bits in the word</span>
02736         <span class="comment">//</span>
02737 
02738         Hunk = *PHunk &amp; ~<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a25">FillMaskUlong</a>[<a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a19">End</a> % 32];
02739 
02740         <span class="keywordflow">if</span> (Hunk == (ULONG)0) {
02741 
02742             <span class="comment">//</span>
02743             <span class="comment">//  Adjust the pointers forward</span>
02744             <span class="comment">//</span>
02745 
02746             <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a19">End</a> += 32 - (<a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a19">End</a> % 32);
02747             PHunk++;
02748 
02749             <span class="keywordflow">while</span> ( PHunk &lt; BitMapEnd ) {
02750 
02751                 <span class="comment">//</span>
02752                 <span class="comment">//  Stop at first word with set bits</span>
02753                 <span class="comment">//</span>
02754 
02755                 <span class="keywordflow">if</span> (*PHunk != (ULONG)0) <span class="keywordflow">break</span>;
02756 
02757                 PHunk++;
02758                 <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a19">End</a> += 32;
02759             }
02760         }
02761     }
02762 
02763     <span class="comment">//</span>
02764     <span class="comment">//  Bitwise search forward for the set bit</span>
02765     <span class="comment">//</span>
02766 
02767     <span class="keywordflow">while</span> ((<a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a19">End</a> &lt; <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;SizeOfBitMap) &amp;&amp; (RtlCheckBit( BitMapHeader, End ) == 0)) { <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a19">End</a> += 1; }
02768 
02769     <span class="comment">//</span>
02770     <span class="comment">//  Compute the index and return the length</span>
02771     <span class="comment">//</span>
02772 
02773     *StartingRunIndex = <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a18">Start</a>;
02774     <span class="keywordflow">return</span> (<a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a19">End</a> - <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a18">Start</a>);
02775 }
</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a30" doxytag="rtl/bitmap.c::RtlFindSetBits" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ULONG RtlFindSetBits           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PRTL_BITMAP&nbsp;</td>
          <td class="mdname" nowrap> <em>BitMapHeader</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>NumberToFind</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>HintIndex</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00866">866</a> of file <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html">rtl/bitmap.c</a>.
<p>
References <a class="el" href="../../d9/d8/tbitmap_8c-source.html#l00027">BitMapHeader</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00213">FillMask</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00112">GET_BYTE</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00105">GET_BYTE_DECLARATIONS</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00108">GET_BYTE_INITIALIZATION</a>, <a class="el" href="../../d6/d8/ntrtlp_8h-source.html#l00144">RtlpBitSetAnywhere</a>, <a class="el" href="../../d6/d8/ntrtlp_8h-source.html#l00160">RtlpBitsSetHigh</a>, <a class="el" href="../../d6/d8/ntrtlp_8h-source.html#l00152">RtlpBitsSetLow</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, and <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00215">ZeroMask</a>.
<p>
Referenced by <a class="el" href="../../d9/d4/physical_8c-source.html#l02313">MiCleanPhysicalProcessPages()</a>, <a class="el" href="../../d9/d4/physical_8c-source.html#l00970">NtAllocateUserPhysicalPages()</a>, and <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l01448">RtlFindSetBitsAndClear()</a>.
<p>
<pre class="fragment"><div>00874                    :
00875 
00876     This <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a69">procedure</a> searches <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified bit map <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified
00877     contiguous region of set bits.
00878 
00879 Arguments:
00880 
00881     <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a> - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> previously initialized <a class="code" href="../../d2/d1/structBitMap.html">BitMap</a>.
00882 
00883     NumberToFind - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> size of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> contiguous region to find.
00884 
00885     HintIndex - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> index (zero based) of where we should start
00886         <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> search from within <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> bitmap.
00887 
00888 Return Value:
00889 
00890     ULONG - Receives <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> starting index (zero based) of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> contiguous
00891         region of set bits found.  If such a region cannot be found then
00892         a -1 (i.e., 0xffffffff) <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> returned.
00893 
00894 --*/
00895 
00896 {
00897     ULONG SizeOfBitMap;
00898     ULONG SizeInBytes;
00899 
00900     ULONG HintBit;
00901     ULONG MainLoopIndex;
00902 
00903     <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a2">GET_BYTE_DECLARATIONS</a>();
00904 
00905     <span class="comment">//</span>
00906     <span class="comment">//  To make the loops in our test run faster we'll extract the</span>
00907     <span class="comment">//  fields from the bitmap header</span>
00908     <span class="comment">//</span>
00909 
00910     SizeOfBitMap = <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;SizeOfBitMap;
00911     SizeInBytes = (SizeOfBitMap + 7) / 8;
00912 
00913     <span class="comment">//</span>
00914     <span class="comment">//  Set any unused bits in the last byte so we won't count them.  We do</span>
00915     <span class="comment">//  this by first checking if there is any odd bits in the last byte.</span>
00916     <span class="comment">//</span>
00917 
00918     <span class="keywordflow">if</span> ((SizeOfBitMap % 8) != 0) {
00919 
00920         <span class="comment">//</span>
00921         <span class="comment">//  The last byte has some odd bits so we'll set the high unused</span>
00922         <span class="comment">//  bits in the last byte to 0's</span>
00923         <span class="comment">//</span>
00924 
00925         ((PUCHAR)<a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;Buffer)[SizeInBytes - 1] &amp;=
00926                                                     <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a23">FillMask</a>[SizeOfBitMap % 8];
00927     }
00928 
00929     <span class="comment">//</span>
00930     <span class="comment">//  Calculate from the hint index where the hint byte is and set ourselves</span>
00931     <span class="comment">//  up to read the hint on the next call to GET_BYTE.  To make the</span>
00932     <span class="comment">//  algorithm run fast we'll only honor hints down to the byte level of</span>
00933     <span class="comment">//  granularity.  There is a possibility that we'll need to execute</span>
00934     <span class="comment">//  our main logic twice.  Once to test from the hint byte to the end of</span>
00935     <span class="comment">//  the bitmap and the other to test from the start of the bitmap.  First</span>
00936     <span class="comment">//  we need to make sure the Hint Index is within range.</span>
00937     <span class="comment">//</span>
00938 
00939     <span class="keywordflow">if</span> (HintIndex &gt;= SizeOfBitMap) {
00940 
00941         HintIndex = 0;
00942     }
00943 
00944     HintBit = HintIndex % 8;
00945 
00946     <span class="keywordflow">for</span> (MainLoopIndex = 0; MainLoopIndex &lt; 2; MainLoopIndex += 1) {
00947 
00948         ULONG StartByteIndex;
00949         ULONG EndByteIndex;
00950 
00951         UCHAR CurrentByte;
00952 
00953         <span class="comment">//</span>
00954         <span class="comment">//  Check for the first time through the main loop, which indicates</span>
00955         <span class="comment">//  that we are going to start our search at our hint byte</span>
00956         <span class="comment">//</span>
00957 
00958         <span class="keywordflow">if</span> (MainLoopIndex == 0) {
00959 
00960             StartByteIndex = HintIndex / 8;
00961             EndByteIndex = SizeInBytes;
00962 
00963         <span class="comment">//</span>
00964         <span class="comment">//  This is the second time through the loop, make sure there is</span>
00965         <span class="comment">//  actually something to check before the hint byte</span>
00966         <span class="comment">//</span>
00967 
00968         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (HintIndex != 0) {
00969 
00970             <span class="comment">//</span>
00971             <span class="comment">//  The end index for the second time around is based on the</span>
00972             <span class="comment">//  number of bits we need to find.  We need to use this inorder</span>
00973             <span class="comment">//  to take the case where the preceding byte to the hint byte</span>
00974             <span class="comment">//  is the start of our run, and the run includes the hint byte</span>
00975             <span class="comment">//  and some following bytes, based on the number of bits needed</span>
00976             <span class="comment">//  The computation is to take the number of bits needed minus</span>
00977             <span class="comment">//  2 divided by 8 and then add 2.  This will take in to account</span>
00978             <span class="comment">//  the worst possible case where we have one bit hanging off</span>
00979             <span class="comment">//  of each end byte, and all intervening bytes are all zero.</span>
00980             <span class="comment">//  We only need to add one in the following equation because</span>
00981             <span class="comment">//  HintByte is already counted.</span>
00982             <span class="comment">//</span>
00983 
00984             <span class="keywordflow">if</span> (NumberToFind &lt; 2) {
00985 
00986                 EndByteIndex = HintIndex / 8;
00987 
00988             } <span class="keywordflow">else</span> {
00989 
00990                 EndByteIndex = HintIndex / 8 + ((NumberToFind - 2) / 8) + 1;
00991 
00992                 <span class="comment">//</span>
00993                 <span class="comment">//  Make sure we don't overrun the end of the bitmap</span>
00994                 <span class="comment">//</span>
00995 
00996                 <span class="keywordflow">if</span> (EndByteIndex &gt; SizeInBytes) {
00997 
00998                     EndByteIndex = SizeInBytes;
00999                 }
01000             }
01001 
01002             StartByteIndex = 0;
01003             HintIndex = 0;
01004             HintBit = 0;
01005 
01006         <span class="comment">//</span>
01007         <span class="comment">//  Otherwise we already did a complete loop through the bitmap</span>
01008         <span class="comment">//  so we should simply return -1 to say nothing was found</span>
01009         <span class="comment">//</span>
01010 
01011         } <span class="keywordflow">else</span> {
01012 
01013             <span class="keywordflow">return</span> 0xffffffff;
01014         }
01015 
01016         <span class="comment">//</span>
01017         <span class="comment">//  Set ourselves up to get the next byte</span>
01018         <span class="comment">//</span>
01019 
01020         <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a3">GET_BYTE_INITIALIZATION</a>(BitMapHeader, StartByteIndex);
01021 
01022         <span class="comment">//</span>
01023         <span class="comment">//  Get the first byte, and clear any bits before the hint bit.</span>
01024         <span class="comment">//</span>
01025 
01026         <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a4">GET_BYTE</a>( CurrentByte );
01027 
01028         CurrentByte &amp;= <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a24">ZeroMask</a>[HintBit];
01029 
01030         <span class="comment">//</span>
01031         <span class="comment">//  If the number of bits can only fit in 1 or 2 bytes (i.e., 9 bits or</span>
01032         <span class="comment">//  less) we do the following test case.</span>
01033         <span class="comment">//</span>
01034 
01035         <span class="keywordflow">if</span> (NumberToFind &lt;= 9) {
01036 
01037             ULONG CurrentBitIndex;
01038 
01039             UCHAR PreviousByte;
01040 
01041             PreviousByte = 0x00;
01042 
01043             <span class="comment">//</span>
01044             <span class="comment">//  Examine all the bytes within our test range searching</span>
01045             <span class="comment">//  for a fit</span>
01046             <span class="comment">//</span>
01047 
01048             CurrentBitIndex = StartByteIndex * 8;
01049 
01050             <span class="keywordflow">while</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
01051 
01052                 <span class="comment">//</span>
01053                 <span class="comment">//  Check to see if the current byte coupled with the previous</span>
01054                 <span class="comment">//  byte will satisfy the requirement. The check uses the high</span>
01055                 <span class="comment">//  part of the previous byte and low part of the current byte.</span>
01056                 <span class="comment">//</span>
01057 
01058                 <span class="keywordflow">if</span> (((ULONG)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a2">RtlpBitsSetHigh</a>(PreviousByte) +
01059                              (ULONG)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a1">RtlpBitsSetLow</a>(CurrentByte)) &gt;= NumberToFind) {
01060 
01061                     ULONG StartingIndex;
01062 
01063                     <span class="comment">//</span>
01064                     <span class="comment">//  It all fits in these two bytes, so we can compute</span>
01065                     <span class="comment">//  the starting index.  This is done by taking the</span>
01066                     <span class="comment">//  index of the current byte (bit 0) and subtracting the</span>
01067                     <span class="comment">//  number of bits its takes to get to the first set</span>
01068                     <span class="comment">//  high bit.</span>
01069                     <span class="comment">//</span>
01070 
01071                     StartingIndex = CurrentBitIndex -
01072                                                (LONG)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a2">RtlpBitsSetHigh</a>(PreviousByte);
01073 
01074                     <span class="comment">//</span>
01075                     <span class="comment">//  Now make sure the total size isn't beyond the bitmap</span>
01076                     <span class="comment">//</span>
01077 
01078                     <span class="keywordflow">if</span> ((StartingIndex + NumberToFind) &lt;= SizeOfBitMap) {
01079 
01080                         <span class="keywordflow">return</span> StartingIndex;
01081                     }
01082                 }
01083 
01084                 <span class="comment">//</span>
01085                 <span class="comment">//  The previous byte does not help, so check the current byte.</span>
01086                 <span class="comment">//</span>
01087 
01088                 <span class="keywordflow">if</span> ((ULONG)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a0">RtlpBitSetAnywhere</a>(CurrentByte) &gt;= NumberToFind) {
01089 
01090                     UCHAR BitMask;
01091                     ULONG i;
01092 
01093                     <span class="comment">//</span>
01094                     <span class="comment">//  It all fits in a single byte, so calculate the bit</span>
01095                     <span class="comment">//  number.  We do this by taking a mask of the appropriate</span>
01096                     <span class="comment">//  size and shifting it over until it fits.  It fits when</span>
01097                     <span class="comment">//  we can bitwise-and the current byte with the bit mask</span>
01098                     <span class="comment">//  and get back the bit mask.</span>
01099                     <span class="comment">//</span>
01100 
01101                     BitMask = <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a23">FillMask</a>[ NumberToFind ];
01102                     <span class="keywordflow">for</span> (i = 0; (BitMask &amp; CurrentByte) != BitMask; i += 1) {
01103 
01104                         BitMask &lt;&lt;= 1;
01105                     }
01106 
01107                     <span class="comment">//</span>
01108                     <span class="comment">//  return to our caller the located bit index, and the</span>
01109                     <span class="comment">//  number that we found.</span>
01110                     <span class="comment">//</span>
01111 
01112                     <span class="keywordflow">return</span> CurrentBitIndex + i;
01113                 }
01114 
01115                 <span class="comment">//</span>
01116                 <span class="comment">//  For the next iteration through our loop we need to make</span>
01117                 <span class="comment">//  the current byte into the previous byte, and go to the</span>
01118                 <span class="comment">//  top of the loop again.</span>
01119                 <span class="comment">//</span>
01120 
01121                 PreviousByte = CurrentByte;
01122 
01123                 <span class="comment">//</span>
01124                 <span class="comment">//  Increment our Bit Index, and either exit, or get the</span>
01125                 <span class="comment">//  next byte.</span>
01126                 <span class="comment">//</span>
01127 
01128                 CurrentBitIndex += 8;
01129 
01130                 <span class="keywordflow">if</span> ( CurrentBitIndex &lt; EndByteIndex * 8 ) {
01131 
01132                     <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a4">GET_BYTE</a>( CurrentByte );
01133 
01134                 } <span class="keywordflow">else</span> {
01135 
01136                     <span class="keywordflow">break</span>;
01137                 }
01138 
01139             } <span class="comment">// end loop CurrentBitIndex</span>
01140 
01141         <span class="comment">//</span>
01142         <span class="comment">//  The number to find is greater than 9 but if it is less than 15</span>
01143         <span class="comment">//  then we know it can be satisfied with at most 2 bytes, or 3 bytes</span>
01144         <span class="comment">//  if the middle byte (of the 3) is all ones.</span>
01145         <span class="comment">//</span>
01146 
01147         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (NumberToFind &lt; 15) {
01148 
01149             ULONG CurrentBitIndex;
01150 
01151             UCHAR PreviousPreviousByte;
01152             UCHAR PreviousByte;
01153 
01154             PreviousByte = 0x00;
01155 
01156             <span class="comment">//</span>
01157             <span class="comment">//  Examine all the bytes within our test range searching</span>
01158             <span class="comment">//  for a fit</span>
01159             <span class="comment">//</span>
01160 
01161             CurrentBitIndex = StartByteIndex * 8;
01162 
01163             <span class="keywordflow">while</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
01164 
01165                 <span class="comment">//</span>
01166                 <span class="comment">//  For the next iteration through our loop we need to make</span>
01167                 <span class="comment">//  the current byte into the previous byte, the previous</span>
01168                 <span class="comment">//  byte into the previous previous byte, and go to the</span>
01169                 <span class="comment">//  top of the loop again.</span>
01170                 <span class="comment">//</span>
01171 
01172                 PreviousPreviousByte = PreviousByte;
01173                 PreviousByte = CurrentByte;
01174 
01175                 <span class="comment">//</span>
01176                 <span class="comment">//  Increment our Bit Index, and either exit, or get the</span>
01177                 <span class="comment">//  next byte.</span>
01178                 <span class="comment">//</span>
01179 
01180                 CurrentBitIndex += 8;
01181 
01182                 <span class="keywordflow">if</span> ( CurrentBitIndex &lt; EndByteIndex * 8 ) {
01183 
01184                     <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a4">GET_BYTE</a>( CurrentByte );
01185 
01186                 } <span class="keywordflow">else</span> {
01187 
01188                     <span class="keywordflow">break</span>;
01189                 }
01190 
01191                 <span class="comment">//</span>
01192                 <span class="comment">//  if the previous byte is all ones then maybe the</span>
01193                 <span class="comment">//  request can be satisfied using the Previous Previous Byte</span>
01194                 <span class="comment">//  Previous Byte, and the Current Byte.</span>
01195                 <span class="comment">//</span>
01196 
01197                 <span class="keywordflow">if</span> ((PreviousByte == 0xff)
01198 
01199                         &amp;&amp;
01200 
01201                     (((ULONG)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a2">RtlpBitsSetHigh</a>(PreviousPreviousByte) + 8 +
01202                             (ULONG)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a1">RtlpBitsSetLow</a>(CurrentByte)) &gt;= NumberToFind)) {
01203 
01204                     ULONG StartingIndex;
01205 
01206                     <span class="comment">//</span>
01207                     <span class="comment">//  It all fits in these three bytes, so we can compute</span>
01208                     <span class="comment">//  the starting index.  This is done by taking the</span>
01209                     <span class="comment">//  index of the previous byte (bit 0) and subtracting</span>
01210                     <span class="comment">//  the number of bits its takes to get to the first</span>
01211                     <span class="comment">//  set high bit.</span>
01212                     <span class="comment">//</span>
01213 
01214                     StartingIndex = (CurrentBitIndex - 8) -
01215                                        (LONG)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a2">RtlpBitsSetHigh</a>(PreviousPreviousByte);
01216 
01217                     <span class="comment">//</span>
01218                     <span class="comment">//  Now make sure the total size isn't beyond the bitmap</span>
01219                     <span class="comment">//</span>
01220 
01221                     <span class="keywordflow">if</span> ((StartingIndex + NumberToFind) &lt;= SizeOfBitMap) {
01222 
01223                         <span class="keywordflow">return</span> StartingIndex;
01224                     }
01225                 }
01226 
01227                 <span class="comment">//</span>
01228                 <span class="comment">//  Check to see if the Previous byte and current byte</span>
01229                 <span class="comment">//  together satisfy the request.</span>
01230                 <span class="comment">//</span>
01231 
01232                 <span class="keywordflow">if</span> (((ULONG)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a2">RtlpBitsSetHigh</a>(PreviousByte) +
01233                              (ULONG)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a1">RtlpBitsSetLow</a>(CurrentByte)) &gt;= NumberToFind) {
01234 
01235                     ULONG StartingIndex;
01236 
01237                     <span class="comment">//</span>
01238                     <span class="comment">//  It all fits in these two bytes, so we can compute</span>
01239                     <span class="comment">//  the starting index.  This is done by taking the</span>
01240                     <span class="comment">//  index of the current byte (bit 0) and subtracting the</span>
01241                     <span class="comment">//  number of bits its takes to get to the first set</span>
01242                     <span class="comment">//  high bit.</span>
01243                     <span class="comment">//</span>
01244 
01245                     StartingIndex = CurrentBitIndex -
01246                                                (LONG)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a2">RtlpBitsSetHigh</a>(PreviousByte);
01247 
01248                     <span class="comment">//</span>
01249                     <span class="comment">//  Now make sure the total size isn't beyond the bitmap</span>
01250                     <span class="comment">//</span>
01251 
01252                     <span class="keywordflow">if</span> ((StartingIndex + NumberToFind) &lt;= SizeOfBitMap) {
01253 
01254                         <span class="keywordflow">return</span> StartingIndex;
01255                     }
01256                 }
01257             } <span class="comment">// end loop CurrentBitIndex</span>
01258 
01259         <span class="comment">//</span>
01260         <span class="comment">//  The number to find is greater than or equal to 15.  This request</span>
01261         <span class="comment">//  has to have at least one byte of all ones to be satisfied</span>
01262         <span class="comment">//</span>
01263 
01264         } <span class="keywordflow">else</span> {
01265 
01266             ULONG CurrentByteIndex;
01267 
01268             ULONG OneBytesNeeded;
01269             ULONG OneBytesFound;
01270 
01271             UCHAR StartOfRunByte;
01272             LONG StartOfRunIndex;
01273 
01274             <span class="comment">//</span>
01275             <span class="comment">//  First precalculate how many one bytes we're going to need</span>
01276             <span class="comment">//</span>
01277 
01278             OneBytesNeeded = (NumberToFind - 7) / 8;
01279 
01280             <span class="comment">//</span>
01281             <span class="comment">//  Indicate for the first time through our loop that we haven't</span>
01282             <span class="comment">//  found a one byte yet, and indicate that the start of the</span>
01283             <span class="comment">//  run is the byte just before the start byte index</span>
01284             <span class="comment">//</span>
01285 
01286             OneBytesFound = 0;
01287             StartOfRunByte = 0x00;
01288             StartOfRunIndex = StartByteIndex - 1;
01289 
01290             <span class="comment">//</span>
01291             <span class="comment">//  Examine all the bytes in our test range searching for a fit</span>
01292             <span class="comment">//</span>
01293 
01294             CurrentByteIndex = StartByteIndex;
01295 
01296             <span class="keywordflow">while</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
01297 
01298                 <span class="comment">//</span>
01299                 <span class="comment">//  If the number of zero bytes fits our minimum requirements</span>
01300                 <span class="comment">//  then we can do the additional test to see if we</span>
01301                 <span class="comment">//  actually found a fit</span>
01302                 <span class="comment">//</span>
01303 
01304                 <span class="keywordflow">if</span> ((OneBytesFound &gt;= OneBytesNeeded)
01305 
01306                         &amp;&amp;
01307 
01308                     ((ULONG)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a2">RtlpBitsSetHigh</a>(StartOfRunByte) + OneBytesFound*8 +
01309                      (ULONG)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a1">RtlpBitsSetLow</a>(CurrentByte)) &gt;= NumberToFind) {
01310 
01311                     ULONG StartingIndex;
01312 
01313                     <span class="comment">//</span>
01314                     <span class="comment">//  It all fits in these bytes, so we can compute</span>
01315                     <span class="comment">//  the starting index.  This is done by taking the</span>
01316                     <span class="comment">//  StartOfRunIndex times 8 and adding the number of bits</span>
01317                     <span class="comment">//  it takes to get to the first set high bit.</span>
01318                     <span class="comment">//</span>
01319 
01320                     StartingIndex = (StartOfRunIndex * 8) +
01321                                        (8 - (LONG)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a2">RtlpBitsSetHigh</a>(StartOfRunByte));
01322 
01323                     <span class="comment">//</span>
01324                     <span class="comment">//  Now make sure the total size isn't beyond the bitmap</span>
01325                     <span class="comment">//</span>
01326 
01327                     <span class="keywordflow">if</span> ((StartingIndex + NumberToFind) &lt;= SizeOfBitMap) {
01328 
01329                         <span class="keywordflow">return</span> StartingIndex;
01330                     }
01331                 }
01332 
01333                 <span class="comment">//</span>
01334                 <span class="comment">//  Check to see if the byte is all ones and increment</span>
01335                 <span class="comment">//  the number of one bytes found</span>
01336                 <span class="comment">//</span>
01337 
01338                 <span class="keywordflow">if</span> (CurrentByte == 0xff) {
01339 
01340                     OneBytesFound += 1;
01341 
01342                 <span class="comment">//</span>
01343                 <span class="comment">//  The byte isn't all ones so we need to start over again</span>
01344                 <span class="comment">//  looking for one bytes.</span>
01345                 <span class="comment">//</span>
01346 
01347                 } <span class="keywordflow">else</span> {
01348 
01349                     OneBytesFound = 0;
01350                     StartOfRunByte = CurrentByte;
01351                     StartOfRunIndex = CurrentByteIndex;
01352                 }
01353 
01354                 <span class="comment">//</span>
01355                 <span class="comment">//  Increment our Byte Index, and either exit, or get the</span>
01356                 <span class="comment">//  next byte.</span>
01357                 <span class="comment">//</span>
01358 
01359                 CurrentByteIndex += 1;
01360 
01361                 <span class="keywordflow">if</span> ( CurrentByteIndex &lt; EndByteIndex ) {
01362 
01363                     <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a4">GET_BYTE</a>( CurrentByte );
01364 
01365                 } <span class="keywordflow">else</span> {
01366 
01367                     <span class="keywordflow">break</span>;
01368                 }
01369             } <span class="comment">// end loop CurrentByteIndex</span>
01370         }
01371     }
01372 
01373     <span class="comment">//</span>
01374     <span class="comment">//  We never found a fit so we'll return -1</span>
01375     <span class="comment">//</span>
01376 
01377     <span class="keywordflow">return</span> 0xffffffff;
01378 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a32" doxytag="rtl/bitmap.c::RtlFindSetBitsAndClear" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ULONG RtlFindSetBitsAndClear           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PRTL_BITMAP&nbsp;</td>
          <td class="mdname" nowrap> <em>BitMapHeader</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>NumberToFind</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>HintIndex</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l01448">1448</a> of file <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html">rtl/bitmap.c</a>.
<p>
References <a class="el" href="../../d9/d8/tbitmap_8c-source.html#l00027">BitMapHeader</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l01508">RtlClearBits()</a>, and <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00866">RtlFindSetBits()</a>.
<p>
Referenced by <a class="el" href="../../d5/d9/tex_8c-source.html#l01781">DoBitMapTest()</a>.
<p>
<pre class="fragment"><div>01456                    :
01457 
01458     This <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a69">procedure</a> searches <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified bit map <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified
01459     contiguous region of set bits, clears <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> bits and returns <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
01460     number of bits found and <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> starting bit number which was set then
01461     clear.
01462 
01463 Arguments:
01464 
01465     <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a> - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> previously initialized <a class="code" href="../../d2/d1/structBitMap.html">BitMap</a>.
01466 
01467     NumberToFind - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> size of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> contiguous region to find.
01468 
01469     HintIndex - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> index (zero based) of where we should start
01470         <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> search from within <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> bitmap.
01471 
01472 Return Value:
01473 
01474     ULONG - Receives <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> starting index (zero based) of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> contiguous
01475         region found.  If such a region cannot be located a -1 (i.e.,
01476         0xffffffff) <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> returned.
01477 
01478 
01479 --*/
01480 
01481 {
01482     ULONG StartingIndex;
01483 
01484     <span class="comment">//</span>
01485     <span class="comment">//  First look for a run of set bits that equals the size requested</span>
01486     <span class="comment">//</span>
01487 
01488     <span class="keywordflow">if</span> ((StartingIndex = <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a30">RtlFindSetBits</a>( BitMapHeader,
01489                                          NumberToFind,
01490                                          HintIndex )) != 0xffffffff) {
01491 
01492         <span class="comment">//</span>
01493         <span class="comment">//  We found a large enough run of set bits so now clear them</span>
01494         <span class="comment">//</span>
01495 
01496         <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a33">RtlClearBits</a>( BitMapHeader, StartingIndex, NumberToFind );
01497     }
01498 
01499     <span class="comment">//</span>
01500     <span class="comment">//  And return to our caller</span>
01501     <span class="comment">//</span>
01502 
01503     <span class="keywordflow">return</span> StartingIndex;
01504 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a26" doxytag="rtl/bitmap.c::RtlInitializeBitMap" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID RtlInitializeBitMap           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PRTL_BITMAP&nbsp;</td>
          <td class="mdname" nowrap> <em>BitMapHeader</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>BitMapBuffer</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>SizeOfBitMap</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00219">219</a> of file <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html">rtl/bitmap.c</a>.
<p>
References <a class="el" href="../../d9/d8/tbitmap_8c-source.html#l00027">BitMapHeader</a>, and <a class="el" href="../../d6/d8/ntrtlp_8h-source.html#l00246">RTL_PAGED_CODE</a>.
<p>
Referenced by <a class="el" href="../../d5/d9/tex_8c-source.html#l01781">DoBitMapTest()</a>, <a class="el" href="../../d6/d0/hiveinit_8c-source.html#l00158">HvInitializeHive()</a>, <a class="el" href="../../d8/d9/hivebin_8c-source.html#l00046">HvpAddBin()</a>, <a class="el" href="../../d8/d0/hivemap_8c-source.html#l00047">HvpBuildMapAndCopy()</a>, <a class="el" href="../../d8/d0/hivemap_8c-source.html#l00304">HvpInitMap()</a>, <a class="el" href="../../d7/d0/hiveload_8c-source.html#l00847">HvpRecoverData()</a>, <a class="el" href="../../d9/d1/ldrinit_8c-source.html#l00616">LdrpInitializeProcess()</a>, <a class="el" href="../../d9/d8/tbitmap_8c-source.html#l00031">main()</a>, <a class="el" href="../../d9/d4/physical_8c-source.html#l00970">NtAllocateUserPhysicalPages()</a>, <a class="el" href="../../d4/d5/allocvm_8c-source.html#l00075">NtAllocateVirtualMemory()</a>, <a class="el" href="../../d0/d6/desktop_8c-source.html#l04494">SetHandleFlag()</a>, and <a class="el" href="../../d7/d2/queue_8c-source.html#l02475">UserDeleteW32Process()</a>.
<p>
<pre class="fragment"><div>00227                    :
00228 
00229     This <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a69">procedure</a> initializes a bit map.
00230 
00231 Arguments:
00232 
00233     <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a> - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d1/structBitMap.html">BitMap</a> <a class="code" href="../../d3/d3/dumpuser_8c.html#a17">Header</a> to initialize
00234 
00235     BitMapBuffer - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> buffer that <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> to serve as <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
00236         <a class="code" href="../../d2/d1/structBitMap.html">BitMap</a>.  This must be an a multiple number of longwords in size.
00237 
00238     SizeOfBitMap - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> number of bits required in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Bit Map.
00239 
00240 Return Value:
00241 
00242     None.
00243 
00244 --*/
00245 
00246 {
00247     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
00248 
00249     <span class="comment">//</span>
00250     <span class="comment">//  Initialize the BitMap header.</span>
00251     <span class="comment">//</span>
00252 
00253     <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;SizeOfBitMap = SizeOfBitMap;
00254     <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;Buffer = BitMapBuffer;
00255 
00256     <span class="comment">//</span>
00257     <span class="comment">//  And return to our caller</span>
00258     <span class="comment">//</span>
00259 
00260     <span class="comment">//DbgPrint("InitializeBitMap"); DumpBitMap(BitMapHeader);</span>
00261     <span class="keywordflow">return</span>;
00262 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a38" doxytag="rtl/bitmap.c::RtlNumberOfClearBits" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ULONG RtlNumberOfClearBits           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PRTL_BITMAP&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>BitMapHeader</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02149">2149</a> of file <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html">rtl/bitmap.c</a>.
<p>
References <a class="el" href="../../d9/d8/tbitmap_8c-source.html#l00027">BitMapHeader</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00112">GET_BYTE</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00105">GET_BYTE_DECLARATIONS</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00108">GET_BYTE_INITIALIZATION</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00190">RtlpBitsClearTotal</a>, and <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00215">ZeroMask</a>.
<p>
Referenced by <a class="el" href="../../d9/d8/tbitmap_8c-source.html#l00031">main()</a>.
<p>
<pre class="fragment"><div>02155                    :
02156 
02157     This <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a69">procedure</a> counts and returns <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> number of clears bits within
02158     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified bitmap.
02159 
02160 Arguments:
02161 
02162     <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a> - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> previously initialized bitmap.
02163 
02164 Return Value:
02165 
02166     ULONG - The total number of clear bits in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> bitmap
02167 
02168 --*/
02169 
02170 {
02171     ULONG SizeOfBitMap;
02172     ULONG SizeInBytes;
02173 
02174     ULONG i;
02175     UCHAR CurrentByte;
02176 
02177     ULONG TotalClear;
02178 
02179     <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a2">GET_BYTE_DECLARATIONS</a>();
02180 
02181     <span class="comment">//</span>
02182     <span class="comment">//  Reference the bitmap header to make the loop run faster</span>
02183     <span class="comment">//</span>
02184 
02185     SizeOfBitMap = <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;SizeOfBitMap;
02186     SizeInBytes = (SizeOfBitMap + 7) / 8;
02187 
02188     <span class="comment">//</span>
02189     <span class="comment">//  Set any unused bits in the last byte so we don't count them.  We</span>
02190     <span class="comment">//  do this by first checking if there are any odd bits in the last byte</span>
02191     <span class="comment">//</span>
02192 
02193     <span class="keywordflow">if</span> ((SizeOfBitMap % 8) != 0) {
02194 
02195         <span class="comment">//</span>
02196         <span class="comment">//  The last byte has some odd bits so we'll set the high unused</span>
02197         <span class="comment">//  bits in the last byte to 1's</span>
02198         <span class="comment">//</span>
02199 
02200         ((PUCHAR)<a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;Buffer)[SizeInBytes - 1] |=
02201                                                     <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a24">ZeroMask</a>[SizeOfBitMap % 8];
02202     }
02203 
02204     <span class="comment">//</span>
02205     <span class="comment">//  Set if up so we can use the GET_BYTE macro</span>
02206     <span class="comment">//</span>
02207 
02208     <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a3">GET_BYTE_INITIALIZATION</a>( BitMapHeader, 0 );
02209 
02210     <span class="comment">//</span>
02211     <span class="comment">//  Examine every byte in the bitmap</span>
02212     <span class="comment">//</span>
02213 
02214     TotalClear = 0;
02215     <span class="keywordflow">for</span> (i = 0; i &lt; SizeInBytes; i += 1) {
02216 
02217         <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a4">GET_BYTE</a>( CurrentByte );
02218 
02219         TotalClear += <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a22">RtlpBitsClearTotal</a>[CurrentByte];
02220     }
02221 
02222     <span class="keywordflow">return</span> TotalClear;
02223 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a39" doxytag="rtl/bitmap.c::RtlNumberOfSetBits" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ULONG RtlNumberOfSetBits           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PRTL_BITMAP&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>BitMapHeader</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02227">2227</a> of file <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html">rtl/bitmap.c</a>.
<p>
References <a class="el" href="../../d9/d8/tbitmap_8c-source.html#l00027">BitMapHeader</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00213">FillMask</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00112">GET_BYTE</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00105">GET_BYTE_DECLARATIONS</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00108">GET_BYTE_INITIALIZATION</a>, and <a class="el" href="../../d6/d8/ntrtlp_8h-source.html#l00167">RtlpBitsSetTotal</a>.
<p>
Referenced by <a class="el" href="../../d2/d2/cmsysini_8c-source.html#l00726">CmpInitializeHiveList()</a>, <a class="el" href="../../d3/d0/hivefree_8c-source.html#l00160">HvFreeHivePartial()</a>, <a class="el" href="../../d1/d1/hivesync_8c-source.html#l00117">HvMarkCellDirty()</a>, <a class="el" href="../../d1/d1/hivesync_8c-source.html#l00401">HvMarkClean()</a>, <a class="el" href="../../d1/d1/hivesync_8c-source.html#l00270">HvMarkDirty()</a>, <a class="el" href="../../d8/d9/hivebin_8c-source.html#l00046">HvpAddBin()</a>, <a class="el" href="../../d1/d1/hivesync_8c-source.html#l00775">HvpDoWriteHive()</a>, <a class="el" href="../../d1/d1/hivesync_8c-source.html#l00495">HvpGrowLog1()</a>, <a class="el" href="../../d1/d1/hivesync_8c-source.html#l00565">HvpGrowLog2()</a>, <a class="el" href="../../d7/d0/hiveload_8c-source.html#l00847">HvpRecoverData()</a>, <a class="el" href="../../d1/d1/hivesync_8c-source.html#l01025">HvpWriteLog()</a>, <a class="el" href="../../d3/d2/dumpctl_8c-source.html#l03815">IopCreateSummaryDump()</a>, <a class="el" href="../../d3/d2/dumpctl_8c-source.html#l03329">IopWriteSummaryDump()</a>, and <a class="el" href="../../d9/d8/tbitmap_8c-source.html#l00031">main()</a>.
<p>
<pre class="fragment"><div>02233                    :
02234 
02235     This <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a69">procedure</a> counts and returns <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> number of set bits within
02236     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified bitmap.
02237 
02238 Arguments:
02239 
02240     <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a> - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> previously initialized bitmap.
02241 
02242 Return Value:
02243 
02244     ULONG - The total number of set bits in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> bitmap
02245 
02246 --*/
02247 
02248 {
02249     ULONG SizeOfBitMap;
02250     ULONG SizeInBytes;
02251 
02252     ULONG i;
02253     UCHAR CurrentByte;
02254 
02255     ULONG TotalSet;
02256 
02257     <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a2">GET_BYTE_DECLARATIONS</a>();
02258 
02259     <span class="comment">//</span>
02260     <span class="comment">//  Reference the bitmap header to make the loop run faster</span>
02261     <span class="comment">//</span>
02262 
02263     SizeOfBitMap = <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;SizeOfBitMap;
02264     SizeInBytes = (SizeOfBitMap + 7) / 8;
02265 
02266     <span class="comment">//</span>
02267     <span class="comment">//  Clear any unused bits in the last byte so we don't count them.  We</span>
02268     <span class="comment">//  do this by first checking if there are any odd bits in the last byte</span>
02269     <span class="comment">//</span>
02270 
02271     <span class="keywordflow">if</span> ((SizeOfBitMap % 8) != 0) {
02272 
02273         <span class="comment">//</span>
02274         <span class="comment">//  The last byte has some odd bits so we'll set the high unused</span>
02275         <span class="comment">//  bits in the last byte to 0's</span>
02276         <span class="comment">//</span>
02277 
02278         ((PUCHAR)<a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;Buffer)[SizeInBytes - 1] &amp;=
02279                                                     <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a23">FillMask</a>[SizeOfBitMap % 8];
02280     }
02281 
02282     <span class="comment">//</span>
02283     <span class="comment">//  Set if up so we can use the GET_BYTE macro</span>
02284     <span class="comment">//</span>
02285 
02286     <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a3">GET_BYTE_INITIALIZATION</a>( BitMapHeader, 0 );
02287 
02288     <span class="comment">//</span>
02289     <span class="comment">//  Examine every byte in the bitmap</span>
02290     <span class="comment">//</span>
02291 
02292     TotalSet = 0;
02293     <span class="keywordflow">for</span> (i = 0; i &lt; SizeInBytes; i += 1) {
02294 
02295         <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a4">GET_BYTE</a>( CurrentByte );
02296 
02297         TotalSet += <a class="code" href="../../d5/d9/ntrtlp_8h.html#a3">RtlpBitsSetTotal</a>(CurrentByte);
02298     }
02299 
02300     <span class="keywordflow">return</span> TotalSet;
02301 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a28" doxytag="rtl/bitmap.c::RtlSetAllBits" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID RtlSetAllBits           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PRTL_BITMAP&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>BitMapHeader</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00305">305</a> of file <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html">rtl/bitmap.c</a>.
<p>
References <a class="el" href="../../d9/d8/tbitmap_8c-source.html#l00027">BitMapHeader</a>.
<p>
Referenced by <a class="el" href="../../d5/d9/tex_8c-source.html#l01781">DoBitMapTest()</a>, <a class="el" href="../../d6/d0/hiveinit_8c-source.html#l00158">HvInitializeHive()</a>, <a class="el" href="../../d1/d1/hivesync_8c-source.html#l01433">HvWriteHive()</a>, <a class="el" href="../../d9/d8/tbitmap_8c-source.html#l00031">main()</a>, <a class="el" href="../../d6/d0/mminit_8c-source.html#l02184">MiBuildPagedPool()</a>, <a class="el" href="../../d7/d2/modwrite_8c-source.html#l01031">MiExtendPagingFileMaximum()</a>, <a class="el" href="../../d2/d5/allocpag_8c-source.html#l04222">MiInitializeSessionPool()</a>, and <a class="el" href="../../d7/d2/modwrite_8c-source.html#l00297">NtCreatePagingFile()</a>.
<p>
<pre class="fragment"><div>00311                    :
00312 
00313     This <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a69">procedure</a> sets all bits in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified Bit Map.
00314 
00315 Arguments:
00316 
00317     <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a> - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> previously initialized <a class="code" href="../../d2/d1/structBitMap.html">BitMap</a>
00318 
00319 Return Value:
00320 
00321     None.
00322 
00323 --*/
00324 
00325 {
00326     <span class="comment">//</span>
00327     <span class="comment">//  Set all the bits</span>
00328     <span class="comment">//</span>
00329 
00330     RtlFillMemoryUlong( <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;Buffer,
00331                         ((<a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;SizeOfBitMap + 31) / 32) * 4,
00332                         0xffffffff
00333                       );
00334 
00335     <span class="comment">//</span>
00336     <span class="comment">//  And return to our caller</span>
00337     <span class="comment">//</span>
00338 
00339     <span class="comment">//DbgPrint("SetAllBits"); DumpBitMap(BitMapHeader);</span>
00340     <span class="keywordflow">return</span>;
00341 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a34" doxytag="rtl/bitmap.c::RtlSetBits" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID RtlSetBits           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PRTL_BITMAP&nbsp;</td>
          <td class="mdname" nowrap> <em>BitMapHeader</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>StartingIndex</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>NumberToSet</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l01634">1634</a> of file <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html">rtl/bitmap.c</a>.
<p>
References <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d9/d8/tbitmap_8c-source.html#l00027">BitMapHeader</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00037">LeftShiftUlong</a>, and <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00036">RightShiftUlong</a>.
<p>
Referenced by <a class="el" href="../../d2/d2/cmsysini_8c-source.html#l00726">CmpInitializeHiveList()</a>, <a class="el" href="../../d5/d9/tex_8c-source.html#l01781">DoBitMapTest()</a>, <a class="el" href="../../d1/d1/hivesync_8c-source.html#l00270">HvMarkDirty()</a>, <a class="el" href="../../d3/d2/dumpctl_8c-source.html#l02172">IopAddPageToPageMap()</a>, <a class="el" href="../../d9/d8/tbitmap_8c-source.html#l00031">main()</a>, <a class="el" href="../../d2/d5/allocpag_8c-source.html#l00807">MiAllocatePoolPages()</a>, <a class="el" href="../../d7/d2/modwrite_8c-source.html#l01940">MiAttemptPageFileReduction()</a>, <a class="el" href="../../d7/d2/modwrite_8c-source.html#l01095">MiCheckForCrashDump()</a>, <a class="el" href="../../d9/d4/physical_8c-source.html#l00970">NtAllocateUserPhysicalPages()</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l01382">RtlFindClearBitsAndSet()</a>, and <a class="el" href="../../d0/d6/desktop_8c-source.html#l04494">SetHandleFlag()</a>.
<p>
<pre class="fragment"><div>01642                    :
01643 
01644     This <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a69">procedure</a> sets <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified range of bits within <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
01645     specified bit map.
01646 
01647 Arguments:
01648 
01649     <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a> - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> previously initialied <a class="code" href="../../d2/d1/structBitMap.html">BitMap</a>.
01650 
01651     StartingIndex - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> index (zero based) of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> first bit to set.
01652 
01653     NumberToSet - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> number of bits to set.
01654 
01655 Return Value:
01656 
01657     None.
01658 
01659 --*/
01660 {
01661     ULONG BitOffset;
01662     PULONG CurrentLong;
01663 
01664     <span class="comment">//DbgPrint("SetBits %08lx, ", NumberToSet);</span>
01665     <span class="comment">//DbgPrint("%08lx", StartingIndex);</span>
01666 
01667     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( StartingIndex + NumberToSet &lt;= BitMapHeader-&gt;SizeOfBitMap );
01668 
01669     <span class="comment">//</span>
01670     <span class="comment">//  Special case the situation where the number of bits to set is</span>
01671     <span class="comment">//  zero.  Turn this into a noop.</span>
01672     <span class="comment">//</span>
01673 
01674     <span class="keywordflow">if</span> (NumberToSet == 0) {
01675 
01676         <span class="keywordflow">return</span>;
01677     }
01678 
01679     BitOffset = StartingIndex % 32;
01680 
01681     <span class="comment">//</span>
01682     <span class="comment">//  Get a pointer to the first longword that needs to be set</span>
01683     <span class="comment">//</span>
01684 
01685     CurrentLong = &amp;<a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;Buffer[ StartingIndex / 32 ];
01686 
01687     <span class="comment">//</span>
01688     <span class="comment">//  Check if we can only need to set one longword.</span>
01689     <span class="comment">//</span>
01690 
01691     <span class="keywordflow">if</span> ((BitOffset + NumberToSet) &lt;= 32) {
01692 
01693         <span class="comment">//</span>
01694         <span class="comment">//  To build a mask of bits to set we shift left to get the number</span>
01695         <span class="comment">//  of bits we're setting and then shift right to put it in position.</span>
01696         <span class="comment">//  We'll typecast the right shift to ULONG to make sure it doesn't</span>
01697         <span class="comment">//  do a sign extend.</span>
01698         <span class="comment">//</span>
01699 
01700         *CurrentLong |= <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a1">LeftShiftUlong</a>(<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a0">RightShiftUlong</a>(((ULONG)0xFFFFFFFF),(32 - NumberToSet)),
01701                                                                     BitOffset);
01702 
01703         <span class="comment">//</span>
01704         <span class="comment">//  And return to our caller</span>
01705         <span class="comment">//</span>
01706 
01707         <span class="comment">//DumpBitMap(BitMapHeader);</span>
01708 
01709         <span class="keywordflow">return</span>;
01710     }
01711 
01712     <span class="comment">//</span>
01713     <span class="comment">//  We can set bits out to the end of the first longword so we'll</span>
01714     <span class="comment">//  do that right now.</span>
01715     <span class="comment">//</span>
01716 
01717     *CurrentLong |= <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a1">LeftShiftUlong</a>(0xFFFFFFFF, BitOffset);
01718 
01719     <span class="comment">//</span>
01720     <span class="comment">//  And indicate what the next longword to set is and how many</span>
01721     <span class="comment">//  bits are left to set</span>
01722     <span class="comment">//</span>
01723 
01724     CurrentLong += 1;
01725     NumberToSet -= 32 - BitOffset;
01726 
01727     <span class="comment">//</span>
01728     <span class="comment">//  The bit position is now long aligned, so we can continue</span>
01729     <span class="comment">//  setting longwords until the number to set is less than 32</span>
01730     <span class="comment">//</span>
01731 
01732     <span class="keywordflow">while</span> (NumberToSet &gt;= 32) {
01733 
01734         *CurrentLong = 0xffffffff;
01735         CurrentLong += 1;
01736         NumberToSet -= 32;
01737     }
01738 
01739     <span class="comment">//</span>
01740     <span class="comment">//  And now we can set the remaining bits, if there are any, in the</span>
01741     <span class="comment">//  last longword</span>
01742     <span class="comment">//</span>
01743 
01744     <span class="keywordflow">if</span> (NumberToSet &gt; 0) {
01745 
01746         *CurrentLong |= ~<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a1">LeftShiftUlong</a>(0xFFFFFFFF, NumberToSet);
01747     }
01748 
01749     <span class="comment">//</span>
01750     <span class="comment">//  And return to our caller</span>
01751     <span class="comment">//</span>
01752 
01753     <span class="comment">//DumpBitMap(BitMapHeader);</span>
01754 
01755     <span class="keywordflow">return</span>;
01756 }

</div></pre>    </td>
  </tr>
</table>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="a23" doxytag="rtl/bitmap.c::FillMask" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> CONST UCHAR <a class="el" href="../../d4/d1/rtl_2bitmap_8c.html#a23">FillMask</a>[] = { 0x00, 0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x7F, 0xFF }<code> [static]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00213">213</a> of file <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html">rtl/bitmap.c</a>.
<p>
Referenced by <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02305">RtlAreBitsClear()</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02464">RtlAreBitsSet()</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00345">RtlFindClearBits()</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l01764">RtlFindClearRuns()</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00866">RtlFindSetBits()</a>, and <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02227">RtlNumberOfSetBits()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a25" doxytag="rtl/bitmap.c::FillMaskUlong" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> CONST ULONG <a class="el" href="../../d4/d1/rtl_2bitmap_8c.html#a25">FillMaskUlong</a>[]<code> [static]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Initial value:</b><pre class="fragment"><div> {
    0x00000000, 0x00000001, 0x00000003, 0x00000007,
    0x0000000f, 0x0000001f, 0x0000003f, 0x0000007f,
    0x000000ff, 0x000001ff, 0x000003ff, 0x000007ff,
    0x00000fff, 0x00001fff, 0x00003fff, 0x00007fff,
    0x0000ffff, 0x0001ffff, 0x0003ffff, 0x0007ffff,
    0x000fffff, 0x001fffff, 0x003fffff, 0x007fffff,
    0x00ffffff, 0x01ffffff, 0x03ffffff, 0x07ffffff,
    0x0fffffff, 0x1fffffff, 0x3fffffff, 0x7fffffff,
    0xffffffff
}
</div></pre>
<p>
Definition at line <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02621">2621</a> of file <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html">rtl/bitmap.c</a>.
<p>
Referenced by <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02779">RtlFindLastBackwardRunClear()</a>, and <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02635">RtlFindNextForwardRunClear()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a19" doxytag="rtl/bitmap.c::RtlpBitsClearAnywhere" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> CONST CCHAR <a class="el" href="../../d5/d9/ntrtlp_8h.html#a16">RtlpBitsClearAnywhere</a>[]          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Initial value:</b><pre class="fragment"><div>
         { 8,7,6,6,5,5,5,5,4,4,4,4,4,4,4,4,
           4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
           5,4,3,3,2,2,2,2,3,2,2,2,2,2,2,2,
           4,3,2,2,2,2,2,2,3,2,2,2,2,2,2,2,
           6,5,4,4,3,3,3,3,3,2,2,2,2,2,2,2,
           4,3,2,2,2,1,1,1,3,2,1,1,2,1,1,1,
           5,4,3,3,2,2,2,2,3,2,1,1,2,1,1,1,
           4,3,2,2,2,1,1,1,3,2,1,1,2,1,1,1,
           7,6,5,5,4,4,4,4,3,3,3,3,3,3,3,3,
           4,3,2,2,2,2,2,2,3,2,2,2,2,2,2,2,
           5,4,3,3,2,2,2,2,3,2,1,1,2,1,1,1,
           4,3,2,2,2,1,1,1,3,2,1,1,2,1,1,1,
           6,5,4,4,3,3,3,3,3,2,2,2,2,2,2,2,
           4,3,2,2,2,1,1,1,3,2,1,1,2,1,1,1,
           5,4,3,3,2,2,2,2,3,2,1,1,2,1,1,1,
           4,3,2,2,2,1,1,1,3,2,1,1,2,1,1,0 }
</div></pre>
<p>
Definition at line <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00122">122</a> of file <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html">rtl/bitmap.c</a>.
<p>
Referenced by <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00345">RtlFindClearBits()</a>, and <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l01764">RtlFindClearRuns()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a21" doxytag="rtl/bitmap.c::RtlpBitsClearHigh" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> CONST CCHAR <a class="el" href="../../d5/d9/ntrtlp_8h.html#a18">RtlpBitsClearHigh</a>[]          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Initial value:</b><pre class="fragment"><div>
          { 8,7,6,6,5,5,5,5,4,4,4,4,4,4,4,4,
            3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
            2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
            2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
            1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
            1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
            1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
            1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }
</div></pre>
<p>
Definition at line <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00168">168</a> of file <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html">rtl/bitmap.c</a>.
<p>
Referenced by <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00345">RtlFindClearBits()</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l01764">RtlFindClearRuns()</a>, and <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02923">RtlFindMostSignificantBit()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a20" doxytag="rtl/bitmap.c::RtlpBitsClearLow" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> CONST CCHAR <a class="el" href="../../d5/d9/ntrtlp_8h.html#a17">RtlpBitsClearLow</a>[]          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Initial value:</b><pre class="fragment"><div>
          { 8,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            7,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0 }
</div></pre>
<p>
Definition at line <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00145">145</a> of file <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html">rtl/bitmap.c</a>.
<p>
Referenced by <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00345">RtlFindClearBits()</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l01764">RtlFindClearRuns()</a>, and <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02999">RtlFindLeastSignificantBit()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a22" doxytag="rtl/bitmap.c::RtlpBitsClearTotal" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> CONST CCHAR <a class="el" href="../../d5/d9/ntrtlp_8h.html#a19">RtlpBitsClearTotal</a>[]          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Initial value:</b><pre class="fragment"><div>
          { 8,7,7,6,7,6,6,5,7,6,6,5,6,5,5,4,
            7,6,6,5,6,5,5,4,6,5,5,4,5,4,4,3,
            7,6,6,5,6,5,5,4,6,5,5,4,5,4,4,3,
            6,5,5,4,5,4,4,3,5,4,4,3,4,3,3,2,
            7,6,6,5,6,5,5,4,6,5,5,4,5,4,4,3,
            6,5,5,4,5,4,4,3,5,4,4,3,4,3,3,2,
            6,5,5,4,5,4,4,3,5,4,4,3,4,3,3,2,
            5,4,4,3,4,3,3,2,4,3,3,2,3,2,2,1,
            7,6,6,5,6,5,5,4,6,5,5,4,5,4,4,3,
            6,5,5,4,5,4,4,3,5,4,4,3,4,3,3,2,
            6,5,5,4,5,4,4,3,5,4,4,3,4,3,3,2,
            5,4,4,3,4,3,3,2,4,3,3,2,3,2,2,1,
            6,5,5,4,5,4,4,3,5,4,4,3,4,3,3,2,
            5,4,4,3,4,3,3,2,4,3,3,2,3,2,2,1,
            5,4,4,3,4,3,3,2,4,3,3,2,3,2,2,1,
            4,3,3,2,3,2,2,1,3,2,2,1,2,1,1,0 }
</div></pre>
<p>
Definition at line <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00190">190</a> of file <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html">rtl/bitmap.c</a>.
<p>
Referenced by <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02149">RtlNumberOfClearBits()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a24" doxytag="rtl/bitmap.c::ZeroMask" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> CONST UCHAR <a class="el" href="../../d4/d1/rtl_2bitmap_8c.html#a24">ZeroMask</a>[] = { 0xFF, 0xFE, 0xFC, 0xF8, 0xf0, 0xe0, 0xc0, 0x80, 0x00 }<code> [static]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00215">215</a> of file <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html">rtl/bitmap.c</a>.
<p>
Referenced by <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02305">RtlAreBitsClear()</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02464">RtlAreBitsSet()</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00345">RtlFindClearBits()</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l01764">RtlFindClearRuns()</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00866">RtlFindSetBits()</a>, and <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l02149">RtlNumberOfClearBits()</a>.    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:42:57 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
