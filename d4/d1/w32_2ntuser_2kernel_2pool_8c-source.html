<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: pool.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>pool.c</h1><a href="../../d3/d2/w32_2ntuser_2kernel_2pool_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/**************************** Module Header ********************************\</span>
00002 <span class="comment">* Module Name: pool.c</span>
00003 <span class="comment">*</span>
00004 <span class="comment">* Copyright (c) 1985 - 1999, Microsoft Corporation</span>
00005 <span class="comment">*</span>
00006 <span class="comment">* Pool reallocation routines</span>
00007 <span class="comment">*</span>
00008 <span class="comment">* History:</span>
00009 <span class="comment">* 03-04-95 JimA       Created.</span>
00010 <span class="comment">\***************************************************************************/</span>
00011 
00012 <span class="preprocessor">#include "<a class="code" href="../../d0/d4/w32_2ntuser_2kernel_2precomp_8h.html">precomp.h</a>"</span>
00013 <span class="preprocessor">#pragma hdrstop</span>
00014 <span class="preprocessor"></span>
<a name="l00015"></a><a class="code" href="../../d3/d2/w32_2ntuser_2kernel_2pool_8c.html#a0">00015</a> <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a11">BOOL</a> <a class="code" href="../../d3/d2/w32_2ntuser_2kernel_2pool_8c.html#a0">gdwPoolFlags</a>;
00016 
00017 <span class="preprocessor">#ifdef POOL_INSTR</span>
00018 <span class="preprocessor"></span>    
00019     <span class="comment">/*</span>
00020 <span class="comment">     * Globals used by RecordStackTrace</span>
00021 <span class="comment">     */</span>
00022     
00023     PVOID     gRecordedStackTrace[<a class="code" href="../../d4/d1/userk_8h.html#a209">RECORD_STACK_TRACE_SIZE</a>];
00024     <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> gpepRecorded;
00025     <a class="code" href="../../d5/d6/struct__ETHREAD.html">PETHREAD</a>  gpetRecorded;
00026 
00027 
00028     <a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a> gdwAllocFailIndex;        <span class="comment">// the index of the allocation that's</span>
00029                                     <span class="comment">// going to fail</span>
00030 
00031     <a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a> gdwAllocsToFail = 1;      <span class="comment">// how many allocs to fail</span>
00032 
00033     <a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a> gdwFreeRecords;
00034     
00035     <span class="comment">/*</span>
00036 <span class="comment">     * Targeted tag failures</span>
00037 <span class="comment">     */</span>
00038     LPDWORD gparrTagsToFail;
00039     SIZE_T  gdwTagsToFailCount;
00040 
00041     <span class="comment">/*</span>
00042 <span class="comment">     * Support to keep records of failed pool allocations</span>
00043 <span class="comment">     */</span>
00044     <a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a> gdwFailRecords;
00045     <a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a> gdwFailRecordCrtIndex;
00046     <a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a> gdwFailRecordTotalFailures;
00047 
00048     <a class="code" href="../../d3/d3/structtagPOOLRECORD.html">PPOOLRECORD</a> gparrFailRecord;
00049     
00050     <span class="comment">/*</span>
00051 <span class="comment">     * Support to keep records of pool free</span>
00052 <span class="comment">     */</span>
00053     <a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a> gdwFreeRecords;
00054     <a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a> gdwFreeRecordCrtIndex;
00055     <a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a> gdwFreeRecordTotalFrees;
00056 
00057     <a class="code" href="../../d3/d3/structtagPOOLRECORD.html">PPOOLRECORD</a> gparrFreeRecord;
00058 
00059     <a class="code" href="../../d6/d9/struct__FAST__MUTEX.html">FAST_MUTEX</a>* gpAllocFastMutex;   <span class="comment">// mutex to syncronize pool allocations</span>
00060 
00061     <a class="code" href="../../d3/d9/structtagWin32AllocStats.html">Win32AllocStats</a> gAllocList;
00062 
00063     <span class="keywordtype">char</span> gszTailAlloc[] = <span class="stringliteral">"Win32kAlloc"</span>;
00064 <span class="preprocessor">#endif // POOL_INSTR</span>
00065 <span class="preprocessor"></span>
00066 
00067 
<a name="l00068"></a><a class="code" href="../../d3/d2/w32_2ntuser_2kernel_2pool_8c.html#a1">00068</a> PVOID <a class="code" href="../../d3/d2/w32_2ntuser_2kernel_2pool_8c.html#a1">Win32AllocPoolWithTagZInit</a>(SIZE_T uBytes, ULONG uTag)
00069 {
00070     PVOID   pv;
00071     
00072     pv = Win32AllocPool(uBytes, uTag);
00073     <span class="keywordflow">if</span> (pv) {
00074         RtlZeroMemory(pv, uBytes);
00075     }
00076 
00077     <span class="keywordflow">return</span> pv;
00078 }
00079 
<a name="l00080"></a><a class="code" href="../../d3/d2/w32_2ntuser_2kernel_2pool_8c.html#a2">00080</a> PVOID <a class="code" href="../../d3/d2/w32_2ntuser_2kernel_2pool_8c.html#a2">Win32AllocPoolWithQuotaTagZInit</a>(SIZE_T uBytes, ULONG uTag)
00081 {
00082     PVOID   pv;
00083     
00084     pv = Win32AllocPoolWithQuota(uBytes, uTag);
00085     <span class="keywordflow">if</span> (pv) {
00086         RtlZeroMemory(pv, uBytes);
00087     }
00088 
00089     <span class="keywordflow">return</span> pv;
00090 }
00091 
<a name="l00092"></a><a class="code" href="../../d3/d2/w32_2ntuser_2kernel_2pool_8c.html#a3">00092</a> PVOID <a class="code" href="../../d3/d2/w32_2ntuser_2kernel_2pool_8c.html#a3">UserReAllocPoolWithTag</a>(
00093     PVOID pSrc,
00094     SIZE_T uBytesSrc,
00095     SIZE_T uBytes,
00096     ULONG iTag)
00097 {
00098     PVOID pDest;
00099 
00100     pDest = UserAllocPool(uBytes, iTag);
00101     <span class="keywordflow">if</span> (pDest != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00102 
00103         <span class="comment">/*</span>
00104 <span class="comment">         * If the block is shrinking, don't copy too many bytes.</span>
00105 <span class="comment">         */</span>
00106         <span class="keywordflow">if</span> (uBytesSrc &gt; uBytes) {
00107             uBytesSrc = uBytes;
00108         }
00109 
00110         RtlCopyMemory(pDest, pSrc, uBytesSrc);
00111 
00112         UserFreePool(pSrc);
00113     }
00114 
00115     <span class="keywordflow">return</span> pDest;
00116 }
00117 
<a name="l00118"></a><a class="code" href="../../d3/d2/w32_2ntuser_2kernel_2pool_8c.html#a4">00118</a> PVOID <a class="code" href="../../d3/d2/w32_2ntuser_2kernel_2pool_8c.html#a4">UserReAllocPoolWithQuotaTag</a>(
00119     PVOID pSrc,
00120     SIZE_T uBytesSrc,
00121     SIZE_T uBytes,
00122     ULONG iTag)
00123 {
00124     PVOID pDest;
00125 
00126     pDest = UserAllocPoolWithQuota(uBytes, iTag);
00127     <span class="keywordflow">if</span> (pDest != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00128 
00129         <span class="comment">/*</span>
00130 <span class="comment">         * If the block is shrinking, don't copy too many bytes.</span>
00131 <span class="comment">         */</span>
00132         <span class="keywordflow">if</span> (uBytesSrc &gt; uBytes)
00133             uBytesSrc = uBytes;
00134 
00135         RtlCopyMemory(pDest, pSrc, uBytesSrc);
00136 
00137         UserFreePool(pSrc);
00138     }
00139 
00140     <span class="keywordflow">return</span> pDest;
00141 }
00142 
00143 <span class="comment">/*</span>
00144 <span class="comment"> * Allocation routines for rtl functions</span>
00145 <span class="comment"> */</span>
00146 
<a name="l00147"></a><a class="code" href="../../d3/d2/w32_2ntuser_2kernel_2pool_8c.html#a5">00147</a> PVOID <a class="code" href="../../d6/d1/userrtl_8h.html#a31">UserRtlAllocMem</a>(
00148     SIZE_T uBytes)
00149 {
00150     <span class="keywordflow">return</span> UserAllocPool(uBytes, TAG_RTL);
00151 }
00152 
<a name="l00153"></a><a class="code" href="../../d3/d2/w32_2ntuser_2kernel_2pool_8c.html#a6">00153</a> <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a> <a class="code" href="../../d6/d1/userrtl_8h.html#a32">UserRtlFreeMem</a>(
00154     PVOID pMem)
00155 {
00156     UserFreePool(pMem);
00157 }
00158 
00159 <span class="preprocessor">#ifdef POOL_INSTR</span>
00160 <span class="preprocessor"></span>
00161 <span class="keywordtype">void</span> RecordStackTrace(<span class="keywordtype">void</span>)
00162 {
00163     ULONG hash;
00164 
00165     RtlZeroMemory(gRecordedStackTrace, RECORD_STACK_TRACE_SIZE * <span class="keyword">sizeof</span>(PVOID));
00166 
00167     GetStackTrace(2,
00168                   RECORD_STACK_TRACE_SIZE,
00169                   gRecordedStackTrace,
00170                   &amp;hash);
00171 
00172     gpepRecorded = <a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a>();
00173     gpetRecorded = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
00174 }
00175 
00176 <span class="comment">/***************************************************************************\</span>
00177 <span class="comment">* RecordFailAllocation</span>
00178 <span class="comment">*</span>
00179 <span class="comment">* Records failed allocations</span>
00180 <span class="comment">*</span>
00181 <span class="comment">* 3-22-99 CLupu      Created.</span>
00182 <span class="comment">\***************************************************************************/</span>
00183 <span class="keywordtype">void</span> RecordFailAllocation(
00184     ULONG  tag,
00185     SIZE_T size)
00186 {
00187     ULONG hash;
00188 
00189     UserAssert(gdwPoolFlags &amp; POOL_KEEP_FAIL_RECORD);
00190     
00191     gparrFailRecord[gdwFailRecordCrtIndex].<a class="code" href="../../d3/d3/structtagPOOLRECORD.html#o0">ExtraData</a> = LongToPtr( tag );
00192     gparrFailRecord[gdwFailRecordCrtIndex].<a class="code" href="../../d3/d3/structtagPOOLRECORD.html#o1">size</a> = size;
00193     
00194     gdwFailRecordTotalFailures++;
00195     
00196     RtlZeroMemory(gparrFailRecord[gdwFailRecordCrtIndex].trace,
00197                   RECORD_STACK_TRACE_SIZE * <span class="keyword">sizeof</span>(PVOID));
00198 
00199     GetStackTrace(2,
00200                   RECORD_STACK_TRACE_SIZE,
00201                   gparrFailRecord[gdwFailRecordCrtIndex].trace,
00202                   &amp;hash);
00203     
00204     gdwFailRecordCrtIndex++;
00205     
00206     <span class="keywordflow">if</span> (gdwFailRecordCrtIndex &gt;= gdwFailRecords) {
00207         gdwFailRecordCrtIndex = 0;
00208     }
00209 }
00210 
00211 <span class="comment">/***************************************************************************\</span>
00212 <span class="comment">* RecordFreePool</span>
00213 <span class="comment">*</span>
00214 <span class="comment">* Records free pool</span>
00215 <span class="comment">*</span>
00216 <span class="comment">* 3-22-99 CLupu      Created.</span>
00217 <span class="comment">\***************************************************************************/</span>
00218 <span class="keywordtype">void</span> RecordFreePool(
00219     PVOID  p,
00220     SIZE_T size)
00221 {
00222     ULONG hash;
00223 
00224     UserAssert(gdwPoolFlags &amp; POOL_KEEP_FREE_RECORD);
00225     
00226     gparrFreeRecord[gdwFreeRecordCrtIndex].<a class="code" href="../../d3/d3/structtagPOOLRECORD.html#o0">ExtraData</a> = p;
00227     gparrFreeRecord[gdwFreeRecordCrtIndex].<a class="code" href="../../d3/d3/structtagPOOLRECORD.html#o1">size</a> = size;
00228     
00229     gdwFreeRecordTotalFrees++;
00230     
00231     RtlZeroMemory(gparrFreeRecord[gdwFreeRecordCrtIndex].trace,
00232                   RECORD_STACK_TRACE_SIZE * <span class="keyword">sizeof</span>(PVOID));
00233 
00234     GetStackTrace(2,
00235                   RECORD_STACK_TRACE_SIZE,
00236                   gparrFreeRecord[gdwFreeRecordCrtIndex].trace,
00237                   &amp;hash);
00238     
00239     gdwFreeRecordCrtIndex++;
00240     
00241     <span class="keywordflow">if</span> (gdwFreeRecordCrtIndex &gt;= gdwFreeRecords) {
00242         gdwFreeRecordCrtIndex = 0;
00243     }
00244 }
00245 
00246 <span class="comment">/***************************************************************************\</span>
00247 <span class="comment">* HeavyAllocPool</span>
00248 <span class="comment">*</span>
00249 <span class="comment">* This will make UserAllocPool to fail if we do not provide enough memory</span>
00250 <span class="comment">* for the specified tag.</span>
00251 <span class="comment">*</span>
00252 <span class="comment">* 12-02-96 CLupu      Created.</span>
00253 <span class="comment">\***************************************************************************/</span>
00254 PVOID HeavyAllocPool(
00255     SIZE_T uBytes,
00256     ULONG  tag,
00257     DWORD  dwFlags)
00258 {
00259     <a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a>*         p;
00260     PWin32PoolHead ph;
00261 
00262     <span class="comment">/*</span>
00263 <span class="comment">     * Make instrumentations faster for the main session if POOL_ONLY_HEAVY_REMOTE</span>
00264 <span class="comment">     * is used</span>
00265 <span class="comment">     */</span>
00266     <span class="keywordflow">if</span> (!(<a class="code" href="../../d3/d2/w32_2ntuser_2kernel_2pool_8c.html#a0">gdwPoolFlags</a> &amp; <a class="code" href="../../d4/d1/userk_8h.html#a210">POOL_HEAVY_ALLOCS</a>)) {
00267         <span class="keywordflow">if</span> (<a class="code" href="../../d3/d8/propapi_8h.html#a34">dwFlags</a> &amp; DAP_USEQUOTA) {
00268             <span class="keywordflow">if</span> (<a class="code" href="../../d3/d8/propapi_8h.html#a34">dwFlags</a> &amp; DAP_NONPAGEDPOOL) {
00269                 p = <a class="code" href="../../d5/d8/ex_8h.html#a5">ExAllocatePoolWithQuotaTag</a>(SESSION_POOL_MASK | NonPagedPool | POOL_QUOTA_FAIL_INSTEAD_OF_RAISE,
00270                                                uBytes,
00271                                                tag);
00272             } <span class="keywordflow">else</span> {
00273                 p = <a class="code" href="../../d5/d8/ex_8h.html#a5">ExAllocatePoolWithQuotaTag</a>(
00274                                        SESSION_POOL_MASK | PagedPool | POOL_QUOTA_FAIL_INSTEAD_OF_RAISE,
00275                                        uBytes,
00276                                        tag);
00277             }
00278         } <span class="keywordflow">else</span> {
00279             <span class="keywordflow">if</span> (<a class="code" href="../../d3/d8/propapi_8h.html#a34">dwFlags</a> &amp; DAP_NONPAGEDPOOL) {
00280                 p = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>(SESSION_POOL_MASK | NonPagedPool, uBytes, tag);
00281             } <span class="keywordflow">else</span> {
00282                 p = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>(SESSION_POOL_MASK | PagedPool, uBytes, tag);
00283             }
00284         }
00285         
00286         <span class="keywordflow">if</span> (p != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> &amp;&amp; (<a class="code" href="../../d3/d8/propapi_8h.html#a34">dwFlags</a> &amp; DAP_ZEROINIT)) {
00287             RtlZeroMemory(p, uBytes);
00288         }
00289         
00290         <span class="keywordflow">return</span> p; 
00291     }
00292     
00293     <span class="comment">/*</span>
00294 <span class="comment">     * Check for overflow</span>
00295 <span class="comment">     */</span>
00296     <span class="keywordflow">if</span> (uBytes &gt;= MAXULONG - <span class="keyword">sizeof</span>(Win32PoolHead) - <span class="keyword">sizeof</span>(gszTailAlloc)) {
00297         
00298         <span class="keywordflow">if</span> (<a class="code" href="../../d3/d2/w32_2ntuser_2kernel_2pool_8c.html#a0">gdwPoolFlags</a> &amp; <a class="code" href="../../d4/d1/userk_8h.html#a216">POOL_KEEP_FAIL_RECORD</a>) {
00299             RecordFailAllocation(tag, 0);
00300         }
00301         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00302     }
00303 
00304     <span class="comment">/*</span>
00305 <span class="comment">     * Acquire the mutex when we play with the list of allocations</span>
00306 <span class="comment">     */</span>
00307     <a class="code" href="../../d4/d9/ke_8h.html#a28">KeEnterCriticalRegion</a>();
00308     <a class="code" href="../../d5/d8/ex_8h.html#a231">ExAcquireFastMutexUnsafe</a>(gpAllocFastMutex);
00309     
00310 <span class="preprocessor">#ifdef POOL_INSTR_API</span>
00311 <span class="preprocessor"></span>    <span class="comment">/*</span>
00312 <span class="comment">     * Fail the allocation if the flag is set</span>
00313 <span class="comment">     * Don't fail allocations that will certainly get us to bugchecking in DBG (i.e. GLOBALTHREADLOCK)</span>
00314 <span class="comment">     */</span>
00315     <span class="keywordflow">if</span> (<a class="code" href="../../d3/d2/w32_2ntuser_2kernel_2pool_8c.html#a0">gdwPoolFlags</a> &amp; <a class="code" href="../../d4/d1/userk_8h.html#a212">POOL_FAIL_ALLOCS</a>
00316 <span class="preprocessor">#if DBG</span>
00317 <span class="preprocessor"></span>        &amp;&amp; (tag != TAG_GLOBALTHREADLOCK)
00318 <span class="preprocessor">#endif // DBG</span>
00319 <span class="preprocessor"></span>        ) {
00320         
00321 
00322         SIZE_T dwInd;
00323 
00324         <span class="keywordflow">for</span> (dwInd = 0; dwInd &lt; gdwTagsToFailCount; dwInd++) {
00325             <span class="keywordflow">if</span> (tag == gparrTagsToFail[dwInd]) {
00326                 <span class="keywordflow">break</span>;
00327             }
00328         }
00329         
00330         <span class="keywordflow">if</span> (dwInd &lt; gdwTagsToFailCount) {
00331             <span class="keywordflow">if</span> (<a class="code" href="../../d3/d2/w32_2ntuser_2kernel_2pool_8c.html#a0">gdwPoolFlags</a> &amp; <a class="code" href="../../d4/d1/userk_8h.html#a216">POOL_KEEP_FAIL_RECORD</a>) {
00332                 RecordFailAllocation(tag, uBytes);
00333             }
00334 
00335             RIPMSG0(RIP_WARNING, <span class="stringliteral">"Pool allocation failed because of global restriction"</span>);
00336             p = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00337             <span class="keywordflow">goto</span> <a class="code" href="../../d9/d1/fedefs_8h.html#a16">exit</a>;
00338         }
00339     }
00340 <span class="preprocessor">#endif // POOL_INSTR_API</span>
00341 <span class="preprocessor"></span>
00342 <span class="preprocessor">#if DBG</span>
00343 <span class="preprocessor"></span>    <span class="keywordflow">if</span> ((<a class="code" href="../../d3/d2/w32_2ntuser_2kernel_2pool_8c.html#a0">gdwPoolFlags</a> &amp; <a class="code" href="../../d4/d1/userk_8h.html#a213">POOL_FAIL_BY_INDEX</a>) &amp;&amp; (tag != TAG_GLOBALTHREADLOCK)) {
00344         
00345         <span class="comment">/*</span>
00346 <span class="comment">         * Count the calls to HeavyAllocPool</span>
00347 <span class="comment">         */</span>
00348         gdwAllocCrt++;
00349 
00350         <span class="keywordflow">if</span> (gdwAllocCrt &gt;= gdwAllocFailIndex &amp;&amp;
00351             gdwAllocCrt &lt; gdwAllocFailIndex + gdwAllocsToFail) {
00352 
00353             RecordStackTrace();
00354 
00355             KdPrint((<span class="stringliteral">"\n--------------------------------------------------\n"</span>));
00356             KdPrint((
00357                     <span class="stringliteral">"\nPool allocation %d failed because of registry settings"</span>,
00358                     gdwAllocCrt));
00359             KdPrint((<span class="stringliteral">"\n--------------------------------------------------\n\n"</span>));
00360 
00361             <span class="keywordflow">if</span> (<a class="code" href="../../d3/d2/w32_2ntuser_2kernel_2pool_8c.html#a0">gdwPoolFlags</a> &amp; <a class="code" href="../../d4/d1/userk_8h.html#a216">POOL_KEEP_FAIL_RECORD</a>) {
00362                 RecordFailAllocation(tag, uBytes);
00363             }
00364             p = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00365             <span class="keywordflow">goto</span> <a class="code" href="../../d9/d1/fedefs_8h.html#a16">exit</a>;
00366         }
00367     }
00368 <span class="preprocessor">#endif // DBG</span>
00369 <span class="preprocessor"></span>    
00370     <span class="comment">/*</span>
00371 <span class="comment">     * Reserve space for the header</span>
00372 <span class="comment">     */</span>
00373     uBytes += <span class="keyword">sizeof</span>(Win32PoolHead);
00374 
00375     <span class="keywordflow">if</span> (<a class="code" href="../../d3/d2/w32_2ntuser_2kernel_2pool_8c.html#a0">gdwPoolFlags</a> &amp; <a class="code" href="../../d4/d1/userk_8h.html#a214">POOL_TAIL_CHECK</a>) {
00376         uBytes += <span class="keyword">sizeof</span>(gszTailAlloc);
00377     }
00378     
00379     <span class="keywordflow">if</span> (<a class="code" href="../../d3/d8/propapi_8h.html#a34">dwFlags</a> &amp; DAP_USEQUOTA) {
00380         <span class="keywordflow">if</span> (<a class="code" href="../../d3/d8/propapi_8h.html#a34">dwFlags</a> &amp; DAP_NONPAGEDPOOL) {
00381             p = <a class="code" href="../../d5/d8/ex_8h.html#a5">ExAllocatePoolWithQuotaTag</a>(SESSION_POOL_MASK | NonPagedPool | POOL_QUOTA_FAIL_INSTEAD_OF_RAISE,
00382                                            uBytes,
00383                                            tag);
00384         } <span class="keywordflow">else</span> {
00385             p = <a class="code" href="../../d5/d8/ex_8h.html#a5">ExAllocatePoolWithQuotaTag</a>(
00386                                    SESSION_POOL_MASK | PagedPool | POOL_QUOTA_FAIL_INSTEAD_OF_RAISE,
00387                                    uBytes,
00388                                    tag);
00389         }
00390     } <span class="keywordflow">else</span> {
00391         <span class="keywordflow">if</span> (<a class="code" href="../../d3/d8/propapi_8h.html#a34">dwFlags</a> &amp; DAP_NONPAGEDPOOL) {
00392             p = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>(SESSION_POOL_MASK | NonPagedPool, uBytes, tag);
00393         } <span class="keywordflow">else</span> {
00394             p = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>(SESSION_POOL_MASK | PagedPool, uBytes, tag);
00395         }
00396     }
00397 
00398     <span class="comment">/*</span>
00399 <span class="comment">     * Return if ExAllocate... failed.</span>
00400 <span class="comment">     */</span>
00401     <span class="keywordflow">if</span> (p == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00402         
00403         <span class="keywordflow">if</span> (<a class="code" href="../../d3/d2/w32_2ntuser_2kernel_2pool_8c.html#a0">gdwPoolFlags</a> &amp; <a class="code" href="../../d4/d1/userk_8h.html#a216">POOL_KEEP_FAIL_RECORD</a>) {
00404             
00405             uBytes -= <span class="keyword">sizeof</span>(Win32PoolHead);
00406 
00407             <span class="keywordflow">if</span> (<a class="code" href="../../d3/d2/w32_2ntuser_2kernel_2pool_8c.html#a0">gdwPoolFlags</a> &amp; <a class="code" href="../../d4/d1/userk_8h.html#a214">POOL_TAIL_CHECK</a>) {
00408                 uBytes -= <span class="keyword">sizeof</span>(gszTailAlloc);
00409             }
00410             
00411             RecordFailAllocation(tag, uBytes);
00412         }
00413         
00414         <span class="keywordflow">goto</span> <a class="code" href="../../d9/d1/fedefs_8h.html#a16">exit</a>;
00415     }
00416 
00417     uBytes -= <span class="keyword">sizeof</span>(Win32PoolHead);
00418 
00419     <span class="keywordflow">if</span> (<a class="code" href="../../d3/d2/w32_2ntuser_2kernel_2pool_8c.html#a0">gdwPoolFlags</a> &amp; <a class="code" href="../../d4/d1/userk_8h.html#a214">POOL_TAIL_CHECK</a>) {
00420         uBytes -= <span class="keyword">sizeof</span>(gszTailAlloc);
00421         
00422         RtlCopyMemory(((BYTE*)p) + uBytes, gszTailAlloc, <span class="keyword">sizeof</span>(gszTailAlloc));
00423     }
00424 
00425     <span class="comment">/*</span>
00426 <span class="comment">     * get the pointer to the header</span>
00427 <span class="comment">     */</span>
00428     ph = (PWin32PoolHead)p;
00429 
00430     p += (<span class="keyword">sizeof</span>(Win32PoolHead) / <span class="keyword">sizeof</span>(<a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a>));
00431 
00432     <span class="comment">/*</span>
00433 <span class="comment">     * Update the global allocations info.</span>
00434 <span class="comment">     */</span>
00435     gAllocList.<a class="code" href="../../d3/d9/structtagWin32AllocStats.html#o1">dwCrtMem</a> += uBytes;
00436 
00437     <span class="keywordflow">if</span> (gAllocList.<a class="code" href="../../d3/d9/structtagWin32AllocStats.html#o0">dwMaxMem</a> &lt; gAllocList.<a class="code" href="../../d3/d9/structtagWin32AllocStats.html#o1">dwCrtMem</a>) {
00438         gAllocList.<a class="code" href="../../d3/d9/structtagWin32AllocStats.html#o0">dwMaxMem</a> = gAllocList.<a class="code" href="../../d3/d9/structtagWin32AllocStats.html#o1">dwCrtMem</a>;
00439     }
00440 
00441     (gAllocList.<a class="code" href="../../d3/d9/structtagWin32AllocStats.html#o3">dwCrtAlloc</a>)++;
00442 
00443     <span class="keywordflow">if</span> (gAllocList.<a class="code" href="../../d3/d9/structtagWin32AllocStats.html#o2">dwMaxAlloc</a> &lt; gAllocList.<a class="code" href="../../d3/d9/structtagWin32AllocStats.html#o3">dwCrtAlloc</a>) {
00444         gAllocList.<a class="code" href="../../d3/d9/structtagWin32AllocStats.html#o2">dwMaxAlloc</a> = gAllocList.<a class="code" href="../../d3/d9/structtagWin32AllocStats.html#o3">dwCrtAlloc</a>;
00445     }
00446 
00447     <span class="comment">/*</span>
00448 <span class="comment">     * Grab the stack traces if the flags say so</span>
00449 <span class="comment">     */</span>
00450     <span class="keywordflow">if</span> (<a class="code" href="../../d3/d2/w32_2ntuser_2kernel_2pool_8c.html#a0">gdwPoolFlags</a> &amp; <a class="code" href="../../d4/d1/userk_8h.html#a211">POOL_CAPTURE_STACK</a>) {
00451         ph-&gt;pTrace = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>(SESSION_POOL_MASK | PagedPool,
00452                                            POOL_ALLOC_TRACE_SIZE * <span class="keyword">sizeof</span>(PVOID),
00453                                            TAG_STACK);
00454         
00455         <span class="keywordflow">if</span> (ph-&gt;pTrace != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00456             
00457             ULONG hash;
00458             
00459             RtlZeroMemory(ph-&gt;pTrace, POOL_ALLOC_TRACE_SIZE * <span class="keyword">sizeof</span>(PVOID));
00460 
00461             GetStackTrace(1,
00462                           POOL_ALLOC_TRACE_SIZE,
00463                           ph-&gt;pTrace,
00464                           &amp;hash);
00465         }
00466     } <span class="keywordflow">else</span> {
00467         ph-&gt;pTrace = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00468     }
00469 
00470     <span class="comment">/*</span>
00471 <span class="comment">     * Save the info in the header and return the pointer after the header.</span>
00472 <span class="comment">     */</span>
00473     ph-&gt;size = uBytes;
00474 
00475     <span class="comment">/*</span>
00476 <span class="comment">     * now, link it into the list for this tag (if any)</span>
00477 <span class="comment">     */</span>
00478     ph-&gt;pPrev = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00479     ph-&gt;pNext = gAllocList.<a class="code" href="../../d3/d9/structtagWin32AllocStats.html#o4">pHead</a>;
00480 
00481     <span class="keywordflow">if</span> (gAllocList.<a class="code" href="../../d3/d9/structtagWin32AllocStats.html#o4">pHead</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)
00482         gAllocList.<a class="code" href="../../d3/d9/structtagWin32AllocStats.html#o4">pHead</a>-&gt;pPrev = ph;
00483 
00484     gAllocList.<a class="code" href="../../d3/d9/structtagWin32AllocStats.html#o4">pHead</a> = ph;
00485 
00486     <span class="keywordflow">if</span> (<a class="code" href="../../d3/d8/propapi_8h.html#a34">dwFlags</a> &amp; DAP_ZEROINIT) {
00487         RtlZeroMemory(p, uBytes);
00488     }
00489 
00490 <a class="code" href="../../d9/d1/fedefs_8h.html#a16">exit</a>:
00491     <span class="comment">/*</span>
00492 <span class="comment">     * Release the mutex</span>
00493 <span class="comment">     */</span>
00494     <a class="code" href="../../d5/d8/ex_8h.html#a232">ExReleaseFastMutexUnsafe</a>(gpAllocFastMutex);
00495     <a class="code" href="../../d4/d9/ke_8h.html#a29">KeLeaveCriticalRegion</a>();
00496     
00497     <span class="keywordflow">return</span> p;
00498 }
00499 
00500 <span class="comment">/***************************************************************************\</span>
00501 <span class="comment">* HeavyFreePool</span>
00502 <span class="comment">*</span>
00503 <span class="comment">* 12-02-96 CLupu      Created.</span>
00504 <span class="comment">\***************************************************************************/</span>
00505 <span class="keywordtype">void</span> HeavyFreePool(
00506     PVOID p)
00507 {
00508     SIZE_T         uBytes;
00509     PWin32PoolHead ph;
00510 
00511     <span class="comment">/*</span>
00512 <span class="comment">     * If POOL_HEAVY_ALLOCS is not defined</span>
00513 <span class="comment">     * then the pointer is what we allocated</span>
00514 <span class="comment">     */</span>
00515     <span class="keywordflow">if</span> (!(<a class="code" href="../../d3/d2/w32_2ntuser_2kernel_2pool_8c.html#a0">gdwPoolFlags</a> &amp; <a class="code" href="../../d4/d1/userk_8h.html#a210">POOL_HEAVY_ALLOCS</a>)) {
00516         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(p);
00517         <span class="keywordflow">return</span>;
00518     }
00519     
00520     <span class="comment">/*</span>
00521 <span class="comment">     * Acquire the mutex when we play with the list of allocations</span>
00522 <span class="comment">     */</span>
00523     <a class="code" href="../../d4/d9/ke_8h.html#a28">KeEnterCriticalRegion</a>();
00524     <a class="code" href="../../d5/d8/ex_8h.html#a231">ExAcquireFastMutexUnsafe</a>(gpAllocFastMutex);
00525     
00526     ph = (PWin32PoolHead)((<a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a>*)p - (<span class="keyword">sizeof</span>(Win32PoolHead) / <span class="keyword">sizeof</span>(<a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a>)));
00527 
00528     uBytes = ph-&gt;size;
00529 
00530     <span class="comment">/*</span>
00531 <span class="comment">     * Check the tail</span>
00532 <span class="comment">     */</span>
00533     <span class="keywordflow">if</span> (<a class="code" href="../../d3/d2/w32_2ntuser_2kernel_2pool_8c.html#a0">gdwPoolFlags</a> &amp; <a class="code" href="../../d4/d1/userk_8h.html#a214">POOL_TAIL_CHECK</a>) {
00534         <span class="keywordflow">if</span> (!RtlEqualMemory((BYTE*)p + uBytes, gszTailAlloc, <span class="keyword">sizeof</span>(gszTailAlloc))) {
00535             RIPMSG1(RIP_ERROR, <span class="stringliteral">"POOL CORRUPTION for %#p"</span>, p);
00536         }
00537     }
00538 
00539     gAllocList.<a class="code" href="../../d3/d9/structtagWin32AllocStats.html#o1">dwCrtMem</a> -= uBytes;
00540 
00541     UserAssert(gAllocList.<a class="code" href="../../d3/d9/structtagWin32AllocStats.html#o3">dwCrtAlloc</a> &gt; 0);
00542 
00543     (gAllocList.<a class="code" href="../../d3/d9/structtagWin32AllocStats.html#o3">dwCrtAlloc</a>)--;
00544 
00545     <span class="comment">/*</span>
00546 <span class="comment">     * now, remove it from the linked list</span>
00547 <span class="comment">     */</span>
00548     <span class="keywordflow">if</span> (ph-&gt;pPrev == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00549         <span class="keywordflow">if</span> (ph-&gt;pNext == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00550 
00551             UserAssert(gAllocList.<a class="code" href="../../d3/d9/structtagWin32AllocStats.html#o3">dwCrtAlloc</a> == 0);
00552 
00553             gAllocList.<a class="code" href="../../d3/d9/structtagWin32AllocStats.html#o4">pHead</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00554         } <span class="keywordflow">else</span> {
00555             ph-&gt;pNext-&gt;pPrev = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00556             gAllocList.<a class="code" href="../../d3/d9/structtagWin32AllocStats.html#o4">pHead</a> = ph-&gt;pNext;
00557         }
00558     } <span class="keywordflow">else</span> {
00559         ph-&gt;pPrev-&gt;pNext = ph-&gt;pNext;
00560         <span class="keywordflow">if</span> (ph-&gt;pNext != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00561             ph-&gt;pNext-&gt;pPrev = ph-&gt;pPrev;
00562         }
00563     }
00564     
00565     <span class="comment">/*</span>
00566 <span class="comment">     * Free the stack traces</span>
00567 <span class="comment">     */</span>
00568     <span class="keywordflow">if</span> (ph-&gt;pTrace != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00569         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(ph-&gt;pTrace);
00570     }
00571 
00572     <span class="keywordflow">if</span> (<a class="code" href="../../d3/d2/w32_2ntuser_2kernel_2pool_8c.html#a0">gdwPoolFlags</a> &amp; <a class="code" href="../../d4/d1/userk_8h.html#a215">POOL_KEEP_FREE_RECORD</a>) {
00573         RecordFreePool(ph, ph-&gt;size);
00574     }
00575     
00576     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(ph);
00577     
00578     <span class="comment">/*</span>
00579 <span class="comment">     * Release the mutex</span>
00580 <span class="comment">     */</span>
00581     <a class="code" href="../../d5/d8/ex_8h.html#a232">ExReleaseFastMutexUnsafe</a>(gpAllocFastMutex);
00582     <a class="code" href="../../d4/d9/ke_8h.html#a29">KeLeaveCriticalRegion</a>();
00583 }
00584 
00585 <span class="comment">/***************************************************************************\</span>
00586 <span class="comment">* CleanupPoolAllocations</span>
00587 <span class="comment">*</span>
00588 <span class="comment">* 12-02-96 CLupu      Created.</span>
00589 <span class="comment">\***************************************************************************/</span>
00590 
00591 <span class="keywordtype">void</span> <a class="code" href="../../d4/d1/userk_8h.html#a218">CleanupPoolAllocations</a>(
00592     <span class="keywordtype">void</span>)
00593 {
00594     PWin32PoolHead pHead;
00595     PWin32PoolHead pNext;
00596 
00597     <span class="keywordflow">if</span> (gAllocList.<a class="code" href="../../d3/d9/structtagWin32AllocStats.html#o3">dwCrtAlloc</a> != 0) {
00598         
00599         <span class="keywordflow">if</span> ((<a class="code" href="../../d3/d2/w32_2ntuser_2kernel_2pool_8c.html#a0">gdwPoolFlags</a> &amp; <a class="code" href="../../d4/d1/userk_8h.html#a217">POOL_BREAK_FOR_LEAKS</a>) &amp;&amp;
00600             **((PBOOLEAN*)&amp;<a class="code" href="../../d7/d3/kd_8h.html#a13">KdDebuggerEnabled</a>)) {
00601 
00602             <span class="comment">/*</span>
00603 <span class="comment">             * The below is as is because it is intended to work on both</span>
00604 <span class="comment">             * free and checked builds.</span>
00605 <span class="comment">             */</span>
00606 <span class="preprocessor">            #undef DbgPrint</span>
00607 <span class="preprocessor"></span>            <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"\n------------------------\n"</span>
00608                      <span class="stringliteral">"There is still pool memory not freed in win32k.sys !!!\n"</span>
00609                      <span class="stringliteral">"Use !dpa -vs to dump it\n"</span>
00610                      <span class="stringliteral">"-------------------------\n"</span>);
00611             DbgBreakPoint();
00612         }
00613         
00614         pHead = gAllocList.<a class="code" href="../../d3/d9/structtagWin32AllocStats.html#o4">pHead</a>;
00615 
00616         <span class="keywordflow">while</span> (pHead != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00617 
00618             pNext = pHead-&gt;pNext;
00619 
00620             UserFreePool(pHead + 1);
00621 
00622             pHead = pNext;
00623         }
00624     }
00625 }
00626 
00627 <span class="comment">/***************************************************************************\</span>
00628 <span class="comment">* CleanUpPoolLimitations</span>
00629 <span class="comment">*</span>
00630 <span class="comment">\***************************************************************************/</span>
00631 <span class="keywordtype">void</span> <a class="code" href="../../d4/d1/userk_8h.html#a220">CleanUpPoolLimitations</a>(<span class="keywordtype">void</span>)
00632 {
00633     <span class="keywordflow">if</span> (gpAllocFastMutex != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00634         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(gpAllocFastMutex);
00635         gpAllocFastMutex = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00636     }
00637     
00638     <span class="keywordflow">if</span> (gparrFailRecord != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00639         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(gparrFailRecord);
00640         gparrFailRecord = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00641     }
00642     
00643     <span class="keywordflow">if</span> (gparrFreeRecord != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00644         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(gparrFreeRecord);
00645         gparrFreeRecord = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00646     }
00647 
00648     <span class="keywordflow">if</span> (gparrTagsToFail != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00649         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(gparrTagsToFail);
00650         gparrTagsToFail = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00651     }
00652     
00653 }
00654 
00655 <span class="comment">/***************************************************************************\</span>
00656 <span class="comment">* InitPoolLimitations</span>
00657 <span class="comment">*</span>
00658 <span class="comment">* 12-02-96 CLupu      Created.</span>
00659 <span class="comment">\***************************************************************************/</span>
00660 <span class="keywordtype">void</span> <a class="code" href="../../d4/d1/userk_8h.html#a219">InitPoolLimitations</a>(<span class="keywordtype">void</span>)
00661 {
00662     UNICODE_STRING      UnicodeString;
00663     OBJECT_ATTRIBUTES   <a class="code" href="../../d7/d0/ctlnpqos_8c.html#a4">ObjectAttributes</a>;
00664     HANDLE              hkey;
00665     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>            <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00666     WCHAR               achKeyName[512];
00667     WCHAR               achKeyValue[512];
00668     <a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a>               dwData;
00669     ULONG               ucb;
00670     
00671     <span class="comment">/*</span>
00672 <span class="comment">     * Initialize a critical section structure that will be used to protect</span>
00673 <span class="comment">     * all the HeavyAllocPool and HeavyFreePool calls</span>
00674 <span class="comment">     */</span>
00675     gpAllocFastMutex = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>(NonPagedPoolMustSucceed,
00676                                              <span class="keyword">sizeof</span>(<a class="code" href="../../d6/d9/struct__FAST__MUTEX.html">FAST_MUTEX</a>),
00677                                              TAG_DEBUG);
00678 
00679     UserAssert(gpAllocFastMutex != NULL);
00680 
00681     <a class="code" href="../../d5/d8/ex_8h.html#a8">ExInitializeFastMutex</a>(gpAllocFastMutex);
00682 
00683     <span class="comment">/*</span>
00684 <span class="comment">     * Default settings</span>
00685 <span class="comment">     */</span>
00686     <span class="keywordflow">if</span> (<a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a328">gbRemoteSession</a>) {
00687         <a class="code" href="../../d3/d2/w32_2ntuser_2kernel_2pool_8c.html#a0">gdwPoolFlags</a> = <a class="code" href="../../d4/d1/userk_8h.html#a210">POOL_HEAVY_ALLOCS</a>;
00688 
00689 <span class="preprocessor">#if DBG</span>
00690 <span class="preprocessor"></span>        <a class="code" href="../../d3/d2/w32_2ntuser_2kernel_2pool_8c.html#a0">gdwPoolFlags</a> |= (<a class="code" href="../../d4/d1/userk_8h.html#a211">POOL_CAPTURE_STACK</a> | <a class="code" href="../../d4/d1/userk_8h.html#a217">POOL_BREAK_FOR_LEAKS</a>);
00691 <span class="preprocessor">#endif // DBG</span>
00692 <span class="preprocessor"></span>    }
00693     
00694     <span class="comment">/*</span>
00695 <span class="comment">     * Open the key containing the limits.</span>
00696 <span class="comment">     */</span>
00697     <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(
00698             &amp;UnicodeString,
00699             L<span class="stringliteral">"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Session Manager\\SubSystems\\Pool"</span>);
00700 
00701     InitializeObjectAttributes(
00702             &amp;ObjectAttributes, &amp;UnicodeString, OBJ_CASE_INSENSITIVE, NULL, NULL);
00703 
00704     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwOpenKey(&amp;hkey, KEY_READ, &amp;ObjectAttributes);
00705     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(Status)) {
00706         
00707 <span class="preprocessor">#if DBG</span>
00708 <span class="preprocessor"></span>        <span class="comment">/*</span>
00709 <span class="comment">         * More default settings if the Pool key doesn't exist</span>
00710 <span class="comment">         */</span>
00711         <span class="keywordflow">if</span> (<a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a328">gbRemoteSession</a>) {
00712 
00713             gparrFailRecord = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>(PagedPool,
00714                                                     32 * <span class="keyword">sizeof</span>(<a class="code" href="../../d3/d3/structtagPOOLRECORD.html">POOLRECORD</a>),
00715                                                     TAG_DEBUG);
00716 
00717             <span class="keywordflow">if</span> (gparrFailRecord != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00718                 gdwFailRecords = 32;
00719                 <a class="code" href="../../d3/d2/w32_2ntuser_2kernel_2pool_8c.html#a0">gdwPoolFlags</a> |= <a class="code" href="../../d4/d1/userk_8h.html#a216">POOL_KEEP_FAIL_RECORD</a>;
00720             }
00721             
00722             gparrFreeRecord = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>(PagedPool,
00723                                                     32 * <span class="keyword">sizeof</span>(<a class="code" href="../../d3/d3/structtagPOOLRECORD.html">POOLRECORD</a>),
00724                                                     TAG_DEBUG);
00725 
00726             <span class="keywordflow">if</span> (gparrFreeRecord != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00727                 gdwFreeRecords = 32;
00728                 <a class="code" href="../../d3/d2/w32_2ntuser_2kernel_2pool_8c.html#a0">gdwPoolFlags</a> |= <a class="code" href="../../d4/d1/userk_8h.html#a215">POOL_KEEP_FREE_RECORD</a>;
00729             }
00730         }
00731 <span class="preprocessor">#endif // DBG</span>
00732 <span class="preprocessor"></span>        
00733         <span class="keywordflow">return</span>;
00734     }
00735 
00736     <span class="keywordflow">if</span> (<a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a328">gbRemoteSession</a>) {
00737         
00738         <span class="comment">/*</span>
00739 <span class="comment">         * Break in the debugger for memory leaks ?</span>
00740 <span class="comment">         */</span>
00741         <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;UnicodeString, L<span class="stringliteral">"BreakForPoolLeaks"</span>);
00742 
00743         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwQueryValueKey(
00744                 hkey,
00745                 &amp;UnicodeString,
00746                 KeyValuePartialInformation,
00747                 &amp;achKeyValue,
00748                 <span class="keyword">sizeof</span>(achKeyValue),
00749                 &amp;ucb);
00750 
00751         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(Status) &amp;&amp;
00752                 ((PKEY_VALUE_PARTIAL_INFORMATION)achKeyValue)-&gt;Type == REG_DWORD) {
00753 
00754             dwData = *((PDWORD)((PKEY_VALUE_PARTIAL_INFORMATION)achKeyValue)-&gt;Data);
00755 
00756             <span class="keywordflow">if</span> (dwData != 0) {
00757                 <a class="code" href="../../d3/d2/w32_2ntuser_2kernel_2pool_8c.html#a0">gdwPoolFlags</a> |= <a class="code" href="../../d4/d1/userk_8h.html#a217">POOL_BREAK_FOR_LEAKS</a>;
00758             } <span class="keywordflow">else</span> {
00759                 <a class="code" href="../../d3/d2/w32_2ntuser_2kernel_2pool_8c.html#a0">gdwPoolFlags</a> &amp;= ~<a class="code" href="../../d4/d1/userk_8h.html#a217">POOL_BREAK_FOR_LEAKS</a>;
00760             }
00761         }
00762         
00763         <span class="comment">/*</span>
00764 <span class="comment">         * Heavy allocs/frees for remote sessions ?</span>
00765 <span class="comment">         */</span>
00766         <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;UnicodeString, L<span class="stringliteral">"HeavyRemoteSession"</span>);
00767 
00768         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwQueryValueKey(
00769                 hkey,
00770                 &amp;UnicodeString,
00771                 KeyValuePartialInformation,
00772                 &amp;achKeyValue,
00773                 <span class="keyword">sizeof</span>(achKeyValue),
00774                 &amp;ucb);
00775 
00776         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(Status) &amp;&amp;
00777                 ((PKEY_VALUE_PARTIAL_INFORMATION)achKeyValue)-&gt;Type == REG_DWORD) {
00778 
00779             dwData = *((PDWORD)((PKEY_VALUE_PARTIAL_INFORMATION)achKeyValue)-&gt;Data);
00780 
00781             <span class="keywordflow">if</span> (dwData == 0) {
00782                 <a class="code" href="../../d3/d2/w32_2ntuser_2kernel_2pool_8c.html#a0">gdwPoolFlags</a> &amp;= ~<a class="code" href="../../d4/d1/userk_8h.html#a210">POOL_HEAVY_ALLOCS</a>;
00783             }
00784         }
00785     } <span class="keywordflow">else</span> {
00786         
00787         <span class="comment">/*</span>
00788 <span class="comment">         * Heavy allocs/frees for main session ?</span>
00789 <span class="comment">         */</span>
00790         <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;UnicodeString, L<span class="stringliteral">"HeavyConsoleSession"</span>);
00791 
00792         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwQueryValueKey(
00793                 hkey,
00794                 &amp;UnicodeString,
00795                 KeyValuePartialInformation,
00796                 &amp;achKeyValue,
00797                 <span class="keyword">sizeof</span>(achKeyValue),
00798                 &amp;ucb);
00799 
00800         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(Status) &amp;&amp;
00801                 ((PKEY_VALUE_PARTIAL_INFORMATION)achKeyValue)-&gt;Type == REG_DWORD) {
00802 
00803             dwData = *((PDWORD)((PKEY_VALUE_PARTIAL_INFORMATION)achKeyValue)-&gt;Data);
00804 
00805             <span class="keywordflow">if</span> (dwData != 0) {
00806                 <a class="code" href="../../d3/d2/w32_2ntuser_2kernel_2pool_8c.html#a0">gdwPoolFlags</a> |= <a class="code" href="../../d4/d1/userk_8h.html#a210">POOL_HEAVY_ALLOCS</a>;
00807             }
00808         }
00809     }
00810     
00811     <span class="keywordflow">if</span> (!(<a class="code" href="../../d3/d2/w32_2ntuser_2kernel_2pool_8c.html#a0">gdwPoolFlags</a> &amp; <a class="code" href="../../d4/d1/userk_8h.html#a210">POOL_HEAVY_ALLOCS</a>)) {
00812         ZwClose(hkey);
00813         <span class="keywordflow">return</span>;
00814     }
00815     
00816     <span class="comment">/*</span>
00817 <span class="comment">     * Check for stack traces</span>
00818 <span class="comment">     */</span>
00819     <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;UnicodeString, L<span class="stringliteral">"StackTraces"</span>);
00820 
00821     RtlZeroMemory(achKeyName, <span class="keyword">sizeof</span>(achKeyName));
00822 
00823     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwQueryValueKey(
00824             hkey,
00825             &amp;UnicodeString,
00826             KeyValuePartialInformation,
00827             &amp;achKeyValue,
00828             <span class="keyword">sizeof</span>(achKeyValue),
00829             &amp;ucb);
00830 
00831     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(Status) &amp;&amp;
00832             ((PKEY_VALUE_PARTIAL_INFORMATION)achKeyValue)-&gt;Type == REG_DWORD) {
00833 
00834         dwData = *((PDWORD)((PKEY_VALUE_PARTIAL_INFORMATION)achKeyValue)-&gt;Data);
00835 
00836         <span class="keywordflow">if</span> (dwData == 0) {
00837             <a class="code" href="../../d3/d2/w32_2ntuser_2kernel_2pool_8c.html#a0">gdwPoolFlags</a> &amp;= ~<a class="code" href="../../d4/d1/userk_8h.html#a211">POOL_CAPTURE_STACK</a>;
00838         } <span class="keywordflow">else</span> {
00839             <a class="code" href="../../d3/d2/w32_2ntuser_2kernel_2pool_8c.html#a0">gdwPoolFlags</a> |= <a class="code" href="../../d4/d1/userk_8h.html#a211">POOL_CAPTURE_STACK</a>;
00840         }
00841     }
00842 
00843     <span class="comment">/*</span>
00844 <span class="comment">     * Use tail checks ?</span>
00845 <span class="comment">     */</span>
00846     <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;UnicodeString, L<span class="stringliteral">"UseTailString"</span>);
00847 
00848     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwQueryValueKey(
00849             hkey,
00850             &amp;UnicodeString,
00851             KeyValuePartialInformation,
00852             &amp;achKeyValue,
00853             <span class="keyword">sizeof</span>(achKeyValue),
00854             &amp;ucb);
00855 
00856     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(Status) &amp;&amp;
00857             ((PKEY_VALUE_PARTIAL_INFORMATION)achKeyValue)-&gt;Type == REG_DWORD) {
00858 
00859         dwData = *((PDWORD)((PKEY_VALUE_PARTIAL_INFORMATION)achKeyValue)-&gt;Data);
00860 
00861         <span class="keywordflow">if</span> (dwData != 0) {
00862             <a class="code" href="../../d3/d2/w32_2ntuser_2kernel_2pool_8c.html#a0">gdwPoolFlags</a> |= <a class="code" href="../../d4/d1/userk_8h.html#a214">POOL_TAIL_CHECK</a>;
00863         }
00864     }
00865     
00866     <span class="comment">/*</span>
00867 <span class="comment">     * Keep a record of frees ? By default keep the last 32.</span>
00868 <span class="comment">     */</span>
00869 <span class="preprocessor">#if DBG</span>
00870 <span class="preprocessor"></span>    gdwFreeRecords = 32;
00871 <span class="preprocessor">#endif // DBG</span>
00872 <span class="preprocessor"></span>
00873     <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;UnicodeString, L<span class="stringliteral">"KeepFreeRecords"</span>);
00874 
00875     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwQueryValueKey(
00876             hkey,
00877             &amp;UnicodeString,
00878             KeyValuePartialInformation,
00879             &amp;achKeyValue,
00880             <span class="keyword">sizeof</span>(achKeyValue),
00881             &amp;ucb);
00882 
00883     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(Status) &amp;&amp;
00884             ((PKEY_VALUE_PARTIAL_INFORMATION)achKeyValue)-&gt;Type == REG_DWORD) {
00885 
00886         gdwFreeRecords = *((PDWORD)((PKEY_VALUE_PARTIAL_INFORMATION)achKeyValue)-&gt;Data);
00887     }
00888     
00889     <span class="keywordflow">if</span> (gdwFreeRecords != 0) {
00890 
00891         gparrFreeRecord = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>(PagedPool,
00892                                                 gdwFreeRecords * <span class="keyword">sizeof</span>(<a class="code" href="../../d3/d3/structtagPOOLRECORD.html">POOLRECORD</a>),
00893                                                 TAG_DEBUG);
00894 
00895         <span class="keywordflow">if</span> (gparrFreeRecord != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00896             <a class="code" href="../../d3/d2/w32_2ntuser_2kernel_2pool_8c.html#a0">gdwPoolFlags</a> |= <a class="code" href="../../d4/d1/userk_8h.html#a215">POOL_KEEP_FREE_RECORD</a>;
00897         }
00898     }
00899 
00900     <span class="comment">/*</span>
00901 <span class="comment">     * Keep a record of failed allocations ? By default keep the last 32.</span>
00902 <span class="comment">     */</span>
00903 <span class="preprocessor">#if DBG</span>
00904 <span class="preprocessor"></span>    gdwFailRecords = 32;
00905 <span class="preprocessor">#endif // DBG</span>
00906 <span class="preprocessor"></span>
00907     <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;UnicodeString, L<span class="stringliteral">"KeepFailRecords"</span>);
00908 
00909     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwQueryValueKey(
00910             hkey,
00911             &amp;UnicodeString,
00912             KeyValuePartialInformation,
00913             &amp;achKeyValue,
00914             <span class="keyword">sizeof</span>(achKeyValue),
00915             &amp;ucb);
00916 
00917     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(Status) &amp;&amp;
00918             ((PKEY_VALUE_PARTIAL_INFORMATION)achKeyValue)-&gt;Type == REG_DWORD) {
00919 
00920         gdwFailRecords = *((PDWORD)((PKEY_VALUE_PARTIAL_INFORMATION)achKeyValue)-&gt;Data);
00921     }
00922     
00923     <span class="keywordflow">if</span> (gdwFailRecords != 0) {
00924 
00925         gparrFailRecord = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>(PagedPool,
00926                                                 gdwFailRecords * <span class="keyword">sizeof</span>(<a class="code" href="../../d3/d3/structtagPOOLRECORD.html">POOLRECORD</a>),
00927                                                 TAG_DEBUG);
00928 
00929         <span class="keywordflow">if</span> (gparrFailRecord != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00930             <a class="code" href="../../d3/d2/w32_2ntuser_2kernel_2pool_8c.html#a0">gdwPoolFlags</a> |= <a class="code" href="../../d4/d1/userk_8h.html#a216">POOL_KEEP_FAIL_RECORD</a>;
00931         }
00932     }
00933 
00934 <span class="preprocessor">#if DBG</span>
00935 <span class="preprocessor"></span>    <span class="comment">/*</span>
00936 <span class="comment">     * Open the key containing the allocation that should fail.</span>
00937 <span class="comment">     */</span>
00938     <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;UnicodeString, L<span class="stringliteral">"AllocationIndex"</span>);
00939 
00940     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwQueryValueKey(
00941             hkey,
00942             &amp;UnicodeString,
00943             KeyValuePartialInformation,
00944             &amp;achKeyValue,
00945             <span class="keyword">sizeof</span>(achKeyValue),
00946             &amp;ucb);
00947 
00948     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(Status) &amp;&amp;
00949             ((PKEY_VALUE_PARTIAL_INFORMATION)achKeyValue)-&gt;Type == REG_DWORD) {
00950 
00951         gdwAllocFailIndex = *((PDWORD)((PKEY_VALUE_PARTIAL_INFORMATION)achKeyValue)-&gt;Data);
00952     }
00953 
00954 
00955     <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;UnicodeString, L<span class="stringliteral">"AllocationsToFail"</span>);
00956 
00957     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwQueryValueKey(
00958             hkey,
00959             &amp;UnicodeString,
00960             KeyValuePartialInformation,
00961             &amp;achKeyValue,
00962             <span class="keyword">sizeof</span>(achKeyValue),
00963             &amp;ucb);
00964 
00965     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(Status) &amp;&amp;
00966             ((PKEY_VALUE_PARTIAL_INFORMATION)achKeyValue)-&gt;Type == REG_DWORD) {
00967 
00968         gdwAllocsToFail = *((PDWORD)((PKEY_VALUE_PARTIAL_INFORMATION)achKeyValue)-&gt;Data);
00969     }
00970 
00971     <span class="keywordflow">if</span> (gdwAllocFailIndex != 0 &amp;&amp; gdwAllocsToFail &gt; 0) {
00972         <a class="code" href="../../d3/d2/w32_2ntuser_2kernel_2pool_8c.html#a0">gdwPoolFlags</a> |= <a class="code" href="../../d4/d1/userk_8h.html#a213">POOL_FAIL_BY_INDEX</a>;
00973     }
00974 <span class="preprocessor">#endif // DBG</span>
00975 <span class="preprocessor"></span>
00976     ZwClose(hkey);
00977 
00978     <span class="keywordflow">return</span>;
00979 }
00980 <span class="preprocessor">#endif // POOL_INSTR</span>
00981 <span class="preprocessor"></span>
00982 <span class="preprocessor">#ifdef POOL_INSTR_API</span>
00983 <span class="preprocessor"></span>
00984 <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a11">BOOL</a> _Win32PoolAllocationStats(
00985     LPDWORD  parrTags,
00986     SIZE_T   tagsCount,
00987     SIZE_T*  lpdwMaxMem,
00988     SIZE_T*  lpdwCrtMem,
00989     LPDWORD  lpdwMaxAlloc,
00990     LPDWORD  lpdwCrtAlloc)
00991 {
00992     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a11">BOOL</a> bRet = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00993 
00994     <span class="comment">/*</span>
00995 <span class="comment">     * Do nothing if heavy allocs/frees are disabled</span>
00996 <span class="comment">     */</span>
00997     <span class="keywordflow">if</span> (!(<a class="code" href="../../d3/d2/w32_2ntuser_2kernel_2pool_8c.html#a0">gdwPoolFlags</a> &amp; <a class="code" href="../../d4/d1/userk_8h.html#a210">POOL_HEAVY_ALLOCS</a>)) {
00998         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00999     }
01000     
01001     *lpdwMaxMem   = gAllocList.<a class="code" href="../../d3/d9/structtagWin32AllocStats.html#o0">dwMaxMem</a>;
01002     *lpdwCrtMem   = gAllocList.<a class="code" href="../../d3/d9/structtagWin32AllocStats.html#o1">dwCrtMem</a>;
01003     *lpdwMaxAlloc = gAllocList.<a class="code" href="../../d3/d9/structtagWin32AllocStats.html#o2">dwMaxAlloc</a>;
01004     *lpdwCrtAlloc = gAllocList.<a class="code" href="../../d3/d9/structtagWin32AllocStats.html#o3">dwCrtAlloc</a>;
01005     
01006     <span class="comment">/*</span>
01007 <span class="comment">     * Acquire the mutex when we play with the list of allocations</span>
01008 <span class="comment">     */</span>
01009     <a class="code" href="../../d4/d9/ke_8h.html#a28">KeEnterCriticalRegion</a>();
01010     <a class="code" href="../../d5/d8/ex_8h.html#a231">ExAcquireFastMutexUnsafe</a>(gpAllocFastMutex);
01011     
01012     <span class="keywordflow">if</span> (gparrTagsToFail != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01013         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(gparrTagsToFail);
01014         gparrTagsToFail = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01015         gdwTagsToFailCount = 0;
01016     }
01017 
01018     <span class="keywordflow">if</span> (tagsCount != 0) {
01019         <a class="code" href="../../d3/d2/w32_2ntuser_2kernel_2pool_8c.html#a0">gdwPoolFlags</a> |= <a class="code" href="../../d4/d1/userk_8h.html#a212">POOL_FAIL_ALLOCS</a>;
01020 
01021         <span class="keywordflow">if</span> (tagsCount &gt; MAX_TAGS_TO_FAIL) {
01022             gdwTagsToFailCount = 0xFFFFFFFF;
01023             RIPMSG0(RIP_WARNING, <span class="stringliteral">"All pool allocations in WIN32K.SYS will fail !!!"</span>);
01024             bRet = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01025             <span class="keywordflow">goto</span> <a class="code" href="../../d9/d1/fedefs_8h.html#a16">exit</a>;
01026         }
01027 
01028     } <span class="keywordflow">else</span> {
01029         <a class="code" href="../../d3/d2/w32_2ntuser_2kernel_2pool_8c.html#a0">gdwPoolFlags</a> &amp;= ~<a class="code" href="../../d4/d1/userk_8h.html#a212">POOL_FAIL_ALLOCS</a>;
01030         
01031         RIPMSG0(RIP_WARNING, <span class="stringliteral">"Pool allocations in WIN32K.SYS back to normal !"</span>);
01032         bRet = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01033         <span class="keywordflow">goto</span> <a class="code" href="../../d9/d1/fedefs_8h.html#a16">exit</a>;
01034     }
01035     
01036     gparrTagsToFail = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>(PagedPool,
01037                                             <span class="keyword">sizeof</span>(DWORD) * tagsCount,
01038                                             TAG_DEBUG);
01039     
01040     <span class="keywordflow">if</span> (gparrTagsToFail == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01041         <a class="code" href="../../d3/d2/w32_2ntuser_2kernel_2pool_8c.html#a0">gdwPoolFlags</a> &amp;= ~<a class="code" href="../../d4/d1/userk_8h.html#a212">POOL_FAIL_ALLOCS</a>;
01042         RIPMSG0(RIP_WARNING, <span class="stringliteral">"Pool allocations in WIN32K.SYS back to normal !"</span>);
01043         <span class="keywordflow">goto</span> <a class="code" href="../../d9/d1/fedefs_8h.html#a16">exit</a>;
01044     }
01045 
01046     <span class="keywordflow">try</span> {
01047         <a class="code" href="../../d5/d8/ex_8h.html#a11">ProbeForRead</a>(parrTags, <span class="keyword">sizeof</span>(DWORD) * tagsCount, DATAALIGN);
01048 
01049         RtlCopyMemory(gparrTagsToFail, parrTags, <span class="keyword">sizeof</span>(DWORD) * tagsCount);
01050 
01051     } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
01052           
01053           <span class="keywordflow">if</span> (gparrTagsToFail != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01054               <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(gparrTagsToFail);
01055               gparrTagsToFail = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01056               
01057               <a class="code" href="../../d3/d2/w32_2ntuser_2kernel_2pool_8c.html#a0">gdwPoolFlags</a> &amp;= ~<a class="code" href="../../d4/d1/userk_8h.html#a212">POOL_FAIL_ALLOCS</a>;
01058               RIPMSG0(RIP_WARNING, <span class="stringliteral">"Pool allocations in WIN32K.SYS back to normal !"</span>);
01059               <span class="keywordflow">goto</span> <a class="code" href="../../d9/d1/fedefs_8h.html#a16">exit</a>;
01060           }
01061     }
01062     gdwTagsToFailCount = tagsCount;
01063         
01064     RIPMSG0(RIP_WARNING, <span class="stringliteral">"Specific pool allocations in WIN32K.SYS will fail !!!"</span>);
01065 
01066 <a class="code" href="../../d9/d1/fedefs_8h.html#a16">exit</a>:        
01067     <span class="comment">/*</span>
01068 <span class="comment">     * Release the mutex</span>
01069 <span class="comment">     */</span>
01070     <a class="code" href="../../d5/d8/ex_8h.html#a232">ExReleaseFastMutexUnsafe</a>(gpAllocFastMutex);
01071     <a class="code" href="../../d4/d9/ke_8h.html#a29">KeLeaveCriticalRegion</a>();
01072     
01073     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01074 }
01075 
01076 <span class="preprocessor">#endif // POOL_INSTR_API</span>
01077 <span class="preprocessor"></span>
01078 <span class="preprocessor">#ifdef TRACE_MAP_VIEWS</span>
01079 <span class="preprocessor"></span>
01080 <a class="code" href="../../d6/d9/struct__FAST__MUTEX.html">FAST_MUTEX</a>*   gpSectionFastMutex;
01081 PWin32Section gpSections;
01082 
01083 <span class="preprocessor">#define EnterSectionCrit()                          \</span>
01084 <span class="preprocessor">    KeEnterCriticalRegion();                        \</span>
01085 <span class="preprocessor">    ExAcquireFastMutexUnsafe(gpSectionFastMutex);</span>
01086 <span class="preprocessor"></span>
01087 <span class="preprocessor">#define LeaveSectionCrit()                          \</span>
01088 <span class="preprocessor">    ExReleaseFastMutexUnsafe(gpSectionFastMutex);   \</span>
01089 <span class="preprocessor">    KeLeaveCriticalRegion();</span>
01090 <span class="preprocessor"></span>
01091 
01092 <span class="comment">/***************************************************************************\</span>
01093 <span class="comment">* CleanUpSections</span>
01094 <span class="comment">*</span>
01095 <span class="comment">\***************************************************************************/</span>
01096 <span class="keywordtype">void</span> <a class="code" href="../../d4/d1/userk_8h.html#a222">CleanUpSections</a>(<span class="keywordtype">void</span>)
01097 {
01098     <span class="keywordflow">if</span> (gpSectionFastMutex) {
01099         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(gpSectionFastMutex);
01100         gpSectionFastMutex = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01101     }
01102 }
01103 
01104 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a> <a class="code" href="../../d4/d1/userk_8h.html#a221">InitSectionTrace</a>(VOID)
01105 {
01106     gpSectionFastMutex = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>(NonPagedPoolMustSucceed,
01107                                                <span class="keyword">sizeof</span>(<a class="code" href="../../d6/d9/struct__FAST__MUTEX.html">FAST_MUTEX</a>),
01108                                                TAG_DEBUG);
01109 
01110     UserAssert(gpSectionFastMutex != NULL);
01111 
01112     <a class="code" href="../../d5/d8/ex_8h.html#a8">ExInitializeFastMutex</a>(gpSectionFastMutex);
01113 }
01114 
01115 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> _Win32CreateSection(
01116     PVOID*              pSectionObject,
01117     ACCESS_MASK         DesiredAccess,
01118     POBJECT_ATTRIBUTES  ObjectAttributes,
01119     PLARGE_INTEGER      pInputMaximumSize,
01120     ULONG               SectionPageProtection,
01121     ULONG               AllocationAttributes,
01122     HANDLE              FileHandle,
01123     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>        FileObject,
01124     DWORD               SectionTag)
01125 {
01126     PWin32Section pSection;
01127     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>      <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01128 
01129 <span class="preprocessor">#ifdef MAP_VIEW_STACK_TRACE</span>
01130 <span class="preprocessor"></span>    ULONG         hash;
01131 <span class="preprocessor">#endif</span>
01132 <span class="preprocessor"></span>
01133     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d0/d8/creasect_8c.html#a20">MmCreateSection</a>(
01134                     pSectionObject,
01135                     DesiredAccess,
01136                     ObjectAttributes,
01137                     pInputMaximumSize,
01138                     SectionPageProtection,
01139                     AllocationAttributes,
01140                     FileHandle,
01141                     FileObject);
01142 
01143     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(Status)) {
01144         RIPMSG1(RIP_WARNING, <span class="stringliteral">"MmCreateSection failed with Statu %x"</span>, Status);
01145         *pSectionObject = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01146         <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01147     }
01148 
01149     pSection = UserAllocPoolZInit(<span class="keyword">sizeof</span>(Win32Section), TAG_SECTION);
01150 
01151     <span class="keywordflow">if</span> (pSection == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01152         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>(*pSectionObject);
01153         RIPMSG0(RIP_WARNING, <span class="stringliteral">"Failed to allocate memory for section"</span>);
01154         *pSectionObject = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01155         <span class="keywordflow">return</span> STATUS_UNSUCCESSFUL;
01156     }
01157 
01158     EnterSectionCrit();
01159 
01160     pSection-&gt;pNext = gpSections;
01161     <span class="keywordflow">if</span> (gpSections != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01162         UserAssert(gpSections-&gt;pPrev == NULL);
01163         gpSections-&gt;pPrev = pSection;
01164     }
01165 
01166     pSection-&gt;SectionObject = *pSectionObject;
01167     pSection-&gt;SectionSize   = *pInputMaximumSize;
01168     pSection-&gt;SectionTag    = SectionTag;
01169 
01170     gpSections = pSection;
01171 
01172 <span class="preprocessor">#ifdef MAP_VIEW_STACK_TRACE</span>
01173 <span class="preprocessor"></span>    RtlZeroMemory(pSection-&gt;trace, MAP_VIEW_STACK_TRACE_SIZE * <span class="keyword">sizeof</span>(PVOID));
01174 
01175     GetStackTrace(1,
01176                   MAP_VIEW_STACK_TRACE_SIZE,
01177                   pSection-&gt;trace,
01178                   &amp;hash);
01179 
01180 <span class="preprocessor">#endif // MAP_VIEW_STACK_TRACE</span>
01181 <span class="preprocessor"></span>
01182     LeaveSectionCrit();
01183 
01184     <span class="keywordflow">return</span> STATUS_SUCCESS;
01185 
01186 }
01187 
01188 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a> _Win32DestroySection(
01189     PVOID Section)
01190 {
01191     PWin32Section ps;
01192 
01193     EnterSectionCrit();
01194 
01195     ps = gpSections;
01196 
01197     <span class="keywordflow">while</span> (ps != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01198         <span class="keywordflow">if</span> (ps-&gt;SectionObject == Section) {
01199 
01200             <span class="comment">/*</span>
01201 <span class="comment">             * Make sure there is no view mapped for this section</span>
01202 <span class="comment">             */</span>
01203             <span class="keywordflow">if</span> (ps-&gt;pFirstView != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01204                 RIPMSG1(RIP_ERROR, <span class="stringliteral">"Section %#p still has views"</span>, ps);
01205             }
01206 
01207             <span class="comment">/*</span>
01208 <span class="comment">             * now, remove it from the linked list of this tag</span>
01209 <span class="comment">             */</span>
01210             <span class="keywordflow">if</span> (ps-&gt;pPrev == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01211 
01212                 UserAssert(ps == gpSections);
01213 
01214                 gpSections = ps-&gt;pNext;
01215 
01216                 <span class="keywordflow">if</span> (ps-&gt;pNext != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01217                     ps-&gt;pNext-&gt;pPrev = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01218                 }
01219             } <span class="keywordflow">else</span> {
01220                 ps-&gt;pPrev-&gt;pNext = ps-&gt;pNext;
01221                 <span class="keywordflow">if</span> (ps-&gt;pNext != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01222                     ps-&gt;pNext-&gt;pPrev = ps-&gt;pPrev;
01223                 }
01224             }
01225             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>(Section);
01226             UserFreePool(ps);
01227             LeaveSectionCrit();
01228             <span class="keywordflow">return</span>;
01229         }
01230         ps = ps-&gt;pNext;
01231     }
01232 
01233     RIPMSG1(RIP_ERROR, <span class="stringliteral">"Cannot find Section %#p"</span>, Section);
01234     LeaveSectionCrit();
01235 }
01236 
01237 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> _Win32MapViewInSessionSpace(
01238     PVOID   Section,
01239     PVOID*  pMappedBase,
01240     PSIZE_T pViewSize)
01241 {
01242     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>      <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01243     PWin32Section ps;
01244     PWin32MapView pMapView;
01245 
01246 <span class="preprocessor">#ifdef MAP_VIEW_STACK_TRACE</span>
01247 <span class="preprocessor"></span>    ULONG         hash;
01248 <span class="preprocessor">#endif</span>
01249 <span class="preprocessor"></span>
01250     <span class="comment">/*</span>
01251 <span class="comment">     * First try to map the view</span>
01252 <span class="comment">     */</span>
01253     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d3/d5/mapview_8c.html#a28">MmMapViewInSessionSpace</a>(Section, pMappedBase, pViewSize);
01254 
01255     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(Status)) {
01256         RIPMSG1(RIP_WARNING, <span class="stringliteral">"MmMapViewInSessionSpace failed with Status %x"</span>,
01257                 Status);
01258         *pMappedBase = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01259         <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01260     }
01261 
01262     <span class="comment">/*</span>
01263 <span class="comment">     * Now add a record for this view</span>
01264 <span class="comment">     */</span>
01265     pMapView = UserAllocPoolZInit(<span class="keyword">sizeof</span>(Win32MapView), TAG_SECTION);
01266 
01267     <span class="keywordflow">if</span> (pMapView == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01268         RIPMSG0(RIP_WARNING, <span class="stringliteral">"_Win32MapViewInSessionSpace: Memory failure"</span>);
01269 
01270         <a class="code" href="../../d3/d5/mapview_8c.html#a30">MmUnmapViewInSessionSpace</a>(*pMappedBase);
01271         *pMappedBase = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01272         <span class="keywordflow">return</span> STATUS_NO_MEMORY;
01273     }
01274 
01275     pMapView-&gt;pViewBase = *pMappedBase;
01276     pMapView-&gt;ViewSize  = *pViewSize;
01277 
01278     EnterSectionCrit();
01279 
01280     ps = gpSections;
01281 
01282     <span class="keywordflow">while</span> (ps != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01283         <span class="keywordflow">if</span> (ps-&gt;SectionObject == Section) {
01284 
01285             pMapView-&gt;pSection = ps;
01286 
01287             pMapView-&gt;pNext = ps-&gt;pFirstView;
01288 
01289             <span class="keywordflow">if</span> (ps-&gt;pFirstView != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01290                 ps-&gt;pFirstView-&gt;pPrev = pMapView;
01291             }
01292             ps-&gt;pFirstView = pMapView;
01293 
01294 <span class="preprocessor">#ifdef MAP_VIEW_STACK_TRACE</span>
01295 <span class="preprocessor"></span>            RtlZeroMemory(pMapView-&gt;trace, MAP_VIEW_STACK_TRACE_SIZE * <span class="keyword">sizeof</span>(PVOID));
01296 
01297             GetStackTrace(1,
01298                           MAP_VIEW_STACK_TRACE_SIZE,
01299                           pMapView-&gt;trace,
01300                           &amp;hash);
01301 
01302 <span class="preprocessor">#endif // MAP_VIEW_STACK_TRACE</span>
01303 <span class="preprocessor"></span>
01304             LeaveSectionCrit();
01305             <span class="keywordflow">return</span> STATUS_SUCCESS;
01306         }
01307         ps = ps-&gt;pNext;
01308     }
01309 
01310     RIPMSG1(RIP_ERROR, <span class="stringliteral">"_Win32MapViewInSessionSpace: Could not find section for %#p"</span>,
01311             Section);
01312 
01313     LeaveSectionCrit();
01314 
01315     <span class="keywordflow">return</span> STATUS_UNSUCCESSFUL;
01316 }
01317 
01318 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> _Win32UnmapViewInSessionSpace(
01319     PVOID MappedBase)
01320 {
01321     PWin32Section ps;
01322     PWin32MapView pv;
01323     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>      <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01324 
01325     EnterSectionCrit();
01326 
01327     ps = gpSections;
01328 
01329     <span class="keywordflow">while</span> (ps != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01330 
01331         pv = ps-&gt;pFirstView;
01332 
01333         <span class="keywordflow">while</span> (pv != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01334 
01335             UserAssert(pv-&gt;pSection == ps);
01336 
01337             <span class="keywordflow">if</span> (pv-&gt;pViewBase == MappedBase) {
01338                 <span class="comment">/*</span>
01339 <span class="comment">                 * now, remove it from the linked list</span>
01340 <span class="comment">                 */</span>
01341                 <span class="keywordflow">if</span> (pv-&gt;pPrev == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01342 
01343                     UserAssert(pv == ps-&gt;pFirstView);
01344 
01345                     ps-&gt;pFirstView = pv-&gt;pNext;
01346 
01347                     <span class="keywordflow">if</span> (pv-&gt;pNext != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01348                         pv-&gt;pNext-&gt;pPrev = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01349                     }
01350                 } <span class="keywordflow">else</span> {
01351                     pv-&gt;pPrev-&gt;pNext = pv-&gt;pNext;
01352                     <span class="keywordflow">if</span> (pv-&gt;pNext != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01353                         pv-&gt;pNext-&gt;pPrev = pv-&gt;pPrev;
01354                     }
01355                 }
01356 
01357                 UserFreePool(pv);
01358 
01359                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d3/d5/mapview_8c.html#a30">MmUnmapViewInSessionSpace</a>(MappedBase);
01360 
01361                 LeaveSectionCrit();
01362 
01363                 <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01364             }
01365             pv = pv-&gt;pNext;
01366         }
01367         ps = ps-&gt;pNext;
01368     }
01369 
01370     RIPMSG1(RIP_ERROR, <span class="stringliteral">"_Win32UnmapViewInSessionSpace: Could not find view for %#p"</span>,
01371             MappedBase);
01372 
01373     LeaveSectionCrit();
01374 
01375     <span class="keywordflow">return</span> STATUS_UNSUCCESSFUL;
01376 }
01377 
01378 <span class="preprocessor">#endif // TRACE_MAP_VIEWS</span>
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:41:24 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
