<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: kimacro.inc Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>kimacro.inc</h1><a href="../../d3/d0/kimacro_8inc.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 ;++
00002 ;
00003 ;   <a class="code" href="../../d1/d9/icmui_8def.html#a8">Copyright</a> (c) 1989  Microsoft Corporation
00004 ;
00005 ;   Module <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>:
00006 ;
00007 ;       kimacro.inc
00008 ;
00009 ;   Abstract:
00010 ;
00011 ;       This module contains <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a6">macros</a> used by kernel assembler code.
00012 ;       It includes <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a6">macros</a> to manipulate interrupts, support system
00013 ;       entry and <a class="code" href="../../d9/d1/fedefs_8h.html#a16">exit</a> <span class="keywordflow">for</span> syscalls, faults, and interrupts, and
00014 ;       manipulate floating point state.
00015 ;
00016 ;   Author:
00017 ;
00018 ;       Shie-Lin (shielint) 24-Jan-1990
00019 ;
00020 ;   Revision <a class="code" href="../../d1/d9/icmui_8def.html#a3">History</a>:
00021 ;
00022 ;       BryanWi 17-Aug-90
00023 ;           Replace GENERATE_MACHINE... and <a class="code" href="../../d2/d5/editreg_8c.html#a26">RESTORE</a>... with ENTER_...
00024 ;           and EXIT_ALL <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a6">macros</a>.
00025 ;
00026 ;--
00027 
00028 ;++
00029 ;
00030 ;   These constants are used by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> fpo directives in <span class="keyword">this</span> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a>.
00031 ;   This directive causes <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> assembler to output a .debug$f segment
00032 ;   in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> obj <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a>.  The segment will contain 1 fpo record <span class="keywordflow">for</span> each
00033 ;   directive present during assembly.
00034 ;
00035 ;   Although <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> assembler will accept all valid values, <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> value of 7
00036 ;   in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> FPO_REGS field indicates to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> debugger that a trap frame <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a>
00037 ;   generated by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> function.  The value of 7 can be used because <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
00038 ;   C/C++ compiler puts a maximum value of 3 in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> field.
00039 ;
00040 FPO_LOCALS      equ     0         ; 32 bits, size of locals in dwords
00041 FPO_PARAMS      equ     0         ; 32 bits, size of parameters in dwords
00042 FPO_PROLOG      equ     0         ; 12 bits, 0-4095, # of bytes in prolog
00043 FPO_REGS        equ     0         ; 3 bits, 0-7, # regs saved in prolog
00044 FPO_USE_EBP     equ     0         ; 1 bit, 0-1, <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> ebp used?
00045 FPO_TRAPFRAME   equ     1         ; 2 bits, 0=fpo, 1=trap frame, 2=tss
00046 ;
00047 ;--
00048 
00049 
00050 ;++
00051 ;
00052 ;   POLL_DEBUGGER
00053 ;
00054 ;   Macro <a class="code" href="../../d4/d9/heapdbg_8c.html#a4">Description</a>:
00055 ;
00056 ;       Call <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> debugger so <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> can check <span class="keywordflow">for</span> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a58">control</a>-<a class="code" href="../../d2/d0/nt6_2user32_8def.html#a35">c</a>.  If <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> finds
00057 ;       <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a>, <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> will report our iret address as address of <span class="keywordflow">break</span>-in.
00058 ;
00059 ;       N.B. This macro should be used when all <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller's registers
00060 ;            have been restored. (Otherwise, <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> kernel debugger <span class="keyword">register</span>
00061 ;            dump will not have correct state.)  The <a class="code" href="../../d3/d0/imm32_8def.html#a1">only</a> exception <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a>
00062 ;            fs.  This <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> because Kd may need to access PCR or PRCB.
00063 ;
00064 ;   Arguments:
00065 ;
00066 ;       There MUST be an iret frame on <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> stack when <span class="keyword">this</span> macro
00067 ;       <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> invoked.
00068 ;
00069 ;   Exit:
00070 ;
00071 ;       Debugger will iret <span class="keywordflow">for</span> us, so we don'<a class="code" href="../../d4/d1/genmips_8c.html#a17">t</a> usually <span class="keywordflow">return</span> from
00072 ;       <span class="keyword">this</span> macro, but remember that <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> generates nothing <span class="keywordflow">for</span> non-DEVL
00073 ;       kernels.
00074 ;--
00075 
00076 POLL_DEBUGGER   macro
00077 local   a, b, c_
00078 
00079 <span class="keywordflow">if</span>  DEVL
00080         EXTRNP   _DbgBreakPointWithStatus,1
00081         stdCall _KdPollBreakIn
00082         or      al,al
00083         jz      <span class="keywordtype">short</span> c_
00084         stdCall _DbgBreakPointWithStatus,&lt;<a class="code" href="../../d6/d7/halmips_8h.html#a24">DBG_STATUS_CONTROL_C</a>&gt;
00085 c_:
00086 endif   ; DEVL
00087 endm
00088 
00089 ;++
00090 ;
00091 ;   ASSERT_FS
00092 ;
00093 ;   Try to <span class="keywordflow">catch</span> funky condition wherein we get <a class="code" href="../../d5/d4/flpt_8h.html#a16">FS</a>=r3 value <span class="keywordflow">while</span>
00094 ;   running in kernel mode.
00095 ;
00096 ;--
00097 
00098 ASSERT_FS   macro
00099 local   a,b
00100 
00101 <span class="keywordflow">if</span> <a class="code" href="../../d0/d9/ntosdef_8h.html#a8">DBG</a>
00102         EXTRNP   _KeBugCheck,1
00103 
00104         mov     bx,fs
00105         cmp     bx,KGDT_R0_PCR
00106         jnz     <span class="keywordtype">short</span> a
00107 
00108         cmp     dword ptr fs:[0], 0
00109         jne     <span class="keywordtype">short</span> b
00110 
00111 a:
00112         stdCall   _KeBugCheck,&lt;-1&gt;
00113 align 4
00114 b:
00115 endif
00116 endm
00117 
00118 
00119 
00120 ;++
00121 ;
00122 ;
00123 ;   <a class="code" href="../../d9/d0/cmdata_8h.html#a104a97">Copy</a> data from various places into base of TrapFrame, net effect
00124 ;   <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> to allow dbg KB command to trace accross trap frame, and to
00125 ;   allow user to find arguments to system calls.
00126 ;
00127 ;   USE ebx and edi.
00128 ;--
00129 
00130 SET_DEBUG_DATA  macro
00131 
00132 ife FPO
00133 
00134 ;
00135 ; This macro <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> used by ENTER_SYSTEM_CALL, ENTER_TRAP and ENTER_INTERRUPT
00136 ; and <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> used at <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> end of above <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a6">macros</a>.  It <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> safe to destroy ebx, edi.
00137 ;
00138 
00139         mov     ebx,[ebp]+TsEbp
00140         mov     edi,[ebp]+TsEip
00141         mov     [ebp]+TsDbgArgPointer,edx
00142         mov     [ebp]+TsDbgArgMark,0BADB0D00h
00143         mov     [ebp]+TsDbgEbp,ebx
00144         mov     [ebp]+TsDbgEip,edi
00145 endif
00146 
00147 endm
00148 
00149 
00150 ;++
00151 ;
00152 ;   ENTER_DR_ASSIST     EnterLabel, ExitLabel, NoAbiosAssist, NoV86Assist
00153 ;
00154 ;   Macro <a class="code" href="../../d4/d9/heapdbg_8c.html#a4">Description</a>:
00155 ;
00156 ;       Jumped to by ENTER_ <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a6">macros</a> to deal with DR <span class="keyword">register</span> work,
00157 ;       abios work and v86 work.  The <a class="code" href="../../d3/d9/arcinst_8c.html#a19">main</a> purpose of <span class="keyword">this</span> macro <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a>
00158 ;       that interrupt/trap/systemCall EnterMacros can jump here to
00159 ;       deal with some special cases such that most of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> times <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
00160 ;       <a class="code" href="../../d3/d9/arcinst_8c.html#a19">main</a> ENTER_ execution flow can proceed without being branched.
00161 ;
00162 ;       If (previousmode == usermode) {
00163 ;           save DR* in trapframe
00164 ;           load DR* from Prcb
00165 ;       }
00166 ;
00167 ;   Arguments:
00168 ;       EnterLabel - label to emit
00169 ;       ExitLabel - label to branch to when done
00170 ;
00171 ;   Entry-conditions:
00172 ;     Dr work:
00173 ;       DebugActive == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>
00174 ;       (esi)-&gt;Thread object
00175 ;       (esp)-&gt;base of trap frame
00176 ;       (ebp)-&gt;base of trap frame
00177 ;
00178 ;     Abios work:
00179 ;     v86 work:
00180 ;
00181 ;   Exit-conditions:
00182 ;     Dr work:
00183 ;       Interrupts match input state (<span class="keyword">this</span> routine doesn't change IEF)
00184 ;       (esp)-&gt;base of trap frame
00185 ;       (ebp)-&gt;base of trap frame
00186 ;       Preserves entry eax, edx
00187 ;     Abios work:
00188 ;     v86 work:
00189 ;
00190 ;--
00191 
00192 ENTER_DR_ASSIST macro   EnterLabel, ExitLabel, NoAbiosAssist, NoV86Assist, V86R
00193         local   a,b
00194 
00195         <span class="keyword">public</span>  Dr_&amp;EnterLabel
00196 align 4
00197 Dr_&amp;EnterLabel:
00198 
00199 ;
00200 ; <a class="code" href="../../d9/d6/ttseacc_8c.html#a1">Test</a> <span class="keywordflow">if</span> we came from user-mode.  If not, <span class="keywordflow">do</span> nothing.
00201 ;
00202 
00203         test    dword ptr [ebp]+TsEFlags,EFLAGS_V86_MASK
00204         jnz     <span class="keywordtype">short</span> a
00205 
00206         test    dword ptr [ebp]+TsSegCs,MODE_MASK
00207         jz      Dr_&amp;ExitLabel          ; called from kmode, go <span class="keywordflow">continue</span>
00208 
00209 
00210 ;
00211 ; Save user-mode Dr* regs in TrapFrame
00212 ;
00213 ; We are safe to destroy ebx, ecx, edi because in ENTER_INTERRUPT and
00214 ; ENTER_TRAP these registers are saved already.  In ENTER_SYSTEMCALL
00215 ; ebx, edi <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> saved and ecx <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> don'<a class="code" href="../../d4/d1/genmips_8c.html#a17">t</a>-care.
00216 ;
00217 
00218 a:      mov     ebx,dr0
00219         mov     ecx,dr1
00220         mov     edi,dr2
00221         mov     [ebp]+TsDr0,ebx
00222         mov     [ebp]+TsDr1,ecx
00223         mov     [ebp]+TsDr2,edi
00224         mov     ebx,dr3
00225         mov     ecx,dr6
00226         mov     edi,dr7
00227         mov     [ebp]+TsDr3,ebx
00228         mov     [ebp]+TsDr6,ecx
00229         mov     ebx,0
00230         mov     [ebp]+TsDr7,edi
00231 
00232 ;
00233 ; Make Dr7 safe before loading junk from save area
00234 ;
00235         mov     dr7,ebx
00236 
00237 ;
00238 ; Load KernelDr* into processor
00239 ;
00240 
00241         mov     edi,dword ptr fs:[<a class="code" href="../../d6/d7/halmips_8h.html#a127">PcPrcb</a>]
00242         mov     ebx,[edi].PbProcessorState.PsSpecialRegisters.SrKernelDr0
00243         mov     ecx,[edi].PbProcessorState.PsSpecialRegisters.SrKernelDr1
00244         mov     dr0,ebx
00245         mov     dr1,ecx
00246         mov     ebx,[edi].PbProcessorState.PsSpecialRegisters.SrKernelDr2
00247         mov     ecx,[edi].PbProcessorState.PsSpecialRegisters.SrKernelDr3
00248         mov     dr2,ebx
00249         mov     dr3,ecx
00250         mov     ebx,[edi].PbProcessorState.PsSpecialRegisters.SrKernelDr6
00251         mov     ecx,[edi].PbProcessorState.PsSpecialRegisters.SrKernelDr7
00252         mov     dr6,ebx
00253         mov     dr7,ecx
00254 
00255 ifnb &lt;V86R&gt;
00256         test    dword ptr [ebp]+TsEFlags,EFLAGS_V86_MASK
00257         jz      <span class="keywordtype">short</span> b
00258         jmp     Dr_&amp;V86R
00259 endif
00260 b:
00261         jmp     Dr_&amp;ExitLabel
00262 
00263 
00264 ifb &lt;NoAbiosAssist&gt;
00265 
00266         <span class="keyword">public</span>  Abios_&amp;EnterLabel
00267 align 4
00268 Abios_&amp;EnterLabel:
00269 
00270 ;
00271 ;   INTERRUPT_STACK16_TO_STACK32
00272 ;
00273 ;       This macro remaps current 32bit stack to 16bit stack at interrupt
00274 ;       time.
00275 ;
00276 ;   Arguments:
00277 ;
00278 ;       (esp)-&gt;trap frame.
00279 ;       (eax)-&gt;Entry Esp.
00280 ;
00281 
00282         mov     eax, [esp].TsErrCode    ; (eax) = Entry Esp
00283         mov     ecx, KGDT_R0_DATA
00284         mov     edx, esp
00285         shl     eax, 16
00286         add     edx, fs:[PcstackLimit]
00287         mov     [esp].TsErrCode, eax
00288         mov     ss, cx
00289         mov     esp, edx                ; Interrupts are off
00290         mov     ebp, edx
00291         jmp     Abios_&amp;ExitLabel
00292 
00293 endif   ; NoAbiosAssist
00294 
00295 ifb &lt;NoV86Assist&gt;
00296 
00297         <span class="keyword">public</span>  V86_&amp;EnterLabel
00298 align 4
00299 V86_&amp;EnterLabel:
00300 
00301 ;
00302 ;   Move <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> V86 segment registers to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> correct place in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> frame
00303 ;
00304         mov     eax,dword ptr [ebp].TsV86Fs
00305         mov     ebx,dword ptr [ebp].TsV86Gs
00306         mov     ecx,dword ptr [ebp].TsV86Es
00307         mov     edx,dword ptr [ebp].TsV86Ds
00308         mov     [ebp].TsSegFs,ax
00309         mov     [ebp].TsSegGs,bx
00310         mov     [ebp].TsSegEs,cx
00311         mov     [ebp].TsSegDs,dx
00312         jmp     V86_&amp;ExitLabel
00313 
00314 endif   ; NoV86Assist
00315 
00316         endm
00317 
00318 ;++
00319 ;
00320 ;   ENTER_SYSCALL       AssistLabel, TagetLabel, NoFSLoad
00321 ;
00322 ;   Macro <a class="code" href="../../d4/d9/heapdbg_8c.html#a4">Description</a>:
00323 ;
00324 ;       Build <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> frame and set registers needed by a system call.
00325 ;
00326 ;       Save:
00327 ;           Errorpad,
00328 ;           Non-<span class="keyword">volatile</span> regs,
00329 ;           <a class="code" href="../../d5/d4/flpt_8h.html#a16">FS</a>,
00330 ;           ExceptionList,
00331 ;           PreviousMode
00332 ;
00333 ;       Don'<a class="code" href="../../d4/d1/genmips_8c.html#a17">t</a> Save:
00334 ;           <a class="code" href="../../d0/d1/hivedata_8h.html#a77a76">Volatile</a> regs
00335 ;           Seg regs
00336 ;           Floating point state
00337 ;
00338 ;       Set:
00339 ;           <a class="code" href="../../d5/d4/flpt_8h.html#a16">FS</a>,
00340 ;           ExceptionList,
00341 ;           PreviousMode,
00342 ;           Direction
00343 ;
00344 ;   Arguments:
00345 ;       AssistLabel - label ENTER_ASSIST macro <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> at
00346 ;       TargetLabel - label to emit <span class="keywordflow">for</span> ENTER_ASSIST to jump to
00347 ;       NoFSLoad    - Don'<a class="code" href="../../d4/d1/genmips_8c.html#a17">t</a> set <a class="code" href="../../d5/d4/flpt_8h.html#a16">FS</a>(it is already set to KGDT_R0_PCR at entry).
00348 ;
00349 ;   Exit-conditions:
00350 ;       Interrupts match input state (<span class="keyword">this</span> routine doesn't change IEF)
00351 ;       (esp)-&gt;base of trap frame
00352 ;       (ebp)-&gt;base of trap frame
00353 ;       Preserves entry eax, edx
00354 ;
00355 ;   Note:
00356 ;       The DS: reference to PreviousMode <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> *required* <span class="keywordflow">for</span> correct
00357 ;       functioning of lazy selector loads.  If you remove <span class="keyword">this</span> use
00358 ;       of DS:, put a DS: override on something.
00359 ;
00360 ;--
00361 
00362 ENTER_SYSCALL macro     AssistLabel, TargetLabel, NoFSLoad
00363 
00364 
00365 .FPO ( FPO_LOCALS, FPO_PARAMS, FPO_PROLOG, FPO_REGS, FPO_USE_EBP, FPO_TRAPFRAME )
00366 
00367 ifdef KERNELONLY
00368 
00369 ;
00370 ; Construct trap frame.
00371 ;
00372 ; N.B. The initial part of the trap frame is constructed by pushing values
00373 ;      on the stack. If the format of the trap frame is changed, then the
00374 ;      following code must alos be changed.
00375 ;
00376 
00377         push    0                       ; put pad dword for error on stack
00378         push    ebp                     ; save the non-volatile registers
00379         push    ebx                     ;
00380         push    esi                     ;
00381         push    edi                     ;
00382 ifb &lt;NoFSLoad&gt;
00383         push    fs                      ; save and set FS to PCR.
00384         mov     ebx,KGDT_R0_PCR         ; set PCR segment number
00385         mov     fs,bx                   ;
00386 else 
00387         ; FS already contains KGDT_R0_PCR(entry via PentiumPro fast system call)
00388         push    KGDT_R3_TEB OR RPL_MASK
00389 endif  ; NoFSLoad
00390 
00391 ;
00392 ; Save the old exception list in trap frame and initialize a new empty
00393 ; exception list.
00394 ;
00395 
00396         push    PCR[PcExceptionList]    ; save old exception list
00397         mov     PCR[PcExceptionList],EXCEPTION_CHAIN_END ; set new empty list
00398 
00399 ;
00400 ; Save the old previous mode in trap frame, allocate remainder of trap frame,
00401 ; and set the new previous mode.
00402 ;
00403 
00404         mov     esi,PCR[PcPrcbData+PbCurrentThread] ; get current thread address
00405         push    [esi]+ThPreviousMode    ; save old previous mode
00406         sub     esp,TsPreviousPreviousMode ; allocate remainder of trap frame
00407         mov     ebx,[esp+TsSegCS]       ; compute new previous mode
00408         and     ebx,MODE_MASK           ;
00409         mov     [esi]+ThPreviousMode,bl ; set new previous mode
00410 
00411 ;
00412 ; Save the old trap frame address and set the new trap frame address.
00413 ;
00414 
00415         mov     ebp,esp                 ; set trap frame address
00416         mov     ebx,[esi].ThTrapFrame   ; save current trap frame address
00417         mov     [ebp].TsEdx,ebx         ;
00418         mov     [esi].ThTrapFrame,ebp   ; set new trap frame address
00419         cld                             ; make sure direction is forward
00420 
00421         SET_DEBUG_DATA                  ; Note this destroys edi
00422 
00423         test    byte ptr [esi]+ThDebugActive,-1 ; test if debugging active
00424         jnz     Dr_&amp;AssistLabel         ; if nz, debugging is active on thread
00425 
00426 Dr_&amp;TargetLabel:                        ;
00427         sti                             ; enable interrupts
00428 
00429 else
00430         %out    ENTER_SYSCAL outside of kernel
00431         .err
00432 endif
00433         endm
00434 
00435 ;++
00436 ;
00437 ;   ENTER_INTERRUPT     AssistLabel, TargetLabel
00438 ;
00439 ;   Macro Description:
00440 ;
00441 ;       Build the frame and set registers needed by an interrupt.
00442 ;
00443 ;       Save:
00444 ;           Errorpad,
00445 ;           Non-volatile regs,
00446 ;           FS,
00447 ;           ExceptionList,
00448 ;           PreviousMode
00449 ;           Volatile regs
00450 ;           Seg regs from V86 mode
00451 ;           DS, ES, GS
00452 ;
00453 ;       Don't Save:
00454 ;           Floating point state
00455 ;
00456 ;       Set:
00457 ;           FS,
00458 ;           ExceptionList,
00459 ;           Direction,
00460 ;           DS, ES
00461 ;
00462 ;       Don't Set:
00463 ;           PreviousMode
00464 ;
00465 ;   Arguments:
00466 ;       AssistLabel - label ENTER_ASSIST macro is at
00467 ;       TargetLabel - label to emit for ENTER_ASSIST to jump to
00468 ;
00469 ;   Exit-conditions:
00470 ;       Interrupts match input state (this routine doesn't change IEF)
00471 ;       (esp)-&gt;base of trap frame
00472 ;       (ebp)-&gt;base of trap frame
00473 ;       Preserves entry eax, ecx, edx
00474 ;
00475 ;--
00476 
00477 ENTER_INTERRUPT macro   AssistLabel, TargetLabel, PassParm
00478         local b
00479 
00480 .FPO ( FPO_LOCALS+2, FPO_PARAMS, FPO_PROLOG, FPO_REGS, FPO_USE_EBP, FPO_TRAPFRAME )
00481 
00482 ;
00483 ;   Fill in parts of frame we care about
00484 ;
00485 
00486 ifb &lt;PassParm&gt;
00487         push    esp                 ; Use Error code field to save 16bit esp
00488 endif
00489         push    ebp                 ; Save the non-volatile registers
00490         push    ebx
00491         push    esi
00492         push    edi
00493 
00494         sub     esp, TsEdi
00495         mov     ebp,esp
00496 
00497         mov     [esp]+TsEax, eax    ; Save volatile registers
00498         mov     [esp]+TsEcx, ecx
00499         mov     [esp]+TsEdx, edx
00500 if DBG
00501         mov     dword ptr [esp]+TsPreviousPreviousMode, -1 ; ThPreviousMode not pushed on interrupt
00502 endif
00503 
00504         test    dword ptr [esp].TsEflags,EFLAGS_V86_MASK
00505         jnz     V86_&amp;AssistLabel
00506 
00507         cmp     word ptr [esp]+TsSegCs, KGDT_R0_CODE
00508         jz      <span class="keywordtype">short</span> @f
00509 
00510         mov     [esp]+TsSegFs, fs  ; Save and set FS to PCR.
00511         mov     [esp]+TsSegDs, ds
00512         mov     [esp]+TsSegEs, es
00513         mov     [esp]+TsSegGs, gs
00514 
00515 V86_&amp;TargetLabel:
00516         mov     ebx,KGDT_R0_PCR
00517         mov     eax,KGDT_R3_DATA OR RPL_MASK
00518         mov     fs, bx
00519         mov     ds, ax
00520         mov     es, ax
00521 @@:
00522         mov     ebx, fs:[PcExceptionList] ;Save, set ExceptionList
00523         mov     fs:[PcExceptionList],EXCEPTION_CHAIN_END
00524         mov     [esp]+TsExceptionList, ebx
00525 
00526 ifnb &lt;PassParm&gt;
00527         lea     eax, [esp].TsErrCode
00528         lea     ecx, [esp].TsEip    ; Move eax to EIP field
00529         mov     ebx, ss:[eax]       ; (ebx) = parameter to pass
00530         mov     ss:[eax], ecx       ; save 16bit esp
00531 endif
00532 
00533 ;
00534 ; Remap ABIOS 16 bit stack to 32 bit stack, if necessary.
00535 ;
00536 
00537         cmp     esp, 10000h
00538         jb      Abios_&amp;AssistLabel
00539 
00540         mov     dword ptr [esp].TsErrCode, 0 ; Indicate no remapping.
00541 Abios_&amp;TargetLabel:
00542 
00543 ;
00544 ; end of Abios stack checking
00545 ;
00546 
00547         cld
00548 
00549 ifnb &lt;PassParm&gt;
00550         push    ebx                 ; push parameter as argument
00551 endif
00552 
00553 
00554         SET_DEBUG_DATA
00555 
00556         test    byte ptr PCR[PcDebugActive], -1
00557         jnz     Dr_&amp;AssistLabel
00558 
00559 Dr_&amp;TargetLabel:
00560 
00561         endm
00562 
00563 ;++
00564 ;
00565 ;   ENTER_INTERRUPT_FORCE_STATE   AssistLabel, TargetLabel
00566 ;
00567 ;   Macro Description:
00568 ;
00569 ;       Build the frame and set registers needed by an interrupt.
00570 ;
00571 ;       This macro is the same as ENTER_INTERRUPT except that it forces the
00572 ;       needed state and does not save previous state.  
00573 ;
00574 ;       This macro is currently only used by HalpApicRebootService which does not 
00575 ;       return;
00576 ;
00577 ;       Save:
00578 ;           Errorpad,
00579 ;           Non-volatile regs,
00580 ;           ExceptionList,
00581 ;           PreviousMode
00582 ;           Volatile regs
00583 ;           Seg regs from V86 mode
00584 ;
00585 ;       Don't Save:
00586 ;           FS,
00587 ;           DS, ES, GS
00588 ;           Floating point state
00589 ;
00590 ;       Set:
00591 ;           FS,
00592 ;           ExceptionList,
00593 ;           Direction,
00594 ;           DS, ES
00595 ;
00596 ;       Don't Set:
00597 ;           PreviousMode
00598 ;
00599 ;   Arguments:
00600 ;       AssistLabel - label ENTER_ASSIST macro is at
00601 ;       TargetLabel - label to emit for ENTER_ASSIST to jump to
00602 ;
00603 ;   Exit-conditions:
00604 ;       Interrupts match input state (this routine doesn't change IEF)
00605 ;       (esp)-&gt;base of trap frame
00606 ;       (ebp)-&gt;base of trap frame
00607 ;       Preserves entry eax, ecx, edx
00608 ;
00609 ;--
00610 
00611 ENTER_INTERRUPT_FORCE_STATE macro   AssistLabel, TargetLabel, PassParm
00612         local b
00613 
00614 .FPO ( FPO_LOCALS+2, FPO_PARAMS, FPO_PROLOG, FPO_REGS, FPO_USE_EBP, FPO_TRAPFRAME )
00615 
00616 ;
00617 ;   Fill in parts of frame we care about
00618 ;
00619 
00620 ifb &lt;PassParm&gt;
00621         push    esp                 ; Use Error code field to save 16bit esp
00622 endif
00623         push    ebp                 ; Save the non-volatile registers
00624         push    ebx
00625         push    esi
00626         push    edi
00627 
00628         sub     esp, TsEdi
00629         mov     ebp,esp
00630 
00631         mov     [esp]+TsEax, eax    ; Save volatile registers
00632         mov     [esp]+TsEcx, ecx
00633         mov     [esp]+TsEdx, edx
00634 if DBG
00635         mov     dword ptr [esp]+TsPreviousPreviousMode, -1 ; ThPreviousMode not pushed on interrupt
00636 endif
00637 
00638         test    dword ptr [esp].TsEflags,EFLAGS_V86_MASK
00639         jnz     V86_&amp;AssistLabel
00640 
00641 V86_&amp;TargetLabel:
00642         mov     ebx,KGDT_R0_PCR
00643         mov     eax,KGDT_R3_DATA OR RPL_MASK
00644         mov     fs, bx
00645         mov     ds, ax
00646         mov     es, ax
00647 @@:
00648         mov     ebx, fs:[PcExceptionList] ;Save, set ExceptionList
00649         mov     fs:[PcExceptionList],EXCEPTION_CHAIN_END
00650         mov     [esp]+TsExceptionList, ebx
00651 
00652 ifnb &lt;PassParm&gt;
00653         lea     eax, [esp].TsErrCode
00654         lea     ecx, [esp].TsEip    ; Move eax to EIP field
00655         mov     ebx, ss:[eax]       ; (ebx) = parameter to pass
00656         mov     ss:[eax], ecx       ; save 16bit esp
00657 endif
00658 
00659 ;
00660 ; Remap ABIOS 16 bit stack to 32 bit stack, if necessary.
00661 ;
00662 
00663         cmp     esp, 10000h
00664         jb      Abios_&amp;AssistLabel
00665 
00666         mov     dword ptr [esp].TsErrCode, 0 ; Indicate no remapping.
00667 Abios_&amp;TargetLabel:
00668 
00669 ;
00670 ; end of Abios stack checking
00671 ;
00672 
00673         cld
00674 
00675 ifnb &lt;PassParm&gt;
00676         push    ebx                 ; push parameter as argument
00677 endif
00678 
00679 
00680         SET_DEBUG_DATA
00681 
00682         test    byte ptr PCR[PcDebugActive], -1
00683         jnz     Dr_&amp;AssistLabel
00684 
00685 Dr_&amp;TargetLabel:
00686 
00687         endm
00688 
00689 ;++
00690 ;
00691 ;   ENTER_TRAP      AssistLabel, TargetLabel
00692 ;
00693 ;   Macro Description:
00694 ;
00695 ;       Build the frame and set registers needed by a trap or exception.
00696 ;
00697 ;       Save:
00698 ;           Non-volatile regs,
00699 ;           FS,
00700 ;           ExceptionList,
00701 ;           PreviousMode,
00702 ;           Volatile regs
00703 ;           Seg Regs from V86 mode
00704 ;           DS, ES, GS
00705 ;
00706 ;       Don't Save:
00707 ;           Floating point state
00708 ;
00709 ;       Set:
00710 ;           FS,
00711 ;           Direction,
00712 ;           DS, ES
00713 ;
00714 ;       Don't Set:
00715 ;           PreviousMode,
00716 ;           ExceptionList
00717 ;
00718 ;   Arguments:
00719 ;       AssistLabel - label ENTER_ASSIST macro is at
00720 ;       TargetLabel - label to emit for ENTER_ASSIST to jump to
00721 ;
00722 ;   Exit-conditions:
00723 ;       Interrupts match input state (this routine doesn't change IEF)
00724 ;       (esp)-&gt;base of trap frame
00725 ;       (ebp)-&gt;base of trap frame
00726 ;       Preserves entry eax
00727 ;
00728 ;--
00729 
00730 ENTER_TRAP macro    AssistLabel, TargetLabel
00731         local b
00732 
00733 .FPO ( FPO_LOCALS, FPO_PARAMS, FPO_PROLOG, FPO_REGS, FPO_USE_EBP, FPO_TRAPFRAME )
00734 
00735 ;
00736 ;   Fill in parts of frame we care about
00737 ;
00738 
00739 if DBG
00740 ifndef  _Ki16BitStackException
00741     EXTRNP   _Ki16BitStackException
00742 endif
00743 endif ; DBG
00744 
00745         mov     word ptr [esp+2], 0 ; Clear upper word of ErrorCode
00746 
00747         push    ebp                 ; Save the non-volatile registers
00748         push    ebx
00749         push    esi
00750         push    edi
00751 
00752         push    fs                  ; Save and set FS to PCR.
00753         mov     ebx,KGDT_R0_PCR
00754         mov     fs,bx
00755         mov     ebx, fs:[PcExceptionList] ;Save ExceptionList
00756         push    ebx
00757 if DBG
00758         push    -1                  ; Don't need to save ThPreviousMode from trap
00759 else
00760         sub     esp, 4              ; pad dword
00761 endif
00762         push    eax                 ; Save the volatile registers
00763         push    ecx
00764         push    edx
00765 
00766         push    ds                  ; Save segments
00767         push    es
00768         push    gs
00769 
00770 ;
00771 ;   Skip allocate reset of trap frame and Set up DS/ES, they may be trash
00772 ;
00773 
00774         mov     ax,KGDT_R3_DATA OR RPL_MASK
00775         sub     esp,TsSegGs
00776         mov     ds,ax
00777         mov     es,ax
00778 
00779 if DBG
00780 ;
00781 ; The code here check if the exception occurred in ring 0
00782 ; ABIOS code. If yes, this is a fatal condition.  We will
00783 ; put out message and bugcheck.
00784 ;
00785 
00786         cmp     esp, 10000h             ; Is the trap in abios?
00787         jb      _Ki16BitStackException       ; if b, yes, switch stack and bugcheck.
00788 
00789 endif ; DBG
00790 
00791         mov     ebp,esp
00792         test    dword ptr [esp].TsEflags,EFLAGS_V86_MASK
00793         jnz     V86_&amp;AssistLabel
00794 
00795 V86_&amp;TargetLabel:
00796 
00797         cld
00798         SET_DEBUG_DATA
00799 
00800         test    byte ptr PCR[PcDebugActive], -1
00801         jnz     Dr_&amp;AssistLabel
00802 
00803 Dr_&amp;TargetLabel:
00804 
00805         endm
00806 ;++
00807 ;
00808 ;   EXIT_ALL    NoRestoreSegs, NoRestoreVolatiles, NoPreviousMode
00809 ;
00810 ;   Macro Description:
00811 ;
00812 ;       Load a syscall frame back into the machine.
00813 ;
00814 ;       Restore:
00815 ;           Volatile regs, IF NoRestoreVolatiles blank
00816 ;           NoPreviousMode,
00817 ;           ExceptionList,
00818 ;           FS,
00819 ;           Non-volatile regs
00820 ;
00821 ;       If the frame is a kernel mode frame, AND esp has been edited,
00822 ;       then TsSegCs will have a special value.  Test for that value
00823 ;       and execute special code for that case.
00824 ;
00825 ;       N.B. This macro generates an IRET!  (i.e. It exits!)
00826 ;
00827 ;   Arguments:
00828 ;
00829 ;       NoRestoreSegs - non-blank if DS, ES, GS are NOT to be restored
00830 ;
00831 ;       NoRestoreVolatiles - non-blank if Volatile regs are NOT to be restored
00832 ;
00833 ;       NoPreviousMode - if nb pop ThPreviousMode
00834 ;
00835 ;   Entry-conditions:
00836 ;
00837 ;       (esp)-&gt;base of trap frame
00838 ;       (ebp)-&gt;Base of trap frame
00839 ;
00840 ;   Exit-conditions:
00841 ;
00842 ;       Does not exit, returns.
00843 ;       Preserves eax, ecx, edx, IFF NoRestoreVolatiles is set
00844 ;
00845 ;--
00846 
00847 ?adjesp = 0
00848 ?RestoreAll = 1
00849 
00850 EXIT_ALL macro  NoRestoreSegs, NoRestoreVolatiles, NoPreviousMode
00851 local   a, b, f, x
00852 local   Abios_ExitHelp, Abios_ExitHelp_Target1, Abios_ExitHelp_Target2
00853 local   Dr_ExitHelp, Dr_ExitHelp_Target, V86_ExitHelp, V86_ExitHelp_Target
00854 local   Db_NotATrapFrame, Db_A, Db_NotValidEntry, NonFlatPm_Target
00855 
00856 ;
00857 ; Sanity check some values and setup globals for macro
00858 ;
00859 
00860 ?adjesp = TsSegGs
00861 ?RestoreAll = 1
00862 
00863 ifnb &lt;NoRestoreSegs&gt;
00864     ?RestoreAll = 0
00865     ?adjesp = ?adjesp + 12
00866 endif
00867 
00868 ifnb &lt;NoRestoreVolatiles&gt;
00869     if ?RestoreAll eq 1
00870         %out "EXIT_ALL NoRestoreVolatiles requires NoRestoreSegs"
00871         .err
00872     endif
00873     ?adjesp = ?adjesp + 12
00874 endif
00875 
00876 ifb &lt;NoPreviousMode&gt;
00877 ifndef KERNELONLY
00878         %out    EXIT_ALL can not restore previousmode outside kernel
00879         .err
00880 endif
00881 endif
00882 
00883 ; All callers are responsible for getting here with interrupts disabled.
00884 
00885 if DBG
00886         pushfd
00887         pop     edx
00888 
00889         test    edx, EFLAGS_INTERRUPT_MASK
00890         jnz     Db_NotValidEntry
00891 
00892         cmp     esp, ebp                    ; make sure esp = ebp
00893         jne     Db_NotValidEntry
00894 
00895 ; Make sure BADB0D00 sig is present.  If not this isn't a trap frame!
00896 Db_A:   sub     [esp]+TsDbgArgMark,0BADB0D00h
00897         jne     Db_NotATrapFrame
00898 endif
00899 
00900         ASSERT_FS
00901 
00902         mov     edx, [esp]+TsExceptionList
00903 if DBG
00904         or      edx, edx
00905         jnz     <span class="keywordtype">short</span> @f
00906     <span class="keywordtype">int</span> 3
00907 @@:
00908 endif
00909         mov     ebx, fs:[PcDebugActive]     ; (ebx) = DebugActive flag
00910         mov     fs:[PcExceptionList], edx   ; Restore ExceptionList
00911 
00912 ifb &lt;NoPreviousMode&gt;
00913         mov     ecx, [esp]+TsPreviousPreviousMode ; Restore PreviousMode
00914 if DBG
00915         cmp     ecx, -1     ; temporary debugging code
00916         jne     @f          ; to make sure no one tries to pop ThPreviousMode
00917     <span class="keywordtype">int</span> 3                   ; when it wasn't saved
00918 @@:
00919 endif
00920         mov     esi,fs:[PcPrcbData+PbCurrentThread]
00921         mov     [esi]+ThPreviousMode,cl
00922 else
00923 if DBG
00924         mov     ecx, [esp]+TsPreviousPreviousMode
00925         cmp     ecx, -1     ; temporary debugging code
00926         je     @f           ; to make sure no one pushed ThPreviousMode and
00927     <span class="keywordtype">int</span> 3                   ; is now exiting without restoreing it
00928 @@:
00929 endif
00930 endif
00931 
00932         test    ebx, 0fh
00933         jnz     Dr_ExitHelp
00934 
00935 Dr_ExitHelp_Target:
00936 
00937         test    dword ptr [esp].TsEflags,EFLAGS_V86_MASK
00938         jnz     V86_ExitHelp
00939 
00940         test    word ptr [esp]+TsSegCs,FRAME_EDITED
00941         jz      b                           ; Edited frame pop out.
00942 
00943 
00944 if ?RestoreAll eq 0
00945 .errnz MODE_MASK-1
00946         cmp     word ptr [esp]+TsSegCs,KGDT_R3_CODE OR RPL_MASK ; set/clear ZF
00947         bt      word ptr [esp]+TsSegCs,0    ; test MODE_MASK      set/clear CF
00948         cmc                                 ;       (CF=1 and ZF=0)
00949         ja      f                           ; jmp if CF=0 and ZF=0
00950 endif
00951 ifb &lt;NoRestoreVolatiles&gt;
00952 ifb &lt;NoRestoreSegs&gt;                         ; must restore eax before any
00953         mov     eax, [esp].TsEax            ; selectors! (see trap0e handler)
00954 endif
00955 endif
00956 
00957 ifb &lt;NoRestoreVolatiles&gt;
00958         mov     edx, [ebp]+TsEdx            ; Restore volitales
00959         mov     ecx, [ebp]+TsEcx
00960 ifb &lt;NoRestoreSegs&gt;
00961 else
00962         mov     eax, [ebp]+TsEax
00963 endif
00964 endif   ; NoRestoreVolatiles
00965 
00966         cmp     word ptr [ebp]+TsSegCs, KGDT_R0_CODE
00967         jz      <span class="keywordtype">short</span> @f
00968 
00969 ifb &lt;NoRestoreSegs&gt;
00970         lea     esp, [ebp]+TsSegGs
00971         pop     gs                          ; Restore Segs
00972         pop     es
00973         pop     ds
00974 endif
00975 NonFlatPm_Target:
00976         lea     esp, [ebp]+TsSegFs
00977         pop     fs
00978 @@:
00979 V86_ExitHelp_Target:
00980 
00981         lea     esp, [ebp]+TsEdi            ; Skip PreMode, ExceptList and fs
00982 
00983         pop     edi                         ; restore non-volatiles
00984         pop     esi
00985         pop     ebx
00986         pop     ebp
00987 
00988 ;
00989 ; Esp MUST point to the Error Code on the stack.  Because we use it to
00990 ; store the entering esp.
00991 ;
00992 
00993         cmp     word ptr [esp+8], 80h ; check for abios code segment?
00994         ja      Abios_ExitHelp
00995 
00996 Abios_ExitHelp_Target1:
00997 
00998         add     esp, 4              ; remove error code from trap frame
00999 
01000 Abios_ExitHelp_Target2:
01001 
01002 ;
01003 ; End of ABIOS stack check
01004 ;
01005 
01006 ifnb &lt;NoRestoreVolatiles&gt;
01007 
01008         test  _KeFeatureBits, KF_FAST_SYSCALL
01009         jz      @f
01010 
01011         ;; If returning to kernel mode, use iretd
01012         test    dword ptr [esp+4], MODE_MASK
01013         jz      @f                  ; Return to kmode. use iretd
01014 
01015         ;; If returning to V86 mode, use iretd
01016         test    dword ptr [esp+8], EFLAGS_V86_MASK
01017         jnz     @f                  ; Return to user V86 mode
01018 
01019         pop     edx                 ; pop EIP
01020         add     esp, 8              ; Remove CS &amp; Eflags
01021         pop     ecx                 ; pop ESP
01022 
01023         sti                         ; sysexit does not reload flags
01024         
01025 
01026         SYSEXIT_INSTR
01027 
01028 @@:
01029 endif  ;; &lt;NoRestoreVolatiles&gt;
01030 
01031         iretd                       ; return
01032 
01033 if DBG
01034 Db_NotATrapFrame:
01035         add     [esp]+TsDbgArgMark,0BADB0D00h   ; put back the orig value
01036 Db_NotValidEntry:
01037         <span class="keywordtype">int</span> 3
01038         jmp     Db_A
01039 endif
01040 
01041 ;
01042 ;   EXIT_HELPER
01043 ;
01044 ;       if (PreviousMode == UserMode) {
01045 ;           DR* regs = TF.Dr* regs
01046 ;       }
01047 ;
01048 ;   Entry-Conditions:
01049 ;
01050 ;       DebugActive == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>
01051 ;       (ebp)-&gt;TrapFrame
01052 ;
01053 ;--
01054 
01055 align dword
01056 Dr_ExitHelp:
01057 
01058         test    dword ptr [ebp]+TsEFlags,EFLAGS_V86_MASK
01059         jnz     <span class="keywordtype">short</span> x
01060 
01061         test    dword ptr [ebp]+TsSegCs,MODE_MASK
01062         jz      Dr_ExitHelp_Target
01063 
01064 x:      mov     ebx,0
01065         mov     esi,[ebp]+TsDr0
01066         mov     edi,[ebp]+TsDr1
01067         mov     dr7,ebx
01068         mov     dr0,esi
01069         mov     ebx,[ebp]+TsDr2
01070         mov     dr1,edi
01071         mov     dr2,ebx
01072         mov     esi,[ebp]+TsDr3
01073         mov     edi,[ebp]+TsDr6
01074         mov     ebx,[ebp]+TsDr7
01075         mov     dr3,esi
01076         mov     dr6,edi
01077         mov     dr7,ebx
01078 
01079         jmp     Dr_ExitHelp_Target
01080 
01081 align dword
01082 Abios_ExitHelp:
01083 
01084 ;
01085 ;   INTERRUPT_STACK32_TO_STACK16
01086 ;
01087 ;       This macro remaps current 32bit stack to 16bit stack at interrupt
01088 ;       time.
01089 ;
01090 ;   Arguments:
01091 ;
01092 ;       (esp)-&gt;TsEip.
01093 ;
01094 ;
01095 ; PERFNOTE shielint We should check <span class="keywordflow">if</span> there <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> any other H/<a class="code" href="../../d2/d1/bench_8h.html#a6">W</a> interrupt
01096 ;          pending.  If yes, don'<a class="code" href="../../d4/d1/genmips_8c.html#a17">t</a> <span class="keywordflow">switch</span> back to 16 bit stack.  This way
01097 ;          we can get better performance.
01098 ;
01099 
01100         cmp     word ptr [esp+2], 0     ; (esp+2) = Low word of error code
01101         jz      Abios_ExitHelp_Target1
01102         cmp     word ptr [esp], 0       ; (esp) = High word of error code
01103         jnz     Abios_ExitHelp_Target1
01104 
01105         shr     dword ptr [esp], 16
01106         mov     word ptr [esp + 2], <a class="code" href="../../d2/d3/abios_8h.html#a4">KGDT_STACK16</a>
01107         lss     sp, dword ptr [esp]
01108         movzx   esp, sp
01109         jmp     Abios_ExitHelp_Target2
01110 
01111 ;
01112 ;   Restore volatiles <span class="keywordflow">for</span> V86 mode, and <a class="code" href="../../d7/d4/conexts_8c.html#a1">move</a> seg regs
01113 ;
01114 
01115 align dword
01116 V86_ExitHelp:
01117 
01118         add     esp,TsEdx
01119         pop     edx
01120         pop     ecx
01121         pop     eax
01122         jmp     V86_ExitHelp_Target
01123 
01124 ;
01125 <span class="keywordflow">if</span> ?RestoreAll eq 0
01126 ;
01127 ;   Restore segs and volatiles <span class="keywordflow">for</span> non-flat R3 PM (VDM in PM)
01128 ;
01129 
01130 f:      mov     eax,[esp].TsEax     ; restore eax before any selectors
01131                                         ; (see trap0e handler)
01132         add     esp,TsSegGs
01133 
01134         pop     gs
01135         pop     es
01136         pop     <a class="code" href="../../d7/d4/conexts_8c.html#a30">ds</a>
01137 
01138         pop     edx
01139         pop     ecx
01140         jmp     NonFlatPm_Target
01141 
01142 endif   ; not ?RestoreAll
01143 
01144 
01145 ;
01146 ;   TsSegCs contains <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> special value that means <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> frame was edited
01147 ;   in a way that affected esp, AND <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a>'s a kernel mode frame.
01148 ;   (Special value <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> null selector except <span class="keywordflow">for</span> RPL.)
01149 ;
01150 ;   Put back <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> real CS.
01151 ;   push eflags, eip onto target stack
01152 ;   restore
01153 ;   <span class="keywordflow">switch</span> to target stack
01154 ;   iret
01155 ;
01156 
01157 b:      mov     ebx,[esp]+TsTempSegCs
01158         mov     [esp]+TsSegCs,ebx
01159 
01160 ;
01161 ;   There <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> no instruction that will load esp with an arbitrary value
01162 ;   (i.e. one <a class="code" href="../../d6/d0/wsprintf_8c.html#a0">out</a> of a frame) and <span class="keywordflow">do</span> a <span class="keywordflow">return</span>, <span class="keywordflow">if</span> no privledge transition
01163 ;   <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> occuring.  Therefore, <span class="keywordflow">if</span> we are returning to kernel mode, and
01164 ;   esp has been edited, we must <span class="stringliteral">"emulate"</span> a kind of iretd.
01165 ;
01166 ;   We <span class="keywordflow">do</span> <span class="keyword">this</span> by logically pushing <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> eip,cs,eflags onto <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <span class="keyword">new</span>
01167 ;   logical stack, loading that stack, and doing an iretd.  This
01168 ;   requires that <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <span class="keyword">new</span> logical stack <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> at least 1 dword higher
01169 ;   than <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> unedited esp would have been.  (i.e.  It <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> not legal
01170 ;   to edit esp to have a <span class="keyword">new</span> value &lt; <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> old value.)
01171 ;
01172 ;   <a class="code" href="../../d4/d9/ke_8h.html#a370">KeContextToKframes</a> enforces <span class="keyword">this</span> rule.
01173 ;
01174 
01175 ;
01176 ;   Compute <span class="keyword">new</span> logical stack address
01177 ;
01178 
01179         mov     ebx,[esp]+TsTempEsp
01180         sub     ebx,12
01181         mov     [esp]+TsErrCode,ebx
01182 
01183 ;
01184 ;   <a class="code" href="../../d9/d0/cmdata_8h.html#a104a97">Copy</a> eip,cs,eflags to <span class="keyword">new</span> stack.  note we <span class="keywordflow">do</span> <span class="keyword">this</span> <a class="code" href="../../d2/d3/fetypes_8h.html#a457a417">high</a> to <a class="code" href="../../d2/d3/fetypes_8h.html#a457a418">low</a>
01185 ;
01186 
01187         mov     esi,[esp]+TsEflags
01188         mov     [ebx+8],esi
01189         mov     esi,[esp]+TsSegCs
01190         mov     [ebx+4],esi
01191         mov     esi,[esp]+TsEip
01192         mov     [ebx],esi
01193 
01194 ;
01195 ;   Do a standard restore sequence.
01196 ;
01197 ;   Observe that RestoreVolatiles <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> honored.  Editing a <span class="keyword">volatile</span>
01198 ;   <span class="keyword">register</span> has no effect when returning from a system call.
01199 ;
01200 ifb     &lt;NoRestoreVolatiles&gt;
01201         mov     eax,[esp].TsEax
01202 endif
01203 ;        add     esp,TsSegGs
01204 ;
01205 ;ifb     &lt;NoRestoreSegs&gt;
01206 ;        pop     gs
01207 ;        pop     es
01208 ;        pop     <a class="code" href="../../d7/d4/conexts_8c.html#a30">ds</a>
01209 ;<span class="keywordflow">else</span>
01210 ;        add     esp,12
01211 ;endif
01212 
01213 ifb     &lt;NoRestoreVolatiles&gt;
01214         mov     edx, [esp]+TsEdx
01215         mov     ecx, [esp]+TsEcx
01216 endif
01217 
01218 ;ifnb &lt;NoPreviousMode&gt;
01219 ;        add     esp, 4              ; Skip previous mode
01220 ;<span class="keywordflow">else</span>
01221 ;        pop     ebx                 ; Restore PreviousMode
01222 ;        mov     esi,fs:[PcPrcbData+<a class="code" href="../../d6/d7/halmips_8h.html#a105">PbCurrentThread</a>]
01223 ;        mov     ss:[esi]+ThPreviousMode,bl
01224 ;endif
01225 ;
01226 ;       pop     ebx
01227 ;
01228 ;       mov     fs:[PcExceptionList], ebx ;Restore ExceptionList
01229 ;       pop     fs
01230 
01231         add     esp, TsEdi
01232         pop     edi                 ; restore non-volatiles
01233         pop     esi
01234         pop     ebx
01235         pop     ebp
01236 
01237 ;
01238 ;   (esp)-&gt;TsErrCode, where we saved <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <span class="keyword">new</span> esp
01239 ;
01240 
01241         mov     esp,[esp]           ; Do <a class="code" href="../../d7/d4/conexts_8c.html#a1">move</a> not push to avoid increment
01242         iretd
01243 
01244         endm
01245 
01246 
01247 ;++
01248 ;
01249 ;   INTERRUPT_EXIT
01250 ;
01251 ;   Macro <a class="code" href="../../d4/d9/heapdbg_8c.html#a4">Description</a>:
01252 ;
01253 ;       This macro <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> executed on <span class="keywordflow">return</span> from an interrupt vector service
01254 ;       service routine.  Its function <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> to restore privileged processor
01255 ;       state, and <span class="keywordflow">continue</span> thread execution. If <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a58">control</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> returning to
01256 ;       user mode and there <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> a user  APC pending, then APC level interupt
01257 ;       will be requested and <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a58">control</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> transfered to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> user APC delivery
01258 ;       routine, <span class="keywordflow">if</span> no higher level interrupt pending.
01259 ;
01260 ;   Arguments:
01261 ;
01262 ;       (TOS)   = previous irql
01263 ;       (TOS+4) = irq vector to eoi
01264 ;       (TOS+8 ...) = machine_state frame
01265 ;       (ebp)-&gt; machine state frame (trap frame)
01266 ;
01267 ;--
01268 
01269 INTERRUPT_EXIT     macro    DebugCheck
01270 local   a
01271 
01272 ifnb &lt;DebugCheck&gt;
01273         POLL_DEBUGGER
01274 endif
01275 <span class="keywordflow">if</span> <a class="code" href="../../d0/d9/ntosdef_8h.html#a8">DBG</a>                                          ; save current eip <span class="keywordflow">for</span>
01276 a:      mov     esi, offset a                   ; debugging bad trap frames
01277 endif
01278 
01279 ifdef __imp_Kei386EoiHelper@0
01280         cli
01281         call    _HalEndSystemInterrupt@8
01282         jmp     dword ptr [__imp_Kei386EoiHelper@0]
01283 
01284 <span class="keywordflow">else</span>
01285         cli
01286         call    dword ptr [__imp__HalEndSystemInterrupt@8]
01287         jmp     Kei386EoiHelper@0
01288 endif
01289 endm
01290 
01291 
01292 ;++
01293 ;
01294 ;   SPURIOUS_INTERRUPT_EXIT
01295 ;
01296 ;   Macro <a class="code" href="../../d4/d9/heapdbg_8c.html#a4">Description</a>:
01297 ;
01298 ;       To <a class="code" href="../../d9/d1/fedefs_8h.html#a16">exit</a> an interrupt without performing <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> EOI.
01299 ;
01300 ;   Arguments:
01301 ;
01302 ;       (TOS) = machine_state frame
01303 ;       (ebp)-&gt; machine state frame (trap frame)
01304 ;
01305 ;--
01306 
01307 SPURIOUS_INTERRUPT_EXIT  macro
01308 local   a
01309 <span class="keywordflow">if</span> <a class="code" href="../../d0/d9/ntosdef_8h.html#a8">DBG</a>                                          ; save current eip <span class="keywordflow">for</span>
01310 a:      mov     esi, offset a                   ; debugging bad trap frames
01311 endif
01312 ifdef __imp_Kei386EoiHelper@0
01313         jmp     dword ptr [__imp_Kei386EoiHelper@0]
01314 <span class="keywordflow">else</span>
01315         jmp     Kei386EoiHelper@0
01316 endif
01317 endm
01318 
01319 ;++
01320 ;
01321 ;   ENTER_TRAPV86
01322 ;
01323 ;   Macro <a class="code" href="../../d4/d9/heapdbg_8c.html#a4">Description</a>:
01324 ;
01325 ;       Construct trap frame <span class="keywordflow">for</span> v86 mode traps.
01326 ;
01327 ;--
01328 
01329 ENTER_TRAPV86 macro DRENTER,V86ENTER,LOADES
01330         sub     esp, TsErrCode
01331         mov     word ptr [esp].TsErrCode + 2, 0
01332         mov     [esp].TsEbx, ebx
01333         mov     [esp].TsEax, eax
01334         mov     [esp].TsEbp, ebp
01335         mov     [esp].TsEsi, esi
01336         mov     [esp].TsEdi, edi
01337         mov     ebx, KGDT_R0_PCR
01338         mov     eax, KGDT_R3_DATA OR RPL_MASK
01339         mov     [esp].TsEcx, ecx
01340         mov     [esp].TsEdx, edx
01341 <span class="keywordflow">if</span> <a class="code" href="../../d0/d9/ntosdef_8h.html#a8">DBG</a>
01342         mov     [esp].TsPreviousPreviousMode, -1
01343         mov     [esp]+TsDbgArgMark, 0BADB0D00h
01344 endif
01345         mov     fs, bx
01346         mov     <a class="code" href="../../d7/d4/conexts_8c.html#a30">ds</a>, ax
01347 ifnb &lt;LOADES&gt;
01348         mov     es, ax
01349 endif
01350         mov     ebp, esp
01351         cld                             ; CHECKIT_SUDEEP ; <span class="keywordflow">do</span> we really need <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a>
01352         test    byte ptr PCR[PcDebugActive], -1
01353         jnz     Dr_&amp;DRENTER
01354 
01355 Dr_&amp;V86ENTER:
01356 endm
01357 
01358 
01359 ;
01360 ; Taken from ntos\vdm\i386\vdmtb.inc
01361 ;
01362 
01363 FIXED_NTVDMSTATE_LINEAR_PC_AT equ 0714H
01364 FIXED_NTVDMSTATE_LINEAR_PC_98 equ 0614H
01365 MACHINE_TYPE_MASK equ 0ff00H
01366 <a class="code" href="../../d2/d5/ke_2i386_2vdmp_8h.html#a3">VDM_VIRTUAL_INTERRUPTS</a>  equ 0200H
01367 
01368 ;++
01369 ;
01370 ;   EXIT_TRAPV86
01371 ;
01372 ;   Macro <a class="code" href="../../d4/d9/heapdbg_8c.html#a4">Description</a>:
01373 ;
01374 ;       <span class="keywordflow">if</span> UserApc <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> pending deliver <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a>
01375 ;       <span class="keywordflow">if</span> User Context <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> v86 mode
01376 ;          Exit from kernel (does not <span class="keywordflow">return</span>)
01377 ;       <span class="keywordflow">else</span>
01378 ;          <span class="keywordflow">return</span> (expected to execute EXIT_ALL)
01379 ;--
01380 
01381 EXIT_TRAPV86 macro
01382         local w, x, y, z
01383 
01384 z:      mov     ebx, PCR[PcPrcbData+<a class="code" href="../../d6/d7/halmips_8h.html#a105">PbCurrentThread</a>]
01385         mov     byte ptr [ebx]+ThAlerted, 0
01386         cmp     byte ptr [ebx]+ThApcState.AsUserApcPending, 0
01387         jne     <span class="keywordtype">short</span> w
01388 
01389         ;
01390         ; Kernel <a class="code" href="../../d9/d1/fedefs_8h.html#a16">exit</a> to V86 mode
01391         ;
01392 
01393         add     esp,TsEdx
01394         pop     edx
01395         pop     ecx
01396         pop     eax
01397         test    byte ptr PCR[PcDebugActive], -1
01398         jnz     <span class="keywordtype">short</span> x
01399 y:
01400         add     esp,12              ; unused fields
01401         pop     edi
01402         pop     esi
01403         pop     ebx
01404         pop     ebp
01405         add     esp,4               ; clear error code
01406         iretd
01407 
01408 x:      mov     esi,[ebp]+TsDr0
01409         mov     edi,[ebp]+TsDr1
01410         mov     ebx,[ebp]+TsDr2
01411         mov     dr0,esi
01412         mov     dr1,edi
01413         mov     dr2,ebx
01414         mov     esi,[ebp]+TsDr3
01415         mov     edi,[ebp]+TsDr6
01416         mov     ebx,[ebp]+TsDr7
01417         mov     dr3,esi
01418         mov     dr6,edi
01419         mov     dr7,ebx
01420         jmp     <span class="keywordtype">short</span> y
01421 
01422 w:
01423         ;
01424         ; Dispatch user mode APC
01425         ; The APC routine runs with interrupts on and at APC level
01426         ;
01427 
01428         mov     ecx, <a class="code" href="../../d6/d7/halmips_8h.html#a52">APC_LEVEL</a>
01429         fstCall KfRaiseIrql
01430         push    eax                              ; Save OldIrql
01431         sti
01432 
01433         stdCall _KiDeliverApc, &lt;1, 0, ebp&gt;       ; ebp - Trap frame
01434                                                  ; 0 - Null exception frame
01435                                                  ; 1 - Previous mode
01436 
01437         pop     ecx                              ; (TOS) = OldIrql
01438         fstCall KfLowerIrql
01439 
01440         cli
01441 
01442         ;
01443         ; UserApc may have changed to vdm Monitor context (user flat 32)
01444         ; If <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> has cannot use <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> v86 <a class="code" href="../../d3/d0/imm32_8def.html#a1">only</a> kernel <a class="code" href="../../d9/d1/fedefs_8h.html#a16">exit</a>
01445         ;
01446 
01447         test    dword ptr [ebp]+TsEFlags,EFLAGS_V86_MASK
01448         jnz     <span class="keywordtype">short</span> z
01449 
01450         ; Exit to <span class="keywordflow">do</span> EXIT_ALL
01451 endm
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:40:35 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
