<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: deviosup.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>deviosup.c</h1><a href="../../d3/d7/deviosup_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1996  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    DevIoSup.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module implements the low lever disk read/write support for Udfs.</span>
00012 <span class="comment"></span>
00013 <span class="comment">Author:</span>
00014 <span class="comment"></span>
00015 <span class="comment">    Dan Lovinger    [DanLo]   11-Jun-1996</span>
00016 <span class="comment"></span>
00017 <span class="comment">Revision History:</span>
00018 <span class="comment"></span>
00019 <span class="comment">--*/</span>
00020 
00021 <span class="preprocessor">#include "UdfProcs.h"</span>
00022 
00023 <span class="comment">//</span>
00024 <span class="comment">//  The Bug check file id for this module</span>
00025 <span class="comment">//</span>
00026 
<a name="l00027"></a><a class="code" href="../../d3/d7/deviosup_8c.html#a0">00027</a> <span class="preprocessor">#define BugCheckFileId                   (UDFS_BUG_CHECK_DEVIOSUP)</span>
00028 <span class="preprocessor"></span>
00029 <span class="comment">//</span>
00030 <span class="comment">//  The local debug trace level</span>
00031 <span class="comment">//</span>
00032 
<a name="l00033"></a><a class="code" href="../../d3/d7/deviosup_8c.html#a1">00033</a> <span class="preprocessor">#define Dbg                              (UDFS_DEBUG_LEVEL_DEVIOSUP)</span>
00034 <span class="preprocessor"></span>
00035 <span class="comment">//</span>
00036 <span class="comment">//  Local structure definitions</span>
00037 <span class="comment">//</span>
00038 
00039 <span class="comment">//</span>
00040 <span class="comment">//  An array of these structures is passed to UdfMultipleAsync describing</span>
00041 <span class="comment">//  a set of runs to execute in parallel.</span>
00042 <span class="comment">//</span>
00043 
<a name="l00044"></a><a class="code" href="../../d0/d5/struct__IO__RUN.html">00044</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d0/d5/struct__IO__RUN.html">_IO_RUN</a> {
00045 
00046     <span class="comment">//</span>
00047     <span class="comment">//  Disk offset to read from and number of bytes to read.  These</span>
00048     <span class="comment">//  must be a multiple of a sector and the disk offset is also a</span>
00049     <span class="comment">//  multiple of sector.</span>
00050     <span class="comment">//</span>
00051 
<a name="l00052"></a><a class="code" href="../../d0/d5/struct__IO__RUN.html#o0">00052</a>     LONGLONG <a class="code" href="../../d0/d5/struct__IO__RUN.html#o0">DiskOffset</a>;
<a name="l00053"></a><a class="code" href="../../d0/d5/struct__IO__RUN.html#o1">00053</a>     ULONG <a class="code" href="../../d0/d5/struct__IO__RUN.html#o1">DiskByteCount</a>;
00054 
00055     <span class="comment">//</span>
00056     <span class="comment">//  Current position in user buffer.  This is the final destination for</span>
00057     <span class="comment">//  this portion of the Io transfer.</span>
00058     <span class="comment">//</span>
00059 
<a name="l00060"></a><a class="code" href="../../d0/d5/struct__IO__RUN.html#o2">00060</a>     PVOID <a class="code" href="../../d0/d5/struct__IO__RUN.html#o2">UserBuffer</a>;
00061 
00062     <span class="comment">//</span>
00063     <span class="comment">//  Buffer to perform the transfer to.  If this is the same as the</span>
00064     <span class="comment">//  user buffer above then we are using the user's buffer.  Otherwise</span>
00065     <span class="comment">//  we either allocated a temporary buffer or are using a different portion</span>
00066     <span class="comment">//  of the user's buffer.</span>
00067     <span class="comment">//</span>
00068     <span class="comment">//  TransferBuffer - Read full sectors into this location.  This can</span>
00069     <span class="comment">//      be a pointer into the user's buffer at the exact location the</span>
00070     <span class="comment">//      data should go.  It can also be an earlier point in the user's</span>
00071     <span class="comment">//      buffer if the complete I/O doesn't start on a sector boundary.</span>
00072     <span class="comment">//      It may also be a pointer into an allocated buffer.</span>
00073     <span class="comment">//</span>
00074     <span class="comment">//  TransferByteCount - Count of bytes to transfer to user's buffer.  A</span>
00075     <span class="comment">//      value of zero indicates that we did do the transfer into the</span>
00076     <span class="comment">//      user's buffer directly.</span>
00077     <span class="comment">//</span>
00078     <span class="comment">//  TransferBufferOffset - Offset in this buffer to begin the transfer</span>
00079     <span class="comment">//      to the user's buffer.</span>
00080     <span class="comment">//</span>
00081 
<a name="l00082"></a><a class="code" href="../../d0/d5/struct__IO__RUN.html#o3">00082</a>     PVOID <a class="code" href="../../d0/d5/struct__IO__RUN.html#o3">TransferBuffer</a>;
<a name="l00083"></a><a class="code" href="../../d0/d5/struct__IO__RUN.html#o4">00083</a>     ULONG <a class="code" href="../../d0/d5/struct__IO__RUN.html#o4">TransferByteCount</a>;
<a name="l00084"></a><a class="code" href="../../d0/d5/struct__IO__RUN.html#o5">00084</a>     ULONG <a class="code" href="../../d0/d5/struct__IO__RUN.html#o5">TransferBufferOffset</a>;
00085 
00086     <span class="comment">//</span>
00087     <span class="comment">//  This is the Mdl describing the locked pages in memory.  It may</span>
00088     <span class="comment">//  be allocated to describe the allocated buffer.  Or it may be</span>
00089     <span class="comment">//  the Mdl in the originating Irp.  The MdlOffset is the offset of</span>
00090     <span class="comment">//  the current buffer from the beginning of the buffer described by</span>
00091     <span class="comment">//  the Mdl below.  If the TransferMdl is not the same as the Mdl</span>
00092     <span class="comment">//  in the user's Irp then we know we have allocated it.</span>
00093     <span class="comment">//</span>
00094 
<a name="l00095"></a><a class="code" href="../../d0/d5/struct__IO__RUN.html#o6">00095</a>     <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> <a class="code" href="../../d0/d5/struct__IO__RUN.html#o6">TransferMdl</a>;
<a name="l00096"></a><a class="code" href="../../d0/d5/struct__IO__RUN.html#o7">00096</a>     PVOID <a class="code" href="../../d0/d5/struct__IO__RUN.html#o7">TransferVirtualAddress</a>;
00097 
00098     <span class="comment">//</span>
00099     <span class="comment">//  Associated Irp used to perform the Io.</span>
00100     <span class="comment">//</span>
00101 
<a name="l00102"></a><a class="code" href="../../d0/d5/struct__IO__RUN.html#o8">00102</a>     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> <a class="code" href="../../d0/d5/struct__IO__RUN.html#o8">SavedIrp</a>;
00103 
00104 } <a class="code" href="../../d0/d5/struct__IO__RUN.html">IO_RUN</a>;
<a name="l00105"></a><a class="code" href="../../d3/d7/deviosup_8c.html#a4">00105</a> <span class="keyword">typedef</span> <a class="code" href="../../d0/d5/struct__IO__RUN.html">IO_RUN</a> *<a class="code" href="../../d0/d5/struct__IO__RUN.html">PIO_RUN</a>;
00106 
<a name="l00107"></a><a class="code" href="../../d3/d7/deviosup_8c.html#a2">00107</a> <span class="preprocessor">#define MAX_PARALLEL_IOS            5</span>
00108 <span class="preprocessor"></span>
00109 <span class="comment">//</span>
00110 <span class="comment">//  Local support routines</span>
00111 <span class="comment">//</span>
00112 
00113 BOOLEAN
00114 <a class="code" href="../../d3/d7/deviosup_8c.html#a18">UdfPrepareBuffers</a> (
00115     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00116     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp,
00117     IN <a class="code" href="../../d7/d9/struct__FCB.html">PFCB</a> Fcb,
00118     IN PVOID UserBuffer,
00119     IN ULONG UserBufferOffset,
00120     IN LONGLONG StartingOffset,
00121     IN ULONG ByteCount,
00122     IN PIO_RUN IoRuns,
00123     IN PULONG RunCount,
00124     IN PULONG ThisByteCount,
00125     OUT PBOOLEAN SparseRuns
00126     );
00127 
00128 BOOLEAN
00129 <a class="code" href="../../d3/d7/deviosup_8c.html#a6">UdfFinishBuffers</a> (
00130     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00131     IN PIO_RUN IoRuns,
00132     IN ULONG RunCount,
00133     IN BOOLEAN FinalCleanup
00134     );
00135 
00136 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00137 <a class="code" href="../../d3/d7/deviosup_8c.html#a7">UdfMultipleAsync</a> (
00138     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00139     IN ULONG RunCount,
00140     IN PIO_RUN IoRuns
00141     );
00142 
00143 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00144 <a class="code" href="../../d3/d7/deviosup_8c.html#a8">UdfSingleAsync</a> (
00145     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00146     IN LONGLONG ByteOffset,
00147     IN ULONG ByteCount
00148     );
00149 
00150 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00151 <a class="code" href="../../d3/d7/deviosup_8c.html#a9">UdfWaitSync</a> (
00152     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext
00153     );
00154 
00155 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00156 <a class="code" href="../../d3/d7/deviosup_8c.html#a10">UdfMultiSyncCompletionRoutine</a> (
00157     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject,
00158     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp,
00159     IN PVOID Context
00160     );
00161 
00162 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00163 <a class="code" href="../../d3/d7/deviosup_8c.html#a11">UdfMultiAsyncCompletionRoutine</a> (
00164     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject,
00165     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp,
00166     IN PVOID Context
00167     );
00168 
00169 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00170 <a class="code" href="../../d3/d7/deviosup_8c.html#a12">UdfSingleSyncCompletionRoutine</a> (
00171     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject,
00172     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp,
00173     IN PVOID Context
00174     );
00175 
00176 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00177 <a class="code" href="../../d3/d7/deviosup_8c.html#a13">UdfSingleAsyncCompletionRoutine</a> (
00178     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject,
00179     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp,
00180     IN PVOID Context
00181     );
00182 
00183 <span class="preprocessor">#ifdef ALLOC_PRAGMA</span>
00184 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00185 <span class="preprocessor"></span>
00186 <span class="preprocessor">#ifdef ALLOC_PRAGMA</span>
00187 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfCreateUserMdl)</span>
00188 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfMultipleAsync)</span>
00189 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfNonCachedRead)</span>
00190 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfFinishBuffers)</span>
00191 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfPrepareBuffers)</span>
00192 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfSingleAsync)</span>
00193 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfWaitSync)</span>
00194 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfPerformDevIoCtrl)</span>
00195 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfReadSectors)</span>
00196 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00197 <span class="preprocessor"></span>
00198 
00199 
00200 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00201"></a><a class="code" href="../../d3/d8/udfprocs_8h.html#a161">00201</a> <a class="code" href="../../d3/d8/udfprocs_8h.html#a161">UdfNonCachedRead</a> (
00202     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00203     IN <a class="code" href="../../d7/d9/struct__FCB.html">PFCB</a> Fcb,
00204     IN LONGLONG StartingOffset,
00205     IN ULONG ByteCount
00206     )
00207 
00208 <span class="comment">/*++</span>
00209 <span class="comment"></span>
00210 <span class="comment">Routine Description:</span>
00211 <span class="comment"></span>
00212 <span class="comment">    This routine performs the non-cached reads of sectors.  This is done by</span>
00213 <span class="comment">    performing the following in a loop.</span>
00214 <span class="comment"></span>
00215 <span class="comment">        Fill in the IoRuns array for the next block of Io.</span>
00216 <span class="comment">        Send the Io to the device.</span>
00217 <span class="comment">        Perform any cleanup on the Io runs array.</span>
00218 <span class="comment"></span>
00219 <span class="comment">    We will not do async Io to any request that generates non-aligned Io.</span>
00220 <span class="comment">    Also we will not perform async Io if it will exceed the size of our</span>
00221 <span class="comment">    IoRuns array.  These should be the unusual cases but we will raise</span>
00222 <span class="comment">    or return CANT_WAIT in this routine if we detect this case.</span>
00223 <span class="comment"></span>
00224 <span class="comment">Arguments:</span>
00225 <span class="comment"></span>
00226 <span class="comment">    Fcb - Fcb representing the file to read.</span>
00227 <span class="comment"></span>
00228 <span class="comment">    StartingOffset - Logical offset in the file to read from.</span>
00229 <span class="comment"></span>
00230 <span class="comment">    ByteCount - Number of bytes to read.</span>
00231 <span class="comment"></span>
00232 <span class="comment">Return Value:</span>
00233 <span class="comment"></span>
00234 <span class="comment">    NTSTATUS - Status indicating the result of the operation.</span>
00235 <span class="comment"></span>
00236 <span class="comment">--*/</span>
00237 
00238 {
00239     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
00240 
00241     <a class="code" href="../../d0/d5/struct__IO__RUN.html">IO_RUN</a> IoRuns[<a class="code" href="../../d3/d7/deviosup_8c.html#a2">MAX_PARALLEL_IOS</a>];
00242     ULONG RunCount = 0;
00243     ULONG CleanupRunCount = 0;
00244 
00245     PVOID UserBuffer;
00246     ULONG UserBufferOffset = 0;
00247     LONGLONG CurrentOffset = StartingOffset;
00248     ULONG RemainingByteCount = ByteCount;
00249     ULONG ThisByteCount;
00250 
00251     BOOLEAN Unaligned;
00252     BOOLEAN SparseRuns;
00253     BOOLEAN FlushIoBuffers = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00254     BOOLEAN FirstPass = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00255 
00256     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00257 
00258     <span class="comment">//</span>
00259     <span class="comment">//  We want to make sure the user's buffer is locked in all cases.</span>
00260     <span class="comment">//</span>
00261 
00262     <span class="keywordflow">if</span> (IrpContext-&gt;Irp-&gt;MdlAddress == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00263 
00264         <a class="code" href="../../d3/d8/udfprocs_8h.html#a162">UdfCreateUserMdl</a>( IrpContext, ByteCount, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
00265     }
00266 
00267     <span class="comment">//</span>
00268     <span class="comment">//  Use a try-finally to perform the final cleanup.</span>
00269     <span class="comment">//</span>
00270 
00271     <span class="keywordflow">try</span> {
00272 
00273         <a class="code" href="../../d3/d8/udfprocs_8h.html#a70">UdfMapUserBuffer</a>( IrpContext, &amp;UserBuffer);
00274 
00275         <span class="comment">//</span>
00276         <span class="comment">//  Loop while there are more bytes to transfer.</span>
00277         <span class="comment">//</span>
00278 
00279         <span class="keywordflow">do</span> {
00280 
00281             <span class="comment">//</span>
00282             <span class="comment">//  Call prepare buffers to set up the next entries</span>
00283             <span class="comment">//  in the IoRuns array.  Remember if there are any</span>
00284             <span class="comment">//  unaligned entries.</span>
00285             <span class="comment">//</span>
00286 
00287             RtlZeroMemory( IoRuns, <span class="keyword">sizeof</span>( IoRuns ));
00288 
00289             Unaligned = <a class="code" href="../../d3/d7/deviosup_8c.html#a18">UdfPrepareBuffers</a>( IrpContext,
00290                                            IrpContext-&gt;Irp,
00291                                            Fcb,
00292                                            UserBuffer,
00293                                            UserBufferOffset,
00294                                            CurrentOffset,
00295                                            RemainingByteCount,
00296                                            IoRuns,
00297                                            &amp;CleanupRunCount,
00298                                            &amp;ThisByteCount,
00299                                            &amp;SparseRuns );
00300 
00301 
00302             RunCount = CleanupRunCount;
00303 
00304             <span class="comment">//</span>
00305             <span class="comment">//  Quickly finish if we wound up having no IO to perform.  This will</span>
00306             <span class="comment">//  occur in the presence of unrecorded sectors.</span>
00307             <span class="comment">//</span>
00308 
00309             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( !(SparseRuns &amp;&amp; <a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( Fcb-&gt;FcbState, <a class="code" href="../../d6/d8/udfstruc_8h.html#a15">FCB_STATE_VMCB_MAPPING</a>|<a class="code" href="../../d6/d8/udfstruc_8h.html#a16">FCB_STATE_EMBEDDED_DATA</a> )));
00310 
00311             <span class="keywordflow">if</span> (RunCount == 0) {
00312 
00313                 <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = IrpContext-&gt;Irp-&gt;IoStatus.Status = STATUS_SUCCESS );
00314             }
00315 
00316             <span class="comment">//</span>
00317             <span class="comment">//  If this is an async request and there aren't enough entries</span>
00318             <span class="comment">//  in the Io array then post the request.  This routine will</span>
00319             <span class="comment">//  always raise if we are doing any unaligned Io for an</span>
00320             <span class="comment">//  async request.</span>
00321             <span class="comment">//</span>
00322 
00323             <span class="keywordflow">if</span> ((ThisByteCount &lt; RemainingByteCount) &amp;&amp;
00324                 !<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( IrpContext-&gt;Flags, <a class="code" href="../../d6/d8/udfstruc_8h.html#a30">IRP_CONTEXT_FLAG_WAIT</a> )) {
00325 
00326                 <a class="code" href="../../d3/d8/udfprocs_8h.html#a122">UdfRaiseStatus</a>( IrpContext, STATUS_CANT_WAIT );
00327             }
00328 
00329             <span class="comment">//</span>
00330             <span class="comment">//  If the entire Io is contained in a single run then</span>
00331             <span class="comment">//  we can pass the Io down to the driver.  Send the driver down</span>
00332             <span class="comment">//  and wait on the result if this is synchronous.  We cannot</span>
00333             <span class="comment">//  do this simple form (just chucking the IRP down) if some</span>
00334             <span class="comment">//  sparse runs were encountered.</span>
00335             <span class="comment">//</span>
00336 
00337             <span class="keywordflow">if</span> ((RunCount == 1) &amp;&amp; !Unaligned &amp;&amp; !SparseRuns &amp;&amp; FirstPass) {
00338 
00339                 <a class="code" href="../../d3/d7/deviosup_8c.html#a8">UdfSingleAsync</a>( IrpContext,
00340                                 IoRuns[0].DiskOffset,
00341                                 IoRuns[0].DiskByteCount );
00342 
00343                 <span class="comment">//</span>
00344                 <span class="comment">//  No cleanup needed for the IoRuns array here.</span>
00345                 <span class="comment">//</span>
00346 
00347                 CleanupRunCount = 0;
00348 
00349                 <span class="comment">//</span>
00350                 <span class="comment">//  Wait if we are synchronous, otherwise return</span>
00351                 <span class="comment">//</span>
00352 
00353                 <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( IrpContext-&gt;Flags, <a class="code" href="../../d6/d8/udfstruc_8h.html#a30">IRP_CONTEXT_FLAG_WAIT</a> )) {
00354 
00355                     <a class="code" href="../../d3/d7/deviosup_8c.html#a9">UdfWaitSync</a>( IrpContext );
00356 
00357                     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = IrpContext-&gt;Irp-&gt;IoStatus.Status;
00358 
00359                 <span class="comment">//</span>
00360                 <span class="comment">//  Our completion routine will free the Io context but</span>
00361                 <span class="comment">//  we do want to return STATUS_PENDING.</span>
00362                 <span class="comment">//</span>
00363 
00364                 } <span class="keywordflow">else</span> {
00365 
00366                     <a class="code" href="../../d5/d5/cc_8h.html#a61">ClearFlag</a>( IrpContext-&gt;Flags, <a class="code" href="../../d6/d8/udfstruc_8h.html#a36">IRP_CONTEXT_FLAG_ALLOC_IO</a> );
00367                     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_PENDING;
00368                 }
00369 
00370                 <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( NOTHING );
00371             }
00372 
00373             <span class="comment">//</span>
00374             <span class="comment">//  Otherwise we will perform multiple Io to read in the data.</span>
00375             <span class="comment">//</span>
00376             
00377             <a class="code" href="../../d3/d7/deviosup_8c.html#a7">UdfMultipleAsync</a>( IrpContext, RunCount, IoRuns );
00378 
00379             <span class="comment">//</span>
00380             <span class="comment">//  No cleanup needed on the IoRuns now.</span>
00381             <span class="comment">//</span>
00382 
00383             CleanupRunCount = 0;
00384 
00385             <span class="comment">//</span>
00386             <span class="comment">//  If this is a synchronous request then perform any necessary</span>
00387             <span class="comment">//  post-processing.</span>
00388             <span class="comment">//</span>
00389 
00390             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( IrpContext-&gt;Flags, <a class="code" href="../../d6/d8/udfstruc_8h.html#a30">IRP_CONTEXT_FLAG_WAIT</a> )) {
00391 
00392                 <span class="comment">//</span>
00393                 <span class="comment">//  Wait for the request to complete.</span>
00394                 <span class="comment">//</span>
00395 
00396                 <a class="code" href="../../d3/d7/deviosup_8c.html#a9">UdfWaitSync</a>( IrpContext );
00397 
00398                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = IrpContext-&gt;Irp-&gt;IoStatus.Status;
00399 
00400                 <span class="comment">//</span>
00401                 <span class="comment">//  Exit this loop if there is an error.</span>
00402                 <span class="comment">//</span>
00403 
00404                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
00405 
00406                     <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( NOTHING );
00407                 }
00408 
00409                 <span class="comment">//</span>
00410                 <span class="comment">//  Perform post read operations on the IoRuns if</span>
00411                 <span class="comment">//  necessary.</span>
00412                 <span class="comment">//</span>
00413 
00414                 <span class="keywordflow">if</span> (Unaligned &amp;&amp;
00415                     <a class="code" href="../../d3/d7/deviosup_8c.html#a6">UdfFinishBuffers</a>( IrpContext, IoRuns, RunCount, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> )) {
00416 
00417                     FlushIoBuffers = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00418                 }
00419 
00420                 <span class="comment">//</span>
00421                 <span class="comment">//  Exit this loop if there are no more bytes to transfer</span>
00422                 <span class="comment">//  or we have any error.</span>
00423                 <span class="comment">//</span>
00424 
00425                 RemainingByteCount -= ThisByteCount;
00426                 CurrentOffset += ThisByteCount;
00427                 UserBuffer = <a class="code" href="../../d2/d7/notify_8c.html#a7">Add2Ptr</a>( UserBuffer, ThisByteCount, PVOID );
00428                 UserBufferOffset += ThisByteCount;
00429 
00430             <span class="comment">//</span>
00431             <span class="comment">//  Otherwise this is an asynchronous request.  Always return</span>
00432             <span class="comment">//  STATUS_PENDING.</span>
00433             <span class="comment">//</span>
00434 
00435             } <span class="keywordflow">else</span> {
00436 
00437                 <a class="code" href="../../d5/d5/cc_8h.html#a61">ClearFlag</a>( IrpContext-&gt;Flags, <a class="code" href="../../d6/d8/udfstruc_8h.html#a36">IRP_CONTEXT_FLAG_ALLOC_IO</a> );
00438                 CleanupRunCount = 0;
00439                 <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_PENDING );
00440                 <span class="keywordflow">break</span>;
00441             }
00442 
00443             FirstPass = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00444         } <span class="keywordflow">while</span> (RemainingByteCount != 0);
00445 
00446         <span class="comment">//</span>
00447         <span class="comment">//  Flush the hardware cache if we performed any copy operations.</span>
00448         <span class="comment">//</span>
00449 
00450         <span class="keywordflow">if</span> (FlushIoBuffers) {
00451 
00452             <a class="code" href="../../d3/d5/ppc_2flush_8c.html#a9">KeFlushIoBuffers</a>( IrpContext-&gt;Irp-&gt;MdlAddress, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00453         }
00454 
00455     } finally {
00456 
00457         <a class="code" href="../../d8/d3/lfsdata_8h.html#a3">DebugUnwind</a>( <span class="stringliteral">"UdfNonCachedRead"</span> );
00458 
00459         <span class="comment">//</span>
00460         <span class="comment">//  Perform final cleanup on the IoRuns if necessary.</span>
00461         <span class="comment">//</span>
00462 
00463         <span class="keywordflow">if</span> (CleanupRunCount != 0) {
00464 
00465             <a class="code" href="../../d3/d7/deviosup_8c.html#a6">UdfFinishBuffers</a>( IrpContext, IoRuns, CleanupRunCount, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
00466         }
00467     }
00468 
00469     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00470 }
00471 
00472 
00473 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00474"></a><a class="code" href="../../d3/d8/udfprocs_8h.html#a162">00474</a> <a class="code" href="../../d3/d8/udfprocs_8h.html#a162">UdfCreateUserMdl</a> (
00475     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00476     IN ULONG BufferLength,
00477     IN BOOLEAN RaiseOnError
00478     )
00479 
00480 <span class="comment">/*++</span>
00481 <span class="comment"></span>
00482 <span class="comment">Routine Description:</span>
00483 <span class="comment"></span>
00484 <span class="comment">    This routine locks the specified buffer for read access (we only write into</span>
00485 <span class="comment">    the buffer).  The file system requires this routine since it does not</span>
00486 <span class="comment">    ask the I/O system to lock its buffers for direct I/O.  This routine</span>
00487 <span class="comment">    may only be called from the Fsd while still in the user context.</span>
00488 <span class="comment"></span>
00489 <span class="comment">    This routine is only called if there is not already an Mdl.</span>
00490 <span class="comment"></span>
00491 <span class="comment">Arguments:</span>
00492 <span class="comment"></span>
00493 <span class="comment">    BufferLength - Length of user buffer.</span>
00494 <span class="comment"></span>
00495 <span class="comment">    RaiseOnError - Indicates if our caller wants this routine to raise on</span>
00496 <span class="comment">        an error condition.</span>
00497 <span class="comment"></span>
00498 <span class="comment">Return Value:</span>
00499 <span class="comment"></span>
00500 <span class="comment">    NTSTATUS - Status from this routine.  Error status only returned if</span>
00501 <span class="comment">        RaiseOnError is FALSE.</span>
00502 <span class="comment"></span>
00503 <span class="comment">--*/</span>
00504 
00505 {
00506     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INSUFFICIENT_RESOURCES;
00507     <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> Mdl;
00508 
00509     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00510 
00511     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
00512     <a class="code" href="../../d1/d8/udfdata_8h.html#a32">ASSERT_IRP</a>( IrpContext-&gt;Irp );
00513     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( IrpContext-&gt;Irp-&gt;MdlAddress == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00514 
00515     <span class="comment">//</span>
00516     <span class="comment">// Allocate the Mdl, and Raise if we fail.</span>
00517     <span class="comment">//</span>
00518 
00519     Mdl = <a class="code" href="../../d4/d6/iosubs_8c.html#a19">IoAllocateMdl</a>( IrpContext-&gt;Irp-&gt;UserBuffer,
00520                          BufferLength,
00521                          <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00522                          <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00523                          IrpContext-&gt;Irp );
00524 
00525     <span class="keywordflow">if</span> (Mdl != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00526 
00527         <span class="comment">//</span>
00528         <span class="comment">//  Now probe the buffer described by the Irp.  If we get an exception,</span>
00529         <span class="comment">//  deallocate the Mdl and return the appropriate "expected" status.</span>
00530         <span class="comment">//</span>
00531 
00532         <span class="keywordflow">try</span> {
00533 
00534             <a class="code" href="../../d5/d6/iosup_8c.html#a41">MmProbeAndLockPages</a>( Mdl, IrpContext-&gt;Irp-&gt;RequestorMode, <a class="code" href="../../d2/d1/mm_8h.html#a344a169">IoWriteAccess</a> );
00535 
00536             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
00537 
00538         } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
00539 
00540             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = GetExceptionCode();
00541 
00542             <a class="code" href="../../d4/d6/iosubs_8c.html#a65">IoFreeMdl</a>( Mdl );
00543             IrpContext-&gt;Irp-&gt;MdlAddress = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00544 
00545             <span class="keywordflow">if</span> (!<a class="code" href="../../d1/d8/fsrtl_8h.html#a137">FsRtlIsNtstatusExpected</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
00546 
00547                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_USER_BUFFER;
00548             }
00549         }
00550     }
00551 
00552     <span class="comment">//</span>
00553     <span class="comment">//  Check if we are to raise or return</span>
00554     <span class="comment">//</span>
00555 
00556     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> != STATUS_SUCCESS) {
00557 
00558         <span class="keywordflow">if</span> (RaiseOnError) {
00559 
00560             <a class="code" href="../../d3/d8/udfprocs_8h.html#a122">UdfRaiseStatus</a>( IrpContext, <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> );
00561         }
00562     }
00563 
00564     <span class="comment">//</span>
00565     <span class="comment">//  Return the status code.</span>
00566     <span class="comment">//</span>
00567 
00568     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00569 }
00570 
00571 
00572 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00573"></a><a class="code" href="../../d3/d8/udfprocs_8h.html#a159">00573</a> <a class="code" href="../../d3/d8/udfprocs_8h.html#a159">UdfPerformDevIoCtrl</a> (
00574     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00575     IN ULONG IoControlCode,
00576     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> Device,
00577     OUT PVOID OutputBuffer OPTIONAL,
00578     IN ULONG OutputBufferLength,
00579     IN BOOLEAN InternalDeviceIoControl,
00580     IN BOOLEAN OverrideVerify,
00581     OUT PIO_STATUS_BLOCK Iosb OPTIONAL
00582     )
00583 
00584 <span class="comment">/*++</span>
00585 <span class="comment"></span>
00586 <span class="comment">Routine Description:</span>
00587 <span class="comment"></span>
00588 <span class="comment">    This routine is called to perform DevIoCtrl functions internally within</span>
00589 <span class="comment">    the filesystem.  We take the status from the driver and return it to our</span>
00590 <span class="comment">    caller.</span>
00591 <span class="comment"></span>
00592 <span class="comment">Arguments:</span>
00593 <span class="comment"></span>
00594 <span class="comment">    IoControlCode - Code to send to driver.</span>
00595 <span class="comment"></span>
00596 <span class="comment">    Device - This is the device to send the request to.</span>
00597 <span class="comment"></span>
00598 <span class="comment">    OutPutBuffer - Pointer to output buffer.</span>
00599 <span class="comment"></span>
00600 <span class="comment">    OutputBufferLength - Length of output buffer above.</span>
00601 <span class="comment"></span>
00602 <span class="comment">    InternalDeviceIoControl - Indicates if this is an internal or external</span>
00603 <span class="comment">        Io control code.</span>
00604 <span class="comment"></span>
00605 <span class="comment">    OverrideVerify - Indicates if we should tell the driver not to return</span>
00606 <span class="comment">        STATUS_VERIFY_REQUIRED for mount and verify.</span>
00607 <span class="comment"></span>
00608 <span class="comment">    Iosb - If specified, we return the results of the operation here.</span>
00609 <span class="comment"></span>
00610 <span class="comment">Return Value:</span>
00611 <span class="comment"></span>
00612 <span class="comment">    NTSTATUS - Status returned by next lower driver.</span>
00613 <span class="comment"></span>
00614 <span class="comment">--*/</span>
00615 
00616 {
00617     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00618     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>;
00619     <a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a> <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>;
00620     IO_STATUS_BLOCK LocalIosb;
00621     PIO_STATUS_BLOCK IosbToUse = &amp;LocalIosb;
00622 
00623     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00624 
00625     <span class="comment">//</span>
00626     <span class="comment">//  Check if the user gave us an Iosb.</span>
00627     <span class="comment">//</span>
00628 
00629     <span class="keywordflow">if</span> (ARGUMENT_PRESENT( Iosb )) {
00630 
00631         IosbToUse = Iosb;
00632     }
00633 
00634     IosbToUse-&gt;Status = 0;
00635     IosbToUse-&gt;Information = 0;
00636 
00637     <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( &amp;<a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>, NotificationEvent, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00638 
00639     <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> = <a class="code" href="../../d4/d6/iosubs_8c.html#a25">IoBuildDeviceIoControlRequest</a>( IoControlCode,
00640                                          Device,
00641                                          <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00642                                          0,
00643                                          OutputBuffer,
00644                                          OutputBufferLength,
00645                                          InternalDeviceIoControl,
00646                                          &amp;<a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>,
00647                                          IosbToUse );
00648 
00649     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00650 
00651         <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
00652     }
00653 
00654     <span class="keywordflow">if</span> (OverrideVerify) {
00655 
00656         <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>( <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> )-&gt;Flags, <a class="code" href="../../d0/d5/io_8h.html#a203">SL_OVERRIDE_VERIFY_VOLUME</a> );
00657     }
00658 
00659     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>( Device, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
00660 
00661     <span class="comment">//</span>
00662     <span class="comment">//  We check for device not ready by first checking Status</span>
00663     <span class="comment">//  and then if status pending was returned, the Iosb status</span>
00664     <span class="comment">//  value.</span>
00665     <span class="comment">//</span>
00666 
00667     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_PENDING) {
00668 
00669         (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;<a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>,
00670                                       <a class="code" href="../../d6/d7/halmips_8h.html#a455">Executive</a>,
00671                                       <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
00672                                       <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00673                                       (PLARGE_INTEGER)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00674 
00675         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = IosbToUse-&gt;Status;
00676     }
00677 
00678     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00679 
00680     UNREFERENCED_PARAMETER( IrpContext );
00681 }
00682 
00683 
00684 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00685"></a><a class="code" href="../../d3/d8/udfprocs_8h.html#a160">00685</a> <a class="code" href="../../d3/d8/udfprocs_8h.html#a160">UdfReadSectors</a> (
00686     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00687     IN LONGLONG StartingOffset,
00688     IN ULONG ByteCount,
00689     IN BOOLEAN ReturnError,
00690     IN OUT PVOID Buffer,
00691     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> TargetDeviceObject
00692     )
00693 
00694 <span class="comment">/*++</span>
00695 <span class="comment"></span>
00696 <span class="comment">Routine Description:</span>
00697 <span class="comment"></span>
00698 <span class="comment">    This routine is called to transfer sectors from the disk to a</span>
00699 <span class="comment">    specified buffer.  It is used for mount and volume verify operations.</span>
00700 <span class="comment"></span>
00701 <span class="comment">    This routine is synchronous, it will not return until the operation</span>
00702 <span class="comment">    is complete or until the operation fails.</span>
00703 <span class="comment"></span>
00704 <span class="comment">    The routine allocates an IRP and then passes this IRP to a lower</span>
00705 <span class="comment">    level driver.  Errors may occur in the allocation of this IRP or</span>
00706 <span class="comment">    in the operation of the lower driver.</span>
00707 <span class="comment"></span>
00708 <span class="comment">Arguments:</span>
00709 <span class="comment"></span>
00710 <span class="comment">    StartingOffset - Logical offset on the disk to start the read.  This</span>
00711 <span class="comment">        must be on a sector boundary, no check is made here.</span>
00712 <span class="comment"></span>
00713 <span class="comment">    ByteCount - Number of bytes to read.  This is an integral number of</span>
00714 <span class="comment">        sectors, or otherwise a value we know the driver can handle,</span>
00715 <span class="comment">        no check is made here to confirm this.</span>
00716 <span class="comment"></span>
00717 <span class="comment">    ReturnError - Indicates whether we should return TRUE or FALSE</span>
00718 <span class="comment">        to indicate an error or raise an error condition.  This only applies</span>
00719 <span class="comment">        to the result of the IO.  Any other error may cause a raise.</span>
00720 <span class="comment"></span>
00721 <span class="comment">    Buffer - Buffer to transfer the disk data into.</span>
00722 <span class="comment"></span>
00723 <span class="comment">    TargetDeviceObject - The device object for the volume to be read.</span>
00724 <span class="comment"></span>
00725 <span class="comment">Return Value:</span>
00726 <span class="comment"></span>
00727 <span class="comment">    The final status of the operation.</span>
00728 <span class="comment"></span>
00729 <span class="comment">--*/</span>
00730 
00731 {
00732     PLONGLONG UseStartingOffset;
00733     LONGLONG LocalStartingOffset;
00734     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00735     <a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a>  <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>;
00736     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>;
00737 
00738     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00739 
00740     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( +1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
00741                  <span class="stringliteral">"UdfReadSectors, %x%08x +%x -&gt; %08x from DO %08x\n"</span>,
00742                  ((PLARGE_INTEGER)&amp;StartingOffset)-&gt;HighPart,
00743                  ((PLARGE_INTEGER)&amp;StartingOffset)-&gt;LowPart,
00744                  ByteCount,
00745                  <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>,
00746                  TargetDeviceObject ));
00747     
00748     <span class="comment">//</span>
00749     <span class="comment">//  For the time being, we assume that we only read sector-at-a-time.</span>
00750     <span class="comment">//  This simplifies sparing, and is the only way I am aware of this</span>
00751     <span class="comment">//  code would not be ready for blocksize != sectorsize.  It just is</span>
00752     <span class="comment">//  not worth writing dead (but straightforward) code right now.</span>
00753     <span class="comment">//</span>
00754 
00755     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( IrpContext-&gt;Vcb == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> || ByteCount == <a class="code" href="../../d3/d8/udfprocs_8h.html#a42">SectorSize</a>( IrpContext-&gt;Vcb ));
00756 
00757     <span class="comment">//</span>
00758     <span class="comment">//  If the volume is spared (and at a point where sparing is possible),</span>
00759     <span class="comment">//  check if a mapping needs to be performed.</span>
00760     <span class="comment">//</span>
00761     
00762     <span class="keywordflow">if</span> (IrpContext-&gt;Vcb &amp;&amp;
00763         IrpContext-&gt;Vcb-&gt;Pcb &amp;&amp;
00764         IrpContext-&gt;Vcb-&gt;Pcb-&gt;SparingMcb) {
00765         
00766         LONGLONG SparingPsn;
00767     
00768         <span class="keywordflow">if</span> (<a class="code" href="../../d1/d8/fsrtl_8h.html#a145">FsRtlLookupLargeMcbEntry</a>( IrpContext-&gt;Vcb-&gt;Pcb-&gt;SparingMcb,
00769                                       <a class="code" href="../../d3/d8/udfprocs_8h.html#a40">LlSectorsFromBytes</a>( IrpContext-&gt;Vcb, StartingOffset ),
00770                                       &amp;SparingPsn,
00771                                       <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00772                                       <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00773                                       <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00774                                       <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) &amp;&amp;
00775             SparingPsn != -1) {
00776 
00777             StartingOffset = <a class="code" href="../../d3/d8/fsrtlp_8h.html#a14">BytesFromSectors</a>( IrpContext-&gt;Vcb, (ULONG) SparingPsn );
00778         }
00779     }
00780     
00781     <span class="comment">//</span>
00782     <span class="comment">//  Initialize the event.</span>
00783     <span class="comment">//</span>
00784 
00785     <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( &amp;<a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>, NotificationEvent, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00786 
00787     <span class="comment">//</span>
00788     <span class="comment">//  Correct the starting offset by the method 2 fixup if neccesary.  This also</span>
00789     <span class="comment">//  assumes sector-at-a-time and sector == block so we don't need to fragment</span>
00790     <span class="comment">//  the request or check if it spans a packet boundary.</span>
00791     <span class="comment">//</span>
00792     <span class="comment">//  We assume that no fixups are required until a Vcb exists.  This is true</span>
00793     <span class="comment">//  since volume recognition may proceed in the first packet.</span>
00794     <span class="comment">//</span>
00795 
00796     UseStartingOffset = &amp;StartingOffset;
00797 
00798     <span class="keywordflow">if</span> (IrpContext-&gt;Vcb &amp;&amp;
00799         <a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( IrpContext-&gt;Vcb-&gt;VcbState, <a class="code" href="../../d6/d8/udfstruc_8h.html#a8">VCB_STATE_METHOD_2_FIXUP</a> )) {
00800 
00801         LocalStartingOffset = <a class="code" href="../../d9/d7/udf_8h.html#a8">UdfMethod2TransformByteOffset</a>( IrpContext-&gt;Vcb, StartingOffset );
00802         UseStartingOffset = &amp;LocalStartingOffset;
00803 
00804         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
00805                      <span class="stringliteral">"UdfReadSectors, Method2 Fixup to %x%08x\n"</span>,
00806                      ((PLARGE_INTEGER)UseStartingOffset)-&gt;HighPart,
00807                      ((PLARGE_INTEGER)UseStartingOffset)-&gt;LowPart ));
00808     }
00809 
00810     <span class="comment">//</span>
00811     <span class="comment">//  Attempt to allocate the IRP.  If unsuccessful, raise</span>
00812     <span class="comment">//  STATUS_INSUFFICIENT_RESOURCES.</span>
00813     <span class="comment">//</span>
00814 
00815     <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> = <a class="code" href="../../d4/d6/iosubs_8c.html#a27">IoBuildSynchronousFsdRequest</a>( <a class="code" href="../../d0/d5/io_8h.html#a16">IRP_MJ_READ</a>,
00816                                         TargetDeviceObject,
00817                                         <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>,
00818                                         ByteCount,
00819                                         (PLARGE_INTEGER) UseStartingOffset,
00820                                         &amp;<a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>,
00821                                         &amp;IrpContext-&gt;Irp-&gt;IoStatus );
00822 
00823     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00824 
00825         <a class="code" href="../../d3/d8/udfprocs_8h.html#a122">UdfRaiseStatus</a>( IrpContext, STATUS_INSUFFICIENT_RESOURCES );
00826     }
00827 
00828     <span class="comment">//</span>
00829     <span class="comment">//  Ignore the change line (verify) for mount and verify requests</span>
00830     <span class="comment">//</span>
00831 
00832     <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>( <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> )-&gt;Flags, <a class="code" href="../../d0/d5/io_8h.html#a203">SL_OVERRIDE_VERIFY_VOLUME</a> );
00833 
00834     <span class="comment">//</span>
00835     <span class="comment">//  Send the request down to the driver.  If an error occurs return</span>
00836     <span class="comment">//  it to the caller.</span>
00837     <span class="comment">//</span>
00838 
00839     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>( TargetDeviceObject, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
00840 
00841     <span class="comment">//</span>
00842     <span class="comment">//  If the status was STATUS_PENDING then wait on the event.</span>
00843     <span class="comment">//</span>
00844 
00845     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_PENDING) {
00846 
00847         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;<a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>,
00848                                         <a class="code" href="../../d6/d7/halmips_8h.html#a455">Executive</a>,
00849                                         <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
00850                                         <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00851                                         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00852 
00853         <span class="comment">//</span>
00854         <span class="comment">//  On a successful wait pull the status out of the IoStatus block.</span>
00855         <span class="comment">//</span>
00856 
00857         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
00858 
00859             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = IrpContext-&gt;Irp-&gt;IoStatus.Status;
00860         }
00861     }
00862 
00863     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfReadSectors -&gt; %08x\n"</span>, <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> ));
00864     
00865     <span class="comment">//</span>
00866     <span class="comment">//  Check whether we should raise in the error case.</span>
00867     <span class="comment">//</span>
00868 
00869     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> ) &amp;&amp; !ReturnError) {
00870 
00871         <a class="code" href="../../d3/d8/udfprocs_8h.html#a123">UdfNormalizeAndRaiseStatus</a>( IrpContext, <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> );
00872     }
00873 
00874     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00875 }
00876 
00877 
00878 <span class="comment">//</span>
00879 <span class="comment">//  Local support routine</span>
00880 <span class="comment">//</span>
00881 
00882 BOOLEAN
<a name="l00883"></a><a class="code" href="../../d3/d7/deviosup_8c.html#a18">00883</a> <a class="code" href="../../d3/d7/deviosup_8c.html#a18">UdfPrepareBuffers</a> (
00884     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00885     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp,
00886     IN <a class="code" href="../../d7/d9/struct__FCB.html">PFCB</a> Fcb,
00887     IN PVOID UserBuffer,
00888     IN ULONG UserBufferOffset,
00889     IN LONGLONG StartingOffset,
00890     IN ULONG ByteCount,
00891     IN PIO_RUN IoRuns,
00892     IN PULONG RunCount,
00893     IN PULONG ThisByteCount,
00894     IN PBOOLEAN SparseRuns
00895     )
00896 
00897 <span class="comment">/*++</span>
00898 <span class="comment"></span>
00899 <span class="comment">Routine Description:</span>
00900 <span class="comment"></span>
00901 <span class="comment">    This routine is the worker routine which looks up each run of an IO</span>
00902 <span class="comment">    request and stores an entry for it in the IoRuns array.  If the run</span>
00903 <span class="comment">    begins on an unaligned disk boundary then we will allocate a buffer</span>
00904 <span class="comment">    and Mdl for the unaligned portion and put it in the IoRuns entry.</span>
00905 <span class="comment"></span>
00906 <span class="comment">    This routine will raise CANT_WAIT if an unaligned transfer is encountered</span>
00907 <span class="comment">    and this request can't wait.</span>
00908 <span class="comment"></span>
00909 <span class="comment">Arguments:</span>
00910 <span class="comment"></span>
00911 <span class="comment">    Irp - Originating Irp for this request.</span>
00912 <span class="comment"></span>
00913 <span class="comment">    Fcb - This is the Fcb for this data stream.  It may be a file, directory,</span>
00914 <span class="comment">        path table or the volume file.</span>
00915 <span class="comment"></span>
00916 <span class="comment">    UserBuffer - Current position in the user's buffer.</span>
00917 <span class="comment"></span>
00918 <span class="comment">    UserBufferOffset - Offset from the start of the original user buffer.</span>
00919 <span class="comment"></span>
00920 <span class="comment">    StartingOffset - Offset in the stream to begin the read.</span>
00921 <span class="comment"></span>
00922 <span class="comment">    ByteCount - Number of bytes to read.  We will fill the IoRuns array up</span>
00923 <span class="comment">        to this point.  We will stop early if we exceed the maximum number</span>
00924 <span class="comment">        of parallel Ios we support.</span>
00925 <span class="comment"></span>
00926 <span class="comment">    IoRuns - Pointer to the IoRuns array.  The entire array is zeroes when</span>
00927 <span class="comment">        this routine is called.</span>
00928 <span class="comment"></span>
00929 <span class="comment">    RunCount - Number of entries in the IoRuns array filled here.</span>
00930 <span class="comment"></span>
00931 <span class="comment">    ThisByteCount - Number of bytes described by the IoRun entries.  Will</span>
00932 <span class="comment">        not exceed the ByteCount passed in.</span>
00933 <span class="comment">        </span>
00934 <span class="comment">    SparseRuns - Will indicate whether sparse runs were a component of the</span>
00935 <span class="comment">        range returned.  While not part of the IoRuns, this will affect</span>
00936 <span class="comment">        our ability to do simple IO.</span>
00937 <span class="comment"></span>
00938 <span class="comment">Return Value:</span>
00939 <span class="comment"></span>
00940 <span class="comment">    BOOLEAN - TRUE if one of the entries in an unaligned buffer (provided</span>
00941 <span class="comment">        this is synchronous).  FALSE otherwise.</span>
00942 <span class="comment"></span>
00943 <span class="comment">--*/</span>
00944 
00945 {
00946     <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb;
00947 
00948     BOOLEAN Recorded;
00949     
00950     BOOLEAN FoundUnaligned = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00951     <a class="code" href="../../d3/d7/deviosup_8c.html#a4">PIO_RUN</a> ThisIoRun = IoRuns;
00952 
00953     <span class="comment">//</span>
00954     <span class="comment">//  Following indicate where we are in the current transfer.  Current</span>
00955     <span class="comment">//  position in the file and number of bytes yet to transfer from</span>
00956     <span class="comment">//  this position.</span>
00957     <span class="comment">//</span>
00958 
00959     ULONG RemainingByteCount = ByteCount;
00960     LONGLONG CurrentFileOffset = StartingOffset;
00961 
00962     <span class="comment">//</span>
00963     <span class="comment">//  Following indicate the state of the user's buffer.  We have</span>
00964     <span class="comment">//  the destination of the next transfer and its offset in the</span>
00965     <span class="comment">//  buffer.  We also have the next available position in the buffer</span>
00966     <span class="comment">//  available for a scratch buffer.  We will align this up to a sector</span>
00967     <span class="comment">//  boundary.</span>
00968     <span class="comment">//</span>
00969 
00970     PVOID CurrentUserBuffer = UserBuffer;
00971     ULONG CurrentUserBufferOffset = UserBufferOffset;
00972 
00973     PVOID ScratchUserBuffer = UserBuffer;
00974     ULONG ScratchUserBufferOffset = UserBufferOffset;
00975 
00976     <span class="comment">//</span>
00977     <span class="comment">//  The following is the next contiguous bytes on the disk to</span>
00978     <span class="comment">//  transfer.  Read from the allocation package.</span>
00979     <span class="comment">//</span>
00980 
00981     LONGLONG DiskOffset;
00982     ULONG CurrentByteCount;
00983 
00984     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00985 
00986     Vcb = Fcb-&gt;Vcb;
00987 
00988     <span class="comment">//</span>
00989     <span class="comment">//  Initialize the RunCount, ByteCount and SparseRuns.</span>
00990     <span class="comment">//</span>
00991 
00992     *RunCount = 0;
00993     *ThisByteCount = 0;
00994     *SparseRuns = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00995 
00996     <span class="comment">//</span>
00997     <span class="comment">//  Loop while there are more bytes to process or there are</span>
00998     <span class="comment">//  available entries in the IoRun array.</span>
00999     <span class="comment">//</span>
01000 
01001     <span class="keywordflow">while</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
01002 
01003         *RunCount += 1;
01004 
01005         <span class="comment">//</span>
01006         <span class="comment">//  Initialize the current position in the IoRuns array.</span>
01007         <span class="comment">//  Find the user's buffer for this portion of the transfer.</span>
01008         <span class="comment">//</span>
01009 
01010         ThisIoRun-&gt;<a class="code" href="../../d0/d5/struct__IO__RUN.html#o2">UserBuffer</a> = CurrentUserBuffer;
01011 
01012         <span class="comment">//</span>
01013         <span class="comment">//  Find the allocation information for the current offset in the</span>
01014         <span class="comment">//  stream.</span>
01015         <span class="comment">//</span>
01016 
01017         Recorded = <a class="code" href="../../d3/d8/udfprocs_8h.html#a146">UdfLookupAllocation</a>( IrpContext,
01018                                         Fcb,
01019                                         CurrentFileOffset,
01020                                         &amp;DiskOffset,
01021                                         &amp;CurrentByteCount );
01022 
01023         <span class="comment">//</span>
01024         <span class="comment">//  Limit ourselves to the data requested.</span>
01025         <span class="comment">//</span>
01026 
01027         <span class="keywordflow">if</span> (CurrentByteCount &gt; RemainingByteCount) {
01028 
01029             CurrentByteCount = RemainingByteCount;
01030         }
01031 
01032         <span class="comment">//</span>
01033         <span class="comment">//  Handle the case of unrecorded data first.</span>
01034         <span class="comment">//</span>
01035 
01036         <span class="keywordflow">if</span> (!Recorded) {
01037 
01038             <span class="comment">//</span>
01039             <span class="comment">//  Note that we did not consume an entry.</span>
01040             <span class="comment">//</span>
01041 
01042             *RunCount -= 1;
01043 
01044             <span class="comment">//</span>
01045             <span class="comment">//  Immediately zero the user buffer and indicate that we found sparse</span>
01046             <span class="comment">//  runs to the caller.</span>
01047             <span class="comment">//</span>
01048 
01049             RtlZeroMemory( CurrentUserBuffer, CurrentByteCount );
01050             *SparseRuns = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01051 
01052             <span class="comment">//</span>
01053             <span class="comment">//  Push the scratch buffer pointers forward so that we don't stomp</span>
01054             <span class="comment">//  on the zeroed buffer.</span>
01055             <span class="comment">//</span>
01056 
01057             ScratchUserBuffer = <a class="code" href="../../d2/d7/notify_8c.html#a7">Add2Ptr</a>( CurrentUserBuffer,
01058                                          CurrentByteCount,
01059                                          PVOID );
01060 
01061             ScratchUserBufferOffset += CurrentByteCount;
01062 
01063         <span class="comment">//</span>
01064         <span class="comment">//  Handle the case where this is an unaligned transfer.  The</span>
01065         <span class="comment">//  following must all be true for this to be an aligned transfer.</span>
01066         <span class="comment">//</span>
01067         <span class="comment">//      Disk offset on a 2048 byte boundary (Start of transfer)</span>
01068         <span class="comment">//</span>
01069         <span class="comment">//      Byte count is a multiple of 2048 (Length of transfer)</span>
01070         <span class="comment">//</span>
01071         <span class="comment">//      Current buffer offset is also on a 2048 byte boundary.</span>
01072         <span class="comment">//</span>
01073         <span class="comment">//  If the ByteCount is at least one sector then do the</span>
01074         <span class="comment">//  unaligned transfer only for the tail.  We can use the</span>
01075         <span class="comment">//  user's buffer for the aligned portion.</span>
01076         <span class="comment">//</span>
01077 
01078         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="../../d3/d8/udfprocs_8h.html#a43">SectorOffset</a>( Vcb, DiskOffset ) ||
01079                    <a class="code" href="../../d3/d8/udfprocs_8h.html#a43">SectorOffset</a>( Vcb, CurrentUserBufferOffset ) ||
01080                    (<a class="code" href="../../d3/d8/udfprocs_8h.html#a43">SectorOffset</a>( Vcb, CurrentByteCount ) &amp;&amp;
01081                     CurrentByteCount &lt; <a class="code" href="../../d3/d8/udfprocs_8h.html#a42">SectorSize</a>( Vcb ))) {
01082 
01083             <span class="comment">//</span>
01084             <span class="comment">//  If we can't wait then raise.</span>
01085             <span class="comment">//</span>
01086 
01087             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( IrpContext-&gt;Flags, <a class="code" href="../../d6/d8/udfstruc_8h.html#a30">IRP_CONTEXT_FLAG_WAIT</a> )) {
01088 
01089                 <a class="code" href="../../d3/d8/udfprocs_8h.html#a122">UdfRaiseStatus</a>( IrpContext, STATUS_CANT_WAIT );
01090             }
01091 
01092             <span class="comment">//</span>
01093             <span class="comment">//  Remember the offset and the number of bytes out of</span>
01094             <span class="comment">//  the transfer buffer to copy into the user's buffer.</span>
01095             <span class="comment">//  We will truncate the current read to end on a sector</span>
01096             <span class="comment">//  boundary.</span>
01097             <span class="comment">//</span>
01098 
01099             ThisIoRun-&gt;<a class="code" href="../../d0/d5/struct__IO__RUN.html#o5">TransferBufferOffset</a> = <a class="code" href="../../d3/d8/udfprocs_8h.html#a43">SectorOffset</a>( Vcb, DiskOffset );
01100 
01101             <span class="comment">//</span>
01102             <span class="comment">//  Make sure this transfer ends on a sector boundary.</span>
01103             <span class="comment">//</span>
01104 
01105             ThisIoRun-&gt;<a class="code" href="../../d0/d5/struct__IO__RUN.html#o0">DiskOffset</a> = <a class="code" href="../../d3/d8/udfprocs_8h.html#a36">LlSectorTruncate</a>( Vcb, DiskOffset );
01106 
01107             <span class="comment">//</span>
01108             <span class="comment">//  Check if we can use a free portion of the user's buffer.</span>
01109             <span class="comment">//  If we can copy the bytes to an earlier portion of the</span>
01110             <span class="comment">//  buffer then read into that location and slide the bytes</span>
01111             <span class="comment">//  up.</span>
01112             <span class="comment">//</span>
01113             <span class="comment">//  We can use the user's buffer if:</span>
01114             <span class="comment">//</span>
01115             <span class="comment">//      The temporary location in the buffer is before the</span>
01116             <span class="comment">//      final destination.</span>
01117             <span class="comment">//</span>
01118             <span class="comment">//      There is at least one sector of data to read.</span>
01119             <span class="comment">//</span>
01120 
01121             <span class="keywordflow">if</span> ((ScratchUserBufferOffset + ThisIoRun-&gt;<a class="code" href="../../d0/d5/struct__IO__RUN.html#o5">TransferBufferOffset</a> &lt; CurrentUserBufferOffset) &amp;&amp;
01122                 (ThisIoRun-&gt;<a class="code" href="../../d0/d5/struct__IO__RUN.html#o5">TransferBufferOffset</a> + CurrentByteCount &gt;= <a class="code" href="../../d3/d8/udfprocs_8h.html#a42">SectorSize</a>( Vcb ))) {
01123 
01124                 ThisIoRun-&gt;<a class="code" href="../../d0/d5/struct__IO__RUN.html#o1">DiskByteCount</a> = <a class="code" href="../../d3/d8/udfprocs_8h.html#a35">SectorTruncate</a>( Vcb, ThisIoRun-&gt;<a class="code" href="../../d0/d5/struct__IO__RUN.html#o5">TransferBufferOffset</a> + CurrentByteCount );
01125                 CurrentByteCount = ThisIoRun-&gt;<a class="code" href="../../d0/d5/struct__IO__RUN.html#o1">DiskByteCount</a> - ThisIoRun-&gt;<a class="code" href="../../d0/d5/struct__IO__RUN.html#o5">TransferBufferOffset</a>;
01126                 ThisIoRun-&gt;<a class="code" href="../../d0/d5/struct__IO__RUN.html#o4">TransferByteCount</a> = CurrentByteCount;
01127 
01128                 <span class="comment">//</span>
01129                 <span class="comment">//  Point to the user's buffer and Mdl for this transfer.</span>
01130                 <span class="comment">//</span>
01131 
01132                 ThisIoRun-&gt;<a class="code" href="../../d0/d5/struct__IO__RUN.html#o3">TransferBuffer</a> = ScratchUserBuffer;
01133                 ThisIoRun-&gt;<a class="code" href="../../d0/d5/struct__IO__RUN.html#o6">TransferMdl</a> = <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o2">MdlAddress</a>;
01134                 ThisIoRun-&gt;<a class="code" href="../../d0/d5/struct__IO__RUN.html#o7">TransferVirtualAddress</a> = <a class="code" href="../../d2/d7/notify_8c.html#a7">Add2Ptr</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o26">UserBuffer</a>,
01135                                                              ScratchUserBufferOffset,
01136                                                              PVOID );
01137 
01138                 ScratchUserBuffer = <a class="code" href="../../d2/d7/notify_8c.html#a7">Add2Ptr</a>( ScratchUserBuffer,
01139                                              ThisIoRun-&gt;<a class="code" href="../../d0/d5/struct__IO__RUN.html#o1">DiskByteCount</a>,
01140                                              PVOID );
01141 
01142                 ScratchUserBufferOffset += ThisIoRun-&gt;<a class="code" href="../../d0/d5/struct__IO__RUN.html#o1">DiskByteCount</a>;
01143 
01144             <span class="comment">//</span>
01145             <span class="comment">//  Otherwise we need to allocate an auxilary buffer for the next sector.</span>
01146             <span class="comment">//</span>
01147 
01148             } <span class="keywordflow">else</span> {
01149 
01150                 <span class="comment">//</span>
01151                 <span class="comment">//  Read up to a page containing the partial data</span>
01152                 <span class="comment">//</span>
01153 
01154                 ThisIoRun-&gt;<a class="code" href="../../d0/d5/struct__IO__RUN.html#o1">DiskByteCount</a> = <a class="code" href="../../d3/d8/fsrtlp_8h.html#a12">SectorAlign</a>( Vcb, ThisIoRun-&gt;<a class="code" href="../../d0/d5/struct__IO__RUN.html#o5">TransferBufferOffset</a> + CurrentByteCount );
01155 
01156                 <span class="keywordflow">if</span> (ThisIoRun-&gt;<a class="code" href="../../d0/d5/struct__IO__RUN.html#o1">DiskByteCount</a> &gt; <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>) {
01157 
01158                     ThisIoRun-&gt;<a class="code" href="../../d0/d5/struct__IO__RUN.html#o1">DiskByteCount</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
01159                 }
01160 
01161                 <span class="keywordflow">if</span> (ThisIoRun-&gt;<a class="code" href="../../d0/d5/struct__IO__RUN.html#o5">TransferBufferOffset</a> + CurrentByteCount &gt; ThisIoRun-&gt;<a class="code" href="../../d0/d5/struct__IO__RUN.html#o1">DiskByteCount</a>) {
01162 
01163                     CurrentByteCount = ThisIoRun-&gt;<a class="code" href="../../d0/d5/struct__IO__RUN.html#o1">DiskByteCount</a> - ThisIoRun-&gt;<a class="code" href="../../d0/d5/struct__IO__RUN.html#o5">TransferBufferOffset</a>;
01164                 }
01165 
01166                 ThisIoRun-&gt;<a class="code" href="../../d0/d5/struct__IO__RUN.html#o4">TransferByteCount</a> = CurrentByteCount;
01167 
01168                 <span class="comment">//</span>
01169                 <span class="comment">//  Allocate a buffer for the non-aligned transfer.</span>
01170                 <span class="comment">//</span>
01171 
01172                 ThisIoRun-&gt;<a class="code" href="../../d0/d5/struct__IO__RUN.html#o3">TransferBuffer</a> = <a class="code" href="../../d1/d8/fsrtl_8h.html#a37">FsRtlAllocatePoolWithTag</a>( <a class="code" href="../../d3/d8/udfprocs_8h.html#a66">UdfNonPagedPool</a>,
01173                                                                       <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>,
01174                                                                       <a class="code" href="../../d1/d7/udfs_2nodetype_8h.html#a77">TAG_IO_BUFFER</a> );
01175 
01176                 <span class="comment">//</span>
01177                 <span class="comment">//  Allocate and build the Mdl to describe this buffer.</span>
01178                 <span class="comment">//</span>
01179 
01180                 ThisIoRun-&gt;<a class="code" href="../../d0/d5/struct__IO__RUN.html#o6">TransferMdl</a> = <a class="code" href="../../d4/d6/iosubs_8c.html#a19">IoAllocateMdl</a>( ThisIoRun-&gt;<a class="code" href="../../d0/d5/struct__IO__RUN.html#o3">TransferBuffer</a>,
01181                                                         <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>,
01182                                                         <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
01183                                                         <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
01184                                                         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
01185 
01186                 ThisIoRun-&gt;<a class="code" href="../../d0/d5/struct__IO__RUN.html#o7">TransferVirtualAddress</a> = ThisIoRun-&gt;<a class="code" href="../../d0/d5/struct__IO__RUN.html#o3">TransferBuffer</a>;
01187 
01188                 <span class="keywordflow">if</span> (ThisIoRun-&gt;<a class="code" href="../../d0/d5/struct__IO__RUN.html#o6">TransferMdl</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01189 
01190                     IrpContext-&gt;Irp-&gt;IoStatus.Information = 0;
01191                     <a class="code" href="../../d3/d8/udfprocs_8h.html#a122">UdfRaiseStatus</a>( IrpContext, STATUS_INSUFFICIENT_RESOURCES );
01192                 }
01193 
01194                 <a class="code" href="../../d5/d6/iosup_8c.html#a46">MmBuildMdlForNonPagedPool</a>( ThisIoRun-&gt;<a class="code" href="../../d0/d5/struct__IO__RUN.html#o6">TransferMdl</a> );
01195             }
01196 
01197             <span class="comment">//</span>
01198             <span class="comment">//  Remember we found an unaligned transfer.</span>
01199             <span class="comment">//</span>
01200 
01201             FoundUnaligned = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01202 
01203         <span class="comment">//</span>
01204         <span class="comment">//  Otherwise we use the buffer and Mdl from the original request.</span>
01205         <span class="comment">//</span>
01206 
01207         } <span class="keywordflow">else</span> {
01208 
01209             <span class="comment">//</span>
01210             <span class="comment">//  Truncate the read length to a sector-aligned value.  We know</span>
01211             <span class="comment">//  the length must be at least one sector or we wouldn't be</span>
01212             <span class="comment">//  here now.</span>
01213             <span class="comment">//</span>
01214 
01215             CurrentByteCount = <a class="code" href="../../d3/d8/udfprocs_8h.html#a35">SectorTruncate</a>( Vcb, CurrentByteCount );
01216 
01217             <span class="comment">//</span>
01218             <span class="comment">//  Read these sectors from the disk.</span>
01219             <span class="comment">//</span>
01220 
01221             ThisIoRun-&gt;<a class="code" href="../../d0/d5/struct__IO__RUN.html#o0">DiskOffset</a> = DiskOffset;
01222             ThisIoRun-&gt;<a class="code" href="../../d0/d5/struct__IO__RUN.html#o1">DiskByteCount</a> = CurrentByteCount;
01223 
01224             <span class="comment">//</span>
01225             <span class="comment">//  Use the user's buffer and Mdl as our transfer buffer</span>
01226             <span class="comment">//  and Mdl.</span>
01227             <span class="comment">//</span>
01228 
01229             ThisIoRun-&gt;<a class="code" href="../../d0/d5/struct__IO__RUN.html#o3">TransferBuffer</a> = CurrentUserBuffer;
01230             ThisIoRun-&gt;<a class="code" href="../../d0/d5/struct__IO__RUN.html#o6">TransferMdl</a> = <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o2">MdlAddress</a>;
01231             ThisIoRun-&gt;<a class="code" href="../../d0/d5/struct__IO__RUN.html#o7">TransferVirtualAddress</a> = <a class="code" href="../../d2/d7/notify_8c.html#a7">Add2Ptr</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o26">UserBuffer</a>,
01232                                                          CurrentUserBufferOffset,
01233                                                          PVOID );
01234 
01235             ScratchUserBuffer = <a class="code" href="../../d2/d7/notify_8c.html#a7">Add2Ptr</a>( CurrentUserBuffer,
01236                                          CurrentByteCount,
01237                                          PVOID );
01238 
01239             ScratchUserBufferOffset += CurrentByteCount;
01240         }
01241 
01242         <span class="comment">//</span>
01243         <span class="comment">//  Update our position in the transfer and the RunCount and</span>
01244         <span class="comment">//  ByteCount for the user.</span>
01245         <span class="comment">//</span>
01246 
01247         RemainingByteCount -= CurrentByteCount;
01248 
01249         <span class="comment">//</span>
01250         <span class="comment">//  Break out if no more positions in the IoRuns array or</span>
01251         <span class="comment">//  we have all of the bytes accounted for.</span>
01252         <span class="comment">//</span>
01253 
01254         *ThisByteCount += CurrentByteCount;
01255 
01256         <span class="keywordflow">if</span> ((RemainingByteCount == 0) || (*RunCount == <a class="code" href="../../d3/d7/deviosup_8c.html#a2">MAX_PARALLEL_IOS</a>)) {
01257 
01258             <span class="keywordflow">break</span>;
01259         }
01260 
01261         <span class="comment">//</span>
01262         <span class="comment">//  Update our pointers for the user's buffer.</span>
01263         <span class="comment">//</span>
01264 
01265         ThisIoRun = IoRuns + *RunCount;
01266         CurrentUserBuffer = <a class="code" href="../../d2/d7/notify_8c.html#a7">Add2Ptr</a>( CurrentUserBuffer, CurrentByteCount, PVOID );
01267         CurrentUserBufferOffset += CurrentByteCount;
01268         CurrentFileOffset += CurrentByteCount;
01269     }
01270 
01271     <span class="keywordflow">return</span> FoundUnaligned;
01272 }
01273 
01274 
01275 <span class="comment">//</span>
01276 <span class="comment">//  Local support routine</span>
01277 <span class="comment">//</span>
01278 
01279 BOOLEAN
<a name="l01280"></a><a class="code" href="../../d3/d7/deviosup_8c.html#a6">01280</a> <a class="code" href="../../d3/d7/deviosup_8c.html#a6">UdfFinishBuffers</a> (
01281     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
01282     IN PIO_RUN IoRuns,
01283     IN ULONG RunCount,
01284     IN BOOLEAN FinalCleanup
01285     )
01286 
01287 <span class="comment">/*++</span>
01288 <span class="comment"></span>
01289 <span class="comment">Routine Description:</span>
01290 <span class="comment"></span>
01291 <span class="comment">    This routine is called to perform any data transferred required for</span>
01292 <span class="comment">    unaligned Io or to perform the final cleanup of the IoRuns array.</span>
01293 <span class="comment"></span>
01294 <span class="comment">    In all cases this is where we will deallocate any buffer and mdl</span>
01295 <span class="comment">    allocated to perform the unaligned transfer.  If this is not the</span>
01296 <span class="comment">    final cleanup then we also transfer the bytes to the user buffer</span>
01297 <span class="comment">    and flush the hardware cache.</span>
01298 <span class="comment"></span>
01299 <span class="comment">    We walk backwards through the run array because we may be shifting data</span>
01300 <span class="comment">    in the user's buffer.  Typical case is where we allocated a buffer for</span>
01301 <span class="comment">    the first part of a read and then used the user's buffer for the</span>
01302 <span class="comment">    next section (but stored it at the beginning of the buffer.</span>
01303 <span class="comment"></span>
01304 <span class="comment">Arguments:</span>
01305 <span class="comment"></span>
01306 <span class="comment">    IoRuns - Pointer to the IoRuns array.</span>
01307 <span class="comment"></span>
01308 <span class="comment">    RunCount - Number of entries in the IoRuns array filled here.</span>
01309 <span class="comment"></span>
01310 <span class="comment">    FinalCleanup - Indicates if we should be deallocating temporary buffers</span>
01311 <span class="comment">        (TRUE) or transferring bytes for a unaligned transfers and</span>
01312 <span class="comment">        deallocating the buffers (FALSE).  Flush the system cache if</span>
01313 <span class="comment">        transferring data.</span>
01314 <span class="comment"></span>
01315 <span class="comment">Return Value:</span>
01316 <span class="comment"></span>
01317 <span class="comment">    BOOLEAN - TRUE if this request needs the Io buffers to be flushed, FALSE otherwise.</span>
01318 <span class="comment"></span>
01319 <span class="comment">--*/</span>
01320 
01321 {
01322     BOOLEAN FlushIoBuffers = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01323 
01324     ULONG RemainingEntries = RunCount;
01325     <a class="code" href="../../d3/d7/deviosup_8c.html#a4">PIO_RUN</a> ThisIoRun = &amp;IoRuns[RunCount - 1];
01326 
01327     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01328 
01329     <span class="comment">//</span>
01330     <span class="comment">//  Walk through each entry in the IoRun array.</span>
01331     <span class="comment">//</span>
01332 
01333     <span class="keywordflow">while</span> (RemainingEntries != 0) {
01334 
01335         <span class="comment">//</span>
01336         <span class="comment">//  We only need to deal with the case of an unaligned transfer.</span>
01337         <span class="comment">//</span>
01338 
01339         <span class="keywordflow">if</span> (ThisIoRun-&gt;<a class="code" href="../../d0/d5/struct__IO__RUN.html#o4">TransferByteCount</a> != 0) {
01340 
01341             <span class="comment">//</span>
01342             <span class="comment">//  If not the final cleanup then transfer the data to the</span>
01343             <span class="comment">//  user's buffer and remember that we will need to flush</span>
01344             <span class="comment">//  the user's buffer to memory.</span>
01345             <span class="comment">//</span>
01346 
01347             <span class="keywordflow">if</span> (!FinalCleanup) {
01348 
01349                 <span class="comment">//</span>
01350                 <span class="comment">//  If we are shifting in the user's buffer then use</span>
01351                 <span class="comment">//  MoveMemory.</span>
01352                 <span class="comment">//</span>
01353 
01354                 <span class="keywordflow">if</span> (ThisIoRun-&gt;<a class="code" href="../../d0/d5/struct__IO__RUN.html#o6">TransferMdl</a> == IrpContext-&gt;Irp-&gt;MdlAddress) {
01355 
01356                     RtlMoveMemory( ThisIoRun-&gt;<a class="code" href="../../d0/d5/struct__IO__RUN.html#o2">UserBuffer</a>,
01357                                    <a class="code" href="../../d2/d7/notify_8c.html#a7">Add2Ptr</a>( ThisIoRun-&gt;<a class="code" href="../../d0/d5/struct__IO__RUN.html#o3">TransferBuffer</a>,
01358                                             ThisIoRun-&gt;<a class="code" href="../../d0/d5/struct__IO__RUN.html#o5">TransferBufferOffset</a>,
01359                                             PVOID ),
01360                                    ThisIoRun-&gt;<a class="code" href="../../d0/d5/struct__IO__RUN.html#o4">TransferByteCount</a> );
01361 
01362                 } <span class="keywordflow">else</span> {
01363 
01364                     RtlCopyMemory( ThisIoRun-&gt;<a class="code" href="../../d0/d5/struct__IO__RUN.html#o2">UserBuffer</a>,
01365                                    <a class="code" href="../../d2/d7/notify_8c.html#a7">Add2Ptr</a>( ThisIoRun-&gt;<a class="code" href="../../d0/d5/struct__IO__RUN.html#o3">TransferBuffer</a>,
01366                                             ThisIoRun-&gt;<a class="code" href="../../d0/d5/struct__IO__RUN.html#o5">TransferBufferOffset</a>,
01367                                             PVOID ),
01368                                    ThisIoRun-&gt;<a class="code" href="../../d0/d5/struct__IO__RUN.html#o4">TransferByteCount</a> );
01369                 }
01370 
01371                 FlushIoBuffers = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01372             }
01373 
01374             <span class="comment">//</span>
01375             <span class="comment">//  Free any Mdl we may have allocated.  If the Mdl isn't</span>
01376             <span class="comment">//  present then we must have failed during the allocation</span>
01377             <span class="comment">//  phase.</span>
01378             <span class="comment">//</span>
01379 
01380             <span class="keywordflow">if</span> (ThisIoRun-&gt;<a class="code" href="../../d0/d5/struct__IO__RUN.html#o6">TransferMdl</a> != IrpContext-&gt;Irp-&gt;MdlAddress) {
01381 
01382                 <span class="keywordflow">if</span> (ThisIoRun-&gt;<a class="code" href="../../d0/d5/struct__IO__RUN.html#o6">TransferMdl</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01383 
01384                     <a class="code" href="../../d4/d6/iosubs_8c.html#a65">IoFreeMdl</a>( ThisIoRun-&gt;<a class="code" href="../../d0/d5/struct__IO__RUN.html#o6">TransferMdl</a> );
01385                 }
01386 
01387                 <span class="comment">//</span>
01388                 <span class="comment">//  Now free any buffer we may have allocated.  If the Mdl</span>
01389                 <span class="comment">//  doesn't match the original Mdl then free the buffer.</span>
01390                 <span class="comment">//</span>
01391 
01392                 <span class="keywordflow">if</span> (ThisIoRun-&gt;<a class="code" href="../../d0/d5/struct__IO__RUN.html#o3">TransferBuffer</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01393 
01394                     <a class="code" href="../../d3/d8/udfprocs_8h.html#a124">UdfFreePool</a>( &amp;ThisIoRun-&gt;<a class="code" href="../../d0/d5/struct__IO__RUN.html#o3">TransferBuffer</a> );
01395                 }
01396             }
01397         }
01398 
01399         <span class="comment">//</span>
01400         <span class="comment">//  Now handle the case where we failed in the process</span>
01401         <span class="comment">//  of allocating associated Irps and Mdls.</span>
01402         <span class="comment">//</span>
01403 
01404         <span class="keywordflow">if</span> (ThisIoRun-&gt;<a class="code" href="../../d0/d5/struct__IO__RUN.html#o8">SavedIrp</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01405 
01406             <span class="keywordflow">if</span> (ThisIoRun-&gt;<a class="code" href="../../d0/d5/struct__IO__RUN.html#o8">SavedIrp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o2">MdlAddress</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01407 
01408                 <a class="code" href="../../d4/d6/iosubs_8c.html#a65">IoFreeMdl</a>( ThisIoRun-&gt;<a class="code" href="../../d0/d5/struct__IO__RUN.html#o8">SavedIrp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o2">MdlAddress</a> );
01409             }
01410 
01411             <a class="code" href="../../d4/d6/iosubs_8c.html#a63">IoFreeIrp</a>( ThisIoRun-&gt;<a class="code" href="../../d0/d5/struct__IO__RUN.html#o8">SavedIrp</a> );
01412         }
01413 
01414         <span class="comment">//</span>
01415         <span class="comment">//  Move to the previous IoRun entry.</span>
01416         <span class="comment">//</span>
01417 
01418         ThisIoRun -= 1;
01419         RemainingEntries -= 1;
01420     }
01421 
01422     <span class="comment">//</span>
01423     <span class="comment">//  If we copied any data then flush the Io buffers.</span>
01424     <span class="comment">//</span>
01425 
01426     <span class="keywordflow">return</span> FlushIoBuffers;
01427 }
01428 
01429 
01430 <span class="comment">//</span>
01431 <span class="comment">//  Local support routine</span>
01432 <span class="comment">//</span>
01433 
01434 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01435"></a><a class="code" href="../../d3/d7/deviosup_8c.html#a7">01435</a> <a class="code" href="../../d3/d7/deviosup_8c.html#a7">UdfMultipleAsync</a> (
01436     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
01437     IN ULONG RunCount,
01438     IN PIO_RUN IoRuns
01439     )
01440 
01441 <span class="comment">/*++</span>
01442 <span class="comment"></span>
01443 <span class="comment">Routine Description:</span>
01444 <span class="comment"></span>
01445 <span class="comment">    This routine first does the initial setup required of a Master IRP that is</span>
01446 <span class="comment">    going to be completed using associated IRPs.  This routine should not</span>
01447 <span class="comment">    be used if only one async request is needed, instead the single read</span>
01448 <span class="comment">    async routines should be called.</span>
01449 <span class="comment"></span>
01450 <span class="comment">    A context parameter is initialized, to serve as a communications area</span>
01451 <span class="comment">    between here and the common completion routine.</span>
01452 <span class="comment"></span>
01453 <span class="comment">    Next this routine reads or writes one or more contiguous sectors from</span>
01454 <span class="comment">    a device asynchronously, and is used if there are multiple reads for a</span>
01455 <span class="comment">    master IRP.  A completion routine is used to synchronize with the</span>
01456 <span class="comment">    completion of all of the I/O requests started by calls to this routine.</span>
01457 <span class="comment"></span>
01458 <span class="comment">    Also, prior to calling this routine the caller must initialize the</span>
01459 <span class="comment">    IoStatus field in the Context, with the correct success status and byte</span>
01460 <span class="comment">    count which are expected if all of the parallel transfers complete</span>
01461 <span class="comment">    successfully.  After return this status will be unchanged if all requests</span>
01462 <span class="comment">    were, in fact, successful.  However, if one or more errors occur, the</span>
01463 <span class="comment">    IoStatus will be modified to reflect the error status and byte count</span>
01464 <span class="comment">    from the first run (by Vbo) which encountered an error.  I/O status</span>
01465 <span class="comment">    from all subsequent runs will not be indicated.</span>
01466 <span class="comment"></span>
01467 <span class="comment">Arguments:</span>
01468 <span class="comment"></span>
01469 <span class="comment">    RunCount - Supplies the number of multiple async requests</span>
01470 <span class="comment">        that will be issued against the master irp.</span>
01471 <span class="comment"></span>
01472 <span class="comment">    IoRuns - Supplies an array containing the Offset and ByteCount for the</span>
01473 <span class="comment">        separate requests.</span>
01474 <span class="comment"></span>
01475 <span class="comment">Return Value:</span>
01476 <span class="comment"></span>
01477 <span class="comment">    None.</span>
01478 <span class="comment"></span>
01479 <span class="comment">--*/</span>
01480 
01481 {
01482     <a class="code" href="../../d0/d5/io_8h.html#a357">PIO_COMPLETION_ROUTINE</a> CompletionRoutine;
01483     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> IrpSp;
01484     <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> Mdl;
01485     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>;
01486     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> MasterIrp;
01487     ULONG UnwindRunCount;
01488 
01489     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01490 
01491     <span class="comment">//</span>
01492     <span class="comment">//  Set up things according to whether this is truely async.</span>
01493     <span class="comment">//</span>
01494 
01495     CompletionRoutine = <a class="code" href="../../d3/d7/deviosup_8c.html#a10">UdfMultiSyncCompletionRoutine</a>;
01496 
01497     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( IrpContext-&gt;Flags, <a class="code" href="../../d6/d8/udfstruc_8h.html#a30">IRP_CONTEXT_FLAG_WAIT</a> )) {
01498 
01499         CompletionRoutine = <a class="code" href="../../d3/d7/deviosup_8c.html#a11">UdfMultiAsyncCompletionRoutine</a>;
01500     }
01501 
01502     <span class="comment">//</span>
01503     <span class="comment">//  Initialize some local variables.</span>
01504     <span class="comment">//</span>
01505 
01506     MasterIrp = IrpContext-&gt;Irp;
01507 
01508     <span class="comment">//</span>
01509     <span class="comment">//  Itterate through the runs, doing everything that can fail.</span>
01510     <span class="comment">//  We let the cleanup in CdFinishBuffers clean up on error.</span>
01511     <span class="comment">//</span>
01512 
01513     <span class="keywordflow">for</span> (UnwindRunCount = 0;
01514          UnwindRunCount &lt; RunCount;
01515          UnwindRunCount += 1) {
01516 
01517         <span class="comment">//</span>
01518         <span class="comment">//  Create an associated IRP, making sure there is one stack entry for</span>
01519         <span class="comment">//  us, as well.</span>
01520         <span class="comment">//</span>
01521 
01522         IoRuns[UnwindRunCount].SavedIrp =
01523         <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> = <a class="code" href="../../d4/d6/iosubs_8c.html#a87">IoMakeAssociatedIrp</a>( MasterIrp, (CCHAR)(IrpContext-&gt;Vcb-&gt;TargetDeviceObject-&gt;StackSize + 1) );
01524 
01525         <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01526 
01527             IrpContext-&gt;Irp-&gt;IoStatus.Information = 0;
01528             <a class="code" href="../../d3/d8/udfprocs_8h.html#a122">UdfRaiseStatus</a>( IrpContext, STATUS_INSUFFICIENT_RESOURCES );
01529         }
01530 
01531         <span class="comment">//</span>
01532         <span class="comment">// Allocate and build a partial Mdl for the request.</span>
01533         <span class="comment">//</span>
01534 
01535         Mdl = <a class="code" href="../../d4/d6/iosubs_8c.html#a19">IoAllocateMdl</a>( IoRuns[UnwindRunCount].TransferVirtualAddress,
01536                              IoRuns[UnwindRunCount].DiskByteCount,
01537                              <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
01538                              <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
01539                              <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
01540 
01541         <span class="keywordflow">if</span> (Mdl == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01542 
01543             IrpContext-&gt;Irp-&gt;IoStatus.Information = 0;
01544             <a class="code" href="../../d3/d8/udfprocs_8h.html#a122">UdfRaiseStatus</a>( IrpContext, STATUS_INSUFFICIENT_RESOURCES );
01545         }
01546 
01547         <a class="code" href="../../d4/d6/iosubs_8c.html#a26">IoBuildPartialMdl</a>( IoRuns[UnwindRunCount].TransferMdl,
01548                            Mdl,
01549                            IoRuns[UnwindRunCount].TransferVirtualAddress,
01550                            IoRuns[UnwindRunCount].DiskByteCount );
01551 
01552         <span class="comment">//</span>
01553         <span class="comment">//  Get the first IRP stack location in the associated Irp</span>
01554         <span class="comment">//</span>
01555 
01556         <a class="code" href="../../d0/d5/io_8h.html#a238">IoSetNextIrpStackLocation</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
01557         IrpSp = <a class="code" href="../../d0/d5/io_8h.html#a228">IoGetCurrentIrpStackLocation</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
01558 
01559         <span class="comment">//</span>
01560         <span class="comment">//  Setup the Stack location to describe our read.</span>
01561         <span class="comment">//</span>
01562 
01563         IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a> = <a class="code" href="../../d0/d5/io_8h.html#a16">IRP_MJ_READ</a>;
01564         IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.Read.Length = IoRuns[UnwindRunCount].DiskByteCount;
01565         IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.Read.ByteOffset.QuadPart = IoRuns[UnwindRunCount].DiskOffset;
01566 
01567         <span class="comment">//</span>
01568         <span class="comment">// Set up the completion routine address in our stack frame.</span>
01569         <span class="comment">//</span>
01570 
01571         <a class="code" href="../../d0/d5/io_8h.html#a237">IoSetCompletionRoutine</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>,
01572                                 CompletionRoutine,
01573                                 IrpContext-&gt;IoContext,
01574                                 <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
01575                                 <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
01576                                 <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
01577 
01578         <span class="comment">//</span>
01579         <span class="comment">//  Setup the next IRP stack location in the associated Irp for the disk</span>
01580         <span class="comment">//  driver beneath us.</span>
01581         <span class="comment">//</span>
01582 
01583         IrpSp = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
01584 
01585         <span class="comment">//</span>
01586         <span class="comment">//  Setup the Stack location to do a read from the disk driver.</span>
01587         <span class="comment">//</span>
01588 
01589         IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a> = <a class="code" href="../../d0/d5/io_8h.html#a16">IRP_MJ_READ</a>;
01590         IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.Read.Length = IoRuns[UnwindRunCount].DiskByteCount;
01591         IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.Read.ByteOffset.QuadPart = IoRuns[UnwindRunCount].DiskOffset;
01592     }
01593 
01594     <span class="comment">//</span>
01595     <span class="comment">//  We only need to set the associated IRP count in the master irp to</span>
01596     <span class="comment">//  make it a master IRP.  But we set the count to one more than our</span>
01597     <span class="comment">//  caller requested, because we do not want the I/O system to complete</span>
01598     <span class="comment">//  the I/O.  We also set our own count.</span>
01599     <span class="comment">//</span>
01600 
01601     IrpContext-&gt;IoContext-&gt;IrpCount = RunCount;
01602     IrpContext-&gt;IoContext-&gt;MasterIrp = MasterIrp;
01603 
01604     <span class="comment">//</span>
01605     <span class="comment">//  We set the count in the master Irp to 1 since typically we</span>
01606     <span class="comment">//  will clean up the associated irps ourselves.  Setting this to one</span>
01607     <span class="comment">//  means completing the last associated Irp with SUCCESS (in the async</span>
01608     <span class="comment">//  case) will complete the master irp.</span>
01609     <span class="comment">//</span>
01610 
01611     MasterIrp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.IrpCount = 1;
01612 
01613     <span class="comment">//</span>
01614     <span class="comment">//  Now that all the dangerous work is done, issue the Io requests</span>
01615     <span class="comment">//</span>
01616 
01617     <span class="keywordflow">for</span> (UnwindRunCount = 0;
01618          UnwindRunCount &lt; RunCount;
01619          UnwindRunCount++) {
01620 
01621         <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> = IoRuns[UnwindRunCount].SavedIrp;
01622         IoRuns[UnwindRunCount].SavedIrp = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01623 
01624         <span class="comment">//</span>
01625         <span class="comment">//  If IoCallDriver returns an error, it has completed the Irp</span>
01626         <span class="comment">//  and the error will be caught by our completion routines</span>
01627         <span class="comment">//  and dealt with as a normal IO error.</span>
01628         <span class="comment">//</span>
01629 
01630         (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>( IrpContext-&gt;Vcb-&gt;TargetDeviceObject, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
01631     }
01632 
01633     <span class="keywordflow">return</span>;
01634 }
01635 
01636 
01637 <span class="comment">//</span>
01638 <span class="comment">//  Local support routine</span>
01639 <span class="comment">//</span>
01640 
01641 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01642"></a><a class="code" href="../../d3/d7/deviosup_8c.html#a8">01642</a> <a class="code" href="../../d3/d7/deviosup_8c.html#a8">UdfSingleAsync</a> (
01643     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
01644     IN LONGLONG ByteOffset,
01645     IN ULONG ByteCount
01646     )
01647 
01648 <span class="comment">/*++</span>
01649 <span class="comment"></span>
01650 <span class="comment">Routine Description:</span>
01651 <span class="comment"></span>
01652 <span class="comment">    This routine reads one or more contiguous sectors from a device</span>
01653 <span class="comment">    asynchronously, and is used if there is only one read necessary to</span>
01654 <span class="comment">    complete the IRP.  It implements the read by simply filling</span>
01655 <span class="comment">    in the next stack frame in the Irp, and passing it on.  The transfer</span>
01656 <span class="comment">    occurs to the single buffer originally specified in the user request.</span>
01657 <span class="comment"></span>
01658 <span class="comment">Arguments:</span>
01659 <span class="comment"></span>
01660 <span class="comment">    ByteOffset - Supplies the starting Logical Byte Offset to begin reading from</span>
01661 <span class="comment"></span>
01662 <span class="comment">    ByteCount - Supplies the number of bytes to read from the device</span>
01663 <span class="comment"></span>
01664 <span class="comment">Return Value:</span>
01665 <span class="comment"></span>
01666 <span class="comment">    None.</span>
01667 <span class="comment"></span>
01668 <span class="comment">--*/</span>
01669 
01670 {
01671     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> IrpSp;
01672     <a class="code" href="../../d0/d5/io_8h.html#a357">PIO_COMPLETION_ROUTINE</a> CompletionRoutine;
01673 
01674     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01675 
01676     <span class="comment">//</span>
01677     <span class="comment">//  Set up things according to whether this is truely async.</span>
01678     <span class="comment">//</span>
01679 
01680     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( IrpContext-&gt;Flags, <a class="code" href="../../d6/d8/udfstruc_8h.html#a30">IRP_CONTEXT_FLAG_WAIT</a> )) {
01681 
01682         CompletionRoutine = <a class="code" href="../../d3/d7/deviosup_8c.html#a12">UdfSingleSyncCompletionRoutine</a>;
01683 
01684     } <span class="keywordflow">else</span> {
01685 
01686         CompletionRoutine = <a class="code" href="../../d3/d7/deviosup_8c.html#a13">UdfSingleAsyncCompletionRoutine</a>;
01687     }
01688 
01689     <span class="comment">//</span>
01690     <span class="comment">// Set up the completion routine address in our stack frame.</span>
01691     <span class="comment">//</span>
01692 
01693     <a class="code" href="../../d0/d5/io_8h.html#a237">IoSetCompletionRoutine</a>( IrpContext-&gt;Irp,
01694                             CompletionRoutine,
01695                             IrpContext-&gt;IoContext,
01696                             <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
01697                             <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
01698                             <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
01699 
01700     <span class="comment">//</span>
01701     <span class="comment">//  Setup the next IRP stack location in the associated Irp for the disk</span>
01702     <span class="comment">//  driver beneath us.</span>
01703     <span class="comment">//</span>
01704 
01705     IrpSp = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>( IrpContext-&gt;Irp );
01706 
01707     <span class="comment">//</span>
01708     <span class="comment">//  Setup the Stack location to do a read from the disk driver.</span>
01709     <span class="comment">//</span>
01710 
01711     IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a> = <a class="code" href="../../d0/d5/io_8h.html#a16">IRP_MJ_READ</a>;
01712     IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.Read.Length = ByteCount;
01713     IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.Read.ByteOffset.QuadPart = ByteOffset;
01714 
01715     <span class="comment">//</span>
01716     <span class="comment">//  Issue the Io request</span>
01717     <span class="comment">//</span>
01718 
01719     <span class="comment">//</span>
01720     <span class="comment">//  If IoCallDriver returns an error, it has completed the Irp</span>
01721     <span class="comment">//  and the error will be caught by our completion routines</span>
01722     <span class="comment">//  and dealt with as a normal IO error.</span>
01723     <span class="comment">//</span>
01724 
01725     (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>)<a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>( IrpContext-&gt;Vcb-&gt;TargetDeviceObject, IrpContext-&gt;Irp );
01726 
01727     <span class="comment">//</span>
01728     <span class="comment">//  And return to our caller</span>
01729     <span class="comment">//</span>
01730 
01731     <span class="keywordflow">return</span>;
01732 }
01733 
01734 
01735 <span class="comment">//</span>
01736 <span class="comment">//  Local support routine</span>
01737 <span class="comment">//</span>
01738 
01739 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01740"></a><a class="code" href="../../d3/d7/deviosup_8c.html#a9">01740</a> <a class="code" href="../../d3/d7/deviosup_8c.html#a9">UdfWaitSync</a> (
01741     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext
01742     )
01743 
01744 <span class="comment">/*++</span>
01745 <span class="comment"></span>
01746 <span class="comment">Routine Description:</span>
01747 <span class="comment"></span>
01748 <span class="comment">    This routine waits for one or more previously started I/O requests</span>
01749 <span class="comment">    from the above routines, by simply waiting on the event.</span>
01750 <span class="comment"></span>
01751 <span class="comment">Arguments:</span>
01752 <span class="comment"></span>
01753 <span class="comment">Return Value:</span>
01754 <span class="comment"></span>
01755 <span class="comment">    None</span>
01756 <span class="comment"></span>
01757 <span class="comment">--*/</span>
01758 
01759 {
01760     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01761 
01762     <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;IrpContext-&gt;IoContext-&gt;SyncEvent,
01763                            <a class="code" href="../../d6/d7/halmips_8h.html#a455">Executive</a>,
01764                            <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
01765                            <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
01766                            <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
01767 
01768     <a class="code" href="../../d4/d9/ke_8h.html#a21">KeClearEvent</a>( &amp;IrpContext-&gt;IoContext-&gt;SyncEvent );
01769 
01770     <span class="keywordflow">return</span>;
01771 }
01772 
01773 
01774 <span class="comment">//</span>
01775 <span class="comment">//  Local support routine</span>
01776 <span class="comment">//</span>
01777 
01778 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l01779"></a><a class="code" href="../../d3/d7/deviosup_8c.html#a10">01779</a> <a class="code" href="../../d3/d7/deviosup_8c.html#a10">UdfMultiSyncCompletionRoutine</a> (
01780     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject,
01781     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp,
01782     IN PVOID Context
01783     )
01784 
01785 <span class="comment">/*++</span>
01786 <span class="comment"></span>
01787 <span class="comment">Routine Description:</span>
01788 <span class="comment"></span>
01789 <span class="comment">    This is the completion routine for all synchronous reads</span>
01790 <span class="comment">    started via UdfMultipleAsync.</span>
01791 <span class="comment"></span>
01792 <span class="comment">    The completion routine has has the following responsibilities:</span>
01793 <span class="comment"></span>
01794 <span class="comment">        If the individual request was completed with an error, then</span>
01795 <span class="comment">        this completion routine must see if this is the first error</span>
01796 <span class="comment">        and remember the error status in the Context.</span>
01797 <span class="comment"></span>
01798 <span class="comment">        If the IrpCount goes to 1, then it sets the event in the Context</span>
01799 <span class="comment">        parameter to signal the caller that all of the asynch requests</span>
01800 <span class="comment">        are done.</span>
01801 <span class="comment"></span>
01802 <span class="comment">Arguments:</span>
01803 <span class="comment"></span>
01804 <span class="comment">    DeviceObject - Pointer to the file system device object.</span>
01805 <span class="comment"></span>
01806 <span class="comment">    Irp - Pointer to the associated Irp which is being completed.  (This</span>
01807 <span class="comment">        Irp will no longer be accessible after this routine returns.)</span>
01808 <span class="comment"></span>
01809 <span class="comment">    Context - The context parameter which was specified for all of</span>
01810 <span class="comment">        the multiple asynch I/O requests for this MasterIrp.</span>
01811 <span class="comment"></span>
01812 <span class="comment">Return Value:</span>
01813 <span class="comment"></span>
01814 <span class="comment">    The routine returns STATUS_MORE_PROCESSING_REQUIRED so that we can</span>
01815 <span class="comment">    immediately complete the Master Irp without being in a race condition</span>
01816 <span class="comment">    with the IoCompleteRequest thread trying to decrement the IrpCount in</span>
01817 <span class="comment">    the Master Irp.</span>
01818 <span class="comment"></span>
01819 <span class="comment">--*/</span>
01820 
01821 {
01822     <a class="code" href="../../d3/d3/struct__UDF__IO__CONTEXT.html">PUDF_IO_CONTEXT</a> IoContext = Context;
01823 
01824     <span class="comment">//</span>
01825     <span class="comment">//  If we got an error (or verify required), remember it in the Irp</span>
01826     <span class="comment">//</span>
01827 
01828     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status )) {
01829 
01830         InterlockedExchange( &amp;IoContext-&gt;<a class="code" href="../../d3/d3/struct__UDF__IO__CONTEXT.html#o2">Status</a>, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status );
01831         IoContext-&gt;<a class="code" href="../../d3/d3/struct__UDF__IO__CONTEXT.html#o1">MasterIrp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Information = 0;
01832     }
01833 
01834     <span class="comment">//</span>
01835     <span class="comment">//  We must do this here since IoCompleteRequest won't get a chance</span>
01836     <span class="comment">//  on this associated Irp.</span>
01837     <span class="comment">//</span>
01838 
01839     <a class="code" href="../../d4/d6/iosubs_8c.html#a65">IoFreeMdl</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o2">MdlAddress</a> );
01840     <a class="code" href="../../d4/d6/iosubs_8c.html#a63">IoFreeIrp</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
01841 
01842     <span class="keywordflow">if</span> (InterlockedDecrement( &amp;IoContext-&gt;<a class="code" href="../../d3/d3/struct__UDF__IO__CONTEXT.html#o0">IrpCount</a> ) == 0) {
01843 
01844         <span class="comment">//</span>
01845         <span class="comment">//  Update the Master Irp with any error status from the associated Irps.</span>
01846         <span class="comment">//</span>
01847 
01848         IoContext-&gt;<a class="code" href="../../d3/d3/struct__UDF__IO__CONTEXT.html#o1">MasterIrp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status = IoContext-&gt;<a class="code" href="../../d3/d3/struct__UDF__IO__CONTEXT.html#o2">Status</a>;
01849         <a class="code" href="../../d2/d8/eventobj_8c.html#a8">KeSetEvent</a>( &amp;IoContext-&gt;<a class="code" href="../../d3/d3/struct__UDF__IO__CONTEXT.html#o7">SyncEvent</a>, 0, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
01850     }
01851 
01852     UNREFERENCED_PARAMETER( DeviceObject );
01853 
01854     <span class="keywordflow">return</span> STATUS_MORE_PROCESSING_REQUIRED;
01855 }
01856 
01857 
01858 <span class="comment">//</span>
01859 <span class="comment">//  Local support routine</span>
01860 <span class="comment">//</span>
01861 
01862 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l01863"></a><a class="code" href="../../d3/d7/deviosup_8c.html#a11">01863</a> <a class="code" href="../../d3/d7/deviosup_8c.html#a11">UdfMultiAsyncCompletionRoutine</a> (
01864     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject,
01865     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp,
01866     IN PVOID Context
01867     )
01868 
01869 <span class="comment">/*++</span>
01870 <span class="comment"></span>
01871 <span class="comment">Routine Description:</span>
01872 <span class="comment"></span>
01873 <span class="comment">    This is the completion routine for all asynchronous reads</span>
01874 <span class="comment">    started via UdfMultipleAsync.</span>
01875 <span class="comment"></span>
01876 <span class="comment">    The completion routine has has the following responsibilities:</span>
01877 <span class="comment"></span>
01878 <span class="comment">        If the individual request was completed with an error, then</span>
01879 <span class="comment">        this completion routine must see if this is the first error</span>
01880 <span class="comment">        and remember the error status in the Context.</span>
01881 <span class="comment"></span>
01882 <span class="comment">Arguments:</span>
01883 <span class="comment"></span>
01884 <span class="comment">    DeviceObject - Pointer to the file system device object.</span>
01885 <span class="comment"></span>
01886 <span class="comment">    Irp - Pointer to the associated Irp which is being completed.  (This</span>
01887 <span class="comment">        Irp will no longer be accessible after this routine returns.)</span>
01888 <span class="comment"></span>
01889 <span class="comment">    Context - The context parameter which was specified for all of</span>
01890 <span class="comment">             the multiple asynch I/O requests for this MasterIrp.</span>
01891 <span class="comment"></span>
01892 <span class="comment">Return Value:</span>
01893 <span class="comment"></span>
01894 <span class="comment">    Currently always returns STATUS_SUCCESS.</span>
01895 <span class="comment"></span>
01896 <span class="comment">--*/</span>
01897 
01898 {
01899     <a class="code" href="../../d3/d3/struct__UDF__IO__CONTEXT.html">PUDF_IO_CONTEXT</a> IoContext = Context;
01900     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> IrpSp = <a class="code" href="../../d0/d5/io_8h.html#a228">IoGetCurrentIrpStackLocation</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
01901 
01902     <span class="comment">//</span>
01903     <span class="comment">//  If we got an error (or verify required), remember it in the Irp</span>
01904     <span class="comment">//</span>
01905 
01906     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status )) {
01907 
01908         InterlockedExchange( &amp;IoContext-&gt;<a class="code" href="../../d3/d3/struct__UDF__IO__CONTEXT.html#o2">Status</a>, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status );
01909     }
01910 
01911     <span class="comment">//</span>
01912     <span class="comment">//  Decrement IrpCount and see if it goes to zero.</span>
01913     <span class="comment">//</span>
01914 
01915     <span class="keywordflow">if</span> (InterlockedDecrement( &amp;IoContext-&gt;<a class="code" href="../../d3/d3/struct__UDF__IO__CONTEXT.html#o0">IrpCount</a> ) == 0) {
01916 
01917         <span class="comment">//</span>
01918         <span class="comment">//  Mark the master Irp pending</span>
01919         <span class="comment">//</span>
01920 
01921         <a class="code" href="../../d0/d5/io_8h.html#a234">IoMarkIrpPending</a>( IoContext-&gt;<a class="code" href="../../d3/d3/struct__UDF__IO__CONTEXT.html#o1">MasterIrp</a> );
01922 
01923         <span class="comment">//</span>
01924         <span class="comment">//  Update the Master Irp with any error status from the associated Irps.</span>
01925         <span class="comment">//</span>
01926 
01927         IoContext-&gt;<a class="code" href="../../d3/d3/struct__UDF__IO__CONTEXT.html#o1">MasterIrp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status = IoContext-&gt;<a class="code" href="../../d3/d3/struct__UDF__IO__CONTEXT.html#o2">Status</a>;
01928 
01929         <span class="comment">//</span>
01930         <span class="comment">//  Update the information field with the correct value.</span>
01931         <span class="comment">//</span>
01932 
01933         IoContext-&gt;<a class="code" href="../../d3/d3/struct__UDF__IO__CONTEXT.html#o1">MasterIrp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Information = 0;
01934 
01935         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( IoContext-&gt;<a class="code" href="../../d3/d3/struct__UDF__IO__CONTEXT.html#o1">MasterIrp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status )) {
01936 
01937             IoContext-&gt;<a class="code" href="../../d3/d3/struct__UDF__IO__CONTEXT.html#o1">MasterIrp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Information = IoContext-&gt;<a class="code" href="../../d3/d3/struct__UDF__IO__CONTEXT.html#o6">RequestedByteCount</a>;
01938         }
01939 
01940         <span class="comment">//</span>
01941         <span class="comment">//  Now release the resource</span>
01942         <span class="comment">//</span>
01943 
01944         <a class="code" href="../../d5/d8/ex_8h.html#a71">ExReleaseResourceForThread</a>( IoContext-&gt;<a class="code" href="../../d3/d3/struct__UDF__IO__CONTEXT.html#o4">Resource</a>,
01945                                     IoContext-&gt;<a class="code" href="../../d3/d3/struct__UDF__IO__CONTEXT.html#o5">ResourceThreadId</a> );
01946 
01947         <span class="comment">//</span>
01948         <span class="comment">//  and finally, free the context record.</span>
01949         <span class="comment">//</span>
01950 
01951         <a class="code" href="../../d3/d8/udfprocs_8h.html#a95">UdfFreeIoContext</a>( IoContext );
01952 
01953         <span class="comment">//</span>
01954         <span class="comment">//  Return success in this case.</span>
01955         <span class="comment">//</span>
01956 
01957         <span class="keywordflow">return</span> STATUS_SUCCESS;
01958 
01959     } <span class="keywordflow">else</span> {
01960 
01961         <span class="comment">//</span>
01962         <span class="comment">//  We need to cleanup the associated Irp and its Mdl.</span>
01963         <span class="comment">//</span>
01964 
01965         <a class="code" href="../../d4/d6/iosubs_8c.html#a65">IoFreeMdl</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o2">MdlAddress</a> );
01966         <a class="code" href="../../d4/d6/iosubs_8c.html#a63">IoFreeIrp</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
01967 
01968         <span class="keywordflow">return</span> STATUS_MORE_PROCESSING_REQUIRED;
01969     }
01970 
01971     UNREFERENCED_PARAMETER( DeviceObject );
01972 }
01973 
01974 
01975 <span class="comment">//</span>
01976 <span class="comment">//  Local support routine</span>
01977 <span class="comment">//</span>
01978 
01979 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l01980"></a><a class="code" href="../../d3/d7/deviosup_8c.html#a12">01980</a> <a class="code" href="../../d3/d7/deviosup_8c.html#a12">UdfSingleSyncCompletionRoutine</a> (
01981     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject,
01982     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp,
01983     IN PVOID Context
01984     )
01985 
01986 <span class="comment">/*++</span>
01987 <span class="comment"></span>
01988 <span class="comment">Routine Description:</span>
01989 <span class="comment"></span>
01990 <span class="comment">    This is the completion routine for all reads started via UdfSingleAsync.</span>
01991 <span class="comment"></span>
01992 <span class="comment">    The completion routine has has the following responsibilities:</span>
01993 <span class="comment"></span>
01994 <span class="comment">        It sets the event in the Context parameter to signal the caller</span>
01995 <span class="comment">        that all of the asynch requests are done.</span>
01996 <span class="comment"></span>
01997 <span class="comment">Arguments:</span>
01998 <span class="comment"></span>
01999 <span class="comment">    DeviceObject - Pointer to the file system device object.</span>
02000 <span class="comment"></span>
02001 <span class="comment">    Irp - Pointer to the Irp for this request.  (This Irp will no longer</span>
02002 <span class="comment">        be accessible after this routine returns.)</span>
02003 <span class="comment"></span>
02004 <span class="comment">    Context - The context parameter which was specified in the call to</span>
02005 <span class="comment">        UdfSingleAsynch.</span>
02006 <span class="comment"></span>
02007 <span class="comment">Return Value:</span>
02008 <span class="comment"></span>
02009 <span class="comment">    The routine returns STATUS_MORE_PROCESSING_REQUIRED so that we can</span>
02010 <span class="comment">    immediately complete the Master Irp without being in a race condition</span>
02011 <span class="comment">    with the IoCompleteRequest thread trying to decrement the IrpCount in</span>
02012 <span class="comment">    the Master Irp.</span>
02013 <span class="comment"></span>
02014 <span class="comment">--*/</span>
02015 
02016 {
02017     <span class="comment">//</span>
02018     <span class="comment">//  Store the correct information field into the Irp.</span>
02019     <span class="comment">//</span>
02020 
02021     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status )) {
02022 
02023         <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Information = 0;
02024     }
02025 
02026     <a class="code" href="../../d2/d8/eventobj_8c.html#a8">KeSetEvent</a>( &amp;((<a class="code" href="../../d3/d3/struct__UDF__IO__CONTEXT.html">PUDF_IO_CONTEXT</a>)Context)-&gt;SyncEvent, 0, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
02027 
02028     <span class="keywordflow">return</span> STATUS_MORE_PROCESSING_REQUIRED;
02029 
02030     UNREFERENCED_PARAMETER( DeviceObject );
02031 }
02032 
02033 
02034 <span class="comment">//</span>
02035 <span class="comment">//  Local support routine</span>
02036 <span class="comment">//</span>
02037 
02038 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l02039"></a><a class="code" href="../../d3/d7/deviosup_8c.html#a13">02039</a> <a class="code" href="../../d3/d7/deviosup_8c.html#a13">UdfSingleAsyncCompletionRoutine</a> (
02040     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject,
02041     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp,
02042     IN PVOID Context
02043     )
02044 
02045 <span class="comment">/*++</span>
02046 <span class="comment"></span>
02047 <span class="comment">Routine Description:</span>
02048 <span class="comment"></span>
02049 <span class="comment">    This is the completion routine for all asynchronous reads</span>
02050 <span class="comment">    started via UdfSingleAsynch.</span>
02051 <span class="comment"></span>
02052 <span class="comment">Arguments:</span>
02053 <span class="comment"></span>
02054 <span class="comment">    DeviceObject - Pointer to the file system device object.</span>
02055 <span class="comment"></span>
02056 <span class="comment">    Irp - Pointer to the Irp for this request.  (This Irp will no longer</span>
02057 <span class="comment">        be accessible after this routine returns.)</span>
02058 <span class="comment"></span>
02059 <span class="comment">    Context - The context parameter which was specified in the call to</span>
02060 <span class="comment">        UdfSingleAsynch.</span>
02061 <span class="comment"></span>
02062 <span class="comment">Return Value:</span>
02063 <span class="comment"></span>
02064 <span class="comment">    Currently always returns STATUS_SUCCESS.</span>
02065 <span class="comment"></span>
02066 <span class="comment">--*/</span>
02067 
02068 {
02069     <span class="comment">//</span>
02070     <span class="comment">//  Update the information field with the correct value for bytes read.</span>
02071     <span class="comment">//</span>
02072 
02073     <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Information = 0;
02074 
02075     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status )) {
02076 
02077         <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Information = ((<a class="code" href="../../d3/d3/struct__UDF__IO__CONTEXT.html">PUDF_IO_CONTEXT</a>) Context)-&gt;RequestedByteCount;
02078     }
02079 
02080     <span class="comment">//</span>
02081     <span class="comment">//  Mark the Irp pending</span>
02082     <span class="comment">//</span>
02083 
02084     <a class="code" href="../../d0/d5/io_8h.html#a234">IoMarkIrpPending</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
02085 
02086     <span class="comment">//</span>
02087     <span class="comment">//  Now release the resource</span>
02088     <span class="comment">//</span>
02089 
02090     <a class="code" href="../../d5/d8/ex_8h.html#a71">ExReleaseResourceForThread</a>( ((<a class="code" href="../../d3/d3/struct__UDF__IO__CONTEXT.html">PUDF_IO_CONTEXT</a>) Context)-&gt;<a class="code" href="../../d4/d0/tex_8c.html#a21">Resource</a>,
02091                                 ((<a class="code" href="../../d3/d3/struct__UDF__IO__CONTEXT.html">PUDF_IO_CONTEXT</a>) Context)-&gt;ResourceThreadId );
02092 
02093     <span class="comment">//</span>
02094     <span class="comment">//  and finally, free the context record.</span>
02095     <span class="comment">//</span>
02096 
02097     <a class="code" href="../../d3/d8/udfprocs_8h.html#a95">UdfFreeIoContext</a>( (<a class="code" href="../../d3/d3/struct__UDF__IO__CONTEXT.html">PUDF_IO_CONTEXT</a>) Context );
02098     <span class="keywordflow">return</span> STATUS_SUCCESS;
02099 
02100     UNREFERENCED_PARAMETER( DeviceObject );
02101 }
02102 
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:39:40 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
