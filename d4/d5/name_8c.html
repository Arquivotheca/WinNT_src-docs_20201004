<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: name.c File Reference</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>name.c File Reference</h1><code>#include "FsRtlP.h"</code><br>

<p>
<a href="../../d5/d4/name_8c-source.html">Go to the source code of this file.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d5/name_8c.html#a0">Dbg</a>&nbsp;&nbsp;&nbsp;(0x10000000)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d5/name_8c.html#a1">DavePrint</a>&nbsp;&nbsp;&nbsp;NOTHING</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d5/name_8c.html#a2">MODULE_POOL_TAG</a>&nbsp;&nbsp;&nbsp;('nrSF')</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d5/name_8c.html#a3">MATCHES_ARRAY_SIZE</a>&nbsp;&nbsp;&nbsp;16</td></tr>

<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d5/name_8c.html#a4">FsRtlIsNameInExpressionPrivate</a> (IN PUNICODE_STRING Expression, IN PUNICODE_STRING <a class="el" href="../../d9/d3/rules_8c.html#a6">Name</a>, IN BOOLEAN IgnoreCase, IN PWCH UpcaseTable)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d5/name_8c.html#a5">FsRtlDissectName</a> (IN UNICODE_STRING Path, OUT PUNICODE_STRING FirstName, OUT PUNICODE_STRING RemainingName)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d5/name_8c.html#a6">FsRtlDoesNameContainWildCards</a> (IN PUNICODE_STRING <a class="el" href="../../d9/d3/rules_8c.html#a6">Name</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d5/name_8c.html#a7">FsRtlAreNamesEqual</a> (PCUNICODE_STRING ConstantNameA, PCUNICODE_STRING ConstantNameB, IN BOOLEAN IgnoreCase, IN PCWCH UpcaseTable OPTIONAL)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d5/name_8c.html#a8">FsRtlIsNameInExpression</a> (IN PUNICODE_STRING Expression, IN PUNICODE_STRING <a class="el" href="../../d9/d3/rules_8c.html#a6">Name</a>, IN BOOLEAN IgnoreCase, IN PWCH UpcaseTable OPTIONAL)</td></tr>

</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="a1" doxytag="name.c::DavePrint" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define DavePrint&nbsp;&nbsp;&nbsp;NOTHING          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d4/name_8c-source.html#l00060">60</a> of file <a class="el" href="../../d5/d4/name_8c-source.html">name.c</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a0" doxytag="name.c::Dbg" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define Dbg&nbsp;&nbsp;&nbsp;(0x10000000)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d4/name_8c-source.html#l00047">47</a> of file <a class="el" href="../../d5/d4/name_8c-source.html">name.c</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="name.c::MATCHES_ARRAY_SIZE" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define MATCHES_ARRAY_SIZE&nbsp;&nbsp;&nbsp;16          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d4/name_8c-source.html#l00475">475</a> of file <a class="el" href="../../d5/d4/name_8c-source.html">name.c</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a2" doxytag="name.c::MODULE_POOL_TAG" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define MODULE_POOL_TAG&nbsp;&nbsp;&nbsp;('nrSF')          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d4/name_8c-source.html#l00069">69</a> of file <a class="el" href="../../d5/d4/name_8c-source.html">name.c</a>.    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a7" doxytag="name.c::FsRtlAreNamesEqual" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> BOOLEAN FsRtlAreNamesEqual           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">PCUNICODE_STRING&nbsp;</td>
          <td class="mdname" nowrap> <em>ConstantNameA</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>PCUNICODE_STRING&nbsp;</td>
          <td class="mdname" nowrap> <em>ConstantNameB</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN BOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>IgnoreCase</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PCWCH UpcaseTable&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d4/name_8c-source.html#l00288">288</a> of file <a class="el" href="../../d5/d4/name_8c-source.html">name.c</a>.
<p>
References <a class="el" href="../../d1/d3/ex_2alpha_2raisests_8c-source.html#l00157">ExRaiseStatus()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d2/d9/cmchek_8c-source.html#l00095">Index</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>, <a class="el" href="../../d7/d5/nls_8c-source.html#l01215">RtlFreeUnicodeString()</a>, <a class="el" href="../../d7/d5/nls_8c-source.html#l01038">RtlUpcaseUnicodeString()</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, and <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>.
<p>
<pre class="fragment"><div>00297                    :
00298 
00299     This routine simple returns whether <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> two names are exactly equal.
00300     If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> two names are known to be constant, <span class="keyword">this</span> routine <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> much
00301     faster than <a class="code" href="../../d4/d5/name_8c.html#a8">FsRtlIsNameInExpression</a>.
00302 
00303 Arguments:
00304 
00305     ConstantNameA - Constant name.
00306 
00307     ConstantNameB - Constant name.
00308 
00309     IgnoreCase - <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Names should be Upcased before comparing.
00310 
00311     UpcaseTable - If supplied, use <span class="keyword">this</span> table <span class="keywordflow">for</span> <span class="keywordflow">case</span> insensitive compares,
00312         otherwise, use <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <span class="keywordflow">default</span> system <a class="code" href="../../d7/d6/nlsboot_8c.html#a0">upcase</a> table.
00313 
00314 Return Value:
00315 
00316     BOOLEAN - <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> two names are lexically equal.
00317 
00318 --*/
00319 
00320 {
00321     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
00322     ULONG NameLength;
00323     BOOLEAN FreeStrings = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00324 
00325     UNICODE_STRING LocalNameA;
00326     UNICODE_STRING LocalNameB;
00327 
00328     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00329 
00330     <span class="comment">//</span>
00331     <span class="comment">// If the names aren't even the same size, then return FALSE right away.</span>
00332     <span class="comment">//</span>
00333 
00334     <span class="keywordflow">if</span> ( ConstantNameA-&gt;Length != ConstantNameB-&gt;Length ) {
00335 
00336         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00337     }
00338 
00339     NameLength = ConstantNameA-&gt;Length / <span class="keyword">sizeof</span>(WCHAR);
00340 
00341     <span class="comment">//</span>
00342     <span class="comment">//  If we weren't given an upcase table, we have to upcase the names</span>
00343     <span class="comment">//  ourselves.</span>
00344     <span class="comment">//</span>
00345 
00346     <span class="keywordflow">if</span> ( IgnoreCase &amp;&amp; !ARGUMENT_PRESENT(UpcaseTable) ) {
00347 
00348         <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00349 
00350         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d6/d6/nls_8c.html#a31">RtlUpcaseUnicodeString</a>( &amp;LocalNameA, ConstantNameA, TRUE );
00351 
00352         <span class="keywordflow">if</span> ( !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(Status) ) {
00353 
00354             <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( Status );
00355         }
00356 
00357         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d6/d6/nls_8c.html#a31">RtlUpcaseUnicodeString</a>( &amp;LocalNameB, ConstantNameB, TRUE );
00358 
00359         <span class="keywordflow">if</span> ( !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(Status) ) {
00360 
00361             <a class="code" href="../../d6/d6/nls_8c.html#a34">RtlFreeUnicodeString</a>( &amp;LocalNameA );
00362 
00363             <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( Status );
00364         }
00365 
00366         ConstantNameA = &amp;LocalNameA;
00367         ConstantNameB = &amp;LocalNameB;
00368 
00369         IgnoreCase = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00370         FreeStrings = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00371     }
00372 
00373     <span class="comment">//</span>
00374     <span class="comment">//  Do either case sensitive or insensitive compare.</span>
00375     <span class="comment">//</span>
00376 
00377     <span class="keywordflow">if</span> ( !IgnoreCase ) {
00378 
00379         BOOLEAN BytesEqual;
00380 
00381         BytesEqual = (BOOLEAN) RtlEqualMemory( ConstantNameA-&gt;Buffer,
00382                                                ConstantNameB-&gt;Buffer,
00383                                                ConstantNameA-&gt;Length );
00384 
00385         <span class="keywordflow">if</span> ( FreeStrings ) {
00386 
00387             <a class="code" href="../../d6/d6/nls_8c.html#a34">RtlFreeUnicodeString</a>( &amp;LocalNameA );
00388             <a class="code" href="../../d6/d6/nls_8c.html#a34">RtlFreeUnicodeString</a>( &amp;LocalNameB );
00389         }
00390 
00391         <span class="keywordflow">return</span> BytesEqual;
00392 
00393     } <span class="keywordflow">else</span> {
00394 
00395         <span class="keywordflow">for</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = 0; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &lt; NameLength; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> += 1) {
00396 
00397             <span class="keywordflow">if</span> ( UpcaseTable[ConstantNameA-&gt;Buffer[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>]] !=
00398                  UpcaseTable[ConstantNameB-&gt;Buffer[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>]] ) {
00399 
00400                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00401             }
00402         }
00403 
00404         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00405     }
00406 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="name.c::FsRtlDissectName" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID FsRtlDissectName           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN UNICODE_STRING&nbsp;</td>
          <td class="mdname" nowrap> <em>Path</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PUNICODE_STRING&nbsp;</td>
          <td class="mdname" nowrap> <em>FirstName</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PUNICODE_STRING&nbsp;</td>
          <td class="mdname" nowrap> <em>RemainingName</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d4/name_8c-source.html#l00093">93</a> of file <a class="el" href="../../d5/d4/name_8c-source.html">name.c</a>.
<p>
References <a class="el" href="../../d3/d9/aw_8h-source.html#l00031">L</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>, and <a class="el" href="../../d5/d4/aug98_2dll32_2icc__i386_8h-source.html#l00064">USHORT</a>.
<p>
<pre class="fragment"><div>00101                    :
00102 
00103     This routine cracks a <a class="code" href="../../d3/d3/dumpuser_8c.html#a14">path</a>.  It picks off <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> first element in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
00104     given <a class="code" href="../../d3/d3/dumpuser_8c.html#a14">path</a> name and provides both <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> and <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> remaining part.  <a class="code" href="../../d2/d1/bench_8h.html#a5">A</a> <a class="code" href="../../d3/d3/dumpuser_8c.html#a14">path</a>
00105     <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> a set of <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> names separated by backslashes.  If a name begins
00106     with a backslash, <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> FirstName <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> string immediately following
00107     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> backslash.  Here are some examples:
00108 
00109         Path           FirstName    RemainingName
00110         ----           ---------    -------------
00111         empty          empty        empty
00112 
00113         \              empty        empty
00114 
00115         <a class="code" href="../../d2/d1/bench_8h.html#a5">A</a>              <a class="code" href="../../d2/d1/bench_8h.html#a5">A</a>            empty
00116 
00117         \<a class="code" href="../../d2/d1/bench_8h.html#a5">A</a>             <a class="code" href="../../d2/d1/bench_8h.html#a5">A</a>            empty
00118 
00119         <a class="code" href="../../d2/d1/bench_8h.html#a5">A</a>\B\C\<a class="code" href="../../d2/d0/imemenu_8c.html#a0">D</a>\E      <a class="code" href="../../d2/d1/bench_8h.html#a5">A</a>            B\C\<a class="code" href="../../d2/d0/imemenu_8c.html#a0">D</a>\E
00120 
00121         *<a class="code" href="../../d2/d1/bench_8h.html#a5">A</a>?            *<a class="code" href="../../d2/d1/bench_8h.html#a5">A</a>?          empty
00122 
00123 
00124     Note that both output strings use <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> same string buffer memory of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
00125     input string, and are not necessarily null terminated.
00126 
00127     Also, <span class="keyword">this</span> routine makes no judgement as to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> legality of each
00128     <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> name componant.  This must be done separatly when each <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> name
00129     <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> extracted.
00130 
00131 Arguments:
00132 
00133     Path - The full <a class="code" href="../../d3/d3/dumpuser_8c.html#a14">path</a> name to crack.
00134 
00135     FirstName - The first name in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d3/d3/dumpuser_8c.html#a14">path</a>.  Don'<a class="code" href="../../d4/d1/genmips_8c.html#a17">t</a> allocate a buffer <span class="keywordflow">for</span>
00136         <span class="keyword">this</span> string.
00137 
00138     RemainingName - The rest of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d3/d3/dumpuser_8c.html#a14">path</a>.  Don'<a class="code" href="../../d4/d1/genmips_8c.html#a17">t</a> allocate a buffer <span class="keywordflow">for</span> <span class="keyword">this</span>
00139         string.
00140 
00141 Return Value:
00142 
00143     None.
00144 
00145 --*/
00146 
00147 {
00148     ULONG i = 0;
00149     ULONG PathLength;
00150     ULONG FirstNameStart;
00151 
00152     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00153 
00154     <span class="comment">//</span>
00155     <span class="comment">//  Make both output strings empty for now</span>
00156     <span class="comment">//</span>
00157 
00158     FirstName-&gt;Length = 0;
00159     FirstName-&gt;MaximumLength = 0;
00160     FirstName-&gt;Buffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00161 
00162     RemainingName-&gt;Length = 0;
00163     RemainingName-&gt;MaximumLength = 0;
00164     RemainingName-&gt;Buffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00165 
00166     PathLength = Path.Length / <span class="keyword">sizeof</span>(WCHAR);
00167 
00168     <span class="comment">//</span>
00169     <span class="comment">//  Check for an empty input string</span>
00170     <span class="comment">//</span>
00171 
00172     <span class="keywordflow">if</span> (PathLength == 0) {
00173 
00174         <span class="keywordflow">return</span>;
00175     }
00176 
00177     <span class="comment">//</span>
00178     <span class="comment">//  Skip over a starting backslash, and make sure there is more.</span>
00179     <span class="comment">//</span>
00180 
00181     <span class="keywordflow">if</span> ( Path.Buffer[0] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span> ) {
00182 
00183         i = 1;
00184     }
00185 
00186     <span class="comment">//</span>
00187     <span class="comment">//  Now run down the input string until we hit a backslash or the end</span>
00188     <span class="comment">//  of the string, remembering where we started;</span>
00189     <span class="comment">//</span>
00190 
00191     <span class="keywordflow">for</span> ( FirstNameStart = i;
00192           (i &lt; PathLength) &amp;&amp; (Path.Buffer[i] != <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span>);
00193           i += 1 ) {
00194 
00195         NOTHING;
00196     }
00197 
00198     <span class="comment">//</span>
00199     <span class="comment">//  At this point all characters up to (but not including) i are</span>
00200     <span class="comment">//  in the first part.   So setup the first name</span>
00201     <span class="comment">//</span>
00202 
00203     FirstName-&gt;Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)((i - FirstNameStart) * <span class="keyword">sizeof</span>(WCHAR));
00204     FirstName-&gt;MaximumLength = FirstName-&gt;Length;
00205     FirstName-&gt;Buffer = &amp;Path.Buffer[FirstNameStart];
00206 
00207     <span class="comment">//</span>
00208     <span class="comment">//  Now the remaining part needs a string only if the first part didn't</span>
00209     <span class="comment">//  exhaust the entire input string.  We know that if anything is left</span>
00210     <span class="comment">//  that is must start with a backslash.  Note that if there is only</span>
00211     <span class="comment">//  a trailing backslash, the length will get correctly set to zero.</span>
00212     <span class="comment">//</span>
00213 
00214     <span class="keywordflow">if</span> (i &lt; PathLength) {
00215 
00216         RemainingName-&gt;Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)((PathLength - (i + 1)) * <span class="keyword">sizeof</span>(WCHAR));
00217         RemainingName-&gt;MaximumLength = RemainingName-&gt;Length;
00218         RemainingName-&gt;Buffer = &amp;Path.Buffer[i + 1];
00219     }
00220 
00221     <span class="comment">//</span>
00222     <span class="comment">//  And return to our caller</span>
00223     <span class="comment">//</span>
00224 
00225     <span class="keywordflow">return</span>;
00226 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="name.c::FsRtlDoesNameContainWildCards" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> BOOLEAN FsRtlDoesNameContainWildCards           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PUNICODE_STRING&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>Name</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d4/name_8c-source.html#l00229">229</a> of file <a class="el" href="../../d5/d4/name_8c-source.html">name.c</a>.
<p>
References <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d2/d7/fsrtl_8h-source.html#l01538">FsRtlIsUnicodeCharacterWild</a>, <a class="el" href="../../d3/d9/aw_8h-source.html#l00031">L</a>, <a class="el" href="../../d9/d9/geninst_8c-source.html#l00154">Name</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>, <a class="el" href="../../d5/d4/aug98_2dll32_2icc__i386_8h-source.html#l00085">PUSHORT</a>, and <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>.
<p>
Referenced by <a class="el" href="../../d5/d4/name_8c-source.html#l00482">FsRtlIsNameInExpressionPrivate()</a>, <a class="el" href="../../d2/d7/dirctrl_8c-source.html#l01003">UdfInitializeEnumeration()</a>, and <a class="el" href="../../d4/d7/udfs_2create_8c-source.html#l00809">UdfNormalizeFileNames()</a>.
<p>
<pre class="fragment"><div>00235                    :
00236 
00237     This routine simply scans <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> input <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a> string looking <span class="keywordflow">for</span> any Nt
00238     wild card characters.
00239 
00240 Arguments:
00241 
00242     <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a> - The string to check.
00243 
00244 Return Value:
00245 
00246     BOOLEAN - <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> <span class="keywordflow">if</span> one or more wild card characters was found.
00247 
00248 --*/
00249 {
00250     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a> p;
00251 
00252     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00253 
00254     <span class="comment">//</span>
00255     <span class="comment">//  Check each character in the name to see if it's a wildcard</span>
00256     <span class="comment">//  character.</span>
00257     <span class="comment">//</span>
00258 
00259     <span class="keywordflow">if</span>( <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length ) {
00260         <span class="keywordflow">for</span>( p = <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Buffer + (<a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length / <span class="keyword">sizeof</span>(WCHAR)) - 1;
00261              p &gt;= <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Buffer &amp;&amp; *p != <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span> ;
00262              p-- ) {
00263 
00264             <span class="comment">//</span>
00265             <span class="comment">//  check for a wild card character</span>
00266             <span class="comment">//</span>
00267 
00268             <span class="keywordflow">if</span> (<a class="code" href="../../d1/d8/fsrtl_8h.html#a45">FsRtlIsUnicodeCharacterWild</a>( *p )) {
00269 
00270                 <span class="comment">//</span>
00271                 <span class="comment">//  Tell caller that this name contains wild cards</span>
00272                 <span class="comment">//</span>
00273 
00274                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00275             }
00276         }
00277     }
00278 
00279     <span class="comment">//</span>
00280     <span class="comment">//  No wildcard characters were found, so return to our caller</span>
00281     <span class="comment">//</span>
00282 
00283     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00284 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a8" doxytag="name.c::FsRtlIsNameInExpression" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> BOOLEAN FsRtlIsNameInExpression           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PUNICODE_STRING&nbsp;</td>
          <td class="mdname" nowrap> <em>Expression</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PUNICODE_STRING&nbsp;</td>
          <td class="mdname" nowrap> <em>Name</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN BOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>IgnoreCase</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PWCH UpcaseTable&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d4/name_8c-source.html#l00415">415</a> of file <a class="el" href="../../d5/d4/name_8c-source.html">name.c</a>.
<p>
References <a class="el" href="../../d1/d3/ex_2alpha_2raisests_8c-source.html#l00157">ExRaiseStatus()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d5/d4/name_8c-source.html#l00482">FsRtlIsNameInExpressionPrivate()</a>, <a class="el" href="../../d9/d9/geninst_8c-source.html#l00154">Name</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d7/d5/nls_8c-source.html#l01215">RtlFreeUnicodeString()</a>, <a class="el" href="../../d7/d5/nls_8c-source.html#l01038">RtlUpcaseUnicodeString()</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, and <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>.
<p>
Referenced by <a class="el" href="../../d6/d4/namesup_8c-source.html#l01203">UdfIsNameInExpression()</a>.
<p>
<pre class="fragment"><div>00422 {
00423     BOOLEAN Result;
00424     UNICODE_STRING LocalName;
00425 
00426     <span class="comment">//</span>
00427     <span class="comment">//  If we weren't given an upcase table, we have to upcase the names</span>
00428     <span class="comment">//  ourselves.</span>
00429     <span class="comment">//</span>
00430 
00431     <span class="keywordflow">if</span> ( IgnoreCase &amp;&amp; !ARGUMENT_PRESENT(UpcaseTable) ) {
00432 
00433         <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00434 
00435         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d6/d6/nls_8c.html#a31">RtlUpcaseUnicodeString</a>( &amp;LocalName, Name, TRUE );
00436 
00437         <span class="keywordflow">if</span> ( !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(Status) ) {
00438 
00439             <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( Status );
00440         }
00441 
00442         <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a> = &amp;LocalName;
00443 
00444         IgnoreCase = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00445 
00446     } <span class="keywordflow">else</span> {
00447 
00448         LocalName.Buffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00449     }
00450 
00451     <span class="comment">//</span>
00452     <span class="comment">//  Now call the main routine, remembering to free the upcased string</span>
00453     <span class="comment">//  if we allocated one.</span>
00454     <span class="comment">//</span>
00455 
00456     <span class="keywordflow">try</span> {
00457 
00458         Result = <a class="code" href="../../d4/d5/name_8c.html#a4">FsRtlIsNameInExpressionPrivate</a>( Expression,
00459                                                  Name,
00460                                                  IgnoreCase,
00461                                                  UpcaseTable );
00462 
00463     } finally {
00464 
00465         <span class="keywordflow">if</span> (LocalName.Buffer != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00466 
00467             <a class="code" href="../../d6/d6/nls_8c.html#a34">RtlFreeUnicodeString</a>( &amp;LocalName );
00468         }
00469     }
00470 
00471     <span class="keywordflow">return</span> Result;
00472 }
</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="name.c::FsRtlIsNameInExpressionPrivate" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> BOOLEAN FsRtlIsNameInExpressionPrivate           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PUNICODE_STRING&nbsp;</td>
          <td class="mdname" nowrap> <em>Expression</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PUNICODE_STRING&nbsp;</td>
          <td class="mdname" nowrap> <em>Name</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN BOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>IgnoreCase</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PWCH&nbsp;</td>
          <td class="mdname" nowrap> <em>UpcaseTable</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d4/name_8c-source.html#l00482">482</a> of file <a class="el" href="../../d5/d4/name_8c-source.html">name.c</a>.
<p>
References <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d0/d5/cdfs__rec_8c-source.html#l00032">Dbg</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02290">DebugTrace</a>, <a class="el" href="../../d7/d2/cmwraper_8c-source.html#l00304">ExFreePool()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d5/d4/name_8c-source.html#l00229">FsRtlDoesNameContainWildCards()</a>, <a class="el" href="../../d4/d7/fsrtlp_8h-source.html#l00040">FsRtlpAllocatePool</a>, <a class="el" href="../../d3/d9/aw_8h-source.html#l00031">L</a>, <a class="el" href="../../d2/d2/dbcsname_8c-source.html#l00768">MATCHES_ARRAY_SIZE</a>, <a class="el" href="../../d9/d9/geninst_8c-source.html#l00154">Name</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l00033">Offset</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>, <a class="el" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, and <a class="el" href="../../d5/d4/aug98_2dll32_2icc__i386_8h-source.html#l00064">USHORT</a>.
<p>
Referenced by <a class="el" href="../../d5/d4/name_8c-source.html#l00415">FsRtlIsNameInExpression()</a>.
<p>
<pre class="fragment"><div>00491                    :
00492 
00493     This routine compares a Dbcs name and an expression and tells <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller
00494     <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> name <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> language defined by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> expression.  The input name
00495     cannot contain wildcards, <span class="keywordflow">while</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> expression may contain wildcards.
00496 
00497     Expression wild cards are evaluated as shown in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> nondeterministic
00498     finite automatons below.  Note that ~* and ~? are DOS_STAR and DOS_QM.
00499 
00500 
00501              ~* <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> DOS_STAR, ~? <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> DOS_QM, and ~. <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> DOS_DOT
00502 
00503 
00504                                        S
00505                                     &lt;-----&lt;
00506                                  X  |     |  e       Y
00507              X * Y ==       (0)-----&gt;-(1)-&gt;-----(2)-----(3)
00508 
00509 
00510                                       S-.
00511                                     &lt;-----&lt;
00512                                  X  |     |  e       Y
00513              X ~* Y ==      (0)-----&gt;-(1)-&gt;-----(2)-----(3)
00514 
00515 
00516 
00517                                 X     S     S     Y
00518              X ?? Y ==      (0)---(1)---(2)---(3)---(4)
00519 
00520 
00521 
00522                                 X     .        .      Y
00523              X ~.~. Y ==    (0)---(1)----(2)------(3)---(4)
00524                                    |      |________|
00525                                    |           ^   |
00526                                    |_______________|
00527                                       ^EOF or .^
00528 
00529 
00530                                 X     S-.     S-.     Y
00531              X ~?~? Y ==    (0)---(1)-----(2)-----(3)---(4)
00532                                    |      |________|
00533                                    |           ^   |
00534                                    |_______________|
00535                                       ^EOF or .^
00536 
00537 
00538 
00539          where S <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> any single character
00540 
00541                S-. <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> any single character except <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <span class="keyword">final</span> .
00542 
00543                e <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> a null character transition
00544 
00545                EOF <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> end of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> name string
00546 
00547     In words:
00548 
00549         * matches 0 or more characters.
00550 
00551         ? matches exactly 1 character.
00552 
00553         DOS_STAR matches 0 or more characters until encountering and <a class="code" href="../../d7/d1/genuedef_8c.html#a7">matching</a>
00554             <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <span class="keyword">final</span> . in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> name.
00555 
00556         DOS_QM matches any single character, or upon encountering a period or
00557             end of name string, advances <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> expression to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> end of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
00558             set of contiguous DOS_QMs.
00559 
00560         DOS_DOT matches either a . or zero characters beyond name string.
00561 
00562 Arguments:
00563 
00564     Expression - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> input expression to check against
00565         (Caller must already <a class="code" href="../../d7/d6/nlsboot_8c.html#a0">upcase</a> <span class="keywordflow">if</span> passing CaseInsensitive <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>.)
00566 
00567     <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a> - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> input name to check <span class="keywordflow">for</span>.
00568 
00569     CaseInsensitive - <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> <span class="keywordflow">if</span> <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a> should be Upcased before comparing.
00570 
00571 Return Value:
00572 
00573     BOOLEAN - <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> <span class="keywordflow">if</span> <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> an element in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> set of strings denoted
00574         by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> input Expression and <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> otherwise.
00575 
00576 --*/
00577 
00578 {
00579     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> NameOffset;
00580     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> ExprOffset;
00581 
00582     ULONG SrcCount;
00583     ULONG DestCount;
00584     ULONG PreviousDestCount;
00585     ULONG MatchesCount;
00586 
00587     WCHAR NameChar, ExprChar;
00588 
00589     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> LocalBuffer[<a class="code" href="../../d1/d3/dbcsname_8c.html#a4">MATCHES_ARRAY_SIZE</a> * 2];
00590 
00591     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> *AuxBuffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00592     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> *PreviousMatches;
00593     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> *CurrentMatches;
00594 
00595     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> MaxState;
00596     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> CurrentState;
00597 
00598     BOOLEAN NameFinished = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00599 
00600     <span class="comment">//</span>
00601     <span class="comment">//  The idea behind the algorithm is pretty simple.  We keep track of</span>
00602     <span class="comment">//  all possible locations in the regular expression that are matching</span>
00603     <span class="comment">//  the name.  If when the name has been exhausted one of the locations</span>
00604     <span class="comment">//  in the expression is also just exhausted, the name is in the language</span>
00605     <span class="comment">//  defined by the regular expression.</span>
00606     <span class="comment">//</span>
00607 
00608     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00609 
00610     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, Dbg, <span class="stringliteral">"FsRtlIsNameInExpression\n"</span>, 0);
00611     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, Dbg, <span class="stringliteral">" Expression      = %Z\n"</span>, Expression );
00612     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, Dbg, <span class="stringliteral">" Name            = %Z\n"</span>, Name );
00613     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, Dbg, <span class="stringliteral">" CaseInsensitive = %08lx\n"</span>, CaseInsensitive );
00614 
00615     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length != 0 );
00616     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( Expression-&gt;Length != 0 );
00617 
00618     <span class="comment">//</span>
00619     <span class="comment">//  If one string is empty return FALSE.  If both are empty return TRUE.</span>
00620     <span class="comment">//</span>
00621 
00622     <span class="keywordflow">if</span> ( (<a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length == 0) || (Expression-&gt;Length == 0) ) {
00623 
00624         <span class="keywordflow">return</span> (BOOLEAN)(!(<a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length + Expression-&gt;Length));
00625     }
00626 
00627     <span class="comment">//</span>
00628     <span class="comment">//  Special case by far the most common wild card search of *</span>
00629     <span class="comment">//</span>
00630 
00631     <span class="keywordflow">if</span> ((Expression-&gt;Length == 2) &amp;&amp; (Expression-&gt;Buffer[0] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'*'</span>)) {
00632 
00633         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00634     }
00635 
00636     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d1/d8/fsrtl_8h.html#a177">FsRtlDoesNameContainWildCards</a>( Expression ) );
00637 
00638     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( !IgnoreCase || ARGUMENT_PRESENT(UpcaseTable) );
00639 
00640     <span class="comment">//</span>
00641     <span class="comment">//  Also special case expressions of the form *X.  With this and the prior</span>
00642     <span class="comment">//  case we have covered virtually all normal queries.</span>
00643     <span class="comment">//</span>
00644 
00645     <span class="keywordflow">if</span> (Expression-&gt;Buffer[0] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'*'</span>) {
00646 
00647         UNICODE_STRING LocalExpression;
00648 
00649         LocalExpression = *Expression;
00650 
00651         LocalExpression.Buffer += 1;
00652         LocalExpression.Length -= 2;
00653 
00654         <span class="comment">//</span>
00655         <span class="comment">//  Only special case an expression with a single *</span>
00656         <span class="comment">//</span>
00657 
00658         <span class="keywordflow">if</span> ( !<a class="code" href="../../d1/d8/fsrtl_8h.html#a177">FsRtlDoesNameContainWildCards</a>( &amp;LocalExpression ) ) {
00659 
00660             ULONG StartingNameOffset;
00661 
00662             <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length &lt; (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(Expression-&gt;Length - <span class="keyword">sizeof</span>(WCHAR))) {
00663 
00664                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00665             }
00666 
00667             StartingNameOffset = ( <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length -
00668                                    LocalExpression.Length ) / <span class="keyword">sizeof</span>(WCHAR);
00669 
00670             <span class="comment">//</span>
00671             <span class="comment">//  Do a simple memory compare if case sensitive, otherwise</span>
00672             <span class="comment">//  we have got to check this one character at a time.</span>
00673             <span class="comment">//</span>
00674 
00675             <span class="keywordflow">if</span> ( !IgnoreCase ) {
00676 
00677                 <span class="keywordflow">return</span> (BOOLEAN) RtlEqualMemory( LocalExpression.Buffer,
00678                                                  <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Buffer + StartingNameOffset,
00679                                                  LocalExpression.Length );
00680 
00681             } <span class="keywordflow">else</span> {
00682 
00683                 <span class="keywordflow">for</span> ( ExprOffset = 0;
00684                       ExprOffset &lt; (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(LocalExpression.Length / <span class="keyword">sizeof</span>(WCHAR));
00685                       ExprOffset += 1 ) {
00686 
00687                     NameChar = <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Buffer[StartingNameOffset + ExprOffset];
00688                     NameChar = UpcaseTable[NameChar];
00689 
00690                     ExprChar = LocalExpression.Buffer[ExprOffset];
00691 
00692                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( ExprChar == UpcaseTable[ExprChar] );
00693 
00694                     <span class="keywordflow">if</span> ( NameChar != ExprChar ) {
00695 
00696                         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00697                     }
00698                 }
00699 
00700                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00701             }
00702         }
00703     }
00704 
00705     <span class="comment">//</span>
00706     <span class="comment">//  Walk through the name string, picking off characters.  We go one</span>
00707     <span class="comment">//  character beyond the end because some wild cards are able to match</span>
00708     <span class="comment">//  zero characters beyond the end of the string.</span>
00709     <span class="comment">//</span>
00710     <span class="comment">//  With each new name character we determine a new set of states that</span>
00711     <span class="comment">//  match the name so far.  We use two arrays that we swap back and forth</span>
00712     <span class="comment">//  for this purpose.  One array lists the possible expression states for</span>
00713     <span class="comment">//  all name characters up to but not including the current one, and other</span>
00714     <span class="comment">//  array is used to build up the list of states considering the current</span>
00715     <span class="comment">//  name character as well.  The arrays are then switched and the process</span>
00716     <span class="comment">//  repeated.</span>
00717     <span class="comment">//</span>
00718     <span class="comment">//  There is not a one-to-one correspondence between state number and</span>
00719     <span class="comment">//  offset into the expression.  This is evident from the NFAs in the</span>
00720     <span class="comment">//  initial comment to this function.  State numbering is not continuous.</span>
00721     <span class="comment">//  This allows a simple conversion between state number and expression</span>
00722     <span class="comment">//  offset.  Each character in the expression can represent one or two</span>
00723     <span class="comment">//  states.  * and DOS_STAR generate two states: ExprOffset*2 and</span>
00724     <span class="comment">//  ExprOffset*2 + 1.  All other expreesion characters can produce only</span>
00725     <span class="comment">//  a single state.  Thus ExprOffset = State/2.</span>
00726     <span class="comment">//</span>
00727     <span class="comment">//</span>
00728     <span class="comment">//  Here is a short description of the variables involved:</span>
00729     <span class="comment">//</span>
00730     <span class="comment">//  NameOffset  - The offset of the current name char being processed.</span>
00731     <span class="comment">//</span>
00732     <span class="comment">//  ExprOffset  - The offset of the current expression char being processed.</span>
00733     <span class="comment">//</span>
00734     <span class="comment">//  SrcCount    - Prior match being investigated with current name char</span>
00735     <span class="comment">//</span>
00736     <span class="comment">//  DestCount   - Next location to put a matching assuming current name char</span>
00737     <span class="comment">//</span>
00738     <span class="comment">//  NameFinished - Allows one more itteration through the Matches array</span>
00739     <span class="comment">//                 after the name is exhusted (to come *s for example)</span>
00740     <span class="comment">//</span>
00741     <span class="comment">//  PreviousDestCount - This is used to prevent entry duplication, see coment</span>
00742     <span class="comment">//</span>
00743     <span class="comment">//  PreviousMatches   - Holds the previous set of matches (the Src array)</span>
00744     <span class="comment">//</span>
00745     <span class="comment">//  CurrentMatches    - Holds the current set of matches (the Dest array)</span>
00746     <span class="comment">//</span>
00747     <span class="comment">//  AuxBuffer, LocalBuffer - the storage for the Matches arrays</span>
00748     <span class="comment">//</span>
00749 
00750     <span class="comment">//</span>
00751     <span class="comment">//  Set up the initial variables</span>
00752     <span class="comment">//</span>
00753 
00754     PreviousMatches = &amp;LocalBuffer[0];
00755     CurrentMatches = &amp;LocalBuffer[<a class="code" href="../../d1/d3/dbcsname_8c.html#a4">MATCHES_ARRAY_SIZE</a>];
00756 
00757     PreviousMatches[0] = 0;
00758     MatchesCount = 1;
00759 
00760     NameOffset = 0;
00761 
00762     MaxState = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(Expression-&gt;Length * 2);
00763 
00764     <span class="keywordflow">while</span> ( !NameFinished ) {
00765 
00766         <span class="keywordflow">if</span> ( NameOffset &lt; <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length ) {
00767 
00768             NameChar = <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Buffer[NameOffset / <span class="keyword">sizeof</span>(WCHAR)];
00769 
00770             NameOffset += <span class="keyword">sizeof</span>(WCHAR);;
00771 
00772         } <span class="keywordflow">else</span> {
00773 
00774             NameFinished = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00775 
00776             <span class="comment">//</span>
00777             <span class="comment">//  if we have already exhasted the expression, cool.  Don't</span>
00778             <span class="comment">//  continue.</span>
00779             <span class="comment">//</span>
00780 
00781             <span class="keywordflow">if</span> ( PreviousMatches[MatchesCount-1] == MaxState ) {
00782 
00783                 <span class="keywordflow">break</span>;
00784             }
00785         }
00786 
00787 
00788         <span class="comment">//</span>
00789         <span class="comment">//  Now, for each of the previous stored expression matches, see what</span>
00790         <span class="comment">//  we can do with this name character.</span>
00791         <span class="comment">//</span>
00792 
00793         SrcCount = 0;
00794         DestCount = 0;
00795         PreviousDestCount = 0;
00796 
00797         <span class="keywordflow">while</span> ( SrcCount &lt; MatchesCount ) {
00798 
00799             <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> Length;
00800 
00801             <span class="comment">//</span>
00802             <span class="comment">//  We have to carry on our expression analysis as far as possible</span>
00803             <span class="comment">//  for each character of name, so we loop here until the</span>
00804             <span class="comment">//  expression stops matching.  A clue here is that expression</span>
00805             <span class="comment">//  cases that can match zero or more characters end with a</span>
00806             <span class="comment">//  continue, while those that can accept only a single character</span>
00807             <span class="comment">//  end with a break.</span>
00808             <span class="comment">//</span>
00809 
00810             ExprOffset = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)((PreviousMatches[SrcCount++] + 1) / 2);
00811 
00812 
00813             Length = 0;
00814 
00815             <span class="keywordflow">while</span> ( <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> ) {
00816 
00817                 <span class="keywordflow">if</span> ( ExprOffset == Expression-&gt;Length ) {
00818 
00819                     <span class="keywordflow">break</span>;
00820                 }
00821 
00822                 <span class="comment">//</span>
00823                 <span class="comment">//  The first time through the loop we don't want</span>
00824                 <span class="comment">//  to increment ExprOffset.</span>
00825                 <span class="comment">//</span>
00826 
00827                 ExprOffset += Length;
00828                 Length = <span class="keyword">sizeof</span>(WCHAR);
00829 
00830                 CurrentState = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(ExprOffset * 2);
00831 
00832                 <span class="keywordflow">if</span> ( ExprOffset == Expression-&gt;Length ) {
00833 
00834                     CurrentMatches[DestCount++] = MaxState;
00835                     <span class="keywordflow">break</span>;
00836                 }
00837 
00838                 ExprChar = Expression-&gt;Buffer[ExprOffset / <span class="keyword">sizeof</span>(WCHAR)];
00839 
00840                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( !IgnoreCase || !((ExprChar &gt;= L<span class="charliteral">'a'</span>) &amp;&amp; (ExprChar &lt;= L<span class="charliteral">'z'</span>)) );
00841 
00842                 <span class="comment">//</span>
00843                 <span class="comment">//  Before we get started, we have to check for something</span>
00844                 <span class="comment">//  really gross.  We may be about to exhaust the local</span>
00845                 <span class="comment">//  space for ExpressionMatches[][], so we have to allocate</span>
00846                 <span class="comment">//  some pool if this is the case.  Yuk!</span>
00847                 <span class="comment">//</span>
00848 
00849                 <span class="keywordflow">if</span> ( (DestCount &gt;= <a class="code" href="../../d1/d3/dbcsname_8c.html#a4">MATCHES_ARRAY_SIZE</a> - 2) &amp;&amp;
00850                      (AuxBuffer == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) ) {
00851 
00852                     ULONG ExpressionChars;
00853 
00854                     ExpressionChars = Expression-&gt;Length / <span class="keyword">sizeof</span>(WCHAR);
00855 
00856                     AuxBuffer = <a class="code" href="../../d3/d8/fsrtlp_8h.html#a2">FsRtlpAllocatePool</a>( PagedPool,
00857                                                     (ExpressionChars+1) *
00858                                                     <span class="keyword">sizeof</span>(USHORT)*2*2 );
00859 
00860                     RtlCopyMemory( AuxBuffer,
00861                                    CurrentMatches,
00862                                    MATCHES_ARRAY_SIZE * <span class="keyword">sizeof</span>(USHORT) );
00863 
00864                     CurrentMatches = AuxBuffer;
00865 
00866                     RtlCopyMemory( AuxBuffer + (ExpressionChars+1)*2,
00867                                    PreviousMatches,
00868                                    MATCHES_ARRAY_SIZE * <span class="keyword">sizeof</span>(USHORT) );
00869 
00870                     PreviousMatches = AuxBuffer + (ExpressionChars+1)*2;
00871                 }
00872 
00873                 <span class="comment">//</span>
00874                 <span class="comment">//  * matches any character zero or more times.</span>
00875                 <span class="comment">//</span>
00876 
00877                 <span class="keywordflow">if</span> (ExprChar == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'*'</span>) {
00878 
00879                     CurrentMatches[DestCount++] = CurrentState;
00880                     CurrentMatches[DestCount++] = CurrentState + 3;
00881                     <span class="keywordflow">continue</span>;
00882                 }
00883 
00884                 <span class="comment">//</span>
00885                 <span class="comment">//  DOS_STAR matches any character except . zero or more times.</span>
00886                 <span class="comment">//</span>
00887 
00888                 <span class="keywordflow">if</span> (ExprChar == DOS_STAR) {
00889 
00890                     BOOLEAN ICanEatADot = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00891 
00892                     <span class="comment">//</span>
00893                     <span class="comment">//  If we are at a period, determine if we are allowed to</span>
00894                     <span class="comment">//  consume it, ie. make sure it is not the last one.</span>
00895                     <span class="comment">//</span>
00896 
00897                     <span class="keywordflow">if</span> ( !NameFinished &amp;&amp; (NameChar == <span class="charliteral">'.'</span>) ) {
00898 
00899                         <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>;
00900 
00901                         <span class="keywordflow">for</span> ( <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> = NameOffset;
00902                               <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> &lt; <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length;
00903                               <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> += Length ) {
00904 
00905                             <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Buffer[<a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> / <span class="keyword">sizeof</span>(WCHAR)] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'.'</span>) {
00906 
00907                                 ICanEatADot = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00908                                 <span class="keywordflow">break</span>;
00909                             }
00910                         }
00911                     }
00912 
00913                     <span class="keywordflow">if</span> (NameFinished || (NameChar != <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'.'</span>) || ICanEatADot) {
00914 
00915                         CurrentMatches[DestCount++] = CurrentState;
00916                         CurrentMatches[DestCount++] = CurrentState + 3;
00917                         <span class="keywordflow">continue</span>;
00918 
00919                     } <span class="keywordflow">else</span> {
00920 
00921                         <span class="comment">//</span>
00922                         <span class="comment">//  We are at a period.  We can only match zero</span>
00923                         <span class="comment">//  characters (ie. the epsilon transition).</span>
00924                         <span class="comment">//</span>
00925 
00926                         CurrentMatches[DestCount++] = CurrentState + 3;
00927                         <span class="keywordflow">continue</span>;
00928                     }
00929                 }
00930 
00931                 <span class="comment">//</span>
00932                 <span class="comment">//  The following expreesion characters all match by consuming</span>
00933                 <span class="comment">//  a character, thus force the expression, and thus state</span>
00934                 <span class="comment">//  forward.</span>
00935                 <span class="comment">//</span>
00936 
00937                 CurrentState += (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(<span class="keyword">sizeof</span>(WCHAR) * 2);
00938 
00939                 <span class="comment">//</span>
00940                 <span class="comment">//  DOS_QM is the most complicated.  If the name is finished,</span>
00941                 <span class="comment">//  we can match zero characters.  If this name is a '.', we</span>
00942                 <span class="comment">//  don't match, but look at the next expression.  Otherwise</span>
00943                 <span class="comment">//  we match a single character.</span>
00944                 <span class="comment">//</span>
00945 
00946                 <span class="keywordflow">if</span> ( ExprChar == DOS_QM ) {
00947 
00948                     <span class="keywordflow">if</span> ( NameFinished || (NameChar == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'.'</span>) ) {
00949 
00950                         <span class="keywordflow">continue</span>;
00951                     }
00952 
00953                     CurrentMatches[DestCount++] = CurrentState;
00954                     <span class="keywordflow">break</span>;
00955                 }
00956 
00957                 <span class="comment">//</span>
00958                 <span class="comment">//  A DOS_DOT can match either a period, or zero characters</span>
00959                 <span class="comment">//  beyond the end of name.</span>
00960                 <span class="comment">//</span>
00961 
00962                 <span class="keywordflow">if</span> (ExprChar == DOS_DOT) {
00963 
00964                     <span class="keywordflow">if</span> ( NameFinished ) {
00965 
00966                         <span class="keywordflow">continue</span>;
00967                     }
00968 
00969                     <span class="keywordflow">if</span> (NameChar == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'.'</span>) {
00970 
00971                         CurrentMatches[DestCount++] = CurrentState;
00972                         <span class="keywordflow">break</span>;
00973                     }
00974                 }
00975 
00976                 <span class="comment">//</span>
00977                 <span class="comment">//  From this point on a name character is required to even</span>
00978                 <span class="comment">//  continue, let alone make a match.</span>
00979                 <span class="comment">//</span>
00980 
00981                 <span class="keywordflow">if</span> ( NameFinished ) {
00982 
00983                     <span class="keywordflow">break</span>;
00984                 }
00985 
00986                 <span class="comment">//</span>
00987                 <span class="comment">//  If this expression was a '?' we can match it once.</span>
00988                 <span class="comment">//</span>
00989 
00990                 <span class="keywordflow">if</span> (ExprChar == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'?'</span>) {
00991 
00992                     CurrentMatches[DestCount++] = CurrentState;
00993                     <span class="keywordflow">break</span>;
00994                 }
00995 
00996                 <span class="comment">//</span>
00997                 <span class="comment">//  Finally, check if the expression char matches the name char</span>
00998                 <span class="comment">//</span>
00999 
01000                 <span class="keywordflow">if</span> (ExprChar == (WCHAR)(IgnoreCase ?
01001                                         UpcaseTable[NameChar] : NameChar)) {
01002 
01003                     CurrentMatches[DestCount++] = CurrentState;
01004                     <span class="keywordflow">break</span>;
01005                 }
01006 
01007                 <span class="comment">//</span>
01008                 <span class="comment">//  The expression didn't match so go look at the next</span>
01009                 <span class="comment">//  previous match.</span>
01010                 <span class="comment">//</span>
01011 
01012                 <span class="keywordflow">break</span>;
01013             }
01014 
01015 
01016             <span class="comment">//</span>
01017             <span class="comment">//  Prevent duplication in the destination array.</span>
01018             <span class="comment">//</span>
01019             <span class="comment">//  Each of the arrays is montonically increasing and non-</span>
01020             <span class="comment">//  duplicating, thus we skip over any source element in the src</span>
01021             <span class="comment">//  array if we just added the same element to the destination</span>
01022             <span class="comment">//  array.  This guarentees non-duplication in the dest. array.</span>
01023             <span class="comment">//</span>
01024 
01025             <span class="keywordflow">if</span> ((SrcCount &lt; MatchesCount) &amp;&amp;
01026                 (PreviousDestCount &lt; DestCount) ) {
01027 
01028                 <span class="keywordflow">while</span> (PreviousDestCount &lt; DestCount) {
01029 
01030                     <span class="keywordflow">while</span> ( PreviousMatches[SrcCount] &lt;
01031                          CurrentMatches[PreviousDestCount] ) {
01032 
01033                         SrcCount += 1;
01034                     }
01035 
01036                     PreviousDestCount += 1;
01037                 }
01038             }
01039         }
01040 
01041         <span class="comment">//</span>
01042         <span class="comment">//  If we found no matches in the just finished itteration, it's time</span>
01043         <span class="comment">//  to bail.</span>
01044         <span class="comment">//</span>
01045 
01046         <span class="keywordflow">if</span> ( DestCount == 0 ) {
01047 
01048             <span class="keywordflow">if</span> (AuxBuffer != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) { <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( AuxBuffer ); }
01049 
01050             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01051         }
01052 
01053         <span class="comment">//</span>
01054         <span class="comment">//  Swap the meaning the two arrays</span>
01055         <span class="comment">//</span>
01056 
01057         {
01058             <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> *Tmp;
01059 
01060             Tmp = PreviousMatches;
01061 
01062             PreviousMatches = CurrentMatches;
01063 
01064             CurrentMatches = Tmp;
01065         }
01066 
01067         MatchesCount = DestCount;
01068     }
01069 
01070 
01071     CurrentState = PreviousMatches[MatchesCount-1];
01072 
01073     <span class="keywordflow">if</span> (AuxBuffer != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) { <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( AuxBuffer ); }
01074 
01075 
01076     <span class="keywordflow">return</span> (BOOLEAN)(CurrentState == MaxState);
01077 }
}
</div></pre>    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:44:49 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
