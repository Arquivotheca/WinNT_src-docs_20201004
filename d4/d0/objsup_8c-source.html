<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: objsup.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>objsup.c</h1><a href="../../d3/d1/objsup_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1989-1993  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    objsup.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module contains the object support routine for the NT I/O system.</span>
00012 <span class="comment"></span>
00013 <span class="comment">Author:</span>
00014 <span class="comment"></span>
00015 <span class="comment">    Darryl E. Havens (darrylh) 30-May-1989</span>
00016 <span class="comment"></span>
00017 <span class="comment">Environment:</span>
00018 <span class="comment"></span>
00019 <span class="comment">    Kernel mode only</span>
00020 <span class="comment"></span>
00021 <span class="comment">Revision History:</span>
00022 <span class="comment"></span>
00023 <span class="comment"></span>
00024 <span class="comment">--*/</span>
00025 
00026 <span class="preprocessor">#include "<a class="code" href="../../d0/d6/iop_8h.html">iop.h</a>"</span>
00027 
00028 <span class="preprocessor">#ifdef ALLOC_PRAGMA</span>
00029 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IopCloseFile)</span>
00030 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IopDeleteDevice)</span>
00031 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IopDeleteDriver)</span>
00032 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IopGetSetSecurityObject)</span>
00033 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00034 <span class="preprocessor"></span>
00035 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00036"></a><a class="code" href="../../d3/d1/objsup_8c.html#a0">00036</a> <a class="code" href="../../d3/d1/objsup_8c.html#a0">IopCloseFile</a>(
00037     IN <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> Process OPTIONAL,
00038     IN PVOID Object,
00039     IN ULONG GrantedAccess,
00040     IN ULONG ProcessHandleCount,
00041     IN ULONG SystemHandleCount
00042     )
00043 
00044 <span class="comment">/*++</span>
00045 <span class="comment"></span>
00046 <span class="comment">Routine Description:</span>
00047 <span class="comment"></span>
00048 <span class="comment">    This routine is invoked whenever a handle to a file is deleted.  If the</span>
00049 <span class="comment">    handle being deleted is the last handle to the file (the ProcessHandleCount</span>
00050 <span class="comment">    parameter is one), then all locks for the file owned by the specified</span>
00051 <span class="comment">    process must be released.</span>
00052 <span class="comment"></span>
00053 <span class="comment">    Likewise, if the SystemHandleCount is one then this is the last handle</span>
00054 <span class="comment">    for this for file object across all processes.  For this case, the file</span>
00055 <span class="comment">    system is notified so that it can perform any necessary cleanup on the</span>
00056 <span class="comment">    file.</span>
00057 <span class="comment"></span>
00058 <span class="comment">Arguments:</span>
00059 <span class="comment"></span>
00060 <span class="comment">    Process - A pointer to the process that closed the handle.</span>
00061 <span class="comment"></span>
00062 <span class="comment">    Object - A pointer to the file object that the handle referenced.</span>
00063 <span class="comment"></span>
00064 <span class="comment">    GrantedAccess - Access that was granted to the object through the handle.</span>
00065 <span class="comment"></span>
00066 <span class="comment">    ProcessHandleCount - Count of handles outstanding to the object for the</span>
00067 <span class="comment">        process specified by the Process argument.  If the count is one</span>
00068 <span class="comment">        then this is the last handle to this file by that process.</span>
00069 <span class="comment"></span>
00070 <span class="comment">    SystemHandleCount - Count of handles outstanding to the object for the</span>
00071 <span class="comment">        entire system.  If the count is one then this is the last handle</span>
00072 <span class="comment">        to this file in the system.</span>
00073 <span class="comment"></span>
00074 <span class="comment">Return Value:</span>
00075 <span class="comment"></span>
00076 <span class="comment">    None.</span>
00077 <span class="comment"></span>
00078 <span class="comment">--*/</span>
00079 
00080 {
00081     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
00082     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpSp;
00083     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> deviceObject;
00084     <a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html">PFAST_IO_DISPATCH</a> fastIoDispatch;
00085     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
00086     <a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a> event;
00087     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> fileObject;
00088     KIRQL irql;
00089 
00090     UNREFERENCED_PARAMETER( Process );
00091     UNREFERENCED_PARAMETER( GrantedAccess );
00092 
00093     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00094 
00095     <span class="comment">//</span>
00096     <span class="comment">// If the handle count is not one then this is not the last close of</span>
00097     <span class="comment">// this file for the specified process so there is nothing to do.</span>
00098     <span class="comment">//</span>
00099 
00100     <span class="keywordflow">if</span> (ProcessHandleCount != 1) {
00101         <span class="keywordflow">return</span>;
00102     }
00103 
00104     fileObject = (<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>) Object;
00105 
00106     <span class="keywordflow">if</span> (fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o10">LockOperation</a> &amp;&amp; SystemHandleCount != 1) {
00107 
00108         IO_STATUS_BLOCK localIoStatus;
00109 
00110         <span class="comment">//</span>
00111         <span class="comment">// This is the last handle for the specified process and the process</span>
00112         <span class="comment">// called the NtLockFile or NtUnlockFile system services at least once.</span>
00113         <span class="comment">// Also, this is not the last handle for this file object system-wide</span>
00114         <span class="comment">// so unlock all of the pending locks for this process.  Note that</span>
00115         <span class="comment">// this check causes an optimization so that if this is the last</span>
00116         <span class="comment">// system-wide handle to this file object the cleanup code will take</span>
00117         <span class="comment">// care of releasing any locks on the file rather than having to</span>
00118         <span class="comment">// send the file system two different packets to get them shut down.</span>
00119 
00120         <span class="comment">//</span>
00121         <span class="comment">// Get the address of the target device object and the Fast I/O dispatch</span>
00122         <span class="comment">//</span>
00123 
00124         <span class="keywordflow">if</span> (!(fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a161">FO_DIRECT_DEVICE_OPEN</a>)) {
00125             deviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a76">IoGetRelatedDeviceObject</a>( fileObject );
00126         } <span class="keywordflow">else</span> {
00127             deviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a66">IoGetAttachedDevice</a>( fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o2">DeviceObject</a> );
00128         }
00129         fastIoDispatch = deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o3">DriverObject</a>-&gt;<a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html#o10">FastIoDispatch</a>;
00130 
00131         <span class="comment">//</span>
00132         <span class="comment">// If this file is open for synchronous I/O, wait until this thread</span>
00133         <span class="comment">// owns it exclusively since there may still be a thread using it.</span>
00134         <span class="comment">// This occurs when a system service owns the file because it owns</span>
00135         <span class="comment">// the semaphore, but the I/O completion code has already dereferenced</span>
00136         <span class="comment">// the file object itself.  Without waiting here for the same semaphore</span>
00137         <span class="comment">// there would be a race condition in the service who owns it now. The</span>
00138         <span class="comment">// service needs to be able to access the object w/o it going away after</span>
00139         <span class="comment">// its wait for the file event is satisfied.</span>
00140         <span class="comment">//</span>
00141 
00142         <span class="keywordflow">if</span> (fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a151">FO_SYNCHRONOUS_IO</a>) {
00143 
00144             BOOLEAN interrupted;
00145 
00146             <span class="keywordflow">if</span> (!<a class="code" href="../../d0/d6/iop_8h.html#a13">IopAcquireFastLock</a>( fileObject )) {
00147                 (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d0/d6/iop_8h.html#a147">IopAcquireFileObjectLock</a>( fileObject,
00148                                                  <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
00149                                                  <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00150                                                  &amp;interrupted );
00151             }
00152         }
00153 
00154         <span class="comment">//</span>
00155         <span class="comment">// Turbo unlock support.  If the fast Io Dispatch specifies a fast lock</span>
00156         <span class="comment">// routine then we'll first try and calling it with the specified lock</span>
00157         <span class="comment">// parameters.  If this is all successful then we do not need to do</span>
00158         <span class="comment">// the Irp based unlock all call.</span>
00159         <span class="comment">//</span>
00160 
00161         <span class="keywordflow">if</span> (fastIoDispatch &amp;&amp;
00162             fastIoDispatch-&gt;<a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html#o8">FastIoUnlockAll</a> &amp;&amp;
00163             fastIoDispatch-&gt;<a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html#o8">FastIoUnlockAll</a>( fileObject,
00164                                              <a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a>(),
00165                                              &amp;localIoStatus,
00166                                              deviceObject )) {
00167 
00168             NOTHING;
00169 
00170         } <span class="keywordflow">else</span> {
00171 
00172             <span class="comment">//</span>
00173             <span class="comment">// Initialize the local event that will be used to synchronize access</span>
00174             <span class="comment">// to the driver completing this I/O operation.</span>
00175             <span class="comment">//</span>
00176 
00177             <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( &amp;event, SynchronizationEvent, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00178 
00179             <span class="comment">//</span>
00180             <span class="comment">// Reset the event in the file object.</span>
00181             <span class="comment">//</span>
00182 
00183             <a class="code" href="../../d4/d9/ke_8h.html#a21">KeClearEvent</a>( &amp;fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o25">Event</a> );
00184 
00185             <span class="comment">//</span>
00186             <span class="comment">// Allocate and initialize the I/O Request Packet (IRP) for this</span>
00187             <span class="comment">// operation.</span>
00188             <span class="comment">//</span>
00189 
00190             irp = <a class="code" href="../../d0/d6/iop_8h.html#a149">IopAllocateIrpMustSucceed</a>( deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o13">StackSize</a> );
00191             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.OriginalFileObject = fileObject;
00192             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.Thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
00193             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o10">RequestorMode</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>;
00194 
00195             <span class="comment">//</span>
00196             <span class="comment">// Fill in the service independent parameters in the IRP.</span>
00197             <span class="comment">//</span>
00198 
00199             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o19">UserEvent</a> = &amp;event;
00200             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o18">UserIosb</a> = &amp;irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>;
00201             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> = <a class="code" href="../../d0/d5/io_8h.html#a176">IRP_SYNCHRONOUS_API</a>;
00202             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o24">Overlay</a>.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00203 
00204             <span class="comment">//</span>
00205             <span class="comment">// Get a pointer to the stack location for the first driver.  This will</span>
00206             <span class="comment">// be used to pass the original function codes and parameters.  No</span>
00207             <span class="comment">// function-specific parameters are required for this operation.</span>
00208             <span class="comment">//</span>
00209 
00210             irpSp = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>( irp );
00211             irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a> = <a class="code" href="../../d0/d5/io_8h.html#a30">IRP_MJ_LOCK_CONTROL</a>;
00212             irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o1">MinorFunction</a> = <a class="code" href="../../d0/d5/io_8h.html#a54">IRP_MN_UNLOCK_ALL</a>;
00213             irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a> = fileObject;
00214 
00215             <span class="comment">//</span>
00216             <span class="comment">//  Reference the fileobject again for the IRP (cleared on completion)</span>
00217             <span class="comment">//</span>
00218 
00219             <a class="code" href="../../d4/d0/ob_8h.html#a15">ObReferenceObject</a>( fileObject );
00220 
00221             <span class="comment">//</span>
00222             <span class="comment">// Insert the packet at the head of the IRP list for the thread.</span>
00223             <span class="comment">//</span>
00224 
00225             <a class="code" href="../../d0/d6/iop_8h.html#a21">IopQueueThreadIrp</a>( irp );
00226 
00227             <span class="comment">//</span>
00228             <span class="comment">// Invoke the driver at its appropriate dispatch entry with the IRP.</span>
00229             <span class="comment">//</span>
00230 
00231             status = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>( deviceObject, irp );
00232 
00233             <span class="comment">//</span>
00234             <span class="comment">// If no error was incurred, wait for the I/O operation to complete.</span>
00235             <span class="comment">//</span>
00236 
00237             <span class="keywordflow">if</span> (status == STATUS_PENDING) {
00238                 (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;event,
00239                                               <a class="code" href="../../d4/d9/ke_8h.html#a407a204">UserRequest</a>,
00240                                               <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
00241                                               <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00242                                               (PLARGE_INTEGER) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00243             }
00244         }
00245 
00246         <span class="comment">//</span>
00247         <span class="comment">// If this operation was a synchronous I/O operation, release the</span>
00248         <span class="comment">// semaphore so that the file can be used by other threads.</span>
00249         <span class="comment">//</span>
00250 
00251         <span class="keywordflow">if</span> (fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a151">FO_SYNCHRONOUS_IO</a>) {
00252             <a class="code" href="../../d0/d6/iop_8h.html#a22">IopReleaseFileObjectLock</a>( fileObject );
00253         }
00254     }
00255 
00256     <span class="keywordflow">if</span> (SystemHandleCount == 1) {
00257 
00258         <span class="comment">//</span>
00259         <span class="comment">// The last handle to this file object for all of the processes in the</span>
00260         <span class="comment">// system has just been closed, so invoke the driver's "cleanup" handler</span>
00261         <span class="comment">// for this file.  This is the file system's opportunity to remove any</span>
00262         <span class="comment">// share access information for the file, to indicate that if the file</span>
00263         <span class="comment">// is opened for a caching operation and this is the last file object</span>
00264         <span class="comment">// to the file, then it can do whatever it needs with memory management</span>
00265         <span class="comment">// to cleanup any information.</span>
00266         <span class="comment">//</span>
00267         <span class="comment">// Begin by getting the address of the target device object.</span>
00268         <span class="comment">//</span>
00269 
00270         <span class="keywordflow">if</span> (!(fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a161">FO_DIRECT_DEVICE_OPEN</a>)) {
00271             deviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a76">IoGetRelatedDeviceObject</a>( fileObject );
00272         } <span class="keywordflow">else</span> {
00273             deviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a66">IoGetAttachedDevice</a>( fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o2">DeviceObject</a> );
00274         }
00275 
00276         <span class="comment">//</span>
00277         <span class="comment">// Ensure that the I/O system believes that this file has a handle</span>
00278         <span class="comment">// associated with it in case it doesn't actually get one from the</span>
00279         <span class="comment">// Object Manager.  This is done because sometimes the Object Manager</span>
00280         <span class="comment">// actually creates a handle, but the I/O system never finds out</span>
00281         <span class="comment">// about it so it attempts to send two cleanups for the same file.</span>
00282         <span class="comment">//</span>
00283 
00284         fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a168">FO_HANDLE_CREATED</a>;
00285 
00286         <span class="comment">//</span>
00287         <span class="comment">// If this file is open for synchronous I/O, wait until this thread</span>
00288         <span class="comment">// owns it exclusively since there may still be a thread using it.</span>
00289         <span class="comment">// This occurs when a system service owns the file because it owns</span>
00290         <span class="comment">// the semaphore, but the I/O completion code has already dereferenced</span>
00291         <span class="comment">// the file object itself.  Without waiting here for the same semaphore</span>
00292         <span class="comment">// there would be a race condition in the service who owns it now. The</span>
00293         <span class="comment">// service needs to be able to access the object w/o it going away after</span>
00294         <span class="comment">// its wait for the file event is satisfied.</span>
00295         <span class="comment">//</span>
00296 
00297         <span class="keywordflow">if</span> (fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a151">FO_SYNCHRONOUS_IO</a>) {
00298 
00299             BOOLEAN interrupted;
00300 
00301             <span class="keywordflow">if</span> (!<a class="code" href="../../d0/d6/iop_8h.html#a13">IopAcquireFastLock</a>( fileObject )) {
00302                 (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d0/d6/iop_8h.html#a147">IopAcquireFileObjectLock</a>( fileObject,
00303                                                  <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
00304                                                  <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00305                                                  &amp;interrupted );
00306             }
00307         }
00308 
00309         <span class="comment">//</span>
00310         <span class="comment">// Initialize the local event that will be used to synchronize access</span>
00311         <span class="comment">// to the driver completing this I/O operation.</span>
00312         <span class="comment">//</span>
00313 
00314         <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( &amp;event, SynchronizationEvent, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00315 
00316         <span class="comment">//</span>
00317         <span class="comment">// Reset the event in the file object.</span>
00318         <span class="comment">//</span>
00319 
00320         <a class="code" href="../../d4/d9/ke_8h.html#a21">KeClearEvent</a>( &amp;fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o25">Event</a> );
00321 
00322         <span class="comment">//</span>
00323         <span class="comment">// Allocate and initialize the I/O Request Packet (IRP) for this</span>
00324         <span class="comment">// operation.</span>
00325         <span class="comment">//</span>
00326 
00327         irp = <a class="code" href="../../d0/d6/iop_8h.html#a149">IopAllocateIrpMustSucceed</a>( deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o13">StackSize</a> );
00328         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.OriginalFileObject = fileObject;
00329         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.Thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
00330         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o10">RequestorMode</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>;
00331 
00332         <span class="comment">//</span>
00333         <span class="comment">// Fill in the service independent parameters in the IRP.</span>
00334         <span class="comment">//</span>
00335 
00336         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o19">UserEvent</a> = &amp;event;
00337         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o18">UserIosb</a> = &amp;irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>;
00338         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o24">Overlay</a>.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00339         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> = <a class="code" href="../../d0/d5/io_8h.html#a176">IRP_SYNCHRONOUS_API</a> | <a class="code" href="../../d0/d5/io_8h.html#a185">IRP_CLOSE_OPERATION</a>;
00340 
00341         <span class="comment">//</span>
00342         <span class="comment">// Get a pointer to the stack location for the first driver.  This will</span>
00343         <span class="comment">// be used to pass the original function codes and parameters.  No</span>
00344         <span class="comment">// function-specific parameters are required for this operation.</span>
00345         <span class="comment">//</span>
00346 
00347         irpSp = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>( irp );
00348         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a> = <a class="code" href="../../d0/d5/io_8h.html#a31">IRP_MJ_CLEANUP</a>;
00349         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a> = fileObject;
00350 
00351         <span class="comment">//</span>
00352         <span class="comment">// Insert the packet at the head of the IRP list for the thread.</span>
00353         <span class="comment">//</span>
00354 
00355         <a class="code" href="../../d0/d6/iop_8h.html#a21">IopQueueThreadIrp</a>( irp );
00356 
00357         <span class="comment">//</span>
00358         <span class="comment">// Update the operation count statistic for the current process for</span>
00359         <span class="comment">// operations other than read and write.</span>
00360         <span class="comment">//</span>
00361 
00362         <a class="code" href="../../d4/d6/iosubs_8c.html#a129">IopUpdateOtherOperationCount</a>();
00363 
00364         <span class="comment">//</span>
00365         <span class="comment">// Invoke the driver at its appropriate dispatch entry with the IRP.</span>
00366         <span class="comment">//</span>
00367 
00368         status = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>( deviceObject, irp );
00369 
00370         <span class="comment">//</span>
00371         <span class="comment">// If no error was incurred, wait for the I/O operation to complete.</span>
00372         <span class="comment">//</span>
00373 
00374         <span class="keywordflow">if</span> (status == STATUS_PENDING) {
00375             (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;event,
00376                                           <a class="code" href="../../d4/d9/ke_8h.html#a407a204">UserRequest</a>,
00377                                           <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
00378                                           <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00379                                           (PLARGE_INTEGER) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00380         }
00381 
00382         <span class="comment">//</span>
00383         <span class="comment">// The following code tears down the IRP by hand since it may not</span>
00384         <span class="comment">// either be possible to it to be completed (because this code was</span>
00385         <span class="comment">// invoked as APC_LEVEL in the first place - or because the reference</span>
00386         <span class="comment">// count on the object cannot be incremented due to this routine</span>
00387         <span class="comment">// being invoked by the delete file procedure below).  Cleanup IRPs</span>
00388         <span class="comment">// therefore use close sematics (the close operation flag is set</span>
00389         <span class="comment">// in the IRP) so that the I/O complete request routine itself sets</span>
00390         <span class="comment">// the event to the Signaled state.</span>
00391         <span class="comment">//</span>
00392 
00393         <a class="code" href="../../d9/d5/verifier_8c.html#a116">KeRaiseIrql</a>( <a class="code" href="../../d6/d7/halmips_8h.html#a52">APC_LEVEL</a>, &amp;irql );
00394         <a class="code" href="../../d0/d6/iop_8h.html#a18">IopDequeueThreadIrp</a>( irp );
00395         <a class="code" href="../../d9/d5/verifier_8c.html#a117">KeLowerIrql</a>( irql );
00396 
00397         <span class="comment">//</span>
00398         <span class="comment">// Also, free the IRP.</span>
00399         <span class="comment">//</span>
00400 
00401         <a class="code" href="../../d4/d6/iosubs_8c.html#a63">IoFreeIrp</a>( irp );
00402 
00403         <span class="comment">//</span>
00404         <span class="comment">// If this operation was a synchronous I/O operation, release the</span>
00405         <span class="comment">// semaphore so that the file can be used by other threads.</span>
00406         <span class="comment">//</span>
00407 
00408         <span class="keywordflow">if</span> (fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a151">FO_SYNCHRONOUS_IO</a>) {
00409             <a class="code" href="../../d0/d6/iop_8h.html#a22">IopReleaseFileObjectLock</a>( fileObject );
00410         }
00411     }
00412 
00413     <span class="keywordflow">return</span>;
00414 }
00415 
00416 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00417"></a><a class="code" href="../../d3/d1/objsup_8c.html#a1">00417</a> <a class="code" href="../../d3/d1/objsup_8c.html#a1">IopDeleteFile</a>(
00418     IN PVOID Object
00419     )
00420 
00421 <span class="comment">/*++</span>
00422 <span class="comment"></span>
00423 <span class="comment">Routine Description:</span>
00424 <span class="comment"></span>
00425 <span class="comment">    This routine is invoked when the last handle to a specific file handle is</span>
00426 <span class="comment">    being closed and the file object is going away.  It is the responsibility</span>
00427 <span class="comment">    of this routine to perform the following functions:</span>
00428 <span class="comment"></span>
00429 <span class="comment">        o  Notify the device driver that the file object is open on that the</span>
00430 <span class="comment">           file is being closed.</span>
00431 <span class="comment"></span>
00432 <span class="comment">        o  Dereference the user's error port for the file object, if there</span>
00433 <span class="comment">           is one associated with the file object.</span>
00434 <span class="comment"></span>
00435 <span class="comment">        o  Decrement the device object reference count.</span>
00436 <span class="comment"></span>
00437 <span class="comment">Arguments:</span>
00438 <span class="comment"></span>
00439 <span class="comment">    Object - Pointer to the file object being deleted.</span>
00440 <span class="comment"></span>
00441 <span class="comment">Return Value:</span>
00442 <span class="comment"></span>
00443 <span class="comment">    None.</span>
00444 <span class="comment"></span>
00445 <span class="comment">--*/</span>
00446 
00447 {
00448     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
00449     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpSp;
00450     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> deviceObject;
00451     IO_STATUS_BLOCK ioStatusBlock;
00452     KIRQL irql;
00453     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
00454     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> fileObject;
00455     <a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a> event;
00456     <a class="code" href="../../d7/d7/struct__VPB.html">PVPB</a> vpb;
00457     BOOLEAN referenceCountDecremented;
00458 
00459     <span class="comment">//</span>
00460     <span class="comment">// Obtain a pointer to the file object.</span>
00461     <span class="comment">//</span>
00462 
00463     fileObject = (<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>) Object;
00464 
00465     <span class="comment">//</span>
00466     <span class="comment">// Get a pointer to the first device driver which should be notified that</span>
00467     <span class="comment">// this file is going away.  If the device driver field is NULL, then this</span>
00468     <span class="comment">// file is being shut down due to an error attempting to get it open in the</span>
00469     <span class="comment">// first place, so do not do any further processing.</span>
00470     <span class="comment">//</span>
00471 
00472     <span class="keywordflow">if</span> (fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o2">DeviceObject</a>) {
00473         <span class="keywordflow">if</span> (!(fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a161">FO_DIRECT_DEVICE_OPEN</a>)) {
00474             deviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a76">IoGetRelatedDeviceObject</a>( fileObject );
00475         } <span class="keywordflow">else</span> {
00476             deviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a66">IoGetAttachedDevice</a>( fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o2">DeviceObject</a> );
00477         }
00478 
00479         <span class="comment">//</span>
00480         <span class="comment">// If this file has never had a file handle created for it, and yet</span>
00481         <span class="comment">// it exists, invoke the close file procedure so that the file system</span>
00482         <span class="comment">// gets the cleanup IRP it is expecting before sending the close IRP.</span>
00483         <span class="comment">//</span>
00484 
00485         <span class="keywordflow">if</span> (!(fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a168">FO_HANDLE_CREATED</a>)) {
00486             <a class="code" href="../../d3/d1/objsup_8c.html#a0">IopCloseFile</a>( (<a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00487                           Object,
00488                           0,
00489                           1,
00490                           1 );
00491         }
00492 
00493         <span class="comment">//</span>
00494         <span class="comment">// If this file is open for synchronous I/O, wait until this thread</span>
00495         <span class="comment">// owns it exclusively since there may still be a thread using it.</span>
00496         <span class="comment">// This occurs when a system service owns the file because it owns</span>
00497         <span class="comment">// the semaphore, but the I/O completion code has already dereferenced</span>
00498         <span class="comment">// the file object itself.  Without waiting here for the same semaphore</span>
00499         <span class="comment">// there would be a race condition in the service who owns it now.  The</span>
00500         <span class="comment">// service needs to be able to access the object w/o it going away after</span>
00501         <span class="comment">// its wait for the file event is satisfied.</span>
00502         <span class="comment">//</span>
00503 
00504         <span class="keywordflow">if</span> (fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a151">FO_SYNCHRONOUS_IO</a>) {
00505 
00506             BOOLEAN interrupted;
00507 
00508             <span class="keywordflow">if</span> (!<a class="code" href="../../d0/d6/iop_8h.html#a13">IopAcquireFastLock</a>( fileObject )) {
00509                 (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d0/d6/iop_8h.html#a147">IopAcquireFileObjectLock</a>( fileObject,
00510                                                  <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
00511                                                  <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00512                                                  &amp;interrupted );
00513             }
00514         }
00515 
00516         <span class="comment">//</span>
00517         <span class="comment">// Reset a local event that can be used to wait for the device driver</span>
00518         <span class="comment">// to close the file.</span>
00519         <span class="comment">//</span>
00520 
00521         <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( &amp;event, SynchronizationEvent, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00522 
00523         <span class="comment">//</span>
00524         <span class="comment">// Reset the event in the file object.</span>
00525         <span class="comment">//</span>
00526 
00527         <a class="code" href="../../d4/d9/ke_8h.html#a21">KeClearEvent</a>( &amp;fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o25">Event</a> );
00528 
00529         <span class="comment">//</span>
00530         <span class="comment">// Allocate an I/O Request Packet (IRP) to be used in communicating with</span>
00531         <span class="comment">// the appropriate device driver that the file is being closed.  Notice</span>
00532         <span class="comment">// that the allocation of this packet is done without charging quota so</span>
00533         <span class="comment">// that the operation will not fail.  This is done because there is no</span>
00534         <span class="comment">// way to return an error to the caller at this point.</span>
00535         <span class="comment">//</span>
00536 
00537         irp = <a class="code" href="../../d4/d6/iosubs_8c.html#a17">IoAllocateIrp</a>( deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o13">StackSize</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00538         <span class="keywordflow">if</span> (!irp) {
00539             irp = <a class="code" href="../../d0/d6/iop_8h.html#a149">IopAllocateIrpMustSucceed</a>( deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o13">StackSize</a> );
00540         }
00541 
00542         <span class="comment">//</span>
00543         <span class="comment">// Get a pointer to the stack location for the first driver.  This is</span>
00544         <span class="comment">// where the function codes and parameters are placed.</span>
00545         <span class="comment">//</span>
00546 
00547         irpSp = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>( irp );
00548 
00549         <span class="comment">//</span>
00550         <span class="comment">// Fill in the IRP, indicating that this file object is being deleted.</span>
00551         <span class="comment">//</span>
00552 
00553         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a> = <a class="code" href="../../d0/d5/io_8h.html#a15">IRP_MJ_CLOSE</a>;
00554         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a> = fileObject;
00555         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o18">UserIosb</a> = &amp;ioStatusBlock;
00556         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o19">UserEvent</a> = &amp;event;
00557         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.OriginalFileObject = fileObject;
00558         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.Thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
00559         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.SystemBuffer = (PVOID) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00560         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> = <a class="code" href="../../d0/d5/io_8h.html#a185">IRP_CLOSE_OPERATION</a> | <a class="code" href="../../d0/d5/io_8h.html#a176">IRP_SYNCHRONOUS_API</a>;
00561 
00562         <span class="comment">//</span>
00563         <span class="comment">// Place this packet in the thread's I/O pending queue.</span>
00564         <span class="comment">//</span>
00565 
00566         <a class="code" href="../../d0/d6/iop_8h.html#a21">IopQueueThreadIrp</a>( irp );
00567 
00568         <span class="comment">//</span>
00569         <span class="comment">// Decrement the reference count on the VPB, if necessary.  We</span>
00570         <span class="comment">// have to do this BEFORE handing the Irp to the file system</span>
00571         <span class="comment">// because of a trick the file systems play with close, and</span>
00572         <span class="comment">// believe me, you really don't want to know what it is.</span>
00573         <span class="comment">//</span>
00574         <span class="comment">// Since there is not a error path here (close cannot fail),</span>
00575         <span class="comment">// and the file system is the only ome who can actually synchronize</span>
00576         <span class="comment">// with the actual completion of close processing, the file system</span>
00577         <span class="comment">// is the one responsible for Vpb deletion.</span>
00578         <span class="comment">//</span>
00579 
00580         vpb = fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o3">Vpb</a>;
00581 
00582         <span class="keywordflow">if</span> (vpb &amp;&amp; !(fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a161">FO_DIRECT_DEVICE_OPEN</a>)) {
00583             <a class="code" href="../../d5/d8/ex_8h.html#a235">ExInterlockedAddUlong</a>( &amp;vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o7">ReferenceCount</a>,
00584                                    0xffffffff,
00585                                    &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a2">IopVpbSpinLock</a> );
00586         }
00587 
00588         <span class="comment">//</span>
00589         <span class="comment">// If this device object has stated for a fact that it knows it will</span>
00590         <span class="comment">// never have the final non-zero reference count among the other</span>
00591         <span class="comment">// device objects associated with our driver object, then decrement</span>
00592         <span class="comment">// our reference count here BEFORE calling the file system.  This</span>
00593         <span class="comment">// is required because for a special class of device objects, the</span>
00594         <span class="comment">// file system may delete them.</span>
00595         <span class="comment">//</span>
00596 
00597         <span class="keywordflow">if</span> (fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o2">DeviceObject</a>-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o8">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a131">DO_NEVER_LAST_DEVICE</a>) {
00598             <a class="code" href="../../d5/d8/ex_8h.html#a235">ExInterlockedAddUlong</a>( &amp;fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o2">DeviceObject</a>-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o2">ReferenceCount</a>,
00599                                    0xffffffff,
00600                                    &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a> );
00601 
00602             referenceCountDecremented = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00603         } <span class="keywordflow">else</span> {
00604             referenceCountDecremented = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00605         }
00606 
00607         <span class="comment">//</span>
00608         <span class="comment">// Give the device driver the packet.  If this request does not work,</span>
00609         <span class="comment">// there is nothing that can be done about it.  This is unfortunate</span>
00610         <span class="comment">// because the driver may have had problems that it was about to</span>
00611         <span class="comment">// report about other operations (e.g., write behind failures, etc.)</span>
00612         <span class="comment">// that it can no longer report.  The reason is that this routine</span>
00613         <span class="comment">// is really initially invoked by NtClose, which has already closed</span>
00614         <span class="comment">// the caller's handle, and that's what the return status from close</span>
00615         <span class="comment">// indicates:  the handle has successfully been closed.</span>
00616         <span class="comment">//</span>
00617 
00618         status = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>( deviceObject, irp );
00619 
00620         <span class="keywordflow">if</span> (status == STATUS_PENDING) {
00621             (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;event,
00622                                           <a class="code" href="../../d6/d7/halmips_8h.html#a455">Executive</a>,
00623                                           <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
00624                                           <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00625                                           (PLARGE_INTEGER) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00626         }
00627 
00628         <span class="comment">//</span>
00629         <span class="comment">// Perform any completion operations that need to be performed on</span>
00630         <span class="comment">// the IRP that was used for this request.  This is done here as</span>
00631         <span class="comment">// as opposed to in normal completion code because there is a race</span>
00632         <span class="comment">// condition between when this routine executes if it was invoked</span>
00633         <span class="comment">// from a special kernel APC (e.g., some IRP was just completed and</span>
00634         <span class="comment">// dereferenced this file object for the last time), and when the</span>
00635         <span class="comment">// special kernel APC because of this packet's completion executing.</span>
00636         <span class="comment">//</span>
00637         <span class="comment">// This problem is solved by not having to queue a special kernel</span>
00638         <span class="comment">// APC routine for completion of this packet.  Rather, it is treated</span>
00639         <span class="comment">// much like a synchronous paging I/O operation, except that the</span>
00640         <span class="comment">// packet is not even freed during I/O completion.  This is because</span>
00641         <span class="comment">// the packet is still in this thread's queue, and there is no way</span>
00642         <span class="comment">// to get it out except at APC_LEVEL.  Unfortunately, the part of</span>
00643         <span class="comment">// I/O completion that needs to dequeue the packet is running at</span>
00644         <span class="comment">// DISPATCH_LEVEL.</span>
00645         <span class="comment">//</span>
00646         <span class="comment">// Hence, the packet must be removed from the queue (synchronized,</span>
00647         <span class="comment">// of course), and then it must be freed.</span>
00648         <span class="comment">//</span>
00649 
00650         <a class="code" href="../../d9/d5/verifier_8c.html#a116">KeRaiseIrql</a>( <a class="code" href="../../d6/d7/halmips_8h.html#a52">APC_LEVEL</a>, &amp;irql );
00651         <a class="code" href="../../d0/d6/iop_8h.html#a18">IopDequeueThreadIrp</a>( irp );
00652         <a class="code" href="../../d9/d5/verifier_8c.html#a117">KeLowerIrql</a>( irql );
00653 
00654         <a class="code" href="../../d4/d6/iosubs_8c.html#a63">IoFreeIrp</a>( irp );
00655 
00656         <span class="comment">//</span>
00657         <span class="comment">// Free the file name string buffer if there was one.</span>
00658         <span class="comment">//</span>
00659 
00660         <span class="keywordflow">if</span> (fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o19">FileName</a>.Length != 0) {
00661             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o19">FileName</a>.Buffer );
00662         }
00663 
00664         <span class="comment">//</span>
00665         <span class="comment">// If there was an completion port associated w/this file object, dereference</span>
00666         <span class="comment">// it now, and deallocate the completion context pool.</span>
00667         <span class="comment">//</span>
00668 
00669         <span class="keywordflow">if</span> (fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o26">CompletionContext</a>) {
00670             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o26">CompletionContext</a>-&gt;<a class="code" href="../../d2/d4/struct__IO__COMPLETION__CONTEXT.html#o0">Port</a> );
00671             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o26">CompletionContext</a> );
00672         }
00673 
00674         <span class="comment">//</span>
00675         <span class="comment">// Get a pointer to the real device object so its reference count</span>
00676         <span class="comment">// can be decremented.</span>
00677         <span class="comment">//</span>
00678 
00679         deviceObject = fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o2">DeviceObject</a>;
00680 
00681         <span class="comment">//</span>
00682         <span class="comment">// Decrement the reference count on the device object.  Note that</span>
00683         <span class="comment">// if the driver has been marked for an unload operation, and the</span>
00684         <span class="comment">// reference count goes to zero, then the driver may need to be</span>
00685         <span class="comment">// unloaded at this point.</span>
00686         <span class="comment">//</span>
00687         <span class="comment">// Note: only do this if the reference count was not already done</span>
00688         <span class="comment">// above.  The device object may be gone in this case.</span>
00689         <span class="comment">//</span>
00690 
00691         <span class="keywordflow">if</span> (!referenceCountDecremented) {
00692             <a class="code" href="../../d0/d6/iop_8h.html#a161">IopDecrementDeviceObjectRef</a>( deviceObject, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00693         }
00694     }
00695 }
00696 
00697 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00698"></a><a class="code" href="../../d3/d1/objsup_8c.html#a2">00698</a> <a class="code" href="../../d3/d1/objsup_8c.html#a2">IopDeleteDriver</a>(
00699     IN PVOID Object
00700     )
00701 
00702 <span class="comment">/*++</span>
00703 <span class="comment"></span>
00704 <span class="comment">Routine Description:</span>
00705 <span class="comment"></span>
00706 <span class="comment">    This routine is invoked when the reference count for a driver object</span>
00707 <span class="comment">    becomes zero.  That is, the last reference for the driver has gone away.</span>
00708 <span class="comment">    This routine ensures that the object is cleaned up and the driver</span>
00709 <span class="comment">    unloaded.</span>
00710 <span class="comment"></span>
00711 <span class="comment">Arguments:</span>
00712 <span class="comment"></span>
00713 <span class="comment">    Object - Pointer to the driver object whose reference count has gone</span>
00714 <span class="comment">        to zero.</span>
00715 <span class="comment"></span>
00716 <span class="comment">Return value:</span>
00717 <span class="comment"></span>
00718 <span class="comment">    None.</span>
00719 <span class="comment"></span>
00720 <span class="comment">--*/</span>
00721 
00722 {
00723     <a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html">PDRIVER_OBJECT</a> driverObject = (<a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html">PDRIVER_OBJECT</a>) Object;
00724     <a class="code" href="../../d1/d4/struct__IO__CLIENT__EXTENSION.html">PIO_CLIENT_EXTENSION</a> <a class="code" href="../../d7/d1/genuedef_8c.html#a6">extension</a>;
00725     <a class="code" href="../../d1/d4/struct__IO__CLIENT__EXTENSION.html">PIO_CLIENT_EXTENSION</a> nextExtension;
00726 
00727     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00728 
00729     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( !driverObject-&gt;<a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html#o2">DeviceObject</a> );
00730 
00731     <span class="comment">//</span>
00732     <span class="comment">// Free any client driver object extensions.</span>
00733     <span class="comment">//</span>
00734 
00735     <a class="code" href="../../d7/d1/genuedef_8c.html#a6">extension</a> = driverObject-&gt;<a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html#o7">DriverExtension</a>-&gt;<a class="code" href="../../d1/d9/struct__DRIVER__EXTENSION.html#o4">ClientDriverExtension</a>;
00736     <span class="keywordflow">while</span> (<a class="code" href="../../d7/d1/genuedef_8c.html#a6">extension</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00737 
00738         nextExtension = <a class="code" href="../../d7/d1/genuedef_8c.html#a6">extension</a>-&gt;NextExtension;
00739         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( <a class="code" href="../../d7/d1/genuedef_8c.html#a6">extension</a> );
00740         <a class="code" href="../../d7/d1/genuedef_8c.html#a6">extension</a> = nextExtension;
00741     }
00742 
00743     <span class="comment">//</span>
00744     <span class="comment">// If there is a driver section then unload the driver.</span>
00745     <span class="comment">//</span>
00746 
00747     <span class="keywordflow">if</span> (driverObject-&gt;<a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html#o6">DriverSection</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00748         <a class="code" href="../../d8/d8/sysload_8c.html#a59">MmUnloadSystemImage</a>( driverObject-&gt;<a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html#o6">DriverSection</a> );
00749     }
00750 
00751     <span class="comment">//</span>
00752     <span class="comment">// Free the pool associated with the name of the driver.</span>
00753     <span class="comment">//</span>
00754 
00755     <span class="keywordflow">if</span> (driverObject-&gt;<a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html#o8">DriverName</a>.Buffer) {
00756         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( driverObject-&gt;<a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html#o8">DriverName</a>.Buffer );
00757     }
00758 
00759     <span class="comment">//</span>
00760     <span class="comment">// Free the pool associated with the service key name of the driver.</span>
00761     <span class="comment">//</span>
00762 
00763     <span class="keywordflow">if</span> (driverObject-&gt;<a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html#o7">DriverExtension</a>-&gt;<a class="code" href="../../d1/d9/struct__DRIVER__EXTENSION.html#o3">ServiceKeyName</a>.Buffer) {
00764         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( driverObject-&gt;<a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html#o7">DriverExtension</a>-&gt;<a class="code" href="../../d1/d9/struct__DRIVER__EXTENSION.html#o3">ServiceKeyName</a>.Buffer );
00765     }
00766 }
00767 
00768 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00769"></a><a class="code" href="../../d3/d1/objsup_8c.html#a3">00769</a> <a class="code" href="../../d3/d1/objsup_8c.html#a3">IopDeleteDevice</a>(
00770     IN PVOID Object
00771     )
00772 
00773 <span class="comment">/*++</span>
00774 <span class="comment"></span>
00775 <span class="comment">Routine Description:</span>
00776 <span class="comment"></span>
00777 <span class="comment">    This routine is invoked when the reference count for a device object</span>
00778 <span class="comment">    becomes zero.  That is, the last reference for the device has gone away.</span>
00779 <span class="comment">    This routine ensures that the object is cleaned up and the driver object</span>
00780 <span class="comment">    is dereferenced.</span>
00781 <span class="comment"></span>
00782 <span class="comment">Arguments:</span>
00783 <span class="comment"></span>
00784 <span class="comment">    Object - Pointer to the driver object whose reference count has gone</span>
00785 <span class="comment">        to zero.</span>
00786 <span class="comment"></span>
00787 <span class="comment">Return value:</span>
00788 <span class="comment"></span>
00789 <span class="comment">    None.</span>
00790 <span class="comment"></span>
00791 <span class="comment">--*/</span>
00792 
00793 {
00794     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> deviceObject = (<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>) Object;
00795     <a class="code" href="../../d7/d7/struct__VPB.html">PVPB</a> vpb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00796 
00797     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00798 
00799     <a class="code" href="../../d9/d0/pnpiop_8h.html#a284">IopDestroyDeviceNode</a>(deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o25">DeviceObjectExtension</a>-&gt;<a class="code" href="../../d3/d5/struct__DEVOBJ__EXTENSION.html#o6">DeviceNode</a>);
00800 
00801 <span class="preprocessor">#if DBG</span>
00802 <span class="preprocessor"></span>    IopCheckDeviceNodeTree (deviceObject, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00803 <span class="preprocessor">#endif</span>
00804 <span class="preprocessor"></span>
00805     <span class="comment">//</span>
00806     <span class="comment">// If there's still a VPB attached then free it.</span>
00807     <span class="comment">//</span>
00808 
00809     vpb = InterlockedExchangePointer(&amp;(deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o10">Vpb</a>), vpb);
00810 
00811     <span class="keywordflow">if</span>(vpb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00812 
00813         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a8">ASSERTMSG</a>(<span class="stringliteral">"Unreferenced device object to be deleted is still in use"</span>,
00814                   ((vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o2">Flags</a> &amp; (<a class="code" href="../../d0/d5/io_8h.html#a116">VPB_MOUNTED</a> | <a class="code" href="../../d0/d5/io_8h.html#a117">VPB_LOCKED</a>)) == 0));
00815 
00816         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o7">ReferenceCount</a> == 0);
00817         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(vpb);
00818     }
00819     <span class="keywordflow">if</span> (deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o3">DriverObject</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00820         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o3">DriverObject</a> );
00821     }
00822 }
00823 
00824 
00825 <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>
<a name="l00826"></a><a class="code" href="../../d3/d1/objsup_8c.html#a4">00826</a> <a class="code" href="../../d3/d1/objsup_8c.html#a4">IopGetDevicePDO</a>(
00827     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject
00828     )
00829 <span class="comment">/*++</span>
00830 <span class="comment"></span>
00831 <span class="comment">Routine Description:</span>
00832 <span class="comment"></span>
00833 <span class="comment">    Call this routine to obtain the Base PDO for a device object</span>
00834 <span class="comment"></span>
00835 <span class="comment">Arguments:</span>
00836 <span class="comment"></span>
00837 <span class="comment">    DeviceObject - pointer to device object to get PDO for</span>
00838 <span class="comment"></span>
00839 <span class="comment">ReturnValue:</span>
00840 <span class="comment"></span>
00841 <span class="comment">    PDO if DeviceObject is attached to a PDO, otherwise NULL</span>
00842 <span class="comment">    The returned PDO is reference-counted</span>
00843 <span class="comment"></span>
00844 <span class="comment">--*/</span>
00845 {
00846     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> deviceBaseObject;
00847     KIRQL irql;
00848 
00849     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(DeviceObject);
00850 
00851     <a class="code" href="../../d9/d0/pnpiop_8h.html#a95">IopAcquireEnumerationLock</a>(<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);        <span class="comment">// ensure we have acquired P&amp;P locks</span>
00852 
00853     ExAcquireSpinLock(&amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a>,&amp;irql);
00854     deviceBaseObject = <a class="code" href="../../d0/d6/iop_8h.html#a173">IopGetDeviceAttachmentBase</a>(DeviceObject);
00855     <span class="keywordflow">if</span> ((deviceBaseObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o8">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a133">DO_BUS_ENUMERATED_DEVICE</a>) != 0) {
00856         <span class="comment">//</span>
00857         <span class="comment">// we have determined that this is attached to a PDO</span>
00858         <span class="comment">//</span>
00859         <a class="code" href="../../d4/d0/ob_8h.html#a15">ObReferenceObject</a>( deviceBaseObject );
00860 
00861     } <span class="keywordflow">else</span> {
00862         <span class="comment">//</span>
00863         <span class="comment">// not a PDO</span>
00864         <span class="comment">//</span>
00865         deviceBaseObject = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00866     }
00867     ExReleaseSpinLock(&amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a>,irql);
00868 
00869     <a class="code" href="../../d9/d0/pnpiop_8h.html#a96">IopReleaseEnumerationLock</a>(<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00870 
00871     <span class="keywordflow">return</span> deviceBaseObject;
00872 }
00873 
00874 
00875 
00876 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00877"></a><a class="code" href="../../d3/d1/objsup_8c.html#a5">00877</a> <a class="code" href="../../d3/d1/objsup_8c.html#a5">IopSetDeviceSecurityDescriptors</a>(
00878     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>           DeviceObject,
00879     IN PSECURITY_INFORMATION    SecurityInformation,
00880     IN PSECURITY_DESCRIPTOR     SecurityDescriptor,
00881     IN POOL_TYPE                PoolType,
00882     IN PGENERIC_MAPPING         GenericMapping,
00883     IN BOOLEAN                  DoAttachedDevices
00884     )
00885 <span class="comment">/*++</span>
00886 <span class="comment"></span>
00887 <span class="comment">Routine Description:</span>
00888 <span class="comment"></span>
00889 <span class="comment">    Call this routine to set device security descriptor</span>
00890 <span class="comment"></span>
00891 <span class="comment">Arguments:</span>
00892 <span class="comment"></span>
00893 <span class="comment">    DeviceObject - pointer to base device object (first one to set)</span>
00894 <span class="comment">    SecurityInformation )_ passed directly from IopGetSetSecurityObject</span>
00895 <span class="comment">    SecurityDescriptor  )</span>
00896 <span class="comment">    PoolType            )</span>
00897 <span class="comment">    GenericMapping      )</span>
00898 <span class="comment">    DoAttachedDevices - if true, iterate the AttachedDevice list</span>
00899 <span class="comment"></span>
00900 <span class="comment">ReturnValue:</span>
00901 <span class="comment"></span>
00902 <span class="comment">    success, or error from first failure</span>
00903 <span class="comment"></span>
00904 <span class="comment">--*/</span>
00905 {
00906     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> NewDeviceObject = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00907     PSECURITY_DESCRIPTOR OldSecurityDescriptor;
00908     KIRQL irql;
00909     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
00910     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> firsterr = STATUS_SUCCESS;
00911     BOOLEAN first = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00912 
00913     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(DeviceObject);
00914 
00915     <a class="code" href="../../d9/d0/pnpiop_8h.html#a95">IopAcquireEnumerationLock</a>(<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);        <span class="comment">// ensure we have acquired P&amp;P locks</span>
00916     <span class="comment">//</span>
00917     <span class="comment">// pre-reference this object to match the dereference later</span>
00918     <span class="comment">//</span>
00919     <a class="code" href="../../d4/d0/ob_8h.html#a15">ObReferenceObject</a>( DeviceObject );
00920 
00921     <span class="keywordflow">do</span> {
00922         <a class="code" href="../../d4/d9/ke_8h.html#a28">KeEnterCriticalRegion</a>();
00923         <a class="code" href="../../d5/d8/ex_8h.html#a70">ExAcquireResourceExclusive</a>( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a5">IopSecurityResource</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
00924 
00925         OldSecurityDescriptor = DeviceObject-&gt;SecurityDescriptor;
00926 
00927         <span class="keywordflow">if</span> (OldSecurityDescriptor || first) {
00928             <span class="comment">//</span>
00929             <span class="comment">// always call this on the first object, only do it for others that have a security descriptor</span>
00930             <span class="comment">//</span>
00931             status = <a class="code" href="../../d0/d6/semethod_8c.html#a4">SeSetSecurityDescriptorInfo</a>( <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00932                                                   SecurityInformation,
00933                                                   SecurityDescriptor,
00934                                                   &amp;DeviceObject-&gt;SecurityDescriptor,
00935                                                   PoolType,
00936                                                   GenericMapping );
00937 
00938             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(firsterr)) {
00939                 firsterr = status;
00940             }
00941             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
00942                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(OldSecurityDescriptor);
00943                 <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( OldSecurityDescriptor );
00944             }
00945             first = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00946         }
00947 
00948         <a class="code" href="../../d5/d8/ex_8h.html#a66">ExReleaseResource</a>( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a5">IopSecurityResource</a> );
00949         <a class="code" href="../../d4/d9/ke_8h.html#a29">KeLeaveCriticalRegion</a>();
00950 
00951         <span class="comment">//</span>
00952         <span class="comment">// get next device on attachment chain</span>
00953         <span class="comment">//</span>
00954         ExAcquireSpinLock(&amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a>,&amp;irql);
00955         NewDeviceObject = DeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o5">AttachedDevice</a>;
00956         <span class="keywordflow">if</span> ( NewDeviceObject != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
00957             <a class="code" href="../../d4/d0/ob_8h.html#a15">ObReferenceObject</a>( NewDeviceObject );
00958         } <span class="keywordflow">else</span> {
00959             DoAttachedDevices = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00960         }
00961         ExReleaseSpinLock(&amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a>,irql);
00962 
00963         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( DeviceObject );
00964         DeviceObject = NewDeviceObject;
00965 
00966     } <span class="keywordflow">while</span>(DoAttachedDevices);
00967 
00968     <a class="code" href="../../d9/d0/pnpiop_8h.html#a96">IopReleaseEnumerationLock</a>(<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00969 
00970     <span class="keywordflow">return</span> firsterr;    <span class="comment">// of the PDO / single object</span>
00971 }
00972 
00973 
00974 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00975"></a><a class="code" href="../../d3/d1/objsup_8c.html#a6">00975</a> <a class="code" href="../../d3/d1/objsup_8c.html#a6">IopGetSetSecurityObject</a>(
00976     IN PVOID Object,
00977     IN SECURITY_OPERATION_CODE OperationCode,
00978     IN PSECURITY_INFORMATION SecurityInformation,
00979     IN OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
00980     IN OUT PULONG CapturedLength,
00981     IN OUT PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
00982     IN POOL_TYPE PoolType,
00983     IN PGENERIC_MAPPING GenericMapping
00984     )
00985 
00986 <span class="comment">/*++</span>
00987 <span class="comment"></span>
00988 <span class="comment">Routine Description:</span>
00989 <span class="comment"></span>
00990 <span class="comment">    This routine is invoked to either query or set the security descriptor</span>
00991 <span class="comment">    for a file, directory, volume, or device.  It implements these functions</span>
00992 <span class="comment">    by either performing an in-line check if the file is a device or a</span>
00993 <span class="comment">    volume, or an I/O Request Packet (IRP) is generated and given to the</span>
00994 <span class="comment">    driver to perform the operation.</span>
00995 <span class="comment"></span>
00996 <span class="comment">Arguments:</span>
00997 <span class="comment"></span>
00998 <span class="comment">    Object - Pointer to the file or device object representing the open object.</span>
00999 <span class="comment"></span>
01000 <span class="comment">    SecurityInformation - Information about what is being done to or obtained</span>
01001 <span class="comment">        from the object's security descriptor.</span>
01002 <span class="comment"></span>
01003 <span class="comment">    SecurityDescriptor - Supplies the base security descriptor and returns</span>
01004 <span class="comment">        the final security descriptor.  Note that if this buffer is coming</span>
01005 <span class="comment">        from user space, it has already been probed by the object manager</span>
01006 <span class="comment">        to length "CapturedLength", otherwise it points to kernel space and</span>
01007 <span class="comment">        should not be probed.  It must, however, be referenced in a try</span>
01008 <span class="comment">        clause.</span>
01009 <span class="comment"></span>
01010 <span class="comment">    CapturedLength - For a query operation this specifies the size, in</span>
01011 <span class="comment">        bytes, of the output security descriptor buffer and on return</span>
01012 <span class="comment">        contains the number of bytes needed to store the complete security</span>
01013 <span class="comment">        descriptor.  If the length needed is greater than the length</span>
01014 <span class="comment">        supplied the operation will fail.  This parameter is ignored for</span>
01015 <span class="comment">        the set and delete operations.  It is expected to point into</span>
01016 <span class="comment">        system space, ie, it need not be probed and it will not change.</span>
01017 <span class="comment"></span>
01018 <span class="comment">    ObjectsSecurityDescriptor - Supplies and returns the object's security</span>
01019 <span class="comment">        descriptor.</span>
01020 <span class="comment"></span>
01021 <span class="comment">    PoolType - Specifies from which type of pool memory is to be allocated.</span>
01022 <span class="comment"></span>
01023 <span class="comment">    GenericMapping - Supplies the generic mapping for the object type.</span>
01024 <span class="comment"></span>
01025 <span class="comment">Return Value:</span>
01026 <span class="comment"></span>
01027 <span class="comment">    The final status of the operation is returned as the function value.</span>
01028 <span class="comment"></span>
01029 <span class="comment">--*/</span>
01030 
01031 {
01032     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
01033     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> fileObject;
01034     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> deviceObject;
01035     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> devicePDO = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01036     BOOLEAN synchronousIo;
01037 
01038     UNREFERENCED_PARAMETER( ObjectsSecurityDescriptor );
01039     UNREFERENCED_PARAMETER( PoolType );
01040 
01041     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01042 
01043 
01044     <span class="comment">//</span>
01045     <span class="comment">// Begin by determining whether the security operation is to be performed</span>
01046     <span class="comment">// in this routine or by the driver.  This is based upon whether the</span>
01047     <span class="comment">// object represents a device object, or it represents a file object</span>
01048     <span class="comment">// to a device, or a file on the device. If the open is a direct device</span>
01049     <span class="comment">// open then use the device object.</span>
01050     <span class="comment">//</span>
01051 
01052     <span class="keywordflow">if</span> (((<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>) (Object))-&gt;Type == <a class="code" href="../../d0/d5/io_8h.html#a2">IO_TYPE_DEVICE</a>) {
01053         deviceObject = (<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>) Object;
01054         fileObject = (<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01055     } <span class="keywordflow">else</span> {
01056         fileObject = (<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>) Object;
01057         <span class="keywordflow">if</span> (fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a161">FO_DIRECT_DEVICE_OPEN</a>) {
01058             deviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a66">IoGetAttachedDevice</a>( fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o2">DeviceObject</a> );
01059         }
01060         <span class="keywordflow">else</span> {
01061                 deviceObject = fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o2">DeviceObject</a>;
01062         }
01063     }
01064 
01065     <span class="keywordflow">if</span> (!fileObject ||
01066         (!fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o19">FileName</a>.Length &amp;&amp; !fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o9">RelatedFileObject</a>) ||
01067         (fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a161">FO_DIRECT_DEVICE_OPEN</a>)) {
01068 
01069         <span class="comment">//</span>
01070         <span class="comment">// This security operation is for the device itself, either through</span>
01071         <span class="comment">// a file object, or directly to the device object.  For the latter</span>
01072         <span class="comment">// case, assignment operations are also possible.  Also note that</span>
01073         <span class="comment">// this may be a stream file object, which do not have security.</span>
01074         <span class="comment">// The security for a stream file is actually represented by the</span>
01075         <span class="comment">// security descriptor on the file itself, or the volume, or the</span>
01076         <span class="comment">// device.</span>
01077         <span class="comment">//</span>
01078 
01079         <span class="keywordflow">if</span> (OperationCode == <a class="code" href="../../d0/d5/se_8h.html#a200a111">AssignSecurityDescriptor</a>) {
01080 
01081             <span class="comment">//</span>
01082             <span class="comment">// Simply assign the security descriptor to the device object,</span>
01083             <span class="comment">// if this is a device object.</span>
01084             <span class="comment">//</span>
01085 
01086             <span class="keywordflow">if</span> (fileObject == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> || !(fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a158">FO_STREAM_FILE</a>)) {
01087                 <a class="code" href="../../d4/d9/ke_8h.html#a28">KeEnterCriticalRegion</a>();
01088                 <a class="code" href="../../d5/d8/ex_8h.html#a70">ExAcquireResourceExclusive</a>( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a5">IopSecurityResource</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
01089                 deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o21">SecurityDescriptor</a> = SecurityDescriptor;
01090                 <a class="code" href="../../d5/d8/ex_8h.html#a66">ExReleaseResource</a>( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a5">IopSecurityResource</a> );
01091                 <a class="code" href="../../d4/d9/ke_8h.html#a29">KeLeaveCriticalRegion</a>();
01092             }
01093             status = STATUS_SUCCESS;
01094 
01095         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (OperationCode == <a class="code" href="../../d0/d5/se_8h.html#a200a108">SetSecurityDescriptor</a>) {
01096 
01097             <span class="comment">//</span>
01098             <span class="comment">// This is a set operation.  The SecurityInformation parameter</span>
01099             <span class="comment">// determines what part of the SecurityDescriptor is going to</span>
01100             <span class="comment">// be applied to the ObjectsSecurityDescriptor.</span>
01101             <span class="comment">//</span>
01102 
01103             <span class="comment">//</span>
01104             <span class="comment">// if this deviceObject is attached to a PDO then we want</span>
01105             <span class="comment">// to modify the security on the PDO and apply it up the</span>
01106             <span class="comment">// device chain</span>
01107             <span class="comment">//</span>
01108             <span class="keywordflow">if</span> (fileObject == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> || !(fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a161">FO_DIRECT_DEVICE_OPEN</a>)) {
01109                 <span class="comment">//</span>
01110                 <span class="comment">// see if there is a PDO for this object, and obtain it</span>
01111                 <span class="comment">//</span>
01112                 devicePDO = <a class="code" href="../../d3/d1/objsup_8c.html#a4">IopGetDevicePDO</a>(deviceObject);
01113             } <span class="keywordflow">else</span> {
01114                 devicePDO = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01115             }
01116             <span class="keywordflow">if</span> (devicePDO) {
01117                 <span class="comment">//</span>
01118                 <span class="comment">// set PDO and all attached device objects</span>
01119                 <span class="comment">//</span>
01120                 status = <a class="code" href="../../d3/d1/objsup_8c.html#a5">IopSetDeviceSecurityDescriptors</a>(devicePDO,SecurityInformation,SecurityDescriptor,PoolType,GenericMapping,<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
01121                 <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( devicePDO );
01122             } <span class="keywordflow">else</span> {
01123                 <span class="comment">//</span>
01124                 <span class="comment">// set this device object only</span>
01125                 <span class="comment">//</span>
01126                 status = <a class="code" href="../../d3/d1/objsup_8c.html#a5">IopSetDeviceSecurityDescriptors</a>(deviceObject,SecurityInformation,SecurityDescriptor,PoolType,GenericMapping,<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
01127             }
01128 
01129         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (OperationCode == <a class="code" href="../../d0/d5/se_8h.html#a200a109">QuerySecurityDescriptor</a>) {
01130 
01131             <span class="comment">//</span>
01132             <span class="comment">// This is a get operation.  The SecurityInformation parameter</span>
01133             <span class="comment">// determines what part of the SecurityDescriptor is going to</span>
01134             <span class="comment">// be returned from the ObjectsSecurityDescriptor.</span>
01135             <span class="comment">//</span>
01136 
01137             <a class="code" href="../../d4/d9/ke_8h.html#a28">KeEnterCriticalRegion</a>();
01138             <a class="code" href="../../d5/d8/ex_8h.html#a69">ExAcquireResourceShared</a>( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a5">IopSecurityResource</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
01139             status = <a class="code" href="../../d0/d6/semethod_8c.html#a6">SeQuerySecurityDescriptorInfo</a>( SecurityInformation,
01140                                                     SecurityDescriptor,
01141                                                     CapturedLength,
01142                                                     &amp;deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o21">SecurityDescriptor</a> );
01143             <a class="code" href="../../d5/d8/ex_8h.html#a66">ExReleaseResource</a>( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a5">IopSecurityResource</a> );
01144             <a class="code" href="../../d4/d9/ke_8h.html#a29">KeLeaveCriticalRegion</a>();
01145 
01146         } <span class="keywordflow">else</span> {
01147 
01148             <span class="comment">//</span>
01149             <span class="comment">// This is a delete operation.  Simply indicate that everything</span>
01150             <span class="comment">// worked just fine.</span>
01151             <span class="comment">//</span>
01152 
01153             status = STATUS_SUCCESS;
01154 
01155         }
01156 
01157     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (OperationCode == <a class="code" href="../../d0/d5/se_8h.html#a200a110">DeleteSecurityDescriptor</a>) {
01158 
01159         <span class="comment">//</span>
01160         <span class="comment">// This is a delete operation for the security descriptor on a file</span>
01161         <span class="comment">// object.  This function will be performed by the file system once</span>
01162         <span class="comment">// the FCB itself is deleted.  Simply indicate that the operation</span>
01163         <span class="comment">// was successful.</span>
01164         <span class="comment">//</span>
01165 
01166         status = STATUS_SUCCESS;
01167 
01168     } <span class="keywordflow">else</span> {
01169 
01170         <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
01171         IO_STATUS_BLOCK localIoStatus;
01172         <a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a> event;
01173         <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpSp;
01174         <a class="code" href="../../d0/d9/ntosdef_8h.html#a39">KPROCESSOR_MODE</a> requestorMode;
01175 
01176         <span class="comment">//</span>
01177         <span class="comment">// This file object does not refer to the device itself.  Rather, it</span>
01178         <span class="comment">// refers to either a file or a directory on the device.  This means</span>
01179         <span class="comment">// that the request must be passed to the file system for processing.</span>
01180         <span class="comment">// Note that the only requests that are passed through in this manner</span>
01181         <span class="comment">// are SET or QUERY security operations.  DELETE operations have</span>
01182         <span class="comment">// already been taken care of above since the file system which just</span>
01183         <span class="comment">// drop the storage on the floor when it really needs to, and ASSIGN</span>
01184         <span class="comment">// operations are irrelevant to file systems since they never</span>
01185         <span class="comment">// generate one because they never assign the security descriptor</span>
01186         <span class="comment">// to the object in the first place, they just assign it to the FCB.</span>
01187         <span class="comment">//</span>
01188 
01189         requestorMode = KeGetPreviousMode();
01190 
01191         <span class="comment">//</span>
01192         <span class="comment">// Begin by referencing the object by pointer.   Note that the object</span>
01193         <span class="comment">// handle has already been checked for the appropriate access by the</span>
01194         <span class="comment">// object system caller.  This reference must be performed because</span>
01195         <span class="comment">// standard I/O completion will dereference the object.</span>
01196         <span class="comment">//</span>
01197 
01198         <a class="code" href="../../d4/d0/ob_8h.html#a15">ObReferenceObject</a>( fileObject );
01199 
01200         <span class="comment">//</span>
01201         <span class="comment">// Make a special check here to determine whether this is a synchronous</span>
01202         <span class="comment">// I/O operation.  If it is, then wait here until the file is owned by</span>
01203         <span class="comment">// the current thread.  If this is not a (serialized) synchronous I/O</span>
01204         <span class="comment">// operation, then initialize the local event.</span>
01205         <span class="comment">//</span>
01206 
01207         <span class="keywordflow">if</span> (fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a151">FO_SYNCHRONOUS_IO</a>) {
01208 
01209             BOOLEAN interrupted;
01210 
01211             <span class="keywordflow">if</span> (!<a class="code" href="../../d0/d6/iop_8h.html#a13">IopAcquireFastLock</a>( fileObject )) {
01212                 status = <a class="code" href="../../d0/d6/iop_8h.html#a147">IopAcquireFileObjectLock</a>( fileObject,
01213                                                    requestorMode,
01214                                                    (BOOLEAN) ((fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a152">FO_ALERTABLE_IO</a>) != 0),
01215                                                    &amp;interrupted );
01216                 <span class="keywordflow">if</span> (interrupted) {
01217                     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
01218                     <span class="keywordflow">return</span> status;
01219                 }
01220             }
01221             synchronousIo = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01222         } <span class="keywordflow">else</span> {
01223             <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( &amp;event, SynchronizationEvent, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
01224             synchronousIo = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01225         }
01226 
01227         <span class="comment">//</span>
01228         <span class="comment">// Set the file object to the Not-Signaled state.</span>
01229         <span class="comment">//</span>
01230 
01231         <a class="code" href="../../d4/d9/ke_8h.html#a21">KeClearEvent</a>( &amp;fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o25">Event</a> );
01232 
01233         <span class="comment">//</span>
01234         <span class="comment">// Get the address of the target device object.</span>
01235         <span class="comment">//</span>
01236 
01237         deviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a76">IoGetRelatedDeviceObject</a>( fileObject );
01238 
01239         <span class="comment">//</span>
01240         <span class="comment">// Allocate and initialize the I/O Request Packet (IRP) for this</span>
01241         <span class="comment">// operation.  The allocation is performed with an exception handler</span>
01242         <span class="comment">// in case the caller does not have enough quota to allocate the packet.</span>
01243 
01244         irp = <a class="code" href="../../d4/d6/iosubs_8c.html#a17">IoAllocateIrp</a>( deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o13">StackSize</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
01245         <span class="keywordflow">if</span> (!irp) {
01246 
01247             <span class="comment">//</span>
01248             <span class="comment">// An IRP could not be allocated.  Cleanup and return an</span>
01249             <span class="comment">// appropriate error status code.</span>
01250             <span class="comment">//</span>
01251 
01252             <a class="code" href="../../d0/d6/iop_8h.html#a148">IopAllocateIrpCleanup</a>( fileObject, (<a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
01253 
01254             <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
01255         }
01256         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.OriginalFileObject = fileObject;
01257         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.Thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
01258         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o10">RequestorMode</a> = requestorMode;
01259 
01260         <span class="comment">//</span>
01261         <span class="comment">// Fill in the service independent parameters in the IRP.</span>
01262         <span class="comment">//</span>
01263 
01264         <span class="keywordflow">if</span> (fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a151">FO_SYNCHRONOUS_IO</a>) {
01265             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o19">UserEvent</a> = (<a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01266         } <span class="keywordflow">else</span> {
01267             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o19">UserEvent</a> = &amp;event;
01268             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> = <a class="code" href="../../d0/d5/io_8h.html#a176">IRP_SYNCHRONOUS_API</a>;
01269         }
01270         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o18">UserIosb</a> = &amp;localIoStatus;
01271         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o24">Overlay</a>.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01272 
01273         <span class="comment">//</span>
01274         <span class="comment">// Get a pointer to the stack location for the first driver.  This will</span>
01275         <span class="comment">// be used to pass the original function codes and parameters.</span>
01276         <span class="comment">//</span>
01277 
01278         irpSp = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>( irp );
01279 
01280         <span class="comment">//</span>
01281         <span class="comment">// Now determine whether this is a set or a query operation.</span>
01282         <span class="comment">//</span>
01283 
01284         <span class="keywordflow">if</span> (OperationCode == <a class="code" href="../../d0/d5/se_8h.html#a200a109">QuerySecurityDescriptor</a>) {
01285 
01286             <span class="comment">//</span>
01287             <span class="comment">// This is a query operation.  Fill in the appropriate fields in</span>
01288             <span class="comment">// the stack location for the packet, as well as the fixed part</span>
01289             <span class="comment">// of the packet.  Note that each of these parameters has been</span>
01290             <span class="comment">// captured as well, so there is no need to perform any probing.</span>
01291             <span class="comment">// The only exception is the UserBuffer memory may change, but</span>
01292             <span class="comment">// that is the file system's responsibility to check.  Note that</span>
01293             <span class="comment">// it has already been probed, so the pointer is at least not</span>
01294             <span class="comment">// in an address space that the caller should not be accessing</span>
01295             <span class="comment">// because of mode.</span>
01296             <span class="comment">//</span>
01297 
01298             irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a> = <a class="code" href="../../d0/d5/io_8h.html#a33">IRP_MJ_QUERY_SECURITY</a>;
01299             irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.QuerySecurity.SecurityInformation = *SecurityInformation;
01300             irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.QuerySecurity.Length = *CapturedLength;
01301             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o26">UserBuffer</a> = SecurityDescriptor;
01302 
01303         } <span class="keywordflow">else</span> {
01304 
01305             <span class="comment">//</span>
01306             <span class="comment">// This is a set operation.  Fill in the appropriate fields in</span>
01307             <span class="comment">// the stack location for the packet.  Note that access to the</span>
01308             <span class="comment">// SecurityInformation parameter is safe, as the parameter was</span>
01309             <span class="comment">// captured by the caller.  Likewise, the SecurityDescriptor</span>
01310             <span class="comment">// refers to a captured copy of the descriptor.</span>
01311             <span class="comment">//</span>
01312 
01313             irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a> = <a class="code" href="../../d0/d5/io_8h.html#a34">IRP_MJ_SET_SECURITY</a>;
01314             irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.SetSecurity.SecurityInformation = *SecurityInformation;
01315             irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.SetSecurity.SecurityDescriptor = SecurityDescriptor;
01316 
01317         }
01318 
01319         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a> = fileObject;
01320 
01321         <span class="comment">//</span>
01322         <span class="comment">// Insert the packet at the head of the IRP list for the thread.</span>
01323         <span class="comment">//</span>
01324 
01325         <a class="code" href="../../d0/d6/iop_8h.html#a21">IopQueueThreadIrp</a>( irp );
01326 
01327         <span class="comment">//</span>
01328         <span class="comment">// Update the operation count statistic for the current process for</span>
01329         <span class="comment">// operations other than read and write.</span>
01330         <span class="comment">//</span>
01331 
01332         <a class="code" href="../../d4/d6/iosubs_8c.html#a129">IopUpdateOtherOperationCount</a>();
01333 
01334         <span class="comment">//</span>
01335         <span class="comment">// Everything has been properly set up, so simply invoke the driver.</span>
01336         <span class="comment">//</span>
01337 
01338         status = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>( deviceObject, irp );
01339 
01340         <span class="comment">//</span>
01341         <span class="comment">// If this operation was a synchronous I/O operation, check the return</span>
01342         <span class="comment">// status to determine whether or not to wait on the file object.  If</span>
01343         <span class="comment">// the file object is to be waited on, wait for the operation to be</span>
01344         <span class="comment">// completed and obtain the final status from the file object itself.</span>
01345         <span class="comment">//</span>
01346 
01347         <span class="keywordflow">if</span> (synchronousIo) {
01348             <span class="keywordflow">if</span> (status == STATUS_PENDING) {
01349                 (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o25">Event</a>,
01350                                               <a class="code" href="../../d6/d7/halmips_8h.html#a455">Executive</a>,
01351                                               <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
01352                                               <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
01353                                               (PLARGE_INTEGER) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
01354                 status = fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o8">FinalStatus</a>;
01355             }
01356             <a class="code" href="../../d0/d6/iop_8h.html#a22">IopReleaseFileObjectLock</a>( fileObject );
01357 
01358         } <span class="keywordflow">else</span> {
01359 
01360             <span class="comment">//</span>
01361             <span class="comment">// This is a normal synchronous I/O operation, as opposed to a</span>
01362             <span class="comment">// serialized synchronous I/O operation.  For this case, wait</span>
01363             <span class="comment">// for the local event and return the final status information</span>
01364             <span class="comment">// back to the caller.</span>
01365             <span class="comment">//</span>
01366 
01367             <span class="keywordflow">if</span> (status == STATUS_PENDING) {
01368                 (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;event,
01369                                               <a class="code" href="../../d6/d7/halmips_8h.html#a455">Executive</a>,
01370                                               <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
01371                                               <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
01372                                               (PLARGE_INTEGER) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
01373                 status = localIoStatus.Status;
01374             }
01375         }
01376 
01377         <span class="comment">//</span>
01378         <span class="comment">// If this operation was just attempted on a file system or a device</span>
01379         <span class="comment">// driver of some kind that does not implement security, then return</span>
01380         <span class="comment">// a normal null security descriptor.</span>
01381         <span class="comment">//</span>
01382 
01383         <span class="keywordflow">if</span> (status == STATUS_INVALID_DEVICE_REQUEST) {
01384 
01385             <span class="comment">//</span>
01386             <span class="comment">// The file system does not implement a security policy.  Determine</span>
01387             <span class="comment">// what type of operation this was and implement the correct</span>
01388             <span class="comment">// semantics for the file system.</span>
01389             <span class="comment">//</span>
01390 
01391             <span class="keywordflow">if</span> (OperationCode == <a class="code" href="../../d0/d5/se_8h.html#a200a109">QuerySecurityDescriptor</a>) {
01392 
01393                 <span class="comment">//</span>
01394                 <span class="comment">// The operation is a query.  If the caller's buffer is too</span>
01395                 <span class="comment">// small, then indicate that this is the case and let him know</span>
01396                 <span class="comment">// what size buffer is required.  Otherwise, attempt to return</span>
01397                 <span class="comment">// a null security descriptor.</span>
01398                 <span class="comment">//</span>
01399 
01400                <span class="keywordflow">try</span> {
01401                     status = <a class="code" href="../../d1/d5/seassign_8c.html#a5">SeAssignWorldSecurityDescriptor</a>(
01402                                  SecurityDescriptor,
01403                                  CapturedLength,
01404                                  SecurityInformation
01405                                  );
01406 
01407                 } except( <a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a> ) {
01408 
01409                     <span class="comment">//</span>
01410                     <span class="comment">// An exception was incurred while attempting to</span>
01411                     <span class="comment">// access the caller's buffer.  Clean everything</span>
01412                     <span class="comment">// up and return an appropriate status code.</span>
01413                     <span class="comment">//</span>
01414 
01415                     status = GetExceptionCode();
01416                 }
01417 
01418             } <span class="keywordflow">else</span> {
01419 
01420                 <span class="comment">//</span>
01421                 <span class="comment">// This was an operation other than a query.  Simply indicate</span>
01422                 <span class="comment">// that the operation was successful.</span>
01423                 <span class="comment">//</span>
01424 
01425                 status = STATUS_SUCCESS;
01426             }
01427 
01428         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (OperationCode == <a class="code" href="../../d0/d5/se_8h.html#a200a109">QuerySecurityDescriptor</a>) {
01429 
01430             <span class="comment">//</span>
01431             <span class="comment">// The final return status from the file system was something</span>
01432             <span class="comment">// other than invalid device request.  This means that the file</span>
01433             <span class="comment">// system actually implemented the query.  Copy the size of the</span>
01434             <span class="comment">// returned data, or the size of the buffer required in order</span>
01435             <span class="comment">// to query the security descriptor.  Note that once again the</span>
01436             <span class="comment">// assignment is performed inside of an exception handler in case</span>
01437             <span class="comment">// the caller's buffer is inaccessible.  Also note that in order</span>
01438             <span class="comment">// for the Information field of the I/O status block to be set,</span>
01439             <span class="comment">// the file system must return a warning status.  Return the</span>
01440             <span class="comment">// status that the caller expects if the buffer really is too</span>
01441             <span class="comment">// small.</span>
01442             <span class="comment">//</span>
01443 
01444             <span class="keywordflow">if</span> (status == STATUS_BUFFER_OVERFLOW) {
01445                 status = STATUS_BUFFER_TOO_SMALL;
01446             }
01447 
01448             <span class="keywordflow">try</span> {
01449 
01450                 *CapturedLength = (ULONG) localIoStatus.Information;
01451 
01452             } except( <a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a> ) {
01453                 status = GetExceptionCode();
01454             }
01455         }
01456     }
01457 
01458     <span class="keywordflow">return</span> status;
01459 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:41:05 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
