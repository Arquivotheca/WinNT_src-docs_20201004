<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: iniaxp64.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>iniaxp64.c</h1><a href="../../d3/d1/iniaxp64_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1990  Microsoft Corporation</span>
00004 <span class="comment">Copyright (c) 1992  Digital Equipment Corporation</span>
00005 <span class="comment"></span>
00006 <span class="comment">Module Name:</span>
00007 <span class="comment"></span>
00008 <span class="comment">    initalpha.c</span>
00009 <span class="comment"></span>
00010 <span class="comment">Abstract:</span>
00011 <span class="comment"></span>
00012 <span class="comment">    This module contains the machine dependent initialization for the</span>
00013 <span class="comment">    memory management component. It is specifically tailored to the</span>
00014 <span class="comment">    ALPHA architecture.</span>
00015 <span class="comment"></span>
00016 <span class="comment">Author:</span>
00017 <span class="comment"></span>
00018 <span class="comment">    Lou Perazzoli (loup) 3-Apr-1990</span>
00019 <span class="comment">    Joe Notarangelo  23-Apr-1992    ALPHA version</span>
00020 <span class="comment"></span>
00021 <span class="comment">Revision History:</span>
00022 <span class="comment"></span>
00023 <span class="comment">    Landy Wang (landyw) 02-June-1998 : Modifications for full 3-level 64-bit NT.</span>
00024 <span class="comment"></span>
00025 <span class="comment">--*/</span>
00026 
00027 <span class="preprocessor">#include "<a class="code" href="../../d4/d8/mi_8h.html">mi.h</a>"</span>
00028 <span class="preprocessor">#include &lt;<a class="code" href="../../d0/d1/inbv_8h.html">inbv.h</a>&gt;</span>
00029 
00030 <span class="comment">//</span>
00031 <span class="comment">// Local definitions.</span>
00032 <span class="comment">//</span>
00033 
<a name="l00034"></a><a class="code" href="../../d3/d1/iniaxp64_8c.html#a0">00034</a> <span class="preprocessor">#define _1mbInPages  (0x100000 &gt;&gt; PAGE_SHIFT)</span>
<a name="l00035"></a><a class="code" href="../../d3/d1/iniaxp64_8c.html#a1">00035</a> <span class="preprocessor"></span><span class="preprocessor">#define _4gbInPages (0x100000000 &gt;&gt; PAGE_SHIFT)</span>
00036 <span class="preprocessor"></span>
00037 <span class="comment">//</span>
00038 <span class="comment">// Local data.</span>
00039 <span class="comment">//</span>
00040 
<a name="l00041"></a><a class="code" href="../../d3/d1/iniaxp64_8c.html#a2">00041</a> <a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html">PMEMORY_ALLOCATION_DESCRIPTOR</a> <a class="code" href="../../d3/d1/iniaxp64_8c.html#a2">MxFreeDescriptor</a>;
<a name="l00042"></a><a class="code" href="../../d3/d1/iniaxp64_8c.html#a3">00042</a> PFN_NUMBER <a class="code" href="../../d3/d1/iniaxp64_8c.html#a3">MxNextPhysicalPage</a>;
<a name="l00043"></a><a class="code" href="../../d3/d1/iniaxp64_8c.html#a4">00043</a> PFN_NUMBER <a class="code" href="../../d3/d1/iniaxp64_8c.html#a4">MxNumberOfPages</a>;
00044 
00045 PFN_NUMBER
<a name="l00046"></a><a class="code" href="../../d3/d1/iniaxp64_8c.html#a5">00046</a> <a class="code" href="../../d3/d1/iniaxp64_8c.html#a5">MxGetNextPage</a> (
00047     VOID
00048     )
00049 
00050 <span class="comment">/*++</span>
00051 <span class="comment"></span>
00052 <span class="comment">Routine Description:</span>
00053 <span class="comment"></span>
00054 <span class="comment">    This function returns the next physical page number from either the</span>
00055 <span class="comment">    largest low memory descritor or the largest free descriptor. If there</span>
00056 <span class="comment">    are no physical pages left, then a bugcheck is executed since the</span>
00057 <span class="comment">    system cannot be initialized.</span>
00058 <span class="comment"></span>
00059 <span class="comment">Arguments:</span>
00060 <span class="comment"></span>
00061 <span class="comment">    LoaderBlock - Supplies the address of the loader block.</span>
00062 <span class="comment"></span>
00063 <span class="comment">Return Value:</span>
00064 <span class="comment"></span>
00065 <span class="comment">    None.</span>
00066 <span class="comment"></span>
00067 <span class="comment">Environment:</span>
00068 <span class="comment"></span>
00069 <span class="comment">    Kernel mode.</span>
00070 <span class="comment"></span>
00071 <span class="comment">--*/</span>
00072 
00073 {
00074 
00075     <span class="comment">//</span>
00076     <span class="comment">// If there are free pages left in the current descriptor, then</span>
00077     <span class="comment">// return the next physical page. Otherwise, attempt to switch</span>
00078     <span class="comment">// descriptors.</span>
00079     <span class="comment">//</span>
00080 
00081     <span class="keywordflow">if</span> (<a class="code" href="../../d3/d1/iniaxp64_8c.html#a4">MxNumberOfPages</a> != 0) {
00082         <a class="code" href="../../d3/d1/iniaxp64_8c.html#a4">MxNumberOfPages</a> -= 1;
00083         <span class="keywordflow">return</span> <a class="code" href="../../d3/d1/iniaxp64_8c.html#a3">MxNextPhysicalPage</a>++;
00084 
00085     } <span class="keywordflow">else</span> {
00086 
00087         <span class="comment">//</span>
00088         <span class="comment">// If the current descriptor is not the largest free descriptor,</span>
00089         <span class="comment">// then switch to the largest free descriptor. Otherwise, bugcheck.</span>
00090         <span class="comment">//</span>
00091 
00092         <span class="keywordflow">if</span> (<a class="code" href="../../d3/d1/iniaxp64_8c.html#a3">MxNextPhysicalPage</a> ==
00093                 (<a class="code" href="../../d3/d1/iniaxp64_8c.html#a2">MxFreeDescriptor</a>-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o2">BasePage</a> + <a class="code" href="../../d3/d1/iniaxp64_8c.html#a2">MxFreeDescriptor</a>-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o3">PageCount</a>)) {
00094             <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a>(INSTALL_MORE_MEMORY,
00095                          <a class="code" href="../../d2/d1/mm_8h.html#a136">MmNumberOfPhysicalPages</a>,
00096                          <a class="code" href="../../d6/d8/sysinfo_8c.html#a6">MmLowestPhysicalPage</a>,
00097                          <a class="code" href="../../d6/d8/sysinfo_8c.html#a7">MmHighestPhysicalPage</a>,
00098                          0);
00099 
00100             <span class="keywordflow">return</span> 0;
00101 
00102         } <span class="keywordflow">else</span> {
00103             <a class="code" href="../../d3/d1/iniaxp64_8c.html#a4">MxNumberOfPages</a> = <a class="code" href="../../d3/d1/iniaxp64_8c.html#a2">MxFreeDescriptor</a>-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o3">PageCount</a> - 1;
00104             <a class="code" href="../../d3/d1/iniaxp64_8c.html#a3">MxNextPhysicalPage</a> = <a class="code" href="../../d3/d1/iniaxp64_8c.html#a2">MxFreeDescriptor</a>-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o2">BasePage</a>;
00105             <span class="keywordflow">return</span> <a class="code" href="../../d3/d1/iniaxp64_8c.html#a3">MxNextPhysicalPage</a>++;
00106         }
00107     }
00108 }
00109 
00110 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00111"></a><a class="code" href="../../d3/d1/iniaxp64_8c.html#a6">00111</a> <a class="code" href="../../d2/d3/initppc_8c.html#a1">MiInitMachineDependent</a> (
00112     IN <a class="code" href="../../d1/d2/struct__LOADER__PARAMETER__BLOCK.html">PLOADER_PARAMETER_BLOCK</a> LoaderBlock
00113     )
00114 
00115 <span class="comment">/*++</span>
00116 <span class="comment"></span>
00117 <span class="comment">Routine Description:</span>
00118 <span class="comment"></span>
00119 <span class="comment">    This routine performs the necessary operations to enable virtual</span>
00120 <span class="comment">    memory. This includes building the page directory parent pages and</span>
00121 <span class="comment">    the page directories for the system, building page table pages to map</span>
00122 <span class="comment">    the code section, the data section, the stack section and the trap handler.</span>
00123 <span class="comment">    It also initializes the PFN database and populates the free list.</span>
00124 <span class="comment"></span>
00125 <span class="comment">Arguments:</span>
00126 <span class="comment"></span>
00127 <span class="comment">    LoaderBlock - Supplies the address of the loader block.</span>
00128 <span class="comment"></span>
00129 <span class="comment">Return Value:</span>
00130 <span class="comment"></span>
00131 <span class="comment">    None.</span>
00132 <span class="comment"></span>
00133 <span class="comment">Environment:</span>
00134 <span class="comment"></span>
00135 <span class="comment">    Kernel mode.</span>
00136 <span class="comment"></span>
00137 <span class="comment">--*/</span>
00138 
00139 {
00140     LOGICAL First;
00141     <a class="code" href="../../d1/d1/bench_8c.html#a16">CHAR</a> <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>[256];
00142     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> BasePfn;
00143     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> BottomPfn;
00144     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> TopPfn;
00145     PFN_NUMBER i;
00146     ULONG j;
00147     PFN_NUMBER HighPage;
00148     PFN_NUMBER PagesLeft;
00149     PFN_NUMBER PageNumber;
00150     PFN_NUMBER PtePage;
00151     PFN_NUMBER PdePage;
00152     PFN_NUMBER PpePage;
00153     PFN_NUMBER FrameNumber;
00154     PFN_NUMBER PfnAllocation;
00155     <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> CurrentProcess;
00156     PVOID SpinLockPage;
00157     PFN_NUMBER MostFreePage;
00158     PFN_NUMBER MostFreeLowMem;
00159     PLIST_ENTRY NextMd;
00160     SIZE_T MaxPool;
00161     PFN_NUMBER NextPhysicalPage;
00162     KIRQL OldIrql;
00163     <a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html">PMEMORY_ALLOCATION_DESCRIPTOR</a> FreeDescriptorLowMem;
00164     <a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html">PMEMORY_ALLOCATION_DESCRIPTOR</a> MemoryDescriptor;
00165     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> TempPte;
00166     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPde;
00167     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
00168     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> LastPte;
00169     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> CacheStackPage;
00170     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> Pde;
00171     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> StartPpe;
00172     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> StartPde;
00173     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> StartPte;
00174     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> EndPpe;
00175     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> EndPde;
00176     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> EndPte;
00177     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn1;
00178     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn2;
00179     PULONG PointerLong;
00180     <a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html">PMMFREE_POOL_ENTRY</a> Entry;
00181     PVOID NonPagedPoolStartVirtual;
00182     ULONG Range;
00183 
00184     MostFreePage = 0;
00185     MostFreeLowMem = 0;
00186     FreeDescriptorLowMem = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00187 
00188     <span class="comment">//</span>
00189     <span class="comment">// Get the lower bound of the free physical memory and the number of</span>
00190     <span class="comment">// physical pages by walking the memory descriptor lists. In addition,</span>
00191     <span class="comment">// find the memory descriptor with the most free pages that is within</span>
00192     <span class="comment">// the first 4gb of physical memory. This memory can be used to allocate</span>
00193     <span class="comment">// common buffers for use by PCI devices that cannot address more than</span>
00194     <span class="comment">// 32 bits. Also find the largest free memory descriptor.</span>
00195     <span class="comment">//</span>
00196 
00197     <span class="comment">//</span>
00198     <span class="comment">// When restoring a hibernation image, OS Loader needs to use "a few" extra</span>
00199     <span class="comment">// pages of LoaderFree memory.</span>
00200     <span class="comment">// This is not accounted for when reserving memory for hibernation below.</span>
00201     <span class="comment">// Start with a safety margin to allow for this plus modest future increase.</span>
00202     <span class="comment">//</span>
00203 
00204     <a class="code" href="../../d4/d8/mi_8h.html#a427">MmHiberPages</a> = 96;
00205 
00206     NextMd = LoaderBlock-&gt;MemoryDescriptorListHead.Flink;
00207     <span class="keywordflow">while</span> (NextMd != &amp;LoaderBlock-&gt;MemoryDescriptorListHead) {
00208         MemoryDescriptor = CONTAINING_RECORD(NextMd,
00209                                              <a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html">MEMORY_ALLOCATION_DESCRIPTOR</a>,
00210                                              ListEntry);
00211 
00212         HighPage = MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o2">BasePage</a> + MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o3">PageCount</a> - 1;
00213 
00214         <span class="comment">//</span>
00215         <span class="comment">// This check results in /BURNMEMORY chunks not being counted.</span>
00216         <span class="comment">//</span>
00217 
00218         <span class="keywordflow">if</span> (MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o1">MemoryType</a> != <a class="code" href="../../d1/d9/arc_8h.html#a320a257">LoaderBad</a>) {
00219             <a class="code" href="../../d2/d1/mm_8h.html#a136">MmNumberOfPhysicalPages</a> += (PFN_COUNT)MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o3">PageCount</a>;
00220         }
00221 
00222         <span class="comment">//</span>
00223         <span class="comment">// If the lowest page is lower than the lowest page encountered</span>
00224         <span class="comment">// so far, then set the new low page number.</span>
00225         <span class="comment">//</span>
00226 
00227         <span class="keywordflow">if</span> (MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o2">BasePage</a> &lt; <a class="code" href="../../d6/d8/sysinfo_8c.html#a6">MmLowestPhysicalPage</a>) {
00228             <a class="code" href="../../d6/d8/sysinfo_8c.html#a6">MmLowestPhysicalPage</a> = MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o2">BasePage</a>;
00229         }
00230 
00231         <span class="comment">//</span>
00232         <span class="comment">// If the highest page is greater than the highest page encountered</span>
00233         <span class="comment">// so far, then set the new high page number.</span>
00234         <span class="comment">//</span>
00235 
00236         <span class="keywordflow">if</span> (HighPage &gt; <a class="code" href="../../d6/d8/sysinfo_8c.html#a7">MmHighestPhysicalPage</a>) {
00237             <a class="code" href="../../d6/d8/sysinfo_8c.html#a7">MmHighestPhysicalPage</a> = HighPage;
00238         }
00239 
00240         <span class="comment">//</span>
00241         <span class="comment">// Locate the largest free block starting below 4GB and the largest</span>
00242         <span class="comment">// free block.</span>
00243         <span class="comment">//</span>
00244 
00245         <span class="keywordflow">if</span> ((MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o1">MemoryType</a> == <a class="code" href="../../d1/d9/arc_8h.html#a320a256">LoaderFree</a>) ||
00246             (MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o1">MemoryType</a> == <a class="code" href="../../d1/d9/arc_8h.html#a320a258">LoaderLoadedProgram</a>) ||
00247             (MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o1">MemoryType</a> == <a class="code" href="../../d1/d9/arc_8h.html#a320a259">LoaderFirmwareTemporary</a>) ||
00248             (MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o1">MemoryType</a> == <a class="code" href="../../d1/d9/arc_8h.html#a320a262">LoaderOsloaderStack</a>)) {
00249 
00250             <span class="comment">//</span>
00251             <span class="comment">// Every page that will be used as free memory that is not already</span>
00252             <span class="comment">// marked as LoaderFree must be counted so a hibernate can reserve</span>
00253             <span class="comment">// the proper amount.</span>
00254             <span class="comment">//</span>
00255 
00256             <span class="keywordflow">if</span> (MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o1">MemoryType</a> != <a class="code" href="../../d1/d9/arc_8h.html#a320a256">LoaderFree</a>) {
00257                 <a class="code" href="../../d4/d8/mi_8h.html#a427">MmHiberPages</a> += MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o3">PageCount</a>;
00258             }
00259 
00260             <span class="keywordflow">if</span> ((MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o3">PageCount</a> &gt; MostFreeLowMem) &amp;&amp;
00261                 (MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o2">BasePage</a> &lt; <a class="code" href="../../d3/d1/iniaxp64_8c.html#a1">_4gbInPages</a>) &amp;&amp;
00262                 (HighPage &lt; <a class="code" href="../../d3/d1/iniaxp64_8c.html#a1">_4gbInPages</a>)) {
00263                 MostFreeLowMem = MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o3">PageCount</a>;
00264                 FreeDescriptorLowMem = MemoryDescriptor;
00265 
00266             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o3">PageCount</a> &gt; MostFreePage) {
00267                 MostFreePage = MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o3">PageCount</a>;
00268                 <a class="code" href="../../d3/d1/iniaxp64_8c.html#a2">MxFreeDescriptor</a> = MemoryDescriptor;
00269             }
00270         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o1">MemoryType</a> == <a class="code" href="../../d1/d9/arc_8h.html#a320a261">LoaderOsloaderHeap</a>) {
00271             <span class="comment">//</span>
00272             <span class="comment">// We do not want to use this memory yet as it still has important</span>
00273             <span class="comment">// data structures in it. But we still want to account for this in</span>
00274             <span class="comment">// the hibernation pages</span>
00275             <span class="comment">//</span>
00276             <a class="code" href="../../d4/d8/mi_8h.html#a427">MmHiberPages</a> += MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o3">PageCount</a>;
00277         }
00278 
00279         NextMd = MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o0">ListEntry</a>.Flink;
00280     }
00281 
00282     <a class="code" href="../../d2/d3/dumpctl_8c.html#a16">MmHighestPossiblePhysicalPage</a> = <a class="code" href="../../d6/d8/sysinfo_8c.html#a7">MmHighestPhysicalPage</a>;
00283 
00284     <span class="comment">//</span>
00285     <span class="comment">// Perform sanity checks on the results of walking the memory</span>
00286     <span class="comment">// descriptors.</span>
00287     <span class="comment">//</span>
00288     <span class="comment">// If the number of physical pages is less that 1024 (i.e., 8mb), then</span>
00289     <span class="comment">// bugcheck. There is not enough memory to run the system.</span>
00290     <span class="comment">//</span>
00291 
00292     <span class="keywordflow">if</span> (<a class="code" href="../../d2/d1/mm_8h.html#a136">MmNumberOfPhysicalPages</a> &lt; 1024) {
00293         <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a>(INSTALL_MORE_MEMORY,
00294                      <a class="code" href="../../d2/d1/mm_8h.html#a136">MmNumberOfPhysicalPages</a>,
00295                      <a class="code" href="../../d6/d8/sysinfo_8c.html#a6">MmLowestPhysicalPage</a>,
00296                      <a class="code" href="../../d6/d8/sysinfo_8c.html#a7">MmHighestPhysicalPage</a>,
00297                      0);
00298     }
00299 
00300     <span class="comment">//</span>
00301     <span class="comment">// If there is no free descriptor below 4gb, then it is not possible to</span>
00302     <span class="comment">// run devices that only support 32 address bits. It is also highly</span>
00303     <span class="comment">// unlikely that the configuration data is correct so bugcheck.</span>
00304     <span class="comment">//</span>
00305 
00306     <span class="keywordflow">if</span> (FreeDescriptorLowMem == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00307         <a class="code" href="../../d0/d1/inbv_8h.html#a9">InbvDisplayString</a>(<span class="stringliteral">"MmInit *** FATAL ERROR *** no free memory below 4gb\n"</span>);
00308         <a class="code" href="../../d9/d1/bugcheck_8c.html#a13">KeBugCheck</a>(MEMORY_MANAGEMENT);
00309     }
00310 
00311     <span class="comment">//</span>
00312     <span class="comment">// Set the initial nonpaged frame allocation parameters.</span>
00313     <span class="comment">//</span>
00314 
00315     <a class="code" href="../../d3/d1/iniaxp64_8c.html#a3">MxNextPhysicalPage</a> = FreeDescriptorLowMem-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o2">BasePage</a>;
00316     <a class="code" href="../../d3/d1/iniaxp64_8c.html#a4">MxNumberOfPages</a> = FreeDescriptorLowMem-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o3">PageCount</a>;
00317 
00318     <span class="comment">//</span>
00319     <span class="comment">// Compute the initial and maximum size of nonpaged pool. The initial</span>
00320     <span class="comment">// allocation of nonpaged pool is such that it is both virtually and</span>
00321     <span class="comment">// physically contiguous.</span>
00322     <span class="comment">//</span>
00323     <span class="comment">// If the size of the initial nonpaged pool was initialized from the</span>
00324     <span class="comment">// registry and is greater than 7/8 of physical memory, then force the</span>
00325     <span class="comment">// size of the initial nonpaged pool to be computed.</span>
00326     <span class="comment">//</span>
00327 
00328     <span class="keywordflow">if</span> ((<a class="code" href="../../d8/d0/cmdat3_8c.html#a19">MmSizeOfNonPagedPoolInBytes</a> &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>) &gt;
00329                                     (7 * (<a class="code" href="../../d2/d1/mm_8h.html#a136">MmNumberOfPhysicalPages</a> &gt;&gt; 3))) {
00330         <a class="code" href="../../d8/d0/cmdat3_8c.html#a19">MmSizeOfNonPagedPoolInBytes</a> = 0;
00331     }
00332 
00333     <span class="comment">//</span>
00334     <span class="comment">// If the size of the initial nonpaged pool is less than the minimum</span>
00335     <span class="comment">// amount, then compute the size of initial nonpaged pool as the minimum</span>
00336     <span class="comment">// size up to 8mb and a computed amount for every 1mb thereafter.</span>
00337     <span class="comment">//</span>
00338 
00339     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a19">MmSizeOfNonPagedPoolInBytes</a> &lt; <a class="code" href="../../d4/d8/mi_8h.html#a620">MmMinimumNonPagedPoolSize</a>) {
00340         <a class="code" href="../../d8/d0/cmdat3_8c.html#a19">MmSizeOfNonPagedPoolInBytes</a> = <a class="code" href="../../d4/d8/mi_8h.html#a620">MmMinimumNonPagedPoolSize</a>;
00341         <span class="keywordflow">if</span> (<a class="code" href="../../d2/d1/mm_8h.html#a136">MmNumberOfPhysicalPages</a> &gt; 1024) {
00342             <a class="code" href="../../d8/d0/cmdat3_8c.html#a19">MmSizeOfNonPagedPoolInBytes</a> +=
00343                 ((<a class="code" href="../../d2/d1/mm_8h.html#a136">MmNumberOfPhysicalPages</a> - 1024) / <a class="code" href="../../d3/d1/iniaxp64_8c.html#a0">_1mbInPages</a>) *
00344                                                 <a class="code" href="../../d4/d8/mi_8h.html#a622">MmMinAdditionNonPagedPoolPerMb</a>;
00345         }
00346     }
00347 
00348     <span class="comment">//</span>
00349     <span class="comment">// Align the size of the initial nonpaged pool to page size boundary.</span>
00350     <span class="comment">//</span>
00351 
00352     <a class="code" href="../../d8/d0/cmdat3_8c.html#a19">MmSizeOfNonPagedPoolInBytes</a> &amp;= ~(<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1);
00353 
00354     <span class="comment">//</span>
00355     <span class="comment">// Limit initial nonpaged pool size to the maximum allowable size.</span>
00356     <span class="comment">//</span>
00357 
00358     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a19">MmSizeOfNonPagedPoolInBytes</a> &gt; <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a30">MM_MAX_INITIAL_NONPAGED_POOL</a>) {
00359         <a class="code" href="../../d8/d0/cmdat3_8c.html#a19">MmSizeOfNonPagedPoolInBytes</a> = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a30">MM_MAX_INITIAL_NONPAGED_POOL</a>;
00360     }
00361 
00362     <span class="comment">//</span>
00363     <span class="comment">// If the computed size of the initial nonpaged pool will not fit in the</span>
00364     <span class="comment">// largest low memory descriptor, then recompute the size of nonpaged pool</span>
00365     <span class="comment">// to be the size of the largest low memory descriptor. If the largest</span>
00366     <span class="comment">// low memory descriptor does not contain the minimum initial nonpaged</span>
00367     <span class="comment">// pool size, then the system cannot be booted.</span>
00368     <span class="comment">//</span>
00369 
00370     <span class="keywordflow">if</span> ((<a class="code" href="../../d8/d0/cmdat3_8c.html#a19">MmSizeOfNonPagedPoolInBytes</a> &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>) &gt; <a class="code" href="../../d3/d1/iniaxp64_8c.html#a4">MxNumberOfPages</a>) {
00371 
00372         <span class="comment">//</span>
00373         <span class="comment">// Reserve all of low memory for nonpaged pool.</span>
00374         <span class="comment">//</span>
00375 
00376         <a class="code" href="../../d8/d0/cmdat3_8c.html#a19">MmSizeOfNonPagedPoolInBytes</a> = <a class="code" href="../../d3/d1/iniaxp64_8c.html#a4">MxNumberOfPages</a> &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>;
00377         <span class="keywordflow">if</span>(<a class="code" href="../../d8/d0/cmdat3_8c.html#a19">MmSizeOfNonPagedPoolInBytes</a> &lt; <a class="code" href="../../d4/d8/mi_8h.html#a620">MmMinimumNonPagedPoolSize</a>) {
00378            <a class="code" href="../../d0/d1/inbv_8h.html#a9">InbvDisplayString</a>(<span class="stringliteral">"MmInit *** FATAL ERROR *** cannot allocate nonpaged pool\n"</span>);
00379            <a class="code" href="../../d6/d9/heappage_8c.html#a68">sprintf</a>(<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>,
00380                    <span class="stringliteral">"Largest description = %d pages, require %d pages\n"</span>,
00381                    <a class="code" href="../../d3/d1/iniaxp64_8c.html#a4">MxNumberOfPages</a>,
00382                    <a class="code" href="../../d4/d8/mi_8h.html#a620">MmMinimumNonPagedPoolSize</a> &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
00383 
00384            <a class="code" href="../../d0/d1/inbv_8h.html#a9">InbvDisplayString</a>(<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>);
00385            <a class="code" href="../../d9/d1/bugcheck_8c.html#a13">KeBugCheck</a>(MEMORY_MANAGEMENT);
00386         }
00387     }
00388 
00389     <span class="comment">//</span>
00390     <span class="comment">// Reserve the physically and virtually contiguous memory that maps</span>
00391     <span class="comment">// the initial nonpaged pool and set page frame allocation parameters.</span>
00392     <span class="comment">//</span>
00393 
00394     <a class="code" href="../../d3/d1/iniaxp64_8c.html#a3">MxNextPhysicalPage</a> += (PFN_NUMBER)(<a class="code" href="../../d8/d0/cmdat3_8c.html#a19">MmSizeOfNonPagedPoolInBytes</a> &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
00395     <a class="code" href="../../d3/d1/iniaxp64_8c.html#a4">MxNumberOfPages</a> -= (PFN_NUMBER)(<a class="code" href="../../d8/d0/cmdat3_8c.html#a19">MmSizeOfNonPagedPoolInBytes</a> &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
00396 
00397     <span class="comment">//</span>
00398     <span class="comment">// Calculate the maximum size of nonpaged pool.</span>
00399     <span class="comment">//</span>
00400 
00401     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d5/kddata_8c.html#a21">MmMaximumNonPagedPoolInBytes</a> == 0) {
00402 
00403         <span class="comment">//</span>
00404         <span class="comment">// Calculate the size of nonpaged pool. If 8mb or less use the</span>
00405         <span class="comment">// minimum size, then for every MB above 8mb add extra pages.</span>
00406         <span class="comment">//</span>
00407 
00408         <a class="code" href="../../d8/d5/kddata_8c.html#a21">MmMaximumNonPagedPoolInBytes</a> = <a class="code" href="../../d4/d8/mi_8h.html#a621">MmDefaultMaximumNonPagedPool</a>;
00409 
00410         <span class="comment">//</span>
00411         <span class="comment">// Make sure enough expansion for PFN database exists.</span>
00412         <span class="comment">//</span>
00413 
00414         <a class="code" href="../../d8/d5/kddata_8c.html#a21">MmMaximumNonPagedPoolInBytes</a> +=
00415             ((ULONG_PTR)<a class="code" href="../../d2/d1/mm_8h.html#a7">PAGE_ALIGN</a>((<a class="code" href="../../d6/d8/sysinfo_8c.html#a7">MmHighestPhysicalPage</a> + 1) * <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d3/struct__MMPFN.html">MMPFN</a>)));
00416 
00417         <span class="comment">//</span>
00418         <span class="comment">// If the number of physical pages is greater than 8mb, then compute</span>
00419         <span class="comment">// an additional amount for every 1mb thereafter.</span>
00420         <span class="comment">//</span>
00421 
00422         <span class="keywordflow">if</span> (<a class="code" href="../../d2/d1/mm_8h.html#a136">MmNumberOfPhysicalPages</a> &gt; 1024) {
00423             <a class="code" href="../../d8/d5/kddata_8c.html#a21">MmMaximumNonPagedPoolInBytes</a> +=
00424                 ((<a class="code" href="../../d2/d1/mm_8h.html#a136">MmNumberOfPhysicalPages</a> - 1024) / <a class="code" href="../../d3/d1/iniaxp64_8c.html#a0">_1mbInPages</a>) *
00425                                                 <a class="code" href="../../d4/d8/mi_8h.html#a623">MmMaxAdditionNonPagedPoolPerMb</a>;
00426         }
00427 
00428         <span class="comment">//</span>
00429         <span class="comment">// If the maximum size of nonpaged pool is greater than the maximum</span>
00430         <span class="comment">// default size of nonpaged pool, then limit the maximum size of</span>
00431         <span class="comment">// onopaged pool to the maximum default size.</span>
00432         <span class="comment">//</span>
00433 
00434         <span class="keywordflow">if</span> (<a class="code" href="../../d8/d5/kddata_8c.html#a21">MmMaximumNonPagedPoolInBytes</a> &gt; <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a33">MM_MAX_DEFAULT_NONPAGED_POOL</a>) {
00435             <a class="code" href="../../d8/d5/kddata_8c.html#a21">MmMaximumNonPagedPoolInBytes</a> = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a33">MM_MAX_DEFAULT_NONPAGED_POOL</a>;
00436         }
00437     }
00438 
00439     <span class="comment">//</span>
00440     <span class="comment">// Align the maximum size of nonpaged pool to page size boundary.</span>
00441     <span class="comment">//</span>
00442 
00443     <a class="code" href="../../d8/d5/kddata_8c.html#a21">MmMaximumNonPagedPoolInBytes</a> &amp;= ~(<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1);
00444 
00445     <span class="comment">//</span>
00446     <span class="comment">// Compute the maximum size of nonpaged pool to include 16 additional</span>
00447     <span class="comment">// pages and enough space to map the PFN database.</span>
00448     <span class="comment">//</span>
00449 
00450     MaxPool = <a class="code" href="../../d8/d0/cmdat3_8c.html#a19">MmSizeOfNonPagedPoolInBytes</a> + (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> * 16) +
00451             ((ULONG_PTR)<a class="code" href="../../d2/d1/mm_8h.html#a7">PAGE_ALIGN</a>((<a class="code" href="../../d6/d8/sysinfo_8c.html#a7">MmHighestPhysicalPage</a> + 1) * <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d3/struct__MMPFN.html">MMPFN</a>)));
00452 
00453     <span class="comment">//</span>
00454     <span class="comment">// If the maximum size of nonpaged pool is less than the computed</span>
00455     <span class="comment">// maximum size of nonpaged pool, then set the maximum size of nonpaged</span>
00456     <span class="comment">// pool to the computed maximum size.</span>
00457     <span class="comment">//</span>
00458 
00459     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d5/kddata_8c.html#a21">MmMaximumNonPagedPoolInBytes</a> &lt; MaxPool) {
00460         <a class="code" href="../../d8/d5/kddata_8c.html#a21">MmMaximumNonPagedPoolInBytes</a> = MaxPool;
00461     }
00462 
00463     <span class="comment">//</span>
00464     <span class="comment">// Limit maximum nonpaged pool to MM_MAX_ADDITIONAL_NONPAGED_POOL.</span>
00465     <span class="comment">//</span>
00466 
00467     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d5/kddata_8c.html#a21">MmMaximumNonPagedPoolInBytes</a> &gt; <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a31">MM_MAX_ADDITIONAL_NONPAGED_POOL</a>) {
00468         <a class="code" href="../../d8/d5/kddata_8c.html#a21">MmMaximumNonPagedPoolInBytes</a> = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a31">MM_MAX_ADDITIONAL_NONPAGED_POOL</a>;
00469     }
00470 
00471     <span class="comment">//</span>
00472     <span class="comment">// Compute the starting address of nonpaged pool.</span>
00473     <span class="comment">//</span>
00474 
00475     <a class="code" href="../../d8/d5/kddata_8c.html#a23">MmNonPagedPoolStart</a> = (PCHAR)<a class="code" href="../../d8/d5/kddata_8c.html#a24">MmNonPagedPoolEnd</a> - <a class="code" href="../../d8/d5/kddata_8c.html#a21">MmMaximumNonPagedPoolInBytes</a>;
00476     NonPagedPoolStartVirtual = <a class="code" href="../../d8/d5/kddata_8c.html#a23">MmNonPagedPoolStart</a>;
00477 
00478     <span class="comment">//</span>
00479     <span class="comment">// Calculate the starting address for nonpaged system space rounded</span>
00480     <span class="comment">// down to a second level PDE mapping boundary.</span>
00481     <span class="comment">//</span>
00482 
00483     <a class="code" href="../../d8/d5/kddata_8c.html#a22">MmNonPagedSystemStart</a> = (PVOID)(((ULONG_PTR)<a class="code" href="../../d8/d5/kddata_8c.html#a23">MmNonPagedPoolStart</a> -
00484                                 (((ULONG_PTR)<a class="code" href="../../d8/d0/cmdat3_8c.html#a23">MmNumberOfSystemPtes</a> + 1) * <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>)) &amp;
00485                                                         (~<a class="code" href="../../d9/d8/axp64_2mialpha_8h.html#a48">PAGE_DIRECTORY2_MASK</a>));
00486 
00487     <span class="comment">//</span>
00488     <span class="comment">// Limit the starting address of system space to the lowest allowable</span>
00489     <span class="comment">// address for nonpaged system space.</span>
00490     <span class="comment">//</span>
00491 
00492     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d5/kddata_8c.html#a22">MmNonPagedSystemStart</a> &lt; <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a22">MM_LOWEST_NONPAGED_SYSTEM_START</a>) {
00493         <a class="code" href="../../d8/d5/kddata_8c.html#a22">MmNonPagedSystemStart</a> = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a22">MM_LOWEST_NONPAGED_SYSTEM_START</a>;
00494     }
00495 
00496     <span class="comment">//</span>
00497     <span class="comment">// Recompute the actual number of system PTEs.</span>
00498     <span class="comment">//</span>
00499 
00500     <a class="code" href="../../d8/d0/cmdat3_8c.html#a23">MmNumberOfSystemPtes</a> = (ULONG)(((ULONG_PTR)<a class="code" href="../../d8/d5/kddata_8c.html#a23">MmNonPagedPoolStart</a> -
00501                             (ULONG_PTR)<a class="code" href="../../d8/d5/kddata_8c.html#a22">MmNonPagedSystemStart</a>) &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>) - 1;
00502 
00503     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(<a class="code" href="../../d8/d0/cmdat3_8c.html#a23">MmNumberOfSystemPtes</a> &gt; 1000);
00504 
00505     <span class="comment">//</span>
00506     <span class="comment">// Set the global bit for all PPEs and PDEs in system space.</span>
00507     <span class="comment">//</span>
00508 
00509     StartPde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a151">MiGetPdeAddress</a>(<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a11">MM_SYSTEM_SPACE_START</a>);
00510     EndPde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a151">MiGetPdeAddress</a>(<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a25">MM_SYSTEM_SPACE_END</a>);
00511     First = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00512 
00513     <span class="keywordflow">while</span> (StartPde &lt;= EndPde) {
00514 
00515         <span class="keywordflow">if</span> (First == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> || <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a167">MiIsPteOnPdeBoundary</a>(StartPde)) {
00516             First = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00517             StartPpe = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>(StartPde);
00518             <span class="keywordflow">if</span> (StartPpe-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 0) {
00519                 StartPpe += 1;
00520                 StartPde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a> (StartPpe);
00521                 <span class="keywordflow">continue</span>;
00522             }
00523             TempPte = *StartPpe;
00524             TempPte.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Global = 1;
00525             *StartPpe = TempPte;
00526         }
00527 
00528         TempPte = *StartPde;
00529         TempPte.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Global = 1;
00530         *StartPde = TempPte;
00531         StartPde += 1;
00532     }
00533 
00534     <span class="comment">//</span>
00535     <span class="comment">// If HYDRA, then reset the global bit for all PPE &amp; PDEs in session space.</span>
00536     <span class="comment">//</span>
00537 
00538     <span class="keywordflow">if</span> (<a class="code" href="../../d4/d8/mi_8h.html#a581">MiHydra</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
00539 
00540         StartPde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a151">MiGetPdeAddress</a>(<a class="code" href="../../d4/d8/mi_8h.html#a748">MmSessionBase</a>);
00541         EndPde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a151">MiGetPdeAddress</a>(<a class="code" href="../../d4/d8/mi_8h.html#a351">MI_SESSION_SPACE_END</a>);
00542         First = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00543 
00544         <span class="keywordflow">while</span> (StartPde &lt; EndPde) {
00545 
00546             <span class="keywordflow">if</span> (First == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> || <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a167">MiIsPteOnPdeBoundary</a>(StartPde)) {
00547                 First = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00548                 StartPpe = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>(StartPde);
00549                 <span class="keywordflow">if</span> (StartPpe-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 0) {
00550                     StartPpe += 1;
00551                     StartPde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a> (StartPpe);
00552                     <span class="keywordflow">continue</span>;
00553                 }
00554                 TempPte = *StartPpe;
00555                 TempPte.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Global = 0;
00556                 *StartPpe = TempPte;
00557             }
00558 
00559             TempPte = *StartPde;
00560             TempPte.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Global = 0;
00561             *StartPde = TempPte;
00562 
00563             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(StartPde-&gt;u.Long == 0);
00564 
00565             StartPde += 1;
00566         }
00567     }
00568 
00569     <span class="comment">//</span>
00570     <span class="comment">// Allocate a page directory and a pair of page table pages.</span>
00571     <span class="comment">// Map the hyper space page directory page into the top level parent</span>
00572     <span class="comment">// directory &amp; the hyper space page table page into the page directory</span>
00573     <span class="comment">// and map an additional page that will eventually be used for the</span>
00574     <span class="comment">// working set list.  Page tables after the first two are set up later</span>
00575     <span class="comment">// on during individual process working set initialization.</span>
00576     <span class="comment">//</span>
00577     <span class="comment">// The working set list page will eventually be a part of hyper space.</span>
00578     <span class="comment">// It is mapped into the second level page directory page so it can be</span>
00579     <span class="comment">// zeroed and so it will be accounted for in the PFN database. Later</span>
00580     <span class="comment">// the page will be unmapped, and its page frame number captured in the</span>
00581     <span class="comment">// system process object.</span>
00582     <span class="comment">//</span>
00583 
00584     TempPte = <a class="code" href="../../d4/d2/datalpha_8c.html#a2">ValidKernelPte</a>;
00585     TempPte.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Global = 0;
00586 
00587     StartPde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a151">MiGetPdeAddress</a>(<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a63">HYPER_SPACE</a>);
00588     StartPpe = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>(StartPde);
00589 
00590     <span class="keywordflow">if</span> (StartPpe-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 0) {
00591         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (StartPpe-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long == 0);
00592         TempPte.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber = <a class="code" href="../../d3/d1/iniaxp64_8c.html#a5">MxGetNextPage</a>();
00593         *StartPpe = TempPte;
00594         RtlZeroMemory (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a> (StartPpe),
00595                        <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
00596     }
00597 
00598     TempPte.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber = <a class="code" href="../../d3/d1/iniaxp64_8c.html#a5">MxGetNextPage</a>();
00599     *StartPde = TempPte;
00600 
00601     <span class="comment">//</span>
00602     <span class="comment">// Zero the hyper space page table page.</span>
00603     <span class="comment">//</span>
00604 
00605     StartPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>(<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a63">HYPER_SPACE</a>);
00606     RtlZeroMemory(StartPte, <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
00607 
00608     <span class="comment">//</span>
00609     <span class="comment">// Allocate page directory and page table pages for</span>
00610     <span class="comment">// system PTEs and nonpaged pool.</span>
00611     <span class="comment">//</span>
00612 
00613     TempPte = <a class="code" href="../../d4/d2/datalpha_8c.html#a2">ValidKernelPte</a>;
00614     StartPde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a151">MiGetPdeAddress</a>(<a class="code" href="../../d8/d5/kddata_8c.html#a22">MmNonPagedSystemStart</a>);
00615     EndPde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a151">MiGetPdeAddress</a>(<a class="code" href="../../d8/d5/kddata_8c.html#a24">MmNonPagedPoolEnd</a>);
00616     First = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00617 
00618     <span class="keywordflow">while</span> (StartPde &lt;= EndPde) {
00619 
00620         <span class="keywordflow">if</span> (First == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> || <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a167">MiIsPteOnPdeBoundary</a>(StartPde)) {
00621             First = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00622             StartPpe = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>(StartPde);
00623             <span class="keywordflow">if</span> (StartPpe-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 0) {
00624                 TempPte.u.Hard.PageFrameNumber = <a class="code" href="../../d3/d1/iniaxp64_8c.html#a5">MxGetNextPage</a>();
00625                 *StartPpe = TempPte;
00626                 RtlZeroMemory (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a> (StartPpe),
00627                                <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
00628             }
00629         }
00630 
00631         <span class="keywordflow">if</span> (StartPde-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 0) {
00632             TempPte.u.Hard.PageFrameNumber = <a class="code" href="../../d3/d1/iniaxp64_8c.html#a5">MxGetNextPage</a>();
00633             *StartPde = TempPte;
00634         }
00635         StartPde += 1;
00636     }
00637 
00638     <span class="comment">//</span>
00639     <span class="comment">// Zero the PTEs that map the nonpaged region just before nonpaged pool.</span>
00640     <span class="comment">//</span>
00641 
00642     StartPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>(<a class="code" href="../../d8/d5/kddata_8c.html#a22">MmNonPagedSystemStart</a>);
00643     EndPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>(<a class="code" href="../../d8/d5/kddata_8c.html#a24">MmNonPagedPoolEnd</a>);
00644 
00645     <span class="keywordflow">if</span> (!<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a167">MiIsPteOnPdeBoundary</a> (EndPte)) {
00646         EndPte = (<a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a>)((ULONG_PTR)<a class="code" href="../../d2/d1/mm_8h.html#a7">PAGE_ALIGN</a> (EndPte) + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
00647     }
00648 
00649     RtlZeroMemory(StartPte, (ULONG_PTR)EndPte - (ULONG_PTR)StartPte);
00650 
00651     <span class="comment">//</span>
00652     <span class="comment">// Fill in the PTEs to cover the initial nonpaged pool. The physical</span>
00653     <span class="comment">// page frames to cover this range were reserved earlier from the</span>
00654     <span class="comment">// largest low memory free descriptor. The initial allocation is both</span>
00655     <span class="comment">// physically and virtually contiguous.</span>
00656     <span class="comment">//</span>
00657 
00658     StartPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>(<a class="code" href="../../d8/d5/kddata_8c.html#a23">MmNonPagedPoolStart</a>);
00659     EndPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>((PCHAR)<a class="code" href="../../d8/d5/kddata_8c.html#a23">MmNonPagedPoolStart</a> +
00660                                                 <a class="code" href="../../d8/d0/cmdat3_8c.html#a19">MmSizeOfNonPagedPoolInBytes</a>);
00661 
00662     PageNumber = FreeDescriptorLowMem-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o2">BasePage</a>;
00663 
00664 <span class="preprocessor">#if 0</span>
00665 <span class="preprocessor"></span>    <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (<a class="code" href="../../d3/d1/iniaxp64_8c.html#a2">MxFreeDescriptor</a> == FreeDescriptorLowMem);
00666     <a class="code" href="../../d3/d1/iniaxp64_8c.html#a4">MxNumberOfPages</a> -= (EndPte - StartPte);
00667     <a class="code" href="../../d3/d1/iniaxp64_8c.html#a3">MxNextPhysicalPage</a> += (EndPte - StartPte);
00668 <span class="preprocessor">#endif</span>
00669 <span class="preprocessor"></span>
00670     <span class="keywordflow">while</span> (StartPte &lt; EndPte) {
00671         TempPte.u.Hard.PageFrameNumber = PageNumber;
00672         PageNumber += 1;
00673         *StartPte = TempPte;
00674         StartPte += 1;
00675     }
00676 
00677     <span class="comment">//</span>
00678     <span class="comment">// Zero the remaining PTEs (if any) for the initial nonpaged pool up to</span>
00679     <span class="comment">// the end of the current page table page.</span>
00680     <span class="comment">//</span>
00681 
00682     <span class="keywordflow">while</span> (!<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a167">MiIsPteOnPdeBoundary</a> (StartPte)) {
00683         *StartPte = <a class="code" href="../../d4/d2/datalpha_8c.html#a1">ZeroKernelPte</a>;
00684         StartPte += 1;
00685     }
00686 
00687     <span class="comment">//</span>
00688     <span class="comment">// Convert the starting nonpaged pool address to a 43-bit superpage</span>
00689     <span class="comment">// address and set the address of the initial nonpaged pool allocation.</span>
00690     <span class="comment">//</span>
00691 
00692     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>(<a class="code" href="../../d8/d5/kddata_8c.html#a23">MmNonPagedPoolStart</a>);
00693     <a class="code" href="../../d8/d5/kddata_8c.html#a23">MmNonPagedPoolStart</a> = KSEG_ADDRESS(PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber);
00694     <a class="code" href="../../d4/d8/mi_8h.html#a653">MmPageAlignedPoolBase</a>[<a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>] = <a class="code" href="../../d8/d5/kddata_8c.html#a23">MmNonPagedPoolStart</a>;
00695 
00696     <span class="comment">//</span>
00697     <span class="comment">// Set subsection base to the address to zero (the PTE format allows the</span>
00698     <span class="comment">// complete address space to be spanned) and the top subsection page.</span>
00699     <span class="comment">//</span>
00700 
00701     <a class="code" href="../../d8/d5/kddata_8c.html#a16">MmSubsectionBase</a> = 0;
00702     <a class="code" href="../../d4/d8/mi_8h.html#a580">MmSubsectionTopPage</a> = (<a class="code" href="../../d6/d7/halmips_8h.html#a445">KSEG2_BASE</a> - <a class="code" href="../../d6/d7/halmips_8h.html#a443">KSEG0_BASE</a>) &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>;
00703 
00704     <span class="comment">//</span>
00705     <span class="comment">// Initialize the pool structures in the nonpaged memory just mapped.</span>
00706     <span class="comment">//</span>
00707 
00708     <a class="code" href="../../d1/d6/allocpag_8c.html#a7">MmNonPagedPoolExpansionStart</a> =
00709                 (PCHAR)NonPagedPoolStartVirtual + <a class="code" href="../../d8/d0/cmdat3_8c.html#a19">MmSizeOfNonPagedPoolInBytes</a>;
00710 
00711     <a class="code" href="../../d4/d8/mi_8h.html#a778">MiInitializeNonPagedPool</a> ();
00712 
00713     <span class="comment">//</span>
00714     <span class="comment">// Before Nonpaged pool can be used, the PFN database must be built.</span>
00715     <span class="comment">// This is due to the fact that the start and ending allocation bits</span>
00716     <span class="comment">// for nonpaged pool are stored in the PFN elements for the corresponding</span>
00717     <span class="comment">// pages.</span>
00718     <span class="comment">//</span>
00719     <span class="comment">// Calculate the number of pages required from page zero to the highest</span>
00720     <span class="comment">// page.</span>
00721     <span class="comment">//</span>
00722     <span class="comment">// Get the number of secondary colors and add the array for tracking</span>
00723     <span class="comment">// secondary colors to the end of the PFN database.</span>
00724     <span class="comment">//</span>
00725 
00726     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a25">MmSecondaryColors</a> == 0) {
00727         <a class="code" href="../../d8/d0/cmdat3_8c.html#a25">MmSecondaryColors</a> = PCR-&gt;SecondLevelCacheSize;
00728     }
00729 
00730     <a class="code" href="../../d8/d0/cmdat3_8c.html#a25">MmSecondaryColors</a> = <a class="code" href="../../d8/d0/cmdat3_8c.html#a25">MmSecondaryColors</a> &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>;
00731 
00732     <span class="comment">//</span>
00733     <span class="comment">// Make sure value is power of two and within limits.</span>
00734     <span class="comment">//</span>
00735 
00736     <span class="keywordflow">if</span> (((<a class="code" href="../../d8/d0/cmdat3_8c.html#a25">MmSecondaryColors</a> &amp; (<a class="code" href="../../d8/d0/cmdat3_8c.html#a25">MmSecondaryColors</a> - 1)) != 0) ||
00737         (<a class="code" href="../../d8/d0/cmdat3_8c.html#a25">MmSecondaryColors</a> &lt; <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a61">MM_SECONDARY_COLORS_MIN</a>) ||
00738         (<a class="code" href="../../d8/d0/cmdat3_8c.html#a25">MmSecondaryColors</a> &gt; <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a62">MM_SECONDARY_COLORS_MAX</a>)) {
00739         <a class="code" href="../../d8/d0/cmdat3_8c.html#a25">MmSecondaryColors</a> = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a60">MM_SECONDARY_COLORS_DEFAULT</a>;
00740     }
00741 
00742     <a class="code" href="../../d4/d2/datalpha_8c.html#a22">MmSecondaryColorMask</a> = <a class="code" href="../../d8/d0/cmdat3_8c.html#a25">MmSecondaryColors</a> - 1;
00743     PfnAllocation =
00744         1 + ((((<a class="code" href="../../d6/d8/sysinfo_8c.html#a7">MmHighestPhysicalPage</a> + 1) * <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d8/mi_8h.html#a438">MMPFN</a>)) +
00745             ((PFN_NUMBER)<a class="code" href="../../d8/d0/cmdat3_8c.html#a25">MmSecondaryColors</a> * <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d1/struct__MMCOLOR__TABLES.html">MMCOLOR_TABLES</a>) * 2)) &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
00746 
00747     <span class="comment">//</span>
00748     <span class="comment">// If the number of pages remaining in the current descriptor is</span>
00749     <span class="comment">// greater than the number of pages needed for the PFN database,</span>
00750     <span class="comment">// then allocate the PFN database from the current free descriptor.</span>
00751     <span class="comment">// Otherwise, allocate the PFN database virtually.</span>
00752     <span class="comment">//</span>
00753 
00754 <span class="preprocessor">#ifndef PFN_CONSISTENCY</span>
00755 <span class="preprocessor"></span>
00756     <span class="keywordflow">if</span> (<a class="code" href="../../d3/d1/iniaxp64_8c.html#a4">MxNumberOfPages</a> &gt;= PfnAllocation) {
00757 
00758         <span class="comment">//</span>
00759         <span class="comment">// Allocate the PFN database in the 43-bit superpage.</span>
00760         <span class="comment">//</span>
00761         <span class="comment">// Compute the address of the PFN by allocating the appropriate</span>
00762         <span class="comment">// number of pages from the end of the free descriptor.</span>
00763         <span class="comment">//</span>
00764 
00765         HighPage = <a class="code" href="../../d3/d1/iniaxp64_8c.html#a3">MxNextPhysicalPage</a> + <a class="code" href="../../d3/d1/iniaxp64_8c.html#a4">MxNumberOfPages</a>;
00766         <a class="code" href="../../d2/d3/dumpctl_8c.html#a15">MmPfnDatabase</a> = KSEG_ADDRESS(HighPage - PfnAllocation);
00767         RtlZeroMemory(<a class="code" href="../../d2/d3/dumpctl_8c.html#a15">MmPfnDatabase</a>, PfnAllocation * <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
00768 
00769         <span class="comment">//</span>
00770         <span class="comment">// Mark off the chunk of memory used for the PFN database from</span>
00771         <span class="comment">// either the largest low free memory descriptor or the largest</span>
00772         <span class="comment">// free memory descriptor.</span>
00773         <span class="comment">//</span>
00774         <span class="comment">// N.B. The PFN database size is subtracted from the appropriate</span>
00775         <span class="comment">//      memory descriptor so it will not appear to be free when</span>
00776         <span class="comment">//      the memory descriptors are scanned to initialize the PFN</span>
00777         <span class="comment">//      database.</span>
00778         <span class="comment">//</span>
00779 
00780         <a class="code" href="../../d3/d1/iniaxp64_8c.html#a4">MxNumberOfPages</a> -= PfnAllocation;
00781         <span class="keywordflow">if</span> ((<a class="code" href="../../d3/d1/iniaxp64_8c.html#a3">MxNextPhysicalPage</a> &gt;= FreeDescriptorLowMem-&gt;BasePage) &amp;&amp;
00782             (<a class="code" href="../../d3/d1/iniaxp64_8c.html#a3">MxNextPhysicalPage</a> &lt; (FreeDescriptorLowMem-&gt;BasePage +
00783                                           FreeDescriptorLowMem-&gt;PageCount))) {
00784             FreeDescriptorLowMem-&gt;PageCount -= (PFN_COUNT)PfnAllocation;
00785 
00786         } <span class="keywordflow">else</span> {
00787             <a class="code" href="../../d3/d1/iniaxp64_8c.html#a2">MxFreeDescriptor</a>-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o3">PageCount</a> -= (PFN_COUNT)PfnAllocation;
00788         }
00789 
00790         <span class="comment">//</span>
00791         <span class="comment">// Allocate one PTE at the very top of nonpaged pool. This provides</span>
00792         <span class="comment">// protection against the caller of the first real nonpaged expansion allocation in case he accidentally overruns his</span>
00793         <span class="comment">// pool block.  (We'll trap instead of corrupting the PFN database).</span>
00794         <span class="comment">// This also allows us to freely increment in MiFreePoolPages without</span>
00795         <span class="comment">// having to worry about a valid PTE after the end of the highest</span>
00796         <span class="comment">// nonpaged pool allocation.</span>
00797         <span class="comment">//</span>
00798 
00799         <a class="code" href="../../d0/d9/sysptes_8c.html#a25">MiReserveSystemPtes</a>(1, <a class="code" href="../../d4/d8/mi_8h.html#a1003a770">NonPagedPoolExpansion</a>, 0, 0, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
00800 
00801     } <span class="keywordflow">else</span> {
00802 
00803 <span class="preprocessor">#endif // PFN_CONSISTENCY</span>
00804 <span class="preprocessor"></span>
00805         <span class="comment">//</span>
00806         <span class="comment">// Calculate the start of the PFN database (it starts at physical</span>
00807         <span class="comment">// page zero, even if the lowest physical page is not zero).</span>
00808         <span class="comment">//</span>
00809 
00810         PointerPte = <a class="code" href="../../d0/d9/sysptes_8c.html#a25">MiReserveSystemPtes</a>((ULONG)PfnAllocation,
00811                                          <a class="code" href="../../d4/d8/mi_8h.html#a1003a770">NonPagedPoolExpansion</a>,
00812                                          0,
00813                                          0,
00814                                          <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
00815 
00816 <span class="preprocessor">#if PFN_CONSISTENCY</span>
00817 <span class="preprocessor"></span>
00818         MiPfnStartPte = PointerPte;
00819         MiPfnPtes = PfnAllocation;
00820 
00821 <span class="preprocessor">#endif</span>
00822 <span class="preprocessor"></span>
00823         <a class="code" href="../../d2/d3/dumpctl_8c.html#a15">MmPfnDatabase</a> = (<a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a>)(<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a>(PointerPte));
00824 
00825         <span class="comment">//</span>
00826         <span class="comment">// Allocate one more PTE just below the PFN database. This provides</span>
00827         <span class="comment">// protection against the caller of the first real nonpaged</span>
00828         <span class="comment">// expansion allocation in case he accidentally overruns his pool</span>
00829         <span class="comment">// block. (We'll trap instead of corrupting the PFN database).</span>
00830         <span class="comment">// This also allows us to freely increment in MiFreePoolPages</span>
00831         <span class="comment">// without having to worry about a valid PTE just after the end of</span>
00832         <span class="comment">// the highest nonpaged pool allocation.</span>
00833         <span class="comment">//</span>
00834 
00835         <a class="code" href="../../d0/d9/sysptes_8c.html#a25">MiReserveSystemPtes</a>(1, <a class="code" href="../../d4/d8/mi_8h.html#a1003a770">NonPagedPoolExpansion</a>, 0, 0, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
00836 
00837         <span class="comment">//</span>
00838         <span class="comment">// Go through the memory descriptors and for each physical page</span>
00839         <span class="comment">// make the PFN database have a valid PTE to map it. This allows</span>
00840         <span class="comment">// machines with sparse physical memory to have a minimal PFN</span>
00841         <span class="comment">// database.</span>
00842         <span class="comment">//</span>
00843 
00844         NextMd = LoaderBlock-&gt;MemoryDescriptorListHead.Flink;
00845         <span class="keywordflow">while</span> (NextMd != &amp;LoaderBlock-&gt;MemoryDescriptorListHead) {
00846             MemoryDescriptor = CONTAINING_RECORD(NextMd,
00847                                                  <a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html">MEMORY_ALLOCATION_DESCRIPTOR</a>,
00848                                                  ListEntry);
00849 
00850             PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>(<a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a>(
00851                                          MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o2">BasePage</a>));
00852 
00853             HighPage = MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o2">BasePage</a> + MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o3">PageCount</a>;
00854             LastPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>((PCHAR)<a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a>(HighPage) - 1);
00855             <span class="keywordflow">while</span> (PointerPte &lt;= LastPte) {
00856                 <span class="keywordflow">if</span> (PointerPte-&gt;u.Hard.Valid == 0) {
00857                     TempPte.u.Hard.PageFrameNumber = <a class="code" href="../../d3/d1/iniaxp64_8c.html#a5">MxGetNextPage</a>();
00858                     *PointerPte = TempPte;
00859                     RtlZeroMemory(<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a>(PointerPte),
00860                                   <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
00861                 }
00862 
00863                 PointerPte += 1;
00864             }
00865 
00866             NextMd = MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o0">ListEntry</a>.Flink;
00867         }
00868 
00869 <span class="preprocessor">#ifndef PFN_CONSISTENCY</span>
00870 <span class="preprocessor"></span>
00871     }
00872 
00873 <span class="preprocessor">#endif // PFN_CONSISTENCY</span>
00874 <span class="preprocessor"></span>
00875     <span class="comment">//</span>
00876     <span class="comment">// Initialize support for colored pages.</span>
00877     <span class="comment">//</span>
00878 
00879     <a class="code" href="../../d4/d2/datalpha_8c.html#a20">MmFreePagesByColor</a>[0] =
00880                 (<a class="code" href="../../d4/d1/struct__MMCOLOR__TABLES.html">PMMCOLOR_TABLES</a>)&amp;<a class="code" href="../../d2/d3/dumpctl_8c.html#a15">MmPfnDatabase</a>[<a class="code" href="../../d6/d8/sysinfo_8c.html#a7">MmHighestPhysicalPage</a> + 1];
00881 
00882     <a class="code" href="../../d4/d2/datalpha_8c.html#a20">MmFreePagesByColor</a>[1] = &amp;<a class="code" href="../../d4/d2/datalpha_8c.html#a20">MmFreePagesByColor</a>[0][<a class="code" href="../../d8/d0/cmdat3_8c.html#a25">MmSecondaryColors</a>];
00883 
00884     <span class="comment">//</span>
00885     <span class="comment">// Make sure the color table are mapped if they are not physically</span>
00886     <span class="comment">// allocated.</span>
00887     <span class="comment">//</span>
00888 
00889     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a178">MI_IS_PHYSICAL_ADDRESS</a>(<a class="code" href="../../d4/d2/datalpha_8c.html#a20">MmFreePagesByColor</a>[0]) == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
00890         PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>(&amp;<a class="code" href="../../d4/d2/datalpha_8c.html#a20">MmFreePagesByColor</a>[0][0]);
00891         LastPte =
00892             <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>((PCHAR)&amp;<a class="code" href="../../d4/d2/datalpha_8c.html#a20">MmFreePagesByColor</a>[1][<a class="code" href="../../d8/d0/cmdat3_8c.html#a25">MmSecondaryColors</a>] - 1);
00893 
00894         <span class="keywordflow">while</span> (PointerPte &lt;= LastPte) {
00895             <span class="keywordflow">if</span> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 0) {
00896                 TempPte.u.Hard.PageFrameNumber = <a class="code" href="../../d3/d1/iniaxp64_8c.html#a5">MxGetNextPage</a>();
00897                 *PointerPte = TempPte;
00898                 RtlZeroMemory(<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a>(PointerPte),
00899                               <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
00900             }
00901 
00902             PointerPte += 1;
00903         }
00904     }
00905 
00906     <span class="comment">//</span>
00907     <span class="comment">// Initialize the secondary color free page listheads.</span>
00908     <span class="comment">//</span>
00909 
00910     <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="../../d8/d0/cmdat3_8c.html#a25">MmSecondaryColors</a>; i += 1) {
00911         <a class="code" href="../../d4/d2/datalpha_8c.html#a20">MmFreePagesByColor</a>[<a class="code" href="../../d2/d1/mm_8h.html#a345a171">ZeroedPageList</a>][i].<a class="code" href="../../d4/d1/struct__MMCOLOR__TABLES.html#o0">Flink</a> = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a0">MM_EMPTY_LIST</a>;
00912         <a class="code" href="../../d4/d2/datalpha_8c.html#a20">MmFreePagesByColor</a>[<a class="code" href="../../d2/d1/mm_8h.html#a345a172">FreePageList</a>][i].<a class="code" href="../../d4/d1/struct__MMCOLOR__TABLES.html#o0">Flink</a> = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a0">MM_EMPTY_LIST</a>;
00913     }
00914 
00915     <span class="comment">//</span>
00916     <span class="comment">// Go through the page table entries and for any page which is valid,</span>
00917     <span class="comment">// update the corresponding PFN database element.</span>
00918     <span class="comment">//</span>
00919     <span class="comment">// Add the level one page directory parent page to the PFN database.</span>
00920     <span class="comment">//</span>
00921 
00922     PointerPde = (<a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a>)PDE_SELFMAP;
00923     PpePage = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a182">MI_GET_PAGE_FRAME_FROM_PTE</a>(PointerPde);
00924     Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a>(PpePage);
00925     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o17">PteFrame</a> = PpePage;
00926     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a> = PointerPde;
00927     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount += 1;
00928     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount = 1;
00929     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PageLocation = <a class="code" href="../../d2/d1/mm_8h.html#a345a177">ActiveAndValid</a>;
00930     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PageColor =
00931             <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a132">MI_GET_COLOR_FROM_SECONDARY</a>(GET_PAGE_COLOR_FROM_PTE(PointerPde));
00932 
00933     <span class="comment">//</span>
00934     <span class="comment">// Add the pages which were used to construct the nonpaged part of the</span>
00935     <span class="comment">// system, hyper space, and the system process working set list to the</span>
00936     <span class="comment">// PFN database.</span>
00937     <span class="comment">//</span>
00938     <span class="comment">// The scan begins at the start of hyper space so the hyper space page</span>
00939     <span class="comment">// table page and the working set list page will be accounted for in</span>
00940     <span class="comment">// the PFN database.</span>
00941     <span class="comment">//</span>
00942 
00943     StartPde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a151">MiGetPdeAddress</a>(<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a63">HYPER_SPACE</a>);
00944     EndPde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a151">MiGetPdeAddress</a>(<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a24">NON_PAGED_SYSTEM_END</a>);
00945     First = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00946 
00947     <span class="keywordflow">while</span> (StartPde &lt;= EndPde) {
00948 
00949         <span class="keywordflow">if</span> (First == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> || <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a167">MiIsPteOnPdeBoundary</a>(StartPde)) {
00950             First = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00951             StartPpe = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>(StartPde);
00952             <span class="keywordflow">if</span> (StartPpe-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 0) {
00953                 StartPpe += 1;
00954                 StartPde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a> (StartPpe);
00955                 <span class="keywordflow">continue</span>;
00956             }
00957 
00958             PdePage = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a182">MI_GET_PAGE_FRAME_FROM_PTE</a>(StartPpe);
00959 
00960             Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a>(PdePage);
00961             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o17">PteFrame</a> = PpePage;
00962             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a> = StartPde;
00963             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount += 1;
00964             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount = 1;
00965             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PageLocation = <a class="code" href="../../d2/d1/mm_8h.html#a345a177">ActiveAndValid</a>;
00966             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PageColor =
00967                 <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a132">MI_GET_COLOR_FROM_SECONDARY</a>(GET_PAGE_COLOR_FROM_PTE(StartPpe));
00968         }
00969 
00970         <span class="comment">//</span>
00971         <span class="comment">// If the second level PDE entry is valid, then add the page to the</span>
00972         <span class="comment">// PFN database.</span>
00973         <span class="comment">//</span>
00974 
00975         <span class="keywordflow">if</span> (StartPde-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1) {
00976 
00977             PtePage = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a182">MI_GET_PAGE_FRAME_FROM_PTE</a>(StartPde);
00978             Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a>(PtePage);
00979             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o17">PteFrame</a> = PdePage;
00980             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a> = StartPde;
00981             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount += 1;
00982             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount = 1;
00983             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PageLocation = <a class="code" href="../../d2/d1/mm_8h.html#a345a177">ActiveAndValid</a>;
00984             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PageColor =
00985                 <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a132">MI_GET_COLOR_FROM_SECONDARY</a>(GET_PAGE_COLOR_FROM_PTE(StartPde));
00986 
00987             <span class="comment">//</span>
00988             <span class="comment">// Scan the page table page for valid PTEs.</span>
00989             <span class="comment">//</span>
00990 
00991             PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a>(StartPde);
00992 
00993             <span class="keywordflow">if</span> ((PointerPte &lt; <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (<a class="code" href="../../d6/d7/halmips_8h.html#a443">KSEG0_BASE</a>)) ||
00994                 (PointerPte &gt;= <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (<a class="code" href="../../d6/d7/halmips_8h.html#a445">KSEG2_BASE</a>))) {
00995 
00996                 <span class="keywordflow">for</span> (j = 0 ; j &lt; <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a103">PTE_PER_PAGE</a>; j += 1) {
00997 
00998                     <span class="comment">//</span>
00999                     <span class="comment">// If the page table page is valid, then add the page</span>
01000                     <span class="comment">// to the PFN database.</span>
01001                     <span class="comment">//</span>
01002 
01003                     <span class="keywordflow">if</span> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1) {
01004                         FrameNumber = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a182">MI_GET_PAGE_FRAME_FROM_PTE</a>(PointerPte);
01005                         Pfn2 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a>(FrameNumber);
01006                         Pfn2-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o17">PteFrame</a> = PtePage;
01007                         Pfn2-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a> = (<a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a>)KSEG_ADDRESS(PtePage) + j;
01008                         Pfn2-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount += 1;
01009                         Pfn2-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount = 1;
01010                         Pfn2-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PageLocation = <a class="code" href="../../d2/d1/mm_8h.html#a345a177">ActiveAndValid</a>;
01011                         Pfn2-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PageColor =
01012                             <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a132">MI_GET_COLOR_FROM_SECONDARY</a>(GET_PAGE_COLOR_FROM_PTE(Pfn2-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a>));
01013                     }
01014 
01015                     PointerPte += 1;
01016                 }
01017             }
01018         }
01019 
01020         StartPde += 1;
01021     }
01022 
01023     <span class="comment">//</span>
01024     <span class="comment">// If the lowest physical page is still unused add it to the PFN</span>
01025     <span class="comment">// database by making its reference count nonzero and pointing</span>
01026     <span class="comment">// it to a second level page directory entry.</span>
01027     <span class="comment">//</span>
01028 
01029     Pfn1 = &amp;<a class="code" href="../../d2/d3/dumpctl_8c.html#a15">MmPfnDatabase</a>[<a class="code" href="../../d6/d8/sysinfo_8c.html#a6">MmLowestPhysicalPage</a>];
01030     <span class="keywordflow">if</span> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount == 0) {
01031         Pde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a151">MiGetPdeAddress</a>(0xFFFFFFFFB0000000);
01032         PdePage = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a182">MI_GET_PAGE_FRAME_FROM_PTE</a>(Pde);
01033         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o17">PteFrame</a> = PdePage;
01034         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a> = Pde;
01035         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount += 1;
01036         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount = 1;
01037         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PageLocation = <a class="code" href="../../d2/d1/mm_8h.html#a345a177">ActiveAndValid</a>;
01038         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PageColor =
01039                     <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a132">MI_GET_COLOR_FROM_SECONDARY</a>(GET_PAGE_COLOR_FROM_PTE(Pde));
01040     }
01041 
01042     <span class="comment">//</span>
01043     <span class="comment">// Walk through the memory descriptors and add pages to the free list</span>
01044     <span class="comment">// in the PFN database as appropriate.</span>
01045     <span class="comment">//</span>
01046 
01047     NextMd = LoaderBlock-&gt;MemoryDescriptorListHead.Flink;
01048     <span class="keywordflow">while</span> (NextMd != &amp;LoaderBlock-&gt;MemoryDescriptorListHead) {
01049         MemoryDescriptor = CONTAINING_RECORD(NextMd,
01050                                              <a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html">MEMORY_ALLOCATION_DESCRIPTOR</a>,
01051                                              ListEntry);
01052 
01053         <span class="comment">//</span>
01054         <span class="comment">// Set the base page number and the number of pages and switch</span>
01055         <span class="comment">// on the memory type.</span>
01056         <span class="comment">//</span>
01057 
01058         i = MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o3">PageCount</a>;
01059         NextPhysicalPage = MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o2">BasePage</a>;
01060         <span class="keywordflow">switch</span> (MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o1">MemoryType</a>) {
01061 
01062             <span class="comment">//</span>
01063             <span class="comment">// Bad pages are not usable and are placed on the bad</span>
01064             <span class="comment">// page list.</span>
01065             <span class="comment">//</span>
01066 
01067         <span class="keywordflow">case</span> <a class="code" href="../../d1/d9/arc_8h.html#a320a257">LoaderBad</a>:
01068             <span class="keywordflow">while</span> (i != 0) {
01069                 <a class="code" href="../../d7/d5/pfnlist_8c.html#a8">MiInsertPageInList</a>(<a class="code" href="../../d4/d8/mi_8h.html#a606">MmPageLocationList</a>[<a class="code" href="../../d2/d1/mm_8h.html#a345a176">BadPageList</a>],
01070                                    NextPhysicalPage);
01071 
01072                 i -= 1;
01073                 NextPhysicalPage += 1;
01074             }
01075 
01076             <span class="keywordflow">break</span>;
01077 
01078             <span class="comment">//</span>
01079             <span class="comment">// Pages from descriptor types free, loaded program, firmware</span>
01080             <span class="comment">// temporary, and OS Loader stack are potentially free.</span>
01081             <span class="comment">//</span>
01082 
01083         <span class="keywordflow">case</span> <a class="code" href="../../d1/d9/arc_8h.html#a320a256">LoaderFree</a>:
01084         <span class="keywordflow">case</span> <a class="code" href="../../d1/d9/arc_8h.html#a320a258">LoaderLoadedProgram</a>:
01085         <span class="keywordflow">case</span> <a class="code" href="../../d1/d9/arc_8h.html#a320a259">LoaderFirmwareTemporary</a>:
01086         <span class="keywordflow">case</span> <a class="code" href="../../d1/d9/arc_8h.html#a320a262">LoaderOsloaderStack</a>:
01087             Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a>(NextPhysicalPage);
01088             <span class="keywordflow">while</span> (i != 0) {
01089 
01090                 <span class="comment">//</span>
01091                 <span class="comment">// If the PFN database entry for the respective page</span>
01092                 <span class="comment">// is not referenced, then insert the page in the free</span>
01093                 <span class="comment">// page list.</span>
01094                 <span class="comment">//</span>
01095 
01096                 <span class="keywordflow">if</span> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount == 0) {
01097                     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a> = KSEG_ADDRESS(NextPhysicalPage);
01098                     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PageColor =
01099                         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a132">MI_GET_COLOR_FROM_SECONDARY</a>(GET_PAGE_COLOR_FROM_PTE(Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a>));
01100 
01101                     <a class="code" href="../../d7/d5/pfnlist_8c.html#a8">MiInsertPageInList</a>(<a class="code" href="../../d4/d8/mi_8h.html#a606">MmPageLocationList</a>[<a class="code" href="../../d2/d1/mm_8h.html#a345a172">FreePageList</a>],
01102                                         NextPhysicalPage);
01103                 }
01104 
01105                 Pfn1 += 1;
01106                 i -= 1;
01107                 NextPhysicalPage += 1;
01108             }
01109 
01110             <span class="keywordflow">break</span>;
01111 
01112             <span class="comment">//</span>
01113             <span class="comment">// All the remaining memory descriptor types represent memory</span>
01114             <span class="comment">// that has been already allocated and is not available.</span>
01115             <span class="comment">//</span>
01116 
01117         <span class="keywordflow">default</span>:
01118             PointerPte = KSEG_ADDRESS(NextPhysicalPage);
01119             Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a>(NextPhysicalPage);
01120             <span class="keywordflow">while</span> (i != 0) {
01121 
01122                 <span class="comment">//</span>
01123                 <span class="comment">// Set the page in use.</span>
01124                 <span class="comment">//</span>
01125 
01126                 Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o17">PteFrame</a> = PpePage;
01127                 Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a> = PointerPte;
01128                 Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount += 1;
01129                 Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount = 1;
01130                 Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PageLocation = <a class="code" href="../../d2/d1/mm_8h.html#a345a177">ActiveAndValid</a>;
01131                 Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PageColor =
01132                     <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a132">MI_GET_COLOR_FROM_SECONDARY</a>(GET_PAGE_COLOR_FROM_PTE(PointerPte));
01133 
01134                 Pfn1 += 1;
01135                 i -= 1;
01136                 NextPhysicalPage += 1;
01137                 PointerPte += 1;
01138             }
01139 
01140             <span class="keywordflow">break</span>;
01141         }
01142 
01143         NextMd = MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o0">ListEntry</a>.Flink;
01144     }
01145 
01146     <span class="comment">//</span>
01147     <span class="comment">// Everything has been accounted for except the PFN database.</span>
01148     <span class="comment">//</span>
01149 
01150     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a178">MI_IS_PHYSICAL_ADDRESS</a>(<a class="code" href="../../d2/d3/dumpctl_8c.html#a15">MmPfnDatabase</a>) == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01151 
01152         <span class="comment">//</span>
01153         <span class="comment">// The PFN database is allocated in virtual memory.</span>
01154         <span class="comment">//</span>
01155         <span class="comment">// Set the start and end of allocation in the PFN database.</span>
01156         <span class="comment">//</span>
01157 
01158         Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a>(<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>(&amp;<a class="code" href="../../d2/d3/dumpctl_8c.html#a15">MmPfnDatabase</a>[<a class="code" href="../../d6/d8/sysinfo_8c.html#a6">MmLowestPhysicalPage</a>])-&gt;u.Hard.PageFrameNumber);
01159         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.StartOfAllocation = 1;
01160         Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a>(<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>(&amp;<a class="code" href="../../d2/d3/dumpctl_8c.html#a15">MmPfnDatabase</a>[<a class="code" href="../../d6/d8/sysinfo_8c.html#a7">MmHighestPhysicalPage</a>])-&gt;u.Hard.PageFrameNumber);
01161         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.EndOfAllocation = 1;
01162 
01163     } <span class="keywordflow">else</span> {
01164 
01165         <span class="comment">//</span>
01166         <span class="comment">// The PFN database is allocated in KSEG43.</span>
01167         <span class="comment">//</span>
01168         <span class="comment">// Mark all PFN entries for the PFN pages in use.</span>
01169         <span class="comment">//</span>
01170 
01171         PageNumber = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a179">MI_CONVERT_PHYSICAL_TO_PFN</a>(<a class="code" href="../../d2/d3/dumpctl_8c.html#a15">MmPfnDatabase</a>);
01172         Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a>(PageNumber);
01173         <span class="keywordflow">do</span> {
01174             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a> = KSEG_ADDRESS(PageNumber);
01175             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PageColor =
01176                 <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a132">MI_GET_COLOR_FROM_SECONDARY</a>(GET_PAGE_COLOR_FROM_PTE(Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a>));
01177 
01178             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount += 1;
01179             PageNumber += 1;
01180             Pfn1 += 1;
01181             PfnAllocation -= 1;
01182         } <span class="keywordflow">while</span> (PfnAllocation != 0);
01183 
01184         <span class="comment">//</span>
01185         <span class="comment">// Scan the PFN database backward for pages that are completely zero.</span>
01186         <span class="comment">// These pages are unused and can be added to the free list.</span>
01187         <span class="comment">//</span>
01188 
01189         BottomPfn = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a>(<a class="code" href="../../d6/d8/sysinfo_8c.html#a7">MmHighestPhysicalPage</a>);
01190         <span class="keywordflow">do</span> {
01191 
01192             <span class="comment">//</span>
01193             <span class="comment">// Compute the address of the start of the page that is next</span>
01194             <span class="comment">// lower in memory and scan backwards until that page address</span>
01195             <span class="comment">// is reached or just crossed.</span>
01196             <span class="comment">//</span>
01197 
01198             <span class="keywordflow">if</span> (((ULONG_PTR)BottomPfn &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1)) != 0) {
01199                 BasePfn = (<a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a>)((ULONG_PTR)BottomPfn &amp; ~(<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1));
01200                 TopPfn = BottomPfn + 1;
01201 
01202             } <span class="keywordflow">else</span> {
01203                 BasePfn = (<a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a>)((ULONG_PTR)BottomPfn - <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
01204                 TopPfn = BottomPfn;
01205             }
01206 
01207             <span class="keywordflow">while</span> (BottomPfn &gt; BasePfn) {
01208                 BottomPfn -= 1;
01209             }
01210 
01211             <span class="comment">//</span>
01212             <span class="comment">// If the entire range over which the PFN entries span is</span>
01213             <span class="comment">// completely zero and the PFN entry that maps the page is</span>
01214             <span class="comment">// not in the range, then add the page to the appropriate</span>
01215             <span class="comment">// free list.</span>
01216             <span class="comment">//</span>
01217 
01218             Range = (ULONG)((ULONG_PTR)TopPfn - (ULONG_PTR)BottomPfn);
01219             <span class="keywordflow">if</span> (<a class="code" href="../../d2/d7/string_8c.html#a17">RtlCompareMemoryUlong</a>((PVOID)BottomPfn, Range, 0) == Range) {
01220 
01221                 <span class="comment">//</span>
01222                 <span class="comment">// Set the PTE address to the physical page for virtual</span>
01223                 <span class="comment">// address alignment checking.</span>
01224                 <span class="comment">//</span>
01225 
01226                 PageNumber = (PFN_NUMBER)(((ULONG_PTR)BasePfn - KSEG43_BASE) &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
01227                 Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a>(PageNumber);
01228 
01229                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount == 1);
01230 
01231                 Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount = 0;
01232                 PfnAllocation += 1;
01233                 Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a> = KSEG_ADDRESS(PageNumber);
01234                 Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PageColor =
01235                     <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a132">MI_GET_COLOR_FROM_SECONDARY</a>(GET_PAGE_COLOR_FROM_PTE(Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a>));
01236 
01237                 <a class="code" href="../../d7/d5/pfnlist_8c.html#a8">MiInsertPageInList</a>(<a class="code" href="../../d4/d8/mi_8h.html#a606">MmPageLocationList</a>[<a class="code" href="../../d2/d1/mm_8h.html#a345a172">FreePageList</a>],
01238                                    PageNumber);
01239             }
01240 
01241         } <span class="keywordflow">while</span> (BottomPfn &gt; <a class="code" href="../../d2/d3/dumpctl_8c.html#a15">MmPfnDatabase</a>);
01242     }
01243 
01244     <span class="comment">//</span>
01245     <span class="comment">// Indicate that nonpaged pool must succeed is allocated in nonpaged pool.</span>
01246     <span class="comment">//</span>
01247 
01248     i = <a class="code" href="../../d4/d8/mi_8h.html#a627">MmSizeOfNonPagedMustSucceed</a>;
01249     Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a>(<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a179">MI_CONVERT_PHYSICAL_TO_PFN</a>(<a class="code" href="../../d4/d8/mi_8h.html#a649">MmNonPagedMustSucceed</a>));
01250     <span class="keywordflow">while</span> (i != 0) {
01251         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.StartOfAllocation = 1;
01252         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.EndOfAllocation = 1;
01253         i -= <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
01254         Pfn1 += 1;
01255     }
01256 
01257     <span class="comment">//</span>
01258     <span class="comment">// Recompute the number of system PTEs to include the virtual space</span>
01259     <span class="comment">// occupied by the initialize nonpaged pool allocation in KSEG43, and</span>
01260     <span class="comment">// initialize the nonpaged available PTEs for mapping I/O space and</span>
01261     <span class="comment">// kernel stacks.</span>
01262     <span class="comment">//</span>
01263 
01264     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>(<a class="code" href="../../d8/d5/kddata_8c.html#a22">MmNonPagedSystemStart</a>);
01265     <a class="code" href="../../d8/d0/cmdat3_8c.html#a23">MmNumberOfSystemPtes</a> = (ULONG)(<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>(<a class="code" href="../../d1/d6/allocpag_8c.html#a7">MmNonPagedPoolExpansionStart</a>) - PointerPte - 1);
01266     <a class="code" href="../../d4/d9/ke_8h.html#a354">KeInitializeSpinLock</a>(&amp;<a class="code" href="../../d4/d4/alpha_2splocks_8c.html#a15">MmSystemSpaceLock</a>);
01267     <a class="code" href="../../d4/d9/ke_8h.html#a354">KeInitializeSpinLock</a>(&amp;<a class="code" href="../../d7/d2/alpha_2initkr_8c.html#a2">MmPfnLock</a>);
01268     <a class="code" href="../../d0/d9/sysptes_8c.html#a27">MiInitializeSystemPtes</a>(PointerPte, <a class="code" href="../../d8/d0/cmdat3_8c.html#a23">MmNumberOfSystemPtes</a>, <a class="code" href="../../d4/d8/mi_8h.html#a1003a769">SystemPteSpace</a>);
01269 
01270     <span class="comment">//</span>
01271     <span class="comment">// Initialize the nonpaged pool.</span>
01272     <span class="comment">//</span>
01273 
01274     <a class="code" href="../../d5/d8/ex_8h.html#a215">InitializePool</a>(<a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, 0);
01275 
01276     <span class="comment">//</span>
01277     <span class="comment">// Initialize memory management structures for the system process.</span>
01278     <span class="comment">//</span>
01279     <span class="comment">// Set the address of the first and last reserved PTE in hyper space.</span>
01280     <span class="comment">//</span>
01281 
01282     <a class="code" href="../../d4/d8/mi_8h.html#a615">MmFirstReservedMappingPte</a> = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>(<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a64">FIRST_MAPPING_PTE</a>);
01283     <a class="code" href="../../d4/d8/mi_8h.html#a616">MmLastReservedMappingPte</a> = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>(<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a66">LAST_MAPPING_PTE</a>);
01284 
01285     <span class="comment">//</span>
01286     <span class="comment">// Set the address of the start of the working set list and header.</span>
01287     <span class="comment">//</span>
01288 
01289     <a class="code" href="../../d4/d8/mi_8h.html#a672">MmWorkingSetList</a> = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a69">WORKING_SET_LIST</a>;
01290     <a class="code" href="../../d4/d8/mi_8h.html#a673">MmWsle</a> = (<a class="code" href="../../d1/d8/struct__MMWSLE.html">PMMWSLE</a>)((PUCHAR)<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a69">WORKING_SET_LIST</a> + <span class="keyword">sizeof</span>(<a class="code" href="../../d0/d8/struct__MMWSL.html">MMWSL</a>));
01291 
01292     <span class="comment">//</span>
01293     <span class="comment">// The PFN element for the page directory parent will be initialized</span>
01294     <span class="comment">// a second time when the process address space is initialized. Therefore,</span>
01295     <span class="comment">// the share count and the reference count must be set to zero.</span>
01296     <span class="comment">//</span>
01297 
01298     Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a>(<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a182">MI_GET_PAGE_FRAME_FROM_PTE</a>((<a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a>)PDE_SELFMAP));
01299     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount = 0;
01300     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount = 0;
01301 
01302     <span class="comment">//</span>
01303     <span class="comment">// The PFN element for the hyper space page directory page will be</span>
01304     <span class="comment">// initialized a second time when the process address space is initialized.</span>
01305     <span class="comment">// Therefore, the share count and the reference count must be set to zero.</span>
01306     <span class="comment">//</span>
01307 
01308     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a150">MiGetPpeAddress</a>(<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a63">HYPER_SPACE</a>);
01309     Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a>(<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a182">MI_GET_PAGE_FRAME_FROM_PTE</a>(PointerPte));
01310     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount = 0;
01311     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount = 0;
01312 
01313     <span class="comment">//</span>
01314     <span class="comment">// The PFN elements for the hyper space page table page and working set list</span>
01315     <span class="comment">// page will be initialized a second time when the process address space</span>
01316     <span class="comment">// is initialized. Therefore, the share count and the reference must be</span>
01317     <span class="comment">// set to zero.</span>
01318     <span class="comment">//</span>
01319 
01320     StartPde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a151">MiGetPdeAddress</a>(<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a63">HYPER_SPACE</a>);
01321 
01322     Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a>(<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a182">MI_GET_PAGE_FRAME_FROM_PTE</a>(StartPde));
01323     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount = 0;
01324     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount = 0;
01325 
01326     <span class="comment">//</span>
01327     <span class="comment">// Save the page frame number of the working set page in the system</span>
01328     <span class="comment">// process object and unmap the working set page from the second level</span>
01329     <span class="comment">// page directory page.</span>
01330     <span class="comment">//</span>
01331 
01332     <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a>(OldIrql);
01333 
01334     FrameNumber = <a class="code" href="../../d4/d8/mi_8h.html#a243">MiRemoveZeroPageIfAny</a> (0);
01335     <span class="keywordflow">if</span> (FrameNumber == 0) {
01336         FrameNumber = <a class="code" href="../../d7/d5/pfnlist_8c.html#a15">MiRemoveAnyPage</a> (0);
01337         <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
01338         <a class="code" href="../../d0/d2/mmsup_8c.html#a14">MiZeroPhysicalPage</a> (FrameNumber, 0);
01339         <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
01340 
01341         Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a>(FrameNumber);
01342         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount = 0;
01343         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount = 0;
01344     }
01345 
01346     CurrentProcess = <a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a>();
01347     CurrentProcess-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o23">WorkingSetPage</a> = FrameNumber;
01348     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a>(EndPde);
01349 
01350     <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a>(OldIrql);
01351 
01352     <span class="comment">//</span>
01353     <span class="comment">// Initialize the system process memory management structures including</span>
01354     <span class="comment">// the working set list.</span>
01355     <span class="comment">//</span>
01356 
01357     PointerPte = <a class="code" href="../../d4/d8/mi_8h.html#a615">MmFirstReservedMappingPte</a>;
01358     PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a65">NUMBER_OF_MAPPING_PTES</a>;
01359     CurrentProcess-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o16">Vm</a>.<a class="code" href="../../d3/d6/struct__MMSUPPORT.html#o6">MaximumWorkingSetSize</a> = (ULONG)<a class="code" href="../../d4/d8/mi_8h.html#a740">MmSystemProcessWorkingSetMax</a>;
01360     CurrentProcess-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o16">Vm</a>.<a class="code" href="../../d3/d6/struct__MMSUPPORT.html#o5">MinimumWorkingSetSize</a> = (ULONG)<a class="code" href="../../d4/d8/mi_8h.html#a739">MmSystemProcessWorkingSetMin</a>;
01361 
01362     <a class="code" href="../../d4/d5/procsup_8c.html#a30">MmInitializeProcessAddressSpace</a>(CurrentProcess, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
01363 
01364     <span class="comment">//</span>
01365     <span class="comment">// Check to see if moving the secondary page structures to the end</span>
01366     <span class="comment">// of the PFN database is a waste of memory.  And if so, copy it</span>
01367     <span class="comment">// to paged pool.</span>
01368     <span class="comment">//</span>
01369     <span class="comment">// If the PFN database ends on a page aligned boundary and the</span>
01370     <span class="comment">// size of the two arrays is less than a page, free the page</span>
01371     <span class="comment">// and allocate nonpagedpool for this.</span>
01372     <span class="comment">//</span>
01373 
01374     <span class="keywordflow">if</span> ((((ULONG_PTR)<a class="code" href="../../d4/d2/datalpha_8c.html#a20">MmFreePagesByColor</a>[0] &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1)) == 0) &amp;&amp;
01375        ((<a class="code" href="../../d8/d0/cmdat3_8c.html#a25">MmSecondaryColors</a> * 2 * <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d1/struct__MMCOLOR__TABLES.html">MMCOLOR_TABLES</a>)) &lt; <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>)) {
01376 
01377         <a class="code" href="../../d4/d1/struct__MMCOLOR__TABLES.html">PMMCOLOR_TABLES</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a35">c</a>;
01378 
01379         <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a35">c</a> = <a class="code" href="../../d4/d2/datalpha_8c.html#a20">MmFreePagesByColor</a>[0];
01380         <a class="code" href="../../d4/d2/datalpha_8c.html#a20">MmFreePagesByColor</a>[0] =
01381             <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>(<a class="code" href="../../d5/d8/ex_8h.html#a329a175">NonPagedPoolMustSucceed</a>,
01382                                   <a class="code" href="../../d8/d0/cmdat3_8c.html#a25">MmSecondaryColors</a> * 2 * <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d1/struct__MMCOLOR__TABLES.html">MMCOLOR_TABLES</a>),
01383                                   '  mM');
01384 
01385         <a class="code" href="../../d4/d2/datalpha_8c.html#a20">MmFreePagesByColor</a>[1] = &amp;<a class="code" href="../../d4/d2/datalpha_8c.html#a20">MmFreePagesByColor</a>[0][<a class="code" href="../../d8/d0/cmdat3_8c.html#a25">MmSecondaryColors</a>];
01386 
01387         RtlMoveMemory (<a class="code" href="../../d4/d2/datalpha_8c.html#a20">MmFreePagesByColor</a>[0],
01388                        <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a35">c</a>,
01389                        <a class="code" href="../../d8/d0/cmdat3_8c.html#a25">MmSecondaryColors</a> * 2 * <span class="keyword">sizeof</span>(<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a202">MMCOLOR_TABLES</a>));
01390 
01391         <span class="comment">//</span>
01392         <span class="comment">// Free the page.</span>
01393         <span class="comment">//</span>
01394 
01395         <span class="keywordflow">if</span> (!<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a178">MI_IS_PHYSICAL_ADDRESS</a>(<a class="code" href="../../d2/d0/nt6_2user32_8def.html#a35">c</a>)) {
01396             PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>(<a class="code" href="../../d2/d0/nt6_2user32_8def.html#a35">c</a>);
01397             FrameNumber = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a182">MI_GET_PAGE_FRAME_FROM_PTE</a>(PointerPte);
01398             *PointerPte = <a class="code" href="../../d4/d2/datalpha_8c.html#a1">ZeroKernelPte</a>;
01399 
01400         } <span class="keywordflow">else</span> {
01401             FrameNumber = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a179">MI_CONVERT_PHYSICAL_TO_PFN</a>(<a class="code" href="../../d2/d0/nt6_2user32_8def.html#a35">c</a>);
01402         }
01403 
01404         <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
01405 
01406         Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (FrameNumber);
01407 
01408         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ((Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount &lt;= 1) &amp;&amp; (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount &lt;= 1));
01409 
01410         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount = 0;
01411         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount = 0;
01412         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a120">MI_SET_PFN_DELETED</a>(Pfn1);
01413 
01414 <span class="preprocessor">#if DBG</span>
01415 <span class="preprocessor"></span>
01416         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PageLocation = <a class="code" href="../../d2/d1/mm_8h.html#a345a173">StandbyPageList</a>;
01417 
01418 <span class="preprocessor">#endif //DBG</span>
01419 <span class="preprocessor"></span>
01420         <a class="code" href="../../d7/d5/pfnlist_8c.html#a8">MiInsertPageInList</a> (<a class="code" href="../../d4/d8/mi_8h.html#a606">MmPageLocationList</a>[<a class="code" href="../../d2/d1/mm_8h.html#a345a172">FreePageList</a>], FrameNumber);
01421 
01422         <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
01423     }
01424 
01425     <span class="keywordflow">return</span>;
01426 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:40:21 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
