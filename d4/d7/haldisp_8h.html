<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: haldisp.h File Reference</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>haldisp.h File Reference</h1>
<p>
<a href="../../d5/d6/haldisp_8h-source.html">Go to the source code of this file.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d7/d5/struct__ADAPTER__OBJECT.html">_ADAPTER_OBJECT</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d9/d9/struct__XHAL__WAIT__CONTEXT__BLOCK.html">_XHAL_WAIT_CONTEXT_BLOCK</a></td></tr>

<tr><td colspan=2><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef <a class="el" href="../../d7/d5/struct__ADAPTER__OBJECT.html">_ADAPTER_OBJECT</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d7/haldisp_8h.html#a0">ADAPTER_OBJECT</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>typedef <a class="el" href="../../d9/d9/struct__XHAL__WAIT__CONTEXT__BLOCK.html">_XHAL_WAIT_CONTEXT_BLOCK</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d7/haldisp_8h.html#a1">XHAL_WAIT_CONTEXT_BLOCK</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>typedef <a class="el" href="../../d9/d9/struct__XHAL__WAIT__CONTEXT__BLOCK.html">_XHAL_WAIT_CONTEXT_BLOCK</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d7/haldisp_8h.html#a2">PXHAL_WAIT_CONTEXT_BLOCK</a></td></tr>

<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d7/haldisp_8h.html#a3">xHalQuerySystemInformation</a> (IN <a class="el" href="../../d2/d7/hal_8h.html#a79">HAL_QUERY_INFORMATION_CLASS</a> InformationClass, IN ULONG <a class="el" href="../../d7/d2/rtqval_8c.html#a7">BufferSize</a>, OUT PVOID <a class="el" href="../../d8/d6/ttri_8c.html#a3">Buffer</a>, OUT PULONG ReturnedLength)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d7/haldisp_8h.html#a4">xHalSetSystemInformation</a> (IN <a class="el" href="../../d2/d7/hal_8h.html#a81">HAL_SET_INFORMATION_CLASS</a> InformationClass, IN ULONG <a class="el" href="../../d7/d2/rtqval_8c.html#a7">BufferSize</a>, OUT PVOID <a class="el" href="../../d8/d6/ttri_8c.html#a3">Buffer</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d7/haldisp_8h.html#a5">xHalQueryBusSlots</a> (IN <a class="el" href="../../d6/d5/struct__BUS__HANDLER.html">PBUS_HANDLER</a> BusHandler, IN ULONG <a class="el" href="../../d7/d2/rtqval_8c.html#a7">BufferSize</a>, OUT PULONG SlotNumbers, OUT PULONG ReturnedLength)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d7/haldisp_8h.html#a6">xHalSetWakeEnable</a> (IN BOOLEAN Enable)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d7/haldisp_8h.html#a7">xHalSetWakeAlarm</a> (IN ULONGLONG WakeTime, IN PTIME_FIELDS WakeTimeFields)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d7/haldisp_8h.html#a8">xHalLocateHiberRanges</a> (IN PVOID MemoryMap)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d7/haldisp_8h.html#a9">xHalRegisterBusHandler</a> (IN INTERFACE_TYPE <a class="el" href="../../d6/d0/cmdat_8c.html#a4">InterfaceType</a>, IN BUS_DATA_TYPE ConfigurationSpace, IN ULONG <a class="el" href="../../d2/d7/hal_8h.html#a75">BusNumber</a>, IN INTERFACE_TYPE ParentBusType, IN ULONG ParentBusNumber, IN ULONG SizeofBusExtensionData, IN <a class="el" href="../../d2/d7/hal_8h.html#a73">PINSTALL_BUS_HANDLER</a> InstallBusHandlers, OUT <a class="el" href="../../d6/d5/struct__BUS__HANDLER.html">PBUS_HANDLER</a> *BusHandler)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="../../d6/d5/struct__BUS__HANDLER.html">PBUS_HANDLER</a> FASTCALL&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d7/haldisp_8h.html#a10">xHalHandlerForBus</a> (IN INTERFACE_TYPE <a class="el" href="../../d6/d0/cmdat_8c.html#a4">InterfaceType</a>, IN ULONG <a class="el" href="../../d2/d7/hal_8h.html#a75">BusNumber</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID FASTCALL&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d7/haldisp_8h.html#a11">xHalExamineMBR</a> (IN <a class="el" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject, IN ULONG SectorSize, IN ULONG MBRTypeIdentifier, OUT PVOID *<a class="el" href="../../d8/d6/ttri_8c.html#a3">Buffer</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID FASTCALL&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d7/haldisp_8h.html#a12">xHalIoAssignDriveLetters</a> (IN struct <a class="el" href="../../d1/d2/struct__LOADER__PARAMETER__BLOCK.html">_LOADER_PARAMETER_BLOCK</a> *LoaderBlock, IN PSTRING NtDeviceName, OUT PUCHAR NtSystemPath, OUT PSTRING NtSystemPathString)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS FASTCALL&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d7/haldisp_8h.html#a13">xHalIoReadPartitionTable</a> (IN <a class="el" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject, IN ULONG SectorSize, IN BOOLEAN ReturnRecognizedPartitions, OUT struct _DRIVE_LAYOUT_INFORMATION **PartitionBuffer)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS FASTCALL&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d7/haldisp_8h.html#a14">xHalIoSetPartitionInformation</a> (IN <a class="el" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject, IN ULONG SectorSize, IN ULONG PartitionNumber, IN ULONG PartitionType)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS FASTCALL&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d7/haldisp_8h.html#a15">xHalIoWritePartitionTable</a> (IN <a class="el" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject, IN ULONG SectorSize, IN ULONG SectorsPerTrack, IN ULONG NumberOfHeads, IN struct _DRIVE_LAYOUT_INFORMATION *PartitionBuffer)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID FASTCALL&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d7/haldisp_8h.html#a16">xHalReferenceHandler</a> (IN <a class="el" href="../../d6/d5/struct__BUS__HANDLER.html">PBUS_HANDLER</a> Handler)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d7/haldisp_8h.html#a17">xHalInitPnpDriver</a> (VOID)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d7/haldisp_8h.html#a18">xHalInitPowerManagement</a> (IN <a class="el" href="../../d0/d6/struct__PM__DISPATCH__TABLE.html">PPM_DISPATCH_TABLE</a> PmDriverDispatchTable, IN OUT <a class="el" href="../../d0/d6/struct__PM__DISPATCH__TABLE.html">PPM_DISPATCH_TABLE</a> *<a class="el" href="../../d6/d7/ntacpi_8h.html#a70">PmHalDispatchTable</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="../../d7/d6/struct__DMA__ADAPTER.html">PDMA_ADAPTER</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d7/haldisp_8h.html#a19">xHalGetDmaAdapter</a> (IN PVOID Context, IN struct <a class="el" href="../../d7/d3/struct__DEVICE__DESCRIPTION.html">_DEVICE_DESCRIPTION</a> *DeviceDescriptor, OUT PULONG NumberOfMapRegisters)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d7/haldisp_8h.html#a20">xHalPutDmaAdapter</a> (<a class="el" href="../../d7/d6/struct__DMA__ADAPTER.html">PDMA_ADAPTER</a> DmaAdapter)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>PVOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d7/haldisp_8h.html#a21">xHalAllocateCommonBuffer</a> (IN <a class="el" href="../../d7/d6/struct__DMA__ADAPTER.html">PDMA_ADAPTER</a> DmaAdapter, IN ULONG Length, OUT PPHYSICAL_ADDRESS LogicalAddress, IN BOOLEAN CacheEnabled)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d7/haldisp_8h.html#a22">xHalFreeCommonBuffer</a> (IN <a class="el" href="../../d7/d6/struct__DMA__ADAPTER.html">PDMA_ADAPTER</a> DmaAdapter, IN ULONG Length, IN PHYSICAL_ADDRESS LogicalAddress, IN PVOID VirtualAddress, IN BOOLEAN CacheEnabled)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d7/haldisp_8h.html#a23">xHalAllocateAdapterChannel</a> (IN <a class="el" href="../../d7/d6/struct__DMA__ADAPTER.html">PDMA_ADAPTER</a> DmaAdapter, IN <a class="el" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject, IN ULONG NumberOfMapRegisters, IN <a class="el" href="../../d0/d5/io_8h.html#a323">PDRIVER_CONTROL</a> ExecutionRoutine, IN PVOID Context)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d7/haldisp_8h.html#a24">xHalFlushAdapterBuffers</a> (IN <a class="el" href="../../d7/d6/struct__DMA__ADAPTER.html">PDMA_ADAPTER</a> DmaAdapter, IN <a class="el" href="../../d6/d7/struct__MDL.html">PMDL</a> Mdl, IN PVOID MapRegisterBase, IN PVOID CurrentVa, IN ULONG Length, IN BOOLEAN WriteToDevice)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d7/haldisp_8h.html#a25">xHalFreeAdapterChannel</a> (IN <a class="el" href="../../d7/d6/struct__DMA__ADAPTER.html">PDMA_ADAPTER</a> DmaAdapter)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d7/haldisp_8h.html#a26">xHalFreeMapRegisters</a> (IN <a class="el" href="../../d7/d6/struct__DMA__ADAPTER.html">PDMA_ADAPTER</a> DmaAdapter, PVOID MapRegisterBase, ULONG NumberOfMapRegisters)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>PHYSICAL_ADDRESS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d7/haldisp_8h.html#a27">xHalMapTransfer</a> (IN <a class="el" href="../../d7/d6/struct__DMA__ADAPTER.html">PDMA_ADAPTER</a> DmaAdapter, IN <a class="el" href="../../d6/d7/struct__MDL.html">PMDL</a> Mdl, IN PVOID MapRegisterBase, IN PVOID CurrentVa, IN OUT PULONG Length, IN BOOLEAN WriteToDevice)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>ULONG&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d7/haldisp_8h.html#a28">xHalGetDmaAlignment</a> (IN <a class="el" href="../../d7/d6/struct__DMA__ADAPTER.html">PDMA_ADAPTER</a> DmaAdapter)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>ULONG&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d7/haldisp_8h.html#a29">xHalReadDmaCounter</a> (IN <a class="el" href="../../d7/d6/struct__DMA__ADAPTER.html">PDMA_ADAPTER</a> DmaAdapter)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d7/haldisp_8h.html#a30">xHalGetScatterGatherList</a> (IN <a class="el" href="../../d7/d6/struct__DMA__ADAPTER.html">PDMA_ADAPTER</a> DmaAdapter, IN <a class="el" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject, IN <a class="el" href="../../d6/d7/struct__MDL.html">PMDL</a> Mdl, IN PVOID CurrentVa, IN ULONG Length, IN <a class="el" href="../../d2/d7/hal_8h.html#a138">PDRIVER_LIST_CONTROL</a> ExecutionRoutine, IN PVOID Context, IN BOOLEAN WriteToDevice)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d7/haldisp_8h.html#a31">xHalPutScatterGatherList</a> (IN <a class="el" href="../../d7/d6/struct__DMA__ADAPTER.html">PDMA_ADAPTER</a> DmaAdapter, IN <a class="el" href="../../d6/d8/struct__SCATTER__GATHER__LIST.html">PSCATTER_GATHER_LIST</a> ScatterGather, IN BOOLEAN WriteToDevice)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="../../d0/d5/io_8h.html#a321">IO_ALLOCATION_ACTION</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d7/haldisp_8h.html#a32">xHalpAllocateAdapterCallback</a> (IN struct <a class="el" href="../../d8/d4/struct__DEVICE__OBJECT.html">_DEVICE_OBJECT</a> *DeviceObject, IN struct <a class="el" href="../../d0/d2/struct__IRP.html">_IRP</a> *<a class="el" href="../../d0/d6/iop_8h.html#a35">Irp</a>, IN PVOID MapRegisterBase, IN PVOID Context)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d7/haldisp_8h.html#a33">xHalGetInterruptTranslator</a> (IN INTERFACE_TYPE ParentInterfaceType, IN ULONG ParentBusNumber, IN INTERFACE_TYPE BridgeInterfaceType, IN <a class="el" href="../../d0/d6/jul98_2test_2icc__i386_8h.html#a14">USHORT</a> <a class="el" href="../../d9/d7/w98_2lh__open_2pi__mem_8h.html#a0">Size</a>, IN <a class="el" href="../../d0/d6/jul98_2test_2icc__i386_8h.html#a14">USHORT</a> <a class="el" href="../../d2/d5/editreg_8c.html#a50">Version</a>, OUT <a class="el" href="../../d3/d2/struct__TRANSLATOR__INTERFACE.html">PTRANSLATOR_INTERFACE</a> Translator, OUT PULONG BridgeBusNumber)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d7/haldisp_8h.html#a34">xHalTranslateBusAddress</a> (IN INTERFACE_TYPE <a class="el" href="../../d6/d0/cmdat_8c.html#a4">InterfaceType</a>, IN ULONG <a class="el" href="../../d2/d7/hal_8h.html#a75">BusNumber</a>, IN PHYSICAL_ADDRESS BusAddress, IN OUT PULONG AddressSpace, OUT PPHYSICAL_ADDRESS TranslatedAddress)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d7/haldisp_8h.html#a35">xHalAssignSlotResources</a> (IN PUNICODE_STRING RegistryPath, IN PUNICODE_STRING DriverClassName OPTIONAL, IN <a class="el" href="../../d4/d9/struct__DRIVER__OBJECT.html">PDRIVER_OBJECT</a> DriverObject, IN <a class="el" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject OPTIONAL, IN INTERFACE_TYPE BusType, IN ULONG <a class="el" href="../../d2/d7/hal_8h.html#a75">BusNumber</a>, IN ULONG SlotNumber, IN OUT PCM_RESOURCE_LIST *AllocatedResources)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d7/haldisp_8h.html#a36">xHalHaltSystem</a> (VOID)</td></tr>

</table>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="a0" doxytag="haldisp.h::ADAPTER_OBJECT" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef struct <a class="el" href="../../d7/d5/struct__ADAPTER__OBJECT.html">_ADAPTER_OBJECT</a> <a class="el" href="../../d7/d5/struct__ADAPTER__OBJECT.html">ADAPTER_OBJECT</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a2" doxytag="haldisp.h::PXHAL_WAIT_CONTEXT_BLOCK" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef struct <a class="el" href="../../d9/d9/struct__XHAL__WAIT__CONTEXT__BLOCK.html">_XHAL_WAIT_CONTEXT_BLOCK</a> * <a class="el" href="../../d9/d9/struct__XHAL__WAIT__CONTEXT__BLOCK.html">PXHAL_WAIT_CONTEXT_BLOCK</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a1" doxytag="haldisp.h::XHAL_WAIT_CONTEXT_BLOCK" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef struct <a class="el" href="../../d9/d9/struct__XHAL__WAIT__CONTEXT__BLOCK.html">_XHAL_WAIT_CONTEXT_BLOCK</a>  <a class="el" href="../../d9/d9/struct__XHAL__WAIT__CONTEXT__BLOCK.html">XHAL_WAIT_CONTEXT_BLOCK</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a23" doxytag="haldisp.h::xHalAllocateAdapterChannel" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS xHalAllocateAdapterChannel           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d7/d6/struct__DMA__ADAPTER.html">PDMA_ADAPTER</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>DmaAdapter</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>DeviceObject</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>NumberOfMapRegisters</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d0/d5/io_8h.html#a323">PDRIVER_CONTROL</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>ExecutionRoutine</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>Context</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a21" doxytag="haldisp.h::xHalAllocateCommonBuffer" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> PVOID xHalAllocateCommonBuffer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d7/d6/struct__DMA__ADAPTER.html">PDMA_ADAPTER</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>DmaAdapter</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Length</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PPHYSICAL_ADDRESS&nbsp;</td>
          <td class="mdname" nowrap> <em>LogicalAddress</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN BOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>CacheEnabled</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a35" doxytag="haldisp.h::xHalAssignSlotResources" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS xHalAssignSlotResources           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PUNICODE_STRING&nbsp;</td>
          <td class="mdname" nowrap> <em>RegistryPath</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PUNICODE_STRING DriverClassName&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d4/d9/struct__DRIVER__OBJECT.html">PDRIVER_OBJECT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>DriverObject</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN INTERFACE_TYPE&nbsp;</td>
          <td class="mdname" nowrap> <em>BusType</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>BusNumber</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>SlotNumber</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN OUT PCM_RESOURCE_LIST *&nbsp;</td>
          <td class="mdname" nowrap> <em>AllocatedResources</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d6/halfnc_8c-source.html#l00884">884</a> of file <a class="el" href="../../d6/d6/halfnc_8c-source.html">halfnc.c</a>.
<p>
References <a class="el" href="../../d0/d1/bugcheck_8c-source.html#l00428">KeBugCheckEx()</a>.
<p>
<pre class="fragment"><div>00894 {
00895     <span class="comment">//</span>
00896     <span class="comment">// If the HAL fails to override this function, then</span>
00897     <span class="comment">// the HAL has clearly failed to initialize.</span>
00898     <span class="comment">//</span>
00899 
00900     <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a>(HAL_INITIALIZATION_FAILED, 0, 0, 0, 7);
00901     <span class="keywordflow">return</span> STATUS_NOT_IMPLEMENTED;
00902 }
</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a11" doxytag="haldisp.h::xHalExamineMBR" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID FASTCALL xHalExamineMBR           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>DeviceObject</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>SectorSize</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>MBRTypeIdentifier</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PVOID *&nbsp;</td>
          <td class="mdname" nowrap> <em>Buffer</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d8/d1/drivesup_8c-source.html#l00190">190</a> of file <a class="el" href="../../d8/d1/drivesup_8c-source.html">drivesup.c</a>.
<p>
<pre class="fragment"><div>00199                    :
00200 
00201     Given a master boot record <a class="code" href="../../d4/d4/iafptrap_8c.html#a9">type</a> (MBR - the zero'th sector on the disk),
00202     read <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> master boot record of a disk.  If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> MBR <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> found to be of that
00203     <a class="code" href="../../d3/d5/i386_2trapc_8c.html#a9">type</a>, allocate a structure whose layout <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> dependant upon that partition
00204     <a class="code" href="../../d3/d5/i386_2trapc_8c.html#a9">type</a>, fill with <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> appropriate values, and <span class="keywordflow">return</span> a pointer to that buffer
00205     in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> output parameter.
00206 
00207     The best example <span class="keywordflow">for</span> a use of <span class="keyword">this</span> routine <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> to support Ontrack
00208     systems DiskManager software.  Ontrack software lays down a special
00209     partition describing <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> entire drive.  The special partition <a class="code" href="../../d3/d5/i386_2trapc_8c.html#a9">type</a>
00210     (0x54) will be recognized and a couple of longwords of data will
00211     be passed back in a buffer <span class="keywordflow">for</span> a disk driver to act upon.
00212 
00213 Arguments:
00214 
00215     DeviceObject - The device object describing <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> entire drive.
00216 
00217     <a class="code" href="../../d3/d8/udfprocs_8h.html#a42">SectorSize</a> - The <a class="code" href="../../d0/d4/mrcf_8c.html#a3">minimum</a> number of bytes that an IO operation can
00218                  fetch.
00219 
00220     MBRIndentifier - <a class="code" href="../../d2/d1/bench_8h.html#a5">A</a> value that will be searched <span class="keywordflow">for</span> in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
00221                      in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> MBR.  This routine will understand
00222                      <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> semantics implied by <span class="keyword">this</span> value.
00223 
00224     <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> - Pointer to a buffer that returns data according to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
00225              <a class="code" href="../../d3/d5/i386_2trapc_8c.html#a9">type</a> of MBR searched <span class="keywordflow">for</span>.  If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> MBR <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> not of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
00226              <a class="code" href="../../d3/d5/i386_2trapc_8c.html#a9">type</a> asked <span class="keywordflow">for</span>, <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> buffer will not be allocated and <span class="keyword">this</span>
00227              pointer will be <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>.  It <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> responsibility of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
00228              caller of <a class="code" href="../../d2/d7/hal_8h.html#a23">HalExamineMBR</a> to deallocate <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> buffer.  The
00229              caller should deallocate <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> memory ASAP.
00230 
00231 Return Value:
00232 
00233     None.
00234 
00235 --*/
00236 
00237 {
00238 
00239 
00240     LARGE_INTEGER partitionTableOffset;
00241     PUCHAR readBuffer = (PUCHAR) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00242     <a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a> event;
00243     IO_STATUS_BLOCK ioStatus;
00244     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
00245     <a class="code" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html">PPARTITION_DESCRIPTOR</a> partitionTableEntry;
00246     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status = STATUS_SUCCESS;
00247     ULONG readSize;
00248 
00249     *<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00250     <span class="comment">//</span>
00251     <span class="comment">// Determine the size of a read operation to ensure that at least 512</span>
00252     <span class="comment">// bytes are read.  This will guarantee that enough data is read to</span>
00253     <span class="comment">// include an entire partition table.  Note that this code assumes that</span>
00254     <span class="comment">// the actual sector size of the disk (if less than 512 bytes) is a</span>
00255     <span class="comment">// multiple of 2, a fairly reasonable assumption.</span>
00256     <span class="comment">//</span>
00257 
00258     <span class="keywordflow">if</span> (<a class="code" href="../../d3/d8/udfprocs_8h.html#a42">SectorSize</a> &gt;= 512) {
00259         readSize = <a class="code" href="../../d3/d8/udfprocs_8h.html#a42">SectorSize</a>;
00260     } <span class="keywordflow">else</span> {
00261         readSize = 512;
00262     }
00263 
00264     <span class="comment">//</span>
00265     <span class="comment">// Start at sector 0 of the device.</span>
00266     <span class="comment">//</span>
00267 
00268     partitionTableOffset = RtlConvertUlongToLargeInteger( 0 );
00269 
00270     <span class="comment">//</span>
00271     <span class="comment">// Allocate a buffer that will hold the reads.</span>
00272     <span class="comment">//</span>
00273 
00274     readBuffer = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>(
00275                      NonPagedPoolCacheAligned,
00276                      PAGE_SIZE&gt;readSize?PAGE_SIZE:readSize,
00277                      'btsF'
00278                      );
00279 
00280     <span class="keywordflow">if</span> (readBuffer == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00281         <span class="keywordflow">return</span>;
00282     }
00283 
00284     <span class="comment">//</span>
00285     <span class="comment">// Read record containing partition table.</span>
00286     <span class="comment">//</span>
00287     <span class="comment">// Create a notification event object to be used while waiting for</span>
00288     <span class="comment">// the read request to complete.</span>
00289     <span class="comment">//</span>
00290 
00291     <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( &amp;event, NotificationEvent, FALSE );
00292 
00293     irp = <a class="code" href="../../d4/d6/iosubs_8c.html#a27">IoBuildSynchronousFsdRequest</a>( IRP_MJ_READ,
00294                                         DeviceObject,
00295                                         readBuffer,
00296                                         readSize,
00297                                         &amp;partitionTableOffset,
00298                                         &amp;event,
00299                                         &amp;ioStatus );
00300 
00301     <span class="keywordflow">if</span> (!irp) {
00302         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(readBuffer);
00303         <span class="keywordflow">return</span>;
00304     } <span class="keywordflow">else</span> {
00305         <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpStack;
00306         irpStack = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>(irp);
00307         irpStack-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o2">Flags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a203">SL_OVERRIDE_VERIFY_VOLUME</a>;
00308     }
00309 
00310     status = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>( DeviceObject, irp );
00311 
00312     <span class="keywordflow">if</span> (status == STATUS_PENDING) {
00313         (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;event,
00314                                       Executive,
00315                                       KernelMode,
00316                                       FALSE,
00317                                       (PLARGE_INTEGER) NULL);
00318         status = ioStatus.Status;
00319     }
00320 
00321     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
00322         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(readBuffer);
00323         <span class="keywordflow">return</span>;
00324     }
00325 
00326     <span class="comment">//</span>
00327     <span class="comment">// Check for Boot Record signature.</span>
00328     <span class="comment">//</span>
00329 
00330     <span class="keywordflow">if</span> (((<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>) readBuffer)[<a class="code" href="../../d2/d7/hal_8h.html#a11">BOOT_SIGNATURE_OFFSET</a>] != <a class="code" href="../../d2/d7/hal_8h.html#a12">BOOT_RECORD_SIGNATURE</a>) {
00331         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(readBuffer);
00332         <span class="keywordflow">return</span>;
00333     }
00334 
00335     <span class="comment">//</span>
00336     <span class="comment">// Check for DM type partition.</span>
00337     <span class="comment">//</span>
00338 
00339     partitionTableEntry = (<a class="code" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html">PPARTITION_DESCRIPTOR</a>) &amp;(((<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>) readBuffer)[<a class="code" href="../../d2/d7/hal_8h.html#a10">PARTITION_TABLE_OFFSET</a>]);
00340 
00341     <span class="keywordflow">if</span> (partitionTableEntry-&gt;<a class="code" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html#o4">PartitionType</a> != MBRTypeIdentifier) {
00342 
00343         <span class="comment">//</span>
00344         <span class="comment">// The partition type isn't what the caller cares about.</span>
00345         <span class="comment">//</span>
00346         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(readBuffer);
00347 
00348     } <span class="keywordflow">else</span> {
00349 
00350         <span class="keywordflow">if</span> (partitionTableEntry-&gt;<a class="code" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html#o4">PartitionType</a> == 0x54) {
00351 
00352             <span class="comment">//</span>
00353             <span class="comment">// Rather than allocate a new piece of memory to return</span>
00354             <span class="comment">// the data - just use the memory allocated for the buffer.</span>
00355             <span class="comment">// We can assume the caller will delete this shortly.</span>
00356             <span class="comment">//</span>
00357 
00358             ((PULONG)readBuffer)[0] = 63;
00359             *<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> = readBuffer;
00360 
00361         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (partitionTableEntry-&gt;<a class="code" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html#o4">PartitionType</a> == 0x55) {
00362 
00363             <span class="comment">//</span>
00364             <span class="comment">// EzDrive Parititon.  Simply return the pointer to non-null</span>
00365             <span class="comment">// There is no skewing here.</span>
00366             <span class="comment">//</span>
00367 
00368             *<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> = readBuffer;
00369 
00370         } <span class="keywordflow">else</span> {
00371 
00372             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(partitionTableEntry-&gt;<a class="code" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html#o4">PartitionType</a> == 0x55);
00373 
00374         }
00375 
00376     }
00377 
00378 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a24" doxytag="haldisp.h::xHalFlushAdapterBuffers" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> BOOLEAN xHalFlushAdapterBuffers           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d7/d6/struct__DMA__ADAPTER.html">PDMA_ADAPTER</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>DmaAdapter</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d6/d7/struct__MDL.html">PMDL</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>Mdl</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>MapRegisterBase</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>CurrentVa</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Length</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN BOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>WriteToDevice</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a25" doxytag="haldisp.h::xHalFreeAdapterChannel" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID xHalFreeAdapterChannel           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d7/d6/struct__DMA__ADAPTER.html">PDMA_ADAPTER</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>DmaAdapter</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a22" doxytag="haldisp.h::xHalFreeCommonBuffer" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID xHalFreeCommonBuffer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d7/d6/struct__DMA__ADAPTER.html">PDMA_ADAPTER</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>DmaAdapter</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Length</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PHYSICAL_ADDRESS&nbsp;</td>
          <td class="mdname" nowrap> <em>LogicalAddress</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>VirtualAddress</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN BOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>CacheEnabled</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a26" doxytag="haldisp.h::xHalFreeMapRegisters" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID xHalFreeMapRegisters           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d7/d6/struct__DMA__ADAPTER.html">PDMA_ADAPTER</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>DmaAdapter</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>MapRegisterBase</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>NumberOfMapRegisters</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a19" doxytag="haldisp.h::xHalGetDmaAdapter" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="../../d7/d6/struct__DMA__ADAPTER.html">PDMA_ADAPTER</a> xHalGetDmaAdapter           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>Context</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN struct <a class="el" href="../../d7/d3/struct__DEVICE__DESCRIPTION.html">_DEVICE_DESCRIPTION</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>DeviceDescriptor</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>NumberOfMapRegisters</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a28" doxytag="haldisp.h::xHalGetDmaAlignment" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ULONG xHalGetDmaAlignment           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d7/d6/struct__DMA__ADAPTER.html">PDMA_ADAPTER</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>DmaAdapter</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a33" doxytag="haldisp.h::xHalGetInterruptTranslator" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS xHalGetInterruptTranslator           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN INTERFACE_TYPE&nbsp;</td>
          <td class="mdname" nowrap> <em>ParentInterfaceType</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>ParentBusNumber</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN INTERFACE_TYPE&nbsp;</td>
          <td class="mdname" nowrap> <em>BridgeInterfaceType</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d0/d6/jul98_2test_2icc__i386_8h.html#a14">USHORT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>Size</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d0/d6/jul98_2test_2icc__i386_8h.html#a14">USHORT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>Version</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT <a class="el" href="../../d3/d2/struct__TRANSLATOR__INTERFACE.html">PTRANSLATOR_INTERFACE</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>Translator</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>BridgeBusNumber</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d2/d4/translate_8c-source.html#l00107">107</a> of file <a class="el" href="../../d2/d4/translate_8c-source.html">translate.c</a>.
<p>
References <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>.
<p>
<pre class="fragment"><div>00118                    :
00119 
00120 
00121 Arguments:
00122 
00123         ParentInterfaceType - The <a class="code" href="../../d3/d5/i386_2trapc_8c.html#a9">type</a> of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> bus <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> bridge lives on (normally PCI).
00124 
00125         ParentBusNumber - The number of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> bus <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> bridge lives on.
00126 
00127         ParentSlotNumber - The slot number <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> bridge lives in (where valid).
00128 
00129         BridgeInterfaceType - The bus <a class="code" href="../../d3/d5/i386_2trapc_8c.html#a9">type</a> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> bridge provides (ie ISA <span class="keywordflow">for</span> a PCI-ISA bridge).
00130 
00131         ResourceType - The resource <a class="code" href="../../d3/d5/i386_2trapc_8c.html#a9">type</a> we want to translate.
00132 
00133         <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> - The size of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> translator buffer.
00134 
00135         <a class="code" href="../../d2/d5/editreg_8c.html#a50">Version</a> - The version of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> translator interface requested.
00136 
00137         Translator - Pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> buffer where <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> translator should be returned
00138 
00139         BridgeBusNumber - Pointer to where <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> bus number of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> bridge bus should be returned
00140 
00141 Return Value:
00142 
00143     Returns <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> status of <span class="keyword">this</span> operation.
00144 
00145 --*/
00146 {
00147     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00148 
00149 <span class="preprocessor">#if defined(NO_LEGACY_DRIVERS)</span>
00150 <span class="preprocessor"></span>    <span class="keywordflow">return</span> STATUS_SUCCESS;
00151 }
00152 <span class="preprocessor">#else</span>
00153 <span class="preprocessor"></span>
00154     UNREFERENCED_PARAMETER(ParentInterfaceType);
00155     UNREFERENCED_PARAMETER(ParentBusNumber);
00156 
00157     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(Version == HAL_IRQ_TRANSLATOR_VERSION);
00158     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(Size &gt;= <span class="keyword">sizeof</span> (<a class="code" href="../../d3/d2/struct__TRANSLATOR__INTERFACE.html">TRANSLATOR_INTERFACE</a>));
00159 
00160     <span class="keywordflow">switch</span> (BridgeInterfaceType) {
00161     <span class="keywordflow">case</span> Eisa:
00162     <span class="keywordflow">case</span> Isa:
00163     <span class="keywordflow">case</span> MicroChannel:
00164     <span class="keywordflow">case</span> InterfaceTypeUndefined:    <span class="comment">// special "IDE" cookie</span>
00165 
00166         <span class="comment">//</span>
00167         <span class="comment">// Pass back an interface for an IRQ translator.</span>
00168         <span class="comment">//</span>
00169         RtlZeroMemory(Translator, <span class="keyword">sizeof</span> (<a class="code" href="../../d3/d2/struct__TRANSLATOR__INTERFACE.html">TRANSLATOR_INTERFACE</a>));
00170 
00171         Translator-&gt;Size = <span class="keyword">sizeof</span> (<a class="code" href="../../d3/d2/struct__TRANSLATOR__INTERFACE.html">TRANSLATOR_INTERFACE</a>);
00172         Translator-&gt;Version = <a class="code" href="../../d1/d5/translate_8c.html#a3">HAL_IRQ_TRANSLATOR_VERSION</a>;
00173         Translator-&gt;InterfaceReference = &amp;<a class="code" href="../../d1/d5/translate_8c.html#a7">FstubTranslatorNull</a>;
00174         Translator-&gt;InterfaceDereference = &amp;<a class="code" href="../../d1/d5/translate_8c.html#a7">FstubTranslatorNull</a>;
00175         Translator-&gt;TranslateResources = &amp;<a class="code" href="../../d1/d5/translate_8c.html#a5">FstubTranslateResource</a>;
00176         Translator-&gt;TranslateResourceRequirements = &amp;<a class="code" href="../../d1/d5/translate_8c.html#a6">FstubTranslateRequirement</a>;
00177 
00178         <span class="keywordflow">if</span> (BridgeInterfaceType == InterfaceTypeUndefined) {
00179             Translator-&gt;Context = (PVOID)Isa;
00180         } <span class="keywordflow">else</span> {
00181             Translator-&gt;Context = (PVOID)BridgeInterfaceType;
00182         }
00183 
00184         <span class="keywordflow">return</span> STATUS_SUCCESS;
00185 
00186     <span class="keywordflow">default</span>:
00187         <span class="keywordflow">return</span> STATUS_NOT_IMPLEMENTED;
00188     }
00189 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a30" doxytag="haldisp.h::xHalGetScatterGatherList" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS xHalGetScatterGatherList           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d7/d6/struct__DMA__ADAPTER.html">PDMA_ADAPTER</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>DmaAdapter</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>DeviceObject</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d6/d7/struct__MDL.html">PMDL</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>Mdl</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>CurrentVa</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Length</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d2/d7/hal_8h.html#a138">PDRIVER_LIST_CONTROL</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>ExecutionRoutine</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>Context</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN BOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>WriteToDevice</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a36" doxytag="haldisp.h::xHalHaltSystem" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID xHalHaltSystem           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">VOID&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d6/halfnc_8c-source.html#l00905">905</a> of file <a class="el" href="../../d6/d6/halfnc_8c-source.html">halfnc.c</a>.
<p>
<pre class="fragment"><div>00908 {
00909     <span class="keywordflow">for</span> (;;) ;
00910 }
</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a10" doxytag="haldisp.h::xHalHandlerForBus" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="../../d6/d5/struct__BUS__HANDLER.html">PBUS_HANDLER</a> FASTCALL xHalHandlerForBus           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN INTERFACE_TYPE&nbsp;</td>
          <td class="mdname" nowrap> <em>InterfaceType</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>BusNumber</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d6/halfnc_8c-source.html#l00177">177</a> of file <a class="el" href="../../d6/d6/halfnc_8c-source.html">halfnc.c</a>.
<p>
References <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>.
<p>
<pre class="fragment"><div>00181 {
00182     <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00183 }
</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a17" doxytag="haldisp.h::xHalInitPnpDriver" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS xHalInitPnpDriver           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">VOID&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d6/halfnc_8c-source.html#l00193">193</a> of file <a class="el" href="../../d6/d6/halfnc_8c-source.html">halfnc.c</a>.
<p>
<pre class="fragment"><div>00196 {
00197     <span class="keywordflow">return</span> STATUS_NOT_SUPPORTED;
00198 }
</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a18" doxytag="haldisp.h::xHalInitPowerManagement" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS xHalInitPowerManagement           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d0/d6/struct__PM__DISPATCH__TABLE.html">PPM_DISPATCH_TABLE</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>PmDriverDispatchTable</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN OUT <a class="el" href="../../d0/d6/struct__PM__DISPATCH__TABLE.html">PPM_DISPATCH_TABLE</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>PmHalDispatchTable</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d6/halfnc_8c-source.html#l00201">201</a> of file <a class="el" href="../../d6/d6/halfnc_8c-source.html">halfnc.c</a>.
<p>
<pre class="fragment"><div>00205 {
00206     <span class="keywordflow">return</span> STATUS_NOT_SUPPORTED;
00207 }
</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a12" doxytag="haldisp.h::xHalIoAssignDriveLetters" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID FASTCALL xHalIoAssignDriveLetters           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN struct <a class="el" href="../../d1/d2/struct__LOADER__PARAMETER__BLOCK.html">_LOADER_PARAMETER_BLOCK</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>LoaderBlock</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PSTRING&nbsp;</td>
          <td class="mdname" nowrap> <em>NtDeviceName</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PUCHAR&nbsp;</td>
          <td class="mdname" nowrap> <em>NtSystemPath</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PSTRING&nbsp;</td>
          <td class="mdname" nowrap> <em>NtSystemPathString</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d8/d1/drivesup_8c-source.html#l01243">1243</a> of file <a class="el" href="../../d8/d1/drivesup_8c-source.html">drivesup.c</a>.
<p>
<pre class="fragment"><div>01252                    :
01253 
01254     This routine assigns DOS drive letters to eligible disk partitions
01255     and CDROM drives. It also maps <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> partition containing <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> NT
01256     boot <a class="code" href="../../d3/d3/dumpuser_8c.html#a14">path</a> to \SystemRoot. In NT, objects are built <span class="keywordflow">for</span> all partition
01257     types except 0 (unused) and 5 (extended). But drive letters are assigned
01258     <a class="code" href="../../d3/d0/imm32_8def.html#a1">only</a> to recognized partition types (1, 4, 6, 7, e).
01259 
01260     Drive letter assignment <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> done in several stages:
01261 
01262         1) For each CdRom:
01263             Determine <span class="keywordflow">if</span> sticky letters are assigned and reserve <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> letter.
01264 
01265         2) For each disk:
01266             Determine how many primary partitions and which <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> bootable.
01267             Determine which partitions already have 'sticky letters'
01268                 and create their symbolic links.
01269             <a class="code" href="../../d4/d5/conimep_8h.html#a111">Create</a> a bit map <span class="keywordflow">for</span> each disk that idicates which partitions
01270                 require <span class="keywordflow">default</span> drive letter assignments.
01271 
01272         3) For each disk:
01273             Assign <span class="keywordflow">default</span> drive letters <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> bootable
01274                 primary partition or <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> first nonbootable primary partition.
01275 
01276         4) For each disk:
01277             Assign <span class="keywordflow">default</span> drive letters <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> partitions in
01278                 extended volumes.
01279 
01280         5) For each disk:
01281             Assign <span class="keywordflow">default</span> drive letters <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> remaining (ENHANCED)
01282                 primary partitions.
01283 
01284         6) Assign A: and B: to the first two floppies in the system if they
01285             exist. Then assign remaining floppies next available drive letters.
01286 
01287         7) Assign drive letters to CdRoms (either sticky or default).
01288 
01289 Arguments:
01290 
01291     LoaderBlock - pointer to a loader parameter block.
01292 
01293     NtDeviceName - pointer to the boot device name string used
01294             to resolve NtSystemPath.
01295 
01296 Return Value:
01297 
01298     None.
01299 
01300 --*/
01301 
01302 {
01303     PUCHAR ntName;
01304     STRING ansiString;
01305     UNICODE_STRING unicodeString;
01306     PUCHAR ntPhysicalName;
01307     STRING ansiPhysicalString;
01308     UNICODE_STRING unicodePhysicalString;
01309     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
01310     OBJECT_ATTRIBUTES objectAttributes;
01311     <a class="code" href="../../d6/d8/struct__CONFIGURATION__INFORMATION.html">PCONFIGURATION_INFORMATION</a> configurationInformation;
01312     ULONG diskCount;
01313     ULONG floppyCount;
01314     HANDLE deviceHandle;
01315     IO_STATUS_BLOCK ioStatusBlock;
01316     ULONG diskNumber;
01317     ULONG i, j;
01318     UCHAR driveLetter;
01319     WCHAR deviceNameBuffer[50];
01320     UNICODE_STRING deviceName, floppyPrefix, cdromPrefix;
01321     PDRIVE_LAYOUT_INFORMATION layout;
01322     BOOLEAN bootable;
01323     ULONG partitionType;
01324     ULONG skip;
01325     ULONG diskCountIncrement;
01326     ULONG actualDiskCount = 0;
01327 
01328     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01329 
01330     <span class="comment">//</span>
01331     <span class="comment">// Get the count of devices from the registry.</span>
01332     <span class="comment">//</span>
01333 
01334     configurationInformation = <a class="code" href="../../d4/d6/iosubs_8c.html#a69">IoGetConfigurationInformation</a>();
01335 
01336     diskCount = configurationInformation-&gt;<a class="code" href="../../d6/d8/struct__CONFIGURATION__INFORMATION.html#o0">DiskCount</a>;
01337     floppyCount = configurationInformation-&gt;<a class="code" href="../../d6/d8/struct__CONFIGURATION__INFORMATION.html#o1">FloppyCount</a>;
01338 
01339     <span class="comment">//</span>
01340     <span class="comment">// Allocate general NT name buffer.</span>
01341     <span class="comment">//</span>
01342 
01343     ntName = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( NonPagedPool, 128, 'btsF');
01344 
01345     ntPhysicalName = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( NonPagedPool, 64, 'btsF');
01346 
01347     <span class="keywordflow">if</span> (ntName == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> || ntPhysicalName == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01348 
01349         <a class="code" href="../../d9/d1/bugcheck_8c.html#a13">KeBugCheck</a>( ASSIGN_DRIVE_LETTERS_FAILED );
01350 
01351     }
01352 
01353     <span class="comment">//</span>
01354     <span class="comment">// If we're doing a remote boot, set NtSystemPath appropriately.</span>
01355     <span class="comment">//</span>
01356 
01357     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d5/io_8h.html#a399">IoRemoteBootClient</a>) {
01358 
01359         PUCHAR p;
01360         PUCHAR q;
01361 
01362         <span class="comment">//</span>
01363         <span class="comment">// If this is a remote boot setup boot, NtBootPathName is of the</span>
01364         <span class="comment">// form &lt;server&gt;&lt;share&gt;\setup&lt;install-directory&gt;&lt;platform&gt;.</span>
01365         <span class="comment">// We want the root of the X: drive to be the root of the install</span>
01366         <span class="comment">// directory.</span>
01367         <span class="comment">//</span>
01368         <span class="comment">// If this is a normal remote boot, NtBootPathName is of the form</span>
01369         <span class="comment">// &lt;server&gt;&lt;share&gt;\images&lt;machine&gt;\winnt. We want the root of</span>
01370         <span class="comment">// the X: drive to be the root of the machine directory.</span>
01371         <span class="comment">//</span>
01372         <span class="comment">// Thus in either case, we need to remove all but the last element</span>
01373         <span class="comment">// of the path.</span>
01374         <span class="comment">//</span>
01375         <span class="comment">// Find the beginning of the last element of the path (including</span>
01376         <span class="comment">// the leading backslash).</span>
01377         <span class="comment">//</span>
01378 
01379         p = strrchr( LoaderBlock-&gt;NtBootPathName, <span class="charliteral">'\\'</span> );   <span class="comment">// find last separator</span>
01380         q = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01381         <span class="keywordflow">if</span> ( (p != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp; (*(p+1) == 0) ) {
01382 
01383             <span class="comment">//</span>
01384             <span class="comment">// NtBootPathName ends with a backslash, so we need to back up</span>
01385             <span class="comment">// to the previous backslash.</span>
01386             <span class="comment">//</span>
01387 
01388             q = p;
01389             *q = 0;
01390             p = strrchr( LoaderBlock-&gt;NtBootPathName, <span class="charliteral">'\\'</span> );   <span class="comment">// find last separator</span>
01391             *q = <span class="charliteral">'\\'</span>;
01392         }
01393         <span class="keywordflow">if</span> ( p == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
01394             <a class="code" href="../../d9/d1/bugcheck_8c.html#a13">KeBugCheck</a>( ASSIGN_DRIVE_LETTERS_FAILED );
01395         }
01396 
01397         <span class="comment">//</span>
01398         <span class="comment">// Set NtSystemPath to X:&lt;last element of path&gt;. Note that the symbolic</span>
01399         <span class="comment">// link for X: is created in io\ioinit.c\IopInitializeBootDrivers.</span>
01400         <span class="comment">//</span>
01401         <span class="comment">// Note that we use X: for the textmode setup phase of a remote</span>
01402         <span class="comment">// installation. But for a true remote boot, we use C:.</span>
01403         <span class="comment">//</span>
01404 
01405 <span class="preprocessor">#if defined(REMOTE_BOOT)</span>
01406 <span class="preprocessor"></span>        <span class="keywordflow">if</span> ((LoaderBlock-&gt;SetupLoaderBlock-&gt;Flags &amp; (<a class="code" href="../../d3/d8/setupblk_8h.html#a28">SETUPBLK_FLAGS_REMOTE_INSTALL</a> |
01407                                                      <a class="code" href="../../d3/d8/setupblk_8h.html#a29">SETUPBLK_FLAGS_SYSPREP_INSTALL</a>)) == 0) {
01408             NtSystemPath[0] = <span class="charliteral">'C'</span>;
01409         } <span class="keywordflow">else</span>
01410 <span class="preprocessor">#endif</span>
01411 <span class="preprocessor"></span>        {
01412             NtSystemPath[0] = <span class="charliteral">'X'</span>;
01413         }
01414         NtSystemPath[1] = <span class="charliteral">':'</span>;
01415         strcpy(&amp;NtSystemPath[2], p );
01416         <span class="keywordflow">if</span> ( q != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
01417             NtSystemPath[<a class="code" href="../../d2/d7/regtest_8c.html#a2">strlen</a>(NtSystemPath)-1] = <span class="charliteral">'\0'</span>; <span class="comment">// remove trailing backslash</span>
01418         }
01419         <a class="code" href="../../d2/d7/string_8c.html#a5">RtlInitString</a>(NtSystemPathString, NtSystemPath);
01420 
01421     }
01422 
01423     <span class="comment">//</span>
01424     <span class="comment">// For each disk ...</span>
01425     <span class="comment">//</span>
01426 
01427     diskCountIncrement = 0;
01428     <span class="keywordflow">for</span> (diskNumber = 0; diskNumber &lt; diskCount; diskNumber++) {
01429 
01430         <span class="comment">//</span>
01431         <span class="comment">// Create ANSI name string for physical disk.</span>
01432         <span class="comment">//</span>
01433 
01434         <a class="code" href="../../d6/d9/heappage_8c.html#a68">sprintf</a>( ntName, DiskPartitionName, diskNumber, 0 );
01435 
01436         <span class="comment">//</span>
01437         <span class="comment">// Convert to unicode string.</span>
01438         <span class="comment">//</span>
01439 
01440         <a class="code" href="../../d2/d7/string_8c.html#a6">RtlInitAnsiString</a>( &amp;ansiString, ntName );
01441 
01442         <a class="code" href="../../d6/d6/nls_8c.html#a21">RtlAnsiStringToUnicodeString</a>( &amp;unicodeString, &amp;ansiString, TRUE );
01443 
01444         InitializeObjectAttributes( &amp;objectAttributes,
01445                                     &amp;unicodeString,
01446                                     OBJ_CASE_INSENSITIVE,
01447                                     NULL,
01448                                     NULL );
01449 
01450         <span class="comment">//</span>
01451         <span class="comment">// Open device by name.</span>
01452         <span class="comment">//</span>
01453 
01454         status = <a class="code" href="../../d6/d9/restrfil_8c.html#a33">ZwOpenFile</a>( &amp;deviceHandle,
01455                              FILE_READ_DATA | SYNCHRONIZE,
01456                              &amp;objectAttributes,
01457                              &amp;ioStatusBlock,
01458                              FILE_SHARE_READ,
01459                              FILE_SYNCHRONOUS_IO_NONALERT );
01460 
01461         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
01462 
01463             <span class="comment">//</span>
01464             <span class="comment">// The device was successfully opened.  Generate a DOS device name</span>
01465             <span class="comment">// for the drive itself.</span>
01466             <span class="comment">//</span>
01467 
01468             <a class="code" href="../../d6/d9/heappage_8c.html#a68">sprintf</a>( ntPhysicalName, <span class="stringliteral">"\\DosDevices\\PhysicalDrive%d"</span>, diskNumber );
01469 
01470             <a class="code" href="../../d2/d7/string_8c.html#a6">RtlInitAnsiString</a>( &amp;ansiPhysicalString, ntPhysicalName );
01471 
01472             <a class="code" href="../../d6/d6/nls_8c.html#a21">RtlAnsiStringToUnicodeString</a>( &amp;unicodePhysicalString, &amp;ansiPhysicalString, TRUE );
01473 
01474             <a class="code" href="../../d4/d6/iosubs_8c.html#a50">IoCreateSymbolicLink</a>( &amp;unicodePhysicalString, &amp;unicodeString );
01475 
01476             <a class="code" href="../../d6/d6/nls_8c.html#a34">RtlFreeUnicodeString</a>( &amp;unicodePhysicalString );
01477 
01478             ZwClose(deviceHandle);
01479 
01480             actualDiskCount = diskNumber + 1;
01481         }
01482 
01483         <a class="code" href="../../d6/d6/nls_8c.html#a34">RtlFreeUnicodeString</a>( &amp;unicodeString );
01484 
01485         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
01486 
01487 <span class="preprocessor">#if DBG</span>
01488 <span class="preprocessor"></span>            <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>( <span class="stringliteral">"IoAssignDriveLetters: Failed to open %s\n"</span>, ntName );
01489 <span class="preprocessor">#endif // DBG</span>
01490 <span class="preprocessor"></span>
01491             <span class="comment">//</span>
01492             <span class="comment">// This may be a sparse name space.  Try going farther but</span>
01493             <span class="comment">// not forever.</span>
01494             <span class="comment">//</span>
01495 
01496             <span class="keywordflow">if</span> (diskCountIncrement &lt; 50) {
01497                 diskCountIncrement++;
01498                 diskCount++;
01499             }
01500         }
01501 
01502     } <span class="comment">// end for diskNumber ...</span>
01503 
01504     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( ntName );
01505     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( ntPhysicalName );
01506 
01507     diskCount -= diskCountIncrement;
01508     <span class="keywordflow">if</span> (actualDiskCount &gt; diskCount) {
01509         diskCount = actualDiskCount;
01510     }
01511 
01512     <span class="keywordflow">for</span> (i = 0; i &lt; diskCount; i++) {
01513 
01514         swprintf(deviceNameBuffer, L<span class="stringliteral">"\\Device\\Harddisk%d\\Partition0"</span>, i);
01515         <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;deviceName, deviceNameBuffer);
01516 
01517         status = <a class="code" href="../../d7/d2/drivesup_8c.html#a20">HalpQueryDriveLayout</a>(&amp;deviceName, &amp;layout);
01518         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status)) {
01519             layout = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01520         }
01521 
01522         bootable = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01523         <span class="keywordflow">for</span> (j = 1; ; j++) {
01524 
01525             swprintf(deviceNameBuffer, L<span class="stringliteral">"\\Device\\Harddisk%d\\Partition%d"</span>,
01526                      i, j);
01527             <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;deviceName, deviceNameBuffer);
01528 
01529             status = <a class="code" href="../../d7/d2/drivesup_8c.html#a19">HalpQueryPartitionType</a>(&amp;deviceName, layout,
01530                                             &amp;partitionType);
01531             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status)) {
01532                 <span class="keywordflow">break</span>;
01533             }
01534 
01535             <span class="keywordflow">if</span> (partitionType != <a class="code" href="../../d7/d2/drivesup_8c.html#a3">BOOTABLE_PARTITION</a>) {
01536                 <span class="keywordflow">continue</span>;
01537             }
01538 
01539             bootable = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01540 
01541             <a class="code" href="../../d7/d2/drivesup_8c.html#a25">HalpNextDriveLetter</a>(&amp;deviceName, NtDeviceName, NtSystemPath, FALSE);
01542             <span class="keywordflow">break</span>;
01543         }
01544 
01545         <span class="keywordflow">if</span> (bootable) {
01546             <span class="keywordflow">if</span> (layout) {
01547                 <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(layout);
01548             }
01549             <span class="keywordflow">continue</span>;
01550         }
01551 
01552         <span class="keywordflow">for</span> (j = 1; ; j++) {
01553 
01554             swprintf(deviceNameBuffer, L<span class="stringliteral">"\\Device\\Harddisk%d\\Partition%d"</span>,
01555                      i, j);
01556             <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;deviceName, deviceNameBuffer);
01557 
01558             status = <a class="code" href="../../d7/d2/drivesup_8c.html#a19">HalpQueryPartitionType</a>(&amp;deviceName, layout,
01559                                             &amp;partitionType);
01560             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status)) {
01561                 <span class="keywordflow">break</span>;
01562             }
01563 
01564             <span class="keywordflow">if</span> (partitionType != <a class="code" href="../../d7/d2/drivesup_8c.html#a4">PRIMARY_PARTITION</a>) {
01565                 <span class="keywordflow">continue</span>;
01566             }
01567 
01568             <a class="code" href="../../d7/d2/drivesup_8c.html#a25">HalpNextDriveLetter</a>(&amp;deviceName, NtDeviceName, NtSystemPath, FALSE);
01569             <span class="keywordflow">break</span>;
01570         }
01571 
01572         <span class="keywordflow">if</span> (layout) {
01573             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(layout);
01574         }
01575     }
01576 
01577     <span class="keywordflow">for</span> (i = 0; i &lt; diskCount; i++) {
01578 
01579         swprintf(deviceNameBuffer, L<span class="stringliteral">"\\Device\\Harddisk%d\\Partition0"</span>, i);
01580         <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;deviceName, deviceNameBuffer);
01581 
01582         status = <a class="code" href="../../d7/d2/drivesup_8c.html#a20">HalpQueryDriveLayout</a>(&amp;deviceName, &amp;layout);
01583         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status)) {
01584             layout = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01585         }
01586 
01587         <span class="keywordflow">for</span> (j = 1; ; j++) {
01588 
01589             swprintf(deviceNameBuffer, L<span class="stringliteral">"\\Device\\Harddisk%d\\Partition%d"</span>,
01590                      i, j);
01591             <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;deviceName, deviceNameBuffer);
01592 
01593             status = <a class="code" href="../../d7/d2/drivesup_8c.html#a19">HalpQueryPartitionType</a>(&amp;deviceName, layout,
01594                                             &amp;partitionType);
01595             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status)) {
01596                 <span class="keywordflow">break</span>;
01597             }
01598 
01599             <span class="keywordflow">if</span> (partitionType != <a class="code" href="../../d7/d2/drivesup_8c.html#a5">LOGICAL_PARTITION</a>) {
01600                 <span class="keywordflow">continue</span>;
01601             }
01602 
01603             <a class="code" href="../../d7/d2/drivesup_8c.html#a25">HalpNextDriveLetter</a>(&amp;deviceName, NtDeviceName, NtSystemPath, FALSE);
01604         }
01605 
01606         <span class="keywordflow">if</span> (layout) {
01607             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(layout);
01608         }
01609     }
01610 
01611     <span class="keywordflow">for</span> (i = 0; i &lt; diskCount; i++) {
01612 
01613         swprintf(deviceNameBuffer, L<span class="stringliteral">"\\Device\\Harddisk%d\\Partition0"</span>, i);
01614         <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;deviceName, deviceNameBuffer);
01615 
01616         status = <a class="code" href="../../d7/d2/drivesup_8c.html#a20">HalpQueryDriveLayout</a>(&amp;deviceName, &amp;layout);
01617         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status)) {
01618             layout = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01619         }
01620 
01621         skip = 0;
01622         <span class="keywordflow">for</span> (j = 1; ; j++) {
01623 
01624             swprintf(deviceNameBuffer, L<span class="stringliteral">"\\Device\\Harddisk%d\\Partition%d"</span>,
01625                      i, j);
01626             <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;deviceName, deviceNameBuffer);
01627 
01628             status = <a class="code" href="../../d7/d2/drivesup_8c.html#a19">HalpQueryPartitionType</a>(&amp;deviceName, layout,
01629                                             &amp;partitionType);
01630             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status)) {
01631                 <span class="keywordflow">break</span>;
01632             }
01633 
01634             <span class="keywordflow">if</span> (partitionType == <a class="code" href="../../d7/d2/drivesup_8c.html#a3">BOOTABLE_PARTITION</a>) {
01635                 skip = j;
01636             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (partitionType == <a class="code" href="../../d7/d2/drivesup_8c.html#a4">PRIMARY_PARTITION</a>) {
01637                 <span class="keywordflow">if</span> (!skip) {
01638                     skip = j;
01639                 }
01640             }
01641         }
01642 
01643         <span class="keywordflow">for</span> (j = 1; ; j++) {
01644 
01645             <span class="keywordflow">if</span> (j == skip) {
01646                 <span class="keywordflow">continue</span>;
01647             }
01648 
01649             swprintf(deviceNameBuffer, L<span class="stringliteral">"\\Device\\Harddisk%d\\Partition%d"</span>,
01650                      i, j);
01651             <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;deviceName, deviceNameBuffer);
01652 
01653             status = <a class="code" href="../../d7/d2/drivesup_8c.html#a19">HalpQueryPartitionType</a>(&amp;deviceName, layout,
01654                                             &amp;partitionType);
01655             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status)) {
01656                 <span class="keywordflow">break</span>;
01657             }
01658 
01659             <span class="keywordflow">if</span> (partitionType != <a class="code" href="../../d7/d2/drivesup_8c.html#a4">PRIMARY_PARTITION</a> &amp;&amp;
01660                 partitionType != <a class="code" href="../../d7/d2/drivesup_8c.html#a6">FT_PARTITION</a>) {
01661 
01662                 <span class="keywordflow">continue</span>;
01663             }
01664 
01665             <a class="code" href="../../d7/d2/drivesup_8c.html#a25">HalpNextDriveLetter</a>(&amp;deviceName, NtDeviceName, NtSystemPath, FALSE);
01666         }
01667 
01668         <span class="keywordflow">if</span> (layout) {
01669             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(layout);
01670         }
01671     }
01672 
01673     <span class="keywordflow">for</span> (i = 0; i &lt; floppyCount; i++) {
01674 
01675         swprintf(deviceNameBuffer, L<span class="stringliteral">"\\Device\\Floppy%d"</span>, i);
01676         <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;deviceName, deviceNameBuffer);
01677 
01678         <span class="keywordflow">if</span> (!<a class="code" href="../../d7/d2/drivesup_8c.html#a28">HalpIsOldStyleFloppy</a>(&amp;deviceName)) {
01679             <span class="keywordflow">continue</span>;
01680         }
01681 
01682         <a class="code" href="../../d7/d2/drivesup_8c.html#a25">HalpNextDriveLetter</a>(&amp;deviceName, NtDeviceName, NtSystemPath, TRUE);
01683     }
01684 
01685     <span class="keywordflow">for</span> (i = 0; i &lt; floppyCount; i++) {
01686 
01687         swprintf(deviceNameBuffer, L<span class="stringliteral">"\\Device\\Floppy%d"</span>, i);
01688         <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;deviceName, deviceNameBuffer);
01689 
01690         <span class="keywordflow">if</span> (<a class="code" href="../../d7/d2/drivesup_8c.html#a28">HalpIsOldStyleFloppy</a>(&amp;deviceName)) {
01691             <span class="keywordflow">continue</span>;
01692         }
01693 
01694         <a class="code" href="../../d7/d2/drivesup_8c.html#a25">HalpNextDriveLetter</a>(&amp;deviceName, NtDeviceName, NtSystemPath, TRUE);
01695     }
01696 
01697     <span class="keywordflow">for</span> (i = 0; i &lt; configurationInformation-&gt;<a class="code" href="../../d6/d8/struct__CONFIGURATION__INFORMATION.html#o2">CdRomCount</a>; i++) {
01698 
01699         swprintf(deviceNameBuffer, L<span class="stringliteral">"\\Device\\CdRom%d"</span>, i);
01700         <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;deviceName, deviceNameBuffer);
01701 
01702         <a class="code" href="../../d7/d2/drivesup_8c.html#a25">HalpNextDriveLetter</a>(&amp;deviceName, NtDeviceName, NtSystemPath, TRUE);
01703     }
01704 
01705     <span class="keywordflow">if</span> (!<a class="code" href="../../d0/d5/io_8h.html#a399">IoRemoteBootClient</a>) {
01706         <a class="code" href="../../d6/d6/nls_8c.html#a21">RtlAnsiStringToUnicodeString</a>(&amp;unicodeString, NtDeviceName, TRUE);
01707         driveLetter = <a class="code" href="../../d7/d2/drivesup_8c.html#a25">HalpNextDriveLetter</a>(&amp;unicodeString, NULL, NULL, TRUE);
01708         <span class="keywordflow">if</span> (driveLetter) {
01709             <span class="keywordflow">if</span> (driveLetter != 0xFF) {
01710                 NtSystemPath[0] = driveLetter;
01711             }
01712         } <span class="keywordflow">else</span> {
01713             <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;floppyPrefix, L<span class="stringliteral">"\\Device\\Floppy"</span>);
01714             <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;cdromPrefix, L<span class="stringliteral">"\\Device\\CdRom"</span>);
01715             <span class="keywordflow">if</span> (<a class="code" href="../../d6/d6/nls_8c.html#a43">RtlPrefixUnicodeString</a>(&amp;floppyPrefix, &amp;unicodeString, TRUE)) {
01716                 driveLetter = <span class="charliteral">'A'</span>;
01717             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="../../d6/d6/nls_8c.html#a43">RtlPrefixUnicodeString</a>(&amp;cdromPrefix, &amp;unicodeString, TRUE)) {
01718                 driveLetter = <span class="charliteral">'D'</span>;
01719             } <span class="keywordflow">else</span> {
01720                 driveLetter = <span class="charliteral">'C'</span>;
01721             }
01722             <span class="keywordflow">for</span> (; driveLetter &lt;= <span class="charliteral">'Z'</span>; driveLetter++) {
01723                 status = <a class="code" href="../../d7/d2/drivesup_8c.html#a27">HalpSetMountLetter</a>(&amp;unicodeString, driveLetter);
01724                 <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status)) {
01725                     NtSystemPath[0] = driveLetter;
01726                 }
01727             }
01728         }
01729         <a class="code" href="../../d6/d6/nls_8c.html#a34">RtlFreeUnicodeString</a>(&amp;unicodeString);
01730     }
01731 
01732     <a class="code" href="../../d7/d2/drivesup_8c.html#a26">HalpEnableAutomaticDriveLetterAssignment</a>();
01733 
01734 } <span class="comment">// end IoAssignDriveLetters()</span>

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a13" doxytag="haldisp.h::xHalIoReadPartitionTable" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS FASTCALL xHalIoReadPartitionTable           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>DeviceObject</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>SectorSize</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN BOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>ReturnRecognizedPartitions</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT struct _DRIVE_LAYOUT_INFORMATION **&nbsp;</td>
          <td class="mdname" nowrap> <em>PartitionBuffer</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d8/d1/drivesup_8c-source.html#l01739">1739</a> of file <a class="el" href="../../d8/d1/drivesup_8c-source.html">drivesup.c</a>.
<p>
<pre class="fragment"><div>01748                    :
01749 
01750     This routine walks <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> disk reading <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> partition tables and creates
01751     an entry in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> partition list buffer <span class="keywordflow">for</span> each partition.
01752 
01753     The algorithm used by <span class="keyword">this</span> routine <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> two-fold:
01754 
01755         1)  Read each partition table and <span class="keywordflow">for</span> each valid, recognized
01756             partition found, to build a descriptor in a partition list.
01757             Extended partitions are located in order to find other
01758             partition tables, but no descriptors are built <span class="keywordflow">for</span> these.
01759             The partition list <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> built in nonpaged <a class="code" href="../../d4/d6/regext_8c.html#a17">pool</a> that <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> allocated
01760             by <span class="keyword">this</span> routine.  It <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller's responsibility to free
01761             <span class="keyword">this</span> <a class="code" href="../../d4/d6/regext_8c.html#a17">pool</a> after <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> has gathered <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> appropriate information
01762             from <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> list.
01763 
01764         2)  Read each partition table and <span class="keywordflow">for</span> each and every entry, build
01765             a descriptor in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> partition list.  Extended partitions are
01766             located to find each partition table on <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> disk, and entries
01767             are built <span class="keywordflow">for</span> these as well.  The partition list <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> build in
01768             nonpaged <a class="code" href="../../d4/d6/regext_8c.html#a17">pool</a> that <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> allocated by <span class="keyword">this</span> routine.  It <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
01769             caller's responsibility to free <span class="keyword">this</span> <a class="code" href="../../d4/d6/regext_8c.html#a17">pool</a> after <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> has copied
01770             <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> information back to its caller.
01771 
01772     The first algorithm <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> used when <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> ReturnRecognizedPartitions flag
01773     <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> set.  This <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> used to determine how many partition device objects
01774     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> device driver <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> to create, and where each lives on <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> drive.
01775 
01776     The second algorithm <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> used when <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> ReturnRecognizedPartitions flag
01777     <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> clear.  This <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> used to find all of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> partition tables and their
01778     entries <span class="keywordflow">for</span> a utility such as fdisk, that would like to revamp where
01779     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> partitions live.
01780 
01781 Arguments:
01782 
01783     DeviceObject - Pointer to device object <span class="keywordflow">for</span> <span class="keyword">this</span> disk.
01784 
01785     <a class="code" href="../../d3/d8/udfprocs_8h.html#a42">SectorSize</a> - Sector size on <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> device.
01786 
01787     ReturnRecognizedPartitions - <a class="code" href="../../d2/d1/bench_8h.html#a5">A</a> flag indicated whether <a class="code" href="../../d3/d0/imm32_8def.html#a1">only</a> recognized
01788         partition descriptors are to be returned, or whether all partition
01789         entries are to be returned.
01790 
01791     PartitionBuffer - Pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> pointer of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> buffer in which <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> list
01792         of partition will be stored.
01793 
01794 Return Value:
01795 
01796     The functional value <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> STATUS_SUCCESS <span class="keywordflow">if</span> at least one sector table was
01797     read.
01798 
01799 Notes:
01800 
01801     It <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> responsibility of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller to deallocate <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> partition list
01802     buffer allocated by <span class="keyword">this</span> routine.
01803 
01804 --*/
01805 
01806 {
01807     ULONG partitionBufferSize = <a class="code" href="../../d2/d7/hal_8h.html#a13">PARTITION_BUFFER_SIZE</a>;
01808     PDRIVE_LAYOUT_INFORMATION newPartitionBuffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01809 
01810     LONG partitionTableCounter = -1;
01811 
01812     DISK_GEOMETRY diskGeometry;
01813     ULONGLONG endSector;
01814     ULONGLONG maxSector;
01815     ULONGLONG maxOffset;
01816 
01817     LARGE_INTEGER partitionTableOffset;
01818     LARGE_INTEGER volumeStartOffset;
01819     LARGE_INTEGER tempInt;
01820     BOOLEAN primaryPartitionTable;
01821     LONG partitionNumber;
01822     PUCHAR readBuffer = (PUCHAR) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01823     <a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a> event;
01824 
01825     IO_STATUS_BLOCK ioStatus;
01826     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
01827     <a class="code" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html">PPARTITION_DESCRIPTOR</a> partitionTableEntry;
01828     CCHAR partitionEntry;
01829     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status = STATUS_SUCCESS;
01830     ULONG readSize;
01831     PPARTITION_INFORMATION partitionInfo;
01832     BOOLEAN foundEZHooker = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01833 
01834     BOOLEAN mbrSignatureFound = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01835     BOOLEAN emptyPartitionTable = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01836 
01837     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01838 
01839     <span class="comment">//</span>
01840     <span class="comment">// Create the buffer that will be passed back to the driver containing</span>
01841     <span class="comment">// the list of partitions on the disk.</span>
01842     <span class="comment">//</span>
01843 
01844     *PartitionBuffer = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( NonPagedPool,
01845                                               partitionBufferSize,
01846                                               'btsF' );
01847 
01848     <span class="keywordflow">if</span> (*PartitionBuffer == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01849         <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
01850     }
01851 
01852     <span class="comment">//</span>
01853     <span class="comment">// Determine the size of a read operation to ensure that at least 512</span>
01854     <span class="comment">// bytes are read.  This will guarantee that enough data is read to</span>
01855     <span class="comment">// include an entire partition table.  Note that this code assumes that</span>
01856     <span class="comment">// the actual sector size of the disk (if less than 512 bytes) is a</span>
01857     <span class="comment">// multiple of 2, a fairly reasonable assumption.</span>
01858     <span class="comment">//</span>
01859 
01860     <span class="keywordflow">if</span> (<a class="code" href="../../d3/d8/udfprocs_8h.html#a42">SectorSize</a> &gt;= 512) {
01861         readSize = <a class="code" href="../../d3/d8/udfprocs_8h.html#a42">SectorSize</a>;
01862     } <span class="keywordflow">else</span> {
01863         readSize = 512;
01864     }
01865 
01866     <span class="comment">//</span>
01867     <span class="comment">// Look to see if this is an EZDrive Disk.  If it is then get the</span>
01868     <span class="comment">// real parititon table at 1.</span>
01869     <span class="comment">//</span>
01870 
01871     {
01872 
01873         PVOID buff;
01874 
01875         <a class="code" href="../../d2/d7/hal_8h.html#a23">HalExamineMBR</a>(
01876             DeviceObject,
01877             readSize,
01878             (ULONG)0x55,
01879             &amp;buff
01880             );
01881 
01882         <span class="keywordflow">if</span> (buff) {
01883 
01884             foundEZHooker = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01885             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(buff);
01886             partitionTableOffset.QuadPart = 512;
01887 
01888         } <span class="keywordflow">else</span> {
01889 
01890             partitionTableOffset.QuadPart = 0;
01891 
01892         }
01893 
01894     }
01895 
01896     <span class="comment">//</span>
01897     <span class="comment">// Get the drive size so we can verify that the partition table is </span>
01898     <span class="comment">// correct.</span>
01899     <span class="comment">//</span>
01900 
01901     status = <a class="code" href="../../d7/d2/drivesup_8c.html#a22">HalpGetFullGeometry</a>(DeviceObject, 
01902                                  &amp;diskGeometry, 
01903                                  &amp;maxOffset);
01904 
01905     <span class="keywordflow">if</span>(!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status)) {
01906         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(*PartitionBuffer);
01907         *PartitionBuffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01908         <span class="keywordflow">return</span> status;
01909     }
01910 
01911     <span class="comment">//</span>
01912     <span class="comment">// Partition offsets need to fit on the disk or we're not going to </span>
01913     <span class="comment">// expose them.  Partition ends are generally very very sloppy so we </span>
01914     <span class="comment">// need to allow some slop.  Adding in a cylinders worth isn't enough </span>
01915     <span class="comment">// so now we'll assume that all partitions end within 2x of the real end</span>
01916     <span class="comment">// of the disk.</span>
01917     <span class="comment">//</span>
01918 
01919     endSector = maxOffset;
01920 
01921     maxSector = maxOffset * 2;
01922 
01923     <a class="code" href="../../d7/d2/drivesup_8c.html#a0">DebugPrint</a>((2, <span class="stringliteral">"MaxOffset = %#I64x, maxSector = %#I64x\n"</span>, 
01924                 maxOffset, maxSector));
01925 
01926     <span class="comment">//</span>
01927     <span class="comment">// Indicate that the primary partition table is being read and</span>
01928     <span class="comment">// processed.</span>
01929     <span class="comment">//</span>
01930 
01931     primaryPartitionTable = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01932 
01933     <span class="comment">//</span>
01934     <span class="comment">// The partitions in this volume have their start sector as 0.</span>
01935     <span class="comment">//</span>
01936 
01937     volumeStartOffset.QuadPart = 0;
01938 
01939     <span class="comment">//</span>
01940     <span class="comment">// Initialize the number of partitions in the list.</span>
01941     <span class="comment">//</span>
01942 
01943     partitionNumber = -1;
01944 
01945     <span class="comment">//</span>
01946     <span class="comment">// Allocate a buffer that will hold the reads.</span>
01947     <span class="comment">//</span>
01948 
01949     readBuffer = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( NonPagedPoolCacheAligned,
01950                                         PAGE_SIZE,
01951                                         'btsF' );
01952 
01953     <span class="keywordflow">if</span> (readBuffer == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01954         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( *PartitionBuffer );
01955         <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
01956     }
01957 
01958     <span class="comment">//</span>
01959     <span class="comment">// Read each partition table, create an object for the partition(s)</span>
01960     <span class="comment">// it represents, and then if there is a link entry to another</span>
01961     <span class="comment">// partition table, repeat.</span>
01962     <span class="comment">//</span>
01963 
01964     <span class="keywordflow">do</span> {
01965 
01966         BOOLEAN tableIsValid;
01967         ULONG containerPartitionCount;
01968 
01969         tableIsValid = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01970 
01971         <span class="comment">//</span>
01972         <span class="comment">// Read record containing partition table.</span>
01973         <span class="comment">//</span>
01974         <span class="comment">// Create a notification event object to be used while waiting for</span>
01975         <span class="comment">// the read request to complete.</span>
01976         <span class="comment">//</span>
01977 
01978         <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( &amp;event, NotificationEvent, FALSE );
01979 
01980         <span class="comment">//</span>
01981         <span class="comment">// Zero out the buffer we're reading into.  In case we get back </span>
01982         <span class="comment">// STATUS_NO_DATA_DETECTED we'll be prepared.</span>
01983         <span class="comment">//</span>
01984 
01985         RtlZeroMemory(readBuffer, readSize);
01986 
01987         irp = <a class="code" href="../../d4/d6/iosubs_8c.html#a27">IoBuildSynchronousFsdRequest</a>( IRP_MJ_READ,
01988                                             DeviceObject,
01989                                             readBuffer,
01990                                             readSize,
01991                                             &amp;partitionTableOffset,
01992                                             &amp;event,
01993                                             &amp;ioStatus );
01994 
01995         <span class="keywordflow">if</span> (!irp) {
01996             status = STATUS_INSUFFICIENT_RESOURCES;
01997             <span class="keywordflow">break</span>;
01998         } <span class="keywordflow">else</span> {
01999             <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpStack;
02000             irpStack = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>(irp);
02001             irpStack-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o2">Flags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a203">SL_OVERRIDE_VERIFY_VOLUME</a>;
02002         }
02003 
02004         status = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>( DeviceObject, irp );
02005 
02006         <span class="keywordflow">if</span> (status == STATUS_PENDING) {
02007             (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;event,
02008                                           Executive,
02009                                           KernelMode,
02010                                           FALSE,
02011                                           (PLARGE_INTEGER) NULL);
02012             status = ioStatus.Status;
02013         }
02014 
02015         <span class="comment">//</span>
02016         <span class="comment">// Special case - if we got a blank-check reading the sector then </span>
02017         <span class="comment">// pretend it was just successful so we can deal with superfloppies</span>
02018         <span class="comment">// where noone bothered to write anything to the non-filesystem sectors</span>
02019         <span class="comment">//</span>
02020 
02021         <span class="keywordflow">if</span>(status == STATUS_NO_DATA_DETECTED) {
02022             status = STATUS_SUCCESS;
02023         }
02024 
02025         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
02026             <span class="keywordflow">break</span>;
02027         }
02028 
02029         <span class="comment">//</span>
02030         <span class="comment">// If EZDrive is hooking the MBR then we found the first partition table</span>
02031         <span class="comment">// in sector 1 rather than 0.  However that partition table is relative</span>
02032         <span class="comment">// to sector zero.  So, Even though we got it from one, reset the partition</span>
02033         <span class="comment">// offset to 0.</span>
02034         <span class="comment">//</span>
02035 
02036         <span class="keywordflow">if</span> (foundEZHooker &amp;&amp; (partitionTableOffset.QuadPart == 512)) {
02037 
02038             partitionTableOffset.QuadPart = 0;
02039 
02040         }
02041 
02042         <span class="comment">//</span>
02043         <span class="comment">// Check for Boot Record signature.</span>
02044         <span class="comment">//</span>
02045 
02046         <span class="keywordflow">if</span> (((<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>) readBuffer)[<a class="code" href="../../d2/d7/hal_8h.html#a11">BOOT_SIGNATURE_OFFSET</a>] != <a class="code" href="../../d2/d7/hal_8h.html#a12">BOOT_RECORD_SIGNATURE</a>) {
02047 
02048             <a class="code" href="../../d7/d2/drivesup_8c.html#a0">DebugPrint</a>((1, <span class="stringliteral">"xHalIoReadPT: No 0xaa55 found in partition table %d\n"</span>,
02049                         partitionTableCounter + 1));
02050 
02051             <span class="keywordflow">break</span>;
02052 
02053         } <span class="keywordflow">else</span> {
02054             mbrSignatureFound = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02055         }
02056 
02057         <span class="comment">//</span>
02058         <span class="comment">// Copy NTFT disk signature to buffer</span>
02059         <span class="comment">//</span>
02060 
02061         <span class="keywordflow">if</span> (partitionTableOffset.QuadPart == 0) {
02062             (*PartitionBuffer)-&gt;Signature =  ((PULONG) readBuffer)[<a class="code" href="../../d2/d7/hal_8h.html#a10">PARTITION_TABLE_OFFSET</a>/2-1];
02063         }
02064 
02065         partitionTableEntry = (<a class="code" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html">PPARTITION_DESCRIPTOR</a>) &amp;(((<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>) readBuffer)[<a class="code" href="../../d2/d7/hal_8h.html#a10">PARTITION_TABLE_OFFSET</a>]);
02066 
02067         <span class="comment">//</span>
02068         <span class="comment">// Keep count of partition tables in case we have an extended partition;</span>
02069         <span class="comment">//</span>
02070 
02071         partitionTableCounter++;
02072 
02073         <span class="comment">//</span>
02074         <span class="comment">// First create the objects corresponding to the entries in this</span>
02075         <span class="comment">// table that are not link entries or are unused.</span>
02076         <span class="comment">//</span>
02077 
02078         <a class="code" href="../../d7/d2/drivesup_8c.html#a0">DebugPrint</a>((2, <span class="stringliteral">"Partition Table %d:\n"</span>, partitionTableCounter));
02079 
02080         <span class="keywordflow">for</span> (partitionEntry = 1, containerPartitionCount = 0;
02081              partitionEntry &lt;= <a class="code" href="../../d2/d7/hal_8h.html#a9">NUM_PARTITION_TABLE_ENTRIES</a>;
02082              partitionEntry++, partitionTableEntry++) {
02083 
02084             <a class="code" href="../../d7/d2/drivesup_8c.html#a0">DebugPrint</a>((2, <span class="stringliteral">"Partition Entry %d,%d: type %#x %s\n"</span>, 
02085                         partitionTableCounter,
02086                         partitionEntry,
02087                         partitionTableEntry-&gt;<a class="code" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html#o4">PartitionType</a>,
02088                         (partitionTableEntry-&gt;<a class="code" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html#o0">ActiveFlag</a>) ? <span class="stringliteral">"Active"</span> : <span class="stringliteral">""</span>));
02089 
02090             <a class="code" href="../../d7/d2/drivesup_8c.html#a0">DebugPrint</a>((2, <span class="stringliteral">"\tOffset %#08lx for %#08lx Sectors\n"</span>, 
02091                         <a class="code" href="../../d7/d2/drivesup_8c.html#a1">GET_STARTING_SECTOR</a>(partitionTableEntry),
02092                         <a class="code" href="../../d7/d2/drivesup_8c.html#a2">GET_PARTITION_LENGTH</a>(partitionTableEntry)));
02093             <span class="comment">//</span>
02094             <span class="comment">// Do a quick pass over the entry to see if this table is valid.</span>
02095             <span class="comment">// It's only fatal if the master partition table is invalid.</span>
02096             <span class="comment">//</span>
02097 
02098             <span class="keywordflow">if</span>((<a class="code" href="../../d7/d2/drivesup_8c.html#a23">HalpIsValidPartitionEntry</a>(partitionTableEntry, 
02099                                           maxOffset,
02100                                           maxSector) == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp; 
02101                (partitionTableCounter == 0)) {
02102 
02103                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(DrivesupBreakIn == FALSE);
02104                 <a class="code" href="../../d7/d2/drivesup_8c.html#a12">DrivesupBreakIn</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02105                 tableIsValid = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02106                 <span class="keywordflow">break</span>;
02107 
02108             } 
02109             <span class="comment">//</span>
02110             <span class="comment">// Only one container partition is allowed per table - any more </span>
02111             <span class="comment">// and it's invalid.</span>
02112             <span class="comment">//</span>
02113 
02114             <span class="keywordflow">if</span>(IsContainerPartition(partitionTableEntry-&gt;<a class="code" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html#o4">PartitionType</a>)) {
02115 
02116                 containerPartitionCount++;
02117 
02118                 <span class="keywordflow">if</span>(containerPartitionCount != 1) {
02119 
02120                     <a class="code" href="../../d7/d2/drivesup_8c.html#a0">DebugPrint</a>((1, <span class="stringliteral">"Multiple container partitions found in "</span>
02121                                    <span class="stringliteral">"partition table %d\n - table is invalid\n"</span>,
02122                                 partitionTableCounter));
02123                     tableIsValid = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02124                     <span class="keywordflow">break</span>;
02125                 }
02126 
02127             }
02128 
02129             <span class="keywordflow">if</span>(emptyPartitionTable) {
02130 
02131                 <span class="keywordflow">if</span>((<a class="code" href="../../d7/d2/drivesup_8c.html#a1">GET_STARTING_SECTOR</a>(partitionTableEntry) != 0) ||
02132                    (<a class="code" href="../../d7/d2/drivesup_8c.html#a2">GET_PARTITION_LENGTH</a>(partitionTableEntry) != 0)) {
02133 
02134                     <span class="comment">//</span>
02135                     <span class="comment">// There's a valid, non-empty partition here. The table</span>
02136                     <span class="comment">// is not empty.</span>
02137                     <span class="comment">//</span>
02138 
02139                     emptyPartitionTable = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02140                 }
02141             }
02142 
02143             <span class="comment">//</span>
02144             <span class="comment">// If the partition entry is not used or not recognized, skip</span>
02145             <span class="comment">// it.  Note that this is only done if the caller wanted only</span>
02146             <span class="comment">// recognized partition descriptors returned.</span>
02147             <span class="comment">//</span>
02148 
02149             <span class="keywordflow">if</span> (ReturnRecognizedPartitions) {
02150 
02151                 <span class="comment">//</span>
02152                 <span class="comment">// Check if partition type is 0 (unused) or 5/f (extended).</span>
02153                 <span class="comment">// The definition of recognized partitions has broadened</span>
02154                 <span class="comment">// to include any partition type other than 0 or 5/f.</span>
02155                 <span class="comment">//</span>
02156 
02157                 <span class="keywordflow">if</span> ((partitionTableEntry-&gt;<a class="code" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html#o4">PartitionType</a> == PARTITION_ENTRY_UNUSED) ||
02158                     IsContainerPartition(partitionTableEntry-&gt;<a class="code" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html#o4">PartitionType</a>)) {
02159 
02160                     <span class="keywordflow">continue</span>;
02161                 }
02162             }
02163 
02164             <span class="comment">//</span>
02165             <span class="comment">// Bump up to the next partition entry.</span>
02166             <span class="comment">//</span>
02167 
02168             partitionNumber++;
02169 
02170             <span class="keywordflow">if</span> (((partitionNumber * <span class="keyword">sizeof</span>( PARTITION_INFORMATION )) + 
02171                  <span class="keyword">sizeof</span>( DRIVE_LAYOUT_INFORMATION )) &gt; 
02172                 (ULONG) partitionBufferSize) {
02173 
02174                 <span class="comment">//</span>
02175                 <span class="comment">// The partition list is too small to contain all of the</span>
02176                 <span class="comment">// entries, so create a buffer that is twice as large to</span>
02177                 <span class="comment">// store the partition list and copy the old buffer into</span>
02178                 <span class="comment">// the new one.</span>
02179                 <span class="comment">//</span>
02180 
02181                 newPartitionBuffer = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( NonPagedPool,
02182                                                             partitionBufferSize &lt;&lt; 1,
02183                                                             'btsF' );
02184 
02185                 <span class="keywordflow">if</span> (newPartitionBuffer == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02186                     --partitionNumber;
02187                     status = STATUS_INSUFFICIENT_RESOURCES;
02188                     <span class="keywordflow">break</span>;
02189                 }
02190 
02191                 RtlMoveMemory( newPartitionBuffer,
02192                                *PartitionBuffer,
02193                                partitionBufferSize );
02194 
02195                 <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( *PartitionBuffer );
02196 
02197                 <span class="comment">//</span>
02198                 <span class="comment">// Reassign the new buffer to the return parameter and</span>
02199                 <span class="comment">// reset the size of the buffer.</span>
02200                 <span class="comment">//</span>
02201 
02202                 *PartitionBuffer = newPartitionBuffer;
02203                 partitionBufferSize &lt;&lt;= 1;
02204             }
02205 
02206             <span class="comment">//</span>
02207             <span class="comment">// Describe this partition table entry in the partition list</span>
02208             <span class="comment">// entry being built for the driver.  This includes writing</span>
02209             <span class="comment">// the partition type, starting offset of the partition, and</span>
02210             <span class="comment">// the length of the partition.</span>
02211             <span class="comment">//</span>
02212 
02213             partitionInfo = &amp;(*PartitionBuffer)-&gt;PartitionEntry[partitionNumber];
02214 
02215             partitionInfo-&gt;PartitionType = partitionTableEntry-&gt;<a class="code" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html#o4">PartitionType</a>;
02216 
02217             partitionInfo-&gt;RewritePartition = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02218 
02219             <span class="keywordflow">if</span> (partitionTableEntry-&gt;<a class="code" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html#o4">PartitionType</a> != PARTITION_ENTRY_UNUSED) {
02220                 LONGLONG startOffset;
02221 
02222                 partitionInfo-&gt;BootIndicator =
02223                     partitionTableEntry-&gt;<a class="code" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html#o0">ActiveFlag</a> &amp; <a class="code" href="../../d2/d7/hal_8h.html#a14">PARTITION_ACTIVE_FLAG</a> ?
02224                         (BOOLEAN) <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> : (BOOLEAN) <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02225 
02226                 <span class="keywordflow">if</span> (IsContainerPartition(partitionTableEntry-&gt;<a class="code" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html#o4">PartitionType</a>)) {
02227                     partitionInfo-&gt;RecognizedPartition = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02228                     startOffset = volumeStartOffset.QuadPart;
02229                 } <span class="keywordflow">else</span> {
02230                     partitionInfo-&gt;RecognizedPartition = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02231                     startOffset = partitionTableOffset.QuadPart;
02232                 }
02233 
02234                 partitionInfo-&gt;StartingOffset.QuadPart = startOffset +
02235                     UInt32x32To64(<a class="code" href="../../d7/d2/drivesup_8c.html#a1">GET_STARTING_SECTOR</a>(partitionTableEntry),
02236                                   SectorSize);
02237                 tempInt.QuadPart = (partitionInfo-&gt;StartingOffset.QuadPart -
02238                                    startOffset) / <a class="code" href="../../d3/d8/udfprocs_8h.html#a42">SectorSize</a>;
02239                 partitionInfo-&gt;HiddenSectors = tempInt.LowPart;
02240 
02241                 partitionInfo-&gt;PartitionLength.QuadPart =
02242                     UInt32x32To64(<a class="code" href="../../d7/d2/drivesup_8c.html#a2">GET_PARTITION_LENGTH</a>(partitionTableEntry),
02243                                   SectorSize);
02244 
02245             } <span class="keywordflow">else</span> {
02246 
02247                 <span class="comment">//</span>
02248                 <span class="comment">// Partitions that are not used do not describe any part</span>
02249                 <span class="comment">// of the disk.  These types are recorded in the partition</span>
02250                 <span class="comment">// list buffer when the caller requested all of the entries</span>
02251                 <span class="comment">// be returned.  Simply zero out the remaining fields in</span>
02252                 <span class="comment">// the entry.</span>
02253                 <span class="comment">//</span>
02254 
02255                 partitionInfo-&gt;BootIndicator = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02256                 partitionInfo-&gt;RecognizedPartition = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02257                 partitionInfo-&gt;StartingOffset.QuadPart = 0;
02258                 partitionInfo-&gt;PartitionLength.QuadPart = 0;
02259                 partitionInfo-&gt;HiddenSectors = 0;
02260             }
02261 
02262         }
02263 
02264         <a class="code" href="../../d7/d2/drivesup_8c.html#a0">DebugPrint</a>((2, <span class="stringliteral">"\n"</span>));
02265 
02266         <span class="comment">//</span>
02267         <span class="comment">// If an error occurred, leave the routine now.</span>
02268         <span class="comment">//</span>
02269 
02270         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
02271             <span class="keywordflow">break</span>;
02272         }
02273 
02274         <span class="keywordflow">if</span>(tableIsValid == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
02275             
02276             <span class="comment">//</span>
02277             <span class="comment">// Invalidate this partition table and stop looking for new ones.</span>
02278             <span class="comment">// we'll build the partition list based on the ones we found </span>
02279             <span class="comment">// previously.</span>
02280             <span class="comment">//</span>
02281 
02282             partitionTableCounter--;
02283             <span class="keywordflow">break</span>;
02284         }
02285 
02286         <span class="comment">//</span>
02287         <span class="comment">// Now check to see if there are any link entries in this table,</span>
02288         <span class="comment">// and if so, set up the sector address of the next partition table.</span>
02289         <span class="comment">// There can only be one link entry in each partition table, and it</span>
02290         <span class="comment">// will point to the next table.</span>
02291         <span class="comment">//</span>
02292 
02293         partitionTableEntry = (<a class="code" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html">PPARTITION_DESCRIPTOR</a>) &amp;(((<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>) readBuffer)[<a class="code" href="../../d2/d7/hal_8h.html#a10">PARTITION_TABLE_OFFSET</a>]);
02294 
02295         <span class="comment">//</span>
02296         <span class="comment">// Assume that the link entry is empty.</span>
02297         <span class="comment">//</span>
02298 
02299         partitionTableOffset.QuadPart = 0;
02300 
02301         <span class="keywordflow">for</span> (partitionEntry = 1;
02302              partitionEntry &lt;= <a class="code" href="../../d2/d7/hal_8h.html#a9">NUM_PARTITION_TABLE_ENTRIES</a>;
02303              partitionEntry++, partitionTableEntry++) {
02304 
02305             <span class="keywordflow">if</span> (IsContainerPartition(partitionTableEntry-&gt;<a class="code" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html#o4">PartitionType</a>)) {
02306 
02307                 <span class="comment">//</span>
02308                 <span class="comment">// Obtain the address of the next partition table on the</span>
02309                 <span class="comment">// disk.  This is the number of hidden sectors added to</span>
02310                 <span class="comment">// the beginning of the extended partition (in the case of</span>
02311                 <span class="comment">// logical drives), since all logical drives are relative</span>
02312                 <span class="comment">// to the extended partition.  The VolumeStartSector will</span>
02313                 <span class="comment">// be zero if this is the primary parition table.</span>
02314                 <span class="comment">//</span>
02315 
02316                 partitionTableOffset.QuadPart = volumeStartOffset.QuadPart +
02317                     UInt32x32To64(<a class="code" href="../../d7/d2/drivesup_8c.html#a1">GET_STARTING_SECTOR</a>(partitionTableEntry),
02318                                   SectorSize);
02319 
02320                 <span class="comment">//</span>
02321                 <span class="comment">// Set the VolumeStartSector to be the begining of the</span>
02322                 <span class="comment">// second partition (extended partition) because all of</span>
02323                 <span class="comment">// the offsets to the partition tables of the logical drives</span>
02324                 <span class="comment">// are relative to this extended partition.</span>
02325                 <span class="comment">//</span>
02326 
02327                 <span class="keywordflow">if</span> (primaryPartitionTable) {
02328                     volumeStartOffset = partitionTableOffset;
02329                 }
02330 
02331                 <span class="comment">//</span>
02332                 <span class="comment">// Update the maximum sector to be the end of the container </span>
02333                 <span class="comment">// partition.</span>
02334                 <span class="comment">//</span>
02335 
02336                 maxSector = <a class="code" href="../../d7/d2/drivesup_8c.html#a2">GET_PARTITION_LENGTH</a>(partitionTableEntry);
02337 
02338                 <a class="code" href="../../d7/d2/drivesup_8c.html#a0">DebugPrint</a>((2, <span class="stringliteral">"MaxSector now = %#08lx\n"</span>, maxSector));
02339 
02340                 <span class="comment">//</span>
02341                 <span class="comment">// There is only ever one link entry per partition table,</span>
02342                 <span class="comment">// exit the loop once it has been found.</span>
02343                 <span class="comment">//</span>
02344 
02345                 <span class="keywordflow">break</span>;
02346             }
02347         }
02348 
02349 
02350         <span class="comment">//</span>
02351         <span class="comment">// All the other partitions will be logical drives.</span>
02352         <span class="comment">//</span>
02353 
02354         primaryPartitionTable = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02355 
02356 
02357     } <span class="keywordflow">while</span> (partitionTableOffset.HighPart | partitionTableOffset.LowPart);
02358 
02359     <span class="comment">//</span>
02360     <span class="comment">// Detect super-floppy media attempt #1.</span>
02361     <span class="comment">// If the media is removable and has an 0xaa55 signature on it and </span>
02362     <span class="comment">// is empty then check to see if we can recognize the BPB.  If we recognize</span>
02363     <span class="comment">// a jump-byte at the beginning of the media then it's a super floppy.  If</span>
02364     <span class="comment">// we don't then it's an unpartitioned disk.</span>
02365     <span class="comment">// </span>
02366 
02367     <a class="code" href="../../d7/d2/drivesup_8c.html#a0">DebugPrint</a>((4, <span class="stringliteral">"xHalIoReadPartitionTable: RM %d  PTC %d  MBR %d  EPT %d\n"</span>, 
02368                 diskGeometry.MediaType,
02369                 partitionTableCounter,
02370                 mbrSignatureFound,
02371                 emptyPartitionTable));
02372 
02373     <span class="keywordflow">if</span>((diskGeometry.MediaType == RemovableMedia) &amp;&amp;
02374        (partitionTableCounter == 0) &amp;&amp;
02375        (mbrSignatureFound == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) &amp;&amp;
02376        (emptyPartitionTable == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>)) {
02377 
02378         <a class="code" href="../../d7/d4/struct__BOOT__SECTOR__INFO.html">PBOOT_SECTOR_INFO</a> bootSector = (<a class="code" href="../../d7/d4/struct__BOOT__SECTOR__INFO.html">PBOOT_SECTOR_INFO</a>) readBuffer;
02379 
02380         <span class="keywordflow">if</span>((bootSector-&gt;<a class="code" href="../../d7/d4/struct__BOOT__SECTOR__INFO.html#o0">JumpByte</a>[0] == 0xeb) ||
02381            (bootSector-&gt;<a class="code" href="../../d7/d4/struct__BOOT__SECTOR__INFO.html#o0">JumpByte</a>[0] == 0xe9)) {
02382 
02383             <span class="comment">//</span>
02384             <span class="comment">// We've got a superfloppy of some sort.</span>
02385             <span class="comment">//</span>
02386 
02387             <a class="code" href="../../d7/d2/drivesup_8c.html#a0">DebugPrint</a>((1, <span class="stringliteral">"xHalIoReadPartitionTable: Jump byte %#x found "</span>
02388                            <span class="stringliteral">"along with empty partition table - disk is a "</span>
02389                            <span class="stringliteral">"super floppy and has no valid MBR\n"</span>, 
02390                         bootSector-&gt;<a class="code" href="../../d7/d4/struct__BOOT__SECTOR__INFO.html#o0">JumpByte</a>));
02391 
02392             partitionTableCounter = -1;
02393         }
02394     }
02395 
02396     <span class="comment">//</span>
02397     <span class="comment">// If the partition table count is still -1 then we didn't find any </span>
02398     <span class="comment">// valid partition records.  In this case we'll build a partition list </span>
02399     <span class="comment">// that contiains one partition spanning the entire disk.</span>
02400     <span class="comment">//</span>
02401 
02402     <span class="keywordflow">if</span>(partitionTableCounter == -1) {
02403 
02404         <span class="keywordflow">if</span>((mbrSignatureFound == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) ||
02405            (diskGeometry.MediaType == RemovableMedia)) {
02406 
02407             <span class="comment">//</span>
02408             <span class="comment">// Either we found a signature but the partition layout was </span>
02409             <span class="comment">// invalid (for all disks) or we didn't find a signature but this</span>
02410             <span class="comment">// is a removable disk.  Either of these two cases makes a </span>
02411             <span class="comment">// superfloppy.</span>
02412             <span class="comment">//</span>
02413 
02414             <a class="code" href="../../d7/d2/drivesup_8c.html#a0">DebugPrint</a>((1, <span class="stringliteral">"xHalIoReadPartitionTable: Drive %#p has no valid MBR. "</span> 
02415                            <span class="stringliteral">"Make it into a super-floppy\n"</span>, DeviceObject));
02416     
02417             <a class="code" href="../../d7/d2/drivesup_8c.html#a0">DebugPrint</a>((1, <span class="stringliteral">"xHalIoReadPartitionTable: Drive has %#08lx sectors "</span>
02418                            <span class="stringliteral">"and is %#016I64x bytes large\n"</span>, 
02419                         endSector, endSector * diskGeometry.BytesPerSector));
02420     
02421             <span class="keywordflow">if</span> (endSector &gt; 0) {
02422     
02423                 partitionInfo = &amp;(*PartitionBuffer)-&gt;PartitionEntry[0];
02424     
02425                 partitionInfo-&gt;RewritePartition = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02426                 partitionInfo-&gt;RecognizedPartition = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02427                 partitionInfo-&gt;PartitionType = PARTITION_FAT_16;
02428                 partitionInfo-&gt;BootIndicator = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02429     
02430                 partitionInfo-&gt;HiddenSectors = 0;
02431     
02432                 partitionInfo-&gt;StartingOffset.QuadPart = 0;
02433     
02434                 partitionInfo-&gt;PartitionLength.QuadPart = 
02435                     (endSector * diskGeometry.BytesPerSector);
02436     
02437                 (*PartitionBuffer)-&gt;Signature = 1;
02438     
02439                 partitionNumber = 0;
02440             }
02441         } <span class="keywordflow">else</span> {
02442 
02443             <span class="comment">//</span>
02444             <span class="comment">// We found no partitions.  Make sure the partition count is -1</span>
02445             <span class="comment">// so that we setup a zeroed-out partition table below.</span>
02446             <span class="comment">//</span>
02447 
02448             partitionNumber = -1;
02449         }
02450     } 
02451 
02452     <span class="comment">//</span>
02453     <span class="comment">// Fill in the first field in the PartitionBuffer. This field indicates how</span>
02454     <span class="comment">// many partition entries there are in the PartitionBuffer.</span>
02455     <span class="comment">//</span>
02456 
02457     (*PartitionBuffer)-&gt;PartitionCount = ++partitionNumber;
02458 
02459     <span class="keywordflow">if</span> (!partitionNumber) {
02460 
02461         <span class="comment">//</span>
02462         <span class="comment">// Zero out disk signature.</span>
02463         <span class="comment">//</span>
02464 
02465         (*PartitionBuffer)-&gt;Signature = 0;
02466     }
02467 
02468     <span class="comment">//</span>
02469     <span class="comment">// Deallocate read buffer if it was allocated it.</span>
02470     <span class="comment">//</span>
02471 
02472     <span class="keywordflow">if</span> (readBuffer != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02473         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( readBuffer );
02474     }
02475 
02476     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status)) {
02477         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(*PartitionBuffer);
02478         *PartitionBuffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02479     }
02480     <span class="keywordflow">return</span> status;
02481 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a14" doxytag="haldisp.h::xHalIoSetPartitionInformation" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS FASTCALL xHalIoSetPartitionInformation           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>DeviceObject</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>SectorSize</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>PartitionNumber</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>PartitionType</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d8/d1/drivesup_8c-source.html#l02485">2485</a> of file <a class="el" href="../../d8/d1/drivesup_8c-source.html">drivesup.c</a>.
<p>
<pre class="fragment"><div>02494                    :
02495 
02496     This routine <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> invoked when a disk device driver <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> asked to set <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
02497     partition <a class="code" href="../../d3/d5/i386_2trapc_8c.html#a9">type</a> in a partition table entry via an I/O <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a58">control</a> code.  This
02498     <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a58">control</a> code <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> generally issued by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d8/d0/rtbatcr_8c.html#a8">format</a> utility just after <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a>
02499     has formatted <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> partition.  The <a class="code" href="../../d8/d0/rtbatcr_8c.html#a8">format</a> utility performs <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> I/O <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a58">control</a>
02500     function on <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> partition and <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> driver passes <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> address of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> base
02501     physical device object and <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> number of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> partition associated with
02502     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> device object that <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d8/d0/rtbatcr_8c.html#a8">format</a> utility has open.  If <span class="keyword">this</span> routine
02503     returns success, then <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> disk driver should updates its notion of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
02504     partition <a class="code" href="../../d3/d5/i386_2trapc_8c.html#a9">type</a> <span class="keywordflow">for</span> <span class="keyword">this</span> partition in its device <a class="code" href="../../d7/d1/genuedef_8c.html#a6">extension</a>.
02505 
02506 Arguments:
02507 
02508     DeviceObject - Pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> base physical device object <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> device
02509         on which <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> partition <a class="code" href="../../d3/d5/i386_2trapc_8c.html#a9">type</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> to be set.
02510 
02511     <a class="code" href="../../d3/d8/udfprocs_8h.html#a42">SectorSize</a> - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> size of a sector on <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> disk in bytes.
02512 
02513     PartitionNumber - Specifies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> partition number on <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> device whose
02514         partition <a class="code" href="../../d3/d5/i386_2trapc_8c.html#a9">type</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> to be changed.
02515 
02516     PartitionType - Specifies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <span class="keyword">new</span> <a class="code" href="../../d3/d5/i386_2trapc_8c.html#a9">type</a> <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> partition.
02517 
02518 Return Value:
02519 
02520     The function value <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <span class="keyword">final</span> status of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> operation.
02521 
02522 Notes:
02523 
02524     This routine <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> synchronous.  Therefore, <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> MUST be invoked by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> disk
02525     driver's dispatch routine, or by a disk driver's thread.  Likewise, all
02526     users, FSP threads, etc., must be prepared to enter a wait state when
02527     issuing <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> I/O <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a58">control</a> code to set <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> partition <a class="code" href="../../d3/d5/i386_2trapc_8c.html#a9">type</a> <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> device.
02528 
02529     Note also that <span class="keyword">this</span> routine assumes that <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> partition number passed
02530     in by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> disk driver actually exists since <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> driver itself supplies
02531     <span class="keyword">this</span> parameter.
02532 
02533     Finally, note that <span class="keyword">this</span> routine may NOT be invoked at <a class="code" href="../../d6/d7/halmips_8h.html#a52">APC_LEVEL</a>.  It
02534     must be invoked at <a class="code" href="../../d1/d3/ppcdef_8h.html#a21">PASSIVE_LEVEL</a>.  This <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> due to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> fact that <span class="keyword">this</span>
02535     routine uses a kernel event object to synchronize I/O completion on <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
02536     device.  The event cannot be set to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> signaled state without queueing
02537     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> I/O system's special kernel APC routine <span class="keywordflow">for</span> I/O completion and
02538     executing <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a>.  (This rules <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> a bit esoteric since <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> <a class="code" href="../../d3/d0/imm32_8def.html#a1">only</a> holds <span class="keyword">true</span>
02539     <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> device driver returns something other than STATUS_PENDING, which
02540     <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> will probably never <span class="keywordflow">do</span>.)
02541 
02542 --*/
02543 
02544 {
02545 
02546 <span class="preprocessor">#define GET_STARTING_SECTOR( p ) (                  \</span>
02547 <span class="preprocessor">        (ULONG) (p-&gt;StartingSectorLsb0) +           \</span>
02548 <span class="preprocessor">        (ULONG) (p-&gt;StartingSectorLsb1 &lt;&lt; 8) +      \</span>
02549 <span class="preprocessor">        (ULONG) (p-&gt;StartingSectorMsb0 &lt;&lt; 16) +     \</span>
02550 <span class="preprocessor">        (ULONG) (p-&gt;StartingSectorMsb1 &lt;&lt; 24) )</span>
02551 <span class="preprocessor"></span>
02552     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
02553     <a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a> event;
02554     IO_STATUS_BLOCK ioStatus;
02555     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
02556     LARGE_INTEGER partitionTableOffset;
02557     LARGE_INTEGER volumeStartOffset;
02558     PUCHAR buffer = (PUCHAR) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02559     ULONG transferSize;
02560     ULONG partitionNumber;
02561     ULONG partitionEntry;
02562     <a class="code" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html">PPARTITION_DESCRIPTOR</a> partitionTableEntry;
02563     BOOLEAN primaryPartitionTable;
02564     BOOLEAN foundEZHooker = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02565 
02566     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
02567 
02568     <span class="comment">//</span>
02569     <span class="comment">// Begin by determining the size of the buffer required to read and write</span>
02570     <span class="comment">// the partition information to/from the disk.  This is done to ensure</span>
02571     <span class="comment">// that at least 512 bytes are read, thereby guaranteeing that enough data</span>
02572     <span class="comment">// is read to include an entire partition table.  Note that this code</span>
02573     <span class="comment">// assumes that the actual sector size of the disk (if less than 512</span>
02574     <span class="comment">// bytes) is a multiple of 2, a</span>
02575     <span class="comment">// fairly reasonable assumption.</span>
02576     <span class="comment">//</span>
02577 
02578     <span class="keywordflow">if</span> (<a class="code" href="../../d3/d8/udfprocs_8h.html#a42">SectorSize</a> &gt;= 512) {
02579         transferSize = <a class="code" href="../../d3/d8/udfprocs_8h.html#a42">SectorSize</a>;
02580     } <span class="keywordflow">else</span> {
02581         transferSize = 512;
02582     }
02583 
02584 
02585     <span class="comment">//</span>
02586     <span class="comment">// Look to see if this is an EZDrive Disk.  If it is then get the</span>
02587     <span class="comment">// real parititon table at 1.</span>
02588     <span class="comment">//</span>
02589 
02590     {
02591 
02592         PVOID buff;
02593 
02594         <a class="code" href="../../d2/d7/hal_8h.html#a23">HalExamineMBR</a>(
02595             DeviceObject,
02596             transferSize,
02597             (ULONG)0x55,
02598             &amp;buff
02599             );
02600 
02601         <span class="keywordflow">if</span> (buff) {
02602 
02603             foundEZHooker = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02604             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(buff);
02605             partitionTableOffset.QuadPart = 512;
02606 
02607         } <span class="keywordflow">else</span> {
02608 
02609             partitionTableOffset.QuadPart = 0;
02610 
02611         }
02612 
02613     }
02614 
02615 
02616     <span class="comment">//</span>
02617     <span class="comment">// The partitions in this primary partition have their start sector 0.</span>
02618     <span class="comment">//</span>
02619 
02620     volumeStartOffset.QuadPart = 0;
02621 
02622     <span class="comment">//</span>
02623     <span class="comment">// Indicate that the table being read and processed is the primary partition</span>
02624     <span class="comment">// table.</span>
02625     <span class="comment">//</span>
02626 
02627     primaryPartitionTable = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02628 
02629     <span class="comment">//</span>
02630     <span class="comment">// Initialize the number of partitions found thus far.</span>
02631     <span class="comment">//</span>
02632 
02633     partitionNumber = 0;
02634 
02635     <span class="comment">//</span>
02636     <span class="comment">// Allocate a buffer that will hold the read/write data.</span>
02637     <span class="comment">//</span>
02638 
02639     buffer = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( NonPagedPoolCacheAligned, PAGE_SIZE, 'btsF');
02640     <span class="keywordflow">if</span> (buffer == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02641         <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
02642     }
02643 
02644     <span class="comment">//</span>
02645     <span class="comment">// Initialize a kernel event to use in synchronizing device requests</span>
02646     <span class="comment">// with I/O completion.</span>
02647     <span class="comment">//</span>
02648 
02649     <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( &amp;event, NotificationEvent, FALSE );
02650 
02651     <span class="comment">//</span>
02652     <span class="comment">// Read each partition table scanning for the partition table entry that</span>
02653     <span class="comment">// the caller wishes to modify.</span>
02654     <span class="comment">//</span>
02655 
02656     <span class="keywordflow">do</span> {
02657 
02658         <span class="comment">//</span>
02659         <span class="comment">// Read the record containing the partition table.</span>
02660         <span class="comment">//</span>
02661 
02662         (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d2/d8/eventobj_8c.html#a7">KeResetEvent</a>( &amp;event );
02663 
02664         irp = <a class="code" href="../../d4/d6/iosubs_8c.html#a27">IoBuildSynchronousFsdRequest</a>( IRP_MJ_READ,
02665                                             DeviceObject,
02666                                             buffer,
02667                                             transferSize,
02668                                             &amp;partitionTableOffset,
02669                                             &amp;event,
02670                                             &amp;ioStatus );
02671 
02672         <span class="keywordflow">if</span> (!irp) {
02673             status = STATUS_INSUFFICIENT_RESOURCES;
02674             <span class="keywordflow">break</span>;
02675         } <span class="keywordflow">else</span> {
02676             <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpStack;
02677             irpStack = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>(irp);
02678             irpStack-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o2">Flags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a203">SL_OVERRIDE_VERIFY_VOLUME</a>;
02679         }
02680 
02681         status = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>( DeviceObject, irp );
02682 
02683         <span class="keywordflow">if</span> (status == STATUS_PENDING) {
02684             (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;event,
02685                                           Executive,
02686                                           KernelMode,
02687                                           FALSE,
02688                                           (PLARGE_INTEGER) NULL );
02689             status = ioStatus.Status;
02690         }
02691 
02692         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
02693             <span class="keywordflow">break</span>;
02694         }
02695 
02696         <span class="comment">//</span>
02697         <span class="comment">// If EZDrive is hooking the MBR then we found the first partition table</span>
02698         <span class="comment">// in sector 1 rather than 0.  However that partition table is relative</span>
02699         <span class="comment">// to sector zero.  So, Even though we got it from one, reset the partition</span>
02700         <span class="comment">// offset to 0.</span>
02701         <span class="comment">//</span>
02702 
02703         <span class="keywordflow">if</span> (foundEZHooker &amp;&amp; (partitionTableOffset.QuadPart == 512)) {
02704 
02705             partitionTableOffset.QuadPart = 0;
02706 
02707         }
02708 
02709         <span class="comment">//</span>
02710         <span class="comment">// Check for a valid Boot Record signature in the partition table</span>
02711         <span class="comment">// record.</span>
02712         <span class="comment">//</span>
02713 
02714         <span class="keywordflow">if</span> (((<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>) buffer)[<a class="code" href="../../d2/d7/hal_8h.html#a11">BOOT_SIGNATURE_OFFSET</a>] != <a class="code" href="../../d2/d7/hal_8h.html#a12">BOOT_RECORD_SIGNATURE</a>) {
02715             status = STATUS_BAD_MASTER_BOOT_RECORD;
02716             <span class="keywordflow">break</span>;
02717         }
02718 
02719         partitionTableEntry = (<a class="code" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html">PPARTITION_DESCRIPTOR</a>) &amp;(((<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>) buffer)[<a class="code" href="../../d2/d7/hal_8h.html#a10">PARTITION_TABLE_OFFSET</a>]);
02720 
02721         <span class="comment">//</span>
02722         <span class="comment">// Scan the partition entries in this partition table to determine if</span>
02723         <span class="comment">// any of the entries are the desired entry.  Each entry in each</span>
02724         <span class="comment">// table must be scanned in the same order as in IoReadPartitionTable</span>
02725         <span class="comment">// so that the partition table entry cooresponding to the driver's</span>
02726         <span class="comment">// notion of the partition number can be located.</span>
02727         <span class="comment">//</span>
02728 
02729         <span class="keywordflow">for</span> (partitionEntry = 1;
02730             partitionEntry &lt;= <a class="code" href="../../d2/d7/hal_8h.html#a9">NUM_PARTITION_TABLE_ENTRIES</a>;
02731             partitionEntry++, partitionTableEntry++) {
02732 
02733 
02734             <span class="comment">//</span>
02735             <span class="comment">// If the partition entry is empty or for an extended, skip it.</span>
02736             <span class="comment">//</span>
02737 
02738             <span class="keywordflow">if</span> ((partitionTableEntry-&gt;<a class="code" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html#o4">PartitionType</a> == PARTITION_ENTRY_UNUSED) ||
02739                 IsContainerPartition(partitionTableEntry-&gt;<a class="code" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html#o4">PartitionType</a>)) {
02740                 <span class="keywordflow">continue</span>;
02741             }
02742 
02743             <span class="comment">//</span>
02744             <span class="comment">// A valid partition entry that is recognized has been located.</span>
02745             <span class="comment">// Bump the count and check to see if this entry is the desired</span>
02746             <span class="comment">// entry.</span>
02747             <span class="comment">//</span>
02748 
02749             partitionNumber++;
02750 
02751             <span class="keywordflow">if</span> (partitionNumber == PartitionNumber) {
02752 
02753                 <span class="comment">//</span>
02754                 <span class="comment">// This is the desired partition that is to be changed.  Simply</span>
02755                 <span class="comment">// overwrite the partition type and write the entire partition</span>
02756                 <span class="comment">// buffer back out to the disk.</span>
02757                 <span class="comment">//</span>
02758 
02759                 partitionTableEntry-&gt;<a class="code" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html#o4">PartitionType</a> = (UCHAR) PartitionType;
02760 
02761                 (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d2/d8/eventobj_8c.html#a7">KeResetEvent</a>( &amp;event );
02762 
02763                 irp = <a class="code" href="../../d4/d6/iosubs_8c.html#a27">IoBuildSynchronousFsdRequest</a>( IRP_MJ_WRITE,
02764                                                     DeviceObject,
02765                                                     buffer,
02766                                                     transferSize,
02767                                                     &amp;partitionTableOffset,
02768                                                     &amp;event,
02769                                                     &amp;ioStatus );
02770 
02771                 <span class="keywordflow">if</span> (!irp) {
02772                     status = STATUS_INSUFFICIENT_RESOURCES;
02773                     <span class="keywordflow">break</span>;
02774                 } <span class="keywordflow">else</span> {
02775                     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpStack;
02776                     irpStack = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>(irp);
02777                     irpStack-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o2">Flags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a203">SL_OVERRIDE_VERIFY_VOLUME</a>;
02778                 }
02779 
02780                 status = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>( DeviceObject, irp );
02781 
02782                 <span class="keywordflow">if</span> (status == STATUS_PENDING) {
02783                     (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;event,
02784                                                   Executive,
02785                                                   KernelMode,
02786                                                   FALSE,
02787                                                   (PLARGE_INTEGER) NULL );
02788                     status = ioStatus.Status;
02789                 }
02790 
02791                 <span class="keywordflow">break</span>;
02792             }
02793         }
02794 
02795         <span class="comment">//</span>
02796         <span class="comment">// If all of the entries in the current buffer were scanned and the</span>
02797         <span class="comment">// desired entry was not found, then continue.  Otherwise, leave the</span>
02798         <span class="comment">// routine.</span>
02799         <span class="comment">//</span>
02800 
02801         <span class="keywordflow">if</span> (partitionEntry &lt;= <a class="code" href="../../d2/d7/hal_8h.html#a9">NUM_PARTITION_TABLE_ENTRIES</a>) {
02802             <span class="keywordflow">break</span>;
02803         }
02804 
02805         <span class="comment">//</span>
02806         <span class="comment">// Now scan the current buffer to locate an extended partition entry</span>
02807         <span class="comment">// in the table so that its partition information can be read.  There</span>
02808         <span class="comment">// can only be one extended partition entry in each partition table,</span>
02809         <span class="comment">// and it will point to the next table.</span>
02810         <span class="comment">//</span>
02811 
02812         partitionTableEntry = (<a class="code" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html">PPARTITION_DESCRIPTOR</a>) &amp;(((<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>) buffer)[<a class="code" href="../../d2/d7/hal_8h.html#a10">PARTITION_TABLE_OFFSET</a>]);
02813 
02814         <span class="keywordflow">for</span> (partitionEntry = 1;
02815             partitionEntry &lt;= <a class="code" href="../../d2/d7/hal_8h.html#a9">NUM_PARTITION_TABLE_ENTRIES</a>;
02816             partitionEntry++, partitionTableEntry++) {
02817 
02818             <span class="keywordflow">if</span> (IsContainerPartition(partitionTableEntry-&gt;<a class="code" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html#o4">PartitionType</a>)) {
02819 
02820                 <span class="comment">//</span>
02821                 <span class="comment">// Obtain the address of the next partition table on the disk.</span>
02822                 <span class="comment">// This is the number of hidden sectors added to the beginning</span>
02823                 <span class="comment">// of the extended partition (in the case of logical drives),</span>
02824                 <span class="comment">// since all logical drives are relative to the extended</span>
02825                 <span class="comment">// partition.  The starting offset of the volume will be zero</span>
02826                 <span class="comment">// if this is the primary partition table.</span>
02827                 <span class="comment">//</span>
02828 
02829                 partitionTableOffset.QuadPart = volumeStartOffset.QuadPart +
02830                     UInt32x32To64(<a class="code" href="../../d7/d2/drivesup_8c.html#a1">GET_STARTING_SECTOR</a>(partitionTableEntry),
02831                                   SectorSize);
02832 
02833                 <span class="comment">//</span>
02834                 <span class="comment">// Set the starting offset of the volume to be the beginning of</span>
02835                 <span class="comment">// the second partition (the extended partition) because all of</span>
02836                 <span class="comment">// the offsets to the partition tables of the logical drives</span>
02837                 <span class="comment">// are relative to this extended partition.</span>
02838                 <span class="comment">//</span>
02839 
02840                 <span class="keywordflow">if</span> (primaryPartitionTable) {
02841                     volumeStartOffset = partitionTableOffset;
02842                 }
02843 
02844                 <span class="keywordflow">break</span>;
02845             }
02846         }
02847 
02848         <span class="comment">//</span>
02849         <span class="comment">// Ensure that a partition entry was located that was an extended</span>
02850         <span class="comment">// partition, otherwise the desired partition will never be found.</span>
02851         <span class="comment">//</span>
02852 
02853         <span class="keywordflow">if</span> (partitionEntry &gt; <a class="code" href="../../d2/d7/hal_8h.html#a9">NUM_PARTITION_TABLE_ENTRIES</a>) {
02854             status = STATUS_BAD_MASTER_BOOT_RECORD;
02855             <span class="keywordflow">break</span>;
02856         }
02857 
02858         <span class="comment">//</span>
02859         <span class="comment">// All the other partitions will be logical drives.</span>
02860         <span class="comment">//</span>
02861 
02862         primaryPartitionTable = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02863 
02864     } <span class="keywordflow">while</span> (partitionNumber &lt; PartitionNumber);
02865 
02866     <span class="comment">//</span>
02867     <span class="comment">// If a data buffer was successfully allocated, deallocate it now.</span>
02868     <span class="comment">//</span>
02869 
02870     <span class="keywordflow">if</span> (buffer != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02871         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( buffer );
02872     }
02873 
02874     <span class="keywordflow">return</span> status;
02875 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a15" doxytag="haldisp.h::xHalIoWritePartitionTable" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS FASTCALL xHalIoWritePartitionTable           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>DeviceObject</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>SectorSize</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>SectorsPerTrack</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>NumberOfHeads</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN struct _DRIVE_LAYOUT_INFORMATION *&nbsp;</td>
          <td class="mdname" nowrap> <em>PartitionBuffer</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d8/d1/drivesup_8c-source.html#l02879">2879</a> of file <a class="el" href="../../d8/d1/drivesup_8c-source.html">drivesup.c</a>.
<p>
<pre class="fragment"><div>02889                    :
02890 
02891     This routine walks <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> disk writing <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> partition tables from
02892     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> entries in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> partition list buffer <span class="keywordflow">for</span> each partition.
02893 
02894     Applications that create and <span class="keyword">delete</span> partitions should issue a
02895     <a class="code" href="../../d2/d7/hal_8h.html#a192">IoReadPartitionTable</a> call with <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> '<span class="keywordflow">return</span> recognized partitions'
02896     <span class="keywordtype">boolean</span> set to <span class="keyword">false</span> to get a full description of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> system.
02897 
02898     Then <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> drive layout structure can be modified by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> application to
02899     reflect <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <span class="keyword">new</span> configuration of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> disk and then <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> written back
02900     to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> disk <span class="keyword">using</span> <span class="keyword">this</span> routine.
02901 
02902 Arguments:
02903 
02904     DeviceObject - Pointer to device object <span class="keywordflow">for</span> <span class="keyword">this</span> disk.
02905 
02906     <a class="code" href="../../d3/d8/udfprocs_8h.html#a42">SectorSize</a> - Sector size on <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> device.
02907 
02908     SectorsPerTrack - Track size on <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> device.
02909 
02910     NumberOfHeads - Same as tracks per cylinder.
02911 
02912     PartitionBuffer - Pointer drive layout buffer.
02913 
02914 Return Value:
02915 
02916     The functional value <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> STATUS_SUCCESS <span class="keywordflow">if</span> all writes are completed
02917     without error.
02918 
02919 --*/
02920 
02921 {
02922 <span class="keyword">typedef</span> <span class="keyword">struct </span>_PARTITION_TABLE {
02923     PARTITION_INFORMATION PartitionEntry[4];
02924 } PARTITION_TABLE, *PPARTITION_TABLE;
02925 
02926 <span class="keyword">typedef</span> <span class="keyword">struct </span>_DISK_LAYOUT {
02927     ULONG TableCount;
02928     ULONG Signature;
02929     PARTITION_TABLE PartitionTable[1];
02930 } DISK_LAYOUT, *PDISK_LAYOUT;
02931 
02932 <span class="keyword">typedef</span> <span class="keyword">struct </span>_PTE {
02933     UCHAR ActiveFlag;               <span class="comment">// Bootable or not</span>
02934     UCHAR StartingTrack;            <span class="comment">// Not used</span>
02935     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> StartingCylinder;        <span class="comment">// Not used</span>
02936     UCHAR PartitionType;            <span class="comment">// 12 bit FAT, 16 bit FAT etc.</span>
02937     UCHAR EndingTrack;              <span class="comment">// Not used</span>
02938     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> EndingCylinder;          <span class="comment">// Not used</span>
02939     ULONG StartingSector;           <span class="comment">// Hidden sectors</span>
02940     ULONG PartitionLength;          <span class="comment">// Sectors in this partition</span>
02941 } PTE;
02942 <span class="keyword">typedef</span> PTE UNALIGNED *PPTE;
02943 
02944 <span class="comment">//</span>
02945 <span class="comment">// This macro has the effect of Bit = log2(Data)</span>
02946 <span class="comment">//</span>
02947 
02948 <span class="preprocessor">#define WHICH_BIT(Data, Bit) {                      \</span>
02949 <span class="preprocessor">    for (Bit = 0; Bit &lt; 32; Bit++) {                \</span>
02950 <span class="preprocessor">        if ((Data &gt;&gt; Bit) == 1) {                   \</span>
02951 <span class="preprocessor">            break;                                  \</span>
02952 <span class="preprocessor">        }                                           \</span>
02953 <span class="preprocessor">    }                                               \</span>
02954 <span class="preprocessor">}</span>
02955 <span class="preprocessor"></span>
02956     ULONG writeSize;
02957     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a> writeBuffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02958     PPTE partitionEntry;
02959     PPARTITION_TABLE partitionTable;
02960     CCHAR shiftCount;
02961     LARGE_INTEGER partitionTableOffset;
02962     LARGE_INTEGER nextRecordOffset;
02963     ULONG partitionTableCount;
02964     ULONG partitionEntryCount;
02965     <a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a> event;
02966     IO_STATUS_BLOCK ioStatus;
02967     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
02968     BOOLEAN rewritePartition = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02969     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status = STATUS_SUCCESS;
02970     LARGE_INTEGER tempInt;
02971     BOOLEAN foundEZHooker = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02972     ULONG conventionalCylinders;
02973     LONGLONG diskSize;
02974 
02975     BOOLEAN isSuperFloppy = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02976 
02977     <span class="comment">//</span>
02978     <span class="comment">// Cast to a structure that is easier to use.</span>
02979     <span class="comment">//</span>
02980 
02981     PDISK_LAYOUT diskLayout = (PDISK_LAYOUT) PartitionBuffer;
02982 
02983     <span class="comment">//</span>
02984     <span class="comment">// Ensure that no one is calling this function illegally.</span>
02985     <span class="comment">//</span>
02986 
02987     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
02988 
02989     <span class="comment">//</span>
02990     <span class="comment">// Determine the size of a write operation to ensure that at least 512</span>
02991     <span class="comment">// bytes are written.  This will guarantee that enough data is written to</span>
02992     <span class="comment">// include an entire partition table.  Note that this code assumes that</span>
02993     <span class="comment">// the actual sector size of the disk (if less than 512 bytes) is a</span>
02994     <span class="comment">// multiple of 2, a fairly reasonable assumption.</span>
02995     <span class="comment">//</span>
02996 
02997     <span class="keywordflow">if</span> (<a class="code" href="../../d3/d8/udfprocs_8h.html#a42">SectorSize</a> &gt;= 512) {
02998         writeSize = <a class="code" href="../../d3/d8/udfprocs_8h.html#a42">SectorSize</a>;
02999     } <span class="keywordflow">else</span> {
03000         writeSize = 512;
03001     }
03002 
03003     <a class="code" href="../../d7/d2/drivesup_8c.html#a21">xHalGetPartialGeometry</a>( DeviceObject,
03004                             &amp;conventionalCylinders,
03005                             &amp;diskSize );
03006 
03007     <span class="comment">//</span>
03008     <span class="comment">// Look to see if this is an EZDrive Disk.  If it is then get the</span>
03009     <span class="comment">// real partititon table at 1.</span>
03010     <span class="comment">//</span>
03011 
03012     {
03013 
03014         PVOID buff;
03015 
03016         <a class="code" href="../../d2/d7/hal_8h.html#a23">HalExamineMBR</a>(
03017             DeviceObject,
03018             writeSize,
03019             (ULONG)0x55,
03020             &amp;buff
03021             );
03022 
03023         <span class="keywordflow">if</span> (buff) {
03024 
03025             foundEZHooker = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03026             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(buff);
03027             partitionTableOffset.QuadPart = 512;
03028 
03029         } <span class="keywordflow">else</span> {
03030 
03031             partitionTableOffset.QuadPart = 0;
03032 
03033         }
03034 
03035     }
03036 
03037     <span class="comment">//</span>
03038     <span class="comment">// Initialize starting variables.</span>
03039     <span class="comment">//</span>
03040 
03041     nextRecordOffset.QuadPart = 0;
03042 
03043     <span class="comment">//</span>
03044     <span class="comment">// Calculate shift count for converting between byte and sector.</span>
03045     <span class="comment">//</span>
03046 
03047     <a class="code" href="../../d7/d2/drivesup_8c.html#a9">WHICH_BIT</a>( SectorSize, shiftCount );
03048 
03049     <span class="comment">//</span>
03050     <span class="comment">// Check to see if this device is partitioned (or is being partitioned) </span>
03051     <span class="comment">// as a floppy.  Floppys have a single partititon with hidden sector count </span>
03052     <span class="comment">// and partition offset equal to zero.  If the disk is being partitioned</span>
03053     <span class="comment">// like this then we need to be sure not to write an MBR signature or </span>
03054     <span class="comment">// an NTFT signature to the media.</span>
03055     <span class="comment">//</span>
03056     <span class="comment">// NOTE: this is only to catch ourself when someone tries to write the </span>
03057     <span class="comment">// existing partition table back to disk.  Any changes to the table will </span>
03058     <span class="comment">// result in a real MBR being written out.</span>
03059     <span class="comment">//</span>
03060 
03061     <span class="keywordflow">if</span>(PartitionBuffer-&gt;PartitionCount == 1) {
03062        
03063         PPARTITION_INFORMATION partitionEntry = PartitionBuffer-&gt;PartitionEntry;
03064 
03065         <span class="keywordflow">if</span>((partitionEntry-&gt;StartingOffset.QuadPart == 0) &amp;&amp;
03066            (partitionEntry-&gt;HiddenSectors == 0)) {
03067 
03068             isSuperFloppy = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03069 
03070             <span class="comment">//</span>
03071             <span class="comment">// This would indeed appear to be an attempt to format a floppy.</span>
03072             <span class="comment">// Make sure the other parameters match the defaut values we </span>
03073             <span class="comment">// provide in ReadParititonTable.  If they don't then fail </span>
03074             <span class="comment">// the write operation.</span>
03075             <span class="comment">//</span>
03076 
03077             <span class="keywordflow">if</span>((partitionEntry-&gt;PartitionNumber != 0) ||
03078                (partitionEntry-&gt;PartitionType != PARTITION_FAT_16) ||
03079                (partitionEntry-&gt;BootIndicator == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>)) {
03080 
03081                 <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
03082             }
03083 
03084             <span class="keywordflow">if</span>(partitionEntry-&gt;RewritePartition == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
03085                 rewritePartition = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03086             }
03087 
03088             foundEZHooker = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03089         }
03090     }
03091 
03092     <span class="comment">//</span>
03093     <span class="comment">// Convert partition count to partition table or boot sector count.</span>
03094     <span class="comment">//</span>
03095 
03096     diskLayout-&gt;TableCount =
03097         (PartitionBuffer-&gt;PartitionCount +
03098         <a class="code" href="../../d2/d7/hal_8h.html#a9">NUM_PARTITION_TABLE_ENTRIES</a> - 1) /
03099         <a class="code" href="../../d2/d7/hal_8h.html#a9">NUM_PARTITION_TABLE_ENTRIES</a>;
03100 
03101     <span class="comment">//</span>
03102     <span class="comment">// Allocate a buffer for the sector writes.</span>
03103     <span class="comment">//</span>
03104 
03105     writeBuffer = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( NonPagedPoolCacheAligned, PAGE_SIZE, 'btsF');
03106 
03107     <span class="keywordflow">if</span> (writeBuffer == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03108         <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
03109     }
03110 
03111     <span class="comment">//</span>
03112     <span class="comment">// Point to the partition table entries in write buffer.</span>
03113     <span class="comment">//</span>
03114 
03115     partitionEntry = (PPTE) &amp;writeBuffer[<a class="code" href="../../d2/d7/hal_8h.html#a10">PARTITION_TABLE_OFFSET</a>];
03116 
03117     <span class="keywordflow">for</span> (partitionTableCount = 0;
03118          partitionTableCount &lt; diskLayout-&gt;TableCount;
03119          partitionTableCount++) {
03120 
03121         UCHAR   partitionType;
03122 
03123         <span class="comment">//</span>
03124         <span class="comment">// the first partition table is in the mbr (physical sector 0).</span>
03125         <span class="comment">// other partition tables are in ebr's within the extended partition.</span>
03126         <span class="comment">//</span>
03127 
03128         BOOLEAN mbr = (BOOLEAN) (!partitionTableCount);
03129         LARGE_INTEGER extendedPartitionOffset;
03130 
03131         <span class="comment">//</span>
03132         <span class="comment">// Read the boot record that's already there into the write buffer</span>
03133         <span class="comment">// and save its boot code area if the signature is valid.  This way</span>
03134         <span class="comment">// we don't clobber any boot code that might be there already.</span>
03135         <span class="comment">//</span>
03136 
03137         <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( &amp;event, NotificationEvent, FALSE );
03138 
03139         irp = <a class="code" href="../../d4/d6/iosubs_8c.html#a27">IoBuildSynchronousFsdRequest</a>( IRP_MJ_READ,
03140                                         DeviceObject,
03141                                         writeBuffer,
03142                                         writeSize,
03143                                         &amp;partitionTableOffset,
03144                                         &amp;event,
03145                                         &amp;ioStatus );
03146 
03147         <span class="keywordflow">if</span> (!irp) {
03148             status = STATUS_INSUFFICIENT_RESOURCES;
03149             <span class="keywordflow">break</span>;
03150         } <span class="keywordflow">else</span> {
03151             <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpStack;
03152             irpStack = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>(irp);
03153             irpStack-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o2">Flags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a203">SL_OVERRIDE_VERIFY_VOLUME</a>;
03154         }
03155 
03156         status = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>( DeviceObject, irp );
03157 
03158         <span class="keywordflow">if</span> (status == STATUS_PENDING) {
03159             (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;event,
03160                                       Executive,
03161                                       KernelMode,
03162                                       FALSE,
03163                                       (PLARGE_INTEGER) NULL);
03164             status = ioStatus.Status;
03165         }
03166 
03167         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
03168             <span class="keywordflow">break</span>;
03169         }
03170 
03171         <span class="comment">//</span>
03172         <span class="comment">// If EZDrive is hooking the MBR then we found the first partition table</span>
03173         <span class="comment">// in sector 1 rather than 0.  However that partition table is relative</span>
03174         <span class="comment">// to sector zero.  So, Even though we got it from one, reset the partition</span>
03175         <span class="comment">// offset to 0.</span>
03176         <span class="comment">//</span>
03177 
03178         <span class="keywordflow">if</span> (foundEZHooker &amp;&amp; (partitionTableOffset.QuadPart == 512)) {
03179 
03180             partitionTableOffset.QuadPart = 0;
03181 
03182         }
03183 
03184         <span class="keywordflow">if</span>(isSuperFloppy == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
03185 
03186             <span class="comment">//</span>
03187             <span class="comment">// Write signature to last word of boot sector.</span>
03188             <span class="comment">//</span>
03189     
03190             writeBuffer[<a class="code" href="../../d2/d7/hal_8h.html#a11">BOOT_SIGNATURE_OFFSET</a>] = <a class="code" href="../../d2/d7/hal_8h.html#a12">BOOT_RECORD_SIGNATURE</a>;
03191     
03192             <span class="comment">//</span>
03193             <span class="comment">// Write NTFT disk signature if it changed and this is the MBR.</span>
03194             <span class="comment">//</span>
03195     
03196             rewritePartition = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03197             <span class="keywordflow">if</span> (partitionTableOffset.QuadPart == 0) {
03198     
03199                 <span class="keywordflow">if</span> (((PULONG)writeBuffer)[<a class="code" href="../../d2/d7/hal_8h.html#a10">PARTITION_TABLE_OFFSET</a>/2-1] !=
03200                     PartitionBuffer-&gt;Signature) {
03201     
03202                     ((PULONG) writeBuffer)[<a class="code" href="../../d2/d7/hal_8h.html#a10">PARTITION_TABLE_OFFSET</a>/2-1] =
03203                         PartitionBuffer-&gt;Signature;
03204                     rewritePartition = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03205                 }
03206             }
03207 
03208             <span class="comment">//</span>
03209             <span class="comment">// Get pointer to first partition table.</span>
03210             <span class="comment">//</span>
03211     
03212             partitionTable = &amp;diskLayout-&gt;PartitionTable[partitionTableCount];
03213     
03214             <span class="comment">//</span>
03215             <span class="comment">// Walk table to determine whether this boot record has changed</span>
03216             <span class="comment">// and update partition table in write buffer in case it needs</span>
03217             <span class="comment">// to be written out to disk.</span>
03218             <span class="comment">//</span>
03219     
03220             <span class="keywordflow">for</span> (partitionEntryCount = 0;
03221                  partitionEntryCount &lt; <a class="code" href="../../d2/d7/hal_8h.html#a9">NUM_PARTITION_TABLE_ENTRIES</a>;
03222                  partitionEntryCount++) {
03223     
03224                 partitionType =
03225                         partitionTable-&gt;PartitionEntry[partitionEntryCount].PartitionType;
03226     
03227                 <span class="comment">//</span>
03228                 <span class="comment">// If the rewrite ISN'T true then copy then just leave the data</span>
03229                 <span class="comment">// alone that is in the on-disk table.</span>
03230                 <span class="comment">//</span>
03231     
03232                 <span class="keywordflow">if</span> (partitionTable-&gt;PartitionEntry[partitionEntryCount].RewritePartition) {
03233     
03234                     <span class="comment">//</span>
03235                     <span class="comment">// This boot record needs to be written back to disk.</span>
03236                     <span class="comment">//</span>
03237     
03238                     rewritePartition = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03239     
03240                     <span class="comment">//</span>
03241                     <span class="comment">// Copy partition type from user buffer to write buffer.</span>
03242                     <span class="comment">//</span>
03243     
03244                     partitionEntry[partitionEntryCount].PartitionType =
03245                         partitionTable-&gt;PartitionEntry[partitionEntryCount].PartitionType;
03246     
03247                     <span class="comment">//</span>
03248                     <span class="comment">// Copy the partition active flag.</span>
03249                     <span class="comment">//</span>
03250     
03251                     partitionEntry[partitionEntryCount].ActiveFlag =
03252                         partitionTable-&gt;PartitionEntry[partitionEntryCount].BootIndicator ?
03253                         (UCHAR) <a class="code" href="../../d2/d7/hal_8h.html#a14">PARTITION_ACTIVE_FLAG</a> : (UCHAR) 0;
03254     
03255                     <span class="keywordflow">if</span> (partitionType != PARTITION_ENTRY_UNUSED) {
03256     
03257                         LARGE_INTEGER sectorOffset;
03258     
03259                         <span class="comment">//</span>
03260                         <span class="comment">// Calculate partition offset.</span>
03261                         <span class="comment">// If in the mbr or the entry is not a link entry, partition offset</span>
03262                         <span class="comment">// is sectors past last boot record.  Otherwise (not in the mbr and</span>
03263                         <span class="comment">// entry is a link entry), partition offset is sectors past start</span>
03264                         <span class="comment">// of extended partition.</span>
03265                         <span class="comment">//</span>
03266     
03267                         <span class="keywordflow">if</span> (mbr || !IsContainerPartition(partitionType)) {
03268                             tempInt.QuadPart = partitionTableOffset.QuadPart;
03269                         } <span class="keywordflow">else</span> {
03270                             tempInt.QuadPart = extendedPartitionOffset.QuadPart;
03271                         }
03272     
03273                         sectorOffset.QuadPart =
03274                             partitionTable-&gt;PartitionEntry[partitionEntryCount].StartingOffset.QuadPart -
03275                             tempInt.QuadPart;
03276     
03277                         tempInt.QuadPart = sectorOffset.QuadPart &gt;&gt; shiftCount;
03278                         partitionEntry[partitionEntryCount].StartingSector = tempInt.LowPart;
03279     
03280                         <span class="comment">//</span>
03281                         <span class="comment">// Calculate partition length.</span>
03282                         <span class="comment">//</span>
03283     
03284                         tempInt.QuadPart = partitionTable-&gt;PartitionEntry[partitionEntryCount].PartitionLength.QuadPart &gt;&gt; shiftCount;
03285                         partitionEntry[partitionEntryCount].PartitionLength = tempInt.LowPart;
03286     
03287                         <span class="comment">//</span>
03288                         <span class="comment">// Fill in CHS values</span>
03289                         <span class="comment">//</span>
03290     
03291                         <a class="code" href="../../d7/d2/drivesup_8c.html#a18">HalpCalculateChsValues</a>(
03292                             &amp;partitionTable-&gt;PartitionEntry[partitionEntryCount].StartingOffset,
03293                             &amp;partitionTable-&gt;PartitionEntry[partitionEntryCount].PartitionLength,
03294                             shiftCount,
03295                             SectorsPerTrack,
03296                             NumberOfHeads,
03297                             conventionalCylinders,
03298                             (<a class="code" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html">PPARTITION_DESCRIPTOR</a>) &amp;partitionEntry[partitionEntryCount]);
03299     
03300                     } <span class="keywordflow">else</span> {
03301     
03302                         <span class="comment">//</span>
03303                         <span class="comment">// Zero out partition entry fields in case an entry</span>
03304                         <span class="comment">// was deleted.</span>
03305                         <span class="comment">//</span>
03306     
03307                         partitionEntry[partitionEntryCount].StartingSector = 0;
03308                         partitionEntry[partitionEntryCount].PartitionLength = 0;
03309                         partitionEntry[partitionEntryCount].StartingTrack = 0;
03310                         partitionEntry[partitionEntryCount].EndingTrack = 0;
03311                         partitionEntry[partitionEntryCount].StartingCylinder = 0;
03312                         partitionEntry[partitionEntryCount].EndingCylinder = 0;
03313                     }
03314     
03315                 }
03316     
03317                 <span class="keywordflow">if</span> (IsContainerPartition(partitionType)) {
03318     
03319                     <span class="comment">//</span>
03320                     <span class="comment">// Save next record offset.</span>
03321                     <span class="comment">//</span>
03322     
03323                     nextRecordOffset =
03324                         partitionTable-&gt;PartitionEntry[partitionEntryCount].StartingOffset;
03325                 }
03326     
03327             } <span class="comment">// end for partitionEntryCount ...</span>
03328 
03329         } <span class="keywordflow">else</span> {
03330 
03331             <span class="comment">//</span>
03332             <span class="comment">// If there's an 0xaa55 in the MBR signature, clear it out.  </span>
03333             <span class="comment">//</span>
03334 
03335             <span class="comment">//</span>
03336             <span class="comment">// BUGBUG - don't do this.</span>
03337             <span class="comment">//</span>
03338 
03339             <span class="keywordflow">if</span>(writeBuffer[<a class="code" href="../../d2/d7/hal_8h.html#a11">BOOT_SIGNATURE_OFFSET</a>] == <a class="code" href="../../d2/d7/hal_8h.html#a12">BOOT_RECORD_SIGNATURE</a>) {
03340                 <span class="comment">// writeBuffer[BOOT_SIGNATURE_OFFSET] += 0x1111;</span>
03341             }
03342         }
03343     
03344         <span class="keywordflow">if</span> (rewritePartition == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
03345 
03346             rewritePartition = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03347 
03348             <span class="comment">//</span>
03349             <span class="comment">// Create a notification event object to be used while waiting for</span>
03350             <span class="comment">// the write request to complete.</span>
03351             <span class="comment">//</span>
03352 
03353             <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( &amp;event, NotificationEvent, FALSE );
03354 
03355             <span class="keywordflow">if</span> (foundEZHooker &amp;&amp; (partitionTableOffset.QuadPart == 0)) {
03356 
03357                 partitionTableOffset.QuadPart = 512;
03358 
03359             }
03360             irp = <a class="code" href="../../d4/d6/iosubs_8c.html#a27">IoBuildSynchronousFsdRequest</a>( IRP_MJ_WRITE,
03361                                             DeviceObject,
03362                                             writeBuffer,
03363                                             writeSize,
03364                                             &amp;partitionTableOffset,
03365                                             &amp;event,
03366                                             &amp;ioStatus );
03367 
03368             <span class="keywordflow">if</span> (!irp) {
03369                 status = STATUS_INSUFFICIENT_RESOURCES;
03370                 <span class="keywordflow">break</span>;
03371             } <span class="keywordflow">else</span> {
03372                 <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpStack;
03373                 irpStack = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>(irp);
03374                 irpStack-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o2">Flags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a203">SL_OVERRIDE_VERIFY_VOLUME</a>;
03375             }
03376 
03377             status = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>( DeviceObject, irp );
03378 
03379             <span class="keywordflow">if</span> (status == STATUS_PENDING) {
03380                 (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;event,
03381                                           Executive,
03382                                           KernelMode,
03383                                           FALSE,
03384                                           (PLARGE_INTEGER) NULL);
03385                 status = ioStatus.Status;
03386             }
03387 
03388             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
03389                 <span class="keywordflow">break</span>;
03390             }
03391 
03392 
03393             <span class="keywordflow">if</span> (foundEZHooker &amp;&amp; (partitionTableOffset.QuadPart == 512)) {
03394 
03395                 partitionTableOffset.QuadPart = 0;
03396 
03397             }
03398 
03399         } <span class="comment">// end if (reWrite ...</span>
03400 
03401         <span class="comment">//</span>
03402         <span class="comment">// Update partitionTableOffset to next boot record offset</span>
03403         <span class="comment">//</span>
03404 
03405         partitionTableOffset = nextRecordOffset;
03406         <span class="keywordflow">if</span>(mbr) {
03407             extendedPartitionOffset = nextRecordOffset;
03408         }
03409 
03410     } <span class="comment">// end for partitionTableCount ...</span>
03411 
03412     <span class="comment">//</span>
03413     <span class="comment">// Deallocate write buffer if it was allocated it.</span>
03414     <span class="comment">//</span>
03415 
03416     <span class="keywordflow">if</span> (writeBuffer != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03417         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( writeBuffer );
03418     }
03419 
03420     <span class="keywordflow">return</span> status;
03421 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a8" doxytag="haldisp.h::xHalLocateHiberRanges" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID xHalLocateHiberRanges           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>MemoryMap</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d6/halfnc_8c-source.html#l00169">169</a> of file <a class="el" href="../../d6/d6/halfnc_8c-source.html">halfnc.c</a>.
<p>
<pre class="fragment"><div>00172 {
00173 }
</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a27" doxytag="haldisp.h::xHalMapTransfer" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> PHYSICAL_ADDRESS xHalMapTransfer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d7/d6/struct__DMA__ADAPTER.html">PDMA_ADAPTER</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>DmaAdapter</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d6/d7/struct__MDL.html">PMDL</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>Mdl</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>MapRegisterBase</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>CurrentVa</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN OUT PULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Length</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN BOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>WriteToDevice</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a32" doxytag="haldisp.h::xHalpAllocateAdapterCallback" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="../../d0/d5/io_8h.html#a321">IO_ALLOCATION_ACTION</a> xHalpAllocateAdapterCallback           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN struct <a class="el" href="../../d8/d4/struct__DEVICE__OBJECT.html">_DEVICE_OBJECT</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>DeviceObject</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN struct <a class="el" href="../../d0/d2/struct__IRP.html">_IRP</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>Irp</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>MapRegisterBase</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>Context</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a20" doxytag="haldisp.h::xHalPutDmaAdapter" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID xHalPutDmaAdapter           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="../../d7/d6/struct__DMA__ADAPTER.html">PDMA_ADAPTER</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>DmaAdapter</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a31" doxytag="haldisp.h::xHalPutScatterGatherList" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID xHalPutScatterGatherList           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d7/d6/struct__DMA__ADAPTER.html">PDMA_ADAPTER</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>DmaAdapter</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d6/d8/struct__SCATTER__GATHER__LIST.html">PSCATTER_GATHER_LIST</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>ScatterGather</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN BOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>WriteToDevice</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="haldisp.h::xHalQueryBusSlots" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS xHalQueryBusSlots           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d6/d5/struct__BUS__HANDLER.html">PBUS_HANDLER</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>BusHandler</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>BufferSize</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>SlotNumbers</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>ReturnedLength</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d6/halfnc_8c-source.html#l00123">123</a> of file <a class="el" href="../../d6/d6/halfnc_8c-source.html">halfnc.c</a>.
<p>
References <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>.
<p>
<pre class="fragment"><div>00129 {
00130     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a> ();
00131     <span class="keywordflow">return</span> STATUS_NOT_SUPPORTED;
00132 }
</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="haldisp.h::xHalQuerySystemInformation" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS xHalQuerySystemInformation           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d2/d7/hal_8h.html#a79">HAL_QUERY_INFORMATION_CLASS</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>InformationClass</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>BufferSize</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>ReturnedLength</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d6/halfnc_8c-source.html#l00100">100</a> of file <a class="el" href="../../d6/d6/halfnc_8c-source.html">halfnc.c</a>.
<p>
References <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>.
<p>
<pre class="fragment"><div>00106 {
00107     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a> ();
00108     <span class="keywordflow">return</span> STATUS_INVALID_LEVEL;
00109 }
</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a29" doxytag="haldisp.h::xHalReadDmaCounter" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ULONG xHalReadDmaCounter           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d7/d6/struct__DMA__ADAPTER.html">PDMA_ADAPTER</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>DmaAdapter</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a16" doxytag="haldisp.h::xHalReferenceHandler" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID FASTCALL xHalReferenceHandler           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d6/d5/struct__BUS__HANDLER.html">PBUS_HANDLER</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>Handler</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d6/halfnc_8c-source.html#l00187">187</a> of file <a class="el" href="../../d6/d6/halfnc_8c-source.html">halfnc.c</a>.
<p>
<pre class="fragment"><div>00190 {
00191 }
</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a9" doxytag="haldisp.h::xHalRegisterBusHandler" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS xHalRegisterBusHandler           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN INTERFACE_TYPE&nbsp;</td>
          <td class="mdname" nowrap> <em>InterfaceType</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN BUS_DATA_TYPE&nbsp;</td>
          <td class="mdname" nowrap> <em>ConfigurationSpace</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>BusNumber</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN INTERFACE_TYPE&nbsp;</td>
          <td class="mdname" nowrap> <em>ParentBusType</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>ParentBusNumber</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>SizeofBusExtensionData</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d2/d7/hal_8h.html#a73">PINSTALL_BUS_HANDLER</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>InstallBusHandlers</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT <a class="el" href="../../d6/d5/struct__BUS__HANDLER.html">PBUS_HANDLER</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>BusHandler</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d6/halfnc_8c-source.html#l00136">136</a> of file <a class="el" href="../../d6/d6/halfnc_8c-source.html">halfnc.c</a>.
<p>
References <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>.
<p>
<pre class="fragment"><div>00146 {
00147     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a> ();
00148     <span class="keywordflow">return</span> STATUS_NOT_SUPPORTED;
00149 }
</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="haldisp.h::xHalSetSystemInformation" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS xHalSetSystemInformation           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d2/d7/hal_8h.html#a81">HAL_SET_INFORMATION_CLASS</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>InformationClass</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>BufferSize</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>Buffer</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d6/halfnc_8c-source.html#l00112">112</a> of file <a class="el" href="../../d6/d6/halfnc_8c-source.html">halfnc.c</a>.
<p>
References <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>.
<p>
<pre class="fragment"><div>00117 {
00118     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a> ();
00119     <span class="keywordflow">return</span> STATUS_INVALID_LEVEL;
00120 }
</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a7" doxytag="haldisp.h::xHalSetWakeAlarm" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID xHalSetWakeAlarm           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN ULONGLONG&nbsp;</td>
          <td class="mdname" nowrap> <em>WakeTime</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PTIME_FIELDS&nbsp;</td>
          <td class="mdname" nowrap> <em>WakeTimeFields</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d6/halfnc_8c-source.html#l00161">161</a> of file <a class="el" href="../../d6/d6/halfnc_8c-source.html">halfnc.c</a>.
<p>
<pre class="fragment"><div>00165 {
00166 }
</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="haldisp.h::xHalSetWakeEnable" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID xHalSetWakeEnable           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN BOOLEAN&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>Enable</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d6/halfnc_8c-source.html#l00153">153</a> of file <a class="el" href="../../d6/d6/halfnc_8c-source.html">halfnc.c</a>.
<p>
<pre class="fragment"><div>00156 {
00157 }
</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a34" doxytag="haldisp.h::xHalTranslateBusAddress" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> BOOLEAN xHalTranslateBusAddress           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN INTERFACE_TYPE&nbsp;</td>
          <td class="mdname" nowrap> <em>InterfaceType</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>BusNumber</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PHYSICAL_ADDRESS&nbsp;</td>
          <td class="mdname" nowrap> <em>BusAddress</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN OUT PULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>AddressSpace</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PPHYSICAL_ADDRESS&nbsp;</td>
          <td class="mdname" nowrap> <em>TranslatedAddress</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d6/halfnc_8c-source.html#l00866">866</a> of file <a class="el" href="../../d6/d6/halfnc_8c-source.html">halfnc.c</a>.
<p>
References <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, and <a class="el" href="../../d0/d1/bugcheck_8c-source.html#l00428">KeBugCheckEx()</a>.
<p>
<pre class="fragment"><div>00873 {
00874     <span class="comment">//</span>
00875     <span class="comment">// If the HAL fails to override this function, then</span>
00876     <span class="comment">// the HAL has clearly failed to initialize.</span>
00877     <span class="comment">//</span>
00878 
00879     <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a>(HAL_INITIALIZATION_FAILED, 0, 0, 0, 7);
00880     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00881 }
</div></pre>    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:43:55 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
