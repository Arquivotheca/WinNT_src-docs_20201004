<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: floatem.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>floatem.c</h1><a href="../../d3/d4/mips_2floatem_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1991  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    floatem.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module implements a software emulation of the IEEE single and</span>
00012 <span class="comment">    double floating operations. It is required on MIPS processors since</span>
00013 <span class="comment">    the hardware does not fully support all of the operations required</span>
00014 <span class="comment">    by the IEEE standard. In particular, infinitives and Nans are not</span>
00015 <span class="comment">    handled by the hardware, but rather cause an exception. On receipt</span>
00016 <span class="comment">    of the exception, a software emulation of the floating operation</span>
00017 <span class="comment">    is performed to determine the real result of the operation and if</span>
00018 <span class="comment">    an exception will actually be raised.</span>
00019 <span class="comment"></span>
00020 <span class="comment">    Since floating exceptions are rather rare events, this routine is</span>
00021 <span class="comment">    written in C. Should a higher performance implementation be required,</span>
00022 <span class="comment">    then the algorithms contained herein, can be used to guide a higher</span>
00023 <span class="comment">    performance assembly language implementation.</span>
00024 <span class="comment"></span>
00025 <span class="comment">    N.B. This routine does not emulate floating loads, floating stores,</span>
00026 <span class="comment">        control to/from floating, or move to/from floating instructions.</span>
00027 <span class="comment">        These instructions either do not fault or are emulated elsewhere.</span>
00028 <span class="comment"></span>
00029 <span class="comment">    Floating point operations are carried out by unpacking the operands,</span>
00030 <span class="comment">    normalizing denormalized numbers, checking for NaNs, interpreting</span>
00031 <span class="comment">    infinities, and computing results.</span>
00032 <span class="comment"></span>
00033 <span class="comment">    Floating operands are converted to a format that has a value with the</span>
00034 <span class="comment">    appropriate number of leading zeros, an overflow bit, the mantissa, a</span>
00035 <span class="comment">    guard bit, a round bit, and a set of sticky bits.</span>
00036 <span class="comment"></span>
00037 <span class="comment">    The overflow bit is needed for addition and is also used for multiply.</span>
00038 <span class="comment">    The mantissa is 24-bits for single operations and 53-bits for double</span>
00039 <span class="comment">    operations. The guard bit and round bit are used to hold precise values</span>
00040 <span class="comment">    for normalization and rounding.</span>
00041 <span class="comment"></span>
00042 <span class="comment">    If the result of an operation is normalized, then the guard bit becomes</span>
00043 <span class="comment">    the round bit and the round bit is accumulated with the sticky bits. If</span>
00044 <span class="comment">    the result of an operation needs to be shifted left one bit for purposes</span>
00045 <span class="comment">    of nomalization, then the guard bit becomes part of the mantissa and the</span>
00046 <span class="comment">    round bit is used for rounding.</span>
00047 <span class="comment"></span>
00048 <span class="comment">    The round bit plus the sticky bits are used to determine how rounding is</span>
00049 <span class="comment">    performed.</span>
00050 <span class="comment"></span>
00051 <span class="comment">Author:</span>
00052 <span class="comment"></span>
00053 <span class="comment">    David N. Cutler (davec) 16-Jun-1991</span>
00054 <span class="comment"></span>
00055 <span class="comment">Environment:</span>
00056 <span class="comment"></span>
00057 <span class="comment">    Kernel mode only.</span>
00058 <span class="comment"></span>
00059 <span class="comment">Revision History:</span>
00060 <span class="comment"></span>
00061 <span class="comment">--*/</span>
00062 
00063 <span class="preprocessor">#include "<a class="code" href="../../d0/d0/ki_8h.html">ki.h</a>"</span>
00064 
00065 <span class="comment">//</span>
00066 <span class="comment">// Define signaling NaN mask values.</span>
00067 <span class="comment">//</span>
00068 
<a name="l00069"></a><a class="code" href="../../d3/d4/mips_2floatem_8c.html#a0">00069</a> <span class="preprocessor">#define DOUBLE_SIGNAL_NAN_MASK (1 &lt;&lt; (53 - 32))</span>
<a name="l00070"></a><a class="code" href="../../d3/d4/mips_2floatem_8c.html#a1">00070</a> <span class="preprocessor"></span><span class="preprocessor">#define SINGLE_SIGNAL_NAN_MASK (1 &lt;&lt; 24)</span>
00071 <span class="preprocessor"></span>
00072 <span class="comment">//</span>
00073 <span class="comment">// Define quite NaN mask values.</span>
00074 <span class="comment">//</span>
00075 
<a name="l00076"></a><a class="code" href="../../d3/d4/mips_2floatem_8c.html#a2">00076</a> <span class="preprocessor">#define DOUBLE_QUIET_NAN_MASK (1 &lt;&lt; (51 - 32))</span>
<a name="l00077"></a><a class="code" href="../../d3/d4/mips_2floatem_8c.html#a3">00077</a> <span class="preprocessor"></span><span class="preprocessor">#define SINGLE_QUIET_NAN_MASK (1 &lt;&lt; 22)</span>
00078 <span class="preprocessor"></span>
00079 <span class="comment">//</span>
00080 <span class="comment">// Define quiet NaN prefix values.</span>
00081 <span class="comment">//</span>
00082 
<a name="l00083"></a><a class="code" href="../../d3/d4/mips_2floatem_8c.html#a4">00083</a> <span class="preprocessor">#define DOUBLE_QUIET_NAN_PREFIX 0x7ff00000</span>
<a name="l00084"></a><a class="code" href="../../d3/d4/mips_2floatem_8c.html#a5">00084</a> <span class="preprocessor"></span><span class="preprocessor">#define SINGLE_QUIET_NAN_PREFIX 0x7f800000</span>
00085 <span class="preprocessor"></span>
00086 <span class="comment">//</span>
00087 <span class="comment">// Define compare function masks.</span>
00088 <span class="comment">//</span>
00089 
<a name="l00090"></a><a class="code" href="../../d3/d4/mips_2floatem_8c.html#a6">00090</a> <span class="preprocessor">#define COMPARE_UNORDERED_MASK (1 &lt;&lt; 0)</span>
<a name="l00091"></a><a class="code" href="../../d3/d4/mips_2floatem_8c.html#a7">00091</a> <span class="preprocessor"></span><span class="preprocessor">#define COMPARE_EQUAL_MASK (1 &lt;&lt; 1)</span>
<a name="l00092"></a><a class="code" href="../../d3/d4/mips_2floatem_8c.html#a8">00092</a> <span class="preprocessor"></span><span class="preprocessor">#define COMPARE_LESS_MASK (1 &lt;&lt; 2)</span>
<a name="l00093"></a><a class="code" href="../../d3/d4/mips_2floatem_8c.html#a9">00093</a> <span class="preprocessor"></span><span class="preprocessor">#define COMPARE_ORDERED_MASK (1 &lt;&lt; 3)</span>
00094 <span class="preprocessor"></span>
00095 <span class="comment">//</span>
00096 <span class="comment">// Define context block structure.</span>
00097 <span class="comment">//</span>
00098 
00099 <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html">_FP_CONTEXT_BLOCK</a> {
<a name="l00100"></a><a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o8">00100</a>     ULONG <a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o8">Fd</a>;
<a name="l00101"></a><a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o9">00101</a>     ULONG <a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o9">BranchAddress</a>;
<a name="l00102"></a><a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o1">00102</a>     PEXCEPTION_RECORD <a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o1">ExceptionRecord</a>;
<a name="l00103"></a><a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o2">00103</a>     PKEXCEPTION_FRAME <a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o2">ExceptionFrame</a>;
<a name="l00104"></a><a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o3">00104</a>     PKTRAP_FRAME <a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o3">TrapFrame</a>;
<a name="l00105"></a><a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o5">00105</a>     ULONG <a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o5">Round</a>;
00106 } <a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html">FP_CONTEXT_BLOCK</a>, *<a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html">PFP_CONTEXT_BLOCK</a>;
00107 
00108 <span class="comment">//</span>
00109 <span class="comment">// Define single and double operand value structures.</span>
00110 <span class="comment">//</span>
00111 
00112 <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html">_FP_DOUBLE_OPERAND</a> {
00113     <span class="keyword">union </span>{
00114         <span class="keyword">struct </span>{
<a name="l00115"></a><a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">00115</a>             ULONG <a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a>;
<a name="l00116"></a><a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">00116</a>             LONG <a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a>;
00117         };
00118 
<a name="l00119"></a><a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o2">00119</a>         LONGLONG <a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o2">Mantissa</a>;
00120     };
00121 
<a name="l00122"></a><a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">00122</a>     LONG <a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a>;
<a name="l00123"></a><a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">00123</a>     LONG <a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a>;
<a name="l00124"></a><a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o5">00124</a>     BOOLEAN <a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o5">Infinity</a>;
<a name="l00125"></a><a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o6">00125</a>     BOOLEAN <a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o6">Nan</a>;
00126 } <a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html">FP_DOUBLE_OPERAND</a>, *<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html">PFP_DOUBLE_OPERAND</a>;
00127 
00128 <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html">_FP_SINGLE_OPERAND</a> {
<a name="l00129"></a><a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">00129</a>     LONG <a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a>;
<a name="l00130"></a><a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">00130</a>     LONG <a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">Exponent</a>;
<a name="l00131"></a><a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">00131</a>     LONG <a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a>;
<a name="l00132"></a><a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o3">00132</a>     BOOLEAN <a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o3">Infinity</a>;
<a name="l00133"></a><a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o4">00133</a>     BOOLEAN <a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o4">Nan</a>;
00134 } <a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html">FP_SINGLE_OPERAND</a>, *<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html">PFP_SINGLE_OPERAND</a>;
00135 
00136 <span class="comment">//</span>
00137 <span class="comment">// Define forward referenced function protypes.</span>
00138 <span class="comment">//</span>
00139 
00140 BOOLEAN
00141 <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a16">KiDivideByZeroDouble</a> (
00142     IN PFP_CONTEXT_BLOCK ContextBlock,
00143     IN PFP_DOUBLE_OPERAND DoubleOperand1,
00144     IN PFP_DOUBLE_OPERAND DoubleOperand2
00145     );
00146 
00147 BOOLEAN
00148 <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a17">KiDivideByZeroSingle</a> (
00149     IN PFP_CONTEXT_BLOCK ContextBlock,
00150     IN PFP_SINGLE_OPERAND SingleOperand1,
00151     IN PFP_SINGLE_OPERAND SingleOperand2
00152     );
00153 
00154 BOOLEAN
00155 <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a18">KiInvalidCompareDouble</a> (
00156     IN PFP_CONTEXT_BLOCK ContextBlock,
00157     IN BOOLEAN CheckForNan,
00158     IN PFP_DOUBLE_OPERAND DoubleOperand1,
00159     IN PFP_DOUBLE_OPERAND DoubleOperand2
00160     );
00161 
00162 BOOLEAN
00163 <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a19">KiInvalidCompareSingle</a> (
00164     IN PFP_CONTEXT_BLOCK ContextBlock,
00165     IN BOOLEAN CheckForNan,
00166     IN PFP_SINGLE_OPERAND SingleOperand1,
00167     IN PFP_SINGLE_OPERAND SingleOperand2
00168     );
00169 
00170 BOOLEAN
00171 <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a20">KiInvalidOperationDouble</a> (
00172     IN PFP_CONTEXT_BLOCK ContextBlock,
00173     IN BOOLEAN CheckForNan,
00174     IN PFP_DOUBLE_OPERAND DoubleOperand1,
00175     IN PFP_DOUBLE_OPERAND DoubleOperand2
00176     );
00177 
00178 BOOLEAN
00179 <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a21">KiInvalidOperationLongword</a> (
00180     IN PFP_CONTEXT_BLOCK ContextBlock,
00181     IN BOOLEAN Infinity,
00182     IN LONG Sign
00183     );
00184 
00185 BOOLEAN
00186 <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a22">KiInvalidOperationQuadword</a> (
00187     IN PFP_CONTEXT_BLOCK ContextBlock,
00188     IN BOOLEAN Infinity,
00189     IN LONG Sign
00190     );
00191 
00192 BOOLEAN
00193 <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a23">KiInvalidOperationSingle</a> (
00194     IN PFP_CONTEXT_BLOCK ContextBlock,
00195     IN BOOLEAN CheckForNan,
00196     IN PFP_SINGLE_OPERAND SingleOperand1,
00197     IN PFP_SINGLE_OPERAND SingleOperand2
00198     );
00199 
00200 BOOLEAN
00201 <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a24">KiNormalizeDouble</a> (
00202     IN PFP_CONTEXT_BLOCK ContextBlock,
00203     IN PFP_DOUBLE_OPERAND ResultOperand,
00204     IN ULONG StickyBits
00205     );
00206 
00207 BOOLEAN
00208 <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a25">KiNormalizeLongword</a> (
00209     IN PFP_CONTEXT_BLOCK ContextBlock,
00210     IN PFP_DOUBLE_OPERAND ResultOperand
00211     );
00212 
00213 BOOLEAN
00214 <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a26">KiNormalizeQuadword</a> (
00215     IN PFP_CONTEXT_BLOCK ContextBlock,
00216     IN PFP_DOUBLE_OPERAND ResultOperand
00217     );
00218 
00219 BOOLEAN
00220 <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a27">KiNormalizeSingle</a> (
00221     IN PFP_CONTEXT_BLOCK ContextBlock,
00222     IN PFP_SINGLE_OPERAND ResultOperand,
00223     IN ULONG StickyBits
00224     );
00225 
00226 ULONG
00227 <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a28">KiSquareRootDouble</a> (
00228     IN PULARGE_INTEGER DoubleValue
00229     );
00230 
00231 ULONG
00232 <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a29">KiSquareRootSingle</a> (
00233     IN PULONG SingleValue
00234     );
00235 
00236 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00237 <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a30">KiUnpackDouble</a> (
00238     IN ULONG Source,
00239     IN PFP_CONTEXT_BLOCK ContextBlock,
00240     OUT PFP_DOUBLE_OPERAND DoubleOperand
00241     );
00242 
00243 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00244 <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a31">KiUnpackSingle</a> (
00245     IN ULONG Source,
00246     IN PFP_CONTEXT_BLOCK ContextBlock,
00247     OUT PFP_SINGLE_OPERAND SingleOperand
00248     );
00249 
00250 BOOLEAN
<a name="l00251"></a><a class="code" href="../../d3/d4/mips_2floatem_8c.html#a32">00251</a> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a32">KiEmulateFloating</a> (
00252     IN OUT PEXCEPTION_RECORD ExceptionRecord,
00253     IN OUT PKEXCEPTION_FRAME ExceptionFrame,
00254     IN OUT PKTRAP_FRAME TrapFrame
00255     )
00256 
00257 <span class="comment">/*++</span>
00258 <span class="comment"></span>
00259 <span class="comment">Routine Description:</span>
00260 <span class="comment"></span>
00261 <span class="comment">    This function is called to emulate a floating operation and convert the</span>
00262 <span class="comment">    exception status to the proper value. If the exception is an unimplemented</span>
00263 <span class="comment">    operation, then the operation is emulated. Otherwise, the status code is</span>
00264 <span class="comment">    just converted to its proper value.</span>
00265 <span class="comment"></span>
00266 <span class="comment">Arguments:</span>
00267 <span class="comment"></span>
00268 <span class="comment">    ExceptionRecord - Supplies a pointer to an exception record.</span>
00269 <span class="comment"></span>
00270 <span class="comment">    ExceptionFrame - Supplies a pointer to an exception frame.</span>
00271 <span class="comment"></span>
00272 <span class="comment">    TrapFrame - Supplies a pointer to a trap frame.</span>
00273 <span class="comment"></span>
00274 <span class="comment">Return Value:</span>
00275 <span class="comment"></span>
00276 <span class="comment">    A value of TRUE is returned if the floating exception is successfully</span>
00277 <span class="comment">    emulated. Otherwise, a value of FALSE is returned.</span>
00278 <span class="comment"></span>
00279 <span class="comment">--*/</span>
00280 
00281 {
00282 
00283     ULARGE_INTEGER AhighBhigh;
00284     ULARGE_INTEGER AhighBlow;
00285     ULARGE_INTEGER AlowBhigh;
00286     ULARGE_INTEGER AlowBlow;
00287     ULONG Carry1;
00288     ULONG Carry2;
00289     BOOLEAN CompareEqual;
00290     ULONG CompareFunction;
00291     BOOLEAN CompareLess;
00292     <a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html">FP_CONTEXT_BLOCK</a> ContextBlock;
00293     LARGE_INTEGER DoubleDividend;
00294     LARGE_INTEGER DoubleDivisor;
00295     ULARGE_INTEGER DoubleValue;
00296     ULONG DoubleMantissaLow;
00297     LONG DoubleMantissaHigh;
00298     <a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html">FP_DOUBLE_OPERAND</a> DoubleOperand1;
00299     <a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html">FP_DOUBLE_OPERAND</a> DoubleOperand2;
00300     <a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html">FP_DOUBLE_OPERAND</a> DoubleOperand3;
00301     LARGE_INTEGER DoubleQuotient;
00302     PVOID ExceptionAddress;
00303     ULONG ExponentDifference;
00304     ULONG ExponentSum;
00305     ULONG Format;
00306     ULONG Fs;
00307     ULONG Ft;
00308     ULONG Function;
00309     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
00310     MIPS_INSTRUCTION Instruction;
00311     ULARGE_INTEGER LargeResult;
00312     LONG Longword;
00313     LONG Negation;
00314     <span class="keyword">union </span>{
00315         LONGLONG Quadword;
00316         LARGE_INTEGER LargeValue;
00317     }u;
00318 
00319     LONG SingleMantissa;
00320     <a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html">FP_SINGLE_OPERAND</a> SingleOperand1;
00321     <a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html">FP_SINGLE_OPERAND</a> SingleOperand2;
00322     <a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html">FP_SINGLE_OPERAND</a> SingleOperand3;
00323     ULONG SingleValue;
00324     ULONG StickyBits;
00325 
00326     <span class="comment">//</span>
00327     <span class="comment">// Save the original exception address in case another exception</span>
00328     <span class="comment">// occurs.</span>
00329     <span class="comment">//</span>
00330 
00331     ExceptionAddress = ExceptionRecord-&gt;ExceptionAddress;
00332 
00333     <span class="comment">//</span>
00334     <span class="comment">// Any exception that occurs during the attempted emulation of the</span>
00335     <span class="comment">// floating operation causes the emulation to be aborted. The new</span>
00336     <span class="comment">// exception code and information is copied to the original exception</span>
00337     <span class="comment">// record and a value of FALSE is returned.</span>
00338     <span class="comment">//</span>
00339 
00340     <span class="keywordflow">try</span> {
00341 
00342         <span class="comment">//</span>
00343         <span class="comment">// If the exception PC is equal to the fault instruction address</span>
00344         <span class="comment">// plus four, then the floating exception occurred in the delay</span>
00345         <span class="comment">// slot of a branch instruction and the continuation address must</span>
00346         <span class="comment">// be computed by emulating the branch instruction. Note that it</span>
00347         <span class="comment">// is possible for an exception to occur when the branch instruction</span>
00348         <span class="comment">// is read from user memory.</span>
00349         <span class="comment">//</span>
00350 
00351         <span class="keywordflow">if</span> ((TrapFrame-&gt;Fir + 4) == (ULONG)ExceptionRecord-&gt;ExceptionAddress) {
00352             ContextBlock.<a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o9">BranchAddress</a> = <a class="code" href="../../d7/d1/branchem_8c.html#a0">KiEmulateBranch</a>(ExceptionFrame,
00353                                                          TrapFrame);
00354 
00355         } <span class="keywordflow">else</span> {
00356             ContextBlock.<a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o9">BranchAddress</a> = TrapFrame-&gt;Fir + 4;
00357         }
00358 
00359         <span class="comment">//</span>
00360         <span class="comment">// Increment the floating emulation count.</span>
00361         <span class="comment">//</span>
00362 
00363         <a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a2">KeGetCurrentPrcb</a>()-&gt;KeFloatingEmulationCount += 1;
00364 
00365         <span class="comment">//</span>
00366         <span class="comment">// Initialize the address of the exception record, exception frame,</span>
00367         <span class="comment">// and trap frame in the context block used during the emulation of</span>
00368         <span class="comment">// the floating point operation.</span>
00369         <span class="comment">//</span>
00370 
00371         ContextBlock.<a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o1">ExceptionRecord</a> = ExceptionRecord;
00372         ContextBlock.<a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o2">ExceptionFrame</a> = ExceptionFrame;
00373         ContextBlock.<a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o3">TrapFrame</a> = TrapFrame;
00374         ContextBlock.<a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o5">Round</a> = ((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;RM;
00375 
00376         <span class="comment">//</span>
00377         <span class="comment">// Initialize the number of exception information parameters, set</span>
00378         <span class="comment">// the branch address, and clear the IEEE exception value.</span>
00379         <span class="comment">//</span>
00380 
00381         ExceptionRecord-&gt;NumberParameters = 6;
00382         ExceptionRecord-&gt;ExceptionInformation[0] = 0;
00383         ExceptionRecord-&gt;ExceptionInformation[1] = ContextBlock.<a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o9">BranchAddress</a>;
00384         ExceptionRecord-&gt;ExceptionInformation[2] = 0;
00385         ExceptionRecord-&gt;ExceptionInformation[3] = 0;
00386         ExceptionRecord-&gt;ExceptionInformation[4] = 0;
00387         ExceptionRecord-&gt;ExceptionInformation[5] = 0;
00388 
00389         <span class="comment">//</span>
00390         <span class="comment">// Clear all exception flags and emulate the floating point operation</span>
00391         <span class="comment">// The return value is dependent on the results of the emulation.</span>
00392         <span class="comment">//</span>
00393 
00394         TrapFrame-&gt;Fsr &amp;= ~(0x3f &lt;&lt; 12);
00395         Instruction = *((PMIPS_INSTRUCTION)ExceptionRecord-&gt;ExceptionAddress);
00396         Function = Instruction.c_format.Function;
00397         ContextBlock.<a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o8">Fd</a> = Instruction.c_format.Fd;
00398         Fs = Instruction.c_format.Fs;
00399         Ft = Instruction.c_format.Ft;
00400         Format = Instruction.c_format.Format;
00401         Negation = 0;
00402 
00403         <span class="comment">//</span>
00404         <span class="comment">// Check for illegal register specification or format code.</span>
00405         <span class="comment">//</span>
00406 
00407         <span class="keywordflow">if</span> (((ContextBlock.<a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o8">Fd</a> &amp; 0x1) != 0) || ((Fs &amp; 0x1) != 0) || ((Ft &amp; 0x1) != 0) ||
00408             ((Format != FORMAT_LONGWORD) &amp;&amp; (Format != FORMAT_QUADWORD) &amp;&amp; (Format &gt; FORMAT_DOUBLE))) {
00409             Function = FLOAT_ILLEGAL;
00410         }
00411 
00412         <span class="comment">//</span>
00413         <span class="comment">// Decode operand values and dispose with NaNs.</span>
00414         <span class="comment">//</span>
00415 
00416         <span class="keywordflow">if</span> ((Function &lt;= FLOAT_DIVIDE) || (Function &gt;= FLOAT_COMPARE)) {
00417 
00418             <span class="comment">//</span>
00419             <span class="comment">// The function has two operand values.</span>
00420             <span class="comment">//</span>
00421 
00422             <span class="keywordflow">if</span> (Format == FORMAT_SINGLE) {
00423                 <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a31">KiUnpackSingle</a>(Fs, &amp;ContextBlock, &amp;SingleOperand1);
00424                 <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a31">KiUnpackSingle</a>(Ft, &amp;ContextBlock, &amp;SingleOperand2);
00425 
00426                 <span class="comment">//</span>
00427                 <span class="comment">// If either operand is a NaN, then check to determine if a</span>
00428                 <span class="comment">// compare instruction or other dyadic operation is being</span>
00429                 <span class="comment">// performed.</span>
00430                 <span class="comment">//</span>
00431 
00432                 <span class="keywordflow">if</span> ((SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o4">Nan</a> != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) || (SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o4">Nan</a> != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>)) {
00433                     <span class="keywordflow">if</span> (Function &lt; FLOAT_COMPARE) {
00434 
00435                         <span class="comment">//</span>
00436                         <span class="comment">// Dyadic operation.</span>
00437                         <span class="comment">//</span>
00438                         <span class="comment">// Store a quite Nan if the invalid operation trap</span>
00439                         <span class="comment">// is disabled, or raise an exception if the invalid</span>
00440                         <span class="comment">// operation trap is enabled and either of the NaNs</span>
00441                         <span class="comment">// is a signally NaN.</span>
00442                         <span class="comment">//</span>
00443 
00444                         <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a23">KiInvalidOperationSingle</a>(&amp;ContextBlock,
00445                                                         <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
00446                                                         &amp;SingleOperand1,
00447                                                         &amp;SingleOperand2);
00448 
00449                     } <span class="keywordflow">else</span> {
00450 
00451                         <span class="comment">//</span>
00452                         <span class="comment">// Compare operation.</span>
00453                         <span class="comment">//</span>
00454                         <span class="comment">// Set the condition based on the predicate of</span>
00455                         <span class="comment">// the floating comparison.</span>
00456                         <span class="comment">//</span>
00457                         <span class="comment">// If the compare is a signaling compare, then</span>
00458                         <span class="comment">// raise an exception if the invalid operation</span>
00459                         <span class="comment">// trap is enabled. Otherwise, raise an exception</span>
00460                         <span class="comment">// if one of the operands is a signaling NaN.</span>
00461                         <span class="comment">//</span>
00462 
00463                         <span class="keywordflow">if</span> ((Function &amp; <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a6">COMPARE_UNORDERED_MASK</a>) != 0) {
00464                             ((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;CC = 1;
00465 
00466                         } <span class="keywordflow">else</span> {
00467                             ((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;CC = 0;
00468                         }
00469 
00470                         <span class="keywordflow">if</span> ((Function &amp; <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a9">COMPARE_ORDERED_MASK</a>) != 0) {
00471                             <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a19">KiInvalidCompareSingle</a>(&amp;ContextBlock,
00472                                                           <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00473                                                           &amp;SingleOperand1,
00474                                                           &amp;SingleOperand2);
00475 
00476                         } <span class="keywordflow">else</span> {
00477                             <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a19">KiInvalidCompareSingle</a>(&amp;ContextBlock,
00478                                                           <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
00479                                                           &amp;SingleOperand1,
00480                                                           &amp;SingleOperand2);
00481 
00482                         }
00483                     }
00484 
00485                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Function &gt;= FLOAT_COMPARE) {
00486                     CompareFunction = Function;
00487                     Function = FLOAT_COMPARE_SINGLE;
00488                 }
00489 
00490             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Format == FORMAT_DOUBLE) {
00491                 <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a30">KiUnpackDouble</a>(Fs, &amp;ContextBlock, &amp;DoubleOperand1);
00492                 <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a30">KiUnpackDouble</a>(Ft, &amp;ContextBlock, &amp;DoubleOperand2);
00493 
00494                 <span class="comment">//</span>
00495                 <span class="comment">// If either operand is a NaN, then check to determine if a</span>
00496                 <span class="comment">// compare instruction or other dyadic operation is being</span>
00497                 <span class="comment">// performed.</span>
00498                 <span class="comment">//</span>
00499 
00500                 <span class="keywordflow">if</span> ((DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o6">Nan</a> != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) || (DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o6">Nan</a> != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>)) {
00501                     <span class="keywordflow">if</span> (Function &lt; FLOAT_COMPARE) {
00502 
00503                         <span class="comment">//</span>
00504                         <span class="comment">// Dyadic operation.</span>
00505                         <span class="comment">//</span>
00506                         <span class="comment">// Store a quite Nan if the invalid operation trap</span>
00507                         <span class="comment">// is disabled, or raise an exception if the invalid</span>
00508                         <span class="comment">// operation trap is enabled and either of the NaNs</span>
00509                         <span class="comment">// is a signally NaN.</span>
00510                         <span class="comment">//</span>
00511 
00512                         <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a20">KiInvalidOperationDouble</a>(&amp;ContextBlock,
00513                                                         <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
00514                                                         &amp;DoubleOperand1,
00515                                                         &amp;DoubleOperand2);
00516 
00517                     } <span class="keywordflow">else</span> {
00518 
00519                         <span class="comment">//</span>
00520                         <span class="comment">// Compare operation.</span>
00521                         <span class="comment">//</span>
00522                         <span class="comment">// Set the condition based on the predicate of</span>
00523                         <span class="comment">// the floating comparison.</span>
00524                         <span class="comment">//</span>
00525                         <span class="comment">// If the compare is a signaling compare, then</span>
00526                         <span class="comment">// raise an exception if the invalid operation</span>
00527                         <span class="comment">// trap is enabled. Othersie, raise an exception</span>
00528                         <span class="comment">// if one of the operands is a signaling NaN.</span>
00529                         <span class="comment">//</span>
00530 
00531                         <span class="keywordflow">if</span> ((Function &amp; <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a6">COMPARE_UNORDERED_MASK</a>) != 0) {
00532                             ((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;CC = 1;
00533 
00534                         } <span class="keywordflow">else</span> {
00535                             ((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;CC = 0;
00536                         }
00537 
00538                         <span class="keywordflow">if</span> ((Function &amp; <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a9">COMPARE_ORDERED_MASK</a>) != 0) {
00539                             <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a18">KiInvalidCompareDouble</a>(&amp;ContextBlock,
00540                                                           <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00541                                                           &amp;DoubleOperand1,
00542                                                           &amp;DoubleOperand2);
00543 
00544                         } <span class="keywordflow">else</span> {
00545                             <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a18">KiInvalidCompareDouble</a>(&amp;ContextBlock,
00546                                                           <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
00547                                                           &amp;DoubleOperand1,
00548                                                           &amp;DoubleOperand2);
00549 
00550                         }
00551                     }
00552 
00553                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Function &gt;= FLOAT_COMPARE) {
00554                     CompareFunction = Function;
00555                     Function = FLOAT_COMPARE_DOUBLE;
00556                 }
00557 
00558             } <span class="keywordflow">else</span> {
00559                 Function = FLOAT_ILLEGAL;
00560             }
00561 
00562         } <span class="keywordflow">else</span> {
00563 
00564             <span class="comment">//</span>
00565             <span class="comment">// The function has one operand value.</span>
00566             <span class="comment">//</span>
00567 
00568             <span class="keywordflow">if</span> (Format == FORMAT_SINGLE) {
00569                 <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a31">KiUnpackSingle</a>(Fs, &amp;ContextBlock, &amp;SingleOperand1);
00570 
00571                 <span class="comment">//</span>
00572                 <span class="comment">// If the operand is a NaN and the function is not a convert</span>
00573                 <span class="comment">// operation, then store a quiet NaN if the invalid operation</span>
00574                 <span class="comment">// trap is disabled, or raise an exception if the invalid</span>
00575                 <span class="comment">// operation trap is enabled and the operand is a signaling</span>
00576                 <span class="comment">// NaN.</span>
00577                 <span class="comment">//</span>
00578 
00579                 <span class="keywordflow">if</span> ((SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o4">Nan</a> != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
00580                     (Function &lt; FLOAT_ROUND_QUADWORD) ||
00581                     (Function &gt; FLOAT_CONVERT_QUADWORD) ||
00582                     ((Function &gt; FLOAT_FLOOR_LONGWORD) &amp;&amp;
00583                     (Function &lt; FLOAT_CONVERT_SINGLE))) {
00584                     <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a23">KiInvalidOperationSingle</a>(&amp;ContextBlock,
00585                                                     <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
00586                                                     &amp;SingleOperand1,
00587                                                     &amp;SingleOperand1);
00588 
00589                 }
00590 
00591             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Format == FORMAT_DOUBLE) {
00592                 <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a30">KiUnpackDouble</a>(Fs, &amp;ContextBlock, &amp;DoubleOperand1);
00593 
00594                 <span class="comment">//</span>
00595                 <span class="comment">// If the operand is a NaN and the function is not a convert</span>
00596                 <span class="comment">// operation, then store a quiet NaN if the invalid operation</span>
00597                 <span class="comment">// trap is disabled, or raise an exception if the invalid</span>
00598                 <span class="comment">// operation trap is enabled and the operand is a signaling</span>
00599                 <span class="comment">// NaN.</span>
00600                 <span class="comment">//</span>
00601 
00602                 <span class="keywordflow">if</span> ((DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o6">Nan</a> != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
00603                     (Function &lt; FLOAT_ROUND_QUADWORD) ||
00604                     (Function &gt; FLOAT_CONVERT_QUADWORD) ||
00605                     ((Function &gt; FLOAT_FLOOR_LONGWORD) &amp;&amp;
00606                     (Function &lt; FLOAT_CONVERT_SINGLE))) {
00607                     <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a20">KiInvalidOperationDouble</a>(&amp;ContextBlock,
00608                                                     <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
00609                                                     &amp;DoubleOperand1,
00610                                                     &amp;DoubleOperand1);
00611                 }
00612 
00613             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((Format == FORMAT_LONGWORD) &amp;&amp;
00614                        (Function &gt;= FLOAT_CONVERT_SINGLE)) {
00615                 Longword = <a class="code" href="../../d8/d5/ppc_2getsetrg_8c.html#a0">KiGetRegisterValue</a>(Fs + 32,
00616                                               ContextBlock.<a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o2">ExceptionFrame</a>,
00617                                               ContextBlock.<a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o3">TrapFrame</a>);
00618 
00619             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((Format == FORMAT_QUADWORD) &amp;&amp;
00620                        (Function &gt;= FLOAT_CONVERT_SINGLE)) {
00621                 u.LargeValue.LowPart = <a class="code" href="../../d8/d5/ppc_2getsetrg_8c.html#a0">KiGetRegisterValue</a>(Fs + 32,
00622                                                           ContextBlock.<a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o2">ExceptionFrame</a>,
00623                                                           ContextBlock.<a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o3">TrapFrame</a>);
00624 
00625                 u.LargeValue.HighPart = <a class="code" href="../../d8/d5/ppc_2getsetrg_8c.html#a0">KiGetRegisterValue</a>(Fs + 33,
00626                                                            ContextBlock.<a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o2">ExceptionFrame</a>,
00627                                                            ContextBlock.<a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o3">TrapFrame</a>);
00628 
00629             } <span class="keywordflow">else</span> {
00630                 Function = FLOAT_ILLEGAL;
00631             }
00632         }
00633 
00634         <span class="comment">//</span>
00635         <span class="comment">// Case to the proper function routine to emulate the operation.</span>
00636         <span class="comment">//</span>
00637 
00638         <span class="keywordflow">switch</span> (Function) {
00639 
00640             <span class="comment">//</span>
00641             <span class="comment">// Floating subtract operation.</span>
00642             <span class="comment">//</span>
00643             <span class="comment">// Floating subtract is accomplished by complementing the sign</span>
00644             <span class="comment">// of the second operand and then performing an add operation.</span>
00645             <span class="comment">//</span>
00646 
00647         <span class="keywordflow">case</span> FLOAT_SUBTRACT:
00648             Negation = 0x1;
00649 
00650             <span class="comment">//</span>
00651             <span class="comment">// Floating add operation.</span>
00652             <span class="comment">//</span>
00653             <span class="comment">// Floating add is accomplished using signed magnitude addition.</span>
00654             <span class="comment">//</span>
00655             <span class="comment">// The exponent difference is calculated and the smaller number</span>
00656             <span class="comment">// is right shifted by the specified amount, but no more than</span>
00657             <span class="comment">// the width of the operand values (i.e., 26 for single and 55</span>
00658             <span class="comment">// for double). The shifted out value is saved for rounding.</span>
00659             <span class="comment">//</span>
00660             <span class="comment">// If the signs of the two operands are the same, then they</span>
00661             <span class="comment">// are added together after having performed the alignment</span>
00662             <span class="comment">// shift.</span>
00663             <span class="comment">//</span>
00664             <span class="comment">// If the signs of the two operands are different, then the</span>
00665             <span class="comment">// sign of the result is the sign of the larger operand and</span>
00666             <span class="comment">// the smaller operand is subtracted from the larger operand.</span>
00667             <span class="comment">// In order to avoid making a double level test (i.e., one on</span>
00668             <span class="comment">// the exponents, and one on the mantissas if the exponents</span>
00669             <span class="comment">// are equal), it is posible that the result of the subtract</span>
00670             <span class="comment">// could be negative (if the exponents are equal). If this</span>
00671             <span class="comment">// occurs, then the result sign and mantissa are complemented</span>
00672             <span class="comment">// to obtain the correct result.</span>
00673             <span class="comment">//</span>
00674 
00675         <span class="keywordflow">case</span> FLOAT_ADD:
00676             <span class="keywordflow">if</span> (Format == FORMAT_SINGLE) {
00677 
00678                 <span class="comment">//</span>
00679                 <span class="comment">// Complement the sign of the second operand if the operation</span>
00680                 <span class="comment">// is subtraction.</span>
00681                 <span class="comment">//</span>
00682 
00683                 SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a> ^= Negation;
00684 
00685                 <span class="comment">//</span>
00686                 <span class="comment">// Reorder then operands according to their exponent value.</span>
00687                 <span class="comment">//</span>
00688 
00689                 <span class="keywordflow">if</span> (SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">Exponent</a> &gt; SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">Exponent</a>) {
00690                     SingleOperand3 = SingleOperand2;
00691                     SingleOperand2 = SingleOperand1;
00692                     SingleOperand1 = SingleOperand3;
00693                 }
00694 
00695                 <span class="comment">//</span>
00696                 <span class="comment">// Compute the exponent difference and shift the smaller</span>
00697                 <span class="comment">// mantissa right by the difference value or 26 which ever</span>
00698                 <span class="comment">// is smaller. The bits shifted out are termed the sticky</span>
00699                 <span class="comment">// bits and are used later in the rounding operation.</span>
00700                 <span class="comment">//</span>
00701 
00702                 ExponentDifference =
00703                             SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">Exponent</a> - SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">Exponent</a>;
00704 
00705                 <span class="keywordflow">if</span> (ExponentDifference &gt; 26) {
00706                     ExponentDifference = 26;
00707                 }
00708 
00709                 StickyBits =
00710                         SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> &amp; ((1 &lt;&lt; ExponentDifference) - 1);
00711                 SingleMantissa = SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> &gt;&gt; ExponentDifference;
00712 
00713                 <span class="comment">//</span>
00714                 <span class="comment">// If the operands both have the same sign, then perform the</span>
00715                 <span class="comment">// operation by adding the values together. Otherwise, perform</span>
00716                 <span class="comment">// the operation by subtracting the second operand from the</span>
00717                 <span class="comment">// first operand.</span>
00718                 <span class="comment">//</span>
00719 
00720                 <span class="keywordflow">if</span> ((SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a> ^ SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a>) == 0) {
00721                     SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> += SingleMantissa;
00722 
00723                 } <span class="keywordflow">else</span> {
00724                     <span class="keywordflow">if</span> ((SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o3">Infinity</a> != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
00725                         (SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o3">Infinity</a> != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>)) {
00726                         <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a23">KiInvalidOperationSingle</a>(&amp;ContextBlock,
00727                                                         <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00728                                                         &amp;SingleOperand1,
00729                                                         &amp;SingleOperand2);
00730 
00731                     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o3">Infinity</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
00732                         <span class="keywordflow">if</span> (StickyBits != 0) {
00733                             SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> -= 1;
00734                         }
00735 
00736                         SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> -= SingleMantissa;
00737                         <span class="keywordflow">if</span> (SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> &lt; 0) {
00738                             SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> = -SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a>;
00739                             SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a> ^= 0x1;
00740                         }
00741                     }
00742                 }
00743 
00744                 <span class="comment">//</span>
00745                 <span class="comment">// Normalize and store the result value.</span>
00746                 <span class="comment">//</span>
00747 
00748                 <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a27">KiNormalizeSingle</a>(&amp;ContextBlock,
00749                                          &amp;SingleOperand1,
00750                                          StickyBits);
00751 
00752             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Format == FORMAT_DOUBLE) {
00753 
00754                 <span class="comment">//</span>
00755                 <span class="comment">// Complement the sign of the second operand if the operation</span>
00756                 <span class="comment">// is subtraction.</span>
00757                 <span class="comment">//</span>
00758 
00759                 DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a> ^= Negation;
00760 
00761                 <span class="comment">//</span>
00762                 <span class="comment">// Reorder then operands according to their exponent value.</span>
00763                 <span class="comment">//</span>
00764 
00765                 <span class="keywordflow">if</span> (DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a> &gt; DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a>) {
00766                     DoubleOperand3 = DoubleOperand2;
00767                     DoubleOperand2 = DoubleOperand1;
00768                     DoubleOperand1 = DoubleOperand3;
00769                 }
00770 
00771                 <span class="comment">//</span>
00772                 <span class="comment">// Compute the exponent difference and shift the smaller</span>
00773                 <span class="comment">// mantissa right by the difference value or 55 which ever</span>
00774                 <span class="comment">// is smaller. The bits shifted out are termed the sticky</span>
00775                 <span class="comment">// bits and are used later in the rounding operation.</span>
00776                 <span class="comment">//</span>
00777 
00778                 ExponentDifference =
00779                         DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a> - DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a>;
00780 
00781                 <span class="keywordflow">if</span> (ExponentDifference &gt; 55) {
00782                     ExponentDifference = 55;
00783                 }
00784 
00785                 <span class="keywordflow">if</span> (ExponentDifference &gt;= 32) {
00786                     ExponentDifference -= 32;
00787                     StickyBits = (DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a>) |
00788                         (DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> &amp; ((1 &lt;&lt; ExponentDifference) - 1));
00789 
00790                     DoubleMantissaLow =
00791                         DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> &gt;&gt; ExponentDifference;
00792 
00793                     DoubleMantissaHigh = 0;
00794 
00795                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ExponentDifference &gt; 0) {
00796                     StickyBits =
00797                         DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> &amp; ((1 &lt;&lt; ExponentDifference) - 1);
00798 
00799                     DoubleMantissaLow =
00800                         (DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> &gt;&gt; ExponentDifference) |
00801                         (DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> &lt;&lt; (32 - ExponentDifference));
00802 
00803                     DoubleMantissaHigh =
00804                         DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> &gt;&gt; ExponentDifference;
00805 
00806                 } <span class="keywordflow">else</span> {
00807                     StickyBits = 0;
00808                     DoubleMantissaLow = DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a>;
00809                     DoubleMantissaHigh = DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a>;
00810                 }
00811 
00812                 <span class="comment">//</span>
00813                 <span class="comment">// If the operands both have the same sign, then perform the</span>
00814                 <span class="comment">// operation by adding the values together. Otherwise, perform</span>
00815                 <span class="comment">// the operation by subtracting the second operand from the</span>
00816                 <span class="comment">// first operand.</span>
00817                 <span class="comment">//</span>
00818 
00819                 <span class="keywordflow">if</span> ((DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a> ^ DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a>) == 0) {
00820                     DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> += DoubleMantissaLow;
00821                     DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> += DoubleMantissaHigh;
00822                     <span class="keywordflow">if</span> (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> &lt; DoubleMantissaLow) {
00823                         DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> += 1;
00824                     }
00825 
00826                 } <span class="keywordflow">else</span> {
00827                     <span class="keywordflow">if</span> ((DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o5">Infinity</a> != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
00828                         (DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o5">Infinity</a> != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>)) {
00829                         <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a20">KiInvalidOperationDouble</a>(&amp;ContextBlock,
00830                                                         <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00831                                                         &amp;DoubleOperand1,
00832                                                         &amp;DoubleOperand2);
00833 
00834                     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o5">Infinity</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
00835                         <span class="keywordflow">if</span> (StickyBits != 0) {
00836                             <span class="keywordflow">if</span> (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> &lt; 1) {
00837                                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> -= 1;
00838                             }
00839 
00840                             DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> -= 1;
00841                         }
00842 
00843                         <span class="keywordflow">if</span> (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> &lt; DoubleMantissaLow) {
00844                             DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> -= 1;
00845                         }
00846 
00847                         DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> -= DoubleMantissaLow;
00848                         DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> -= DoubleMantissaHigh;
00849                         <span class="keywordflow">if</span> (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> &lt; 0) {
00850                             DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> = ~DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> + 1;
00851                             DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> = -DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a>;
00852                             <span class="keywordflow">if</span> (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> != 0) {
00853                                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> -= 1;
00854                             }
00855 
00856                             DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a> ^= 0x1;
00857                         }
00858                     }
00859                 }
00860 
00861                 <span class="comment">//</span>
00862                 <span class="comment">// Normalize and store the result value.</span>
00863                 <span class="comment">//</span>
00864 
00865                 <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a24">KiNormalizeDouble</a>(&amp;ContextBlock,
00866                                          &amp;DoubleOperand1,
00867                                          StickyBits);
00868 
00869             } <span class="keywordflow">else</span> {
00870                 <span class="keywordflow">break</span>;
00871             }
00872 
00873             <span class="comment">//</span>
00874             <span class="comment">// Floating multiply operation.</span>
00875             <span class="comment">//</span>
00876             <span class="comment">// Floating multiply is accomplished using unsigned multiplies</span>
00877             <span class="comment">// of the mantissa values, and adding the parital results together</span>
00878             <span class="comment">// to form the total product.</span>
00879             <span class="comment">//</span>
00880             <span class="comment">// The two mantissa values are preshifted such that the final</span>
00881             <span class="comment">// result is properly aligned.</span>
00882             <span class="comment">//</span>
00883 
00884         <span class="keywordflow">case</span> FLOAT_MULTIPLY:
00885             <span class="keywordflow">if</span> (Format == FORMAT_SINGLE) {
00886 
00887                 <span class="comment">//</span>
00888                 <span class="comment">// Reorder the operands according to their exponent value.</span>
00889                 <span class="comment">//</span>
00890 
00891                 <span class="keywordflow">if</span> (SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">Exponent</a> &gt; SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">Exponent</a>) {
00892                     SingleOperand3 = SingleOperand2;
00893                     SingleOperand2 = SingleOperand1;
00894                     SingleOperand1 = SingleOperand3;
00895                 }
00896 
00897                 <span class="comment">//</span>
00898                 <span class="comment">// If the first operand is infinite and the second operand is</span>
00899                 <span class="comment">// zero, then an invalid operation is specified.</span>
00900                 <span class="comment">//</span>
00901 
00902                 <span class="keywordflow">if</span> ((SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o3">Infinity</a> != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
00903                     (SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o3">Infinity</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
00904                     (SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> == 0)) {
00905                     <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a23">KiInvalidOperationSingle</a>(&amp;ContextBlock,
00906                                                     <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00907                                                     &amp;SingleOperand1,
00908                                                     &amp;SingleOperand2);
00909 
00910                 }
00911 
00912                 <span class="comment">//</span>
00913                 <span class="comment">// Preshift the operand mantissas so the result will be a</span>
00914                 <span class="comment">// properly aligned 64-bit value and then unsigned multiply</span>
00915                 <span class="comment">// the two mantissa values. The single result is the high part</span>
00916                 <span class="comment">// of the 64-bit product and the sticky bits are the low part</span>
00917                 <span class="comment">// of the 64-bit product.</span>
00918                 <span class="comment">//</span>
00919 
00920                 LargeResult.QuadPart = UInt32x32To64(SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> &lt;&lt; (32 - 26),
00921                                                      SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> &lt;&lt; 1);
00922 
00923                 SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> = LargeResult.HighPart;
00924                 StickyBits = LargeResult.LowPart;
00925 
00926                 <span class="comment">//</span>
00927                 <span class="comment">// Compute the sign and exponent of the result.</span>
00928                 <span class="comment">//</span>
00929 
00930                 SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a> ^= SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a>;
00931                 SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">Exponent</a> +=
00932                             SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">Exponent</a> - SINGLE_EXPONENT_BIAS;
00933 
00934                 <span class="comment">//</span>
00935                 <span class="comment">// Normalize and store the result value.</span>
00936                 <span class="comment">//</span>
00937 
00938                 <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a27">KiNormalizeSingle</a>(&amp;ContextBlock,
00939                                          &amp;SingleOperand1,
00940                                          StickyBits);
00941 
00942             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Format == FORMAT_DOUBLE) {
00943 
00944                 <span class="comment">//</span>
00945                 <span class="comment">// Reorder the operands according to their exponent value.</span>
00946                 <span class="comment">//</span>
00947 
00948                 <span class="keywordflow">if</span> (DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a> &gt; DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a>) {
00949                     DoubleOperand3 = DoubleOperand2;
00950                     DoubleOperand2 = DoubleOperand1;
00951                     DoubleOperand1 = DoubleOperand3;
00952                 }
00953 
00954                 <span class="comment">//</span>
00955                 <span class="comment">// If the first operand is infinite and the second operand is</span>
00956                 <span class="comment">// zero, then an invalid operation is specified.</span>
00957                 <span class="comment">//</span>
00958 
00959                 <span class="keywordflow">if</span> ((DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o5">Infinity</a> != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
00960                     (DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o5">Infinity</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
00961                     (DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> == 0)) {
00962                     <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a20">KiInvalidOperationDouble</a>(&amp;ContextBlock,
00963                                                     <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00964                                                     &amp;DoubleOperand1,
00965                                                     &amp;DoubleOperand2);
00966 
00967                 }
00968 
00969                 <span class="comment">//</span>
00970                 <span class="comment">// Preshift the operand mantissas so the result will be a</span>
00971                 <span class="comment">// properly aligned 128-bit value and then unsigned multiply</span>
00972                 <span class="comment">// the two mantissa values. The double result is the high part</span>
00973                 <span class="comment">// of the 128-bit product and the sticky bits are the low part</span>
00974                 <span class="comment">// of the 128-bit product.</span>
00975                 <span class="comment">//</span>
00976 
00977                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> =
00978                         (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> &lt;&lt; 1) |
00979                                 (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> &gt;&gt; 31);
00980 
00981                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> &lt;&lt;= 1;
00982                 DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> =
00983                         (DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> &lt;&lt; (64 - 55)) |
00984                                 (DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> &gt;&gt; (32 - (64 -55)));
00985 
00986                 DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> &lt;&lt;= (64 - 55);
00987 
00988                 <span class="comment">//</span>
00989                 <span class="comment">// The 128-bit product is formed by mutiplying and adding</span>
00990                 <span class="comment">// all the cross product values.</span>
00991                 <span class="comment">//</span>
00992                 <span class="comment">// Consider the operands (A and B) as being composed of two</span>
00993                 <span class="comment">// parts Ahigh, Alow, Bhigh, and Blow. The cross product sum</span>
00994                 <span class="comment">// is then:</span>
00995                 <span class="comment">//</span>
00996                 <span class="comment">//       Ahigh * Bhigh * 2^64 +</span>
00997                 <span class="comment">//              Ahigh * Blow * 2^32 +</span>
00998                 <span class="comment">//              Alow * Bhigh * 2^32 +</span>
00999                 <span class="comment">//                              Alow * Blow</span>
01000                 <span class="comment">//</span>
01001 
01002                 AhighBhigh.QuadPart = UInt32x32To64(DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a>,
01003                                                     DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a>);
01004 
01005                 AhighBlow.QuadPart = UInt32x32To64(DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a>,
01006                                                    DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a>);
01007 
01008                 AlowBhigh.QuadPart = UInt32x32To64(DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a>,
01009                                                    DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a>);
01010 
01011                 AlowBlow.QuadPart = UInt32x32To64(DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a>,
01012                                                   DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a>);
01013 
01014                 AlowBlow.HighPart += AhighBlow.LowPart;
01015                 <span class="keywordflow">if</span> (AlowBlow.HighPart &lt; AhighBlow.LowPart) {
01016                     Carry1 = 1;
01017 
01018                 } <span class="keywordflow">else</span> {
01019                     Carry1 = 0;
01020                 }
01021 
01022                 AlowBlow.HighPart += AlowBhigh.LowPart;
01023                 <span class="keywordflow">if</span> (AlowBlow.HighPart &lt; AlowBhigh.LowPart) {
01024                     Carry1 += 1;
01025                 }
01026 
01027                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> = AhighBlow.HighPart + Carry1;
01028                 <span class="keywordflow">if</span> (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> &lt; Carry1) {
01029                     Carry2 = 1;
01030 
01031                 } <span class="keywordflow">else</span> {
01032                     Carry2 = 0;
01033                 }
01034 
01035                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> += AlowBhigh.HighPart;
01036                 <span class="keywordflow">if</span> (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> &lt; AlowBhigh.HighPart) {
01037                     Carry2 += 1;
01038                 }
01039 
01040                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> += AhighBhigh.LowPart;
01041                 <span class="keywordflow">if</span> (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> &lt; AhighBhigh.LowPart) {
01042                     Carry2 += 1;
01043                 }
01044 
01045                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> = AhighBhigh.HighPart + Carry2;
01046                 StickyBits = AlowBlow.HighPart | AlowBlow.LowPart;
01047 
01048                 <span class="comment">//</span>
01049                 <span class="comment">// Compute the sign and exponent of the result.</span>
01050                 <span class="comment">//</span>
01051 
01052                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a> ^= DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a>;
01053                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a> +=
01054                             DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a> - DOUBLE_EXPONENT_BIAS;
01055 
01056                 <span class="comment">//</span>
01057                 <span class="comment">// Normalize and store the result value.</span>
01058                 <span class="comment">//</span>
01059 
01060                 <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a24">KiNormalizeDouble</a>(&amp;ContextBlock,
01061                                          &amp;DoubleOperand1,
01062                                          StickyBits);
01063 
01064             } <span class="keywordflow">else</span> {
01065                 <span class="keywordflow">break</span>;
01066             }
01067 
01068             <span class="comment">//</span>
01069             <span class="comment">// Floating divide operation.</span>
01070             <span class="comment">//</span>
01071             <span class="comment">// Floating division is accomplished by repeated subtract using</span>
01072             <span class="comment">// a single one-bit-at-a-time algorithm. The number of division</span>
01073             <span class="comment">// steps performed is equal to the mantissa size plus one guard</span>
01074             <span class="comment">// bit.</span>
01075             <span class="comment">//</span>
01076             <span class="comment">// The sticky bits are the remainder after the specified number</span>
01077             <span class="comment">// of division steps.</span>
01078             <span class="comment">//</span>
01079 
01080         <span class="keywordflow">case</span> FLOAT_DIVIDE:
01081             <span class="keywordflow">if</span> (Format == FORMAT_SINGLE) {
01082 
01083                 <span class="comment">//</span>
01084                 <span class="comment">// If the first operand is infinite and the second operand</span>
01085                 <span class="comment">// is infinite, or both operands are zero, then an invalid</span>
01086                 <span class="comment">// operation is specified.</span>
01087                 <span class="comment">//</span>
01088 
01089                 <span class="keywordflow">if</span> (((SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o3">Infinity</a> != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
01090                     (SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o3">Infinity</a> != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>)) ||
01091                     ((SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o3">Infinity</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
01092                     (SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> == 0) &amp;&amp;
01093                     (SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o3">Infinity</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
01094                     (SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> == 0))) {
01095                     <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a23">KiInvalidOperationSingle</a>(&amp;ContextBlock,
01096                                                     <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
01097                                                     &amp;SingleOperand1,
01098                                                     &amp;SingleOperand2);
01099 
01100                 }
01101 
01102                 <span class="comment">//</span>
01103                 <span class="comment">// If the second operand is zero, then a divide by zero</span>
01104                 <span class="comment">// operation is specified.</span>
01105                 <span class="comment">//</span>
01106 
01107                 <span class="keywordflow">if</span> ((SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o3">Infinity</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
01108                     (SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> == 0)) {
01109                     <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a17">KiDivideByZeroSingle</a>(&amp;ContextBlock,
01110                                                 &amp;SingleOperand1,
01111                                                 &amp;SingleOperand2);
01112                 }
01113 
01114                 <span class="comment">//</span>
01115                 <span class="comment">// If the first operand is infinite, then the result is</span>
01116                 <span class="comment">// infinite. Otherwise, if the second operand is infinite,</span>
01117                 <span class="comment">// then the result is zero (note that both operands cannot</span>
01118                 <span class="comment">// be infinite).</span>
01119                 <span class="comment">//</span>
01120 
01121                 <span class="keywordflow">if</span> (SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o3">Infinity</a> != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01122                     SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a> ^= SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a>;
01123                     <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a27">KiNormalizeSingle</a>(&amp;ContextBlock,
01124                                              &amp;SingleOperand1,
01125                                              0);
01126 
01127                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o3">Infinity</a> != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01128                     SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a> ^= SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a>;
01129                     SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">Exponent</a> = 0;
01130                     SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> = 0;
01131                     <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a27">KiNormalizeSingle</a>(&amp;ContextBlock,
01132                                              &amp;SingleOperand1,
01133                                              0);
01134 
01135                 }
01136 
01137                 <span class="comment">//</span>
01138                 <span class="comment">// Perform divide operation by repeating a single bit</span>
01139                 <span class="comment">// divide step 26 iterations.</span>
01140                 <span class="comment">//</span>
01141 
01142                 SingleOperand3.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> = 0;
01143                 <span class="keywordflow">for</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = 0; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &lt; 26; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> += 1) {
01144                     SingleOperand3.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> &lt;&lt;=1;
01145                     <span class="keywordflow">if</span> (SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> &gt;= SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a>) {
01146                         SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> -= SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a>;
01147                         SingleOperand3.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> |= 1;
01148                     }
01149 
01150                     SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> &lt;&lt;= 1;
01151                 }
01152 
01153                 <span class="comment">//</span>
01154                 <span class="comment">// Compute the sign and exponent of the result.</span>
01155                 <span class="comment">//</span>
01156 
01157                 SingleOperand3.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a> = SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a> ^ SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a>;
01158                 SingleOperand3.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">Exponent</a> = SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">Exponent</a> -
01159                                 SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">Exponent</a> + SINGLE_EXPONENT_BIAS;
01160 
01161                 <span class="comment">//</span>
01162                 <span class="comment">// Normalize and store the result value.</span>
01163                 <span class="comment">//</span>
01164 
01165                 SingleOperand3.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o3">Infinity</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01166                 SingleOperand3.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o4">Nan</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01167                 <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a27">KiNormalizeSingle</a>(&amp;ContextBlock,
01168                                          &amp;SingleOperand3,
01169                                          SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a>);
01170 
01171             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Format == FORMAT_DOUBLE) {
01172 
01173                 <span class="comment">//</span>
01174                 <span class="comment">// If the first operand is infinite and the second operand</span>
01175                 <span class="comment">// is infinite, or both operands are zero, then an invalid</span>
01176                 <span class="comment">// operation is specified.</span>
01177                 <span class="comment">//</span>
01178 
01179                 <span class="keywordflow">if</span> (((DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o5">Infinity</a> != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
01180                     (DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o5">Infinity</a> != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>)) ||
01181                     ((DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o5">Infinity</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
01182                     (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> == 0) &amp;&amp;
01183                     (DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o5">Infinity</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
01184                     (DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> == 0))) {
01185                     <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a20">KiInvalidOperationDouble</a>(&amp;ContextBlock,
01186                                                     <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
01187                                                     &amp;DoubleOperand1,
01188                                                     &amp;DoubleOperand2);
01189 
01190                 }
01191 
01192                 <span class="comment">//</span>
01193                 <span class="comment">// If the second operand is zero, then a divide by zero</span>
01194                 <span class="comment">// operation is specified.</span>
01195                 <span class="comment">//</span>
01196 
01197                 <span class="keywordflow">if</span> ((DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o5">Infinity</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
01198                     (DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> == 0)) {
01199                     <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a16">KiDivideByZeroDouble</a>(&amp;ContextBlock,
01200                                                 &amp;DoubleOperand1,
01201                                                 &amp;DoubleOperand2);
01202                 }
01203 
01204                 <span class="comment">//</span>
01205                 <span class="comment">// If the first operand is infinite, then the result is</span>
01206                 <span class="comment">// infinite. Otherwise, if the second operand is infinite,</span>
01207                 <span class="comment">// then the result is zero (note that both operands cannot</span>
01208                 <span class="comment">// be infinite).</span>
01209                 <span class="comment">//</span>
01210 
01211                 <span class="keywordflow">if</span> (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o5">Infinity</a> != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01212                     DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a> ^= DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a>;
01213                     <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a24">KiNormalizeDouble</a>(&amp;ContextBlock,
01214                                              &amp;DoubleOperand1,
01215                                              0);
01216 
01217                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o5">Infinity</a> != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01218                     DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a> ^= DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a>;
01219                     DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a> = 0;
01220                     DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> = 0;
01221                     DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> = 0;
01222                     <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a24">KiNormalizeDouble</a>(&amp;ContextBlock,
01223                                              &amp;DoubleOperand1,
01224                                              0);
01225 
01226                 }
01227 
01228                 <span class="comment">//</span>
01229                 <span class="comment">// Perform divide operation by repeating a single bit</span>
01230                 <span class="comment">// divide step 55 iterations.</span>
01231                 <span class="comment">//</span>
01232 
01233                 DoubleDividend.LowPart = DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a>;
01234                 DoubleDividend.HighPart = DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a>;
01235                 DoubleDivisor.LowPart = DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a>;
01236                 DoubleDivisor.HighPart = DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a>;
01237                 DoubleQuotient.LowPart = 0;
01238                 DoubleQuotient.HighPart = 0;
01239                 <span class="keywordflow">for</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = 0; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &lt; 55; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> += 1) {
01240                     DoubleQuotient.HighPart =
01241                                 (DoubleQuotient.HighPart &lt;&lt; 1) |
01242                                                 DoubleQuotient.LowPart &gt;&gt; 31;
01243 
01244                     DoubleQuotient.LowPart &lt;&lt;= 1;
01245                     <span class="keywordflow">if</span> (DoubleDividend.QuadPart &gt;= DoubleDivisor.QuadPart) {
01246                         DoubleDividend.QuadPart -= DoubleDivisor.QuadPart;
01247                         DoubleQuotient.LowPart |= 1;
01248                     }
01249 
01250                     DoubleDividend.HighPart =
01251                                 (DoubleDividend.HighPart &lt;&lt; 1) |
01252                                                 DoubleDividend.LowPart &gt;&gt; 31;
01253 
01254                     DoubleDividend.LowPart &lt;&lt;= 1;
01255                 }
01256 
01257                 DoubleOperand3.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> = DoubleQuotient.LowPart;
01258                 DoubleOperand3.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> = DoubleQuotient.HighPart;
01259 
01260                 <span class="comment">//</span>
01261                 <span class="comment">// Compute the sign and exponent of the result.</span>
01262                 <span class="comment">//</span>
01263 
01264                 DoubleOperand3.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a> = DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a> ^ DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a>;
01265                 DoubleOperand3.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a> = DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a> -
01266                                 DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a> + DOUBLE_EXPONENT_BIAS;
01267 
01268                 <span class="comment">//</span>
01269                 <span class="comment">// Normalize and store the result value.</span>
01270                 <span class="comment">//</span>
01271 
01272                 DoubleOperand3.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o5">Infinity</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01273                 DoubleOperand3.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o6">Nan</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01274                 <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a24">KiNormalizeDouble</a>(&amp;ContextBlock,
01275                                          &amp;DoubleOperand3,
01276                                          DoubleDividend.LowPart | DoubleDividend.HighPart);
01277 
01278             } <span class="keywordflow">else</span> {
01279                 <span class="keywordflow">break</span>;
01280             }
01281 
01282             <span class="comment">//</span>
01283             <span class="comment">// Floating square root.</span>
01284             <span class="comment">//</span>
01285 
01286         <span class="keywordflow">case</span> FLOAT_SQUARE_ROOT:
01287             <span class="keywordflow">if</span> (Format == FORMAT_SINGLE) {
01288 
01289                 <span class="comment">//</span>
01290                 <span class="comment">// If the operand is plus infinity, then the result is</span>
01291                 <span class="comment">// plus infinity, or if the operand is plus or minus</span>
01292                 <span class="comment">// zero, then the result is plus or minus zero.</span>
01293                 <span class="comment">//</span>
01294 
01295                 <span class="keywordflow">if</span> (((SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a> == 0) &amp;&amp;
01296                    (SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o3">Infinity</a> != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>)) ||
01297                    (SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> == 0)) {
01298                     <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a27">KiNormalizeSingle</a>(&amp;ContextBlock,
01299                                              &amp;SingleOperand1,
01300                                              0);
01301                 }
01302 
01303                 <span class="comment">//</span>
01304                 <span class="comment">// If the operand is negative, then the operation is</span>
01305                 <span class="comment">// invalid.</span>
01306                 <span class="comment">//</span>
01307 
01308                 <span class="keywordflow">if</span> (SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a> != 0) {
01309                     <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a23">KiInvalidOperationSingle</a>(&amp;ContextBlock,
01310                                                     <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
01311                                                     &amp;SingleOperand1,
01312                                                     &amp;SingleOperand1);
01313                 }
01314 
01315                 <span class="comment">//</span>
01316                 <span class="comment">// The only case remaining that could cause an exception</span>
01317                 <span class="comment">// is a denomalized source value. The square root of a</span>
01318                 <span class="comment">// denormalized value is computed by:</span>
01319                 <span class="comment">//</span>
01320                 <span class="comment">//   1. Converting the value to a normalized value with</span>
01321                 <span class="comment">//      an exponent equal to the denormalization shift count</span>
01322                 <span class="comment">//      plus the bias of the exponent plus one.</span>
01323                 <span class="comment">//</span>
01324                 <span class="comment">//   2. Computing the square root of the value and unpacking</span>
01325                 <span class="comment">//      the result.</span>
01326                 <span class="comment">//</span>
01327                 <span class="comment">//   3. Converting the shift count back to a normalization</span>
01328                 <span class="comment">//      shift count.</span>
01329                 <span class="comment">//</span>
01330                 <span class="comment">//   4. Rounding and packing the resultant value.</span>
01331                 <span class="comment">//</span>
01332                 <span class="comment">// N.B. The square root of all denormalized number is a</span>
01333                 <span class="comment">//      normalized number.</span>
01334                 <span class="comment">//</span>
01335 
01336                 SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">Exponent</a> = (SINGLE_EXPONENT_BIAS + 1 +
01337                                             SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">Exponent</a>) &lt;&lt; 23;
01338 
01339                 SingleValue = (SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> &amp; ~(1 &lt;&lt; 25)) &gt;&gt; 2;
01340                 SingleValue |= SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">Exponent</a>;
01341                 StickyBits = <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a29">KiSquareRootSingle</a>(&amp;SingleValue);
01342                 SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">Exponent</a> =  (SingleValue &gt;&gt; 23) -
01343                                             ((SINGLE_EXPONENT_BIAS + 1) / 2);
01344 
01345                 SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> = ((SingleValue &amp;
01346                                             0x7fffff) | 0x800000) &lt;&lt; 2;
01347 
01348                 <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a27">KiNormalizeSingle</a>(&amp;ContextBlock,
01349                                          &amp;SingleOperand1,
01350                                          StickyBits);
01351 
01352             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Format == FORMAT_DOUBLE) {
01353 
01354                 <span class="comment">//</span>
01355                 <span class="comment">// If the operand is plus infinity, then the result is</span>
01356                 <span class="comment">// plus infinity, or if the operand is plus or minus</span>
01357                 <span class="comment">// zero, then the result is plus or minus zero.</span>
01358                 <span class="comment">//</span>
01359 
01360                 <span class="keywordflow">if</span> (((DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a> == 0) &amp;&amp;
01361                    (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o5">Infinity</a> != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>)) ||
01362                    (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> == 0)) {
01363                     <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a24">KiNormalizeDouble</a>(&amp;ContextBlock,
01364                                              &amp;DoubleOperand1,
01365                                              0);
01366                 }
01367 
01368                 <span class="comment">//</span>
01369                 <span class="comment">// If the operand is negative, then the operation is</span>
01370                 <span class="comment">// invalid.</span>
01371                 <span class="comment">//</span>
01372 
01373                 <span class="keywordflow">if</span> (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a> != 0) {
01374                     <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a20">KiInvalidOperationDouble</a>(&amp;ContextBlock,
01375                                                     <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
01376                                                     &amp;DoubleOperand1,
01377                                                     &amp;DoubleOperand1);
01378                 }
01379 
01380                 <span class="comment">//</span>
01381                 <span class="comment">// The only case remaining that could cause an exception</span>
01382                 <span class="comment">// is a denomalized source value. The square root of a</span>
01383                 <span class="comment">// denormalized value is computed by:</span>
01384                 <span class="comment">//</span>
01385                 <span class="comment">//   1. Converting the value to a normalized value with</span>
01386                 <span class="comment">//      an exponent equal to the denormalization shift count</span>
01387                 <span class="comment">//      plus the bias of the exponent plus one.</span>
01388                 <span class="comment">//</span>
01389                 <span class="comment">//   2. Computing the square root of the value and unpacking</span>
01390                 <span class="comment">//      the result.</span>
01391                 <span class="comment">//</span>
01392                 <span class="comment">//   3. Converting the shift count back to a normalization</span>
01393                 <span class="comment">//      shift count.</span>
01394                 <span class="comment">//</span>
01395                 <span class="comment">//   4. Rounding and packing the resultant value.</span>
01396                 <span class="comment">//</span>
01397                 <span class="comment">// N.B. The square root of all denormalized numbers is a</span>
01398                 <span class="comment">//      normalized number.</span>
01399                 <span class="comment">//</span>
01400 
01401                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a> = (DOUBLE_EXPONENT_BIAS + 1 +
01402                                             DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a>) &lt;&lt; 20;
01403 
01404                 DoubleValue.HighPart = (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> &amp; ~(1 &lt;&lt; 22)) &gt;&gt; 2;
01405                 DoubleValue.LowPart = (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> &lt;&lt; 30) |
01406                                             (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> &gt;&gt; 2);
01407 
01408                 DoubleValue.HighPart |= DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a>;
01409                 StickyBits = <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a28">KiSquareRootDouble</a>(&amp;DoubleValue);
01410                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a> =  (DoubleValue.HighPart &gt;&gt; 20) -
01411                                             ((DOUBLE_EXPONENT_BIAS + 1) / 2);
01412 
01413                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> = DoubleValue.LowPart &lt;&lt; 2;
01414                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> = ((DoubleValue.HighPart &amp;
01415                                             0xfffff) | 0x100000) &lt;&lt; 2;
01416 
01417                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> |= (DoubleValue.LowPart &gt;&gt; 30);
01418                 <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a24">KiNormalizeDouble</a>(&amp;ContextBlock,
01419                                          &amp;DoubleOperand1,
01420                                          StickyBits);
01421 
01422             } <span class="keywordflow">else</span> {
01423                 <span class="keywordflow">break</span>;
01424             }
01425 
01426             <span class="comment">//</span>
01427             <span class="comment">// Floating absolute operation.</span>
01428             <span class="comment">//</span>
01429             <span class="comment">// Floating absolute is accomplished by clearing the sign</span>
01430             <span class="comment">// of the floating value.</span>
01431             <span class="comment">//</span>
01432 
01433         <span class="keywordflow">case</span> FLOAT_ABSOLUTE:
01434             <span class="keywordflow">if</span> (Format == FORMAT_SINGLE) {
01435 
01436                 <span class="comment">//</span>
01437                 <span class="comment">// Clear the sign, normalize the result, and store in the</span>
01438                 <span class="comment">// destination register.</span>
01439                 <span class="comment">//</span>
01440 
01441                 SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a> = 0;
01442                 <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a27">KiNormalizeSingle</a>(&amp;ContextBlock,
01443                                          &amp;SingleOperand1,
01444                                          0);
01445 
01446             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Format == FORMAT_DOUBLE) {
01447 
01448                 <span class="comment">//</span>
01449                 <span class="comment">// Clear the sign, normalize the result, and store in the</span>
01450                 <span class="comment">// destination register.</span>
01451                 <span class="comment">//</span>
01452 
01453                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a> = 0;
01454                 <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a24">KiNormalizeDouble</a>(&amp;ContextBlock,
01455                                          &amp;DoubleOperand1,
01456                                          0);
01457 
01458             } <span class="keywordflow">else</span> {
01459                 <span class="keywordflow">break</span>;
01460             }
01461 
01462             <span class="comment">//</span>
01463             <span class="comment">// Floating move operation.</span>
01464             <span class="comment">//</span>
01465             <span class="comment">// Floating move is accomplished by moving the source operand</span>
01466             <span class="comment">// to the destination register.</span>
01467             <span class="comment">//</span>
01468 
01469         <span class="keywordflow">case</span> FLOAT_MOVE:
01470             <span class="keywordflow">if</span> (Format == FORMAT_SINGLE) {
01471 
01472                 <span class="comment">//</span>
01473                 <span class="comment">// Normalize the result and store in the destination</span>
01474                 <span class="comment">// register.</span>
01475                 <span class="comment">//</span>
01476 
01477                 <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a27">KiNormalizeSingle</a>(&amp;ContextBlock,
01478                                          &amp;SingleOperand1,
01479                                          0);
01480 
01481             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Format == FORMAT_DOUBLE) {
01482 
01483                 <span class="comment">//</span>
01484                 <span class="comment">// Normalize the result and store in the destination</span>
01485                 <span class="comment">// register.</span>
01486                 <span class="comment">//</span>
01487 
01488                 <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a24">KiNormalizeDouble</a>(&amp;ContextBlock,
01489                                          &amp;DoubleOperand1,
01490                                          0);
01491 
01492             } <span class="keywordflow">else</span> {
01493                 <span class="keywordflow">break</span>;
01494             }
01495 
01496             <span class="comment">//</span>
01497             <span class="comment">// Floating negate operation.</span>
01498             <span class="comment">//</span>
01499             <span class="comment">// Floating absolute is accomplished by complementing the sign</span>
01500             <span class="comment">// of the floating value.</span>
01501             <span class="comment">//</span>
01502 
01503         <span class="keywordflow">case</span> FLOAT_NEGATE:
01504             <span class="keywordflow">if</span> (Format == FORMAT_SINGLE) {
01505 
01506                 <span class="comment">//</span>
01507                 <span class="comment">// Complement the sign, normalize the result, and store in the</span>
01508                 <span class="comment">// destination register.</span>
01509                 <span class="comment">//</span>
01510 
01511                 SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a> ^= 0x1;
01512                 <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a27">KiNormalizeSingle</a>(&amp;ContextBlock,
01513                                          &amp;SingleOperand1,
01514                                          0);
01515 
01516             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Format == FORMAT_DOUBLE) {
01517 
01518                 <span class="comment">//</span>
01519                 <span class="comment">// Complement the sign, normalize the result, and store in the</span>
01520                 <span class="comment">// destination register.</span>
01521                 <span class="comment">//</span>
01522 
01523                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a> ^= 0x1;
01524                 <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a24">KiNormalizeDouble</a>(&amp;ContextBlock,
01525                                          &amp;DoubleOperand1,
01526                                          0);
01527 
01528             } <span class="keywordflow">else</span> {
01529                 <span class="keywordflow">break</span>;
01530             }
01531 
01532             <span class="comment">//</span>
01533             <span class="comment">// Floating compare single.</span>
01534             <span class="comment">//</span>
01535             <span class="comment">// This operation is performed after having separated out NaNs,</span>
01536             <span class="comment">// and therefore the only comparison predicates left are equal</span>
01537             <span class="comment">// and less.</span>
01538             <span class="comment">//</span>
01539             <span class="comment">// Floating compare single is accomplished by comparing signs,</span>
01540             <span class="comment">// then exponents, and finally the mantissa if necessary.</span>
01541             <span class="comment">//</span>
01542             <span class="comment">// N.B. The sign of zero is ignorned.</span>
01543             <span class="comment">//</span>
01544 
01545         <span class="keywordflow">case</span> FLOAT_COMPARE_SINGLE:
01546 
01547             <span class="comment">//</span>
01548             <span class="comment">// If either operand is zero, then set the sign of the operand</span>
01549             <span class="comment">// positive.</span>
01550             <span class="comment">//</span>
01551 
01552             <span class="keywordflow">if</span> ((SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o3">Infinity</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
01553                 (SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> == 0)) {
01554                 SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a> = 0;
01555                 SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">Exponent</a> = - 23;
01556             }
01557 
01558             <span class="keywordflow">if</span> ((SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o3">Infinity</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>)  &amp;&amp;
01559                 (SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> == 0)) {
01560                 SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a> = 0;
01561                 SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">Exponent</a> = - 23;
01562             }
01563 
01564             <span class="comment">//</span>
01565             <span class="comment">// Compare signs first.</span>
01566             <span class="comment">//</span>
01567 
01568             <span class="keywordflow">if</span> (SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a> &lt; SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a>) {
01569 
01570                 <span class="comment">//</span>
01571                 <span class="comment">// The first operand is greater than the second operand.</span>
01572                 <span class="comment">//</span>
01573 
01574                 CompareEqual = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01575                 CompareLess = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01576 
01577             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a> &gt; SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a>) {
01578 
01579                 <span class="comment">//</span>
01580                 <span class="comment">// The first operand is less than the second operand.</span>
01581                 <span class="comment">//</span>
01582 
01583                 CompareEqual = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01584                 CompareLess = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01585 
01586             } <span class="keywordflow">else</span> {
01587 
01588                 <span class="comment">//</span>
01589                 <span class="comment">// The operand signs are equal.</span>
01590                 <span class="comment">//</span>
01591                 <span class="comment">// If the sign of the operand is negative, then the sense of</span>
01592                 <span class="comment">// the comparison is reversed.</span>
01593                 <span class="comment">//</span>
01594 
01595                 <span class="keywordflow">if</span> (SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a> == 0) {
01596 
01597                     <span class="comment">//</span>
01598                     <span class="comment">// Compare positive operand with positive operand.</span>
01599                     <span class="comment">//</span>
01600 
01601                     <span class="keywordflow">if</span> (SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">Exponent</a> &gt; SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">Exponent</a>) {
01602                         CompareEqual = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01603                         CompareLess = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01604 
01605                     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">Exponent</a> &lt; SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">Exponent</a>) {
01606                         CompareEqual = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01607                         CompareLess = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01608 
01609                     } <span class="keywordflow">else</span> {
01610                         <span class="keywordflow">if</span> (SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> &gt; SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a>) {
01611                             CompareEqual = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01612                             CompareLess = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01613 
01614                         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> &lt; SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a>) {
01615                             CompareEqual = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01616                             CompareLess = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01617 
01618                         } <span class="keywordflow">else</span> {
01619                             CompareEqual = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01620                             CompareLess = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01621                         }
01622                     }
01623 
01624                 } <span class="keywordflow">else</span> {
01625 
01626                     <span class="comment">//</span>
01627                     <span class="comment">// Compare negative operand with negative operand.</span>
01628                     <span class="comment">//</span>
01629 
01630                     <span class="keywordflow">if</span> (SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">Exponent</a> &gt; SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">Exponent</a>) {
01631                         CompareEqual = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01632                         CompareLess = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01633 
01634                     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">Exponent</a> &lt; SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">Exponent</a>) {
01635                         CompareEqual = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01636                         CompareLess = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01637 
01638                     } <span class="keywordflow">else</span> {
01639                         <span class="keywordflow">if</span> (SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> &gt; SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a>) {
01640                             CompareEqual = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01641                             CompareLess = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01642 
01643                         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (SingleOperand2.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> &lt; SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a>) {
01644                             CompareEqual = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01645                             CompareLess = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01646 
01647                         } <span class="keywordflow">else</span> {
01648                             CompareEqual = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01649                             CompareLess = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01650                         }
01651                     }
01652                 }
01653             }
01654 
01655             <span class="comment">//</span>
01656             <span class="comment">// Form the condition code using the comparison information</span>
01657             <span class="comment">// and the compare function predicate bits.</span>
01658             <span class="comment">//</span>
01659 
01660             <span class="keywordflow">if</span> (((CompareLess != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
01661                 ((CompareFunction &amp; <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a8">COMPARE_LESS_MASK</a>) != 0)) ||
01662                 ((CompareEqual != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
01663                 ((CompareFunction &amp; <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a7">COMPARE_EQUAL_MASK</a>) != 0))) {
01664                 ((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;CC = 1;
01665 
01666             } <span class="keywordflow">else</span> {
01667                 ((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;CC = 0;
01668             }
01669 
01670             TrapFrame-&gt;Fir = ContextBlock.<a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o9">BranchAddress</a>;
01671             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01672 
01673             <span class="comment">//</span>
01674             <span class="comment">// Floating compare double.</span>
01675             <span class="comment">//</span>
01676             <span class="comment">// This operation is performed after having separated out NaNs,</span>
01677             <span class="comment">// and therefore the only comparison predicates left are equal</span>
01678             <span class="comment">// and less.</span>
01679             <span class="comment">//</span>
01680             <span class="comment">// Floating compare double is accomplished by comparing signs,</span>
01681             <span class="comment">// then exponents, and finally the mantissa if necessary.</span>
01682             <span class="comment">//</span>
01683             <span class="comment">// N.B. The sign of zero is ignorned.</span>
01684             <span class="comment">//</span>
01685 
01686         <span class="keywordflow">case</span> FLOAT_COMPARE_DOUBLE:
01687 
01688             <span class="comment">//</span>
01689             <span class="comment">// If either operand is zero, then set the sign of the operand</span>
01690             <span class="comment">// positive.</span>
01691             <span class="comment">//</span>
01692 
01693             <span class="keywordflow">if</span> ((DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o5">Infinity</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
01694                 (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> == 0)) {
01695                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a> = 0;
01696                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a> = - 52;
01697             }
01698 
01699             <span class="keywordflow">if</span> ((DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o5">Infinity</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
01700                 (DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> == 0)) {
01701                 DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a> = 0;
01702                 DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a> = - 52;
01703             }
01704 
01705             <span class="comment">//</span>
01706             <span class="comment">// Compare signs first.</span>
01707             <span class="comment">//</span>
01708 
01709             <span class="keywordflow">if</span> (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a> &lt; DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a>) {
01710 
01711                 <span class="comment">//</span>
01712                 <span class="comment">// The first operand is greater than the second operand.</span>
01713                 <span class="comment">//</span>
01714 
01715                 CompareEqual = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01716                 CompareLess = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01717 
01718             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a> &gt; DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a>) {
01719 
01720                 <span class="comment">//</span>
01721                 <span class="comment">// The first operand is less than the second operand.</span>
01722                 <span class="comment">//</span>
01723 
01724                 CompareEqual = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01725                 CompareLess = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01726 
01727             } <span class="keywordflow">else</span> {
01728 
01729                 <span class="comment">//</span>
01730                 <span class="comment">// The operand signs are equal.</span>
01731                 <span class="comment">//</span>
01732                 <span class="comment">// If the sign of the operand is negative, then the sense of</span>
01733                 <span class="comment">// the comparison is reversed.</span>
01734                 <span class="comment">//</span>
01735 
01736                 <span class="keywordflow">if</span> (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a> == 0) {
01737 
01738                     <span class="comment">//</span>
01739                     <span class="comment">// Compare positive operand with positive operand.</span>
01740                     <span class="comment">//</span>
01741 
01742                     <span class="keywordflow">if</span> (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a> &gt; DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a>) {
01743                         CompareEqual = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01744                         CompareLess = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01745 
01746                     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a> &lt; DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a>) {
01747                         CompareEqual = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01748                         CompareLess = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01749 
01750                     } <span class="keywordflow">else</span> {
01751                         <span class="keywordflow">if</span> (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> &gt;
01752                             DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a>) {
01753                             CompareEqual = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01754                             CompareLess = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01755 
01756                         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> &lt;
01757                                    DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a>) {
01758                             CompareEqual = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01759                             CompareLess = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01760 
01761                         } <span class="keywordflow">else</span> {
01762                             <span class="keywordflow">if</span> (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> &gt;
01763                                 DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a>) {
01764                                 CompareEqual = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01765                                 CompareLess = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01766 
01767                             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> &lt;
01768                                        DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a>) {
01769                                 CompareEqual = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01770                                 CompareLess = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01771 
01772                             } <span class="keywordflow">else</span> {
01773                                 CompareEqual = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01774                                 CompareLess = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01775                             }
01776                         }
01777                     }
01778 
01779                 } <span class="keywordflow">else</span> {
01780 
01781                     <span class="comment">//</span>
01782                     <span class="comment">// Compare negative operand with negative operand.</span>
01783                     <span class="comment">//</span>
01784 
01785                     <span class="keywordflow">if</span> (DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a> &gt; DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a>) {
01786                         CompareEqual = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01787                         CompareLess = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01788 
01789                     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a> &lt; DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a>) {
01790                         CompareEqual = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01791                         CompareLess = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01792 
01793                     } <span class="keywordflow">else</span> {
01794                         <span class="keywordflow">if</span> (DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> &gt;
01795                             DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a>) {
01796                             CompareEqual = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01797                             CompareLess = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01798 
01799                         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> &lt;
01800                                    DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a>) {
01801                             CompareEqual = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01802                             CompareLess = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01803 
01804                         } <span class="keywordflow">else</span> {
01805                             <span class="keywordflow">if</span> (DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> &gt;
01806                                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a>) {
01807                                 CompareEqual = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01808                                 CompareLess = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01809 
01810                             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (DoubleOperand2.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> &lt;
01811                                        DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a>) {
01812                                 CompareEqual = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01813                                 CompareLess = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01814 
01815                             } <span class="keywordflow">else</span> {
01816                                 CompareEqual = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01817                                 CompareLess = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01818                             }
01819                         }
01820                     }
01821                 }
01822             }
01823 
01824             <span class="comment">//</span>
01825             <span class="comment">// Form the condition code using the comparison information</span>
01826             <span class="comment">// and the compare function predicate bits.</span>
01827             <span class="comment">//</span>
01828 
01829             <span class="keywordflow">if</span> (((CompareLess != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
01830                 ((CompareFunction &amp; <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a8">COMPARE_LESS_MASK</a>) != 0)) ||
01831                 ((CompareEqual != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
01832                 ((CompareFunction &amp; <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a7">COMPARE_EQUAL_MASK</a>) != 0))) {
01833                 ((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;CC = 1;
01834 
01835             } <span class="keywordflow">else</span> {
01836                 ((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;CC = 0;
01837             }
01838 
01839             TrapFrame-&gt;Fir = ContextBlock.<a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o9">BranchAddress</a>;
01840             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01841 
01842             <span class="comment">//</span>
01843             <span class="comment">// Floating convert to single.</span>
01844             <span class="comment">//</span>
01845             <span class="comment">// This operation is only legal for conversion from quadword,</span>
01846             <span class="comment">// longword, and double formats to single format. This operation</span>
01847             <span class="comment">// can not be used to convert from a single format to a single format.</span>
01848             <span class="comment">//</span>
01849             <span class="comment">// Floating conversion to single is accompished by forming a</span>
01850             <span class="comment">// single floating operand and then normalize and storing the</span>
01851             <span class="comment">// result value.</span>
01852             <span class="comment">//</span>
01853 
01854         <span class="keywordflow">case</span> FLOAT_CONVERT_SINGLE:
01855             <span class="keywordflow">if</span> (Format == FORMAT_SINGLE) {
01856                 <span class="keywordflow">break</span>;
01857 
01858             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Format == FORMAT_DOUBLE) {
01859 
01860                 <span class="comment">//</span>
01861                 <span class="comment">// If the operand is a NaN, then store a quiet NaN if the</span>
01862                 <span class="comment">// invalid operation trap is disabled, or raise an exception</span>
01863                 <span class="comment">// if the invalid operation trap is enabled and the operand</span>
01864                 <span class="comment">// is a signaling NaN.</span>
01865                 <span class="comment">//</span>
01866 
01867                 <span class="keywordflow">if</span> (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o6">Nan</a> != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01868                     SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> =
01869                         (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> &lt;&lt; (26 - (55 - 32))) |
01870                         (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> &gt;&gt; (32 - (26 - (55 - 32))));
01871                     SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">Exponent</a> = SINGLE_MAXIMUM_EXPONENT;
01872                     SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a> = DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a>;
01873                     SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o3">Infinity</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01874                     SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o4">Nan</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01875                     <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a23">KiInvalidOperationSingle</a>(&amp;ContextBlock,
01876                                                     <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
01877                                                     &amp;SingleOperand1,
01878                                                     &amp;SingleOperand1);
01879 
01880                 }
01881 
01882                 <span class="comment">//</span>
01883                 <span class="comment">// Transform the double operand to single format.</span>
01884                 <span class="comment">//</span>
01885 
01886                 SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> =
01887                     (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> &lt;&lt; (26 - (55 - 32))) |
01888                     (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> &gt;&gt; (32 - (26 - (55 - 32))));
01889                 StickyBits = DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> &lt;&lt; (26 - (55 - 32));
01890                 SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">Exponent</a> = DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a> +
01891                                     SINGLE_EXPONENT_BIAS - DOUBLE_EXPONENT_BIAS;
01892                 SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a> = DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a>;
01893                 SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o3">Infinity</a> = DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o5">Infinity</a>;
01894                 SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o4">Nan</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01895 
01896                 <span class="comment">//</span>
01897                 <span class="comment">// Normalize and store the result value.</span>
01898                 <span class="comment">//</span>
01899 
01900                 <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a27">KiNormalizeSingle</a>(&amp;ContextBlock,
01901                                          &amp;SingleOperand1,
01902                                          StickyBits);
01903 
01904             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Format == FORMAT_LONGWORD) {
01905 
01906                 <span class="comment">//</span>
01907                 <span class="comment">// Compute the sign of the result.</span>
01908                 <span class="comment">//</span>
01909 
01910                 <span class="keywordflow">if</span> (Longword &lt; 0) {
01911                     SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a> = 0x1;
01912                     Longword = -Longword;
01913 
01914                 } <span class="keywordflow">else</span> {
01915                     SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a> = 0;
01916                 }
01917 
01918                 <span class="comment">//</span>
01919                 <span class="comment">// Initialize the infinity and NaN values.</span>
01920                 <span class="comment">//</span>
01921 
01922                 SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o3">Infinity</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01923                 SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o4">Nan</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01924 
01925                 <span class="comment">//</span>
01926                 <span class="comment">// Compute the exponent value and normalize the longword</span>
01927                 <span class="comment">// value.</span>
01928                 <span class="comment">//</span>
01929 
01930                 <span class="keywordflow">if</span> (Longword != 0) {
01931                     SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">Exponent</a> = SINGLE_EXPONENT_BIAS + 31;
01932                     <span class="keywordflow">while</span> (Longword &gt; 0) {
01933                         Longword &lt;&lt;= 1;
01934                         SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">Exponent</a> -= 1;
01935                     }
01936 
01937                     SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> = (ULONG)Longword &gt;&gt; (32 - 26);
01938                     StickyBits = Longword &lt;&lt; 26;
01939 
01940                 } <span class="keywordflow">else</span> {
01941                     SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> = 0;
01942                     StickyBits = 0;
01943                     SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">Exponent</a> = 0;
01944                 }
01945 
01946                 <span class="comment">//</span>
01947                 <span class="comment">// Normalize and store the result value.</span>
01948                 <span class="comment">//</span>
01949 
01950                 <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a27">KiNormalizeSingle</a>(&amp;ContextBlock,
01951                                          &amp;SingleOperand1,
01952                                          StickyBits);
01953 
01954             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Format == FORMAT_QUADWORD) {
01955 
01956                 <span class="comment">//</span>
01957                 <span class="comment">// Compute the sign of the result.</span>
01958                 <span class="comment">//</span>
01959 
01960                 <span class="keywordflow">if</span> (u.Quadword &lt; 0) {
01961                     SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a> = 0x1;
01962                     u.Quadword = -u.Quadword;
01963 
01964                 } <span class="keywordflow">else</span> {
01965                     SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a> = 0;
01966                 }
01967 
01968                 <span class="comment">//</span>
01969                 <span class="comment">// Initialize the infinity and NaN values.</span>
01970                 <span class="comment">//</span>
01971 
01972                 SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o3">Infinity</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01973                 SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o4">Nan</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01974 
01975                 <span class="comment">//</span>
01976                 <span class="comment">// Compute the exponent value and normalize the quadword</span>
01977                 <span class="comment">// value.</span>
01978                 <span class="comment">//</span>
01979 
01980                 <span class="keywordflow">if</span> (u.Quadword != 0) {
01981                     SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">Exponent</a> = SINGLE_EXPONENT_BIAS + 63;
01982                     <span class="keywordflow">while</span> (u.Quadword &gt; 0) {
01983                         u.Quadword &lt;&lt;= 1;
01984                         SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">Exponent</a> -= 1;
01985                     }
01986 
01987                     SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> = (LONG)((ULONGLONG)u.Quadword &gt;&gt; (64 - 26));
01988                     StickyBits = (u.Quadword &lt;&lt; 26) ? 1 : 0;
01989 
01990                 } <span class="keywordflow">else</span> {
01991                     SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> = 0;
01992                     StickyBits = 0;
01993                     SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">Exponent</a> = 0;
01994                 }
01995 
01996                 <span class="comment">//</span>
01997                 <span class="comment">// Normalize and store the result value.</span>
01998                 <span class="comment">//</span>
01999 
02000                 <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a27">KiNormalizeSingle</a>(&amp;ContextBlock,
02001                                          &amp;SingleOperand1,
02002                                          StickyBits);
02003 
02004             } <span class="keywordflow">else</span> {
02005                 <span class="keywordflow">break</span>;
02006             }
02007 
02008             <span class="comment">//</span>
02009             <span class="comment">// Floating convert to double.</span>
02010             <span class="comment">//</span>
02011             <span class="comment">// This operation is only legal for conversion from quadword,</span>
02012             <span class="comment">// longword, and single formats to double format. This operation</span>
02013             <span class="comment">// cannot be used to convert from a double format to a double</span>
02014             <span class="comment">// format.</span>
02015             <span class="comment">//</span>
02016             <span class="comment">// Floating conversion to double is accomplished by forming</span>
02017             <span class="comment">// double floating operand and then normalizing and storing</span>
02018             <span class="comment">// the result value.</span>
02019             <span class="comment">//</span>
02020 
02021         <span class="keywordflow">case</span> FLOAT_CONVERT_DOUBLE:
02022             <span class="keywordflow">if</span> (Format == FORMAT_SINGLE) {
02023 
02024                 <span class="comment">//</span>
02025                 <span class="comment">// If the operand is a NaN, then store a quiet NaN if the</span>
02026                 <span class="comment">// invalid operation trap is disabled, or raise an exception</span>
02027                 <span class="comment">// if the invalid operation trap is enabled and the operand</span>
02028                 <span class="comment">// is a signaling NaN.</span>
02029                 <span class="comment">//</span>
02030 
02031                 <span class="keywordflow">if</span> (SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o4">Nan</a> != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
02032                     DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> =
02033                             SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> &gt;&gt; (26 - (55 - 32));
02034                     DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> = (0xffffffff &gt;&gt; (26 - 2 - (55 - 32))) |
02035                             SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> &lt;&lt; (32 - (26 - (55 - 32)));
02036                     DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a> = DOUBLE_MAXIMUM_EXPONENT;
02037                     DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a> = SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a>;
02038                     DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o5">Infinity</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02039                     DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o6">Nan</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02040                     <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a20">KiInvalidOperationDouble</a>(&amp;ContextBlock,
02041                                                     <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
02042                                                     &amp;DoubleOperand1,
02043                                                     &amp;DoubleOperand1);
02044 
02045                 }
02046 
02047                 <span class="comment">//</span>
02048                 <span class="comment">// Transform the single operand to double format.</span>
02049                 <span class="comment">//</span>
02050 
02051                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> =
02052                             SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> &gt;&gt; (26 - (55 - 32));
02053                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> =
02054                             SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> &lt;&lt; (32 - (26 - (55 - 32)));
02055                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a> = SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">Exponent</a> +
02056                                     DOUBLE_EXPONENT_BIAS - SINGLE_EXPONENT_BIAS;
02057                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a> = SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a>;
02058                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o5">Infinity</a> = SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o3">Infinity</a>;
02059                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o6">Nan</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02060 
02061                 <span class="comment">//</span>
02062                 <span class="comment">// Normalize and store the result value.</span>
02063                 <span class="comment">//</span>
02064 
02065                 <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a24">KiNormalizeDouble</a>(&amp;ContextBlock,
02066                                          &amp;DoubleOperand1,
02067                                          0);
02068 
02069             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Format == FORMAT_DOUBLE) {
02070                 <span class="keywordflow">break</span>;
02071 
02072             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Format == FORMAT_LONGWORD) {
02073 
02074                 <span class="comment">//</span>
02075                 <span class="comment">// Compute the sign of the result.</span>
02076                 <span class="comment">//</span>
02077 
02078                 <span class="keywordflow">if</span> (Longword &lt; 0) {
02079                     DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a> = 0x1;
02080                     Longword = -Longword;
02081 
02082                 } <span class="keywordflow">else</span> {
02083                     DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a> = 0;
02084                 }
02085 
02086                 <span class="comment">//</span>
02087                 <span class="comment">// Initialize the infinity and NaN values.</span>
02088                 <span class="comment">//</span>
02089 
02090                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o5">Infinity</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02091                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o6">Nan</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02092 
02093                 <span class="comment">//</span>
02094                 <span class="comment">// Compute the exponent value and normalize the longword</span>
02095                 <span class="comment">// value.</span>
02096                 <span class="comment">//</span>
02097 
02098                 <span class="keywordflow">if</span> (Longword != 0) {
02099                     SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">Exponent</a> = DOUBLE_EXPONENT_BIAS + 31;
02100                     <span class="keywordflow">while</span> (Longword &gt; 0) {
02101                         Longword &lt;&lt;= 1;
02102                         DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a> -= 1;
02103                     }
02104 
02105                     DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o2">Mantissa</a> = (ULONGLONG)Longword &gt;&gt; (64 - 55);
02106 
02107                 } <span class="keywordflow">else</span> {
02108                     DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o2">Mantissa</a> = 0;
02109                     DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a> = 0;
02110                 }
02111 
02112                 <span class="comment">//</span>
02113                 <span class="comment">// Normalize and store the result value.</span>
02114                 <span class="comment">//</span>
02115 
02116                 <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a24">KiNormalizeDouble</a>(&amp;ContextBlock,
02117                                          &amp;DoubleOperand1,
02118                                          0);
02119 
02120             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Format == FORMAT_QUADWORD) {
02121 
02122                 <span class="comment">//</span>
02123                 <span class="comment">// Compute the sign of the result.</span>
02124                 <span class="comment">//</span>
02125 
02126                 <span class="keywordflow">if</span> (u.Quadword &lt; 0) {
02127                     DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a> = 0x1;
02128                     u.Quadword = -u.Quadword;
02129 
02130                 } <span class="keywordflow">else</span> {
02131                     DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a> = 0;
02132                 }
02133 
02134                 <span class="comment">//</span>
02135                 <span class="comment">// Initialize the infinity and NaN values.</span>
02136                 <span class="comment">//</span>
02137 
02138                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o5">Infinity</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02139                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o6">Nan</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02140 
02141                 <span class="comment">//</span>
02142                 <span class="comment">// Compute the exponent value and normalize the quadword</span>
02143                 <span class="comment">// value.</span>
02144                 <span class="comment">//</span>
02145 
02146                 <span class="keywordflow">if</span> (u.Quadword != 0) {
02147                     DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a> = DOUBLE_EXPONENT_BIAS + 63;
02148                     <span class="keywordflow">while</span> (u.Quadword &gt; 0) {
02149                         u.Quadword &lt;&lt;= 1;
02150                         DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a> -= 1;
02151                     }
02152 
02153                     DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o2">Mantissa</a> = (ULONGLONG)u.Quadword &gt;&gt; (64 - 55);
02154                     StickyBits = (u.Quadword &lt;&lt; 55) ? 1 : 0;
02155 
02156                 } <span class="keywordflow">else</span> {
02157                     DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o2">Mantissa</a> = 0;
02158                     StickyBits = 0;
02159                     DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a> = 0;
02160                 }
02161 
02162                 <span class="comment">//</span>
02163                 <span class="comment">// Normalize and store the result value.</span>
02164                 <span class="comment">//</span>
02165 
02166                 <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a24">KiNormalizeDouble</a>(&amp;ContextBlock,
02167                                          &amp;DoubleOperand1,
02168                                          StickyBits);
02169 
02170             } <span class="keywordflow">else</span> {
02171                 <span class="keywordflow">break</span>;
02172             }
02173 
02174             <span class="comment">//</span>
02175             <span class="comment">// Floating convert to quadword.</span>
02176             <span class="comment">//</span>
02177             <span class="comment">// This operation is only legal for conversion from double</span>
02178             <span class="comment">// and single formats to quadword format. This operation</span>
02179             <span class="comment">// cannot be used to convert from a quadword format to a</span>
02180             <span class="comment">// longword or quadword format.</span>
02181             <span class="comment">//</span>
02182             <span class="comment">// Floating conversion to quadword is accomplished by forming</span>
02183             <span class="comment">// a quadword value from a single or double floating value.</span>
02184             <span class="comment">//</span>
02185             <span class="comment">// There is one general conversion operation and four directed</span>
02186             <span class="comment">// rounding operations.</span>
02187             <span class="comment">//</span>
02188 
02189         <span class="keywordflow">case</span> FLOAT_ROUND_QUADWORD:
02190             ContextBlock.<a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o5">Round</a> = ROUND_TO_NEAREST;
02191             <span class="keywordflow">goto</span> ConvertQuadword;
02192 
02193         <span class="keywordflow">case</span> FLOAT_TRUNC_QUADWORD:
02194             ContextBlock.<a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o5">Round</a> = ROUND_TO_ZERO;
02195             <span class="keywordflow">goto</span> ConvertQuadword;
02196 
02197         <span class="keywordflow">case</span> FLOAT_CEIL_QUADWORD:
02198             ContextBlock.<a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o5">Round</a> = ROUND_TO_PLUS_INFINITY;
02199             <span class="keywordflow">goto</span> ConvertQuadword;
02200 
02201         <span class="keywordflow">case</span> FLOAT_FLOOR_QUADWORD:
02202             ContextBlock.<a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o5">Round</a> = ROUND_TO_MINUS_INFINITY;
02203             <span class="keywordflow">goto</span> ConvertQuadword;
02204 
02205         <span class="keywordflow">case</span> FLOAT_CONVERT_QUADWORD:
02206         ConvertQuadword:
02207             <span class="keywordflow">if</span> (Format == FORMAT_SINGLE) {
02208 
02209                 <span class="comment">//</span>
02210                 <span class="comment">// If the operand is infinite or is a NaN, then store a</span>
02211                 <span class="comment">// quiet NaN or an appropriate infinity if the invalid</span>
02212                 <span class="comment">// operation trap is disabled, or raise an exception if</span>
02213                 <span class="comment">// the invalid trap is enabled.</span>
02214                 <span class="comment">//</span>
02215 
02216                 <span class="keywordflow">if</span> ((SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o3">Infinity</a> != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) ||
02217                     (SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o4">Nan</a> != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>)) {
02218                     <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a22">KiInvalidOperationQuadword</a>(&amp;ContextBlock,
02219                                                       SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o3">Infinity</a>,
02220                                                       SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a>);
02221                 }
02222 
02223                 <span class="comment">//</span>
02224                 <span class="comment">// Transform the single operand to double format.</span>
02225                 <span class="comment">//</span>
02226 
02227                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o2">Mantissa</a> = (LONGLONG)SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> &lt;&lt; (55 - 26);
02228                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a> = SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">Exponent</a> +
02229                                     DOUBLE_EXPONENT_BIAS - SINGLE_EXPONENT_BIAS;
02230 
02231                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a> = SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a>;
02232                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o5">Infinity</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02233                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o6">Nan</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02234 
02235                 <span class="comment">//</span>
02236                 <span class="comment">// Convert double to quadword and store the result value.</span>
02237                 <span class="comment">//</span>
02238 
02239                 <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a26">KiNormalizeQuadword</a>(&amp;ContextBlock, &amp;DoubleOperand1);
02240 
02241             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Format == FORMAT_DOUBLE) {
02242 
02243                 <span class="comment">//</span>
02244                 <span class="comment">// If the operand is infinite or is a NaN, then store a</span>
02245                 <span class="comment">// quiet NaN or an appropriate infinity if the invalid</span>
02246                 <span class="comment">// operation trap is disabled, or raise an exception if</span>
02247                 <span class="comment">// the invalid trap is enabled.</span>
02248                 <span class="comment">//</span>
02249 
02250                 <span class="keywordflow">if</span> ((DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o5">Infinity</a> != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) ||
02251                     (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o6">Nan</a> != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>)) {
02252                     <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a22">KiInvalidOperationQuadword</a>(&amp;ContextBlock,
02253                                                       DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o5">Infinity</a>,
02254                                                       DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a>);
02255                 }
02256 
02257                 <span class="comment">//</span>
02258                 <span class="comment">// Convert double to quadword and store the result value.</span>
02259                 <span class="comment">//</span>
02260 
02261                 <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a26">KiNormalizeQuadword</a>(&amp;ContextBlock, &amp;DoubleOperand1);
02262 
02263             } <span class="keywordflow">else</span> {
02264                 <span class="keywordflow">break</span>;
02265             }
02266 
02267             <span class="comment">//</span>
02268             <span class="comment">// Floating convert to longword.</span>
02269             <span class="comment">//</span>
02270             <span class="comment">// This operation is only legal for conversion from double</span>
02271             <span class="comment">// and single formats to longword format. This operation</span>
02272             <span class="comment">// cannot be used to convert from a longword format to a</span>
02273             <span class="comment">// longword format.</span>
02274             <span class="comment">//</span>
02275             <span class="comment">// Floating conversion to longword is accomplished by forming</span>
02276             <span class="comment">// a longword value from a single or double floating value.</span>
02277             <span class="comment">//</span>
02278             <span class="comment">// There is one general conversion operation and four directed</span>
02279             <span class="comment">// rounding operations.</span>
02280             <span class="comment">//</span>
02281 
02282         <span class="keywordflow">case</span> FLOAT_ROUND_LONGWORD:
02283             ContextBlock.<a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o5">Round</a> = ROUND_TO_NEAREST;
02284             <span class="keywordflow">goto</span> ConvertLongword;
02285 
02286         <span class="keywordflow">case</span> FLOAT_TRUNC_LONGWORD:
02287             ContextBlock.<a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o5">Round</a> = ROUND_TO_ZERO;
02288             <span class="keywordflow">goto</span> ConvertLongword;
02289 
02290         <span class="keywordflow">case</span> FLOAT_CEIL_LONGWORD:
02291             ContextBlock.<a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o5">Round</a> = ROUND_TO_PLUS_INFINITY;
02292             <span class="keywordflow">goto</span> ConvertLongword;
02293 
02294         <span class="keywordflow">case</span> FLOAT_FLOOR_LONGWORD:
02295             ContextBlock.<a class="code" href="../../d1/d0/struct__FP__CONTEXT__BLOCK.html#o5">Round</a> = ROUND_TO_MINUS_INFINITY;
02296             <span class="keywordflow">goto</span> ConvertLongword;
02297 
02298         <span class="keywordflow">case</span> FLOAT_CONVERT_LONGWORD:
02299         ConvertLongword:
02300             <span class="keywordflow">if</span> (Format == FORMAT_SINGLE) {
02301 
02302                 <span class="comment">//</span>
02303                 <span class="comment">// If the operand is infinite or is a NaN, then store a</span>
02304                 <span class="comment">// quiet NaN or an appropriate infinity if the invalid</span>
02305                 <span class="comment">// operation trap is disabled, or raise an exception if</span>
02306                 <span class="comment">// the invalid trap is enabled.</span>
02307                 <span class="comment">//</span>
02308 
02309                 <span class="keywordflow">if</span> ((SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o3">Infinity</a> != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) ||
02310                     (SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o4">Nan</a> != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>)) {
02311                     <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a21">KiInvalidOperationLongword</a>(&amp;ContextBlock,
02312                                                       SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o3">Infinity</a>,
02313                                                       SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a>);
02314                 }
02315 
02316                 <span class="comment">//</span>
02317                 <span class="comment">// Transform the single operand to double format.</span>
02318                 <span class="comment">//</span>
02319 
02320                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o0">MantissaHigh</a> =
02321                             SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> &gt;&gt; (26 - (55 - 32));
02322                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o1">MantissaLow</a> =
02323                             SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o0">Mantissa</a> &lt;&lt; (32 - (26 - (55 - 32)));
02324                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o3">Exponent</a> = SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o1">Exponent</a> +
02325                                     DOUBLE_EXPONENT_BIAS - SINGLE_EXPONENT_BIAS;
02326                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a> = SingleOperand1.<a class="code" href="../../d5/d0/struct__FP__SINGLE__OPERAND.html#o2">Sign</a>;
02327                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o5">Infinity</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02328                 DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o6">Nan</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02329 
02330                 <span class="comment">//</span>
02331                 <span class="comment">// Convert double to longword and store the result value.</span>
02332                 <span class="comment">//</span>
02333 
02334                 <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a25">KiNormalizeLongword</a>(&amp;ContextBlock, &amp;DoubleOperand1);
02335 
02336             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Format == FORMAT_DOUBLE) {
02337 
02338                 <span class="comment">//</span>
02339                 <span class="comment">// If the operand is infinite or is a NaN, then store a</span>
02340                 <span class="comment">// quiet NaN or an appropriate infinity if the invalid</span>
02341                 <span class="comment">// operation trap is disabled, or raise an exception if</span>
02342                 <span class="comment">// the invalid trap is enabled.</span>
02343                 <span class="comment">//</span>
02344 
02345                 <span class="keywordflow">if</span> ((DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o5">Infinity</a> != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) ||
02346                     (DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o6">Nan</a> != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>)) {
02347                     <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a21">KiInvalidOperationLongword</a>(&amp;ContextBlock,
02348                                                       DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o5">Infinity</a>,
02349                                                       DoubleOperand1.<a class="code" href="../../d2/d0/struct__FP__DOUBLE__OPERAND.html#o4">Sign</a>);
02350                 }
02351 
02352                 <span class="comment">//</span>
02353                 <span class="comment">// Convert double to longword and store the result value.</span>
02354                 <span class="comment">//</span>
02355 
02356                 <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a25">KiNormalizeLongword</a>(&amp;ContextBlock, &amp;DoubleOperand1);
02357 
02358             } <span class="keywordflow">else</span> {
02359                 <span class="keywordflow">break</span>;
02360             }
02361 
02362             <span class="comment">//</span>
02363             <span class="comment">// An illegal function, format value, or field value.</span>
02364             <span class="comment">//</span>
02365 
02366         <span class="keywordflow">default</span> :
02367             <span class="keywordflow">break</span>;
02368         }
02369 
02370         <span class="comment">//</span>
02371         <span class="comment">// An illegal function, format value, or field value was encoutnered.</span>
02372         <span class="comment">// Generate and illegal instruction exception.</span>
02373         <span class="comment">//</span>
02374 
02375         ExceptionRecord-&gt;ExceptionCode = STATUS_ILLEGAL_INSTRUCTION;
02376         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02377 
02378     <span class="comment">//</span>
02379     <span class="comment">// If an exception occurs, then copy the new exception information to the</span>
02380     <span class="comment">// original exception record and handle the exception.</span>
02381     <span class="comment">//</span>
02382 
02383     } except (<a class="code" href="../../d2/d9/ppc_2exceptn_8c.html#a12">KiCopyInformation</a>(ExceptionRecord,
02384                                (GetExceptionInformation())-&gt;ExceptionRecord)) {
02385 
02386         <span class="comment">//</span>
02387         <span class="comment">// Preserve the original exception address and branch destination.</span>
02388         <span class="comment">//</span>
02389 
02390         ExceptionRecord-&gt;ExceptionAddress = ExceptionAddress;
02391         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02392     }
02393 }
02394 
02395 BOOLEAN
02396 <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a16">KiDivideByZeroDouble</a> (
02397     IN PFP_CONTEXT_BLOCK ContextBlock,
02398     IN PFP_DOUBLE_OPERAND DoubleOperand1,
02399     IN PFP_DOUBLE_OPERAND DoubleOperand2
02400     )
02401 
02402 <span class="comment">/*++</span>
02403 <span class="comment"></span>
02404 <span class="comment">Routine Description:</span>
02405 <span class="comment"></span>
02406 <span class="comment">    This function is called to either raise an exception or store a</span>
02407 <span class="comment">    quiet NaN or properly signed infinity for a divide by zero double</span>
02408 <span class="comment">    floating operation.</span>
02409 <span class="comment"></span>
02410 <span class="comment">Arguments:</span>
02411 <span class="comment"></span>
02412 <span class="comment">    ContextBlock - Supplies a pointer to the emulation context block.</span>
02413 <span class="comment"></span>
02414 <span class="comment">    DoubleOperand1 - Supplies a pointer to the first operand value.</span>
02415 <span class="comment"></span>
02416 <span class="comment">    DoubleOperand2 - Supplies a pointer ot the second operand value.</span>
02417 <span class="comment"></span>
02418 <span class="comment">Return Value:</span>
02419 <span class="comment"></span>
02420 <span class="comment">    If the divide by zero trap is enabled and the dividend is not infinite,</span>
02421 <span class="comment">    then a value of FALSE is returned. Otherwise, a quite NaN or a properly</span>
02422 <span class="comment">    signed infinity is stored as the destination result and a value of TRUE</span>
02423 <span class="comment">    is returned.</span>
02424 <span class="comment"></span>
02425 <span class="comment">--*/</span>
02426 
02427 {
02428 
02429     PEXCEPTION_RECORD ExceptionRecord;
02430     PFP_IEEE_VALUE IeeeValue;
02431     ULONG ResultSign;
02432     ULONG ResultValueHigh;
02433     ULONG ResultValueLow;
02434     PKTRAP_FRAME TrapFrame;
02435 
02436     <span class="comment">//</span>
02437     <span class="comment">// The result value is a properly signed infinity.</span>
02438     <span class="comment">//</span>
02439 
02440     ResultSign = DoubleOperand1-&gt;Sign ^ DoubleOperand2-&gt;Sign;
02441     ResultValueHigh = DOUBLE_INFINITY_VALUE_HIGH | (ResultSign &lt;&lt; 31);
02442     ResultValueLow = DOUBLE_INFINITY_VALUE_LOW;
02443 
02444     <span class="comment">//</span>
02445     <span class="comment">// If the first operand is not infinite and the divide by zero trap is</span>
02446     <span class="comment">// enabled, then store the proper exception code and exception flags</span>
02447     <span class="comment">// and return a value of FALSE. Otherwise, store the appropriatly signed</span>
02448     <span class="comment">// infinity and return a value of TRUE.</span>
02449     <span class="comment">//</span>
02450 
02451     ExceptionRecord = ContextBlock-&gt;ExceptionRecord;
02452     TrapFrame = ContextBlock-&gt;TrapFrame;
02453     <span class="keywordflow">if</span> (DoubleOperand1-&gt;Infinity == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
02454         ((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;SZ = 1;
02455         <span class="keywordflow">if</span> (((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;EZ != 0) {
02456             ExceptionRecord-&gt;ExceptionCode = STATUS_FLOAT_DIVIDE_BY_ZERO;
02457             ((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;XZ = 1;
02458             IeeeValue = (PFP_IEEE_VALUE)&amp;ExceptionRecord-&gt;ExceptionInformation[2];
02459             IeeeValue-&gt;Value.Fp64Value.W[0] = ResultValueLow;
02460             IeeeValue-&gt;Value.Fp64Value.W[1] = ResultValueHigh;
02461             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02462         }
02463     }
02464 
02465     <a class="code" href="../../d8/d5/ppc_2getsetrg_8c.html#a1">KiSetRegisterValue</a>(ContextBlock-&gt;Fd + 32,
02466                        ResultValueLow,
02467                        ContextBlock-&gt;ExceptionFrame,
02468                        ContextBlock-&gt;TrapFrame);
02469 
02470     <a class="code" href="../../d8/d5/ppc_2getsetrg_8c.html#a1">KiSetRegisterValue</a>(ContextBlock-&gt;Fd + 32 + 1,
02471                        ResultValueHigh,
02472                        ContextBlock-&gt;ExceptionFrame,
02473                        ContextBlock-&gt;TrapFrame);
02474 
02475     TrapFrame-&gt;Fir = ContextBlock-&gt;BranchAddress;
02476     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02477 }
02478 
02479 BOOLEAN
02480 <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a17">KiDivideByZeroSingle</a> (
02481     IN PFP_CONTEXT_BLOCK ContextBlock,
02482     IN PFP_SINGLE_OPERAND SingleOperand1,
02483     IN PFP_SINGLE_OPERAND SingleOperand2
02484     )
02485 
02486 <span class="comment">/*++</span>
02487 <span class="comment"></span>
02488 <span class="comment">Routine Description:</span>
02489 <span class="comment"></span>
02490 <span class="comment">    This function is called to either raise an exception or store a</span>
02491 <span class="comment">    quiet NaN or properly signed infinity for a divide by zero single</span>
02492 <span class="comment">    floating operation.</span>
02493 <span class="comment"></span>
02494 <span class="comment">Arguments:</span>
02495 <span class="comment"></span>
02496 <span class="comment">    ContextBlock - Supplies a pointer to the emulation context block.</span>
02497 <span class="comment"></span>
02498 <span class="comment">    SingleOperand1 - Supplies a pointer to the first operand value.</span>
02499 <span class="comment"></span>
02500 <span class="comment">    SingleOperand2 - Supplies a pointer ot the second operand value.</span>
02501 <span class="comment"></span>
02502 <span class="comment">Return Value:</span>
02503 <span class="comment"></span>
02504 <span class="comment">    If the divide by zero trap is enabled and the dividend is not infinite,</span>
02505 <span class="comment">    then a value of FALSE is returned. Otherwise, a quite NaN is or properly</span>
02506 <span class="comment">    signed infinity is stored as the destination result and a value of TRUE</span>
02507 <span class="comment">    is returned.</span>
02508 <span class="comment"></span>
02509 <span class="comment">--*/</span>
02510 
02511 {
02512 
02513     PEXCEPTION_RECORD ExceptionRecord;
02514     PFP_IEEE_VALUE IeeeValue;
02515     ULONG ResultSign;
02516     ULONG ResultValue;
02517     PKTRAP_FRAME TrapFrame;
02518 
02519     <span class="comment">//</span>
02520     <span class="comment">// The result value is a properly signed infinity.</span>
02521     <span class="comment">//</span>
02522 
02523     ResultSign = SingleOperand1-&gt;Sign ^ SingleOperand2-&gt;Sign;
02524     ResultValue = SINGLE_INFINITY_VALUE | (ResultSign &lt;&lt; 31);
02525 
02526     <span class="comment">//</span>
02527     <span class="comment">// If the first operand is not infinite and the divide by zero trap is</span>
02528     <span class="comment">// enabled, then store the proper exception code and exception flags</span>
02529     <span class="comment">// and return a value of FALSE. Otherwise, store the appropriatly signed</span>
02530     <span class="comment">// infinity and return a value of TRUE.</span>
02531     <span class="comment">//</span>
02532     <span class="comment">//</span>
02533 
02534     ExceptionRecord = ContextBlock-&gt;ExceptionRecord;
02535     TrapFrame = ContextBlock-&gt;TrapFrame;
02536     <span class="keywordflow">if</span> (SingleOperand1-&gt;Infinity == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
02537         ((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;SZ = 1;
02538         <span class="keywordflow">if</span> (((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;EZ != 0) {
02539             ExceptionRecord-&gt;ExceptionCode = STATUS_FLOAT_DIVIDE_BY_ZERO;
02540             ((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;XZ = 1;
02541             IeeeValue = (PFP_IEEE_VALUE)&amp;ExceptionRecord-&gt;ExceptionInformation[2];
02542             IeeeValue-&gt;Value.Fp32Value.W[0] = ResultValue;
02543             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02544         }
02545     }
02546 
02547     <a class="code" href="../../d8/d5/ppc_2getsetrg_8c.html#a1">KiSetRegisterValue</a>(ContextBlock-&gt;Fd + 32,
02548                        ResultValue,
02549                        ContextBlock-&gt;ExceptionFrame,
02550                        ContextBlock-&gt;TrapFrame);
02551 
02552     TrapFrame-&gt;Fir = ContextBlock-&gt;BranchAddress;
02553     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02554 }
02555 
02556 BOOLEAN
02557 <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a18">KiInvalidCompareDouble</a> (
02558     IN PFP_CONTEXT_BLOCK ContextBlock,
02559     IN BOOLEAN CheckForNan,
02560     IN PFP_DOUBLE_OPERAND DoubleOperand1,
02561     IN PFP_DOUBLE_OPERAND DoubleOperand2
02562     )
02563 
02564 <span class="comment">/*++</span>
02565 <span class="comment"></span>
02566 <span class="comment">Routine Description:</span>
02567 <span class="comment"></span>
02568 <span class="comment">    This function is called to determine whether an invalid operation</span>
02569 <span class="comment">    exception should be raised for a double compare operation.</span>
02570 <span class="comment"></span>
02571 <span class="comment">Arguments:</span>
02572 <span class="comment"></span>
02573 <span class="comment">    ContextBlock - Supplies a pointer to the emulation context block.</span>
02574 <span class="comment"></span>
02575 <span class="comment">    CheckForNan - Supplies a boolean value that detetermines whether the</span>
02576 <span class="comment">        operand values should be checked for a signaling NaN.</span>
02577 <span class="comment"></span>
02578 <span class="comment">    DoubleOperand1 - Supplies a pointer to the first operand value.</span>
02579 <span class="comment"></span>
02580 <span class="comment">    DoubleOperand2 - Supplies a pointer ot the second operand value.</span>
02581 <span class="comment"></span>
02582 <span class="comment">Return Value:</span>
02583 <span class="comment"></span>
02584 <span class="comment">    If the invalid operation trap is enabled and either the operation is</span>
02585 <span class="comment">    invalid or one of the operands in a signaling NaN, then a value of</span>
02586 <span class="comment">    FALSE is returned. Otherwise, no operation is performed and a value</span>
02587 <span class="comment">    of TRUE is returned.</span>
02588 <span class="comment"></span>
02589 <span class="comment">--*/</span>
02590 
02591 {
02592 
02593     PEXCEPTION_RECORD ExceptionRecord;
02594     PFP_IEEE_VALUE IeeeValue;
02595     PKTRAP_FRAME TrapFrame;
02596 
02597     <span class="comment">//</span>
02598     <span class="comment">// If an invalid operation is specified or one of the operands is a</span>
02599     <span class="comment">// signaling NaN and the invalid operation trap is enabled, then</span>
02600     <span class="comment">// store the proper exception code and exception flags and return</span>
02601     <span class="comment">// a value of FALSE. Otherwise, perform no operation and return a</span>
02602     <span class="comment">// value of TRUE.</span>
02603     <span class="comment">//</span>
02604 
02605     ExceptionRecord = ContextBlock-&gt;ExceptionRecord;
02606     TrapFrame = ContextBlock-&gt;TrapFrame;
02607     <span class="keywordflow">if</span> ((CheckForNan == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) ||
02608         ((DoubleOperand1-&gt;Nan != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
02609         ((DoubleOperand1-&gt;MantissaHigh &amp; <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a0">DOUBLE_SIGNAL_NAN_MASK</a>) != 0)) ||
02610         ((DoubleOperand2-&gt;Nan != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
02611         ((DoubleOperand2-&gt;MantissaHigh &amp; <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a0">DOUBLE_SIGNAL_NAN_MASK</a>) != 0))) {
02612         ((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;SV = 1;
02613         <span class="keywordflow">if</span> (((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;EV != 0) {
02614             ExceptionRecord-&gt;ExceptionCode = STATUS_FLOAT_INVALID_OPERATION;
02615             ((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;XV = 1;
02616             IeeeValue = (PFP_IEEE_VALUE)&amp;ExceptionRecord-&gt;ExceptionInformation[2];
02617             IeeeValue-&gt;Value.CompareValue = FpCompareUnordered;
02618             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02619         }
02620     }
02621 
02622     TrapFrame-&gt;Fir = ContextBlock-&gt;BranchAddress;
02623     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02624 }
02625 
02626 BOOLEAN
<a name="l02627"></a><a class="code" href="../../d3/d4/mips_2floatem_8c.html#a19">02627</a> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a19">KiInvalidCompareSingle</a> (
02628     IN PFP_CONTEXT_BLOCK ContextBlock,
02629     IN BOOLEAN CheckForNan,
02630     IN PFP_SINGLE_OPERAND SingleOperand1,
02631     IN PFP_SINGLE_OPERAND SingleOperand2
02632     )
02633 
02634 <span class="comment">/*++</span>
02635 <span class="comment"></span>
02636 <span class="comment">Routine Description:</span>
02637 <span class="comment"></span>
02638 <span class="comment">    This function is called to determine whether an invalid operation</span>
02639 <span class="comment">    exception should be raised for a single compare operation.</span>
02640 <span class="comment"></span>
02641 <span class="comment">Arguments:</span>
02642 <span class="comment"></span>
02643 <span class="comment">    ContextBlock - Supplies a pointer to the emulation context block.</span>
02644 <span class="comment"></span>
02645 <span class="comment">    CheckForNan - Supplies a boolean value that detetermines whether the</span>
02646 <span class="comment">        operand values should be checked for a signaling NaN.</span>
02647 <span class="comment"></span>
02648 <span class="comment">    SingleOperand1 - Supplies a pointer to the first operand value.</span>
02649 <span class="comment"></span>
02650 <span class="comment">    SingleOperand2 - Supplies a pointer ot the second operand value.</span>
02651 <span class="comment"></span>
02652 <span class="comment">Return Value:</span>
02653 <span class="comment"></span>
02654 <span class="comment">    If the invalid operation trap is enabled and either the operation is</span>
02655 <span class="comment">    invalid or one of the operands in a signaling NaN, then a value of</span>
02656 <span class="comment">    FALSE is returned. Otherwise, no operation is performed and a value</span>
02657 <span class="comment">    of TRUE is returned.</span>
02658 <span class="comment"></span>
02659 <span class="comment">--*/</span>
02660 
02661 {
02662 
02663     PEXCEPTION_RECORD ExceptionRecord;
02664     PFP_IEEE_VALUE IeeeValue;
02665     PKTRAP_FRAME TrapFrame;
02666 
02667     <span class="comment">//</span>
02668     <span class="comment">// If an invalid operation is specified or one of the operands is a</span>
02669     <span class="comment">// signaling NaN and the invalid operation trap is enabled, then</span>
02670     <span class="comment">// store the proper exception code and exception flags and return</span>
02671     <span class="comment">// a value of FALSE. Otherwise, perform no operation and return a</span>
02672     <span class="comment">// value of TRUE.</span>
02673     <span class="comment">//</span>
02674 
02675     ExceptionRecord = ContextBlock-&gt;ExceptionRecord;
02676     TrapFrame = ContextBlock-&gt;TrapFrame;
02677     <span class="keywordflow">if</span> ((CheckForNan == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) ||
02678         ((SingleOperand1-&gt;Nan != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
02679         ((SingleOperand1-&gt;Mantissa &amp; <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a1">SINGLE_SIGNAL_NAN_MASK</a>) != 0)) ||
02680         ((SingleOperand2-&gt;Nan != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
02681         ((SingleOperand2-&gt;Mantissa &amp; <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a1">SINGLE_SIGNAL_NAN_MASK</a>) != 0))) {
02682         ((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;SV = 1;
02683         <span class="keywordflow">if</span> (((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;EV != 0) {
02684             ExceptionRecord-&gt;ExceptionCode = STATUS_FLOAT_INVALID_OPERATION;
02685             ((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;XV = 1;
02686             IeeeValue = (PFP_IEEE_VALUE)&amp;ExceptionRecord-&gt;ExceptionInformation[2];
02687             IeeeValue-&gt;Value.CompareValue = FpCompareUnordered;
02688             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02689         }
02690     }
02691 
02692     TrapFrame-&gt;Fir = ContextBlock-&gt;BranchAddress;
02693     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02694 }
02695 
02696 BOOLEAN
02697 <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a20">KiInvalidOperationDouble</a> (
02698     IN PFP_CONTEXT_BLOCK ContextBlock,
02699     IN BOOLEAN CheckForNan,
02700     IN PFP_DOUBLE_OPERAND DoubleOperand1,
02701     IN PFP_DOUBLE_OPERAND DoubleOperand2
02702     )
02703 
02704 <span class="comment">/*++</span>
02705 <span class="comment"></span>
02706 <span class="comment">Routine Description:</span>
02707 <span class="comment"></span>
02708 <span class="comment">    This function is called to either raise and exception or store a</span>
02709 <span class="comment">    quiet NaN for an invalid double floating operation.</span>
02710 <span class="comment"></span>
02711 <span class="comment">Arguments:</span>
02712 <span class="comment"></span>
02713 <span class="comment">    ContextBlock - Supplies a pointer to the emulation context block.</span>
02714 <span class="comment"></span>
02715 <span class="comment">    CheckForNan - Supplies a boolean value that detetermines whether the</span>
02716 <span class="comment">        operand values should be checked for a signaling NaN.</span>
02717 <span class="comment"></span>
02718 <span class="comment">    DoubleOperand1 - Supplies a pointer to the first operand value.</span>
02719 <span class="comment"></span>
02720 <span class="comment">    DoubleOperand2 - Supplies a pointer ot the second operand value.</span>
02721 <span class="comment"></span>
02722 <span class="comment">Return Value:</span>
02723 <span class="comment"></span>
02724 <span class="comment">    If the invalid operation trap is enabled and either the operation is</span>
02725 <span class="comment">    invalid or one of the operands in a signaling NaN, then a value of</span>
02726 <span class="comment">    FALSE is returned. Otherwise, a quite NaN is stored as the destination</span>
02727 <span class="comment">    result and a value of TRUE is returned.</span>
02728 <span class="comment"></span>
02729 <span class="comment">--*/</span>
02730 
02731 {
02732 
02733     PEXCEPTION_RECORD ExceptionRecord;
02734     PFP_IEEE_VALUE IeeeValue;
02735     ULONG MantissaHigh;
02736     ULONG ResultValueHigh;
02737     ULONG ResultValueLow;
02738     PKTRAP_FRAME TrapFrame;
02739 
02740     <span class="comment">//</span>
02741     <span class="comment">// If the first operand is a NaN, then compute a quite NaN from its</span>
02742     <span class="comment">// value. Otherwise, if the second operand is a NaN, then compute a</span>
02743     <span class="comment">// quiet NaN from its value. Otherwise, the result value is a quite</span>
02744     <span class="comment">// NaN.</span>
02745 
02746     <span class="keywordflow">if</span> (DoubleOperand1-&gt;Nan != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
02747         MantissaHigh = DoubleOperand1-&gt;MantissaHigh &amp; ~<a class="code" href="../../d3/d4/mips_2floatem_8c.html#a0">DOUBLE_SIGNAL_NAN_MASK</a>;
02748         <span class="keywordflow">if</span> ((DoubleOperand1-&gt;MantissaLow | MantissaHigh) != 0) {
02749             ResultValueLow = DoubleOperand1-&gt;MantissaLow &gt;&gt; 2;
02750             ResultValueLow |= DoubleOperand1-&gt;MantissaHigh &lt;&lt; 30;
02751             ResultValueHigh = DoubleOperand1-&gt;MantissaHigh &gt;&gt; 2;
02752             ResultValueHigh |= <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a4">DOUBLE_QUIET_NAN_PREFIX</a>;
02753             ResultValueHigh &amp;= ~<a class="code" href="../../d3/d4/mips_2floatem_8c.html#a2">DOUBLE_QUIET_NAN_MASK</a>;
02754 
02755         } <span class="keywordflow">else</span> {
02756             ResultValueLow = DOUBLE_NAN_LOW;
02757             ResultValueHigh = DOUBLE_QUIET_NAN;
02758         }
02759 
02760     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (DoubleOperand2-&gt;Nan != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
02761         MantissaHigh = DoubleOperand2-&gt;MantissaHigh &amp; ~<a class="code" href="../../d3/d4/mips_2floatem_8c.html#a0">DOUBLE_SIGNAL_NAN_MASK</a>;
02762         <span class="keywordflow">if</span> ((DoubleOperand2-&gt;MantissaLow | MantissaHigh) != 0) {
02763             ResultValueLow = DoubleOperand2-&gt;MantissaLow &gt;&gt; 2;
02764             ResultValueLow |= DoubleOperand2-&gt;MantissaHigh &lt;&lt; 30;
02765             ResultValueHigh = DoubleOperand2-&gt;MantissaHigh &gt;&gt; 2;
02766             ResultValueHigh |= <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a4">DOUBLE_QUIET_NAN_PREFIX</a>;
02767             ResultValueHigh &amp;= ~<a class="code" href="../../d3/d4/mips_2floatem_8c.html#a2">DOUBLE_QUIET_NAN_MASK</a>;
02768 
02769         } <span class="keywordflow">else</span> {
02770             ResultValueLow = DOUBLE_NAN_LOW;
02771             ResultValueHigh = DOUBLE_QUIET_NAN;
02772         }
02773 
02774     } <span class="keywordflow">else</span> {
02775         ResultValueLow = DOUBLE_NAN_LOW;
02776         ResultValueHigh = DOUBLE_QUIET_NAN;
02777     }
02778 
02779     <span class="comment">//</span>
02780     <span class="comment">// If an invalid operation is specified or one of the operands is a</span>
02781     <span class="comment">// signaling NaN and the invalid operation trap is enabled, then</span>
02782     <span class="comment">// store the proper exception code and exception flags and return</span>
02783     <span class="comment">// a value of FALSE. Otherwise, store a quiet NaN as the destination</span>
02784     <span class="comment">// result and return a value of TRUE.</span>
02785     <span class="comment">//</span>
02786 
02787     ExceptionRecord = ContextBlock-&gt;ExceptionRecord;
02788     TrapFrame = ContextBlock-&gt;TrapFrame;
02789     <span class="keywordflow">if</span> ((CheckForNan == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) ||
02790         ((DoubleOperand1-&gt;Nan != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
02791         ((DoubleOperand1-&gt;MantissaHigh &amp; <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a0">DOUBLE_SIGNAL_NAN_MASK</a>) != 0)) ||
02792         ((DoubleOperand2-&gt;Nan != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
02793         ((DoubleOperand2-&gt;MantissaHigh &amp; <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a0">DOUBLE_SIGNAL_NAN_MASK</a>) != 0))) {
02794         ((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;SV = 1;
02795         <span class="keywordflow">if</span> (((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;EV != 0) {
02796             ExceptionRecord-&gt;ExceptionCode = STATUS_FLOAT_INVALID_OPERATION;
02797             ((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;XV = 1;
02798             IeeeValue = (PFP_IEEE_VALUE)&amp;ExceptionRecord-&gt;ExceptionInformation[2];
02799             IeeeValue-&gt;Value.Fp64Value.W[0] = ResultValueLow;
02800             IeeeValue-&gt;Value.Fp64Value.W[1] = ResultValueHigh;
02801             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02802         }
02803     }
02804 
02805     <a class="code" href="../../d8/d5/ppc_2getsetrg_8c.html#a1">KiSetRegisterValue</a>(ContextBlock-&gt;Fd + 32,
02806                        ResultValueLow,
02807                        ContextBlock-&gt;ExceptionFrame,
02808                        ContextBlock-&gt;TrapFrame);
02809 
02810     <a class="code" href="../../d8/d5/ppc_2getsetrg_8c.html#a1">KiSetRegisterValue</a>(ContextBlock-&gt;Fd + 32 + 1,
02811                        ResultValueHigh,
02812                        ContextBlock-&gt;ExceptionFrame,
02813                        ContextBlock-&gt;TrapFrame);
02814 
02815     TrapFrame-&gt;Fir = ContextBlock-&gt;BranchAddress;
02816     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02817 }
02818 
02819 BOOLEAN
<a name="l02820"></a><a class="code" href="../../d3/d4/mips_2floatem_8c.html#a21">02820</a> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a21">KiInvalidOperationLongword</a> (
02821     IN PFP_CONTEXT_BLOCK ContextBlock,
02822     IN BOOLEAN Infinity,
02823     IN LONG Sign
02824     )
02825 
02826 <span class="comment">/*++</span>
02827 <span class="comment"></span>
02828 <span class="comment">Routine Description:</span>
02829 <span class="comment"></span>
02830 <span class="comment">    This function is called to either raise and exception or store a</span>
02831 <span class="comment">    quiet NaN for an invalid conversion to longword.</span>
02832 <span class="comment"></span>
02833 <span class="comment">Arguments:</span>
02834 <span class="comment"></span>
02835 <span class="comment">    ContextBlock - Supplies a pointer to the emulation context block.</span>
02836 <span class="comment"></span>
02837 <span class="comment">    Infinity - Suuplies a boolean variable that specifies whether the</span>
02838 <span class="comment">        invalid operand is infinite.</span>
02839 <span class="comment"></span>
02840 <span class="comment">    Sign - Supplies the infinity sign if the invalid operand is infinite.</span>
02841 <span class="comment"></span>
02842 <span class="comment">Return Value:</span>
02843 <span class="comment"></span>
02844 <span class="comment">    If the invalid operation trap is enabled, then a value of FALSE is</span>
02845 <span class="comment">    returned. Otherwise, an appropriate longword value is stored as the</span>
02846 <span class="comment">    destination result and a value of TRUE is returned.</span>
02847 <span class="comment"></span>
02848 <span class="comment">--*/</span>
02849 
02850 {
02851 
02852     PEXCEPTION_RECORD ExceptionRecord;
02853     PFP_IEEE_VALUE IeeeValue;
02854     ULONG ResultValue;
02855     PKTRAP_FRAME TrapFrame;
02856 
02857     <span class="comment">//</span>
02858     <span class="comment">// If the value is infinite, then the result is a properly signed value</span>
02859     <span class="comment">// whose magnitude is the largest that will fit in 32-bits. Otherwise,</span>
02860     <span class="comment">// the result is an integer NaN.</span>
02861     <span class="comment">//</span>
02862 
02863     <span class="keywordflow">if</span> (Infinity != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
02864         <span class="keywordflow">if</span> (Sign == 0) {
02865             ResultValue = 0x7fffffff;
02866 
02867         } <span class="keywordflow">else</span> {
02868             ResultValue = 0x80000000;
02869         }
02870 
02871     } <span class="keywordflow">else</span> {
02872         ResultValue = SINGLE_INTEGER_NAN;
02873     }
02874 
02875     <span class="comment">//</span>
02876     <span class="comment">// If the invalid operation trap is enabled then store the proper</span>
02877     <span class="comment">// exception code and exception flags and return a value of FALSE.</span>
02878     <span class="comment">// Otherwise, store a quiet NaN as the destination result and return</span>
02879     <span class="comment">// a value of TRUE.</span>
02880     <span class="comment">//</span>
02881 
02882     ExceptionRecord = ContextBlock-&gt;ExceptionRecord;
02883     TrapFrame = ContextBlock-&gt;TrapFrame;
02884     ((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;SV = 1;
02885     <span class="keywordflow">if</span> (((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;EV != 0) {
02886         ExceptionRecord-&gt;ExceptionCode = STATUS_FLOAT_INVALID_OPERATION;
02887         ((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;XV = 1;
02888         IeeeValue = (PFP_IEEE_VALUE)&amp;ExceptionRecord-&gt;ExceptionInformation[2];
02889         IeeeValue-&gt;Value.U32Value = ResultValue;
02890         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02891 
02892     } <span class="keywordflow">else</span> {
02893 
02894         <a class="code" href="../../d8/d5/ppc_2getsetrg_8c.html#a1">KiSetRegisterValue</a>(ContextBlock-&gt;Fd + 32,
02895                            ResultValue,
02896                            ContextBlock-&gt;ExceptionFrame,
02897                            ContextBlock-&gt;TrapFrame);
02898 
02899         TrapFrame-&gt;Fir = ContextBlock-&gt;BranchAddress;
02900         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02901     }
02902 }
02903 
02904 BOOLEAN
<a name="l02905"></a><a class="code" href="../../d3/d4/mips_2floatem_8c.html#a22">02905</a> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a22">KiInvalidOperationQuadword</a> (
02906     IN PFP_CONTEXT_BLOCK ContextBlock,
02907     IN BOOLEAN Infinity,
02908     IN LONG Sign
02909     )
02910 
02911 <span class="comment">/*++</span>
02912 <span class="comment"></span>
02913 <span class="comment">Routine Description:</span>
02914 <span class="comment"></span>
02915 <span class="comment">    This function is called to either raise and exception or store a</span>
02916 <span class="comment">    quiet NaN for an invalid conversion to quadword.</span>
02917 <span class="comment"></span>
02918 <span class="comment">Arguments:</span>
02919 <span class="comment"></span>
02920 <span class="comment">    ContextBlock - Supplies a pointer to the emulation context block.</span>
02921 <span class="comment"></span>
02922 <span class="comment">    Infinity - Suuplies a boolean variable that specifies whether the</span>
02923 <span class="comment">        invalid operand is infinite.</span>
02924 <span class="comment"></span>
02925 <span class="comment">    Sign - Supplies the infinity sign if the invalid operand is infinite.</span>
02926 <span class="comment"></span>
02927 <span class="comment">Return Value:</span>
02928 <span class="comment"></span>
02929 <span class="comment">    If the invalid operation trap is enabled, then a value of FALSE is</span>
02930 <span class="comment">    returned. Otherwise, an appropriate longword value is stored as the</span>
02931 <span class="comment">    destination result and a value of TRUE is returned.</span>
02932 <span class="comment"></span>
02933 <span class="comment">--*/</span>
02934 
02935 {
02936 
02937     PEXCEPTION_RECORD ExceptionRecord;
02938     PFP_IEEE_VALUE IeeeValue;
02939     <span class="keyword">union </span>{
02940         ULONGLONG ResultValue;
02941         ULARGE_INTEGER LargeValue;
02942     }u;
02943 
02944     PKTRAP_FRAME TrapFrame;
02945 
02946     <span class="comment">//</span>
02947     <span class="comment">// If the value is infinite, then the result is a properly signed value</span>
02948     <span class="comment">// whose magnitude is the largest that will fit in 64-bits. Otherwise,</span>
02949     <span class="comment">// the result is an integer NaN.</span>
02950     <span class="comment">//</span>
02951 
02952     <span class="keywordflow">if</span> (Infinity != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
02953         <span class="keywordflow">if</span> (Sign == 0) {
02954             u.ResultValue = 0x7fffffffffffffff;
02955 
02956         } <span class="keywordflow">else</span> {
02957             u.ResultValue = 0x8000000000000000;
02958         }
02959 
02960     } <span class="keywordflow">else</span> {
02961         u.ResultValue = DOUBLE_INTEGER_NAN;
02962     }
02963 
02964     <span class="comment">//</span>
02965     <span class="comment">// If the invalid operation trap is enabled then store the proper</span>
02966     <span class="comment">// exception code and exception flags and return a value of FALSE.</span>
02967     <span class="comment">// Otherwise, store a quiet NaN as the destination result and return</span>
02968     <span class="comment">// a value of TRUE.</span>
02969     <span class="comment">//</span>
02970 
02971     ExceptionRecord = ContextBlock-&gt;ExceptionRecord;
02972     TrapFrame = ContextBlock-&gt;TrapFrame;
02973     ((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;SV = 1;
02974     <span class="keywordflow">if</span> (((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;EV != 0) {
02975         ExceptionRecord-&gt;ExceptionCode = STATUS_FLOAT_INVALID_OPERATION;
02976         ((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;XV = 1;
02977         IeeeValue = (PFP_IEEE_VALUE)&amp;ExceptionRecord-&gt;ExceptionInformation[2];
02978         IeeeValue-&gt;Value.U64Value.QuadPart = u.ResultValue;
02979         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02980 
02981     } <span class="keywordflow">else</span> {
02982 
02983         <a class="code" href="../../d8/d5/ppc_2getsetrg_8c.html#a1">KiSetRegisterValue</a>(ContextBlock-&gt;Fd + 32,
02984                            u.LargeValue.LowPart,
02985                            ContextBlock-&gt;ExceptionFrame,
02986                            ContextBlock-&gt;TrapFrame);
02987 
02988         <a class="code" href="../../d8/d5/ppc_2getsetrg_8c.html#a1">KiSetRegisterValue</a>(ContextBlock-&gt;Fd + 33,
02989                            u.LargeValue.HighPart,
02990                            ContextBlock-&gt;ExceptionFrame,
02991                            ContextBlock-&gt;TrapFrame);
02992 
02993         TrapFrame-&gt;Fir = ContextBlock-&gt;BranchAddress;
02994         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02995     }
02996 }
02997 
02998 BOOLEAN
02999 <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a23">KiInvalidOperationSingle</a> (
03000     IN PFP_CONTEXT_BLOCK ContextBlock,
03001     IN BOOLEAN CheckForNan,
03002     IN PFP_SINGLE_OPERAND SingleOperand1,
03003     IN PFP_SINGLE_OPERAND SingleOperand2
03004     )
03005 
03006 <span class="comment">/*++</span>
03007 <span class="comment"></span>
03008 <span class="comment">Routine Description:</span>
03009 <span class="comment"></span>
03010 <span class="comment">    This function is called to either raise and exception or store a</span>
03011 <span class="comment">    quiet NaN for an invalid single floating operation.</span>
03012 <span class="comment"></span>
03013 <span class="comment">Arguments:</span>
03014 <span class="comment"></span>
03015 <span class="comment">    ContextBlock - Supplies a pointer to the emulation context block.</span>
03016 <span class="comment"></span>
03017 <span class="comment">    CheckForNan - Supplies a boolean value that detetermines whether the</span>
03018 <span class="comment">        operand values should be checked for a signaling NaN.</span>
03019 <span class="comment"></span>
03020 <span class="comment">    SingleOperand1 - Supplies a pointer to the first operand value.</span>
03021 <span class="comment"></span>
03022 <span class="comment">    SingleOperand2 - Supplies a pointer ot the second operand value.</span>
03023 <span class="comment"></span>
03024 <span class="comment">Return Value:</span>
03025 <span class="comment"></span>
03026 <span class="comment">    If the invalid operation trap is enabled and either the operation is</span>
03027 <span class="comment">    invalid or one of the operands in a signaling NaN, then a value of</span>
03028 <span class="comment">    FALSE is returned. Otherwise, a quite NaN is stored as the destination</span>
03029 <span class="comment">    result and a value of TRUE is returned.</span>
03030 <span class="comment"></span>
03031 <span class="comment">--*/</span>
03032 
03033 {
03034 
03035     PEXCEPTION_RECORD ExceptionRecord;
03036     PFP_IEEE_VALUE IeeeValue;
03037     ULONG ResultValue;
03038     PKTRAP_FRAME TrapFrame;
03039 
03040     <span class="comment">//</span>
03041     <span class="comment">// If the first operand is a NaN, then compute a quite NaN from its</span>
03042     <span class="comment">// value. Otherwise, if the second operand is a NaN, then compute a</span>
03043     <span class="comment">// quiet NaN from its value. Otherwise, the result value is a quite</span>
03044     <span class="comment">// NaN.</span>
03045 
03046     <span class="keywordflow">if</span> (SingleOperand1-&gt;Nan != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
03047         <span class="keywordflow">if</span> ((SingleOperand1-&gt;Mantissa  &amp; ~<a class="code" href="../../d3/d4/mips_2floatem_8c.html#a1">SINGLE_SIGNAL_NAN_MASK</a>) != 0) {
03048             ResultValue = SingleOperand1-&gt;Mantissa &gt;&gt; 2;
03049             ResultValue |= <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a5">SINGLE_QUIET_NAN_PREFIX</a>;
03050             ResultValue &amp;= ~<a class="code" href="../../d3/d4/mips_2floatem_8c.html#a3">SINGLE_QUIET_NAN_MASK</a>;
03051 
03052         } <span class="keywordflow">else</span> {
03053             ResultValue = SINGLE_QUIET_NAN;
03054         }
03055 
03056     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (SingleOperand2-&gt;Nan != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
03057         <span class="keywordflow">if</span> ((SingleOperand2-&gt;Mantissa &amp; ~<a class="code" href="../../d3/d4/mips_2floatem_8c.html#a1">SINGLE_SIGNAL_NAN_MASK</a>) != 0) {
03058             ResultValue = SingleOperand2-&gt;Mantissa &gt;&gt; 2;
03059             ResultValue |= <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a5">SINGLE_QUIET_NAN_PREFIX</a>;
03060             ResultValue &amp;= ~<a class="code" href="../../d3/d4/mips_2floatem_8c.html#a3">SINGLE_QUIET_NAN_MASK</a>;
03061 
03062         } <span class="keywordflow">else</span> {
03063             ResultValue = SINGLE_QUIET_NAN;
03064         }
03065 
03066     } <span class="keywordflow">else</span> {
03067         ResultValue = SINGLE_QUIET_NAN;
03068     }
03069 
03070     <span class="comment">//</span>
03071     <span class="comment">// If an invalid operation is specified or one of the operands is a</span>
03072     <span class="comment">// signaling NaN and the invalid operation trap is enabled, then</span>
03073     <span class="comment">// store the proper exception code and exception flags and return</span>
03074     <span class="comment">// a value of FALSE. Otherwise, store a quiet NaN as the destination</span>
03075     <span class="comment">// result and return a value of TRUE.</span>
03076     <span class="comment">//</span>
03077 
03078     ExceptionRecord = ContextBlock-&gt;ExceptionRecord;
03079     TrapFrame = ContextBlock-&gt;TrapFrame;
03080     <span class="keywordflow">if</span> ((CheckForNan == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) ||
03081         ((SingleOperand1-&gt;Nan != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
03082         ((SingleOperand1-&gt;Mantissa &amp; <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a1">SINGLE_SIGNAL_NAN_MASK</a>) != 0)) ||
03083         ((SingleOperand2-&gt;Nan != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
03084         ((SingleOperand2-&gt;Mantissa &amp; <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a1">SINGLE_SIGNAL_NAN_MASK</a>) != 0))) {
03085         ((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;SV = 1;
03086         <span class="keywordflow">if</span> (((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;EV != 0) {
03087             ExceptionRecord-&gt;ExceptionCode = STATUS_FLOAT_INVALID_OPERATION;
03088             ((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;XV = 1;
03089             IeeeValue = (PFP_IEEE_VALUE)&amp;ExceptionRecord-&gt;ExceptionInformation[2];
03090             IeeeValue-&gt;Value.Fp32Value.W[0] = ResultValue;
03091             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03092         }
03093     }
03094 
03095     <a class="code" href="../../d8/d5/ppc_2getsetrg_8c.html#a1">KiSetRegisterValue</a>(ContextBlock-&gt;Fd + 32,
03096                        ResultValue,
03097                        ContextBlock-&gt;ExceptionFrame,
03098                        ContextBlock-&gt;TrapFrame);
03099 
03100     TrapFrame-&gt;Fir = ContextBlock-&gt;BranchAddress;
03101     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03102 }
03103 
03104 BOOLEAN
<a name="l03105"></a><a class="code" href="../../d3/d4/mips_2floatem_8c.html#a24">03105</a> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a24">KiNormalizeDouble</a> (
03106     IN PFP_CONTEXT_BLOCK ContextBlock,
03107     IN PFP_DOUBLE_OPERAND ResultOperand,
03108     IN ULONG StickyBits
03109     )
03110 
03111 <span class="comment">/*++</span>
03112 <span class="comment"></span>
03113 <span class="comment">Routine Description:</span>
03114 <span class="comment"></span>
03115 <span class="comment">    This function is called to normalize a double floating result.</span>
03116 <span class="comment"></span>
03117 <span class="comment">    N.B. The result value is specified with a guard bit on the right,</span>
03118 <span class="comment">        the hidden bit (if appropriate), and a possible overflow bit.</span>
03119 <span class="comment">        The result format is:</span>
03120 <span class="comment"></span>
03121 <span class="comment">        &lt;63:56&gt; - zero</span>
03122 <span class="comment">        &lt;55&gt; - overflow bit</span>
03123 <span class="comment">        &lt;54&gt; - hidden bit</span>
03124 <span class="comment">        &lt;53:2&gt; - mantissa</span>
03125 <span class="comment">        &lt;1&gt; - guard bit</span>
03126 <span class="comment">        &lt;0&gt; - round bit</span>
03127 <span class="comment"></span>
03128 <span class="comment">        The sticky bits specify bits that were lost during the computable.</span>
03129 <span class="comment"></span>
03130 <span class="comment">Arguments:</span>
03131 <span class="comment"></span>
03132 <span class="comment">    ContextBlock - Supplies a pointer to the emulation context block.</span>
03133 <span class="comment"></span>
03134 <span class="comment">    ResultOperand - Supplies a pointer to the result operand value.</span>
03135 <span class="comment"></span>
03136 <span class="comment">    StickyBits - Supplies the value of the sticky bits.</span>
03137 <span class="comment"></span>
03138 <span class="comment">Return Value:</span>
03139 <span class="comment"></span>
03140 <span class="comment">    If there is not an exception, or the exception is handled, then a proper</span>
03141 <span class="comment">    result is stored in the destination result, the continuation address is</span>
03142 <span class="comment">    set, and a value of TRUE is returned. Otherwise, no value is stored and</span>
03143 <span class="comment">    a value of FALSE is returned.</span>
03144 <span class="comment"></span>
03145 <span class="comment">--*/</span>
03146 
03147 {
03148 
03149     ULONG DenormalizeShift;
03150     PEXCEPTION_RECORD ExceptionRecord;
03151     ULONG ExceptionResultHigh;
03152     ULONG ExceptionResultLow;
03153     PFP_IEEE_VALUE IeeeValue;
03154     BOOLEAN Inexact;
03155     BOOLEAN Overflow;
03156     ULONG ResultValueHigh;
03157     ULONG ResultValueLow;
03158     ULONG RoundBit;
03159     PKTRAP_FRAME TrapFrame;
03160     BOOLEAN Underflow;
03161 
03162     <span class="comment">//</span>
03163     <span class="comment">// If the result is infinite, then store a properly signed infinity</span>
03164     <span class="comment">// in the destination register and return a value of TRUE. Otherwise,</span>
03165     <span class="comment">// round and normalize the result and check for overflow and underflow.</span>
03166     <span class="comment">//</span>
03167 
03168     ExceptionRecord = ContextBlock-&gt;ExceptionRecord;
03169     TrapFrame = ContextBlock-&gt;TrapFrame;
03170     <span class="keywordflow">if</span> (ResultOperand-&gt;Infinity != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
03171         <a class="code" href="../../d8/d5/ppc_2getsetrg_8c.html#a1">KiSetRegisterValue</a>(ContextBlock-&gt;Fd + 32,
03172                            DOUBLE_INFINITY_VALUE_LOW,
03173                            ContextBlock-&gt;ExceptionFrame,
03174                            ContextBlock-&gt;TrapFrame);
03175 
03176         <a class="code" href="../../d8/d5/ppc_2getsetrg_8c.html#a1">KiSetRegisterValue</a>(ContextBlock-&gt;Fd + 32 + 1,
03177                            DOUBLE_INFINITY_VALUE_HIGH | (ResultOperand-&gt;Sign &lt;&lt; 31),
03178                            ContextBlock-&gt;ExceptionFrame,
03179                            ContextBlock-&gt;TrapFrame);
03180 
03181         TrapFrame-&gt;Fir = ContextBlock-&gt;BranchAddress;
03182         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03183     }
03184 
03185     <span class="comment">//</span>
03186     <span class="comment">// If the overflow bit is set, then right shift the mantissa one bit,</span>
03187     <span class="comment">// accumlate the lost bit with the sticky bits, and adjust the exponent</span>
03188     <span class="comment">// value.</span>
03189     <span class="comment">//</span>
03190 
03191     <span class="keywordflow">if</span> ((ResultOperand-&gt;MantissaHigh &amp; (1 &lt;&lt; (55 - 32))) != 0) {
03192         StickyBits |= (ResultOperand-&gt;MantissaLow &amp; 0x1);
03193         ResultOperand-&gt;MantissaLow =
03194                         (ResultOperand-&gt;MantissaLow &gt;&gt; 1) |
03195                                             (ResultOperand-&gt;MantissaHigh &lt;&lt; 31);
03196 
03197         ResultOperand-&gt;MantissaHigh &gt;&gt;= 1;
03198         ResultOperand-&gt;Exponent += 1;
03199     }
03200 
03201     <span class="comment">//</span>
03202     <span class="comment">// If the mantissa is not zero, then normalize the mantissa by left</span>
03203     <span class="comment">// shifting one bit at a time until there is a one bit in bit 54.</span>
03204     <span class="comment">//</span>
03205 
03206     <span class="keywordflow">if</span> ((ResultOperand-&gt;MantissaLow != 0) || (ResultOperand-&gt;MantissaHigh != 0)) {
03207         <span class="keywordflow">while</span> ((ResultOperand-&gt;MantissaHigh &amp; (1 &lt;&lt; (54 - 32))) == 0) {
03208             ResultOperand-&gt;MantissaHigh =
03209                         (ResultOperand-&gt;MantissaHigh &lt;&lt; 1) |
03210                                             (ResultOperand-&gt;MantissaLow &gt;&gt; 31);
03211 
03212             ResultOperand-&gt;MantissaLow &lt;&lt;= 1;
03213             ResultOperand-&gt;Exponent -= 1;
03214         }
03215     }
03216 
03217     <span class="comment">//</span>
03218     <span class="comment">// Right shift the mantissa one bit and accumlate the lost bit with the</span>
03219     <span class="comment">// sticky bits.</span>
03220     <span class="comment">//</span>
03221 
03222     StickyBits |= (ResultOperand-&gt;MantissaLow &amp; 0x1);
03223     ResultOperand-&gt;MantissaLow =
03224                         (ResultOperand-&gt;MantissaLow &gt;&gt; 1) |
03225                                             (ResultOperand-&gt;MantissaHigh &lt;&lt; 31);
03226 
03227     ResultOperand-&gt;MantissaHigh &gt;&gt;= 1;
03228 
03229     <span class="comment">//</span>
03230     <span class="comment">// Round the result value using the mantissa and the sticky bits,</span>
03231     <span class="comment">//</span>
03232 
03233     RoundBit = ResultOperand-&gt;MantissaLow &amp; 0x1;
03234     <span class="keywordflow">switch</span> (ContextBlock-&gt;Round) {
03235 
03236         <span class="comment">//</span>
03237         <span class="comment">// Round to nearest representable number.</span>
03238         <span class="comment">//</span>
03239 
03240     <span class="keywordflow">case</span> ROUND_TO_NEAREST:
03241         <span class="keywordflow">if</span> (RoundBit != 0) {
03242             <span class="keywordflow">if</span> ((StickyBits != 0) || ((ResultOperand-&gt;MantissaLow &amp; 0x2) != 0)) {
03243                 ResultOperand-&gt;MantissaLow += 2;
03244                 <span class="keywordflow">if</span> (ResultOperand-&gt;MantissaLow &lt; 2) {
03245                     ResultOperand-&gt;MantissaHigh += 1;
03246                 }
03247             }
03248         }
03249 
03250         <span class="keywordflow">break</span>;
03251 
03252         <span class="comment">//</span>
03253         <span class="comment">// Round toward zero.</span>
03254         <span class="comment">//</span>
03255 
03256     <span class="keywordflow">case</span> ROUND_TO_ZERO:
03257         <span class="keywordflow">break</span>;
03258 
03259         <span class="comment">//</span>
03260         <span class="comment">// Round toward plus infinity.</span>
03261         <span class="comment">//</span>
03262 
03263     <span class="keywordflow">case</span> ROUND_TO_PLUS_INFINITY:
03264         <span class="keywordflow">if</span> ((ResultOperand-&gt;Sign == 0) &amp;&amp;
03265             ((StickyBits != 0) || (RoundBit != 0))) {
03266             ResultOperand-&gt;MantissaLow += 2;
03267             <span class="keywordflow">if</span> (ResultOperand-&gt;MantissaLow &lt; 2) {
03268                 ResultOperand-&gt;MantissaHigh += 1;
03269             }
03270         }
03271 
03272         <span class="keywordflow">break</span>;
03273 
03274         <span class="comment">//</span>
03275         <span class="comment">// Round toward minus infinity.</span>
03276         <span class="comment">//</span>
03277 
03278     <span class="keywordflow">case</span> ROUND_TO_MINUS_INFINITY:
03279         <span class="keywordflow">if</span> ((ResultOperand-&gt;Sign != 0) &amp;&amp;
03280             ((StickyBits != 0) || (RoundBit != 0))) {
03281             ResultOperand-&gt;MantissaLow += 2;
03282             <span class="keywordflow">if</span> (ResultOperand-&gt;MantissaLow &lt; 2) {
03283                 ResultOperand-&gt;MantissaHigh += 1;
03284             }
03285         }
03286 
03287         <span class="keywordflow">break</span>;
03288     }
03289 
03290     <span class="comment">//</span>
03291     <span class="comment">// If rounding resulted in a carry into bit 54, then right shift the</span>
03292     <span class="comment">// mantissa one bit and adjust the exponent.</span>
03293     <span class="comment">//</span>
03294 
03295     <span class="keywordflow">if</span> ((ResultOperand-&gt;MantissaHigh &amp; (1 &lt;&lt; (54 - 32))) != 0) {
03296         ResultOperand-&gt;MantissaLow =
03297                         (ResultOperand-&gt;MantissaLow &gt;&gt; 1) |
03298                                             (ResultOperand-&gt;MantissaHigh &lt;&lt; 31);
03299 
03300         ResultOperand-&gt;MantissaHigh &gt;&gt;= 1;
03301         ResultOperand-&gt;Exponent += 1;
03302     }
03303 
03304     <span class="comment">//</span>
03305     <span class="comment">// Right shift the mantissa one bit to normalize the final result.</span>
03306     <span class="comment">//</span>
03307 
03308     StickyBits |= ResultOperand-&gt;MantissaLow &amp; 0x1;
03309     ResultOperand-&gt;MantissaLow =
03310                         (ResultOperand-&gt;MantissaLow &gt;&gt; 1) |
03311                                             (ResultOperand-&gt;MantissaHigh &lt;&lt; 31);
03312 
03313     ResultOperand-&gt;MantissaHigh &gt;&gt;= 1;
03314 
03315     <span class="comment">//</span>
03316     <span class="comment">// If the exponent value is greater than or equal to the maximum</span>
03317     <span class="comment">// exponent value, then overflow has occurred. This results in both</span>
03318     <span class="comment">// the inexact and overflow sticky bits being set in FSR.</span>
03319     <span class="comment">//</span>
03320     <span class="comment">// If the exponent value is less than or equal to the minimum exponent</span>
03321     <span class="comment">// value, the mantissa is nonzero, and the result is inexact or the</span>
03322     <span class="comment">// denormalized result causes loss of accuracy, then underflow has</span>
03323     <span class="comment">// occurred. If denormals are being flushed to zero, then a result of</span>
03324     <span class="comment">// zero is returned. Otherwise, both the inexact and underflow sticky</span>
03325     <span class="comment">// bits are set in FSR.</span>
03326     <span class="comment">//</span>
03327     <span class="comment">// Otherwise, a normal result can be delivered, but it may be inexact.</span>
03328     <span class="comment">// If the result is inexact, then the inexact sticky bit is set in FSR.</span>
03329     <span class="comment">//</span>
03330 
03331     <span class="keywordflow">if</span> (ResultOperand-&gt;Exponent &gt;= DOUBLE_MAXIMUM_EXPONENT) {
03332         Inexact = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03333         Overflow = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03334         Underflow = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03335 
03336         <span class="comment">//</span>
03337         <span class="comment">// The overflow value is dependent on the rounding mode.</span>
03338         <span class="comment">//</span>
03339 
03340         <span class="keywordflow">switch</span> (ContextBlock-&gt;Round) {
03341 
03342             <span class="comment">//</span>
03343             <span class="comment">// Round to nearest representable number.</span>
03344             <span class="comment">//</span>
03345             <span class="comment">// The result value is infinity with the sign of the result.</span>
03346             <span class="comment">//</span>
03347 
03348         <span class="keywordflow">case</span> ROUND_TO_NEAREST:
03349             ResultValueLow = DOUBLE_INFINITY_VALUE_LOW;
03350             ResultValueHigh =
03351                         DOUBLE_INFINITY_VALUE_HIGH | (ResultOperand-&gt;Sign &lt;&lt; 31);
03352 
03353             <span class="keywordflow">break</span>;
03354 
03355             <span class="comment">//</span>
03356             <span class="comment">// Round toward zero.</span>
03357             <span class="comment">//</span>
03358             <span class="comment">// The result is the maximum number with the sign of the result.</span>
03359             <span class="comment">//</span>
03360 
03361         <span class="keywordflow">case</span> ROUND_TO_ZERO:
03362             ResultValueLow = DOUBLE_MAXIMUM_VALUE_LOW;
03363             ResultValueHigh =
03364                         DOUBLE_MAXIMUM_VALUE_HIGH | (ResultOperand-&gt;Sign &lt;&lt; 31);
03365             <span class="keywordflow">break</span>;
03366 
03367             <span class="comment">//</span>
03368             <span class="comment">// Round toward plus infinity.</span>
03369             <span class="comment">//</span>
03370             <span class="comment">// If the sign of the result is positive, then the result is</span>
03371             <span class="comment">// plus infinity. Otherwise, the result is the maximum negative</span>
03372             <span class="comment">// number.</span>
03373             <span class="comment">//</span>
03374 
03375         <span class="keywordflow">case</span> ROUND_TO_PLUS_INFINITY:
03376             <span class="keywordflow">if</span> (ResultOperand-&gt;Sign == 0) {
03377                 ResultValueLow = DOUBLE_INFINITY_VALUE_LOW;
03378                 ResultValueHigh = DOUBLE_INFINITY_VALUE_HIGH;
03379 
03380             } <span class="keywordflow">else</span> {
03381                 ResultValueLow = DOUBLE_MAXIMUM_VALUE_LOW;
03382                 ResultValueHigh = (ULONG)(DOUBLE_MAXIMUM_VALUE_HIGH | (1 &lt;&lt; 31));
03383             }
03384 
03385             <span class="keywordflow">break</span>;
03386 
03387             <span class="comment">//</span>
03388             <span class="comment">// Round toward minus infinity.</span>
03389             <span class="comment">//</span>
03390             <span class="comment">// If the sign of the result is negative, then the result is</span>
03391             <span class="comment">// negative infinity. Otherwise, the result is the maximum</span>
03392             <span class="comment">// positive number.</span>
03393             <span class="comment">//</span>
03394 
03395 
03396         <span class="keywordflow">case</span> ROUND_TO_MINUS_INFINITY:
03397             <span class="keywordflow">if</span> (ResultOperand-&gt;Sign != 0) {
03398                 ResultValueLow = DOUBLE_INFINITY_VALUE_LOW;
03399                 ResultValueHigh = (ULONG)(DOUBLE_INFINITY_VALUE_HIGH | (1 &lt;&lt; 31));
03400 
03401             } <span class="keywordflow">else</span> {
03402                 ResultValueLow = DOUBLE_MAXIMUM_VALUE_LOW;
03403                 ResultValueHigh = DOUBLE_MAXIMUM_VALUE_HIGH;
03404             }
03405 
03406             <span class="keywordflow">break</span>;
03407         }
03408 
03409         <span class="comment">//</span>
03410         <span class="comment">// Compute the overflow exception result value by subtracting 1536</span>
03411         <span class="comment">// from the exponent.</span>
03412         <span class="comment">//</span>
03413 
03414         ExceptionResultLow = ResultOperand-&gt;MantissaLow;
03415         ExceptionResultHigh = ResultOperand-&gt;MantissaHigh &amp; ((1 &lt;&lt; (52 - 32)) - 1);
03416         ExceptionResultHigh |= ((ResultOperand-&gt;Exponent - 1536) &lt;&lt; (52 - 32));
03417         ExceptionResultHigh |= (ResultOperand-&gt;Sign &lt;&lt; 31);
03418 
03419     } <span class="keywordflow">else</span> {
03420         <span class="keywordflow">if</span> ((ResultOperand-&gt;Exponent &lt;= DOUBLE_MINIMUM_EXPONENT) &amp;&amp;
03421             (ResultOperand-&gt;MantissaHigh != 0)) {
03422             <span class="keywordflow">if</span> (((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;FS == 0) {
03423                 DenormalizeShift = 1 - ResultOperand-&gt;Exponent;
03424                 <span class="keywordflow">if</span> (DenormalizeShift &gt;= 53) {
03425                     DenormalizeShift = 53;
03426                 }
03427 
03428                 <span class="keywordflow">if</span> (DenormalizeShift &gt;= 32) {
03429                     DenormalizeShift -= 32;
03430                     StickyBits |= ResultOperand-&gt;MantissaLow |
03431                         (ResultOperand-&gt;MantissaHigh &amp; ((1 &lt;&lt; DenormalizeShift) - 1));
03432 
03433                     ResultValueLow = ResultOperand-&gt;MantissaHigh &gt;&gt; DenormalizeShift;
03434                     ResultValueHigh = 0;
03435 
03436                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (DenormalizeShift &gt; 0) {
03437                     StickyBits |=
03438                         ResultOperand-&gt;MantissaLow &amp; ((1 &lt;&lt; DenormalizeShift) - 1);
03439 
03440                     ResultValueLow =
03441                         (ResultOperand-&gt;MantissaLow &gt;&gt; DenormalizeShift) |
03442                         (ResultOperand-&gt;MantissaHigh &lt;&lt; (32 - DenormalizeShift));
03443 
03444                     ResultValueHigh =
03445                             (ResultOperand-&gt;MantissaHigh &gt;&gt; DenormalizeShift);
03446 
03447                 } <span class="keywordflow">else</span> {
03448                     ResultValueLow = ResultOperand-&gt;MantissaLow;
03449                     ResultValueHigh = ResultOperand-&gt;MantissaHigh;
03450                 }
03451 
03452                 ResultValueHigh |= (ResultOperand-&gt;Sign &lt;&lt; 31);
03453                 <span class="keywordflow">if</span> (StickyBits != 0) {
03454                     Inexact = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03455                     Overflow = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03456                     Underflow = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03457 
03458                     <span class="comment">//</span>
03459                     <span class="comment">// Compute the underflow exception result value by adding</span>
03460                     <span class="comment">// 1536 to the exponent.</span>
03461                     <span class="comment">//</span>
03462 
03463                     ExceptionResultLow = ResultOperand-&gt;MantissaLow;
03464                     ExceptionResultHigh = ResultOperand-&gt;MantissaHigh &amp; ((1 &lt;&lt; (52 - 32)) - 1);
03465                     ExceptionResultHigh |= ((ResultOperand-&gt;Exponent + 1536) &lt;&lt; (52 - 32));
03466                     ExceptionResultHigh |= (ResultOperand-&gt;Sign &lt;&lt; 31);
03467 
03468                 } <span class="keywordflow">else</span> {
03469                     Inexact = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03470                     Overflow = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03471                     Underflow = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03472                 }
03473 
03474             } <span class="keywordflow">else</span> {
03475                 ResultValueLow = 0;
03476                 ResultValueHigh = 0;
03477                 Inexact = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03478                 Overflow = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03479                 Underflow = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03480             }
03481 
03482         } <span class="keywordflow">else</span> {
03483             <span class="keywordflow">if</span> (ResultOperand-&gt;MantissaHigh == 0) {
03484                 ResultOperand-&gt;Exponent = 0;
03485             }
03486 
03487             ResultValueLow = ResultOperand-&gt;MantissaLow;
03488             ResultValueHigh = ResultOperand-&gt;MantissaHigh &amp; ((1 &lt;&lt; (52 - 32)) - 1);
03489             ResultValueHigh |= (ResultOperand-&gt;Exponent &lt;&lt; (52 - 32));
03490             ResultValueHigh |= (ResultOperand-&gt;Sign &lt;&lt; 31);
03491             Inexact = StickyBits ? <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> : <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03492             Overflow = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03493             Underflow = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03494         }
03495     }
03496 
03497     <span class="comment">//</span>
03498     <span class="comment">// Check to determine if an exception should be delivered or the result</span>
03499     <span class="comment">// should be written to the destination register.</span>
03500     <span class="comment">//</span>
03501 
03502     <span class="keywordflow">if</span> (Overflow != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
03503         ((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;SI = 1;
03504         ((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;SO = 1;
03505         <span class="keywordflow">if</span> ((((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;EO != 0) ||
03506             (((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;EI != 0)) {
03507             <span class="keywordflow">if</span> (((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;EO != 0) {
03508                 ExceptionRecord-&gt;ExceptionCode = STATUS_FLOAT_OVERFLOW;
03509 
03510             } <span class="keywordflow">else</span> {
03511                 ExceptionRecord-&gt;ExceptionCode = STATUS_FLOAT_INEXACT_RESULT;
03512             }
03513 
03514             IeeeValue = (PFP_IEEE_VALUE)&amp;ExceptionRecord-&gt;ExceptionInformation[2];
03515             IeeeValue-&gt;Value.Fp64Value.W[0] = ExceptionResultLow;
03516             IeeeValue-&gt;Value.Fp64Value.W[1] = ExceptionResultHigh;
03517             ((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;XI = 1;
03518             ((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;XO = 1;
03519             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03520         }
03521 
03522     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Underflow != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
03523         ((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;SI = 1;
03524         ((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;SU = 1;
03525         <span class="keywordflow">if</span> ((((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;EU != 0) ||
03526             (((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;EI != 0)) {
03527             <span class="keywordflow">if</span> (((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;EU != 0) {
03528                 ExceptionRecord-&gt;ExceptionCode = STATUS_FLOAT_UNDERFLOW;
03529 
03530             } <span class="keywordflow">else</span> {
03531                 ExceptionRecord-&gt;ExceptionCode = STATUS_FLOAT_INEXACT_RESULT;
03532             }
03533 
03534             IeeeValue = (PFP_IEEE_VALUE)&amp;ExceptionRecord-&gt;ExceptionInformation[2];
03535             IeeeValue-&gt;Value.Fp64Value.W[0] = ExceptionResultLow;
03536             IeeeValue-&gt;Value.Fp64Value.W[1] = ExceptionResultHigh;
03537             ((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;XI = 1;
03538             ((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;XU = 1;
03539             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03540         }
03541 
03542     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Inexact != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
03543         ((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;SI = 1;
03544         <span class="keywordflow">if</span> (((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;EI != 0) {
03545             ExceptionRecord-&gt;ExceptionCode = STATUS_FLOAT_INEXACT_RESULT;
03546             ((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;XI = 1;
03547             IeeeValue = (PFP_IEEE_VALUE)&amp;ExceptionRecord-&gt;ExceptionInformation[2];
03548             IeeeValue-&gt;Value.Fp64Value.W[0] = ResultValueLow;
03549             IeeeValue-&gt;Value.Fp64Value.W[1] = ResultValueHigh;
03550             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03551         }
03552     }
03553 
03554     <span class="comment">//</span>
03555     <span class="comment">// Set the destination register value, update the return address,</span>
03556     <span class="comment">// and return a value of TRUE.</span>
03557     <span class="comment">//</span>
03558 
03559     <a class="code" href="../../d8/d5/ppc_2getsetrg_8c.html#a1">KiSetRegisterValue</a>(ContextBlock-&gt;Fd + 32,
03560                        ResultValueLow,
03561                        ContextBlock-&gt;ExceptionFrame,
03562                        ContextBlock-&gt;TrapFrame);
03563 
03564     <a class="code" href="../../d8/d5/ppc_2getsetrg_8c.html#a1">KiSetRegisterValue</a>(ContextBlock-&gt;Fd + 32 + 1,
03565                        ResultValueHigh,
03566                        ContextBlock-&gt;ExceptionFrame,
03567                        ContextBlock-&gt;TrapFrame);
03568 
03569     TrapFrame-&gt;Fir = ContextBlock-&gt;BranchAddress;
03570     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03571 }
03572 
03573 BOOLEAN
<a name="l03574"></a><a class="code" href="../../d3/d4/mips_2floatem_8c.html#a25">03574</a> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a25">KiNormalizeLongword</a> (
03575     IN PFP_CONTEXT_BLOCK ContextBlock,
03576     IN PFP_DOUBLE_OPERAND ResultOperand
03577     )
03578 
03579 <span class="comment">/*++</span>
03580 <span class="comment"></span>
03581 <span class="comment">Routine Description:</span>
03582 <span class="comment"></span>
03583 <span class="comment">    This function is called to convert a result value to a longword result.</span>
03584 <span class="comment"></span>
03585 <span class="comment">    N.B. The result value is specified with a guard bit on the right,</span>
03586 <span class="comment">        the hidden bit (if appropriate), and an overlfow bit of zero.</span>
03587 <span class="comment">        The result format is:</span>
03588 <span class="comment"></span>
03589 <span class="comment">        &lt;63:55&gt; - zero</span>
03590 <span class="comment">        &lt;54 - hidden bit</span>
03591 <span class="comment">        &lt;53:2&gt; - mantissa</span>
03592 <span class="comment">        &lt;1&gt; - guard bit</span>
03593 <span class="comment">        &lt;0&gt; - round bit</span>
03594 <span class="comment"></span>
03595 <span class="comment">        There are no sticky bits.</span>
03596 <span class="comment"></span>
03597 <span class="comment">Arguments:</span>
03598 <span class="comment"></span>
03599 <span class="comment">    ContextBlock - Supplies a pointer to the emulation context block.</span>
03600 <span class="comment"></span>
03601 <span class="comment">    ResultOperand - Supplies a pointer to the result operand value.</span>
03602 <span class="comment"></span>
03603 <span class="comment">Return Value:</span>
03604 <span class="comment"></span>
03605 <span class="comment">    If there is not an exception, or the exception is handled, then a proper</span>
03606 <span class="comment">    result is stored in the destination result, the continuation address is</span>
03607 <span class="comment">    set, and a value of TRUE is returned. Otherwise, no value is stored and</span>
03608 <span class="comment">    a value of FALSE is returned.</span>
03609 <span class="comment"></span>
03610 <span class="comment">--*/</span>
03611 
03612 {
03613 
03614     PEXCEPTION_RECORD ExceptionRecord;
03615     LONG ExponentShift;
03616     PFP_IEEE_VALUE IeeeValue;
03617     BOOLEAN Inexact;
03618     BOOLEAN Overflow;
03619     ULONG ResultValue;
03620     ULONG RoundBit;
03621     ULONG StickyBits;
03622     PKTRAP_FRAME TrapFrame;
03623 
03624     <span class="comment">//</span>
03625     <span class="comment">// Subtract out the exponent bias and divide the cases into right</span>
03626     <span class="comment">// and left shifts.</span>
03627     <span class="comment">//</span>
03628 
03629     ExceptionRecord = ContextBlock-&gt;ExceptionRecord;
03630     TrapFrame = ContextBlock-&gt;TrapFrame;
03631     ExponentShift = ResultOperand-&gt;Exponent - DOUBLE_EXPONENT_BIAS;
03632     <span class="keywordflow">if</span> (ExponentShift &lt; 23) {
03633 
03634         <span class="comment">//</span>
03635         <span class="comment">// The integer value is less than 2**23 and a right shift must</span>
03636         <span class="comment">// be performed.</span>
03637         <span class="comment">//</span>
03638 
03639         ExponentShift = 22 - ExponentShift;
03640         <span class="keywordflow">if</span> (ExponentShift &gt; 24) {
03641             ExponentShift = 24;
03642         }
03643 
03644         StickyBits =
03645                 (ResultOperand-&gt;MantissaLow &gt;&gt; 2) |
03646                 (ResultOperand-&gt;MantissaHigh &lt;&lt; (32 - ExponentShift));
03647 
03648         ResultValue = ResultOperand-&gt;MantissaHigh &gt;&gt; ExponentShift;
03649         Overflow = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03650 
03651     } <span class="keywordflow">else</span> {
03652 
03653         <span class="comment">//</span>
03654         <span class="comment">// The integer value is two or greater and a left shift must be</span>
03655         <span class="comment">// performed.</span>
03656         <span class="comment">//</span>
03657 
03658         ExponentShift -= 22;
03659         <span class="keywordflow">if</span> (ExponentShift &lt;= (31 - 22)) {
03660             StickyBits = ResultOperand-&gt;MantissaLow &lt;&lt; ExponentShift;
03661             ResultValue =
03662                 (ResultOperand-&gt;MantissaHigh &lt;&lt; ExponentShift) |
03663                 (ResultOperand-&gt;MantissaLow &gt;&gt; (32 - ExponentShift));
03664 
03665             Overflow = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03666 
03667         } <span class="keywordflow">else</span> {
03668             Overflow = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03669         }
03670     }
03671 
03672     <span class="comment">//</span>
03673     <span class="comment">// Round the result value using the mantissa and the sticky bits,</span>
03674     <span class="comment">//</span>
03675 
03676     RoundBit = StickyBits &gt;&gt; 31;
03677     StickyBits &lt;&lt;= 1;
03678     <span class="keywordflow">switch</span> (ContextBlock-&gt;Round) {
03679 
03680         <span class="comment">//</span>
03681         <span class="comment">// Round to nearest representable number.</span>
03682         <span class="comment">//</span>
03683 
03684     <span class="keywordflow">case</span> ROUND_TO_NEAREST:
03685         <span class="keywordflow">if</span> (RoundBit != 0) {
03686             <span class="keywordflow">if</span> ((StickyBits != 0) || ((ResultValue &amp; 0x1) != 0)) {
03687                 ResultValue += 1;
03688                 <span class="keywordflow">if</span> (ResultValue == 0) {
03689                     Overflow = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03690                 }
03691             }
03692         }
03693 
03694         <span class="keywordflow">break</span>;
03695 
03696         <span class="comment">//</span>
03697         <span class="comment">// Round toward zero.</span>
03698         <span class="comment">//</span>
03699 
03700     <span class="keywordflow">case</span> ROUND_TO_ZERO:
03701         <span class="keywordflow">break</span>;
03702 
03703         <span class="comment">//</span>
03704         <span class="comment">// Round toward plus infinity.</span>
03705         <span class="comment">//</span>
03706 
03707     <span class="keywordflow">case</span> ROUND_TO_PLUS_INFINITY:
03708         <span class="keywordflow">if</span> ((ResultOperand-&gt;Sign == 0) &amp;&amp; (StickyBits != 0)) {
03709             ResultValue += 1;
03710             <span class="keywordflow">if</span> (ResultValue == 0) {
03711                 Overflow = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03712             }
03713         }
03714 
03715         <span class="keywordflow">break</span>;
03716 
03717         <span class="comment">//</span>
03718         <span class="comment">// Round toward minus infinity.</span>
03719         <span class="comment">//</span>
03720 
03721     <span class="keywordflow">case</span> ROUND_TO_MINUS_INFINITY:
03722         <span class="keywordflow">if</span> ((ResultOperand-&gt;Sign != 0) &amp;&amp; (StickyBits != 0)) {
03723             ResultValue += 1;
03724             <span class="keywordflow">if</span> (ResultValue == 0) {
03725                 Overflow = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03726             }
03727         }
03728 
03729         <span class="keywordflow">break</span>;
03730     }
03731 
03732     <span class="comment">//</span>
03733     <span class="comment">// If the result value is positive and the result is negative, then</span>
03734     <span class="comment">// overflow has occurred. Otherwise, negate the result value and</span>
03735     <span class="comment">// check if the result is negative. If the result is positive, then</span>
03736     <span class="comment">// overflow has occurred.</span>
03737     <span class="comment">//</span>
03738 
03739     <span class="keywordflow">if</span> (ResultOperand-&gt;Sign == 0) {
03740         <span class="keywordflow">if</span> ((ResultValue &gt;&gt; 31) != 0) {
03741             Overflow = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03742         }
03743 
03744     } <span class="keywordflow">else</span> {
03745         ResultValue = ~ResultValue + 1;
03746         <span class="keywordflow">if</span> ((ResultValue &gt;&gt; 31) == 0) {
03747             Overflow = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03748         }
03749     }
03750 
03751     <span class="comment">//</span>
03752     <span class="comment">// Check to determine if an exception should be delivered or the result</span>
03753     <span class="comment">// should be written to the destination register.</span>
03754     <span class="comment">//</span>
03755 
03756     <span class="keywordflow">if</span> (Overflow != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
03757         <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a21">KiInvalidOperationLongword</a>(ContextBlock,
03758                                           <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
03759                                           0);
03760 
03761     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((StickyBits | RoundBit) != 0) {
03762         ((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;SI = 1;
03763         <span class="keywordflow">if</span> (((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;EI != 0) {
03764             ExceptionRecord-&gt;ExceptionCode = STATUS_FLOAT_INEXACT_RESULT;
03765             ((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;XI = 1;
03766             IeeeValue = (PFP_IEEE_VALUE)&amp;ExceptionRecord-&gt;ExceptionInformation[2];
03767             IeeeValue-&gt;Value.U32Value = ResultValue;
03768             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03769         }
03770 
03771     }
03772 
03773     <span class="comment">//</span>
03774     <span class="comment">// Set the destination register value, update the return address,</span>
03775     <span class="comment">// and return a value of TRUE.</span>
03776     <span class="comment">//</span>
03777 
03778     <a class="code" href="../../d8/d5/ppc_2getsetrg_8c.html#a1">KiSetRegisterValue</a>(ContextBlock-&gt;Fd + 32,
03779                        ResultValue,
03780                        ContextBlock-&gt;ExceptionFrame,
03781                        ContextBlock-&gt;TrapFrame);
03782 
03783     TrapFrame-&gt;Fir = ContextBlock-&gt;BranchAddress;
03784     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03785 }
03786 
03787 BOOLEAN
03788 <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a26">KiNormalizeQuadword</a> (
03789     IN PFP_CONTEXT_BLOCK ContextBlock,
03790     IN PFP_DOUBLE_OPERAND ResultOperand
03791     )
03792 
03793 <span class="comment">/*++</span>
03794 <span class="comment"></span>
03795 <span class="comment">Routine Description:</span>
03796 <span class="comment"></span>
03797 <span class="comment">    This function is called to convert a result value to a quadword result.</span>
03798 <span class="comment"></span>
03799 <span class="comment">    N.B. The result value is specified with a guard bit on the right,</span>
03800 <span class="comment">        the hidden bit (if appropriate), and an overlfow bit of zero.</span>
03801 <span class="comment">        The result format is:</span>
03802 <span class="comment"></span>
03803 <span class="comment">        &lt;63:55&gt; - zero</span>
03804 <span class="comment">        &lt;54 - hidden bit</span>
03805 <span class="comment">        &lt;53:2&gt; - mantissa</span>
03806 <span class="comment">        &lt;1&gt; - guard bit</span>
03807 <span class="comment">        &lt;0&gt; - round bit</span>
03808 <span class="comment"></span>
03809 <span class="comment">        There are no sticky bits.</span>
03810 <span class="comment"></span>
03811 <span class="comment">Arguments:</span>
03812 <span class="comment"></span>
03813 <span class="comment">    ContextBlock - Supplies a pointer to the emulation context block.</span>
03814 <span class="comment"></span>
03815 <span class="comment">    ResultOperand - Supplies a pointer to the result operand value.</span>
03816 <span class="comment"></span>
03817 <span class="comment">Return Value:</span>
03818 <span class="comment"></span>
03819 <span class="comment">    If there is not an exception, or the exception is handled, then a proper</span>
03820 <span class="comment">    result is stored in the destination result, the continuation address is</span>
03821 <span class="comment">    set, and a value of TRUE is returned. Otherwise, no value is stored and</span>
03822 <span class="comment">    a value of FALSE is returned.</span>
03823 <span class="comment"></span>
03824 <span class="comment">--*/</span>
03825 
03826 {
03827 
03828     PEXCEPTION_RECORD ExceptionRecord;
03829     LONG ExponentShift;
03830     PFP_IEEE_VALUE IeeeValue;
03831     BOOLEAN Inexact;
03832     BOOLEAN Overflow;
03833     <span class="keyword">union </span>{
03834         ULONGLONG ResultValue;
03835         ULARGE_INTEGER LargeValue;
03836     }u;
03837 
03838     ULONG RoundBit;
03839     ULONG StickyBits;
03840     PKTRAP_FRAME TrapFrame;
03841 
03842     <span class="comment">//</span>
03843     <span class="comment">// Subtract out the exponent bias and divide the cases into right</span>
03844     <span class="comment">// and left shifts.</span>
03845     <span class="comment">//</span>
03846 
03847     ExceptionRecord = ContextBlock-&gt;ExceptionRecord;
03848     TrapFrame = ContextBlock-&gt;TrapFrame;
03849     ExponentShift = ResultOperand-&gt;Exponent - DOUBLE_EXPONENT_BIAS;
03850     <span class="keywordflow">if</span> (ExponentShift &lt; 54) {
03851 
03852         <span class="comment">//</span>
03853         <span class="comment">// The integer value is less than 2**52 and a right shift must</span>
03854         <span class="comment">// be performed.</span>
03855         <span class="comment">//</span>
03856 
03857         ExponentShift = 54 - ExponentShift;
03858         <span class="keywordflow">if</span> (ExponentShift &gt; 54) {
03859             ExponentShift = 54;
03860         }
03861 
03862         StickyBits = (ULONG)(ResultOperand-&gt;Mantissa &lt;&lt; (32 - ExponentShift));
03863         u.ResultValue = ResultOperand-&gt;Mantissa &gt;&gt; ExponentShift;
03864         Overflow = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03865 
03866     } <span class="keywordflow">else</span> {
03867 
03868         <span class="comment">//</span>
03869         <span class="comment">// The integer value is two or greater and a left shift must be</span>
03870         <span class="comment">// performed.</span>
03871         <span class="comment">//</span>
03872 
03873         ExponentShift -= 54;
03874         <span class="keywordflow">if</span> (ExponentShift &lt;= (63 - 54)) {
03875             StickyBits = 0;
03876             u.ResultValue = ResultOperand-&gt;Mantissa &lt;&lt; ExponentShift;
03877             Overflow = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03878 
03879         } <span class="keywordflow">else</span> {
03880             Overflow = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03881         }
03882     }
03883 
03884     <span class="comment">//</span>
03885     <span class="comment">// Round the result value using the mantissa and the sticky bits,</span>
03886     <span class="comment">//</span>
03887 
03888     RoundBit = StickyBits &gt;&gt; 31;
03889     StickyBits &lt;&lt;= 1;
03890     <span class="keywordflow">switch</span> (ContextBlock-&gt;Round) {
03891 
03892         <span class="comment">//</span>
03893         <span class="comment">// Round to nearest representable number.</span>
03894         <span class="comment">//</span>
03895 
03896     <span class="keywordflow">case</span> ROUND_TO_NEAREST:
03897         <span class="keywordflow">if</span> (RoundBit != 0) {
03898             <span class="keywordflow">if</span> ((StickyBits != 0) || ((u.ResultValue &amp; 0x1) != 0)) {
03899                 u.ResultValue += 1;
03900                 <span class="keywordflow">if</span> (u.ResultValue == 0) {
03901                     Overflow = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03902                 }
03903             }
03904         }
03905 
03906         <span class="keywordflow">break</span>;
03907 
03908         <span class="comment">//</span>
03909         <span class="comment">// Round toward zero.</span>
03910         <span class="comment">//</span>
03911 
03912     <span class="keywordflow">case</span> ROUND_TO_ZERO:
03913         <span class="keywordflow">break</span>;
03914 
03915         <span class="comment">//</span>
03916         <span class="comment">// Round toward plus infinity.</span>
03917         <span class="comment">//</span>
03918 
03919     <span class="keywordflow">case</span> ROUND_TO_PLUS_INFINITY:
03920         <span class="keywordflow">if</span> ((ResultOperand-&gt;Sign == 0) &amp;&amp; (StickyBits != 0)) {
03921             u.ResultValue += 1;
03922             <span class="keywordflow">if</span> (u.ResultValue == 0) {
03923                 Overflow = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03924             }
03925         }
03926 
03927         <span class="keywordflow">break</span>;
03928 
03929         <span class="comment">//</span>
03930         <span class="comment">// Round toward minus infinity.</span>
03931         <span class="comment">//</span>
03932 
03933     <span class="keywordflow">case</span> ROUND_TO_MINUS_INFINITY:
03934         <span class="keywordflow">if</span> ((ResultOperand-&gt;Sign != 0) &amp;&amp; (StickyBits != 0)) {
03935             u.ResultValue += 1;
03936             <span class="keywordflow">if</span> (u.ResultValue == 0) {
03937                 Overflow = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03938             }
03939         }
03940 
03941         <span class="keywordflow">break</span>;
03942     }
03943 
03944     <span class="comment">//</span>
03945     <span class="comment">// If the result value is positive and the result is negative, then</span>
03946     <span class="comment">// overflow has occurred. Otherwise, negate the result value and</span>
03947     <span class="comment">// check if the result is negative. If the result is positive, then</span>
03948     <span class="comment">// overflow has occurred.</span>
03949     <span class="comment">//</span>
03950 
03951     <span class="keywordflow">if</span> (ResultOperand-&gt;Sign == 0) {
03952         <span class="keywordflow">if</span> ((u.ResultValue &gt;&gt; 63) != 0) {
03953             Overflow = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03954         }
03955 
03956     } <span class="keywordflow">else</span> {
03957         u.ResultValue = ~u.ResultValue + 1;
03958         <span class="keywordflow">if</span> ((u.ResultValue &gt;&gt; 63) == 0) {
03959             Overflow = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03960         }
03961     }
03962 
03963     <span class="comment">//</span>
03964     <span class="comment">// Check to determine if an exception should be delivered or the result</span>
03965     <span class="comment">// should be written to the destination register.</span>
03966     <span class="comment">//</span>
03967 
03968     <span class="keywordflow">if</span> (Overflow != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
03969         <span class="keywordflow">return</span> <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a22">KiInvalidOperationQuadword</a>(ContextBlock,
03970                                           FALSE,
03971                                           0);
03972 
03973     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((StickyBits | RoundBit) != 0) {
03974         ((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;SI = 1;
03975         <span class="keywordflow">if</span> (((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;EI != 0) {
03976             ExceptionRecord-&gt;ExceptionCode = STATUS_FLOAT_INEXACT_RESULT;
03977             ((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;XI = 1;
03978             IeeeValue = (PFP_IEEE_VALUE)&amp;ExceptionRecord-&gt;ExceptionInformation[2];
03979             IeeeValue-&gt;Value.U64Value.QuadPart = u.ResultValue;
03980             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03981         }
03982 
03983     }
03984 
03985     <span class="comment">//</span>
03986     <span class="comment">// Set the destination register value, update the return address,</span>
03987     <span class="comment">// and return a value of TRUE.</span>
03988     <span class="comment">//</span>
03989 
03990     <a class="code" href="../../d8/d5/ppc_2getsetrg_8c.html#a1">KiSetRegisterValue</a>(ContextBlock-&gt;Fd + 32,
03991                        u.LargeValue.LowPart,
03992                        ContextBlock-&gt;ExceptionFrame,
03993                        ContextBlock-&gt;TrapFrame);
03994 
03995     <a class="code" href="../../d8/d5/ppc_2getsetrg_8c.html#a1">KiSetRegisterValue</a>(ContextBlock-&gt;Fd + 33,
03996                        u.LargeValue.HighPart,
03997                        ContextBlock-&gt;ExceptionFrame,
03998                        ContextBlock-&gt;TrapFrame);
03999 
04000     TrapFrame-&gt;Fir = ContextBlock-&gt;BranchAddress;
04001     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04002 }
04003 
04004 BOOLEAN
04005 <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a27">KiNormalizeSingle</a> (
04006     IN PFP_CONTEXT_BLOCK ContextBlock,
04007     IN PFP_SINGLE_OPERAND ResultOperand,
04008     IN ULONG StickyBits
04009     )
04010 
04011 <span class="comment">/*++</span>
04012 <span class="comment"></span>
04013 <span class="comment">Routine Description:</span>
04014 <span class="comment"></span>
04015 <span class="comment">    This function is called to normalize a single floating result.</span>
04016 <span class="comment"></span>
04017 <span class="comment">    N.B. The result value is specified with a guard bit on the right,</span>
04018 <span class="comment">        the hidden bit (if appropriate), and a possible overflow bit.</span>
04019 <span class="comment">        The result format is:</span>
04020 <span class="comment"></span>
04021 <span class="comment">        &lt;31:27&gt; - zero</span>
04022 <span class="comment">        &lt;26&gt; - overflow bit</span>
04023 <span class="comment">        &lt;25&gt; - hidden bit</span>
04024 <span class="comment">        &lt;24:2&gt; - mantissa</span>
04025 <span class="comment">        &lt;1&gt; - guard bit</span>
04026 <span class="comment">        &lt;0&gt; - round bit</span>
04027 <span class="comment"></span>
04028 <span class="comment">        The sticky bits specify bits that were lost during the computable.</span>
04029 <span class="comment"></span>
04030 <span class="comment">Arguments:</span>
04031 <span class="comment"></span>
04032 <span class="comment">    ContextBlock - Supplies a pointer to the emulation context block.</span>
04033 <span class="comment"></span>
04034 <span class="comment">    ResultOperand - Supplies a pointer to the result operand value.</span>
04035 <span class="comment"></span>
04036 <span class="comment">    StickyBits - Supplies the value of the sticky bits.</span>
04037 <span class="comment"></span>
04038 <span class="comment">Return Value:</span>
04039 <span class="comment"></span>
04040 <span class="comment">    If there is not an exception, or the exception is handled, then a proper</span>
04041 <span class="comment">    result is stored in the destination result, the continuation address is</span>
04042 <span class="comment">    set, and a value of TRUE is returned. Otherwise, no value is stored and</span>
04043 <span class="comment">    a value of FALSE is returned.</span>
04044 <span class="comment"></span>
04045 <span class="comment">--*/</span>
04046 
04047 {
04048 
04049     ULONG DenormalizeShift;
04050     PEXCEPTION_RECORD ExceptionRecord;
04051     ULONG ExceptionResult;
04052     PFP_IEEE_VALUE IeeeValue;
04053     BOOLEAN Inexact;
04054     BOOLEAN Overflow;
04055     ULONG ResultValue;
04056     ULONG RoundBit;
04057     PKTRAP_FRAME TrapFrame;
04058     BOOLEAN Underflow;
04059 
04060     <span class="comment">//</span>
04061     <span class="comment">// If the result is infinite, then store a properly signed infinity</span>
04062     <span class="comment">// in the destination register and return a value of TRUE. Otherwise,</span>
04063     <span class="comment">// round and normalize the result and check for overflow and underflow.</span>
04064     <span class="comment">//</span>
04065 
04066     ExceptionRecord = ContextBlock-&gt;ExceptionRecord;
04067     TrapFrame = ContextBlock-&gt;TrapFrame;
04068     <span class="keywordflow">if</span> (ResultOperand-&gt;Infinity != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
04069         <a class="code" href="../../d8/d5/ppc_2getsetrg_8c.html#a1">KiSetRegisterValue</a>(ContextBlock-&gt;Fd + 32,
04070                            SINGLE_INFINITY_VALUE | (ResultOperand-&gt;Sign &lt;&lt; 31),
04071                            ContextBlock-&gt;ExceptionFrame,
04072                            ContextBlock-&gt;TrapFrame);
04073 
04074         TrapFrame-&gt;Fir = ContextBlock-&gt;BranchAddress;
04075         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04076     }
04077 
04078     <span class="comment">//</span>
04079     <span class="comment">// If the overflow bit is set, then right shift the mantissa one bit,</span>
04080     <span class="comment">// accumlate the lost bit with the sticky bits, and adjust the exponent</span>
04081     <span class="comment">// value.</span>
04082     <span class="comment">//</span>
04083 
04084     <span class="keywordflow">if</span> ((ResultOperand-&gt;Mantissa &amp; (1 &lt;&lt; 26)) != 0) {
04085         StickyBits |= (ResultOperand-&gt;Mantissa &amp; 0x1);
04086         ResultOperand-&gt;Mantissa &gt;&gt;= 1;
04087         ResultOperand-&gt;Exponent += 1;
04088     }
04089 
04090     <span class="comment">//</span>
04091     <span class="comment">// If the mantissa is not zero, then normalize the mantissa by left</span>
04092     <span class="comment">// shifting one bit at a time until there is a one bit in bit 25.</span>
04093     <span class="comment">//</span>
04094 
04095     <span class="keywordflow">if</span> (ResultOperand-&gt;Mantissa != 0) {
04096         <span class="keywordflow">while</span> ((ResultOperand-&gt;Mantissa &amp; (1 &lt;&lt; 25)) == 0) {
04097             ResultOperand-&gt;Mantissa &lt;&lt;= 1;
04098             ResultOperand-&gt;Exponent -= 1;
04099         }
04100     }
04101 
04102     <span class="comment">//</span>
04103     <span class="comment">// Right shift the mantissa one bit and accumlate the lost bit with the</span>
04104     <span class="comment">// sticky bits.</span>
04105     <span class="comment">//</span>
04106 
04107     StickyBits |= (ResultOperand-&gt;Mantissa &amp; 0x1);
04108     ResultOperand-&gt;Mantissa &gt;&gt;= 1;
04109 
04110     <span class="comment">//</span>
04111     <span class="comment">// Round the result value using the mantissa, the round bit, and the</span>
04112     <span class="comment">// sticky bits,</span>
04113     <span class="comment">//</span>
04114 
04115     RoundBit = ResultOperand-&gt;Mantissa &amp; 0x1;
04116     <span class="keywordflow">switch</span> (ContextBlock-&gt;Round) {
04117 
04118         <span class="comment">//</span>
04119         <span class="comment">// Round to nearest representable number.</span>
04120         <span class="comment">//</span>
04121 
04122     <span class="keywordflow">case</span> ROUND_TO_NEAREST:
04123         <span class="keywordflow">if</span> (RoundBit != 0) {
04124             <span class="keywordflow">if</span> ((StickyBits != 0) || ((ResultOperand-&gt;Mantissa &amp; 0x2) != 0)) {
04125                 ResultOperand-&gt;Mantissa += 2;
04126             }
04127         }
04128 
04129         <span class="keywordflow">break</span>;
04130 
04131         <span class="comment">//</span>
04132         <span class="comment">// Round toward zero.</span>
04133         <span class="comment">//</span>
04134 
04135     <span class="keywordflow">case</span> ROUND_TO_ZERO:
04136         <span class="keywordflow">break</span>;
04137 
04138         <span class="comment">//</span>
04139         <span class="comment">// Round toward plus infinity.</span>
04140         <span class="comment">//</span>
04141 
04142     <span class="keywordflow">case</span> ROUND_TO_PLUS_INFINITY:
04143         <span class="keywordflow">if</span> ((ResultOperand-&gt;Sign == 0) &amp;&amp;
04144             ((StickyBits != 0) || (RoundBit != 0))) {
04145             ResultOperand-&gt;Mantissa += 2;
04146         }
04147 
04148         <span class="keywordflow">break</span>;
04149 
04150         <span class="comment">//</span>
04151         <span class="comment">// Round toward minus infinity.</span>
04152         <span class="comment">//</span>
04153 
04154     <span class="keywordflow">case</span> ROUND_TO_MINUS_INFINITY:
04155         <span class="keywordflow">if</span> ((ResultOperand-&gt;Sign != 0) &amp;&amp;
04156             ((StickyBits != 0) || (RoundBit != 0))) {
04157             ResultOperand-&gt;Mantissa += 2;
04158         }
04159 
04160         <span class="keywordflow">break</span>;
04161     }
04162 
04163     <span class="comment">//</span>
04164     <span class="comment">// If rounding resulted in a carry into bit 25, then right shift the</span>
04165     <span class="comment">// mantissa one bit and adjust the exponent.</span>
04166     <span class="comment">//</span>
04167 
04168     <span class="keywordflow">if</span> ((ResultOperand-&gt;Mantissa &amp; (1 &lt;&lt; 25)) != 0) {
04169         ResultOperand-&gt;Mantissa &gt;&gt;= 1;
04170         ResultOperand-&gt;Exponent += 1;
04171     }
04172 
04173     <span class="comment">//</span>
04174     <span class="comment">// Right shift the mantissa one bit to normalize the final result.</span>
04175     <span class="comment">//</span>
04176 
04177     StickyBits |= RoundBit;
04178     ResultOperand-&gt;Mantissa &gt;&gt;= 1;
04179 
04180     <span class="comment">//</span>
04181     <span class="comment">// If the exponent value is greater than or equal to the maximum</span>
04182     <span class="comment">// exponent value, then overflow has occurred. This results in both</span>
04183     <span class="comment">// the inexact and overflow stickt bits being set in FSR.</span>
04184     <span class="comment">//</span>
04185     <span class="comment">// If the exponent value is less than or equal to the minimum exponent</span>
04186     <span class="comment">// value, the mantissa is nonzero, and the result is inexact or the</span>
04187     <span class="comment">// denormalized result causes loss of accuracy, then underflow has</span>
04188     <span class="comment">// occurred. If denormals are being flushed to zero, then a result of</span>
04189     <span class="comment">// zero is returned. Otherwise, both the inexact and underflow sticky</span>
04190     <span class="comment">// bits are set in FSR.</span>
04191     <span class="comment">//</span>
04192     <span class="comment">// Otherwise, a normal result can be delivered, but it may be inexact.</span>
04193     <span class="comment">// If the result is inexact, then the inexact sticky bit is set in FSR.</span>
04194     <span class="comment">//</span>
04195 
04196     <span class="keywordflow">if</span> (ResultOperand-&gt;Exponent &gt;= SINGLE_MAXIMUM_EXPONENT) {
04197         Inexact = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04198         Overflow = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04199         Underflow = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04200 
04201         <span class="comment">//</span>
04202         <span class="comment">// The overflow value is dependent on the rounding mode.</span>
04203         <span class="comment">//</span>
04204 
04205         <span class="keywordflow">switch</span> (ContextBlock-&gt;Round) {
04206 
04207             <span class="comment">//</span>
04208             <span class="comment">// Round to nearest representable number.</span>
04209             <span class="comment">//</span>
04210             <span class="comment">// The result value is infinity with the sign of the result.</span>
04211             <span class="comment">//</span>
04212 
04213         <span class="keywordflow">case</span> ROUND_TO_NEAREST:
04214             ResultValue = SINGLE_INFINITY_VALUE | (ResultOperand-&gt;Sign &lt;&lt; 31);
04215             <span class="keywordflow">break</span>;
04216 
04217             <span class="comment">//</span>
04218             <span class="comment">// Round toward zero.</span>
04219             <span class="comment">//</span>
04220             <span class="comment">// The result is the maximum number with the sign of the result.</span>
04221             <span class="comment">//</span>
04222 
04223         <span class="keywordflow">case</span> ROUND_TO_ZERO:
04224             ResultValue = SINGLE_MAXIMUM_VALUE | (ResultOperand-&gt;Sign &lt;&lt; 31);
04225             <span class="keywordflow">break</span>;
04226 
04227             <span class="comment">//</span>
04228             <span class="comment">// Round toward plus infinity.</span>
04229             <span class="comment">//</span>
04230             <span class="comment">// If the sign of the result is positive, then the result is</span>
04231             <span class="comment">// plus infinity. Otherwise, the result is the maximum negative</span>
04232             <span class="comment">// number.</span>
04233             <span class="comment">//</span>
04234 
04235         <span class="keywordflow">case</span> ROUND_TO_PLUS_INFINITY:
04236             <span class="keywordflow">if</span> (ResultOperand-&gt;Sign == 0) {
04237                 ResultValue = SINGLE_INFINITY_VALUE;
04238 
04239             } <span class="keywordflow">else</span> {
04240                 ResultValue = (ULONG)(SINGLE_MAXIMUM_VALUE | (1 &lt;&lt; 31));
04241             }
04242 
04243             <span class="keywordflow">break</span>;
04244 
04245             <span class="comment">//</span>
04246             <span class="comment">// Round toward minus infinity.</span>
04247             <span class="comment">//</span>
04248             <span class="comment">// If the sign of the result is negative, then the result is</span>
04249             <span class="comment">// negative infinity. Otherwise, the result is the maximum</span>
04250             <span class="comment">// positive number.</span>
04251             <span class="comment">//</span>
04252 
04253 
04254         <span class="keywordflow">case</span> ROUND_TO_MINUS_INFINITY:
04255             <span class="keywordflow">if</span> (ResultOperand-&gt;Sign != 0) {
04256                 ResultValue = (ULONG)(SINGLE_INFINITY_VALUE | (1 &lt;&lt; 31));
04257 
04258             } <span class="keywordflow">else</span> {
04259                 ResultValue = SINGLE_MAXIMUM_VALUE;
04260             }
04261 
04262             <span class="keywordflow">break</span>;
04263         }
04264 
04265         <span class="comment">//</span>
04266         <span class="comment">// Compute the overflow exception result value by subtracting 192</span>
04267         <span class="comment">// from the exponent.</span>
04268         <span class="comment">//</span>
04269 
04270         ExceptionResult = ResultOperand-&gt;Mantissa &amp; ((1 &lt;&lt; 23) - 1);
04271         ExceptionResult |= ((ResultOperand-&gt;Exponent - 192) &lt;&lt; 23);
04272         ExceptionResult |= (ResultOperand-&gt;Sign &lt;&lt; 31);
04273 
04274     } <span class="keywordflow">else</span> {
04275         <span class="keywordflow">if</span> ((ResultOperand-&gt;Exponent &lt;= SINGLE_MINIMUM_EXPONENT) &amp;&amp;
04276             (ResultOperand-&gt;Mantissa != 0)) {
04277             <span class="keywordflow">if</span> (((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;FS == 0) {
04278                 DenormalizeShift = 1 - ResultOperand-&gt;Exponent;
04279                 <span class="keywordflow">if</span> (DenormalizeShift &gt;= 24) {
04280                     DenormalizeShift = 24;
04281                 }
04282 
04283                 ResultValue = ResultOperand-&gt;Mantissa &gt;&gt; DenormalizeShift;
04284                 ResultValue |= (ResultOperand-&gt;Sign &lt;&lt; 31);
04285                 <span class="keywordflow">if</span> ((StickyBits != 0) ||
04286                     ((ResultOperand-&gt;Mantissa &amp; ((1 &lt;&lt; DenormalizeShift) - 1)) != 0)) {
04287                     Inexact = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04288                     Overflow = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04289                     Underflow = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04290 
04291                     <span class="comment">//</span>
04292                     <span class="comment">// Compute the underflow exception result value by adding</span>
04293                     <span class="comment">// 192 to the exponent.</span>
04294                     <span class="comment">//</span>
04295 
04296                     ExceptionResult = ResultOperand-&gt;Mantissa &amp; ((1 &lt;&lt; 23) - 1);
04297                     ExceptionResult |= ((ResultOperand-&gt;Exponent + 192) &lt;&lt; 23);
04298                     ExceptionResult |= (ResultOperand-&gt;Sign &lt;&lt; 31);
04299 
04300                 } <span class="keywordflow">else</span> {
04301                     Inexact = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04302                     Overflow = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04303                     Underflow = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04304                 }
04305 
04306             } <span class="keywordflow">else</span> {
04307                 ResultValue = 0;
04308                 Inexact = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04309                 Overflow = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04310                 Underflow = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04311             }
04312 
04313         } <span class="keywordflow">else</span> {
04314             <span class="keywordflow">if</span> (ResultOperand-&gt;Mantissa == 0) {
04315                 ResultOperand-&gt;Exponent = 0;
04316             }
04317 
04318             ResultValue = ResultOperand-&gt;Mantissa &amp; ((1 &lt;&lt; 23) - 1);
04319             ResultValue |= (ResultOperand-&gt;Exponent &lt;&lt; 23);
04320             ResultValue |= (ResultOperand-&gt;Sign &lt;&lt; 31);
04321             Inexact = StickyBits ? <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> : <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04322             Overflow = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04323             Underflow = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04324         }
04325     }
04326 
04327     <span class="comment">//</span>
04328     <span class="comment">// Check to determine if an exception should be delivered or the result</span>
04329     <span class="comment">// should be written to the destination register.</span>
04330     <span class="comment">//</span>
04331 
04332     <span class="keywordflow">if</span> (Overflow != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
04333         ((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;SI = 1;
04334         ((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;SO = 1;
04335         <span class="keywordflow">if</span> ((((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;EO != 0) ||
04336             (((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;EI != 0)) {
04337             <span class="keywordflow">if</span> (((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;EO != 0) {
04338                 ExceptionRecord-&gt;ExceptionCode = STATUS_FLOAT_OVERFLOW;
04339 
04340             } <span class="keywordflow">else</span> {
04341                 ExceptionRecord-&gt;ExceptionCode = STATUS_FLOAT_INEXACT_RESULT;
04342             }
04343 
04344             IeeeValue = (PFP_IEEE_VALUE)&amp;ExceptionRecord-&gt;ExceptionInformation[2];
04345             IeeeValue-&gt;Value.Fp32Value.W[0] = ExceptionResult;
04346             ((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;XI = 1;
04347             ((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;XO = 1;
04348             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04349         }
04350 
04351     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Underflow != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
04352         ((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;SI = 1;
04353         ((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;SU = 1;
04354         <span class="keywordflow">if</span> ((((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;EU != 0) ||
04355             (((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;EI != 0)) {
04356             <span class="keywordflow">if</span> (((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;EU != 0) {
04357                 ExceptionRecord-&gt;ExceptionCode = STATUS_FLOAT_UNDERFLOW;
04358 
04359             } <span class="keywordflow">else</span> {
04360                 ExceptionRecord-&gt;ExceptionCode = STATUS_FLOAT_INEXACT_RESULT;
04361             }
04362 
04363             IeeeValue = (PFP_IEEE_VALUE)&amp;ExceptionRecord-&gt;ExceptionInformation[2];
04364             IeeeValue-&gt;Value.Fp32Value.W[0] = ExceptionResult;
04365             ((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;XI = 1;
04366             ((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;XU = 1;
04367             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04368         }
04369 
04370     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Inexact != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
04371         ((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;SI = 1;
04372         <span class="keywordflow">if</span> (((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;EI != 0) {
04373             ExceptionRecord-&gt;ExceptionCode = STATUS_FLOAT_INEXACT_RESULT;
04374             ((PFSR)&amp;TrapFrame-&gt;Fsr)-&gt;XI = 1;
04375             IeeeValue = (PFP_IEEE_VALUE)&amp;ExceptionRecord-&gt;ExceptionInformation[2];
04376             IeeeValue-&gt;Value.Fp32Value.W[0] = ResultValue;
04377             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04378         }
04379 
04380     }
04381 
04382     <span class="comment">//</span>
04383     <span class="comment">// Set the destination register value, update the return address,</span>
04384     <span class="comment">// and return a value of TRUE.</span>
04385     <span class="comment">//</span>
04386 
04387     <a class="code" href="../../d8/d5/ppc_2getsetrg_8c.html#a1">KiSetRegisterValue</a>(ContextBlock-&gt;Fd + 32,
04388                        ResultValue,
04389                        ContextBlock-&gt;ExceptionFrame,
04390                        ContextBlock-&gt;TrapFrame);
04391 
04392     TrapFrame-&gt;Fir = ContextBlock-&gt;BranchAddress;
04393     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04394 }
04395 
04396 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
04397 <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a30">KiUnpackDouble</a> (
04398     IN ULONG Source,
04399     IN PFP_CONTEXT_BLOCK ContextBlock,
04400     OUT PFP_DOUBLE_OPERAND DoubleOperand
04401     )
04402 
04403 <span class="comment">/*++</span>
04404 <span class="comment"></span>
04405 <span class="comment">Routine Description:</span>
04406 <span class="comment"></span>
04407 <span class="comment">    This function is called to unpack a double floating value from the</span>
04408 <span class="comment">    specified source register.</span>
04409 <span class="comment"></span>
04410 <span class="comment">    N.B. The unpacked mantissa value is returned with a guard bit and a</span>
04411 <span class="comment">        round bit on the right and the hidden bit inserted if appropriate.</span>
04412 <span class="comment">        The format of the returned value is:</span>
04413 <span class="comment"></span>
04414 <span class="comment">        &lt;63:55&gt; - zero</span>
04415 <span class="comment">        &lt;54&gt; - hidden bit</span>
04416 <span class="comment">        &lt;53:2&gt; - mantissa</span>
04417 <span class="comment">        &lt;1&gt; - guard bit</span>
04418 <span class="comment">        &lt;0&gt; - round bit</span>
04419 <span class="comment"></span>
04420 <span class="comment">Arguments:</span>
04421 <span class="comment"></span>
04422 <span class="comment">    Source - Supplies the number of the register that contains the operand.</span>
04423 <span class="comment"></span>
04424 <span class="comment">    ContextBlock - Supplies a pointer to the emulation context block.</span>
04425 <span class="comment"></span>
04426 <span class="comment">    DoubleOperand - Supplies a pointer to a structure that is to receive the</span>
04427 <span class="comment">        operand value.</span>
04428 <span class="comment"></span>
04429 <span class="comment">Return Value:</span>
04430 <span class="comment"></span>
04431 <span class="comment">    None.</span>
04432 <span class="comment"></span>
04433 <span class="comment">--*/</span>
04434 
04435 {
04436 
04437     ULONG Value1;
04438     ULONG Value2;
04439 
04440     <span class="comment">//</span>
04441     <span class="comment">// Get the source register value and unpack the sign, exponent, and</span>
04442     <span class="comment">// mantissa value.</span>
04443     <span class="comment">//</span>
04444 
04445     Value1 = <a class="code" href="../../d8/d5/ppc_2getsetrg_8c.html#a0">KiGetRegisterValue</a>(Source + 32,
04446                                 ContextBlock-&gt;ExceptionFrame,
04447                                 ContextBlock-&gt;TrapFrame);
04448 
04449     Value2 = <a class="code" href="../../d8/d5/ppc_2getsetrg_8c.html#a0">KiGetRegisterValue</a>(Source + 32 + 1,
04450                                 ContextBlock-&gt;ExceptionFrame,
04451                                 ContextBlock-&gt;TrapFrame);
04452 
04453     DoubleOperand-&gt;Sign = Value2 &gt;&gt; 31;
04454     DoubleOperand-&gt;Exponent = (Value2 &gt;&gt; (52 - 32)) &amp; 0x7ff;
04455     DoubleOperand-&gt;MantissaHigh = Value2 &amp; 0xfffff;
04456     DoubleOperand-&gt;MantissaLow = Value1;
04457 
04458     <span class="comment">//</span>
04459     <span class="comment">// If the exponent is the largest possible value, then the number is</span>
04460     <span class="comment">// either a Nan or an infinity.</span>
04461     <span class="comment">//</span>
04462 
04463     <span class="keywordflow">if</span> (DoubleOperand-&gt;Exponent == DOUBLE_MAXIMUM_EXPONENT) {
04464         <span class="keywordflow">if</span> ((DoubleOperand-&gt;MantissaLow | DoubleOperand-&gt;MantissaHigh) != 0) {
04465             DoubleOperand-&gt;Infinity = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04466             DoubleOperand-&gt;Nan = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04467 
04468         } <span class="keywordflow">else</span> {
04469             DoubleOperand-&gt;Infinity = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04470             DoubleOperand-&gt;Nan = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04471         }
04472 
04473     } <span class="keywordflow">else</span> {
04474         DoubleOperand-&gt;Infinity = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04475         DoubleOperand-&gt;Nan = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04476         <span class="keywordflow">if</span> (DoubleOperand-&gt;Exponent == DOUBLE_MINIMUM_EXPONENT) {
04477             <span class="keywordflow">if</span> ((DoubleOperand-&gt;MantissaHigh | DoubleOperand-&gt;MantissaLow) != 0) {
04478                 DoubleOperand-&gt;Exponent += 1;
04479                 <span class="keywordflow">while</span> ((DoubleOperand-&gt;MantissaHigh &amp; (1 &lt;&lt; 20)) == 0) {
04480                     DoubleOperand-&gt;MantissaHigh =
04481                             (DoubleOperand-&gt;MantissaHigh &lt;&lt; 1) |
04482                                             (DoubleOperand-&gt;MantissaLow &gt;&gt; 31);
04483                     DoubleOperand-&gt;MantissaLow &lt;&lt;= 1;
04484                     DoubleOperand-&gt;Exponent -= 1;
04485                 }
04486             }
04487 
04488         } <span class="keywordflow">else</span> {
04489             DoubleOperand-&gt;MantissaHigh |= (1 &lt;&lt; 20);
04490         }
04491     }
04492 
04493     <span class="comment">//</span>
04494     <span class="comment">// Left shift the mantissa 2-bits to provide for a guard bit and a round</span>
04495     <span class="comment">// bit.</span>
04496     <span class="comment">//</span>
04497 
04498     DoubleOperand-&gt;MantissaHigh =
04499         (DoubleOperand-&gt;MantissaHigh &lt;&lt; 2) | (DoubleOperand-&gt;MantissaLow &gt;&gt; 30);
04500     DoubleOperand-&gt;MantissaLow &lt;&lt;= 2;
04501     <span class="keywordflow">return</span>;
04502 }
04503 
04504 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
04505 <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a31">KiUnpackSingle</a> (
04506     IN ULONG Source,
04507     IN PFP_CONTEXT_BLOCK ContextBlock,
04508     OUT PFP_SINGLE_OPERAND SingleOperand
04509     )
04510 
04511 <span class="comment">/*++</span>
04512 <span class="comment"></span>
04513 <span class="comment">Routine Description:</span>
04514 <span class="comment"></span>
04515 <span class="comment">    This function is called to unpack a single floating value from the</span>
04516 <span class="comment">    specified source register.</span>
04517 <span class="comment"></span>
04518 <span class="comment">    N.B. The unpacked mantissa value is returned with a guard bit and a</span>
04519 <span class="comment">        round bit on the right and the hidden bit inserted if appropriate.</span>
04520 <span class="comment">        The format of the returned value is:</span>
04521 <span class="comment"></span>
04522 <span class="comment">        &lt;31:26&gt; - zero</span>
04523 <span class="comment">        &lt;25&gt; - hidden bit</span>
04524 <span class="comment">        &lt;24:2&gt; - mantissa</span>
04525 <span class="comment">        &lt;1&gt; - guard bit</span>
04526 <span class="comment">        &lt;0&gt; - round bit</span>
04527 <span class="comment"></span>
04528 <span class="comment">Arguments:</span>
04529 <span class="comment"></span>
04530 <span class="comment">    Source - Supplies the number of the register that contains the operand.</span>
04531 <span class="comment"></span>
04532 <span class="comment">    ContextBlock - Supplies a pointer to the emulation context block.</span>
04533 <span class="comment"></span>
04534 <span class="comment">    SingleOperand - Supplies a pointer to a structure that is to receive the</span>
04535 <span class="comment">        operand value.</span>
04536 <span class="comment"></span>
04537 <span class="comment">Return Value:</span>
04538 <span class="comment"></span>
04539 <span class="comment">    None.</span>
04540 <span class="comment"></span>
04541 <span class="comment">--*/</span>
04542 
04543 {
04544 
04545     ULONG Value;
04546 
04547     <span class="comment">//</span>
04548     <span class="comment">// Get the source register value and unpack the sign, exponent, and</span>
04549     <span class="comment">// mantissa value.</span>
04550     <span class="comment">//</span>
04551 
04552     Value = <a class="code" href="../../d8/d5/ppc_2getsetrg_8c.html#a0">KiGetRegisterValue</a>(Source + 32,
04553                                ContextBlock-&gt;ExceptionFrame,
04554                                ContextBlock-&gt;TrapFrame);
04555 
04556     SingleOperand-&gt;Sign = Value &gt;&gt; 31;
04557     SingleOperand-&gt;Exponent = (Value &gt;&gt; 23) &amp; 0xff;
04558     SingleOperand-&gt;Mantissa = Value &amp; 0x7fffff;
04559 
04560     <span class="comment">//</span>
04561     <span class="comment">// If the exponent is the largest possible value, then the number is</span>
04562     <span class="comment">// either a Nan or an infinity.</span>
04563     <span class="comment">//</span>
04564 
04565     <span class="keywordflow">if</span> (SingleOperand-&gt;Exponent == SINGLE_MAXIMUM_EXPONENT) {
04566         <span class="keywordflow">if</span> (SingleOperand-&gt;Mantissa != 0) {
04567             SingleOperand-&gt;Infinity = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04568             SingleOperand-&gt;Nan = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04569 
04570         } <span class="keywordflow">else</span> {
04571             SingleOperand-&gt;Infinity = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04572             SingleOperand-&gt;Nan = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04573         }
04574 
04575     } <span class="keywordflow">else</span> {
04576         SingleOperand-&gt;Infinity = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04577         SingleOperand-&gt;Nan = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04578         <span class="keywordflow">if</span> (SingleOperand-&gt;Exponent == SINGLE_MINIMUM_EXPONENT) {
04579             <span class="keywordflow">if</span> (SingleOperand-&gt;Mantissa != 0) {
04580                 SingleOperand-&gt;Exponent += 1;
04581                 <span class="keywordflow">while</span> ((SingleOperand-&gt;Mantissa &amp; (1 &lt;&lt; 23)) == 0) {
04582                     SingleOperand-&gt;Mantissa &lt;&lt;= 1;
04583                     SingleOperand-&gt;Exponent -= 1;
04584                 }
04585             }
04586 
04587         } <span class="keywordflow">else</span> {
04588             SingleOperand-&gt;Mantissa |= (1 &lt;&lt; 23);
04589         }
04590     }
04591 
04592     <span class="comment">//</span>
04593     <span class="comment">// Left shift the mantissa 2-bits to provide for a guard bit and a round</span>
04594     <span class="comment">// bit.</span>
04595     <span class="comment">//</span>
04596 
04597     SingleOperand-&gt;Mantissa &lt;&lt;= 2;
04598     <span class="keywordflow">return</span>;
04599 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:40:01 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
