<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: ia64.h Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>ia64.h</h1><a href="../../d3/d4/ia64_8h.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Module Name:</span>
00004 <span class="comment"></span>
00005 <span class="comment">    ia64.h</span>
00006 <span class="comment"></span>
00007 <span class="comment">Abstract:</span>
00008 <span class="comment"></span>
00009 <span class="comment">    This module contains the IA64 hardware specific header file.</span>
00010 <span class="comment"></span>
00011 <span class="comment">Author:</span>
00012 <span class="comment"></span>
00013 <span class="comment">    David N. Cutler (davec) 31-Mar-1990</span>
00014 <span class="comment"></span>
00015 <span class="comment">Revision History:</span>
00016 <span class="comment"></span>
00017 <span class="comment">    Bernard Lint 6-Jun-1995: IA64 version based on MIPS version.</span>
00018 <span class="comment"></span>
00019 <span class="comment">--*/</span>
00020 
00021 <span class="preprocessor">#ifndef _IA64H_</span>
00022 <span class="preprocessor"></span><span class="preprocessor">#define _IA64H_</span>
00023 <span class="preprocessor"></span>
00024 <span class="comment">//</span>
00025 <span class="comment">// Interruption history</span>
00026 <span class="comment">//</span>
00027 <span class="comment">// N.B. Currently the history records are saved in the 2nd half of the 8K </span>
00028 <span class="comment">//      PCR page.  Therefore, we can only keep track of up to the latest</span>
00029 <span class="comment">//      128 interruption records, each of 32 bytes in size.  Also, the PCR</span>
00030 <span class="comment">//      structure cannot be greater than 4K.  In the future, the interruption</span>
00031 <span class="comment">//      history records may become part of the KPCR structure.</span>
00032 <span class="comment">//</span>
00033 
<a name="l00034"></a><a class="code" href="../../d0/d1/struct__IHISTORY__RECORD.html">00034</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d0/d1/struct__IHISTORY__RECORD.html">_IHISTORY_RECORD</a> {
<a name="l00035"></a><a class="code" href="../../d0/d1/struct__IHISTORY__RECORD.html#o0">00035</a>     ULONGLONG <a class="code" href="../../d0/d1/struct__IHISTORY__RECORD.html#o0">InterruptionType</a>;
<a name="l00036"></a><a class="code" href="../../d0/d1/struct__IHISTORY__RECORD.html#o1">00036</a>     ULONGLONG <a class="code" href="../../d0/d1/struct__IHISTORY__RECORD.html#o1">IIP</a>;
<a name="l00037"></a><a class="code" href="../../d0/d1/struct__IHISTORY__RECORD.html#o2">00037</a>     ULONGLONG <a class="code" href="../../d0/d1/struct__IHISTORY__RECORD.html#o2">IPSR</a>;
<a name="l00038"></a><a class="code" href="../../d0/d1/struct__IHISTORY__RECORD.html#o3">00038</a>     ULONGLONG <a class="code" href="../../d0/d1/struct__IHISTORY__RECORD.html#o3">Extra0</a>;
00039 } <a class="code" href="../../d0/d1/struct__IHISTORY__RECORD.html">IHISTORY_RECORD</a>;
00040 
<a name="l00041"></a><a class="code" href="../../d3/d4/ia64_8h.html#a0">00041</a> <span class="preprocessor">#define MAX_NUMBER_OF_IHISTORY_RECORDS  128</span>
00042 <span class="preprocessor"></span>
00043 <span class="comment">//</span>
00044 <span class="comment">// For PSR bit field definitions</span>
00045 <span class="comment">//</span>
00046 <span class="preprocessor">#include "kxia64.h"</span>
00047 
00048 
00049 <span class="comment">// begin_ntddk begin_wdm begin_nthal begin_ntndis</span>
00050 
00051 <span class="preprocessor">#if defined(_IA64_)</span>
00052 <span class="preprocessor"></span>
00053 <span class="comment">//</span>
00054 <span class="comment">// Types to use to contain PFNs and their counts.</span>
00055 <span class="comment">//</span>
00056 
00057 <span class="keyword">typedef</span> ULONG PFN_COUNT;
00058 
00059 <span class="keyword">typedef</span> LONG_PTR SPFN_NUMBER, *PSPFN_NUMBER;
00060 <span class="keyword">typedef</span> ULONG_PTR PFN_NUMBER, *PPFN_NUMBER;    
00061 
00062 <span class="comment">//</span>
00063 <span class="comment">// Define maximum size of flush multiple TB request.</span>
00064 <span class="comment">//</span>
00065 
00066 <span class="preprocessor">#define FLUSH_MULTIPLE_MAXIMUM 100</span>
00067 <span class="preprocessor"></span>
00068 <span class="comment">//</span>
00069 <span class="comment">// Indicate that the IA64 compiler supports the pragma textout construct.</span>
00070 <span class="comment">//</span>
00071 
00072 <span class="preprocessor">#define ALLOC_PRAGMA 1</span>
00073 <span class="preprocessor"></span>
00074 <span class="comment">//</span>
00075 <span class="comment">// Define intrinsic calls and their prototypes</span>
00076 <span class="comment">//</span>
00077 
00078 <span class="preprocessor">#include "ia64reg.h"</span>
00079 
00080 <span class="comment">// Please contact INTEL to get IA64-specific information</span>
00081 <span class="comment">// @@BEGIN_DDKSPLIT</span>
00082 
00083 <span class="keywordtype">unsigned</span> __int64 __getReg (<span class="keywordtype">int</span>);         <span class="comment">// Intel-IA64-Filler</span>
00084 <span class="keywordtype">void</span> __setReg (<span class="keywordtype">int</span>, <span class="keywordtype">unsigned</span> __int64);   <span class="comment">// Intel-IA64-Filler</span>
00085 <span class="keywordtype">void</span> __isrlz (<span class="keywordtype">void</span>);                     <span class="comment">// Intel-IA64-Filler</span>
00086 <span class="keywordtype">void</span> __dsrlz (<span class="keywordtype">void</span>);                     <span class="comment">// Intel-IA64-Filler</span>
00087 <span class="keywordtype">void</span> __fwb (<span class="keywordtype">void</span>);                       <span class="comment">// Intel-IA64-Filler</span>
00088 <span class="keywordtype">void</span> __mf (<span class="keywordtype">void</span>);                        <span class="comment">// Intel-IA64-Filler</span>
00089 <span class="keywordtype">void</span> __mfa (<span class="keywordtype">void</span>);                       <span class="comment">// Intel-IA64-Filler</span>
00090 <span class="keywordtype">void</span> __synci (<span class="keywordtype">void</span>);                     <span class="comment">// Intel-IA64-Filler</span>
00091 __int64 __thash (__int64);               <span class="comment">// Intel-IA64-Filler</span>
00092 __int64 __ttag (__int64);                <span class="comment">// Intel-IA64-Filler</span>
00093 <span class="keywordtype">void</span> __ptcl (__int64, __int64);          <span class="comment">// Intel-IA64-Filler</span>
00094 <span class="keywordtype">void</span> __ptcg (__int64, __int64);          <span class="comment">// Intel-IA64-Filler</span>
00095 <span class="keywordtype">void</span> __ptcga (__int64, __int64);         <span class="comment">// Intel-IA64-Filler</span>
00096 <span class="keywordtype">void</span> __ptri (__int64, __int64);          <span class="comment">// Intel-IA64-Filler</span>
00097 <span class="keywordtype">void</span> __ptrd (__int64, __int64);          <span class="comment">// Intel-IA64-Filler</span>
00098 <span class="keywordtype">void</span> __invalat (<span class="keywordtype">void</span>);                   <span class="comment">// Intel-IA64-Filler</span>
00099 <span class="keywordtype">void</span> __break (<span class="keywordtype">int</span>);                      <span class="comment">// Intel-IA64-Filler</span>
00100 <span class="keywordtype">void</span> __fc (__int64);                     <span class="comment">// Intel-IA64-Filler</span>
00101 <span class="keywordtype">void</span> __sum (<span class="keywordtype">int</span>);                        <span class="comment">// Intel-IA64-Filler</span>
00102 <span class="keywordtype">void</span> __rsm (<span class="keywordtype">int</span>);                        <span class="comment">// Intel-IA64-Filler</span>
00103 
00104 <span class="preprocessor">#ifdef _M_IA64</span>
00105 <span class="preprocessor"></span><span class="preprocessor">#pragma intrinsic (__getReg)             // Intel-IA64-Filler</span>
00106 <span class="preprocessor"></span><span class="preprocessor">#pragma intrinsic (__setReg)             // Intel-IA64-Filler</span>
00107 <span class="preprocessor"></span><span class="preprocessor">#pragma intrinsic (__isrlz)              // Intel-IA64-Filler</span>
00108 <span class="preprocessor"></span><span class="preprocessor">#pragma intrinsic (__dsrlz)              // Intel-IA64-Filler</span>
00109 <span class="preprocessor"></span><span class="preprocessor">#pragma intrinsic (__fwb)                // Intel-IA64-Filler</span>
00110 <span class="preprocessor"></span><span class="preprocessor">#pragma intrinsic (__mf)                 // Intel-IA64-Filler</span>
00111 <span class="preprocessor"></span><span class="preprocessor">#pragma intrinsic (__mfa)                // Intel-IA64-Filler</span>
00112 <span class="preprocessor"></span><span class="preprocessor">#pragma intrinsic (__synci)              // Intel-IA64-Filler</span>
00113 <span class="preprocessor"></span><span class="preprocessor">#pragma intrinsic (__thash)              // Intel-IA64-Filler</span>
00114 <span class="preprocessor"></span><span class="preprocessor">#pragma intrinsic (__ttag)               // Intel-IA64-Filler</span>
00115 <span class="preprocessor"></span><span class="preprocessor">#pragma intrinsic (__ptcl)               // Intel-IA64-Filler</span>
00116 <span class="preprocessor"></span><span class="preprocessor">#pragma intrinsic (__ptcg)               // Intel-IA64-Filler</span>
00117 <span class="preprocessor"></span><span class="preprocessor">#pragma intrinsic (__ptcga)              // Intel-IA64-Filler</span>
00118 <span class="preprocessor"></span><span class="preprocessor">#pragma intrinsic (__ptri)               // Intel-IA64-Filler</span>
00119 <span class="preprocessor"></span><span class="preprocessor">#pragma intrinsic (__ptrd)               // Intel-IA64-Filler</span>
00120 <span class="preprocessor"></span><span class="preprocessor">#pragma intrinsic (__invalat)            // Intel-IA64-Filler</span>
00121 <span class="preprocessor"></span><span class="preprocessor">#pragma intrinsic (__break)              // Intel-IA64-Filler</span>
00122 <span class="preprocessor"></span><span class="preprocessor">#pragma intrinsic (__fc)                 // Intel-IA64-Filler</span>
00123 <span class="preprocessor"></span><span class="preprocessor">#pragma intrinsic (__sum)                // Intel-IA64-Filler</span>
00124 <span class="preprocessor"></span><span class="preprocessor">#pragma intrinsic (__rsm)                // Intel-IA64-Filler</span>
00125 <span class="preprocessor"></span><span class="preprocessor">#endif // _M_IA64</span>
00126 <span class="preprocessor"></span>
00127 <span class="comment">// @@END_DDKSPLIT</span>
00128 
00129 <span class="comment">// end_wdm end_ntndis</span>
00130 
00131 <span class="comment">//</span>
00132 <span class="comment">// Define macro to generate import names.</span>
00133 <span class="comment">//</span>
00134 
00135 <span class="preprocessor">#define IMPORT_NAME(name) __imp_##name</span>
00136 <span class="preprocessor"></span>
00137 <span class="comment">// begin_wdm</span>
00138 
00139 <span class="comment">//</span>
00140 <span class="comment">// Define length of interrupt vector table.</span>
00141 <span class="comment">//</span>
00142 
00143 <span class="comment">// Please contact INTEL to get IA64-specific information</span>
00144 <span class="preprocessor">#define MAXIMUM_VECTOR 256</span>
00145 <span class="preprocessor"></span>
00146 <span class="comment">// end_wdm</span>
00147 
00148 
00149 <span class="comment">//</span>
00150 <span class="comment">// IA64 specific interlocked operation result values.</span>
00151 <span class="comment">//</span>
00152 
00153 <span class="preprocessor">#define RESULT_ZERO 0</span>
00154 <span class="preprocessor"></span><span class="preprocessor">#define RESULT_NEGATIVE 1</span>
00155 <span class="preprocessor"></span><span class="preprocessor">#define RESULT_POSITIVE 2</span>
00156 <span class="preprocessor"></span>
00157 <span class="comment">//</span>
00158 <span class="comment">// Interlocked result type is portable, but its values are machine specific.</span>
00159 <span class="comment">// Constants for values are in i386.h, mips.h, etc.</span>
00160 <span class="comment">//</span>
00161 
00162 <span class="keyword">typedef</span> <span class="keyword">enum</span> _INTERLOCKED_RESULT {
00163     ResultNegative = RESULT_NEGATIVE,
00164     ResultZero     = RESULT_ZERO,
00165     ResultPositive = RESULT_POSITIVE
00166 } INTERLOCKED_RESULT;
00167 
00168 <span class="comment">//</span>
00169 <span class="comment">// Convert portable interlock interfaces to architecture specific interfaces.</span>
00170 <span class="comment">//</span>
00171 
00172 <span class="preprocessor">#define ExInterlockedIncrementLong(Addend, Lock) \</span>
00173 <span class="preprocessor">    ExIa64InterlockedIncrementLong(Addend)</span>
00174 <span class="preprocessor"></span>
00175 <span class="preprocessor">#define ExInterlockedDecrementLong(Addend, Lock) \</span>
00176 <span class="preprocessor">    ExIa64InterlockedDecrementLong(Addend)</span>
00177 <span class="preprocessor"></span>
00178 <span class="preprocessor">#define ExInterlockedExchangeAddLargeInteger(Target, Value, Lock) \</span>
00179 <span class="preprocessor">    ExpInterlockedExchangeAddLargeInteger(Target, Value)</span>
00180 <span class="preprocessor"></span>
00181 <span class="preprocessor">#define ExInterlockedExchangeUlong(Target, Value, Lock) \</span>
00182 <span class="preprocessor">    ExIa64InterlockedExchangeUlong(Target, Value)</span>
00183 <span class="preprocessor"></span>
00184 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00185 INTERLOCKED_RESULT
00186 ExIa64InterlockedIncrementLong (
00187     IN PLONG Addend
00188     );
00189 
00190 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00191 INTERLOCKED_RESULT
00192 ExIa64InterlockedDecrementLong (
00193     IN PLONG Addend
00194     );
00195 
00196 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00197 LARGE_INTEGER
00198 ExpInterlockedExchangeAddLargeInteger (
00199     IN PLARGE_INTEGER Addend,
00200     IN LARGE_INTEGER Increment
00201     );
00202 
00203 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00204 ULONG
00205 ExIa64InterlockedExchangeUlong (
00206     IN PULONG Target,
00207     IN ULONG Value
00208     );
00209 
00210 <span class="comment">// begin_wdm</span>
00211 
00212 <span class="comment">//</span>
00213 <span class="comment">// IA64 Interrupt Definitions.</span>
00214 <span class="comment">//</span>
00215 <span class="comment">// Define length of interrupt object dispatch code in longwords.</span>
00216 <span class="comment">//</span>
00217 
00218 <span class="comment">// Please contact INTEL to get IA64-specific information</span>
00219 <span class="comment">// @@BEGIN_DDKSPLIT</span>
00220 <span class="preprocessor">#define DISPATCH_LENGTH 2*2               // Intel-IA64-Filler ; Length of dispatch code template in 32-bit words</span>
00221 <span class="preprocessor"></span><span class="comment">// @@END_DDKSPLIT</span>
00222 
00223 <span class="comment">//</span>
00224 <span class="comment">// Begin of a block of definitions that must be synchronized with kxia64.h.</span>
00225 <span class="comment">//</span>
00226 
00227 <span class="comment">//</span>
00228 <span class="comment">// Define Interrupt Request Levels.</span>
00229 <span class="comment">//</span>
00230 
00231 <span class="preprocessor">#define PASSIVE_LEVEL            0      // Passive release level</span>
00232 <span class="preprocessor"></span><span class="preprocessor">#define LOW_LEVEL                0      // Lowest interrupt level</span>
00233 <span class="preprocessor"></span><span class="preprocessor">#define APC_LEVEL                1      // APC interrupt level</span>
00234 <span class="preprocessor"></span><span class="preprocessor">#define DISPATCH_LEVEL           2      // Dispatcher level</span>
00235 <span class="preprocessor"></span><span class="preprocessor">#define CMC_LEVEL                3      // Correctable machine check level</span>
00236 <span class="preprocessor"></span><span class="preprocessor">#define DEVICE_LEVEL_BASE        4      // 4 - 11 - Device IRQLs</span>
00237 <span class="preprocessor"></span><span class="preprocessor">#define PROFILE_LEVEL           12      // Profiling level</span>
00238 <span class="preprocessor"></span><span class="preprocessor">#define PC_LEVEL                12      // Performance Counter IRQL</span>
00239 <span class="preprocessor"></span><span class="preprocessor">#define SYNCH_LEVEL             (IPI_LEVEL-1)      // Synchronization level</span>
00240 <span class="preprocessor"></span><span class="preprocessor">#define IPI_LEVEL               14      // IPI IRQL</span>
00241 <span class="preprocessor"></span><span class="preprocessor">#define CLOCK_LEVEL             13      // Clock Timer IRQL</span>
00242 <span class="preprocessor"></span><span class="preprocessor">#define POWER_LEVEL             15      // Power failure level</span>
00243 <span class="preprocessor"></span><span class="preprocessor">#define HIGH_LEVEL              15      // Highest interrupt level</span>
00244 <span class="preprocessor"></span>
00245 <span class="comment">// Please contact INTEL to get IA64-specific information</span>
00246 <span class="comment">// @@BEGIN_DDKSPLIT</span>
00247 <span class="comment">//</span>
00248 <span class="comment">// The current IRQL is maintained in the TPR.mic field. The         // Intel-IA64-Filler</span>
00249 <span class="comment">// shift count is the number of bits to shift right to extract the  // Intel-IA64-Filler</span>
00250 <span class="comment">// IRQL from the TPR. See the GET/SET_IRQL macros.                  // Intel-IA64-Filler</span>
00251 <span class="comment">//</span>
00252 
00253 <span class="preprocessor">#define TPR_MIC        4                                            // Intel-IA64-Filler</span>
00254 <span class="preprocessor"></span><span class="preprocessor">#define TPR_IRQL_SHIFT TPR_MIC                                      // Intel-IA64-Filler</span>
00255 <span class="preprocessor"></span>
00256 <span class="comment">// To go from vector number &lt;-&gt; IRQL we just do a shift             // Intel-IA64-Filler</span>
00257 <span class="preprocessor">#define VECTOR_IRQL_SHIFT TPR_IRQL_SHIFT                            // Intel-IA64-Filler</span>
00258 <span class="preprocessor"></span>
00259 <span class="comment">//                                                                  // Intel-IA64-Filler</span>
00260 <span class="comment">// Interrupt Vector Definitions                                     // Intel-IA64-Filler</span>
00261 <span class="comment">//                                                                  // Intel-IA64-Filler</span>
00262 
00263 <span class="preprocessor">#define APC_VECTOR          APC_LEVEL &lt;&lt; VECTOR_IRQL_SHIFT          // Intel-IA64-Filler</span>
00264 <span class="preprocessor"></span><span class="preprocessor">#define DISPATCH_VECTOR     DISPATCH_LEVEL &lt;&lt; VECTOR_IRQL_SHIFT     // Intel-IA64-Filler</span>
00265 <span class="preprocessor"></span>
00266 <span class="comment">// @@END_DDKSPLIT</span>
00267 
00268 <span class="comment">//</span>
00269 <span class="comment">// End of a block of definitions that must be synchronized with kxia64.h.</span>
00270 <span class="comment">//</span>
00271 
00272 <span class="comment">//</span>
00273 <span class="comment">// Define profile intervals.</span>
00274 <span class="comment">//</span>
00275 
00276 <span class="preprocessor">#define DEFAULT_PROFILE_COUNT 0x40000000 // ~= 20 seconds @50mhz</span>
00277 <span class="preprocessor"></span><span class="preprocessor">#define DEFAULT_PROFILE_INTERVAL (10 * 500) // 500 microseconds</span>
00278 <span class="preprocessor"></span><span class="preprocessor">#define MAXIMUM_PROFILE_INTERVAL (10 * 1000 * 1000) // 1 second</span>
00279 <span class="preprocessor"></span><span class="preprocessor">#define MINIMUM_PROFILE_INTERVAL (10 * 40) // 40 microseconds</span>
00280 <span class="preprocessor"></span>
00281 <span class="preprocessor">#if defined(_M_IA64) &amp;&amp; !defined(RC_INVOKED)</span>
00282 <span class="preprocessor"></span>
00283 <span class="preprocessor">#define InterlockedAdd _InterlockedAdd</span>
00284 <span class="preprocessor"></span><span class="preprocessor">#define InterlockedIncrement _InterlockedIncrement</span>
00285 <span class="preprocessor"></span><span class="preprocessor">#define InterlockedDecrement _InterlockedDecrement</span>
00286 <span class="preprocessor"></span><span class="preprocessor">#define InterlockedExchange _InterlockedExchange</span>
00287 <span class="preprocessor"></span><span class="preprocessor">#define InterlockedExchangeAdd _InterlockedExchangeAdd</span>
00288 <span class="preprocessor"></span>
00289 <span class="preprocessor">#define InterlockedAdd64 _InterlockedAdd64</span>
00290 <span class="preprocessor"></span><span class="preprocessor">#define InterlockedIncrement64 _InterlockedIncrement64</span>
00291 <span class="preprocessor"></span><span class="preprocessor">#define InterlockedDecrement64 _InterlockedDecrement64</span>
00292 <span class="preprocessor"></span><span class="preprocessor">#define InterlockedExchange64 _InterlockedExchange64</span>
00293 <span class="preprocessor"></span><span class="preprocessor">#define InterlockedExchangeAdd64 _InterlockedExchangeAdd64</span>
00294 <span class="preprocessor"></span><span class="preprocessor">#define InterlockedCompareExchange64 _InterlockedCompareExchange64</span>
00295 <span class="preprocessor"></span>
00296 <span class="preprocessor">#define InterlockedCompareExchange _InterlockedCompareExchange</span>
00297 <span class="preprocessor"></span><span class="preprocessor">#define InterlockedExchangePointer _InterlockedExchangePointer</span>
00298 <span class="preprocessor"></span><span class="preprocessor">#define InterlockedCompareExchangePointer _InterlockedCompareExchangePointer</span>
00299 <span class="preprocessor"></span>
00300 LONG
00301 __cdecl
00302 InterlockedAdd (
00303     LONG *Addend,
00304     LONG Value
00305     );
00306 
00307 LONGLONG
00308 __cdecl
00309 InterlockedAdd64 (
00310     LONGLONG *Addend,
00311     LONGLONG Value
00312     );
00313 
00314 LONG
00315 __cdecl
00316 InterlockedIncrement(
00317     IN OUT PLONG Addend
00318     );
00319 
00320 LONG
00321 __cdecl
00322 InterlockedDecrement(
00323     IN OUT PLONG Addend
00324     );
00325 
00326 LONG
00327 __cdecl
00328 InterlockedExchange(
00329     IN OUT PLONG Target,
00330     IN LONG Value
00331     );
00332 
00333 LONG
00334 __cdecl
00335 InterlockedExchangeAdd(
00336     IN OUT PLONG Addend,
00337     IN LONG Value
00338     );
00339 
00340 LONG
00341 __cdecl
00342 InterlockedCompareExchange (
00343     IN OUT PLONG Destination,
00344     IN LONG ExChange,
00345     IN LONG Comperand
00346     );
00347 
00348 LONGLONG
00349 __cdecl
00350 InterlockedIncrement64(
00351     IN OUT PLONGLONG Addend
00352     );
00353 
00354 LONGLONG
00355 __cdecl
00356 InterlockedDecrement64(
00357     IN OUT PLONGLONG Addend
00358     );
00359 
00360 LONGLONG
00361 __cdecl
00362 InterlockedExchange64(
00363     IN OUT PLONGLONG Target,
00364     IN LONGLONG Value
00365     );
00366 
00367 LONGLONG
00368 __cdecl
00369 InterlockedExchangeAdd64(
00370     IN OUT PLONGLONG Addend,
00371     IN LONGLONG Value
00372     );
00373 
00374 LONGLONG
00375 __cdecl
00376 InterlockedCompareExchange64 (
00377     IN OUT PLONGLONG Destination,
00378     IN LONGLONG ExChange,
00379     IN LONGLONG Comperand
00380     );
00381 
00382 PVOID
00383 __cdecl
00384 InterlockedCompareExchangePointer (
00385     IN OUT PVOID *Destination,
00386     IN PVOID Exchange,
00387     IN PVOID Comperand
00388     );
00389 
00390 PVOID
00391 __cdecl
00392 InterlockedExchangePointer(
00393     IN OUT PVOID *Target,
00394     IN PVOID Value
00395     );
00396 
00397 <span class="preprocessor">#pragma intrinsic(_InterlockedAdd)</span>
00398 <span class="preprocessor"></span><span class="preprocessor">#pragma intrinsic(_InterlockedIncrement)</span>
00399 <span class="preprocessor"></span><span class="preprocessor">#pragma intrinsic(_InterlockedDecrement)</span>
00400 <span class="preprocessor"></span><span class="preprocessor">#pragma intrinsic(_InterlockedExchange)</span>
00401 <span class="preprocessor"></span><span class="preprocessor">#pragma intrinsic(_InterlockedCompareExchange)</span>
00402 <span class="preprocessor"></span><span class="preprocessor">#pragma intrinsic(_InterlockedExchangeAdd)</span>
00403 <span class="preprocessor"></span><span class="preprocessor">#pragma intrinsic(_InterlockedAdd64)</span>
00404 <span class="preprocessor"></span><span class="preprocessor">#pragma intrinsic(_InterlockedIncrement64)</span>
00405 <span class="preprocessor"></span><span class="preprocessor">#pragma intrinsic(_InterlockedDecrement64)</span>
00406 <span class="preprocessor"></span><span class="preprocessor">#pragma intrinsic(_InterlockedExchange64)</span>
00407 <span class="preprocessor"></span><span class="preprocessor">#pragma intrinsic(_InterlockedCompareExchange64)</span>
00408 <span class="preprocessor"></span><span class="preprocessor">#pragma intrinsic(_InterlockedExchangeAdd64)</span>
00409 <span class="preprocessor"></span><span class="preprocessor">#pragma intrinsic(_InterlockedExchangePointer)</span>
00410 <span class="preprocessor"></span><span class="preprocessor">#pragma intrinsic(_InterlockedCompareExchangePointer)</span>
00411 <span class="preprocessor"></span>
00412 <span class="preprocessor">#endif // defined(_M_IA64) &amp;&amp; !defined(RC_INVOKED)</span>
00413 <span class="preprocessor"></span>
00414 <span class="comment">// end_ntddk end_nthal end_wdm</span>
00415 
00416 <span class="preprocessor">#define KiSynchIrql SYNCH_LEVEL         // enable portable code</span>
00417 <span class="preprocessor"></span><span class="preprocessor">#define KiProfileIrql PROFILE_LEVEL     // enable portable code</span>
00418 <span class="preprocessor"></span>
00419 
00420 <span class="comment">// Please contact INTEL to get IA64-specific information</span>
00421 <span class="comment">// @@BEGIN_DDKSPLIT</span>
00422 <span class="comment">//</span>
00423 <span class="comment">// Sanitize FPSR based on processor mode.</span>
00424 <span class="comment">//</span>
00425 <span class="comment">// If kernel mode, then</span>
00426 <span class="comment">//      let caller specify all bits, except reserved</span>
00427 <span class="comment">//</span>
00428 <span class="comment">// If user mode, then</span>
00429 <span class="comment">//      let the caller specify all bits, except reserved</span>
00430 <span class="comment">//</span>
00431 
00432 <span class="preprocessor">#define SANITIZE_FSR(fsr, mode) (  </span><span class="comment">/* Intel-IA64-Filler */</span> \
00433     ((mode) == KernelMode ?  <span class="comment">/* Intel-IA64-Filler */</span> \
00434         ((0x0000000000000000UL) | ((fsr) &amp; ~(MASK_IA64(FPSR_MBZ0,FPSR_MBZ0_V)))) :  <span class="comment">/* Intel-IA64-Filler */</span> \
00435         ((0x0000000000000000UL) | ((fsr) &amp; ~(MASK_IA64(FPSR_MBZ0,FPSR_MBZ0_V))))  <span class="comment">/* Intel-IA64-Filler */</span> \
00436     )  <span class="comment">/* Intel-IA64-Filler */</span> \
00437                                 )  // Intel-IA64-Filler
00438 <span class="comment">//</span>
00439 <span class="comment">// Define SANITIZE_PSR for IA64     // Intel-IA64-Filler</span>
00440 <span class="comment">//</span>
00441 <span class="comment">// If kernel mode, then     // Intel-IA64-Filler</span>
00442 <span class="comment">//      force clearing of BE, SP, CPL, MC, PK, DFL, reserved (MBZ)     // Intel-IA64-Filler</span>
00443 <span class="comment">//      force the setting of IC, DT, DFH, DI, LP, RT, IT      // Intel-IA64-Filler</span>
00444 <span class="comment">//      let caller specify UP, AC, I, BN, PP, SI, DB, TB, IS, ID, DA, DD, SS, RI, ED     // Intel-IA64-Filler</span>
00445 <span class="comment">//</span>
00446 <span class="comment">// If user mode, then     // Intel-IA64-Filler</span>
00447 <span class="comment">//      force clearing of MC, PK, LP, reserved     // Intel-IA64-Filler</span>
00448 <span class="comment">//      force the setting of BN, IC, I, DT, RT, CPL, IT     // Intel-IA64-Filler</span>
00449 <span class="comment">//      let caller specify BE, UP, PP, AC, DFL, DFH, SP, SI, DI, DB, TB, IS, ID, DA, DD, SS, RI, ED     // Intel-IA64-Filler</span>
00450 <span class="comment">//</span>
00451 
00452 <span class="preprocessor">#define PSR_KERNEL_CLR  (MASK_IA64(PSR_BE,1i64) | MASK_IA64(PSR_SP,1i64) | MASK_IA64(PSR_PK,1i64) | </span><span class="comment">/* Intel-IA64-Filler */</span> \
00453                          MASK_IA64(PSR_CPL,0x3i64) | MASK_IA64(PSR_MC,1i64) | MASK_IA64(PSR_MBZ0,PSR_MBZ0_V) | <span class="comment">/* Intel-IA64-Filler */</span> \
00454                          MASK_IA64(PSR_MBZ1,PSR_MBZ1_V) | MASK_IA64(PSR_MBZ2,PSR_MBZ2) | <span class="comment">/* Intel-IA64-Filler */</span> \
00455                          MASK_IA64(PSR_DFL, 1i64)) // Intel-IA64-Filler
00456 
00457 <span class="preprocessor">#define PSR_KERNEL_SET  (MASK_IA64(PSR_IC,1i64) | MASK_IA64(PSR_DT,1i64) | MASK_IA64(PSR_DFH,1i64) | </span><span class="comment">/* Intel-IA64-Filler */</span> \
00458                          MASK_IA64(PSR_DI,1i64) | MASK_IA64(PSR_IT,1i64) | <span class="comment">/* Intel-IA64-Filler */</span> \
00459                          MASK_IA64(PSR_RT,1i64)) // Intel-IA64-Filler
00460 
00461 <span class="preprocessor">#define PSR_KERNEL_CPY  (MASK_IA64(PSR_UP,1i64) | MASK_IA64(PSR_AC,1i64) | </span><span class="comment">/* Intel-IA64-Filler */</span> \
00462                          MASK_IA64(PSR_I,1i64) | MASK_IA64(PSR_BN,1i64)  | <span class="comment">/* Intel-IA64-Filler */</span> \
00463                          MASK_IA64(PSR_PP,1i64) | MASK_IA64(PSR_SI,1i64) | MASK_IA64(PSR_DB,1i64) | <span class="comment">/* Intel-IA64-Filler */</span> \
00464                          MASK_IA64(PSR_TB,1i64) | MASK_IA64(PSR_IS,1i64) | MASK_IA64(PSR_ID,1i64) | <span class="comment">/* Intel-IA64-Filler */</span> \
00465                          MASK_IA64(PSR_DA,1i64) | MASK_IA64(PSR_DD,1i64) | MASK_IA64(PSR_SS,1i64) | <span class="comment">/* Intel-IA64-Filler */</span> \
00466                          MASK_IA64(PSR_RI,0x3i64) | MASK_IA64(PSR_ED,1i64) | MASK_IA64(PSR_LP,1i64)) // Intel-IA64-Filler
00467 
00468 <span class="preprocessor">#define PSR_USER_CLR    (MASK_IA64(PSR_MC,1i64) | </span><span class="comment">/* Intel-IA64-Filler */</span> \
00469                          MASK_IA64(PSR_MBZ0,PSR_MBZ0_V) | MASK_IA64(PSR_PK,1i64) | <span class="comment">/* Intel-IA64-Filler */</span> \
00470                          MASK_IA64(PSR_MBZ1,PSR_MBZ1_V) | MASK_IA64(PSR_MBZ2,PSR_MBZ2) | <span class="comment">/* Intel-IA64-Filler */</span> \
00471                          MASK_IA64(PSR_LP,1i64)) // Intel-IA64-Filler
00472 
00473 <span class="preprocessor">#define PSR_USER_SET    (MASK_IA64(PSR_IC,1i64) | MASK_IA64(PSR_I,1i64)  | </span><span class="comment">/* Intel-IA64-Filler */</span> \
00474                          MASK_IA64(PSR_DT,1i64) | MASK_IA64(PSR_BN,1i64) | <span class="comment">/* Intel-IA64-Filler */</span> \
00475                          MASK_IA64(PSR_RT,1i64) | <span class="comment">/* Intel-IA64-Filler */</span> \
00476                          MASK_IA64(PSR_CPL,0x3i64) | MASK_IA64(PSR_IT,1i64)) // Intel-IA64-Filler
00477 
00478 <span class="preprocessor">#define PSR_USER_CPY    (MASK_IA64(PSR_BE,1i64) | MASK_IA64(PSR_UP,1i64) | MASK_IA64(PSR_PP,1i64) |</span><span class="comment">/* Intel-IA64-Filler */</span> \
00479                          MASK_IA64(PSR_AC,1i64) | MASK_IA64(PSR_DFL,1i64) | MASK_IA64(PSR_DFH,1i64) | <span class="comment">/* Intel-IA64-Filler */</span> \
00480                          MASK_IA64(PSR_SP,1i64) | MASK_IA64(PSR_DI,1i64) | MASK_IA64(PSR_DB,1i64) | <span class="comment">/* Intel-IA64-Filler */</span> \
00481                          MASK_IA64(PSR_TB,1i64) | MASK_IA64(PSR_IS,1i64) | MASK_IA64(PSR_ID,1i64) | <span class="comment">/* Intel-IA64-Filler */</span> \
00482                          MASK_IA64(PSR_DA,1i64) | MASK_IA64(PSR_DD,1i64) | MASK_IA64(PSR_SS, 1i64) | <span class="comment">/* Intel-IA64-Filler */</span> \
00483                          MASK_IA64(PSR_RI,0x3i64) | MASK_IA64(PSR_ED,1i64) | MASK_IA64(PSR_SI,1i64)) <span class="comment">/* Intel-IA64-Filler */</span>
00484 
00485 <span class="preprocessor">#define PSR_DEBUG_SET   (MASK_IA64(PSR_DB,1i64) | MASK_IA64(PSR_SS,1i64) | MASK_IA64(PSR_TB,1i64) | </span><span class="comment">/* Intel-IA64-Filler */</span> \
00486                          MASK_IA64(PSR_ID,1i64) | MASK_IA64(PSR_DD,1i64)) // Intel-IA64-Filler
00487 
00488 <span class="preprocessor">#define SANITIZE_PSR(psr, mode) ( </span><span class="comment">/* Intel-IA64-Filler */</span> \
00489     ((mode) == KernelMode ? <span class="comment">/* Intel-IA64-Filler */</span> \
00490         (PSR_KERNEL_SET | ((psr) &amp; (PSR_KERNEL_CPY | ~PSR_KERNEL_CLR))) : <span class="comment">/* Intel-IA64-Filler */</span> \
00491         (PSR_USER_SET | ((psr) &amp; (PSR_USER_CPY | ~PSR_USER_CLR))) <span class="comment">/* Intel-IA64-Filler */</span> \
00492     ) <span class="comment">/* Intel-IA64-Filler */</span> \
00493                                 ) // Intel-IA64-Filler
00494 
00495 <span class="comment">//</span>
00496 <span class="comment">// Define SANITIZE_IFS for IA64</span>
00497 <span class="comment">//</span>
00498 
00499 <span class="preprocessor">#define SANITIZE_IFS(ifs, mode) ( </span><span class="comment">/* Intel-IA64-Filler */</span> \
00500     ((mode) == KernelMode ? <span class="comment">/* Intel-IA64-Filler */</span> \
00501         ((ifs) | (MASK_IA64(IFS_V,1i64))) : <span class="comment">/* Intel-IA64-Filler */</span> \
00502         (((ifs) | (MASK_IA64(IFS_V,1i64))) &amp; (~MASK_IA64(IFS_MBZ0, (ULONGLONG)IFS_MBZ0_V))) <span class="comment">/* Intel-IA64-Filler */</span> \
00503     ) <span class="comment">/* Intel-IA64-Filler */</span> \
00504                                 ) // Intel-IA64-Filler
00505 
00506 <span class="preprocessor">#define SANITIZE_DCR(dcr, mode) </span><span class="comment">/* Intel-IA64-Filler */</span> \
00507     ((mode) == KernelMode ? dcr : USER_DCR_INITIAL) // Intel-IA64-Filler
00508 
00509 <span class="comment">//</span>
00510 <span class="comment">// Macro to sanitize debug registers</span>
00511 <span class="comment">//</span>
00512 
00513 <span class="preprocessor">#define SANITIZE_DR(dr, mode) </span><span class="comment">/* Intel-IA64-Filler */</span> \
00514     ((mode) == KernelMode ? <span class="comment">/* Intel-IA64-Filler */</span> \
00515         (dr) : <span class="comment">/* Intel-IA64-Filler */</span> \
00516         (dr &amp; ~(0x7i64 &lt;&lt; DR_PLM0)) <span class="comment">/* disable pl 0-2 */</span> <span class="comment">/* Intel-IA64-Filler */</span> \
00517     ) <span class="comment">/* Intel-IA64-Filler */</span>
00518 <span class="comment">// @@END_DDKSPLIT</span>
00519 
00520 
00521 <span class="comment">// begin_nthal</span>
00522 
00523 <span class="comment">// Please contact INTEL to get IA64-specific information</span>
00524 <span class="comment">// @@BEGIN_DDKSPLIT</span>
00525 <span class="comment">//</span>
00526 <span class="comment">// Define interrupt request physical address (maps to HAL virtual address)</span>
00527 <span class="comment">//</span>
00528 
00529 <span class="preprocessor">#define INTERRUPT_REQUEST_PHYSICAL_ADDRESS  0xFFE00000 // Intel-IA64-Filler</span>
00530 <span class="preprocessor"></span>
00531 <span class="comment">//</span>
00532 <span class="comment">// Define Address of Processor Control Registers. // Intel-IA64-Filler</span>
00533 <span class="comment">//</span>
00534 
00535 <span class="comment">// @@END_DDKSPLIT</span>
00536 
00537 <span class="comment">//</span>
00538 <span class="comment">// Define Pointer to Processor Control Registers.</span>
00539 <span class="comment">//</span>
00540 
00541 <span class="preprocessor">#define KIPCR ((ULONG_PTR)(KADDRESS_BASE + 0xFFFF0000))            // kernel address of first PCR</span>
00542 <span class="preprocessor"></span><span class="preprocessor">#define PCR ((volatile KPCR * const)KIPCR)</span>
00543 <span class="preprocessor"></span>
00544 
00545 <span class="comment">// begin_ntddk begin_wdm</span>
00546 
00547 <span class="preprocessor">#define KI_USER_SHARED_DATA ((ULONG_PTR)(KADDRESS_BASE + 0xFFFE0000))</span>
00548 <span class="preprocessor"></span><span class="preprocessor">#define SharedUserData ((KUSER_SHARED_DATA * const)KI_USER_SHARED_DATA)</span>
00549 <span class="preprocessor"></span>
00550 <span class="comment">//</span>
00551 <span class="comment">// Prototype for get current IRQL. **** TBD (read TPR)</span>
00552 <span class="comment">//</span>
00553 
00554 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00555 KIRQL
00556 KeGetCurrentIrql();
00557 
00558 <span class="comment">// end_wdm</span>
00559 
00560 <span class="comment">//</span>
00561 <span class="comment">// Get address of current processor block.</span>
00562 <span class="comment">//</span>
00563 
00564 <span class="preprocessor">#define KeGetCurrentPrcb() PCR-&gt;Prcb</span>
00565 <span class="preprocessor"></span>
00566 <span class="comment">//</span>
00567 <span class="comment">// Get address of processor control region.</span>
00568 <span class="comment">//</span>
00569 
00570 <span class="preprocessor">#define KeGetPcr() PCR</span>
00571 <span class="preprocessor"></span>
00572 <span class="comment">//</span>
00573 <span class="comment">// Get address of current kernel thread object.</span>
00574 <span class="comment">//</span>
00575 
00576 <span class="preprocessor">#define KeGetCurrentThread() PCR-&gt;CurrentThread</span>
00577 <span class="preprocessor"></span>
00578 <span class="comment">//</span>
00579 <span class="comment">// Get current processor number.</span>
00580 <span class="comment">//</span>
00581 
00582 <span class="preprocessor">#define KeGetCurrentProcessorNumber() PCR-&gt;Number</span>
00583 <span class="preprocessor"></span>
00584 <span class="comment">//</span>
00585 <span class="comment">// Get data cache fill size.</span>
00586 <span class="comment">//</span>
00587 
00588 <span class="preprocessor">#define KeGetDcacheFillSize() PCR-&gt;DcacheFillSize</span>
00589 <span class="preprocessor"></span>
00590 <span class="comment">// end_ntddk end_nthal</span>
00591 
00592 <span class="comment">//</span>
00593 <span class="comment">// Get previous processor mode.</span>
00594 <span class="comment">//</span>
00595 
00596 <span class="preprocessor">#define KeGetPreviousMode() (KPROCESSOR_MODE)PCR-&gt;CurrentThread-&gt;PreviousMode</span>
00597 <span class="preprocessor"></span>
00598 <span class="comment">//</span>
00599 <span class="comment">// Test if executing a DPC.</span>
00600 <span class="comment">//</span>
00601 
00602 <span class="preprocessor">#define KeIsExecutingDpc() (PCR-&gt;Prcb-&gt;DpcRoutineActive != 0)</span>
00603 <span class="preprocessor"></span>
00604 <span class="comment">//</span>
00605 <span class="comment">// Save &amp; Restore floating point state</span>
00606 <span class="comment">//</span>
00607 <span class="comment">// begin_ntddk begin_wdm</span>
00608 
00609 <span class="preprocessor">#define KeSaveFloatingPointState(a)         STATUS_SUCCESS</span>
00610 <span class="preprocessor"></span><span class="preprocessor">#define KeRestoreFloatingPointState(a)      STATUS_SUCCESS</span>
00611 <span class="preprocessor"></span>
00612 <span class="comment">// end_ntddk end_wdm</span>
00613 
00614 
00615 <span class="comment">// begin_ntddk begin_nthal begin_ntndis begin_wdm</span>
00616 
00617 <span class="comment">//</span>
00618 <span class="comment">// Define the page size</span>
00619 <span class="comment">//</span>
00620 
00621 <span class="preprocessor">#define PAGE_SIZE 0x2000</span>
00622 <span class="preprocessor"></span>
00623 <span class="comment">//</span>
00624 <span class="comment">// Define the number of trailing zeroes in a page aligned virtual address.</span>
00625 <span class="comment">// This is used as the shift count when shifting virtual addresses to</span>
00626 <span class="comment">// virtual page numbers.</span>
00627 <span class="comment">//</span>
00628 
00629 <span class="preprocessor">#define PAGE_SHIFT 13L</span>
00630 <span class="preprocessor"></span>
00631 <span class="comment">// end_ntddk end_nthal end_ntndis end_wdm</span>
00632 
00633 <span class="comment">// begin_nthal</span>
00634 <span class="comment">//</span>
00635 <span class="comment">// IA64 hardware structures</span>
00636 <span class="comment">//</span>
00637 
00638 <span class="comment">// Please contact INTEL to get IA64-specific information</span>
00639 <span class="comment">// @@BEGIN_DDKSPLIT</span>
00640 
00641 <span class="comment">//</span>
00642 <span class="comment">// A Page Table Entry on an IA64 has the following definition.</span>
00643 <span class="comment">//</span>
00644 
00645 <span class="preprocessor">#define _HARDWARE_PTE_WORKING_SET_BITS  11 // Intel-IA64-Filler</span>
00646 <span class="preprocessor"></span>
00647 <span class="keyword">typedef</span> <span class="keyword">struct </span>_HARDWARE_PTE {            <span class="comment">// Intel-IA64-Filler</span>
00648     ULONG64 Valid : 1;                    <span class="comment">// Intel-IA64-Filler</span>
00649     ULONG64 Rsvd0 : 1;                    <span class="comment">// Intel-IA64-Filler</span>
00650     ULONG64 Cache : 3;                    <span class="comment">// Intel-IA64-Filler</span>
00651     ULONG64 Accessed : 1;                 <span class="comment">// Intel-IA64-Filler</span>
00652     ULONG64 Dirty : 1;                    <span class="comment">// Intel-IA64-Filler</span>
00653     ULONG64 <a class="code" href="../../d6/d0/ctaccess_8c.html#a53">Owner</a> : 2;                    <span class="comment">// Intel-IA64-Filler</span>
00654     ULONG64 Execute : 1;                  <span class="comment">// Intel-IA64-Filler</span>
00655     ULONG64 Write : 1;                    <span class="comment">// Intel-IA64-Filler</span>
00656     ULONG64 Rsvd1 : <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a> - 12;      <span class="comment">// Intel-IA64-Filler</span>
00657     ULONG64 CopyOnWrite : 1;              <span class="comment">// Intel-IA64-Filler</span>
00658     ULONG64 PageFrameNumber : 50 - <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>;  <span class="comment">// Intel-IA64-Filler</span>
00659     ULONG64 Rsvd2 : 2;                    <span class="comment">// Intel-IA64-Filler</span>
00660     ULONG64 Exception : 1;                <span class="comment">// Intel-IA64-Filler</span>
00661     ULONGLONG SoftwareWsIndex : <a class="code" href="../../d2/d9/miia64_8h.html#a200">_HARDWARE_PTE_WORKING_SET_BITS</a>; <span class="comment">// Intel-IA64-Filler</span>
00662 } HARDWARE_PTE, *PHARDWARE_PTE;           <span class="comment">// Intel-IA64-Filler</span>
00663 
00664 <span class="comment">//</span>
00665 <span class="comment">// Fill TB entry // Intel-IA64-Filler</span>
00666 <span class="comment">//</span>
00667 <span class="comment">// Filling TB entry on demand by VHPT H/W seems faster than done by s/w. // Intel-IA64-Filler</span>
00668 <span class="comment">// Determining I/D side of TLB, disabling/enabling PSR.i and ic bits, // Intel-IA64-Filler</span>
00669 <span class="comment">// serialization, writing to IIP, IDA, IDTR and IITR seem just too much // Intel-IA64-Filler</span>
00670 <span class="comment">// compared to VHPT searching it automatically. // Intel-IA64-Filler</span>
00671 <span class="comment">//</span>
00672 
00673 <span class="preprocessor">#define KiVhptEntry(va)  ((PVOID)__thash((__int64)va)) // Intel-IA64-Filler</span>
00674 <span class="preprocessor"></span><span class="preprocessor">#define KiVhptEntryTag(va)  ((ULONGLONG)__ttag((__int64)va)) // Intel-IA64-Filler</span>
00675 <span class="preprocessor"></span>
00676 <span class="preprocessor">#define KiFlushSingleTb(Invalid, va)   </span><span class="comment">/* Intel-IA64-Filler */</span>                \
00677     __ptcl((__int64)va,PAGE_SHIFT &lt;&lt; 2);  __isrlz() // Intel-IA64-Filler
00678 
00679 <span class="preprocessor">#define KeFillEntryTb(PointerPte, Virtual, Invalid) </span><span class="comment">/* Intel-IA64-Filler */</span>   \
00680     if (Invalid != FALSE) { <span class="comment">/* Intel-IA64-Filler */</span>\
00681        KiFlushSingleTb(0, Virtual);     <span class="comment">/* Intel-IA64-Filler */</span>               \
00682     } // Intel-IA64-Filler
00683 
00684 <span class="preprocessor">#define KiFlushFixedInstTb(Invalid, va)  </span><span class="comment">/* Intel-IA64-Filler */</span> \
00685     __ptri((__int64)va, PAGE_SHIFT &lt;&lt; 2); __isrlz() // Intel-IA64-Filler
00686 
00687 <span class="preprocessor">#define KiFlushFixedDataTb(Invalid, va)  </span><span class="comment">/* Intel-IA64-Filler */</span> \
00688     __ptrd((__int64)va, PAGE_SHIFT &lt;&lt; 2); __dsrlz() // Intel-IA64-Filler
00689 
00690 <span class="comment">// @@END_DDKSPLIT</span>
00691 
00692 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00693 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00694 KeFillLargeEntryTb (
00695     IN HARDWARE_PTE Pte[2],
00696     IN PVOID Virtual,
00697     IN ULONG PageSize
00698     );
00699 
00700 <span class="comment">//</span>
00701 <span class="comment">// Fill TB fixed entry</span>
00702 <span class="comment">//</span>
00703 
00704 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00705 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00706 KeFillFixedEntryTb (
00707     IN HARDWARE_PTE Pte[2],
00708     IN PVOID Virtual,
00709     IN ULONG Index
00710     );
00711 
00712 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00713 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00714 KeFillFixedLargeEntryTb (
00715     IN HARDWARE_PTE Pte[2],
00716     IN PVOID Virtual,
00717     IN ULONG PageSize,
00718     IN ULONG Index
00719     );
00720 
00721 <span class="comment">//</span>
00722 <span class="comment">// Fill Inst TB entry</span>
00723 <span class="comment">//</span>
00724 
00725 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00726 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00727 KeFillInstEntryTb (
00728     IN HARDWARE_PTE Pte,
00729     IN PVOID Virtual
00730     );
00731 
00732 <span class="comment">//</span>
00733 <span class="comment">// Get a VHPT entry address</span>
00734 <span class="comment">//</span>
00735 
00736 PVOID
00737 KiVhptEntry64(
00738    IN ULONG VirtualPageNumber
00739    );
00740 
00741 <span class="comment">//</span>
00742 <span class="comment">// Get a VHPT entry TAG value</span>
00743 <span class="comment">//</span>
00744 
00745 ULONGLONG
00746 KiVhptEntryTag64(
00747     IN ULONG VirtualPageNumber
00748     );
00749 
00750 <span class="comment">//</span>
00751 <span class="comment">// Fill a VHPT entry</span>
00752 <span class="comment">//</span>
00753 
00754 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00755 KiFillEntryVhpt(
00756    IN PHARDWARE_PTE PointerPte,
00757    IN PVOID Virtual
00758    );
00759 
00760 
00761 <span class="comment">//</span>
00762 <span class="comment">// Flush the kernel portions of Tb</span>
00763 <span class="comment">//</span>
00764 
00765 
00766 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00767 KeFlushKernelTb(
00768     IN BOOLEAN AllProcessors
00769     );
00770 
00771 <span class="comment">//</span>
00772 <span class="comment">// Flush the user portions of Tb</span>
00773 <span class="comment">//</span>
00774 
00775 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00776 KeFlushUserTb(
00777     IN BOOLEAN AllProcessors
00778     );
00779 
00780 
00781 
00782 <span class="comment">//</span>
00783 <span class="comment">// Data cache, instruction cache, I/O buffer, and write buffer flush routine</span>
00784 <span class="comment">// prototypes.</span>
00785 <span class="comment">//</span>
00786 
00787 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00788 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00789 <a class="code" href="../../d3/d5/ppc_2flush_8c.html#a5">KeChangeColorPage</a> (
00790     IN PVOID NewColor,
00791     IN PVOID OldColor,
00792     IN ULONG PageFrame
00793     );
00794 
00795 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00796 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00797 <a class="code" href="../../d3/d5/ppc_2flush_8c.html#a6">KeSweepDcache</a> (
00798     IN BOOLEAN AllProcessors
00799     );
00800 
00801 <span class="preprocessor">#define KeSweepCurrentDcache()</span>
00802 <span class="preprocessor"></span>
00803 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00804 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00805 <a class="code" href="../../d3/d5/ppc_2flush_8c.html#a7">KeSweepIcache</a> (
00806     IN BOOLEAN AllProcessors
00807     );
00808 
00809 <span class="preprocessor">#define KeSweepCurrentIcache()</span>
00810 <span class="preprocessor"></span>
00811 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00812 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00813 <a class="code" href="../../d3/d5/ppc_2flush_8c.html#a8">KeSweepIcacheRange</a> (
00814     IN BOOLEAN AllProcessors,
00815     IN PVOID BaseAddress,
00816     IN ULONG Length
00817     );
00818 
00819 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00820 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00821 <a class="code" href="../../d1/d5/ia64_2flush_8c.html#a16">KeSweepCacheRangeWithDrain</a> (
00822     IN BOOLEAN AllProcessors,
00823     IN PVOID BaseAddress,
00824     IN ULONG Length
00825     );
00826 
00827 <span class="comment">// begin_ntddk begin_ntndis begin_wdm</span>
00828 <span class="comment">//</span>
00829 <span class="comment">// Cache and write buffer flush functions.</span>
00830 <span class="comment">//</span>
00831 
00832 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00833 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00834 <a class="code" href="../../d3/d5/ppc_2flush_8c.html#a9">KeFlushIoBuffers</a> (
00835     IN <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> Mdl,
00836     IN BOOLEAN ReadOperation,
00837     IN BOOLEAN DmaOperation
00838     );
00839 
00840 <span class="comment">// end_ntddk end_ntndis end_wdm</span>
00841 
00842 <span class="comment">//</span>
00843 <span class="comment">// Clock, profile, and interprocessor interrupt functions.</span>
00844 <span class="comment">//</span>
00845 
00846 <span class="keyword">struct </span>_KEXCEPTION_FRAME;
00847 <span class="keyword">struct </span>_KTRAP_FRAME;
00848 
00849 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00850 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00851 KeIpiInterrupt (
00852     IN <span class="keyword">struct</span> _KTRAP_FRAME *TrapFrame
00853     );
00854 
00855 <span class="preprocessor">#define KeYieldProcessor()</span>
00856 <span class="preprocessor"></span>
00857 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00858 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00859 <a class="code" href="../../d1/d9/clock_8c.html#a5">KeProfileInterrupt</a> (
00860     IN <span class="keyword">struct</span> _KTRAP_FRAME *TrapFrame
00861     );
00862 
00863 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00864 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00865 <a class="code" href="../../d1/d9/clock_8c.html#a6">KeProfileInterruptWithSource</a> (
00866     IN <span class="keyword">struct</span> _KTRAP_FRAME *TrapFrame,
00867     IN KPROFILE_SOURCE ProfileSource
00868     );
00869 
00870 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00871 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00872 <a class="code" href="../../d1/d9/clock_8c.html#a3">KeUpdateRunTime</a> (
00873     IN <span class="keyword">struct</span> _KTRAP_FRAME *TrapFrame
00874     );
00875 
00876 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00877 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00878 <a class="code" href="../../d1/d9/clock_8c.html#a2">KeUpdateSystemTime</a> (
00879     IN <span class="keyword">struct</span> _KTRAP_FRAME *TrapFrame,
00880     IN ULONG Increment
00881     );
00882 
00883 <span class="comment">//</span>
00884 <span class="comment">// The following function prototypes are exported for use in MP HALs.</span>
00885 <span class="comment">//</span>
00886 
00887 <span class="preprocessor">#if defined(NT_UP)</span>
00888 <span class="preprocessor"></span>
00889 <span class="preprocessor">#define KiAcquireSpinLock(SpinLock)</span>
00890 <span class="preprocessor"></span>
00891 <span class="preprocessor">#else</span>
00892 <span class="preprocessor"></span>
00893 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00894 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00895 KiAcquireSpinLock (
00896     IN PKSPIN_LOCK SpinLock
00897     );
00898 
00899 <span class="preprocessor">#endif</span>
00900 <span class="preprocessor"></span>
00901 <span class="preprocessor">#if defined(NT_UP)</span>
00902 <span class="preprocessor"></span>
00903 <span class="preprocessor">#define KiReleaseSpinLock(SpinLock)</span>
00904 <span class="preprocessor"></span>
00905 <span class="preprocessor">#else</span>
00906 <span class="preprocessor"></span>
00907 <span class="preprocessor">#define KiReleaseSpinLock(SpinLock) _ReleaseSpinLock(SpinLock)</span>
00908 <span class="preprocessor"></span>
00909 <span class="preprocessor">#endif</span>
00910 <span class="preprocessor"></span>
00911 <span class="comment">//</span>
00912 <span class="comment">// KeTestSpinLock may be used to spin at low IRQL until the lock is</span>
00913 <span class="comment">// available.  The IRQL must then be raised and the lock acquired with</span>
00914 <span class="comment">// KeTryToAcquireSpinLock.  If that fails, lower the IRQL and start again.</span>
00915 <span class="comment">//</span>
00916 
00917 <span class="preprocessor">#if defined(NT_UP)</span>
00918 <span class="preprocessor"></span>
00919 <span class="preprocessor">#define KeTestSpinLock(SpinLock) (TRUE)</span>
00920 <span class="preprocessor"></span>
00921 <span class="preprocessor">#else</span>
00922 <span class="preprocessor"></span>
00923 BOOLEAN
00924 KeTestSpinLock (
00925     IN PKSPIN_LOCK SpinLock
00926     );
00927 
00928 <span class="preprocessor">#endif</span>
00929 <span class="preprocessor"></span>
00930 <span class="comment">//</span>
00931 <span class="comment">// Define cache error routine type and prototype.</span>
00932 <span class="comment">//</span>
00933 
00934 <span class="keyword">typedef</span>
00935 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00936 (*PKCACHE_ERROR_ROUTINE) (
00937     <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00938     );
00939 
00940 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00941 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00942 <a class="code" href="../../d1/d2/mips_2buserror_8c.html#a4">KeSetCacheErrorRoutine</a> (
00943     IN PKCACHE_ERROR_ROUTINE Routine
00944     );
00945 
00946 <span class="comment">// begin_ntddk begin_wdm</span>
00947 
00948 <span class="comment">//</span>
00949 <span class="comment">// Kernel breakin breakpoint</span>
00950 <span class="comment">//</span>
00951 
00952 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00953 KeBreakinBreakpoint (
00954     VOID
00955     );
00956 
00957 <span class="comment">// end_ntddk end_nthal end_wdm</span>
00958 
00959 <span class="comment">//</span>
00960 <span class="comment">// Define executive macros for acquiring and releasing executive spinlocks.</span>
00961 <span class="comment">// These macros can ONLY be used by executive components and NOT by drivers.</span>
00962 <span class="comment">// Drivers MUST use the kernel interfaces since they must be MP enabled on</span>
00963 <span class="comment">// all systems.</span>
00964 <span class="comment">//</span>
00965 
00966 <span class="preprocessor">#if defined(NT_UP) &amp;&amp; !defined(_NTDDK_) &amp;&amp; !defined(_NTIFS_)</span>
00967 <span class="preprocessor"></span><span class="preprocessor">#define ExAcquireSpinLock(Lock, OldIrql) KeRaiseIrql(DISPATCH_LEVEL, (OldIrql))</span>
00968 <span class="preprocessor"></span><span class="preprocessor">#define ExReleaseSpinLock(Lock, OldIrql) KeLowerIrql((OldIrql))</span>
00969 <span class="preprocessor"></span><span class="preprocessor">#define ExAcquireSpinLockAtDpcLevel(Lock)</span>
00970 <span class="preprocessor"></span><span class="preprocessor">#define ExReleaseSpinLockFromDpcLevel(Lock)</span>
00971 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00972 <span class="preprocessor"></span>
00973 <span class="comment">// begin_wdm begin_ntddk</span>
00974 
00975 <span class="preprocessor">#define ExAcquireSpinLock(Lock, OldIrql) KeAcquireSpinLock((Lock), (OldIrql))</span>
00976 <span class="preprocessor"></span><span class="preprocessor">#define ExReleaseSpinLock(Lock, OldIrql) KeReleaseSpinLock((Lock), (OldIrql))</span>
00977 <span class="preprocessor"></span><span class="preprocessor">#define ExAcquireSpinLockAtDpcLevel(Lock) KeAcquireSpinLockAtDpcLevel(Lock)</span>
00978 <span class="preprocessor"></span><span class="preprocessor">#define ExReleaseSpinLockFromDpcLevel(Lock) KeReleaseSpinLockFromDpcLevel(Lock)</span>
00979 <span class="preprocessor"></span>
00980 <span class="comment">// end_wdm end_ntddk</span>
00981 
00982 <span class="preprocessor">#endif</span>
00983 <span class="preprocessor"></span>
00984 <span class="comment">//</span>
00985 <span class="comment">// The acquire and release fast lock macros disable and enable interrupts</span>
00986 <span class="comment">// on UP nondebug systems. On MP or debug systems, the spinlock routines</span>
00987 <span class="comment">// are used.</span>
00988 <span class="comment">//</span>
00989 <span class="comment">// N.B. Extreme caution should be observed when using these routines.</span>
00990 <span class="comment">//</span>
00991 
00992 <span class="preprocessor">#if defined(_M_IA64)</span>
00993 <span class="preprocessor"></span>
00994 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00995 _disable (
00996     VOID
00997     );
00998 
00999 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01000 _enable (
01001     VOID
01002     );
01003 
01004 <span class="preprocessor">#pragma intrinsic(_disable)</span>
01005 <span class="preprocessor"></span><span class="preprocessor">#pragma intrinsic(_enable)</span>
01006 <span class="preprocessor"></span>
01007 <span class="preprocessor">#endif</span>
01008 <span class="preprocessor"></span>
01009 <span class="preprocessor">#if defined(NT_UP) &amp;&amp; !DBG</span>
01010 <span class="preprocessor"></span><span class="preprocessor">#define ExAcquireFastLock(Lock, OldIrql) _disable()</span>
01011 <span class="preprocessor"></span><span class="preprocessor">#else</span>
01012 <span class="preprocessor"></span><span class="preprocessor">#define ExAcquireFastLock(Lock, OldIrql) \</span>
01013 <span class="preprocessor">    ExAcquireSpinLock(Lock, OldIrql)</span>
01014 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
01015 <span class="preprocessor"></span>
01016 <span class="preprocessor">#if defined(NT_UP) &amp;&amp; !DBG</span>
01017 <span class="preprocessor"></span><span class="preprocessor">#define ExReleaseFastLock(Lock, OldIrql) _enable()</span>
01018 <span class="preprocessor"></span><span class="preprocessor">#else</span>
01019 <span class="preprocessor"></span><span class="preprocessor">#define ExReleaseFastLock(Lock, OldIrql) \</span>
01020 <span class="preprocessor">    ExReleaseSpinLock(Lock, OldIrql)</span>
01021 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
01022 <span class="preprocessor"></span>
01023 <span class="comment">//</span>
01024 <span class="comment">// Data and instruction bus error function prototypes.</span>
01025 <span class="comment">//</span>
01026 
01027 BOOLEAN
01028 <a class="code" href="../../d1/d2/mips_2buserror_8c.html#a0">KeBusError</a> (
01029     IN PEXCEPTION_RECORD ExceptionRecord,
01030     IN <span class="keyword">struct</span> _KEXCEPTION_FRAME *ExceptionFrame,
01031     IN <span class="keyword">struct</span> _KTRAP_FRAME *TrapFrame,
01032     IN PVOID VirtualAddress,
01033     IN PHYSICAL_ADDRESS PhysicalAddress
01034     );
01035 
01036 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01037 <a class="code" href="../../d1/d2/mips_2buserror_8c.html#a2">KiDataBusError</a> (
01038     IN PEXCEPTION_RECORD ExceptionRecord,
01039     IN <span class="keyword">struct</span> _KEXCEPTION_FRAME *ExceptionFrame,
01040     IN <span class="keyword">struct</span> _KTRAP_FRAME *TrapFrame
01041     );
01042 
01043 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01044 <a class="code" href="../../d1/d2/mips_2buserror_8c.html#a3">KiInstructionBusError</a> (
01045     IN PEXCEPTION_RECORD ExceptionRecord,
01046     IN <span class="keyword">struct</span> _KEXCEPTION_FRAME *ExceptionFrame,
01047     IN <span class="keyword">struct</span> _KTRAP_FRAME *TrapFrame
01048     );
01049 
01050 <span class="comment">//</span>
01051 <span class="comment">// Define query system time macro.</span>
01052 <span class="comment">//</span>
01053 
01054 <span class="preprocessor">#define KiQuerySystemTime(CurrentTime)     \</span>
01055 <span class="preprocessor">    while (TRUE) {                                                             \</span>
01056 <span class="preprocessor">        (CurrentTime)-&gt;HighPart = SharedUserData-&gt;SystemHigh1Time;             \</span>
01057 <span class="preprocessor">        (CurrentTime)-&gt;LowPart = SharedUserData-&gt;SystemLowTime;                \</span>
01058 <span class="preprocessor">        if ((CurrentTime)-&gt;HighPart == SharedUserData-&gt;SystemHigh2Time) break; \</span>
01059 <span class="preprocessor">    }</span>
01060 <span class="preprocessor"></span>
01061 <span class="comment">//</span>
01062 <span class="comment">// Define query tick count macro.</span>
01063 <span class="comment">//</span>
01064 <span class="comment">// begin_ntddk begin_nthal</span>
01065 
01066 <span class="preprocessor">#if defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_)</span>
01067 <span class="preprocessor"></span>
01068 <span class="comment">// begin_wdm</span>
01069 
01070 <span class="preprocessor">#define KeQueryTickCount(CurrentCount ) \</span>
01071 <span class="preprocessor">    *(PULONGLONG)(CurrentCount) = **((volatile ULONGLONG **)(&amp;KeTickCount));</span>
01072 <span class="preprocessor"></span>
01073 <span class="comment">// end_wdm</span>
01074 
01075 <span class="preprocessor">#else</span>
01076 <span class="preprocessor"></span>
01077 <span class="preprocessor">#define KiQueryTickCount(CurrentCount) \</span>
01078 <span class="preprocessor">    *(PULONGLONG)(CurrentCount) = KeTickCount;</span>
01079 <span class="preprocessor"></span>
01080 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01081 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01082 <a class="code" href="../../d7/d0/ke_2miscc_8c.html#a4">KeQueryTickCount</a> (
01083     OUT PLARGE_INTEGER CurrentCount
01084     );
01085 
01086 <span class="preprocessor">#endif // defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_)</span>
01087 <span class="preprocessor"></span>
01088 <span class="comment">// end_ntddk end_nthal</span>
01089 
01090 <span class="preprocessor">#define KiQueryLowTickCount() (ULONG)KeTickCount</span>
01091 <span class="preprocessor"></span>
01092 <span class="comment">//</span>
01093 <span class="comment">// Define query interrupt time macro.</span>
01094 <span class="comment">//</span>
01095 
01096 <span class="preprocessor">#define KiQueryInterruptTime(CurrentTime) \</span>
01097 <span class="preprocessor">    *(PULONGLONG)(CurrentTime) = SharedUserData-&gt;InterruptTime</span>
01098 <span class="preprocessor"></span>
01099 <span class="comment">//</span>
01100 <span class="comment">// The following function prototypes must be in the module since they are</span>
01101 <span class="comment">// machine dependent.</span>
01102 <span class="comment">//</span>
01103 
01104 ULONG
01105 <a class="code" href="../../d7/d1/branchem_8c.html#a0">KiEmulateBranch</a> (
01106     IN <span class="keyword">struct</span> _KEXCEPTION_FRAME *ExceptionFrame,
01107     IN <span class="keyword">struct</span> _KTRAP_FRAME *TrapFrame
01108     );
01109 
01110 BOOLEAN
01111 <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a32">KiEmulateFloating</a> (
01112     IN OUT PEXCEPTION_RECORD ExceptionRecord,
01113     IN OUT <span class="keyword">struct</span> _KEXCEPTION_FRAME *ExceptionFrame,
01114     IN OUT <span class="keyword">struct</span> _KTRAP_FRAME *TrapFrame
01115     );
01116 
01117 BOOLEAN
01118 <a class="code" href="../../d7/d5/ppc_2alignem_8c.html#a18">KiEmulateReference</a> (
01119     IN OUT PEXCEPTION_RECORD ExceptionRecord,
01120     IN OUT <span class="keyword">struct</span> _KEXCEPTION_FRAME *ExceptionFrame,
01121     IN OUT <span class="keyword">struct</span> _KTRAP_FRAME *TrapFrame
01122     );
01123 
01124 ULONGLONG
01125 <a class="code" href="../../d8/d5/ppc_2getsetrg_8c.html#a0">KiGetRegisterValue</a> (
01126     IN ULONG Register,
01127     IN <span class="keyword">struct</span> _KEXCEPTION_FRAME *ExceptionFrame,
01128     IN <span class="keyword">struct</span> _KTRAP_FRAME *TrapFrame
01129     );
01130 
01131 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01132 <a class="code" href="../../d8/d5/ppc_2getsetrg_8c.html#a1">KiSetRegisterValue</a> (
01133     IN ULONG Register,
01134     IN ULONGLONG Value,
01135     OUT <span class="keyword">struct</span> _KEXCEPTION_FRAME *ExceptionFrame,
01136     OUT <span class="keyword">struct</span> _KTRAP_FRAME *TrapFrame
01137     );
01138 
01139 FLOAT128
01140 <a class="code" href="../../d8/d5/ppc_2getsetrg_8c.html#a2">KiGetFloatRegisterValue</a> (
01141     IN ULONG Register,
01142     IN <span class="keyword">struct</span> _KEXCEPTION_FRAME *ExceptionFrame,
01143     IN <span class="keyword">struct</span> _KTRAP_FRAME *TrapFrame
01144     );
01145 
01146 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01147 <a class="code" href="../../d8/d5/ppc_2getsetrg_8c.html#a3">KiSetFloatRegisterValue</a> (
01148     IN ULONG Register,
01149     IN FLOAT128 Value,
01150     OUT <span class="keyword">struct</span> _KEXCEPTION_FRAME *ExceptionFrame,
01151     OUT <span class="keyword">struct</span> _KTRAP_FRAME *TrapFrame
01152     );
01153 
01154 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01155 <a class="code" href="../../d4/d5/ia64_2trapc_8c.html#a13">KiAdvanceInstPointer</a>(
01156     IN OUT <span class="keyword">struct</span> _KTRAP_FRAME *TrapFrame
01157     );
01158 
01159 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01160 <a class="code" href="../../d9/d4/intsupc_8c.html#a3">KiRequestSoftwareInterrupt</a> (
01161     KIRQL RequestIrql
01162     );
01163 
01164 <span class="comment">// begin_ntddk begin_nthal begin_ntndis begin_wdm</span>
01165 <span class="comment">//</span>
01166 <span class="comment">// I/O space read and write macros.</span>
01167 <span class="comment">//</span>
01168 
01169 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
01170 UCHAR
01171 READ_PORT_UCHAR (
01172     PUCHAR RegisterAddress
01173     );
01174 
01175 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
01176 <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>
01177 READ_PORT_USHORT (
01178     PUSHORT RegisterAddress
01179     );
01180 
01181 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
01182 ULONG
01183 READ_PORT_ULONG (
01184     PULONG RegisterAddress
01185     );
01186 
01187 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
01188 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01189 READ_PORT_BUFFER_UCHAR (
01190     PUCHAR portAddress,
01191     PUCHAR readBuffer,
01192     ULONG  readCount
01193     );
01194 
01195 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
01196 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01197 READ_PORT_BUFFER_USHORT (
01198     PUSHORT portAddress,
01199     PUSHORT readBuffer,
01200     ULONG  readCount
01201     );
01202 
01203 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
01204 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01205 READ_PORT_BUFFER_ULONG (
01206     PULONG portAddress,
01207     PULONG readBuffer,
01208     ULONG  readCount
01209     );
01210 
01211 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
01212 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01213 WRITE_PORT_UCHAR (
01214     PUCHAR portAddress,
01215     UCHAR  Data
01216     );
01217 
01218 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
01219 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01220 WRITE_PORT_USHORT (
01221     PUSHORT portAddress,
01222     USHORT  Data
01223     );
01224 
01225 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
01226 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01227 WRITE_PORT_ULONG (
01228     PULONG portAddress,
01229     ULONG  Data
01230     );
01231 
01232 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
01233 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01234 WRITE_PORT_BUFFER_UCHAR (
01235     PUCHAR portAddress,
01236     PUCHAR writeBuffer,
01237     ULONG  writeCount
01238     );
01239 
01240 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
01241 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01242 WRITE_PORT_BUFFER_USHORT (
01243     PUSHORT portAddress,
01244     PUSHORT writeBuffer,
01245     ULONG  writeCount
01246     );
01247 
01248 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
01249 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01250 WRITE_PORT_BUFFER_ULONG (
01251     PULONG portAddress,
01252     PULONG writeBuffer,
01253     ULONG  writeCount
01254     );
01255 
01256 
01257 <span class="preprocessor">#define READ_REGISTER_UCHAR(x) \</span>
01258 <span class="preprocessor">    (__mf(), *(volatile UCHAR * const)(x))</span>
01259 <span class="preprocessor"></span>
01260 <span class="preprocessor">#define READ_REGISTER_USHORT(x) \</span>
01261 <span class="preprocessor">    (__mf(), *(volatile USHORT * const)(x))</span>
01262 <span class="preprocessor"></span>
01263 <span class="preprocessor">#define READ_REGISTER_ULONG(x) \</span>
01264 <span class="preprocessor">    (__mf(), *(volatile ULONG * const)(x))</span>
01265 <span class="preprocessor"></span>
01266 <span class="preprocessor">#define READ_REGISTER_BUFFER_UCHAR(x, y, z) {                           \</span>
01267 <span class="preprocessor">    PUCHAR registerBuffer = x;                                          \</span>
01268 <span class="preprocessor">    PUCHAR readBuffer = y;                                              \</span>
01269 <span class="preprocessor">    ULONG readCount;                                                    \</span>
01270 <span class="preprocessor">    __mf();                                                             \</span>
01271 <span class="preprocessor">    for (readCount = z; readCount--; readBuffer++, registerBuffer++) {  \</span>
01272 <span class="preprocessor">        *readBuffer = *(volatile UCHAR * const)(registerBuffer);        \</span>
01273 <span class="preprocessor">    }                                                                   \</span>
01274 <span class="preprocessor">}</span>
01275 <span class="preprocessor"></span>
01276 <span class="preprocessor">#define READ_REGISTER_BUFFER_USHORT(x, y, z) {                          \</span>
01277 <span class="preprocessor">    PUSHORT registerBuffer = x;                                         \</span>
01278 <span class="preprocessor">    PUSHORT readBuffer = y;                                             \</span>
01279 <span class="preprocessor">    ULONG readCount;                                                    \</span>
01280 <span class="preprocessor">    __mf();                                                             \</span>
01281 <span class="preprocessor">    for (readCount = z; readCount--; readBuffer++, registerBuffer++) {  \</span>
01282 <span class="preprocessor">        *readBuffer = *(volatile USHORT * const)(registerBuffer);       \</span>
01283 <span class="preprocessor">    }                                                                   \</span>
01284 <span class="preprocessor">}</span>
01285 <span class="preprocessor"></span>
01286 <span class="preprocessor">#define READ_REGISTER_BUFFER_ULONG(x, y, z) {                           \</span>
01287 <span class="preprocessor">    PULONG registerBuffer = x;                                          \</span>
01288 <span class="preprocessor">    PULONG readBuffer = y;                                              \</span>
01289 <span class="preprocessor">    ULONG readCount;                                                    \</span>
01290 <span class="preprocessor">    __mf();                                                             \</span>
01291 <span class="preprocessor">    for (readCount = z; readCount--; readBuffer++, registerBuffer++) {  \</span>
01292 <span class="preprocessor">        *readBuffer = *(volatile ULONG * const)(registerBuffer);        \</span>
01293 <span class="preprocessor">    }                                                                   \</span>
01294 <span class="preprocessor">}</span>
01295 <span class="preprocessor"></span>
01296 <span class="preprocessor">#define WRITE_REGISTER_UCHAR(x, y) {    \</span>
01297 <span class="preprocessor">    *(volatile UCHAR * const)(x) = y;   \</span>
01298 <span class="preprocessor">    KeFlushWriteBuffer();               \</span>
01299 <span class="preprocessor">}</span>
01300 <span class="preprocessor"></span>
01301 <span class="preprocessor">#define WRITE_REGISTER_USHORT(x, y) {   \</span>
01302 <span class="preprocessor">    *(volatile USHORT * const)(x) = y;  \</span>
01303 <span class="preprocessor">    KeFlushWriteBuffer();               \</span>
01304 <span class="preprocessor">}</span>
01305 <span class="preprocessor"></span>
01306 <span class="preprocessor">#define WRITE_REGISTER_ULONG(x, y) {    \</span>
01307 <span class="preprocessor">    *(volatile ULONG * const)(x) = y;   \</span>
01308 <span class="preprocessor">    KeFlushWriteBuffer();               \</span>
01309 <span class="preprocessor">}</span>
01310 <span class="preprocessor"></span>
01311 <span class="preprocessor">#define WRITE_REGISTER_BUFFER_UCHAR(x, y, z) {                            \</span>
01312 <span class="preprocessor">    PUCHAR registerBuffer = x;                                            \</span>
01313 <span class="preprocessor">    PUCHAR writeBuffer = y;                                               \</span>
01314 <span class="preprocessor">    ULONG writeCount;                                                     \</span>
01315 <span class="preprocessor">    for (writeCount = z; writeCount--; writeBuffer++, registerBuffer++) { \</span>
01316 <span class="preprocessor">        *(volatile UCHAR * const)(registerBuffer) = *writeBuffer;         \</span>
01317 <span class="preprocessor">    }                                                                     \</span>
01318 <span class="preprocessor">    KeFlushWriteBuffer();                                                 \</span>
01319 <span class="preprocessor">}</span>
01320 <span class="preprocessor"></span>
01321 <span class="preprocessor">#define WRITE_REGISTER_BUFFER_USHORT(x, y, z) {                           \</span>
01322 <span class="preprocessor">    PUSHORT registerBuffer = x;                                           \</span>
01323 <span class="preprocessor">    PUSHORT writeBuffer = y;                                              \</span>
01324 <span class="preprocessor">    ULONG writeCount;                                                     \</span>
01325 <span class="preprocessor">    for (writeCount = z; writeCount--; writeBuffer++, registerBuffer++) { \</span>
01326 <span class="preprocessor">        *(volatile USHORT * const)(registerBuffer) = *writeBuffer;        \</span>
01327 <span class="preprocessor">    }                                                                     \</span>
01328 <span class="preprocessor">    KeFlushWriteBuffer();                                                 \</span>
01329 <span class="preprocessor">}</span>
01330 <span class="preprocessor"></span>
01331 <span class="preprocessor">#define WRITE_REGISTER_BUFFER_ULONG(x, y, z) {                            \</span>
01332 <span class="preprocessor">    PULONG registerBuffer = x;                                            \</span>
01333 <span class="preprocessor">    PULONG writeBuffer = y;                                               \</span>
01334 <span class="preprocessor">    ULONG writeCount;                                                     \</span>
01335 <span class="preprocessor">    for (writeCount = z; writeCount--; writeBuffer++, registerBuffer++) { \</span>
01336 <span class="preprocessor">        *(volatile ULONG * const)(registerBuffer) = *writeBuffer;         \</span>
01337 <span class="preprocessor">    }                                                                     \</span>
01338 <span class="preprocessor">    KeFlushWriteBuffer();                                                 \</span>
01339 <span class="preprocessor">}</span>
01340 <span class="preprocessor"></span>
01341 <span class="comment">// end_ntddk end_ntndis end_wdm</span>
01342 
01343 
01344 <span class="comment">// Please contact INTEL to get IA64-specific information</span>
01345 <span class="comment">// @@BEGIN_DDKSPLIT</span>
01346 
01347 <span class="comment">//</span>
01348 <span class="comment">// Higher FP volatile // Intel-IA64-Filler</span>
01349 <span class="comment">//</span>
01350 <span class="comment">//  This structure defines the higher FP volatile registers. // Intel-IA64-Filler</span>
01351 <span class="comment">//</span>
01352 
01353 <span class="keyword">typedef</span> <span class="keyword">struct </span>_KHIGHER_FP_VOLATILE { <span class="comment">// Intel-IA64-Filler</span>
01354     <span class="comment">// volatile higher floating registers f32 - f127 // Intel-IA64-Filler</span>
01355     FLOAT128 FltF32; <span class="comment">// Intel-IA64-Filler</span>
01356     FLOAT128 FltF33; <span class="comment">// Intel-IA64-Filler</span>
01357     FLOAT128 FltF34; <span class="comment">// Intel-IA64-Filler</span>
01358     FLOAT128 FltF35; <span class="comment">// Intel-IA64-Filler</span>
01359     FLOAT128 FltF36; <span class="comment">// Intel-IA64-Filler</span>
01360     FLOAT128 FltF37; <span class="comment">// Intel-IA64-Filler</span>
01361     FLOAT128 FltF38; <span class="comment">// Intel-IA64-Filler</span>
01362     FLOAT128 FltF39; <span class="comment">// Intel-IA64-Filler</span>
01363     FLOAT128 FltF40; <span class="comment">// Intel-IA64-Filler</span>
01364     FLOAT128 FltF41; <span class="comment">// Intel-IA64-Filler</span>
01365     FLOAT128 FltF42; <span class="comment">// Intel-IA64-Filler</span>
01366     FLOAT128 FltF43; <span class="comment">// Intel-IA64-Filler</span>
01367     FLOAT128 FltF44; <span class="comment">// Intel-IA64-Filler</span>
01368     FLOAT128 FltF45; <span class="comment">// Intel-IA64-Filler</span>
01369     FLOAT128 FltF46; <span class="comment">// Intel-IA64-Filler</span>
01370     FLOAT128 FltF47; <span class="comment">// Intel-IA64-Filler</span>
01371     FLOAT128 FltF48; <span class="comment">// Intel-IA64-Filler</span>
01372     FLOAT128 FltF49; <span class="comment">// Intel-IA64-Filler</span>
01373     FLOAT128 FltF50; <span class="comment">// Intel-IA64-Filler</span>
01374     FLOAT128 FltF51; <span class="comment">// Intel-IA64-Filler</span>
01375     FLOAT128 FltF52; <span class="comment">// Intel-IA64-Filler</span>
01376     FLOAT128 FltF53; <span class="comment">// Intel-IA64-Filler</span>
01377     FLOAT128 FltF54; <span class="comment">// Intel-IA64-Filler</span>
01378     FLOAT128 FltF55; <span class="comment">// Intel-IA64-Filler</span>
01379     FLOAT128 FltF56; <span class="comment">// Intel-IA64-Filler</span>
01380     FLOAT128 FltF57; <span class="comment">// Intel-IA64-Filler</span>
01381     FLOAT128 FltF58; <span class="comment">// Intel-IA64-Filler</span>
01382     FLOAT128 FltF59; <span class="comment">// Intel-IA64-Filler</span>
01383     FLOAT128 FltF60; <span class="comment">// Intel-IA64-Filler</span>
01384     FLOAT128 FltF61; <span class="comment">// Intel-IA64-Filler</span>
01385     FLOAT128 FltF62; <span class="comment">// Intel-IA64-Filler</span>
01386     FLOAT128 FltF63; <span class="comment">// Intel-IA64-Filler</span>
01387     FLOAT128 FltF64; <span class="comment">// Intel-IA64-Filler</span>
01388     FLOAT128 FltF65; <span class="comment">// Intel-IA64-Filler</span>
01389     FLOAT128 FltF66; <span class="comment">// Intel-IA64-Filler</span>
01390     FLOAT128 FltF67; <span class="comment">// Intel-IA64-Filler</span>
01391     FLOAT128 FltF68; <span class="comment">// Intel-IA64-Filler</span>
01392     FLOAT128 FltF69; <span class="comment">// Intel-IA64-Filler</span>
01393     FLOAT128 FltF70; <span class="comment">// Intel-IA64-Filler</span>
01394     FLOAT128 FltF71; <span class="comment">// Intel-IA64-Filler</span>
01395     FLOAT128 FltF72; <span class="comment">// Intel-IA64-Filler</span>
01396     FLOAT128 FltF73; <span class="comment">// Intel-IA64-Filler</span>
01397     FLOAT128 FltF74; <span class="comment">// Intel-IA64-Filler</span>
01398     FLOAT128 FltF75; <span class="comment">// Intel-IA64-Filler</span>
01399     FLOAT128 FltF76; <span class="comment">// Intel-IA64-Filler</span>
01400     FLOAT128 FltF77; <span class="comment">// Intel-IA64-Filler</span>
01401     FLOAT128 FltF78; <span class="comment">// Intel-IA64-Filler</span>
01402     FLOAT128 FltF79; <span class="comment">// Intel-IA64-Filler</span>
01403     FLOAT128 FltF80; <span class="comment">// Intel-IA64-Filler</span>
01404     FLOAT128 FltF81; <span class="comment">// Intel-IA64-Filler</span>
01405     FLOAT128 FltF82; <span class="comment">// Intel-IA64-Filler</span>
01406     FLOAT128 FltF83; <span class="comment">// Intel-IA64-Filler</span>
01407     FLOAT128 FltF84; <span class="comment">// Intel-IA64-Filler</span>
01408     FLOAT128 FltF85; <span class="comment">// Intel-IA64-Filler</span>
01409     FLOAT128 FltF86; <span class="comment">// Intel-IA64-Filler</span>
01410     FLOAT128 FltF87; <span class="comment">// Intel-IA64-Filler</span>
01411     FLOAT128 FltF88; <span class="comment">// Intel-IA64-Filler</span>
01412     FLOAT128 FltF89; <span class="comment">// Intel-IA64-Filler</span>
01413     FLOAT128 FltF90; <span class="comment">// Intel-IA64-Filler</span>
01414     FLOAT128 FltF91; <span class="comment">// Intel-IA64-Filler</span>
01415     FLOAT128 FltF92; <span class="comment">// Intel-IA64-Filler</span>
01416     FLOAT128 FltF93; <span class="comment">// Intel-IA64-Filler</span>
01417     FLOAT128 FltF94; <span class="comment">// Intel-IA64-Filler</span>
01418     FLOAT128 FltF95; <span class="comment">// Intel-IA64-Filler</span>
01419     FLOAT128 FltF96; <span class="comment">// Intel-IA64-Filler</span>
01420     FLOAT128 FltF97; <span class="comment">// Intel-IA64-Filler</span>
01421     FLOAT128 FltF98; <span class="comment">// Intel-IA64-Filler</span>
01422     FLOAT128 FltF99; <span class="comment">// Intel-IA64-Filler</span>
01423     FLOAT128 FltF100; <span class="comment">// Intel-IA64-Filler</span>
01424     FLOAT128 FltF101; <span class="comment">// Intel-IA64-Filler</span>
01425     FLOAT128 FltF102; <span class="comment">// Intel-IA64-Filler</span>
01426     FLOAT128 FltF103; <span class="comment">// Intel-IA64-Filler</span>
01427     FLOAT128 FltF104; <span class="comment">// Intel-IA64-Filler</span>
01428     FLOAT128 FltF105; <span class="comment">// Intel-IA64-Filler</span>
01429     FLOAT128 FltF106; <span class="comment">// Intel-IA64-Filler</span>
01430     FLOAT128 FltF107; <span class="comment">// Intel-IA64-Filler</span>
01431     FLOAT128 FltF108; <span class="comment">// Intel-IA64-Filler</span>
01432     FLOAT128 FltF109; <span class="comment">// Intel-IA64-Filler</span>
01433     FLOAT128 FltF110; <span class="comment">// Intel-IA64-Filler</span>
01434     FLOAT128 FltF111; <span class="comment">// Intel-IA64-Filler</span>
01435     FLOAT128 FltF112; <span class="comment">// Intel-IA64-Filler</span>
01436     FLOAT128 FltF113; <span class="comment">// Intel-IA64-Filler</span>
01437     FLOAT128 FltF114; <span class="comment">// Intel-IA64-Filler</span>
01438     FLOAT128 FltF115; <span class="comment">// Intel-IA64-Filler</span>
01439     FLOAT128 FltF116; <span class="comment">// Intel-IA64-Filler</span>
01440     FLOAT128 FltF117; <span class="comment">// Intel-IA64-Filler</span>
01441     FLOAT128 FltF118; <span class="comment">// Intel-IA64-Filler</span>
01442     FLOAT128 FltF119; <span class="comment">// Intel-IA64-Filler</span>
01443     FLOAT128 FltF120; <span class="comment">// Intel-IA64-Filler</span>
01444     FLOAT128 FltF121; <span class="comment">// Intel-IA64-Filler</span>
01445     FLOAT128 FltF122; <span class="comment">// Intel-IA64-Filler</span>
01446     FLOAT128 FltF123; <span class="comment">// Intel-IA64-Filler</span>
01447     FLOAT128 FltF124; <span class="comment">// Intel-IA64-Filler</span>
01448     FLOAT128 FltF125; <span class="comment">// Intel-IA64-Filler</span>
01449     FLOAT128 FltF126; <span class="comment">// Intel-IA64-Filler</span>
01450     FLOAT128 FltF127; <span class="comment">// Intel-IA64-Filler</span>
01451 
01452 } KHIGHER_FP_VOLATILE, *PKHIGHER_FP_VOLATILE; <span class="comment">// Intel-IA64-Filler</span>
01453 
01454 <span class="comment">//</span>
01455 <span class="comment">// Debug registers // Intel-IA64-Filler</span>
01456 <span class="comment">//</span>
01457 <span class="comment">// This structure defines the hardware debug registers. // Intel-IA64-Filler</span>
01458 <span class="comment">// We allow space for 4 pairs of instruction and 4 pairs of data debug registers // Intel-IA64-Filler</span>
01459 <span class="comment">// The hardware may actually have more. // Intel-IA64-Filler</span>
01460 <span class="comment">//</span>
01461 
01462 <span class="keyword">typedef</span> <span class="keyword">struct </span>_KDEBUG_REGISTERS { <span class="comment">// Intel-IA64-Filler</span>
01463 
01464     ULONGLONG DbI0; <span class="comment">// Intel-IA64-Filler</span>
01465     ULONGLONG DbI1; <span class="comment">// Intel-IA64-Filler</span>
01466     ULONGLONG DbI2; <span class="comment">// Intel-IA64-Filler</span>
01467     ULONGLONG DbI3; <span class="comment">// Intel-IA64-Filler</span>
01468     ULONGLONG DbI4; <span class="comment">// Intel-IA64-Filler</span>
01469     ULONGLONG DbI5; <span class="comment">// Intel-IA64-Filler</span>
01470     ULONGLONG DbI6; <span class="comment">// Intel-IA64-Filler</span>
01471     ULONGLONG DbI7; <span class="comment">// Intel-IA64-Filler</span>
01472 
01473     ULONGLONG DbD0; <span class="comment">// Intel-IA64-Filler</span>
01474     ULONGLONG DbD1; <span class="comment">// Intel-IA64-Filler</span>
01475     ULONGLONG DbD2; <span class="comment">// Intel-IA64-Filler</span>
01476     ULONGLONG DbD3; <span class="comment">// Intel-IA64-Filler</span>
01477     ULONGLONG DbD4; <span class="comment">// Intel-IA64-Filler</span>
01478     ULONGLONG DbD5; <span class="comment">// Intel-IA64-Filler</span>
01479     ULONGLONG DbD6; <span class="comment">// Intel-IA64-Filler</span>
01480     ULONGLONG DbD7; <span class="comment">// Intel-IA64-Filler</span>
01481 
01482 } KDEBUG_REGISTERS, *PKDEBUG_REGISTERS; <span class="comment">// Intel-IA64-Filler</span>
01483 
01484 <span class="comment">//</span>
01485 <span class="comment">// misc. application registers (mapped to IA-32 registers)</span>
01486 <span class="comment">//</span>
01487 
01488 <span class="keyword">typedef</span> <span class="keyword">struct </span>_KAPPLICATION_REGISTERS {
01489     ULONGLONG Ar21;
01490     ULONGLONG Ar24;
01491     ULONGLONG Ar25;
01492     ULONGLONG Ar26;
01493     ULONGLONG Ar27;
01494     ULONGLONG Ar28;
01495     ULONGLONG Ar29;
01496     ULONGLONG Ar30;
01497 } KAPPLICATION_REGISTERS, *PKAPPLICATION_REGISTERS;
01498 
01499 <span class="comment">//</span>
01500 <span class="comment">// performance registers</span>
01501 <span class="comment">//</span>
01502 
01503 <span class="keyword">typedef</span> <span class="keyword">struct </span>_KPERFORMANCE_REGISTERS {
01504     ULONGLONG Perfr0;
01505     ULONGLONG Perfr1;
01506     ULONGLONG Perfr2;
01507     ULONGLONG Perfr3;
01508     ULONGLONG Perfr4;
01509     ULONGLONG Perfr5;
01510     ULONGLONG Perfr6;
01511     ULONGLONG Perfr7;
01512 } KPERFORMANCE_REGISTERS, *PKPERFORMANCE_REGISTERS;
01513 
01514 <span class="comment">//</span>
01515 <span class="comment">// Thread State save area. Currently, beginning of Kernel Stack // Intel-IA64-Filler</span>
01516 <span class="comment">//</span>
01517 <span class="comment">// This structure defines the area for: // Intel-IA64-Filler</span>
01518 <span class="comment">//</span>
01519 <span class="comment">//      higher fp register save/restore // Intel-IA64-Filler</span>
01520 <span class="comment">//      user debug register save/restore. // Intel-IA64-Filler</span>
01521 <span class="comment">//</span>
01522 <span class="comment">// The order of these area is significant.</span>
01523 <span class="comment">//</span>
01524 
01525 <span class="keyword">typedef</span> <span class="keyword">struct </span>_KTHREAD_STATE_SAVEAREA { <span class="comment">// Intel-IA64-Filler</span>
01526 
01527     KAPPLICATION_REGISTERS AppRegisters;
01528     KPERFORMANCE_REGISTERS PerfRegisters;
01529     KHIGHER_FP_VOLATILE HigherFPVolatile; <span class="comment">// Intel-IA64-Filler</span>
01530     KDEBUG_REGISTERS DebugRegisters; <span class="comment">// Intel-IA64-Filler</span>
01531 
01532 } KTHREAD_STATE_SAVEAREA, *PKTHREAD_STATE_SAVEAREA; <span class="comment">// Intel-IA64-Filler</span>
01533 
01534 <span class="preprocessor">#define KTHREAD_STATE_SAVEAREA_LENGTH ((sizeof(KTHREAD_STATE_SAVEAREA) + 15) &amp; ~((ULONG_PTR)15))</span>
01535 <span class="preprocessor"></span>
01536 <span class="preprocessor">#define GET_HIGH_FLOATING_POINT_REGISTER_SAVEAREA()         \</span>
01537 <span class="preprocessor">    (PKHIGHER_FP_VOLATILE) &amp;(((PKTHREAD_STATE_SAVEAREA)(((ULONG_PTR)PCR-&gt;InitialStack - sizeof(KTHREAD_STATE_SAVEAREA)) &amp; ~((ULONG_PTR)15)))-&gt;HigherFPVolatile)</span>
01538 <span class="preprocessor"></span>
01539 <span class="preprocessor">#define GET_DEBUG_REGISTER_SAVEAREA()                       \</span>
01540 <span class="preprocessor">    (PKDEBUG_REGISTERS) &amp;(((PKTHREAD_STATE_SAVEAREA)(((ULONG_PTR)KeGetCurrentThread()-&gt;StackBase - sizeof(KTHREAD_STATE_SAVEAREA)) &amp; ~((ULONG_PTR)15)))-&gt;DebugRegisters)</span>
01541 <span class="preprocessor"></span>
01542 <span class="preprocessor">#define GET_APPLICATION_REGISTER_SAVEAREA(StackBase)     \</span>
01543 <span class="preprocessor">    (PKAPPLICATION_REGISTERS) &amp;(((PKTHREAD_STATE_SAVEAREA)(((ULONG_PTR)StackBase - sizeof(KTHREAD_STATE_SAVEAREA)) &amp; ~((ULONG_PTR)15)))-&gt;AppRegisters)</span>
01544 <span class="preprocessor"></span>
01545 <span class="comment">// @@END_DDKSPLIT</span>
01546 
01547 <span class="comment">//</span>
01548 <span class="comment">// Exception frame</span>
01549 <span class="comment">//</span>
01550 <span class="comment">//  This frame is established when handling an exception. It provides a place</span>
01551 <span class="comment">//  to save all preserved registers. The volatile registers will already</span>
01552 <span class="comment">//  have been saved in a trap frame. Also used as part of switch frame built</span>
01553 <span class="comment">//  at thread switch.</span>
01554 <span class="comment">//</span>
01555 <span class="comment">//  The frame is 16-byte aligned to maintain 16-byte alignment for the stack,</span>
01556 <span class="comment">//</span>
01557 
01558 <span class="keyword">typedef</span> <span class="keyword">struct </span>_KEXCEPTION_FRAME {
01559 
01560 <span class="comment">// Please contact INTEL to get IA64-specific information</span>
01561 <span class="comment">// @@BEGIN_DDKSPLIT</span>
01562 
01563     <span class="comment">// Preserved application registers // Intel-IA64-Filler</span>
01564     ULONGLONG ApEC;       <span class="comment">// epilogue count // Intel-IA64-Filler</span>
01565     ULONGLONG ApLC;       <span class="comment">// loop count // Intel-IA64-Filler</span>
01566     ULONGLONG IntNats;    <span class="comment">// Nats for S0-S3; i.e. ar.UNAT after spill // Intel-IA64-Filler</span>
01567 
01568     <span class="comment">// Preserved (saved) interger registers, s0-s3 // Intel-IA64-Filler</span>
01569     ULONGLONG IntS0; <span class="comment">// Intel-IA64-Filler</span>
01570     ULONGLONG IntS1; <span class="comment">// Intel-IA64-Filler</span>
01571     ULONGLONG IntS2; <span class="comment">// Intel-IA64-Filler</span>
01572     ULONGLONG IntS3; <span class="comment">// Intel-IA64-Filler</span>
01573 
01574     <span class="comment">// Preserved (saved) branch registers, bs0-bs4 // Intel-IA64-Filler</span>
01575     ULONGLONG BrS0; <span class="comment">// Intel-IA64-Filler</span>
01576     ULONGLONG BrS1; <span class="comment">// Intel-IA64-Filler</span>
01577     ULONGLONG BrS2; <span class="comment">// Intel-IA64-Filler</span>
01578     ULONGLONG BrS3; <span class="comment">// Intel-IA64-Filler</span>
01579     ULONGLONG BrS4; <span class="comment">// Intel-IA64-Filler</span>
01580 
01581     <span class="comment">// Preserved (saved) floating point registers, f2 - f5, f16 - f31 // Intel-IA64-Filler</span>
01582     FLOAT128 FltS0; <span class="comment">// Intel-IA64-Filler</span>
01583     FLOAT128 FltS1; <span class="comment">// Intel-IA64-Filler</span>
01584     FLOAT128 FltS2; <span class="comment">// Intel-IA64-Filler</span>
01585     FLOAT128 FltS3; <span class="comment">// Intel-IA64-Filler</span>
01586     FLOAT128 FltS4; <span class="comment">// Intel-IA64-Filler</span>
01587     FLOAT128 FltS5; <span class="comment">// Intel-IA64-Filler</span>
01588     FLOAT128 FltS6; <span class="comment">// Intel-IA64-Filler</span>
01589     FLOAT128 FltS7; <span class="comment">// Intel-IA64-Filler</span>
01590     FLOAT128 FltS8; <span class="comment">// Intel-IA64-Filler</span>
01591     FLOAT128 FltS9; <span class="comment">// Intel-IA64-Filler</span>
01592     FLOAT128 FltS10; <span class="comment">// Intel-IA64-Filler</span>
01593     FLOAT128 FltS11; <span class="comment">// Intel-IA64-Filler</span>
01594     FLOAT128 FltS12; <span class="comment">// Intel-IA64-Filler</span>
01595     FLOAT128 FltS13; <span class="comment">// Intel-IA64-Filler</span>
01596     FLOAT128 FltS14; <span class="comment">// Intel-IA64-Filler</span>
01597     FLOAT128 FltS15; <span class="comment">// Intel-IA64-Filler</span>
01598     FLOAT128 FltS16; <span class="comment">// Intel-IA64-Filler</span>
01599     FLOAT128 FltS17; <span class="comment">// Intel-IA64-Filler</span>
01600     FLOAT128 FltS18; <span class="comment">// Intel-IA64-Filler</span>
01601     FLOAT128 FltS19; <span class="comment">// Intel-IA64-Filler</span>
01602 
01603 <span class="comment">// @@END_DDKSPLIT</span>
01604 
01605 } KEXCEPTION_FRAME, *PKEXCEPTION_FRAME;
01606 
01607 <span class="comment">// Please contact INTEL to get IA64-specific information</span>
01608 <span class="comment">// @@BEGIN_DDKSPLIT</span>
01609 
01610 <span class="comment">//</span>
01611 <span class="comment">// Switch frame</span>
01612 <span class="comment">//</span>
01613 <span class="comment">//  This frame is established when doing a thread switch in SwapContext. It</span>
01614 <span class="comment">//  provides a place to save the preserved kernel state at the point of the</span>
01615 <span class="comment">//  switch registers.</span>
01616 <span class="comment">//  The volatile registers are scratch across the call to SwapContext.</span>
01617 <span class="comment">//</span>
01618 <span class="comment">//  The frame is 16-byte aligned to maintain 16-byte alignment for the stack,</span>
01619 <span class="comment">//</span>
01620 
01621 <span class="keyword">typedef</span> <span class="keyword">struct </span>_KSWITCH_FRAME { <span class="comment">// Intel-IA64-Filler</span>
01622 
01623     ULONGLONG SwitchPredicates; <span class="comment">// Predicates for Switch // Intel-IA64-Filler</span>
01624     ULONGLONG SwitchRp;         <span class="comment">// return pointer for Switch // Intel-IA64-Filler</span>
01625     ULONGLONG SwitchPFS;        <span class="comment">// PFS for Switch // Intel-IA64-Filler</span>
01626     ULONGLONG SwitchFPSR;   <span class="comment">// ProcessorFP status at thread switch // Intel-IA64-Filler</span>
01627     ULONGLONG SwitchBsp;                     <span class="comment">// Intel-IA64-Filler</span>
01628     ULONGLONG SwitchRnat;                     <span class="comment">// Intel-IA64-Filler</span>
01629     <span class="comment">// ULONGLONG Pad;</span>
01630 
01631     KEXCEPTION_FRAME SwitchExceptionFrame; <span class="comment">// Intel-IA64-Filler</span>
01632 
01633 } KSWITCH_FRAME, *PKSWITCH_FRAME; <span class="comment">// Intel-IA64-Filler</span>
01634 
01635 <span class="comment">// Trap frame</span>
01636 <span class="comment">//  This frame is established when handling a trap. It provides a place to</span>
01637 <span class="comment">//  save all volatile registers. The nonvolatile registers are saved in an</span>
01638 <span class="comment">//  exception frame or through the normal C calling conventions for saved</span>
01639 <span class="comment">//  registers.  Its size must be a multiple of 16 bytes.</span>
01640 <span class="comment">//</span>
01641 <span class="comment">//  N.B - the 16-byte alignment is required to maintain the stack alignment.</span>
01642 <span class="comment">//</span>
01643 
01644 <span class="preprocessor">#define KTRAP_FRAME_ARGUMENTS (8 * 8)       // up to 8 in-memory syscall args // Intel-IA64-Filler</span>
01645 <span class="preprocessor"></span>
01646 <span class="comment">// @@END_DDKSPLIT</span>
01647 
01648 <span class="keyword">typedef</span> <span class="keyword">struct </span>_KTRAP_FRAME {
01649 <span class="comment">// Please contact INTEL to get IA64-specific information</span>
01650 <span class="comment">// @@BEGIN_DDKSPLIT</span>
01651 
01652     <span class="comment">//</span>
01653     <span class="comment">// Reserved for additional memory arguments and stack scratch area</span>
01654     <span class="comment">// The size of Reserved[] must be a multiple of 16 bytes.</span>
01655     <span class="comment">//</span>
01656 
01657     ULONGLONG Reserved[(KTRAP_FRAME_ARGUMENTS+16)/8]; <span class="comment">// Intel-IA64-Filler</span>
01658 
01659     <span class="comment">// Temporary (volatile) FP registers - f6-f15 (don't use f32+ in kernel) // Intel-IA64-Filler</span>
01660     FLOAT128 FltT0; <span class="comment">// Intel-IA64-Filler</span>
01661     FLOAT128 FltT1; <span class="comment">// Intel-IA64-Filler</span>
01662     FLOAT128 FltT2; <span class="comment">// Intel-IA64-Filler</span>
01663     FLOAT128 FltT3; <span class="comment">// Intel-IA64-Filler</span>
01664     FLOAT128 FltT4; <span class="comment">// Intel-IA64-Filler</span>
01665     FLOAT128 FltT5; <span class="comment">// Intel-IA64-Filler</span>
01666     FLOAT128 FltT6; <span class="comment">// Intel-IA64-Filler</span>
01667     FLOAT128 FltT7; <span class="comment">// Intel-IA64-Filler</span>
01668     FLOAT128 FltT8; <span class="comment">// Intel-IA64-Filler</span>
01669     FLOAT128 FltT9; <span class="comment">// Intel-IA64-Filler</span>
01670 
01671     <span class="comment">// Temporary (volatile) interger registers</span>
01672     ULONGLONG IntGp;    <span class="comment">// global pointer (r1) // Intel-IA64-Filler</span>
01673     ULONGLONG IntT0; <span class="comment">// Intel-IA64-Filler</span>
01674     ULONGLONG IntT1; <span class="comment">// Intel-IA64-Filler</span>
01675                         <span class="comment">// The following 4 registers fill in space of preserved  (S0-S3) to align Nats // Intel-IA64-Filler</span>
01676     ULONGLONG ApUNAT;   <span class="comment">// ar.UNAT on kernel entry // Intel-IA64-Filler</span>
01677     ULONGLONG ApCCV;    <span class="comment">// ar.CCV // Intel-IA64-Filler</span>
01678     ULONGLONG ApDCR;    <span class="comment">// DCR register on kernel entry // Intel-IA64-Filler</span>
01679     ULONGLONG Preds;    <span class="comment">// Predicates // Intel-IA64-Filler</span>
01680 
01681     ULONGLONG IntV0;    <span class="comment">// return value (r8) // Intel-IA64-Filler</span>
01682     ULONGLONG IntT2; <span class="comment">// Intel-IA64-Filler</span>
01683     ULONGLONG IntT3; <span class="comment">// Intel-IA64-Filler</span>
01684     ULONGLONG IntT4; <span class="comment">// Intel-IA64-Filler</span>
01685     ULONGLONG IntSp;    <span class="comment">// stack pointer (r12) // Intel-IA64-Filler</span>
01686     ULONGLONG IntTeb;   <span class="comment">// teb (r13) // Intel-IA64-Filler</span>
01687     ULONGLONG IntT5; <span class="comment">// Intel-IA64-Filler</span>
01688     ULONGLONG IntT6; <span class="comment">// Intel-IA64-Filler</span>
01689     ULONGLONG IntT7; <span class="comment">// Intel-IA64-Filler</span>
01690     ULONGLONG IntT8; <span class="comment">// Intel-IA64-Filler</span>
01691     ULONGLONG IntT9; <span class="comment">// Intel-IA64-Filler</span>
01692     ULONGLONG IntT10; <span class="comment">// Intel-IA64-Filler</span>
01693     ULONGLONG IntT11; <span class="comment">// Intel-IA64-Filler</span>
01694     ULONGLONG IntT12; <span class="comment">// Intel-IA64-Filler</span>
01695     ULONGLONG IntT13; <span class="comment">// Intel-IA64-Filler</span>
01696     ULONGLONG IntT14; <span class="comment">// Intel-IA64-Filler</span>
01697     ULONGLONG IntT15; <span class="comment">// Intel-IA64-Filler</span>
01698     ULONGLONG IntT16; <span class="comment">// Intel-IA64-Filler</span>
01699     ULONGLONG IntT17; <span class="comment">// Intel-IA64-Filler</span>
01700     ULONGLONG IntT18; <span class="comment">// Intel-IA64-Filler</span>
01701     ULONGLONG IntT19; <span class="comment">// Intel-IA64-Filler</span>
01702     ULONGLONG IntT20; <span class="comment">// Intel-IA64-Filler</span>
01703     ULONGLONG IntT21; <span class="comment">// Intel-IA64-Filler</span>
01704     ULONGLONG IntT22; <span class="comment">// Intel-IA64-Filler</span>
01705 
01706     ULONGLONG IntNats;  <span class="comment">// Temporary (volatile) registers' Nats directly from ar.UNAT at point of spill // Intel-IA64-Filler</span>
01707 
01708     ULONGLONG BrRp;     <span class="comment">// Return pointer on kernel entry // Intel-IA64-Filler</span>
01709 
01710     ULONGLONG BrT0;     <span class="comment">// Temporary (volatile) branch registers (b6-b7) // Intel-IA64-Filler</span>
01711     ULONGLONG BrT1; <span class="comment">// Intel-IA64-Filler</span>
01712 
01713     <span class="comment">// Register stack info // Intel-IA64-Filler</span>
01714     ULONGLONG RsRSC;    <span class="comment">// RSC on kernel entry // Intel-IA64-Filler</span>
01715     ULONGLONG RsBSP;    <span class="comment">// BSP on kernel entry // Intel-IA64-Filler</span>
01716     ULONGLONG RsBSPSTORE; <span class="comment">// User BSP Store at point of switch to kernel backing store // Intel-IA64-Filler</span>
01717     ULONGLONG RsRNAT;   <span class="comment">// old RNAT at point of switch to kernel backing store // Intel-IA64-Filler</span>
01718     ULONGLONG RsPFS;    <span class="comment">// PFS on kernel entry // Intel-IA64-Filler</span>
01719 
01720     <span class="comment">// Trap Status Information // Intel-IA64-Filler</span>
01721     ULONGLONG StIPSR;   <span class="comment">// Interruption Processor Status Register // Intel-IA64-Filler</span>
01722     ULONGLONG StIIP;    <span class="comment">// Interruption IP // Intel-IA64-Filler</span>
01723     ULONGLONG StIFS;    <span class="comment">// Interruption Function State // Intel-IA64-Filler</span>
01724     ULONGLONG StFPSR;   <span class="comment">// FP status // Intel-IA64-Filler</span>
01725     ULONGLONG StISR;    <span class="comment">// Interruption Status Register // Intel-IA64-Filler</span>
01726     ULONGLONG StIFA;    <span class="comment">// Interruption Data Address // Intel-IA64-Filler</span>
01727     ULONGLONG StIIPA;   <span class="comment">// Last executed bundle address // Intel-IA64-Filler</span>
01728     ULONGLONG StIIM;    <span class="comment">// Interruption Immediate // Intel-IA64-Filler</span>
01729     ULONGLONG StIHA;    <span class="comment">// Interruption Hash Address // Intel-IA64-Filler</span>
01730 
01731     ULONG OldIrql;      <span class="comment">// Previous Irql. // Intel-IA64-Filler</span>
01732     ULONG PreviousMode; <span class="comment">// Previous Mode. // Intel-IA64-Filler</span>
01733     ULONGLONG TrapFrame;<span class="comment">// Previous Trap Frame // Intel-IA64-Filler</span>
01734 <span class="comment">// @@END_DDKSPLIT</span>
01735     <span class="comment">// Exception record</span>
01736     UCHAR ExceptionRecord[(<span class="keyword">sizeof</span>(EXCEPTION_RECORD) + 15) &amp; (~15)];
01737 
01738     <span class="comment">// End of frame marker (for debugging)</span>
01739     ULONGLONG Handler;  <span class="comment">// Handler for this trap</span>
01740     ULONGLONG EOFMarker;
01741 } KTRAP_FRAME, *PKTRAP_FRAME;
01742 
01743 <span class="preprocessor">#define KTRAP_FRAME_LENGTH ((sizeof(KTRAP_FRAME) + 15) &amp; (~15))</span>
01744 <span class="preprocessor"></span><span class="preprocessor">#define KTRAP_FRAME_ALIGN (16)</span>
01745 <span class="preprocessor"></span><span class="preprocessor">#define KTRAP_FRAME_ROUND (KTRAP_FRAME_ALIGN - 1)</span>
01746 <span class="preprocessor"></span><span class="preprocessor">#define KTRAP_FRAME_EOF 0xe0f0e0f0e0f0e000i64</span>
01747 <span class="preprocessor"></span>
01748 <span class="comment">//</span>
01749 <span class="comment">// Use the lowest 4 bits of EOFMarker field to encode the trap frame type</span>
01750 <span class="comment">//</span>
01751 
01752 <span class="preprocessor">#define SYSCALL_FRAME      0</span>
01753 <span class="preprocessor"></span><span class="preprocessor">#define INTERRUPT_FRAME    1</span>
01754 <span class="preprocessor"></span><span class="preprocessor">#define EXCEPTION_FRAME    2</span>
01755 <span class="preprocessor"></span><span class="preprocessor">#define CONTEXT_FRAME      10</span>
01756 <span class="preprocessor"></span>
01757 <span class="preprocessor">#define TRAP_FRAME_TYPE(tf)  (tf-&gt;EOFMarker &amp; 0xf)</span>
01758 <span class="preprocessor"></span>
01759 <span class="comment">//</span>
01760 <span class="comment">// Define the kernel mode and user mode callback frame structures.</span>
01761 <span class="comment">//</span>
01762 
01763 <span class="comment">//</span>
01764 <span class="comment">// The frame saved by KiCallUserMode is defined here to allow</span>
01765 <span class="comment">// the kernel debugger to trace the entire kernel stack</span>
01766 <span class="comment">// when usermode callouts are pending.</span>
01767 <span class="comment">//</span>
01768 <span class="comment">// N.B. The size of the following structure must be a multiple of 16 bytes</span>
01769 <span class="comment">//      and it must be 16-byte aligned.</span>
01770 <span class="comment">//</span>
01771 
01772 <span class="keyword">typedef</span> <span class="keyword">struct </span>_KCALLOUT_FRAME {
01773 
01774 <span class="comment">// Please contact INTEL to get IA64-specific information</span>
01775 <span class="comment">// @@BEGIN_DDKSPLIT</span>
01776 
01777     ULONGLONG   BrRp;       <span class="comment">// Intel-IA64-Filler</span>
01778     ULONGLONG   RsPFS;       <span class="comment">// Intel-IA64-Filler</span>
01779     ULONGLONG   Preds;       <span class="comment">// Intel-IA64-Filler</span>
01780     ULONGLONG   ApUNAT;       <span class="comment">// Intel-IA64-Filler</span>
01781     ULONGLONG   ApLC;       <span class="comment">// Intel-IA64-Filler</span>
01782     ULONGLONG   RsRNAT;       <span class="comment">// Intel-IA64-Filler</span>
01783     ULONGLONG   IntNats;       <span class="comment">// Intel-IA64-Filler</span>
01784 
01785     ULONGLONG   IntS0;       <span class="comment">// Intel-IA64-Filler</span>
01786     ULONGLONG   IntS1;       <span class="comment">// Intel-IA64-Filler</span>
01787     ULONGLONG   IntS2;       <span class="comment">// Intel-IA64-Filler</span>
01788     ULONGLONG   IntS3;       <span class="comment">// Intel-IA64-Filler</span>
01789 
01790     ULONGLONG   BrS0;       <span class="comment">// Intel-IA64-Filler</span>
01791     ULONGLONG   BrS1;       <span class="comment">// Intel-IA64-Filler</span>
01792     ULONGLONG   BrS2;       <span class="comment">// Intel-IA64-Filler</span>
01793     ULONGLONG   BrS3;       <span class="comment">// Intel-IA64-Filler</span>
01794     ULONGLONG   BrS4;       <span class="comment">// Intel-IA64-Filler</span>
01795 
01796     FLOAT128    FltS0;          <span class="comment">// 16-byte aligned boundary       // Intel-IA64-Filler</span>
01797     FLOAT128    FltS1;       <span class="comment">// Intel-IA64-Filler</span>
01798     FLOAT128    FltS2;       <span class="comment">// Intel-IA64-Filler</span>
01799     FLOAT128    FltS3;       <span class="comment">// Intel-IA64-Filler</span>
01800     FLOAT128    FltS4;       <span class="comment">// Intel-IA64-Filler</span>
01801     FLOAT128    FltS5;       <span class="comment">// Intel-IA64-Filler</span>
01802     FLOAT128    FltS6;       <span class="comment">// Intel-IA64-Filler</span>
01803     FLOAT128    FltS7;       <span class="comment">// Intel-IA64-Filler</span>
01804     FLOAT128    FltS8;       <span class="comment">// Intel-IA64-Filler</span>
01805     FLOAT128    FltS9;       <span class="comment">// Intel-IA64-Filler</span>
01806     FLOAT128    FltS10;       <span class="comment">// Intel-IA64-Filler</span>
01807     FLOAT128    FltS11;       <span class="comment">// Intel-IA64-Filler</span>
01808     FLOAT128    FltS12;       <span class="comment">// Intel-IA64-Filler</span>
01809     FLOAT128    FltS13;       <span class="comment">// Intel-IA64-Filler</span>
01810     FLOAT128    FltS14;       <span class="comment">// Intel-IA64-Filler</span>
01811     FLOAT128    FltS15;       <span class="comment">// Intel-IA64-Filler</span>
01812     FLOAT128    FltS16;       <span class="comment">// Intel-IA64-Filler</span>
01813     FLOAT128    FltS17;       <span class="comment">// Intel-IA64-Filler</span>
01814     FLOAT128    FltS18;       <span class="comment">// Intel-IA64-Filler</span>
01815     FLOAT128    FltS19;       <span class="comment">// Intel-IA64-Filler</span>
01816 
01817     ULONGLONG   A0;             <span class="comment">// saved argument registers a0-a2       // Intel-IA64-Filler</span>
01818     ULONGLONG   <a class="code" href="../../d1/d1/bench_8c.html#a6">A1</a>;       <span class="comment">// Intel-IA64-Filler</span>
01819     ULONGLONG   CbStk;          <span class="comment">// saved callback stack address       // Intel-IA64-Filler</span>
01820     ULONGLONG   InStack;        <span class="comment">// saved initial stack address       // Intel-IA64-Filler</span>
01821     ULONGLONG   CbBStore;       <span class="comment">// saved callback stack address       // Intel-IA64-Filler</span>
01822     ULONGLONG   InBStore;       <span class="comment">// saved initial stack address       // Intel-IA64-Filler</span>
01823     ULONGLONG   TrFrame;        <span class="comment">// saved callback trap frame address       // Intel-IA64-Filler</span>
01824     ULONGLONG   TrStIIP;        <span class="comment">// saved continuation address       // Intel-IA64-Filler</span>
01825 
01826 <span class="comment">// @@END_DDKSPLIT</span>
01827 
01828 } KCALLOUT_FRAME, *PKCALLOUT_FRAME;
01829 
01830 
01831 <span class="keyword">typedef</span> <span class="keyword">struct </span>_UCALLOUT_FRAME {
01832 <span class="comment">// Please contact INTEL to get IA64-specific information</span>
01833 <span class="comment">// @@BEGIN_DDKSPLIT</span>
01834     PVOID <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>;       <span class="comment">// Intel-IA64-Filler</span>
01835     ULONG Length;       <span class="comment">// Intel-IA64-Filler</span>
01836     ULONG ApiNumber;       <span class="comment">// Intel-IA64-Filler</span>
01837     ULONGLONG IntSp;       <span class="comment">// Intel-IA64-Filler</span>
01838     ULONGLONG RsPFS;       <span class="comment">// Intel-IA64-Filler</span>
01839     ULONGLONG BrRp;       <span class="comment">// Intel-IA64-Filler</span>
01840     ULONGLONG Pad;       <span class="comment">// Intel-IA64-Filler</span>
01841 <span class="comment">// @@END_DDKSPLIT</span>
01842 } UCALLOUT_FRAME, *PUCALLOUT_FRAME;
01843 
01844 
01845 <span class="comment">// end_nthal</span>
01846 
01847 <span class="comment">// begin_ntddk begin_wdm</span>
01848 <span class="comment">//</span>
01849 <span class="comment">// Non-volatile floating point state</span>
01850 <span class="comment">//</span>
01851 
01852 <span class="keyword">typedef</span> <span class="keyword">struct </span>_KFLOATING_SAVE {
01853     ULONG   Reserved;
01854 } KFLOATING_SAVE, *PKFLOATING_SAVE;
01855 
01856 <span class="comment">// end_ntddk end_wdm</span>
01857 
01858 <span class="preprocessor">#define STATUS_IA64_INVALID_STACK     STATUS_BAD_STACK</span>
01859 <span class="preprocessor"></span>
01860 <span class="comment">//</span>
01861 <span class="comment">// iA32 control bits definition</span>
01862 <span class="comment">//</span>
01863 <span class="comment">//</span>
01864 <span class="comment">// Define constants to access the bits in CR0.</span>
01865 <span class="comment">//</span>
01866 
01867 <span class="preprocessor">#define CR0_PG  0x80000000          // paging</span>
01868 <span class="preprocessor"></span><span class="preprocessor">#define CR0_ET  0x00000010          // extension type (80387)</span>
01869 <span class="preprocessor"></span><span class="preprocessor">#define CR0_TS  0x00000008          // task switched</span>
01870 <span class="preprocessor"></span><span class="preprocessor">#define CR0_EM  0x00000004          // emulate math coprocessor</span>
01871 <span class="preprocessor"></span><span class="preprocessor">#define CR0_MP  0x00000002          // math present</span>
01872 <span class="preprocessor"></span><span class="preprocessor">#define CR0_PE  0x00000001          // protection enable</span>
01873 <span class="preprocessor"></span>
01874 <span class="comment">//</span>
01875 <span class="comment">// More CR0 bits; these only apply to the 80486.</span>
01876 <span class="comment">//</span>
01877 
01878 <span class="preprocessor">#define CR0_CD  0x40000000          // cache disable</span>
01879 <span class="preprocessor"></span><span class="preprocessor">#define CR0_NW  0x20000000          // not write-through</span>
01880 <span class="preprocessor"></span><span class="preprocessor">#define CR0_AM  0x00040000          // alignment mask</span>
01881 <span class="preprocessor"></span><span class="preprocessor">#define CR0_WP  0x00010000          // write protect</span>
01882 <span class="preprocessor"></span><span class="preprocessor">#define CR0_NE  0x00000020          // numeric error</span>
01883 <span class="preprocessor"></span>
01884 <span class="comment">//</span>
01885 <span class="comment">// Define constants to access CFLG bits</span>
01886 <span class="comment">//</span>
01887 <span class="preprocessor">#define CFLG_IO 0x00000040          // IO bit map checking on</span>
01888 <span class="preprocessor"></span><span class="preprocessor">#define CFLG_IF 0x00000080          // EFLAG.if to control external interrupt</span>
01889 <span class="preprocessor"></span><span class="preprocessor">#define CFLG_II 0x00000100          // enable EFLAG.if interception</span>
01890 <span class="preprocessor"></span><span class="preprocessor">#define CFLG_NM 0x00000200          // NMI intercept</span>
01891 <span class="preprocessor"></span>
01892 <span class="comment">//</span>
01893 <span class="comment">// CR4 bits;  These only apply to Pentium</span>
01894 <span class="comment">//</span>
01895 <span class="preprocessor">#define CR4_VME 0x00000001          // V86 mode extensions</span>
01896 <span class="preprocessor"></span><span class="preprocessor">#define CR4_PVI 0x00000002          // Protected mode virtual interrupts</span>
01897 <span class="preprocessor"></span><span class="preprocessor">#define CR4_TSD 0x00000004          // Time stamp disable</span>
01898 <span class="preprocessor"></span><span class="preprocessor">#define CR4_DE  0x00000008          // Debugging Extensions</span>
01899 <span class="preprocessor"></span><span class="preprocessor">#define CR4_PSE 0x00000010          // Page size extensions</span>
01900 <span class="preprocessor"></span><span class="preprocessor">#define CR4_MCE 0x00000040          // Machine check enable</span>
01901 <span class="preprocessor"></span>
01902 <span class="comment">//</span>
01903 <span class="comment">// Define constants to access ThNpxState</span>
01904 <span class="comment">//</span>
01905 
01906 <span class="preprocessor">#define NPX_STATE_NOT_LOADED    (CR0_TS | CR0_MP)</span>
01907 <span class="preprocessor"></span><span class="preprocessor">#define NPX_STATE_LOADED        0</span>
01908 <span class="preprocessor"></span>
01909 <span class="comment">//</span>
01910 <span class="comment">// begin_nthal begin_ntddk begin_wdm</span>
01911 <span class="comment">//</span>
01912 <span class="comment">// STATUS register for each MCA bank.</span>
01913 <span class="comment">//</span>
01914 
01915 <span class="keyword">typedef</span> <span class="keyword">union </span>_MCI_STATS {
01916     <span class="keyword">struct </span>{
01917         <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>  McaCod;
01918         <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>  MsCod;
01919         ULONG   OtherInfo : 25;
01920         ULONG   Damage : 1;
01921         ULONG   AddressValid : 1;
01922         ULONG   MiscValid : 1;
01923         ULONG   Enabled : 1;
01924         ULONG   UnCorrected : 1;
01925         ULONG   OverFlow : 1;
01926         ULONG   Valid : 1;
01927     } MciStats;
01928 
01929     ULONGLONG QuadPart;
01930 
01931 } MCI_STATS, *PMCI_STATS;
01932 
01933 <span class="comment">// end_ntddk end_wdm</span>
01934 <span class="comment">//</span>
01935 <span class="comment">// Machine type definitions</span>
01936 <span class="comment">// BUGBUG shielint These are temporary definitions.</span>
01937 <span class="comment">//</span>
01938 
01939 <span class="preprocessor">#define MACHINE_TYPE_ISA 0</span>
01940 <span class="preprocessor"></span><span class="preprocessor">#define MACHINE_TYPE_EISA 1</span>
01941 <span class="preprocessor"></span><span class="preprocessor">#define MACHINE_TYPE_MCA 2</span>
01942 <span class="preprocessor"></span>
01943 <span class="comment">//</span>
01944 <span class="comment">// PAL Interface</span>
01945 <span class="comment">//</span>
01946 <span class="comment">// iA-64 defined PAL function IDs in decimal format as in the PAL spec</span>
01947 <span class="comment">// All PAL calls done through HAL. HAL may block some calls</span>
01948 <span class="comment">//</span>
01949 
01950 <span class="preprocessor">#define PAL_CACHE_FLUSH                                       1I64</span>
01951 <span class="preprocessor"></span><span class="preprocessor">#define PAL_CACHE_INFO                                        2I64</span>
01952 <span class="preprocessor"></span><span class="preprocessor">#define PAL_CACHE_INIT                                        3I64</span>
01953 <span class="preprocessor"></span><span class="preprocessor">#define PAL_CACHE_SUMMARY                                     4I64</span>
01954 <span class="preprocessor"></span><span class="preprocessor">#define PAL_PTCE_INFO                                         6I64</span>
01955 <span class="preprocessor"></span><span class="preprocessor">#define PAL_MEM_ATTRIB                                        5I64</span>
01956 <span class="preprocessor"></span><span class="preprocessor">#define PAL_VM_INFO                                           7I64</span>
01957 <span class="preprocessor"></span><span class="preprocessor">#define PAL_VM_SUMMARY                                        8I64</span>
01958 <span class="preprocessor"></span><span class="preprocessor">#define PAL_BUS_GET_FEATURES                                  9I64</span>
01959 <span class="preprocessor"></span><span class="preprocessor">#define PAL_BUS_SET_FEATURES                                 10I64</span>
01960 <span class="preprocessor"></span><span class="preprocessor">#define PAL_DEBUG_INFO                                       11I64</span>
01961 <span class="preprocessor"></span><span class="preprocessor">#define PAL_FIXED_ADDR                                       12I64</span>
01962 <span class="preprocessor"></span><span class="preprocessor">#define PAL_FREQ_BASE                                        13I64</span>
01963 <span class="preprocessor"></span><span class="preprocessor">#define PAL_FREQ_RATIOS                                      14I64</span>
01964 <span class="preprocessor"></span><span class="preprocessor">#define PAL_PERF_MON_INFO                                    15I64</span>
01965 <span class="preprocessor"></span><span class="preprocessor">#define PAL_PLATFORM_ADDR                                    16I64</span>
01966 <span class="preprocessor"></span><span class="preprocessor">#define PAL_PROC_GET_FEATURES                                17I64</span>
01967 <span class="preprocessor"></span><span class="preprocessor">#define PAL_PROC_SET_FEATURES                                18I64</span>
01968 <span class="preprocessor"></span><span class="preprocessor">#define PAL_RSE_INFO                                         19I64</span>
01969 <span class="preprocessor"></span><span class="preprocessor">#define PAL_VERSION                                          20I64</span>
01970 <span class="preprocessor"></span><span class="preprocessor">#define PAL_MC_CLEAR_LOG                                     21I64</span>
01971 <span class="preprocessor"></span><span class="preprocessor">#define PAL_MC_DRAIN                                         22I64</span>
01972 <span class="preprocessor"></span><span class="preprocessor">#define PAL_MC_EXPECTED                                      23I64</span>
01973 <span class="preprocessor"></span><span class="preprocessor">#define PAL_MC_DYNAMIC_STATE                                 24I64</span>
01974 <span class="preprocessor"></span><span class="preprocessor">#define PAL_MC_ERROR_INFO                                    25I64</span>
01975 <span class="preprocessor"></span><span class="preprocessor">#define PAL_MC_RESUME                                        26I64</span>
01976 <span class="preprocessor"></span><span class="preprocessor">#define PAL_MC_REGISTER_MEM                                  27I64</span>
01977 <span class="preprocessor"></span><span class="preprocessor">#define PAL_HALT                                             28I64</span>
01978 <span class="preprocessor"></span><span class="preprocessor">#define PAL_HALT_LIGHT                                       29I64</span>
01979 <span class="preprocessor"></span><span class="preprocessor">#define PAL_COPY_INFO                                        30I64</span>
01980 <span class="preprocessor"></span><span class="preprocessor">#define PAL_CACHE_LINE_INIT                                  31I64</span>
01981 <span class="preprocessor"></span><span class="preprocessor">#define PAL_PMI_ENTRYPOINT                                   32I64</span>
01982 <span class="preprocessor"></span><span class="preprocessor">#define PAL_ENTER_IA_32_ENV                                  33I64</span>
01983 <span class="preprocessor"></span><span class="preprocessor">#define PAL_VM_PAGE_SIZE                                     34I64</span>
01984 <span class="preprocessor"></span><span class="preprocessor">#define PAL_MEM_FOR_TEST                                     37I64</span>
01985 <span class="preprocessor"></span><span class="preprocessor">#define PAL_CACHE_PROT_INFO                                  38I64</span>
01986 <span class="preprocessor"></span><span class="preprocessor">#define PAL_REGISTER_INFO                                    39I64</span>
01987 <span class="preprocessor"></span><span class="preprocessor">#define PAL_SHUTDOWN                                         44I64</span>
01988 <span class="preprocessor"></span><span class="preprocessor">#define PAL_PREFETCH_VISIBILITY                              41I64</span>
01989 <span class="preprocessor"></span>
01990 <span class="preprocessor">#define PAL_COPY_PAL                                        256I64</span>
01991 <span class="preprocessor"></span><span class="preprocessor">#define PAL_HALT_INFO                                       257I64</span>
01992 <span class="preprocessor"></span><span class="preprocessor">#define PAL_TEST_PROC                                       258I64</span>
01993 <span class="preprocessor"></span><span class="preprocessor">#define PAL_CACHE_READ                                      259I64</span>
01994 <span class="preprocessor"></span><span class="preprocessor">#define PAL_CACHE_WRITE                                     260I64</span>
01995 <span class="preprocessor"></span><span class="preprocessor">#define PAL_VM_TR_READ                                      261I64</span>
01996 <span class="preprocessor"></span>
01997 <span class="comment">//</span>
01998 <span class="comment">// iA-64 defined PAL return values</span>
01999 <span class="comment">//</span>
02000 
02001 <span class="preprocessor">#define PAL_STATUS_INVALID_CACHELINE                          1I64</span>
02002 <span class="preprocessor"></span><span class="preprocessor">#define PAL_STATUS_SUPPORT_NOT_NEEDED                         1I64</span>
02003 <span class="preprocessor"></span><span class="preprocessor">#define PAL_STATUS_SUCCESS                                    0</span>
02004 <span class="preprocessor"></span><span class="preprocessor">#define PAL_STATUS_NOT_IMPLEMENTED                           -1I64</span>
02005 <span class="preprocessor"></span><span class="preprocessor">#define PAL_STATUS_INVALID_ARGUMENT                          -2I64</span>
02006 <span class="preprocessor"></span><span class="preprocessor">#define PAL_STATUS_ERROR                                     -3I64</span>
02007 <span class="preprocessor"></span><span class="preprocessor">#define PAL_STATUS_UNABLE_TO_INIT_CACHE_LEVEL_AND_TYPE       -4I64</span>
02008 <span class="preprocessor"></span><span class="preprocessor">#define PAL_STATUS_NOT_FOUND_IN_CACHE                        -5I64</span>
02009 <span class="preprocessor"></span><span class="preprocessor">#define PAL_STATUS_NO_ERROR_INFO_AVAILABLE                   -6I64</span>
02010 <span class="preprocessor"></span>
02011 
02012 <span class="comment">// end_nthal</span>
02013                
02014 <span class="comment">//</span>
02015 <span class="comment">// Define constants used in selector tests.</span>
02016 <span class="comment">//</span>
02017 <span class="comment">//  RPL_MASK is the real value for extracting RPL values.  IT IS THE WRONG</span>
02018 <span class="comment">//  CONSTANT TO USE FOR MODE TESTING.</span>
02019 <span class="comment">//</span>
02020 <span class="comment">//  MODE_MASK is the value for deciding the current mode.</span>
02021 <span class="comment">//  WARNING:    MODE_MASK assumes that all code runs at either ring-0</span>
02022 <span class="comment">//              or ring-3.  Ring-1 or Ring-2 support will require changing</span>
02023 <span class="comment">//              this value and all of the code that refers to it.</span>
02024 
02025 <span class="preprocessor">#define MODE_MASK    1</span>
02026 <span class="preprocessor"></span><span class="preprocessor">#define RPL_MASK     3</span>
02027 <span class="preprocessor"></span>
02028 <span class="comment">//</span>
02029 <span class="comment">// SEGMENT_MASK is used to throw away trash part of segment.  Part always</span>
02030 <span class="comment">// pushes or pops 32 bits to/from stack, but if it's a segment value,</span>
02031 <span class="comment">// high order 16 bits are trash.</span>
02032 <span class="comment">//</span>
02033 
02034 <span class="preprocessor">#define SEGMENT_MASK    0xffff</span>
02035 <span class="preprocessor"></span>
02036 <span class="keyword">typedef</span> <span class="keyword">struct </span>_LDTINFORMATION {
02037     ULONG <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
02038     ULONG AllocatedSize;
02039     PLDT_ENTRY Ldt;
02040 } LDTINFORMATION, *PLDTINFORMATION;
02041 
02042 <span class="comment">//</span>
02043 <span class="comment">// SetProcessInformation Structure for ProcessSetIoHandlers info class</span>
02044 <span class="comment">//</span>
02045 
02046 <span class="keyword">typedef</span> <span class="keyword">struct </span>_PROCESS_IO_PORT_HANDLER_INFORMATION {
02047     BOOLEAN Install;            <span class="comment">// true if handlers to be installed</span>
02048     ULONG NumEntries;
02049     ULONG Context;
02050     <a class="code" href="../../d2/d3/struct__EMULATOR__ACCESS__ENTRY.html">PEMULATOR_ACCESS_ENTRY</a> EmulatorAccessEntries;
02051 } PROCESS_IO_PORT_HANDLER_INFORMATION, *PPROCESS_IO_PORT_HANDLER_INFORMATION;
02052 
02053 
02054 <span class="comment">//</span>
02055 <span class="comment">// GDT Entry</span>
02056 <span class="comment">//</span>
02057 
02058 <span class="keyword">typedef</span> <span class="keyword">struct </span>_KGDTENTRY {
02059     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>  LimitLow;
02060     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>  BaseLow;
02061     <span class="keyword">union </span>{
02062         <span class="keyword">struct </span>{
02063             UCHAR   BaseMid;
02064             UCHAR   Flags1;     <span class="comment">// Declare as bytes to avoid alignment</span>
02065             UCHAR   Flags2;     <span class="comment">// Problems.</span>
02066             UCHAR   BaseHi;
02067         } Bytes;
02068         <span class="keyword">struct </span>{
02069             ULONG   BaseMid : 8;
02070             ULONG   Type : 5;
02071             ULONG   Dpl : 2;
02072             ULONG   Pres : 1;
02073             ULONG   LimitHi : 4;
02074             ULONG   Sys : 1;
02075             ULONG   Reserved_0 : 1;
02076             ULONG   Default_Big : 1;
02077             ULONG   Granularity : 1;
02078             ULONG   BaseHi : 8;
02079         } Bits;
02080     } HighWord;
02081 } KGDTENTRY, *PKGDTENTRY;
02082 
02083 <span class="preprocessor">#define TYPE_TSS    0x01  // 01001 = NonBusy TSS</span>
02084 <span class="preprocessor"></span><span class="preprocessor">#define TYPE_LDT    0x02  // 00010 = LDT</span>
02085 <span class="preprocessor"></span>
02086 <span class="comment">//</span>
02087 <span class="comment">// UnScrambled Descriptor format</span>
02088 <span class="comment">//</span>
02089 <span class="keyword">typedef</span> <span class="keyword">struct </span>_KDESCRIPTOR_UNSCRAM {
02090     <span class="keyword">union </span>{
02091         ULONGLONG  DescriptorWords;
02092         <span class="keyword">struct </span>{
02093             ULONGLONG   Base : 32;
02094             ULONGLONG   Limit : 20;
02095             ULONGLONG   Type : 5;
02096             ULONGLONG   Dpl : 2;
02097             ULONGLONG   Pres : 1;
02098             ULONGLONG   Sys : 1;
02099             ULONGLONG   Reserved_0 : 1;
02100             ULONGLONG   Default_Big : 1;
02101             ULONGLONG   Granularity : 1;
02102          } Bits;
02103     } Words;
02104 } KXDESCRIPTOR, *PKXDESCRIPTOR;
02105 
02106 <span class="preprocessor">#define TYPE_CODE_USER                0x1A // 0x11011 = Code, Readable, Accessed</span>
02107 <span class="preprocessor"></span><span class="preprocessor">#define TYPE_DATA_USER                0x13 // 0x10011 = Data, ReadWrite, Accessed</span>
02108 <span class="preprocessor"></span>
02109 <span class="preprocessor">#define DESCRIPTOR_EXPAND_DOWN        0x14</span>
02110 <span class="preprocessor"></span><span class="preprocessor">#define DESCRIPTOR_DATA_READWRITE     (0x8|0x2) // Data, Read/Write</span>
02111 <span class="preprocessor"></span>
02112 <span class="preprocessor">#define DPL_USER    3</span>
02113 <span class="preprocessor"></span><span class="preprocessor">#define DPL_SYSTEM  0</span>
02114 <span class="preprocessor"></span>
02115 <span class="preprocessor">#define GRAN_BYTE   0</span>
02116 <span class="preprocessor"></span><span class="preprocessor">#define GRAN_PAGE   1</span>
02117 <span class="preprocessor"></span>
02118 <span class="preprocessor">#define SELECTOR_TABLE_INDEX 0x04</span>
02119 <span class="preprocessor"></span>
02120 <span class="comment">//</span>
02121 <span class="comment">// Entry of Interrupt Descriptor Table (IDTENTRY)</span>
02122 <span class="comment">//</span>
02123 
02124 <span class="keyword">typedef</span> <span class="keyword">struct </span>_KIDTENTRY {
02125    <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>;
02126    <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> Selector;
02127    <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> Access;
02128    <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> ExtendedOffset;
02129 } KIDTENTRY;
02130 
02131 <span class="keyword">typedef</span> KIDTENTRY *PKIDTENTRY;
02132 
02133 
02134 <span class="comment">//</span>
02135 <span class="comment">// User mode, then</span>
02136 <span class="comment">//      let caller specify Carry, Parity, AuxCarry, Zero, Sign, Trap,</span>
02137 <span class="comment">//      Direction, Overflow, AlignCheck.</span>
02138 <span class="comment">//      force Interrupts on.</span>
02139 <span class="comment">//</span>
02140 
02141 <span class="preprocessor">#define EFLAGS_DF_MASK        0x00000400L</span>
02142 <span class="preprocessor"></span><span class="preprocessor">#define EFLAGS_INTERRUPT_MASK 0x00000200L</span>
02143 <span class="preprocessor"></span><span class="preprocessor">#define EFLAGS_V86_MASK       0x00020000L</span>
02144 <span class="preprocessor"></span><span class="preprocessor">#define EFLAGS_ALIGN_CHECK    0x00040000L</span>
02145 <span class="preprocessor"></span><span class="preprocessor">#define EFLAGS_IOPL_MASK      0x00003000L</span>
02146 <span class="preprocessor"></span><span class="preprocessor">#define EFLAGS_VIF            0x00080000L</span>
02147 <span class="preprocessor"></span><span class="preprocessor">#define EFLAGS_VIP            0x00100000L</span>
02148 <span class="preprocessor"></span><span class="preprocessor">#define EFLAGS_USER_SANITIZE  0x003e0dd7L</span>
02149 <span class="preprocessor"></span>
02150 <span class="preprocessor">#define SANITIZE_FLAGS(eFlags, mode) (\</span>
02151 <span class="preprocessor">    ((mode) == KernelMode ? \</span>
02152 <span class="preprocessor">        ((0x00000000L) | ((eFlags) &amp; 0x003e0fd7)) : \</span>
02153 <span class="preprocessor">        ((EFLAGS_INTERRUPT_MASK) | ((eFlags) &amp; EFLAGS_USER_SANITIZE))))</span>
02154 <span class="preprocessor"></span>
02155 <span class="comment">//</span>
02156 <span class="comment">// Definitions that used by CSD and SSD</span>
02157 <span class="comment">//</span>
02158 <span class="preprocessor">#define USER_CODE_DESCRIPTOR  0xCFBFFFFF00000000i64</span>
02159 <span class="preprocessor"></span><span class="preprocessor">#define USER_DATA_DESCRIPTOR  0xCF3FFFFF00000000i64</span>
02160 <span class="preprocessor"></span>
02161 <span class="comment">//</span>
02162 <span class="comment">// Macros for Emulx86.c and VDM files</span>
02163 <span class="comment">//</span>
02164 <span class="comment">//</span>
02165 <span class="comment">// Prefix Flags</span>
02166 <span class="comment">//</span>
02167 <span class="comment">// Copied from .../ntos/vdm/i386/vdm.inc</span>
02168 <span class="comment">// The bottom byte originally corresponded to the number of prefixes seen</span>
02169 <span class="comment">// which is effectively the length of the instruction...</span>
02170 <span class="comment">//</span>
02171 <span class="preprocessor">#define PREFIX_ES               0x00000100</span>
02172 <span class="preprocessor"></span><span class="preprocessor">#define PREFIX_CS               0x00000200</span>
02173 <span class="preprocessor"></span><span class="preprocessor">#define PREFIX_SS               0x00000400</span>
02174 <span class="preprocessor"></span><span class="preprocessor">#define PREFIX_DS               0x00000800</span>
02175 <span class="preprocessor"></span><span class="preprocessor">#define PREFIX_FS               0x00001000</span>
02176 <span class="preprocessor"></span><span class="preprocessor">#define PREFIX_GS               0x00002000</span>
02177 <span class="preprocessor"></span><span class="preprocessor">#define PREFIX_OPER32           0x00004000</span>
02178 <span class="preprocessor"></span><span class="preprocessor">#define PREFIX_ADDR32           0x00008000</span>
02179 <span class="preprocessor"></span><span class="preprocessor">#define PREFIX_LOCK             0x00010000</span>
02180 <span class="preprocessor"></span><span class="preprocessor">#define PREFIX_REPNE            0x00020000</span>
02181 <span class="preprocessor"></span><span class="preprocessor">#define PREFIX_REP              0x00040000</span>
02182 <span class="preprocessor"></span><span class="preprocessor">#define PREFIX_SEG_ALL          0x00003f00</span>
02183 <span class="preprocessor"></span>
02184 
02185 <span class="comment">//</span>
02186 <span class="comment">// Masks for Dr7 and sanitize macros for various Dr registers.</span>
02187 <span class="comment">//</span>
02188 
02189 <span class="preprocessor">#define DR6_LEGAL   0x0000e00f</span>
02190 <span class="preprocessor"></span>
02191 <span class="preprocessor">#define DR7_LEGAL   0xffff0155  // R/W, LEN for Dr0-Dr4,</span>
02192 <span class="preprocessor"></span>                                <span class="comment">// Local enable for Dr0-Dr4,</span>
02193                                 <span class="comment">// Le for "perfect" trapping</span>
02194 
02195 <span class="preprocessor">#define DR7_ACTIVE  0x00000055  // If any of these bits are set, a Dr is active</span>
02196 <span class="preprocessor"></span>
02197 <span class="preprocessor">#define SANITIZE_DR6(Dr6, mode) ((Dr6 &amp; DR6_LEGAL));</span>
02198 <span class="preprocessor"></span>
02199 <span class="preprocessor">#define SANITIZE_DR7(Dr7, mode) ((Dr7 &amp; DR7_LEGAL));</span>
02200 <span class="preprocessor"></span>
02201 <span class="preprocessor">#define SANITIZE_DRADDR(DrReg, mode) (          \</span>
02202 <span class="preprocessor">    (mode) == KernelMode ?                      \</span>
02203 <span class="preprocessor">        (DrReg) :                               \</span>
02204 <span class="preprocessor">        (((PVOID)DrReg &lt;= MM_HIGHEST_USER_ADDRESS) ?   \</span>
02205 <span class="preprocessor">            (DrReg) :                           \</span>
02206 <span class="preprocessor">            (0)                                 \</span>
02207 <span class="preprocessor">        )                                       \</span>
02208 <span class="preprocessor">    )</span>
02209 <span class="preprocessor"></span>
02210 <span class="comment">// begin_windbgkd</span>
02211 
02212 <span class="preprocessor">#ifdef _IA64_</span>
02213 <span class="preprocessor"></span>
02214 <span class="comment">// begin_nthal</span>
02215 
02216 <span class="comment">//</span>
02217 <span class="comment">// Stack Registers for IA64</span>
02218 <span class="comment">//</span>
02219 
02220 <span class="keyword">typedef</span> <span class="keyword">struct </span>_STACK_REGISTERS {
02221 
02222 <span class="comment">// Please contact INTEL to get IA64-specific information</span>
02223 <span class="comment">// @@BEGIN_DDKSPLIT</span>
02224 
02225     ULONGLONG IntR32;       <span class="comment">// Intel-IA64-Filler</span>
02226     ULONGLONG IntR33;       <span class="comment">// Intel-IA64-Filler</span>
02227     ULONGLONG IntR34;       <span class="comment">// Intel-IA64-Filler</span>
02228     ULONGLONG IntR35;       <span class="comment">// Intel-IA64-Filler</span>
02229     ULONGLONG IntR36;       <span class="comment">// Intel-IA64-Filler</span>
02230     ULONGLONG IntR37;       <span class="comment">// Intel-IA64-Filler</span>
02231     ULONGLONG IntR38;       <span class="comment">// Intel-IA64-Filler</span>
02232     ULONGLONG IntR39;       <span class="comment">// Intel-IA64-Filler</span>
02233 
02234     ULONGLONG IntR40;       <span class="comment">// Intel-IA64-Filler</span>
02235     ULONGLONG IntR41;       <span class="comment">// Intel-IA64-Filler</span>
02236     ULONGLONG IntR42;       <span class="comment">// Intel-IA64-Filler</span>
02237     ULONGLONG IntR43;       <span class="comment">// Intel-IA64-Filler</span>
02238     ULONGLONG IntR44;       <span class="comment">// Intel-IA64-Filler</span>
02239     ULONGLONG IntR45;       <span class="comment">// Intel-IA64-Filler</span>
02240     ULONGLONG IntR46;       <span class="comment">// Intel-IA64-Filler</span>
02241     ULONGLONG IntR47;       <span class="comment">// Intel-IA64-Filler</span>
02242     ULONGLONG IntR48;       <span class="comment">// Intel-IA64-Filler</span>
02243     ULONGLONG IntR49;       <span class="comment">// Intel-IA64-Filler</span>
02244 
02245     ULONGLONG IntR50;       <span class="comment">// Intel-IA64-Filler</span>
02246     ULONGLONG IntR51;       <span class="comment">// Intel-IA64-Filler</span>
02247     ULONGLONG IntR52;       <span class="comment">// Intel-IA64-Filler</span>
02248     ULONGLONG IntR53;       <span class="comment">// Intel-IA64-Filler</span>
02249     ULONGLONG IntR54;       <span class="comment">// Intel-IA64-Filler</span>
02250     ULONGLONG IntR55;       <span class="comment">// Intel-IA64-Filler</span>
02251     ULONGLONG IntR56;       <span class="comment">// Intel-IA64-Filler</span>
02252     ULONGLONG IntR57;       <span class="comment">// Intel-IA64-Filler</span>
02253     ULONGLONG IntR58;       <span class="comment">// Intel-IA64-Filler</span>
02254     ULONGLONG IntR59;       <span class="comment">// Intel-IA64-Filler</span>
02255 
02256     ULONGLONG IntR60;       <span class="comment">// Intel-IA64-Filler</span>
02257     ULONGLONG IntR61;       <span class="comment">// Intel-IA64-Filler</span>
02258     ULONGLONG IntR62;       <span class="comment">// Intel-IA64-Filler</span>
02259     ULONGLONG IntR63;       <span class="comment">// Intel-IA64-Filler</span>
02260     ULONGLONG IntR64;       <span class="comment">// Intel-IA64-Filler</span>
02261     ULONGLONG IntR65;       <span class="comment">// Intel-IA64-Filler</span>
02262     ULONGLONG IntR66;       <span class="comment">// Intel-IA64-Filler</span>
02263     ULONGLONG IntR67;       <span class="comment">// Intel-IA64-Filler</span>
02264     ULONGLONG IntR68;       <span class="comment">// Intel-IA64-Filler</span>
02265     ULONGLONG IntR69;       <span class="comment">// Intel-IA64-Filler</span>
02266 
02267     ULONGLONG IntR70;       <span class="comment">// Intel-IA64-Filler</span>
02268     ULONGLONG IntR71;       <span class="comment">// Intel-IA64-Filler</span>
02269     ULONGLONG IntR72;       <span class="comment">// Intel-IA64-Filler</span>
02270     ULONGLONG IntR73;       <span class="comment">// Intel-IA64-Filler</span>
02271     ULONGLONG IntR74;       <span class="comment">// Intel-IA64-Filler</span>
02272     ULONGLONG IntR75;       <span class="comment">// Intel-IA64-Filler</span>
02273     ULONGLONG IntR76;       <span class="comment">// Intel-IA64-Filler</span>
02274     ULONGLONG IntR77;       <span class="comment">// Intel-IA64-Filler</span>
02275     ULONGLONG IntR78;       <span class="comment">// Intel-IA64-Filler</span>
02276     ULONGLONG IntR79;       <span class="comment">// Intel-IA64-Filler</span>
02277 
02278     ULONGLONG IntR80;       <span class="comment">// Intel-IA64-Filler</span>
02279     ULONGLONG IntR81;       <span class="comment">// Intel-IA64-Filler</span>
02280     ULONGLONG IntR82;       <span class="comment">// Intel-IA64-Filler</span>
02281     ULONGLONG IntR83;       <span class="comment">// Intel-IA64-Filler</span>
02282     ULONGLONG IntR84;       <span class="comment">// Intel-IA64-Filler</span>
02283     ULONGLONG IntR85;       <span class="comment">// Intel-IA64-Filler</span>
02284     ULONGLONG IntR86;       <span class="comment">// Intel-IA64-Filler</span>
02285     ULONGLONG IntR87;       <span class="comment">// Intel-IA64-Filler</span>
02286     ULONGLONG IntR88;       <span class="comment">// Intel-IA64-Filler</span>
02287     ULONGLONG IntR89;       <span class="comment">// Intel-IA64-Filler</span>
02288 
02289     ULONGLONG IntR90;       <span class="comment">// Intel-IA64-Filler</span>
02290     ULONGLONG IntR91;       <span class="comment">// Intel-IA64-Filler</span>
02291     ULONGLONG IntR92;       <span class="comment">// Intel-IA64-Filler</span>
02292     ULONGLONG IntR93;       <span class="comment">// Intel-IA64-Filler</span>
02293     ULONGLONG IntR94;       <span class="comment">// Intel-IA64-Filler</span>
02294     ULONGLONG IntR95;       <span class="comment">// Intel-IA64-Filler</span>
02295     ULONGLONG IntR96;       <span class="comment">// Intel-IA64-Filler</span>
02296     ULONGLONG IntR97;       <span class="comment">// Intel-IA64-Filler</span>
02297     ULONGLONG IntR98;       <span class="comment">// Intel-IA64-Filler</span>
02298     ULONGLONG IntR99;       <span class="comment">// Intel-IA64-Filler</span>
02299 
02300     ULONGLONG IntR100;       <span class="comment">// Intel-IA64-Filler</span>
02301     ULONGLONG IntR101;       <span class="comment">// Intel-IA64-Filler</span>
02302     ULONGLONG IntR102;       <span class="comment">// Intel-IA64-Filler</span>
02303     ULONGLONG IntR103;       <span class="comment">// Intel-IA64-Filler</span>
02304     ULONGLONG IntR104;       <span class="comment">// Intel-IA64-Filler</span>
02305     ULONGLONG IntR105;       <span class="comment">// Intel-IA64-Filler</span>
02306     ULONGLONG IntR106;       <span class="comment">// Intel-IA64-Filler</span>
02307     ULONGLONG IntR107;       <span class="comment">// Intel-IA64-Filler</span>
02308     ULONGLONG IntR108;       <span class="comment">// Intel-IA64-Filler</span>
02309     ULONGLONG IntR109;       <span class="comment">// Intel-IA64-Filler</span>
02310 
02311     ULONGLONG IntR110;       <span class="comment">// Intel-IA64-Filler</span>
02312     ULONGLONG IntR111;       <span class="comment">// Intel-IA64-Filler</span>
02313     ULONGLONG IntR112;       <span class="comment">// Intel-IA64-Filler</span>
02314     ULONGLONG IntR113;       <span class="comment">// Intel-IA64-Filler</span>
02315     ULONGLONG IntR114;       <span class="comment">// Intel-IA64-Filler</span>
02316     ULONGLONG IntR115;       <span class="comment">// Intel-IA64-Filler</span>
02317     ULONGLONG IntR116;       <span class="comment">// Intel-IA64-Filler</span>
02318     ULONGLONG IntR117;       <span class="comment">// Intel-IA64-Filler</span>
02319     ULONGLONG IntR118;       <span class="comment">// Intel-IA64-Filler</span>
02320     ULONGLONG IntR119;       <span class="comment">// Intel-IA64-Filler</span>
02321 
02322     ULONGLONG IntR120;       <span class="comment">// Intel-IA64-Filler</span>
02323     ULONGLONG IntR121;       <span class="comment">// Intel-IA64-Filler</span>
02324     ULONGLONG IntR122;       <span class="comment">// Intel-IA64-Filler</span>
02325     ULONGLONG IntR123;       <span class="comment">// Intel-IA64-Filler</span>
02326     ULONGLONG IntR124;       <span class="comment">// Intel-IA64-Filler</span>
02327     ULONGLONG IntR125;       <span class="comment">// Intel-IA64-Filler</span>
02328     ULONGLONG IntR126;       <span class="comment">// Intel-IA64-Filler</span>
02329     ULONGLONG IntR127;       <span class="comment">// Intel-IA64-Filler</span>
02330                                  <span class="comment">// Nat bits for stack registers       // Intel-IA64-Filler</span>
02331     ULONGLONG IntNats2;          <span class="comment">// r32-r95 in bit positions 1 to 63       // Intel-IA64-Filler</span>
02332     ULONGLONG IntNats3;          <span class="comment">// r96-r127 in bit position 1 to 31       // Intel-IA64-Filler</span>
02333 
02334 <span class="comment">// @@END_DDKSPLIT</span>
02335 
02336 } STACK_REGISTERS, *PSTACK_REGISTERS;
02337 
02338 
02339 <span class="comment">// Please contact INTEL to get IA64-specific information</span>
02340 <span class="comment">// @@BEGIN_DDKSPLIT</span>
02341 
02342 <span class="comment">//</span>
02343 <span class="comment">// Special Registers for IA64  // Intel-IA64-Filler</span>
02344 <span class="comment">//</span>
02345 
02346 <span class="keyword">typedef</span> <span class="keyword">struct </span>_KSPECIAL_REGISTERS {  <span class="comment">// Intel-IA64-Filler</span>
02347 
02348     <span class="comment">// Kernel debug breakpoint registers       // Intel-IA64-Filler</span>
02349 
02350     ULONGLONG KernelDbI0;         <span class="comment">// Instruction debug registers       // Intel-IA64-Filler</span>
02351     ULONGLONG KernelDbI1;       <span class="comment">// Intel-IA64-Filler</span>
02352     ULONGLONG KernelDbI2;       <span class="comment">// Intel-IA64-Filler</span>
02353     ULONGLONG KernelDbI3;       <span class="comment">// Intel-IA64-Filler</span>
02354     ULONGLONG KernelDbI4;       <span class="comment">// Intel-IA64-Filler</span>
02355     ULONGLONG KernelDbI5;       <span class="comment">// Intel-IA64-Filler</span>
02356     ULONGLONG KernelDbI6;       <span class="comment">// Intel-IA64-Filler</span>
02357     ULONGLONG KernelDbI7;       <span class="comment">// Intel-IA64-Filler</span>
02358 
02359     ULONGLONG KernelDbD0;         <span class="comment">// Data debug registers       // Intel-IA64-Filler</span>
02360     ULONGLONG KernelDbD1;       <span class="comment">// Intel-IA64-Filler</span>
02361     ULONGLONG KernelDbD2;       <span class="comment">// Intel-IA64-Filler</span>
02362     ULONGLONG KernelDbD3;       <span class="comment">// Intel-IA64-Filler</span>
02363     ULONGLONG KernelDbD4;       <span class="comment">// Intel-IA64-Filler</span>
02364     ULONGLONG KernelDbD5;       <span class="comment">// Intel-IA64-Filler</span>
02365     ULONGLONG KernelDbD6;       <span class="comment">// Intel-IA64-Filler</span>
02366     ULONGLONG KernelDbD7;       <span class="comment">// Intel-IA64-Filler</span>
02367 
02368     <span class="comment">// Kernel performance monitor registers       // Intel-IA64-Filler</span>
02369 
02370     ULONGLONG KernelPfC0;         <span class="comment">// Performance configuration registers       // Intel-IA64-Filler</span>
02371     ULONGLONG KernelPfC1;       <span class="comment">// Intel-IA64-Filler</span>
02372     ULONGLONG KernelPfC2;       <span class="comment">// Intel-IA64-Filler</span>
02373     ULONGLONG KernelPfC3;       <span class="comment">// Intel-IA64-Filler</span>
02374     ULONGLONG KernelPfC4;       <span class="comment">// Intel-IA64-Filler</span>
02375     ULONGLONG KernelPfC5;       <span class="comment">// Intel-IA64-Filler</span>
02376     ULONGLONG KernelPfC6;       <span class="comment">// Intel-IA64-Filler</span>
02377     ULONGLONG KernelPfC7;       <span class="comment">// Intel-IA64-Filler</span>
02378 
02379     ULONGLONG KernelPfD0;         <span class="comment">// Performance data registers       // Intel-IA64-Filler</span>
02380     ULONGLONG KernelPfD1;       <span class="comment">// Intel-IA64-Filler</span>
02381     ULONGLONG KernelPfD2;       <span class="comment">// Intel-IA64-Filler</span>
02382     ULONGLONG KernelPfD3;       <span class="comment">// Intel-IA64-Filler</span>
02383     ULONGLONG KernelPfD4;       <span class="comment">// Intel-IA64-Filler</span>
02384     ULONGLONG KernelPfD5;       <span class="comment">// Intel-IA64-Filler</span>
02385     ULONGLONG KernelPfD6;       <span class="comment">// Intel-IA64-Filler</span>
02386     ULONGLONG KernelPfD7;       <span class="comment">// Intel-IA64-Filler</span>
02387 
02388     <span class="comment">// kernel bank shadow (hidden) registers       // Intel-IA64-Filler</span>
02389 
02390     ULONGLONG IntH16;       <span class="comment">// Intel-IA64-Filler</span>
02391     ULONGLONG IntH17;       <span class="comment">// Intel-IA64-Filler</span>
02392     ULONGLONG IntH18;       <span class="comment">// Intel-IA64-Filler</span>
02393     ULONGLONG IntH19;       <span class="comment">// Intel-IA64-Filler</span>
02394     ULONGLONG IntH20;       <span class="comment">// Intel-IA64-Filler</span>
02395     ULONGLONG IntH21;       <span class="comment">// Intel-IA64-Filler</span>
02396     ULONGLONG IntH22;       <span class="comment">// Intel-IA64-Filler</span>
02397     ULONGLONG IntH23;       <span class="comment">// Intel-IA64-Filler</span>
02398     ULONGLONG IntH24;       <span class="comment">// Intel-IA64-Filler</span>
02399     ULONGLONG IntH25;       <span class="comment">// Intel-IA64-Filler</span>
02400     ULONGLONG IntH26;       <span class="comment">// Intel-IA64-Filler</span>
02401     ULONGLONG IntH27;       <span class="comment">// Intel-IA64-Filler</span>
02402     ULONGLONG IntH28;       <span class="comment">// Intel-IA64-Filler</span>
02403     ULONGLONG IntH29;       <span class="comment">// Intel-IA64-Filler</span>
02404     ULONGLONG IntH30;       <span class="comment">// Intel-IA64-Filler</span>
02405     ULONGLONG IntH31;       <span class="comment">// Intel-IA64-Filler</span>
02406 
02407     <span class="comment">// Application Registers       // Intel-IA64-Filler</span>
02408 
02409     <span class="comment">//       - CPUID Registers - AR       // Intel-IA64-Filler</span>
02410     ULONGLONG ApCPUID0; <span class="comment">// Cpuid Register 0       // Intel-IA64-Filler</span>
02411     ULONGLONG ApCPUID1; <span class="comment">// Cpuid Register 1       // Intel-IA64-Filler</span>
02412     ULONGLONG ApCPUID2; <span class="comment">// Cpuid Register 2       // Intel-IA64-Filler</span>
02413     ULONGLONG ApCPUID3; <span class="comment">// Cpuid Register 3       // Intel-IA64-Filler</span>
02414     ULONGLONG ApCPUID4; <span class="comment">// Cpuid Register 4       // Intel-IA64-Filler</span>
02415     ULONGLONG ApCPUID5; <span class="comment">// Cpuid Register 5       // Intel-IA64-Filler</span>
02416     ULONGLONG ApCPUID6; <span class="comment">// Cpuid Register 6       // Intel-IA64-Filler</span>
02417     ULONGLONG ApCPUID7; <span class="comment">// Cpuid Register 7       // Intel-IA64-Filler</span>
02418 
02419     <span class="comment">//       - Kernel Registers - AR       // Intel-IA64-Filler</span>
02420     ULONGLONG ApKR0;    <span class="comment">// Kernel Register 0 (User RO)       // Intel-IA64-Filler</span>
02421     ULONGLONG ApKR1;    <span class="comment">// Kernel Register 1 (User RO)       // Intel-IA64-Filler</span>
02422     ULONGLONG ApKR2;    <span class="comment">// Kernel Register 2 (User RO)       // Intel-IA64-Filler</span>
02423     ULONGLONG ApKR3;    <span class="comment">// Kernel Register 3 (User RO)       // Intel-IA64-Filler</span>
02424     ULONGLONG ApKR4;    <span class="comment">// Kernel Register 4       // Intel-IA64-Filler</span>
02425     ULONGLONG ApKR5;    <span class="comment">// Kernel Register 5       // Intel-IA64-Filler</span>
02426     ULONGLONG ApKR6;    <span class="comment">// Kernel Register 6       // Intel-IA64-Filler</span>
02427     ULONGLONG ApKR7;    <span class="comment">// Kernel Register 7       // Intel-IA64-Filler</span>
02428 
02429     ULONGLONG ApITC;    <span class="comment">// Interval Timer Counter       // Intel-IA64-Filler</span>
02430 
02431     <span class="comment">// Global control registers       // Intel-IA64-Filler</span>
02432 
02433     ULONGLONG ApITM;    <span class="comment">// Interval Timer Match register       // Intel-IA64-Filler</span>
02434     ULONGLONG ApIVA;    <span class="comment">// Interrupt Vector Address       // Intel-IA64-Filler</span>
02435     ULONGLONG ApPTA;    <span class="comment">// Page Table Address       // Intel-IA64-Filler</span>
02436     ULONGLONG ApGPTA;   <span class="comment">// ia32 Page Table Address       // Intel-IA64-Filler</span>
02437 
02438     ULONGLONG StISR;    <span class="comment">// Interrupt status       // Intel-IA64-Filler</span>
02439     ULONGLONG StIFA;    <span class="comment">// Interruption Faulting Address       // Intel-IA64-Filler</span>
02440     ULONGLONG StITIR;   <span class="comment">// Interruption TLB Insertion Register       // Intel-IA64-Filler</span>
02441     ULONGLONG StIIPA;   <span class="comment">// Interruption Instruction Previous Address (RO)       // Intel-IA64-Filler</span>
02442     ULONGLONG StIIM;    <span class="comment">// Interruption Immediate register (RO)       // Intel-IA64-Filler</span>
02443     ULONGLONG StIHA;    <span class="comment">// Interruption Hash Address (RO)       // Intel-IA64-Filler</span>
02444 
02445     <span class="comment">//       - External Interrupt control registers (SAPIC)       // Intel-IA64-Filler</span>
02446     ULONGLONG SaLID;    <span class="comment">// Local SAPIC ID       // Intel-IA64-Filler</span>
02447     ULONGLONG SaIVR;    <span class="comment">// Interrupt Vector Register (RO)       // Intel-IA64-Filler</span>
02448     ULONGLONG SaTPR;    <span class="comment">// Task Priority Register       // Intel-IA64-Filler</span>
02449     ULONGLONG SaEOI;    <span class="comment">// End Of Interrupt       // Intel-IA64-Filler</span>
02450     ULONGLONG SaIRR0;   <span class="comment">// Interrupt Request Register 0 (RO)       // Intel-IA64-Filler</span>
02451     ULONGLONG SaIRR1;   <span class="comment">// Interrupt Request Register 1 (RO)       // Intel-IA64-Filler</span>
02452     ULONGLONG SaIRR2;   <span class="comment">// Interrupt Request Register 2 (RO)       // Intel-IA64-Filler</span>
02453     ULONGLONG SaIRR3;   <span class="comment">// Interrupt Request Register 3 (RO)       // Intel-IA64-Filler</span>
02454     ULONGLONG SaITV;    <span class="comment">// Interrupt Timer Vector       // Intel-IA64-Filler</span>
02455     ULONGLONG SaPMV;    <span class="comment">// Performance Monitor Vector       // Intel-IA64-Filler</span>
02456     ULONGLONG SaCMCV;   <span class="comment">// Corrected Machine Check Vector       // Intel-IA64-Filler</span>
02457     ULONGLONG SaLRR0;   <span class="comment">// Local Interrupt Redirection Vector 0       // Intel-IA64-Filler</span>
02458     ULONGLONG SaLRR1;   <span class="comment">// Local Interrupt Redirection Vector 1       // Intel-IA64-Filler</span>
02459 
02460     <span class="comment">// System Registers       // Intel-IA64-Filler</span>
02461     <span class="comment">//       - Region registers       // Intel-IA64-Filler</span>
02462     ULONGLONG Rr0;  <span class="comment">// Region register 0       // Intel-IA64-Filler</span>
02463     ULONGLONG Rr1;  <span class="comment">// Region register 1       // Intel-IA64-Filler</span>
02464     ULONGLONG Rr2;  <span class="comment">// Region register 2       // Intel-IA64-Filler</span>
02465     ULONGLONG Rr3;  <span class="comment">// Region register 3       // Intel-IA64-Filler</span>
02466     ULONGLONG Rr4;  <span class="comment">// Region register 4       // Intel-IA64-Filler</span>
02467     ULONGLONG Rr5;  <span class="comment">// Region register 5       // Intel-IA64-Filler</span>
02468     ULONGLONG Rr6;  <span class="comment">// Region register 6       // Intel-IA64-Filler</span>
02469     ULONGLONG Rr7;  <span class="comment">// Region register 7       // Intel-IA64-Filler</span>
02470 
02471     <span class="comment">//      - Protection Key registers  // Intel-IA64-Filler</span>
02472     ULONGLONG Pkr0;     <span class="comment">// Protection Key register 0  // Intel-IA64-Filler</span>
02473     ULONGLONG Pkr1;     <span class="comment">// Protection Key register 1  // Intel-IA64-Filler</span>
02474     ULONGLONG Pkr2;     <span class="comment">// Protection Key register 2  // Intel-IA64-Filler</span>
02475     ULONGLONG Pkr3;     <span class="comment">// Protection Key register 3  // Intel-IA64-Filler</span>
02476     ULONGLONG Pkr4;     <span class="comment">// Protection Key register 4  // Intel-IA64-Filler</span>
02477     ULONGLONG Pkr5;     <span class="comment">// Protection Key register 5  // Intel-IA64-Filler</span>
02478     ULONGLONG Pkr6;     <span class="comment">// Protection Key register 6  // Intel-IA64-Filler</span>
02479     ULONGLONG Pkr7;     <span class="comment">// Protection Key register 7  // Intel-IA64-Filler</span>
02480     ULONGLONG Pkr8;     <span class="comment">// Protection Key register 8  // Intel-IA64-Filler</span>
02481     ULONGLONG Pkr9;     <span class="comment">// Protection Key register 9  // Intel-IA64-Filler</span>
02482     ULONGLONG Pkr10;    <span class="comment">// Protection Key register 10  // Intel-IA64-Filler</span>
02483     ULONGLONG Pkr11;    <span class="comment">// Protection Key register 11  // Intel-IA64-Filler</span>
02484     ULONGLONG Pkr12;    <span class="comment">// Protection Key register 12  // Intel-IA64-Filler</span>
02485     ULONGLONG Pkr13;    <span class="comment">// Protection Key register 13  // Intel-IA64-Filler</span>
02486     ULONGLONG Pkr14;    <span class="comment">// Protection Key register 14  // Intel-IA64-Filler</span>
02487     ULONGLONG Pkr15;    <span class="comment">// Protection Key register 15  // Intel-IA64-Filler</span>
02488 
02489     <span class="comment">//      -  Translation Lookaside buffers  // Intel-IA64-Filler</span>
02490     ULONGLONG TrI0;     <span class="comment">// Instruction Translation Register 0  // Intel-IA64-Filler</span>
02491     ULONGLONG TrI1;     <span class="comment">// Instruction Translation Register 1  // Intel-IA64-Filler</span>
02492     ULONGLONG TrI2;     <span class="comment">// Instruction Translation Register 2  // Intel-IA64-Filler</span>
02493     ULONGLONG TrI3;     <span class="comment">// Instruction Translation Register 3  // Intel-IA64-Filler</span>
02494     ULONGLONG TrI4;     <span class="comment">// Instruction Translation Register 4  // Intel-IA64-Filler</span>
02495     ULONGLONG TrI5;     <span class="comment">// Instruction Translation Register 5  // Intel-IA64-Filler</span>
02496     ULONGLONG TrI6;     <span class="comment">// Instruction Translation Register 6  // Intel-IA64-Filler</span>
02497     ULONGLONG TrI7;     <span class="comment">// Instruction Translation Register 7  // Intel-IA64-Filler</span>
02498 
02499     ULONGLONG TrD0;     <span class="comment">// Data Translation Register 0  // Intel-IA64-Filler</span>
02500     ULONGLONG TrD1;     <span class="comment">// Data Translation Register 1  // Intel-IA64-Filler</span>
02501     ULONGLONG TrD2;     <span class="comment">// Data Translation Register 2  // Intel-IA64-Filler</span>
02502     ULONGLONG TrD3;     <span class="comment">// Data Translation Register 3  // Intel-IA64-Filler</span>
02503     ULONGLONG TrD4;     <span class="comment">// Data Translation Register 4  // Intel-IA64-Filler</span>
02504     ULONGLONG TrD5;     <span class="comment">// Data Translation Register 5  // Intel-IA64-Filler</span>
02505     ULONGLONG TrD6;     <span class="comment">// Data Translation Register 6  // Intel-IA64-Filler</span>
02506     ULONGLONG TrD7;     <span class="comment">// Data Translation Register 7  // Intel-IA64-Filler</span>
02507 
02508     <span class="comment">//      -  Machine Specific Registers  // Intel-IA64-Filler</span>
02509     ULONGLONG SrMSR0;   <span class="comment">// Machine Specific Register 0  // Intel-IA64-Filler</span>
02510     ULONGLONG SrMSR1;   <span class="comment">// Machine Specific Register 1  // Intel-IA64-Filler</span>
02511     ULONGLONG SrMSR2;   <span class="comment">// Machine Specific Register 2  // Intel-IA64-Filler</span>
02512     ULONGLONG SrMSR3;   <span class="comment">// Machine Specific Register 3  // Intel-IA64-Filler</span>
02513     ULONGLONG SrMSR4;   <span class="comment">// Machine Specific Register 4  // Intel-IA64-Filler</span>
02514     ULONGLONG SrMSR5;   <span class="comment">// Machine Specific Register 5  // Intel-IA64-Filler</span>
02515     ULONGLONG SrMSR6;   <span class="comment">// Machine Specific Register 6  // Intel-IA64-Filler</span>
02516     ULONGLONG SrMSR7;   <span class="comment">// Machine Specific Register 7  // Intel-IA64-Filler</span>
02517 
02518 } KSPECIAL_REGISTERS, *PKSPECIAL_REGISTERS;  <span class="comment">// Intel-IA64-Filler</span>
02519 
02520 
02521 <span class="comment">//</span>
02522 <span class="comment">// Processor State structure.</span>
02523 <span class="comment">//</span>
02524 
02525 <span class="keyword">typedef</span> <span class="keyword">struct </span>_KPROCESSOR_STATE {  <span class="comment">// Intel-IA64-Filler</span>
02526     <span class="keyword">struct </span>_CONTEXT ContextFrame;  <span class="comment">// Intel-IA64-Filler</span>
02527     <span class="keyword">struct </span>_KSPECIAL_REGISTERS SpecialRegisters;  <span class="comment">// Intel-IA64-Filler</span>
02528 } KPROCESSOR_STATE, *PKPROCESSOR_STATE;  <span class="comment">// Intel-IA64-Filler</span>
02529 
02530 <span class="comment">// @@END_DDKSPLIT</span>
02531 
02532 <span class="comment">// end_nthal</span>
02533 
02534 <span class="preprocessor">#endif // _IA64_</span>
02535 <span class="preprocessor"></span>
02536 <span class="comment">// end_windbgkd</span>
02537 
02538 <span class="comment">// begin_nthal begin_ntddk</span>
02539 
02540 <span class="comment">//</span>
02541 <span class="comment">// Processor Control Block (PRCB)</span>
02542 <span class="comment">//</span>
02543 
02544 <span class="preprocessor">#define PRCB_MINOR_VERSION 1</span>
02545 <span class="preprocessor"></span><span class="preprocessor">#define PRCB_MAJOR_VERSION 1</span>
02546 <span class="preprocessor"></span><span class="preprocessor">#define PRCB_BUILD_DEBUG        0x0001</span>
02547 <span class="preprocessor"></span><span class="preprocessor">#define PRCB_BUILD_UNIPROCESSOR 0x0002</span>
02548 <span class="preprocessor"></span>
02549 <span class="keyword">struct </span><a class="code" href="../../d5/d4/struct__RESTART__BLOCK.html">_RESTART_BLOCK</a>;
02550 
02551 <span class="keyword">typedef</span> <span class="keyword">struct </span>_KPRCB {
02552 
02553 <span class="comment">//</span>
02554 <span class="comment">// Major and minor version numbers of the PCR.</span>
02555 <span class="comment">//</span>
02556 
02557     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> MinorVersion;
02558     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> MajorVersion;
02559 
02560 <span class="comment">//</span>
02561 <span class="comment">// Start of the architecturally defined section of the PRCB. This section</span>
02562 <span class="comment">// may be directly addressed by vendor/platform specific HAL code and will</span>
02563 <span class="comment">// not change from version to version of NT.</span>
02564 <span class="comment">//</span>
02565 <span class="comment">//</span>
02566 
02567     <span class="keyword">struct </span><a class="code" href="../../d1/d8/struct__KTHREAD.html">_KTHREAD</a> *CurrentThread;
02568     <span class="keyword">struct </span><a class="code" href="../../d1/d8/struct__KTHREAD.html">_KTHREAD</a> *RESTRICTED_POINTER NextThread;
02569     <span class="keyword">struct </span><a class="code" href="../../d1/d8/struct__KTHREAD.html">_KTHREAD</a> *IdleThread;
02570     CCHAR Number;
02571     CCHAR Reserved;
02572     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> BuildType;
02573     KAFFINITY <a class="code" href="../../d0/d0/ki_8h.html#a7">SetMember</a>;
02574     <span class="keyword">struct </span><a class="code" href="../../d5/d4/struct__RESTART__BLOCK.html">_RESTART_BLOCK</a> *RestartBlock;
02575     ULONG_PTR PcrPage;
02576     ULONG Spares1[4];
02577 
02578 <span class="comment">//</span>
02579 <span class="comment">// Space reserved for the system.</span>
02580 <span class="comment">//</span>
02581 
02582     ULONGLONG SystemReserved[8];
02583 
02584 <span class="comment">//</span>
02585 <span class="comment">// Space reserved for the HAL.</span>
02586 <span class="comment">//</span>
02587 
02588     ULONGLONG HalReserved[16];
02589 
02590 <span class="comment">//</span>
02591 <span class="comment">// End of the architecturally defined section of the PRCB.</span>
02592 <span class="comment">// end_nthal end_ntddk</span>
02593 <span class="comment">//</span>
02594 
02595     ULONG DpcTime;
02596     ULONG InterruptTime;
02597     ULONG KernelTime;
02598     ULONG UserTime;
02599     ULONG InterruptCount;
02600     ULONG DispatchInterruptCount;
02601     ULONG ApcBypassCount;
02602     ULONG DpcBypassCount;
02603     ULONG Spare0[4];
02604 
02605 <span class="comment">//</span>
02606 <span class="comment">// MP information.</span>
02607 <span class="comment">//</span>
02608 
02609     PVOID Spare1;
02610     PVOID <a class="code" href="../../d4/d9/ke_8h.html#a407a219">Spare2</a>;
02611     PVOID <a class="code" href="../../d4/d9/ke_8h.html#a407a220">Spare3</a>;
02612     <span class="keyword">volatile</span> ULONG IpiFrozen;
02613     <span class="keyword">struct </span>_KPROCESSOR_STATE ProcessorState;
02614 
02615 <span class="comment">//</span>
02616 <span class="comment">//  Per-processor data for various hot code which resides in the</span>
02617 <span class="comment">//  kernel image. Each processor is given it's own copy of the data</span>
02618 <span class="comment">//  to lessen the cache impact of sharing the data between multiple</span>
02619 <span class="comment">//  processors.</span>
02620 <span class="comment">//</span>
02621 
02622 <span class="comment">//</span>
02623 <span class="comment">//  Spares (formerly fsrtl filelock free lists)</span>
02624 <span class="comment">//</span>
02625 
02626     PVOID SpareHotData[2];
02627 
02628 <span class="comment">//</span>
02629 <span class="comment">//  Cache manager performance counters.</span>
02630 <span class="comment">//</span>
02631 
02632     ULONG <a class="code" href="../../d5/d2/cachedat_8c.html#a44">CcFastReadNoWait</a>;
02633     ULONG <a class="code" href="../../d5/d2/cachedat_8c.html#a45">CcFastReadWait</a>;
02634     ULONG <a class="code" href="../../d5/d2/cachedat_8c.html#a47">CcFastReadNotPossible</a>;
02635     ULONG <a class="code" href="../../d5/d2/cachedat_8c.html#a61">CcCopyReadNoWait</a>;
02636     ULONG <a class="code" href="../../d5/d2/cachedat_8c.html#a62">CcCopyReadWait</a>;
02637     ULONG <a class="code" href="../../d5/d2/cachedat_8c.html#a63">CcCopyReadNoWaitMiss</a>;
02638 
02639 <span class="comment">//</span>
02640 <span class="comment">// Kernel performance counters.</span>
02641 <span class="comment">//</span>
02642 
02643     ULONG KeAlignmentFixupCount;
02644     ULONG KeContextSwitches;
02645     ULONG <a class="code" href="../../d5/d9/kernldat_8c.html#a13">KeDcacheFlushCount</a>;
02646     ULONG KeExceptionDispatchCount;
02647     ULONG KeFirstLevelTbFills;
02648     ULONG KeFloatingEmulationCount;
02649     ULONG <a class="code" href="../../d5/d9/kernldat_8c.html#a14">KeIcacheFlushCount</a>;
02650     ULONG KeSecondLevelTbFills;
02651     ULONG KeSystemCalls;
02652 
02653 <span class="comment">//</span>
02654 <span class="comment">//  Reserved for future counters.</span>
02655 <span class="comment">//</span>
02656 
02657     ULONG ReservedCounter[8];
02658 
02659 <span class="comment">//</span>
02660 <span class="comment">// I/O system per processor single entry lookaside lists.</span>
02661 <span class="comment">//</span>
02662 
02663     PVOID SmallIrpFreeEntry;
02664     PVOID LargeIrpFreeEntry;
02665     PVOID MdlFreeEntry;
02666 
02667 <span class="comment">//</span>
02668 <span class="comment">// Object manager per processor single entry lookaside lists.</span>
02669 <span class="comment">//</span>
02670 
02671     PVOID CreateInfoFreeEntry;
02672     PVOID NameBufferFreeEntry;
02673 
02674 <span class="comment">//</span>
02675 <span class="comment">// Cache manager per processor single entry lookaside lists.</span>
02676 <span class="comment">//</span>
02677 
02678     PVOID SharedCacheMapEntry;
02679 
02680 <span class="comment">//</span>
02681 <span class="comment">//  Spares (formerly fsrtl filelock free lists)</span>
02682 <span class="comment">//</span>
02683 
02684     PVOID MoreSpareHotData[2];
02685 
02686 <span class="comment">//</span>
02687 <span class="comment">// Nonpaged per processor lookaside lists.</span>
02688 <span class="comment">//</span>
02689 
02690     <a class="code" href="../../d5/d9/struct__PP__LOOKASIDE__LIST.html">PP_LOOKASIDE_LIST</a> PPLookasideList[16];
02691 
02692 <span class="comment">//</span>
02693 <span class="comment">// Nonpaged per processor small pool lookaside lists.</span>
02694 <span class="comment">//</span>
02695 
02696     <a class="code" href="../../d5/d9/struct__PP__LOOKASIDE__LIST.html">PP_LOOKASIDE_LIST</a> PPNPagedLookasideList[<a class="code" href="../../d0/d9/ntosdef_8h.html#a2">POOL_SMALL_LISTS</a>];
02697 
02698 <span class="comment">//</span>
02699 <span class="comment">// Paged per processor small pool lookaside lists.</span>
02700 <span class="comment">//</span>
02701 
02702     <a class="code" href="../../d5/d9/struct__PP__LOOKASIDE__LIST.html">PP_LOOKASIDE_LIST</a> PPPagedLookasideList[<a class="code" href="../../d0/d9/ntosdef_8h.html#a2">POOL_SMALL_LISTS</a>];
02703 
02704 <span class="comment">//</span>
02705 <span class="comment">// Per processor lock queue entries.</span>
02706 <span class="comment">//</span>
02707 
02708     <a class="code" href="../../d0/d8/struct__KSPIN__LOCK__QUEUE.html">KSPIN_LOCK_QUEUE</a> LockQueue[16];
02709 
02710 <span class="comment">//</span>
02711 <span class="comment">// MP interprocessor request packet and summary.</span>
02712 <span class="comment">//</span>
02713 <span class="comment">// N.B. This is carefully aligned to be on a cache line boundary.</span>
02714 <span class="comment">//</span>
02715 
02716     <span class="keyword">volatile</span> PVOID CurrentPacket[3];
02717     <span class="keyword">volatile</span> KAFFINITY TargetSet;
02718     <span class="keyword">volatile</span> <a class="code" href="../../d0/d9/ntosdef_8h.html#a55">PKIPI_WORKER</a> WorkerRoutine;
02719     ULONGLONG CachePad1[11];
02720 
02721 <span class="comment">//</span>
02722 <span class="comment">// N.B. These two longwords must be on a quadword boundary and adjacent.</span>
02723 <span class="comment">//</span>
02724 
02725     <span class="keyword">volatile</span> ULONG RequestSummary;
02726     <span class="keyword">volatile</span> <span class="keyword">struct </span>_KPRCB *SignalDone;
02727 
02728 <span class="comment">//</span>
02729 <span class="comment">// Spare counters.</span>
02730 <span class="comment">//</span>
02731 
02732     ULONGLONG <a class="code" href="../../d4/d9/ke_8h.html#a407a221">Spare4</a>[14];
02733 
02734 <span class="comment">//</span>
02735 <span class="comment">// DPC interrupt requested.</span>
02736 <span class="comment">//</span>
02737 
02738     ULONG DpcInterruptRequested;
02739     ULONGLONG <a class="code" href="../../d4/d9/ke_8h.html#a407a222">Spare5</a>[15];
02740     ULONG MaximumDpcQueueDepth;
02741     ULONG MinimumDpcRate;
02742     ULONG AdjustDpcThreshold;
02743     ULONG DpcRequestRate;
02744     LARGE_INTEGER StartCount;
02745 
02746 <span class="comment">//</span>
02747 <span class="comment">// DPC list head, spinlock, and count.</span>
02748 <span class="comment">//</span>
02749 
02750     LIST_ENTRY DpcListHead;
02751     KSPIN_LOCK DpcLock;
02752     ULONG DpcCount;
02753     ULONG DpcLastCount;
02754     ULONG QuantumEnd;
02755     ULONG DpcRoutineActive;
02756     ULONG DpcQueueDepth;
02757     BOOLEAN SkipTick;
02758 
02759 <span class="comment">//</span>
02760 <span class="comment">// Address of MP interprocessor operation counters.</span>
02761 <span class="comment">//</span>
02762 
02763     <a class="code" href="../../d1/d7/struct__KIPI__COUNTS.html">PKIPI_COUNTS</a> IpiCounts;
02764 
02765 <span class="comment">//</span>
02766 <span class="comment">// Processors power state</span>
02767 <span class="comment">//</span>
02768     PROCESSOR_POWER_STATE PowerState;
02769 
02770 <span class="comment">// begin_nthal begin_ntddk</span>
02771 } KPRCB, *PKPRCB, *RESTRICTED_POINTER PRKPRCB;
02772 
02773 <span class="comment">// begin_ntndis</span>
02774 
02775 <span class="comment">//</span>
02776 <span class="comment">// Define Processor Control Region Structure.</span>
02777 <span class="comment">//</span>
02778 
02779 <span class="preprocessor">#define PCR_MINOR_VERSION 1</span>
02780 <span class="preprocessor"></span><span class="preprocessor">#define PCR_MAJOR_VERSION 1</span>
02781 <span class="preprocessor"></span>
02782 <span class="keyword">typedef</span> <span class="keyword">struct </span>_KPCR {
02783 
02784 <span class="comment">//</span>
02785 <span class="comment">// Major and minor version numbers of the PCR.</span>
02786 <span class="comment">//</span>
02787     ULONG MinorVersion;
02788     ULONG MajorVersion;
02789 
02790 <span class="comment">//</span>
02791 <span class="comment">// Start of the architecturally defined section of the PCR. This section</span>
02792 <span class="comment">// may be directly addressed by vendor/platform specific HAL code and will</span>
02793 <span class="comment">// not change from version to version of NT.</span>
02794 <span class="comment">//</span>
02795 
02796 <span class="comment">//</span>
02797 <span class="comment">// First and second level cache parameters.</span>
02798 <span class="comment">//</span>
02799 
02800     ULONG FirstLevelDcacheSize;
02801     ULONG FirstLevelDcacheFillSize;
02802     ULONG FirstLevelIcacheSize;
02803     ULONG FirstLevelIcacheFillSize;
02804     ULONG SecondLevelDcacheSize;
02805     ULONG SecondLevelDcacheFillSize;
02806     ULONG SecondLevelIcacheSize;
02807     ULONG SecondLevelIcacheFillSize;
02808 
02809 <span class="comment">//</span>
02810 <span class="comment">// Data cache alignment and fill size used for cache flushing and alignment.</span>
02811 <span class="comment">// These fields are set to the larger of the first and second level data</span>
02812 <span class="comment">// cache fill sizes.</span>
02813 <span class="comment">//</span>
02814 
02815     ULONG DcacheAlignment;
02816     ULONG DcacheFillSize;
02817 
02818 <span class="comment">//</span>
02819 <span class="comment">// Instruction cache alignment and fill size used for cache flushing and</span>
02820 <span class="comment">// alignment. These fields are set to the larger of the first and second</span>
02821 <span class="comment">// level data cache fill sizes.</span>
02822 <span class="comment">//</span>
02823 
02824     ULONG IcacheAlignment;
02825     ULONG IcacheFillSize;
02826 
02827 <span class="comment">//</span>
02828 <span class="comment">// Processor identification from PrId register.</span>
02829 <span class="comment">//</span>
02830 
02831     ULONG ProcessorId;
02832 
02833 <span class="comment">//</span>
02834 <span class="comment">// Profiling data.</span>
02835 <span class="comment">//</span>
02836 
02837     ULONG ProfileInterval;
02838     ULONG ProfileCount;
02839 
02840 <span class="comment">//</span>
02841 <span class="comment">// Stall execution count and scale factor.</span>
02842 <span class="comment">//</span>
02843 
02844     ULONG StallExecutionCount;
02845     ULONG StallScaleFactor;
02846 
02847     ULONG InterruptionCount;
02848 
02849 <span class="comment">//</span>
02850 <span class="comment">// Space reserved for the system.</span>
02851 <span class="comment">//</span>
02852 
02853     ULONGLONG   SystemReserved[6];
02854 
02855 <span class="comment">//</span>
02856 <span class="comment">// Space reserved for the HAL</span>
02857 <span class="comment">//</span>
02858 
02859     ULONGLONG   HalReserved[64];
02860 
02861 <span class="comment">//</span>
02862 <span class="comment">// IRQL mapping tables.</span>
02863 <span class="comment">//</span>
02864 
02865     UCHAR IrqlMask[64];
02866     UCHAR IrqlTable[64];
02867 
02868 <span class="comment">//</span>
02869 <span class="comment">// External Interrupt vectors.</span>
02870 <span class="comment">//</span>
02871 
02872     PKINTERRUPT_ROUTINE InterruptRoutine[MAXIMUM_VECTOR];
02873 
02874 <span class="comment">//</span>
02875 <span class="comment">// Reserved interrupt vector mask.</span>
02876 <span class="comment">//</span>
02877 
02878     ULONG ReservedVectors;
02879 
02880 <span class="comment">//</span>
02881 <span class="comment">// Processor affinity mask.</span>
02882 <span class="comment">//</span>
02883 
02884     KAFFINITY <a class="code" href="../../d0/d0/ki_8h.html#a7">SetMember</a>;
02885 
02886 <span class="comment">//</span>
02887 <span class="comment">// Complement of the processor affinity mask.</span>
02888 <span class="comment">//</span>
02889 
02890     KAFFINITY NotMember;
02891 
02892 <span class="comment">//</span>
02893 <span class="comment">// Pointer to processor control block.</span>
02894 <span class="comment">//</span>
02895 
02896     <span class="keyword">struct </span>_KPRCB *Prcb;
02897 
02898 <span class="comment">//</span>
02899 <span class="comment">//  Shadow copy of Prcb-&gt;CurrentThread for fast access</span>
02900 <span class="comment">//</span>
02901 
02902     <span class="keyword">struct </span><a class="code" href="../../d1/d8/struct__KTHREAD.html">_KTHREAD</a> *CurrentThread;
02903 
02904 <span class="comment">//</span>
02905 <span class="comment">// Processor number.</span>
02906 <span class="comment">//</span>
02907 
02908     CCHAR Number;                        <span class="comment">// Processor Number</span>
02909     UCHAR DebugActive;                   <span class="comment">// debug register active in user flag</span>
02910     UCHAR KernelDebugActive;             <span class="comment">// debug register active in kernel flag</span>
02911     UCHAR CurrentIrql;                   <span class="comment">// Current IRQL</span>
02912     <span class="keyword">union </span>{
02913         <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> SoftwareInterruptPending; <span class="comment">// Software Interrupt Pending Flag</span>
02914         <span class="keyword">struct </span>{
02915             UCHAR ApcInterrupt;          <span class="comment">// 0x01 if APC int pending</span>
02916             UCHAR DispatchInterrupt;     <span class="comment">// 0x01 if dispatch int pending</span>
02917         };
02918     };
02919 
02920 <span class="comment">//</span>
02921 <span class="comment">// End of the architecturally defined section of the PCR. This section</span>
02922 <span class="comment">// may be directly addressed by vendor/platform specific HAL code and will</span>
02923 <span class="comment">// not change from version to version of NT.</span>
02924 <span class="comment">//</span>
02925 
02926 <span class="comment">// end_nthal end_ntddk</span>
02927 
02928 <span class="comment">//</span>
02929 <span class="comment">// OS Part</span>
02930 <span class="comment">//</span>
02931 
02932 <span class="comment">// Please contact INTEL to get IA64-specific information</span>
02933 <span class="comment">// @@BEGIN_DDKSPLIT</span>
02934 <span class="comment">//  Per processor kernel (ntoskrnl.exe) global pointer - gp (swizzled) // Intel-IA64-Filler</span>
02935     ULONGLONG   KernelGP; <span class="comment">// Intel-IA64-Filler</span>
02936 <span class="comment">//  Per processor initial kernel stack for current thread (swizzled) // Intel-IA64-Filler</span>
02937     ULONGLONG   InitialStack; <span class="comment">// Intel-IA64-Filler</span>
02938 <span class="comment">//  Per processor pointer to kernel BSP (swizzled) // Intel-IA64-Filler</span>
02939     ULONGLONG   InitialBStore; <span class="comment">// Intel-IA64-Filler</span>
02940 <span class="comment">//  Per processor kernel stack limit (swizzled) // Intel-IA64-Filler</span>
02941     ULONGLONG   StackLimit; <span class="comment">// Intel-IA64-Filler</span>
02942 <span class="comment">//  Per processor kernel backing store limit (swizzled) // Intel-IA64-Filler</span>
02943     ULONGLONG   BStoreLimit; <span class="comment">// Intel-IA64-Filler</span>
02944 <span class="comment">//  Per processor panic kernel stack (swizzled) // Intel-IA64-Filler</span>
02945     ULONGLONG   PanicStack; <span class="comment">// Intel-IA64-Filler</span>
02946 
02947 <span class="comment">//</span>
02948 <span class="comment">//  Save area for kernel entry/exit</span>
02949 <span class="comment">//</span>
02950     ULONGLONG   SavedIIM; <span class="comment">// Intel-IA64-Filler</span>
02951     ULONGLONG   SavedIFA; <span class="comment">// Intel-IA64-Filler</span>
02952 
02953     ULONGLONG   ForwardProgressBuffer[16]; <span class="comment">// Intel-IA64-Filler</span>
02954 <span class="comment">// @@END_DDKSPLIT</span>
02955 
02956 <span class="comment">// begin_nthal begin_ntddk</span>
02957 
02958 } KPCR, *PKPCR;
02959 
02960 <span class="comment">// end_nthal end_ntddk</span>
02961 
02962 <span class="comment">// begin_nthal</span>
02963 
02964 <span class="comment">// Please contact INTEL to get IA64-specific information</span>
02965 <span class="comment">// @@BEGIN_DDKSPLIT</span>
02966 <span class="comment">//</span>
02967 <span class="comment">// Define the number of bits to shift to right justify the Page Table Index</span>
02968 <span class="comment">// field of a PTE.</span>
02969 <span class="comment">//</span>
02970 
02971 <span class="preprocessor">#define PTI_SHIFT PAGE_SHIFT // Intel-IA64-Filler</span>
02972 <span class="preprocessor"></span>
02973 <span class="comment">//</span>
02974 <span class="comment">// Define the number of bits to shift to right justify the Page Directory Index</span>
02975 <span class="comment">// field of a PTE.</span>
02976 <span class="comment">//</span>
02977 
02978 <span class="preprocessor">#define PDI_SHIFT (PTI_SHIFT + PAGE_SHIFT - PTE_SHIFT)  // Intel-IA64-Filler</span>
02979 <span class="preprocessor"></span><span class="preprocessor">#define PDI1_SHIFT (PDI_SHIFT + PAGE_SHIFT - PTE_SHIFT) // Intel-IA64-Filler</span>
02980 <span class="preprocessor"></span><span class="preprocessor">#define PDI_MASK ((1 &lt;&lt; (PAGE_SHIFT - PTE_SHIFT)) - 1)  // Intel-IA64-Filler</span>
02981 <span class="preprocessor"></span>
02982 <span class="comment">//</span>
02983 <span class="comment">// Define the number of bits to shift to left to produce page table offset</span>
02984 <span class="comment">// from page table index.</span>
02985 <span class="comment">//</span>
02986 
02987 <span class="preprocessor">#define PTE_SHIFT 3 // Intel-IA64-Filler</span>
02988 <span class="preprocessor"></span>
02989 <span class="comment">//</span>
02990 <span class="comment">// Define the number of bits to shift to the right justify the Page Directory</span>
02991 <span class="comment">// Table Entry field.</span>
02992 <span class="comment">//</span>
02993 
02994 <span class="preprocessor">#define VHPT_PDE_BITS 40 // Intel-IA64-Filler</span>
02995 <span class="preprocessor"></span>
02996 <span class="comment">//</span>
02997 <span class="comment">// Define the RID for IO Port Space. // Intel-IA64-Filler</span>
02998 <span class="comment">//</span>
02999 
03000 <span class="preprocessor">#define RR_IO_PORT 6 // Intel-IA64-Filler</span>
03001 <span class="preprocessor"></span>
03002 <span class="comment">// @@END_DDKSPLIT</span>
03003 
03004 
03005 <span class="comment">// begin_ntddk</span>
03006 <span class="comment">//</span>
03007 <span class="comment">// The highest user address reserves 64K bytes for a guard page. This</span>
03008 <span class="comment">// the probing of address from kernel mode to only have to check the</span>
03009 <span class="comment">// starting address for structures of 64k bytes or less.</span>
03010 <span class="comment">//</span>
03011 
03012 <span class="preprocessor">#define MM_HIGHEST_USER_ADDRESS (PVOID) (ULONG_PTR)((UADDRESS_BASE + 0x3FFFFFEFFFF)) // highest user address</span>
03013 <span class="preprocessor"></span><span class="preprocessor">#define MM_USER_PROBE_ADDRESS ((ULONG_PTR)(UADDRESS_BASE + 0x3FFFFFF0000UI64)) // starting address of guard page</span>
03014 <span class="preprocessor"></span><span class="preprocessor">#define MM_SYSTEM_RANGE_START (PVOID) (KSEG0_BASE) // start of system space</span>
03015 <span class="preprocessor"></span>
03016 <span class="comment">//</span>
03017 <span class="comment">// The following definitions are required for the debugger data block.</span>
03018 <span class="comment">//</span>
03019 
03020 <span class="keyword">extern</span> PVOID <a class="code" href="../../d0/d9/miglobal_8c.html#a0">MmHighestUserAddress</a>;
03021 <span class="keyword">extern</span> PVOID <a class="code" href="../../d0/d9/miglobal_8c.html#a1">MmSystemRangeStart</a>;
03022 <span class="keyword">extern</span> ULONG_PTR <a class="code" href="../../d0/d9/miglobal_8c.html#a2">MmUserProbeAddress</a>;
03023 
03024 <span class="comment">//</span>
03025 <span class="comment">// The lowest user address reserves the low 64k.</span>
03026 <span class="comment">//</span>
03027 
03028 <span class="preprocessor">#define MM_LOWEST_USER_ADDRESS  (PVOID)((ULONG_PTR)(UADDRESS_BASE+0x00010000))</span>
03029 <span class="preprocessor"></span>
03030 <span class="comment">// begin_wdm</span>
03031 
03032 <span class="preprocessor">#define MmGetProcedureAddress(Address) (Address)</span>
03033 <span class="preprocessor"></span><span class="preprocessor">#define MmLockPagableCodeSection(PLabelAddress) \</span>
03034 <span class="preprocessor">    MmLockPagableDataSection((PVOID)(*((PULONGLONG)PLabelAddress)))</span>
03035 <span class="preprocessor"></span>
03036 <span class="comment">// end_ntddk end_wdm</span>
03037 <span class="comment">//</span>
03038 <span class="comment">// Define the page table base and the page directory base for</span>
03039 <span class="comment">// the TB miss routines and memory management.</span>
03040 <span class="comment">//</span>
03041 
03042 <span class="preprocessor">#define VA_SIGN    0x0002000000000000UI64    // MSB of implemented virtual address</span>
03043 <span class="preprocessor"></span><span class="preprocessor">#define VA_FILL    0x1FFC000000000000UI64    // singed fill for unimplemented virtual address</span>
03044 <span class="preprocessor"></span><span class="preprocessor">#define VRN_MASK   0xE000000000000000UI64    // Virtual Region Number mask</span>
03045 <span class="preprocessor"></span><span class="preprocessor">#define PTA_BASE0  0x1FFC000000000000UI64    // Page Table Address BASE 0</span>
03046 <span class="preprocessor"></span><span class="preprocessor">#define PTA_SIGN   (VA_SIGN &gt;&gt; (PAGE_SHIFT - PTE_SHIFT)) // MSB of VPN offset</span>
03047 <span class="preprocessor"></span><span class="preprocessor">#define PTA_FILL   (VA_FILL &gt;&gt; (PAGE_SHIFT - PTE_SHIFT)) // signed fill for PTA base0</span>
03048 <span class="preprocessor"></span><span class="preprocessor">#define PTA_BASE   (PTA_BASE0|PTA_FILL)      // PTA_BASE address</span>
03049 <span class="preprocessor"></span>
03050 <span class="comment">//</span>
03051 <span class="comment">// user/kernel page table base and top addresses</span>
03052 <span class="comment">//</span>
03053 
03054 <span class="preprocessor">#define SADDRESS_BASE 0x2000000000000000UI64  // session base address</span>
03055 <span class="preprocessor"></span>
03056 <span class="preprocessor">#define PTE_UBASE  (UADDRESS_BASE|PTA_BASE)</span>
03057 <span class="preprocessor"></span><span class="preprocessor">#define PTE_KBASE  (KADDRESS_BASE|PTA_BASE)</span>
03058 <span class="preprocessor"></span><span class="preprocessor">#define PTE_SBASE  (SADDRESS_BASE|PTA_BASE)</span>
03059 <span class="preprocessor"></span>
03060 <span class="preprocessor">#define PTE_UTOP (PTE_UBASE|(((ULONG_PTR)1 &lt;&lt; PDI1_SHIFT) - 1)) // top level PDR address (user)</span>
03061 <span class="preprocessor"></span><span class="preprocessor">#define PTE_KTOP (PTE_KBASE|(((ULONG_PTR)1 &lt;&lt; PDI1_SHIFT) - 1)) // top level PDR address (kernel)</span>
03062 <span class="preprocessor"></span><span class="preprocessor">#define PTE_STOP (PTE_SBASE|(((ULONG_PTR)1 &lt;&lt; PDI1_SHIFT) - 1)) // top level PDR address (session)</span>
03063 <span class="preprocessor"></span>
03064 <span class="comment">//</span>
03065 <span class="comment">// Second level user and kernel PDR address</span>
03066 <span class="comment">//</span>
03067 
03068 <span class="preprocessor">#define PDE_UBASE  (PTE_UBASE|(PTE_UBASE&gt;&gt;(PTI_SHIFT-PTE_SHIFT)))</span>
03069 <span class="preprocessor"></span><span class="preprocessor">#define PDE_KBASE  (PTE_KBASE|(PTE_KBASE&gt;&gt;(PTI_SHIFT-PTE_SHIFT)))</span>
03070 <span class="preprocessor"></span><span class="preprocessor">#define PDE_SBASE  (PTE_SBASE|(PTE_SBASE&gt;&gt;(PTI_SHIFT-PTE_SHIFT)))</span>
03071 <span class="preprocessor"></span>
03072 <span class="preprocessor">#define PDE_UTOP (PDE_UBASE|(((ULONG_PTR)1 &lt;&lt; PDI_SHIFT) - 1)) // second level PDR address (user)</span>
03073 <span class="preprocessor"></span><span class="preprocessor">#define PDE_KTOP (PDE_KBASE|(((ULONG_PTR)1 &lt;&lt; PDI_SHIFT) - 1)) // second level PDR address (kernel)</span>
03074 <span class="preprocessor"></span><span class="preprocessor">#define PDE_STOP (PDE_SBASE|(((ULONG_PTR)1 &lt;&lt; PDI_SHIFT) - 1)) // second level PDR address (session)</span>
03075 <span class="preprocessor"></span>
03076 <span class="comment">//</span>
03077 <span class="comment">// 8KB first level user and kernel PDR address</span>
03078 <span class="comment">//</span>
03079 
03080 <span class="preprocessor">#define PDE_UTBASE (PTE_UBASE|(PDE_UBASE&gt;&gt;(PTI_SHIFT-PTE_SHIFT)))</span>
03081 <span class="preprocessor"></span><span class="preprocessor">#define PDE_KTBASE (PTE_KBASE|(PDE_KBASE&gt;&gt;(PTI_SHIFT-PTE_SHIFT)))</span>
03082 <span class="preprocessor"></span><span class="preprocessor">#define PDE_STBASE (PTE_SBASE|(PDE_SBASE&gt;&gt;(PTI_SHIFT-PTE_SHIFT)))</span>
03083 <span class="preprocessor"></span>
03084 <span class="preprocessor">#define PDE_USELFMAP (PDE_UTBASE|(PAGE_SIZE - (1&lt;&lt;PTE_SHIFT))) // self mapped PPE address (user)</span>
03085 <span class="preprocessor"></span><span class="preprocessor">#define PDE_KSELFMAP (PDE_KTBASE|(PAGE_SIZE - (1&lt;&lt;PTE_SHIFT))) // self mapped PPE address (kernel)</span>
03086 <span class="preprocessor"></span><span class="preprocessor">#define PDE_SSELFMAP (PDE_STBASE|(PAGE_SIZE - (1&lt;&lt;PTE_SHIFT))) // self mapped PPE address (kernel)</span>
03087 <span class="preprocessor"></span>
03088 <span class="preprocessor">#define PTE_BASE    PTE_UBASE</span>
03089 <span class="preprocessor"></span><span class="preprocessor">#define PDE_BASE    PDE_UBASE</span>
03090 <span class="preprocessor"></span><span class="preprocessor">#define PDE_TBASE   PDE_UTBASE</span>
03091 <span class="preprocessor"></span><span class="preprocessor">#define PDE_SELFMAP PDE_USELFMAP</span>
03092 <span class="preprocessor"></span>
03093 <span class="preprocessor">#define KSEG3_BASE 0x8000000000000000UI64</span>
03094 <span class="preprocessor"></span><span class="preprocessor">#define KSEG3_LIMIT 0x8000100000000000UI64</span>
03095 <span class="preprocessor"></span>
03096 <span class="comment">//</span>
03097 <span class="comment">//++</span>
03098 <span class="comment">//PVOID</span>
03099 <span class="comment">//KSEG_ADDRESS (</span>
03100 <span class="comment">//    IN ULONG PAGE</span>
03101 <span class="comment">//    );</span>
03102 <span class="comment">//</span>
03103 <span class="comment">// Routine Description:</span>
03104 <span class="comment">//</span>
03105 <span class="comment">//    This macro returns a KSEG virtual address which maps the page.</span>
03106 <span class="comment">//</span>
03107 <span class="comment">// Arguments:</span>
03108 <span class="comment">//</span>
03109 <span class="comment">//    PAGE - Supplies the physical page frame number</span>
03110 <span class="comment">//</span>
03111 <span class="comment">// Return Value:</span>
03112 <span class="comment">//</span>
03113 <span class="comment">//    The address of the KSEG address</span>
03114 <span class="comment">//</span>
03115 <span class="comment">//--</span>
03116 
03117 <span class="preprocessor">#define KSEG_ADDRESS(PAGE) ((PVOID)(KSEG3_BASE | ((ULONG_PTR)(PAGE) &lt;&lt; PAGE_SHIFT)))</span>
03118 <span class="preprocessor"></span>
03119 <span class="preprocessor">#define MAXIMUM_FWP_BUFFER_ENTRY 8</span>
03120 <span class="preprocessor"></span>
03121 <span class="keyword">typedef</span> <span class="keyword">struct </span>_REGION_MAP_INFO {
03122     ULONG RegionId;
03123     ULONG PageSize;
03124     ULONGLONG SequenceNumber;
03125 } REGION_MAP_INFO, *PREGION_MAP_INFO;
03126 
03127 <span class="comment">// begin_ntddk begin_wdm</span>
03128 <span class="comment">//</span>
03129 <span class="comment">// The lowest address for system space.</span>
03130 <span class="comment">//</span>
03131 
03132 <span class="preprocessor">#define MM_LOWEST_SYSTEM_ADDRESS ((PVOID)((ULONG_PTR)(KADDRESS_BASE + 0xC0C00000)))</span>
03133 <span class="preprocessor"></span><span class="comment">// end_nthal end_ntddk end_wdm</span>
03134 
03135 <span class="preprocessor">#define SYSTEM_BASE (KADDRESS_BASE + 0xC3000000)          // start of system space (no typecast)</span>
03136 <span class="preprocessor"></span>
03137 <span class="comment">//</span>
03138 <span class="comment">// Define macro to initialize directory table base.</span>
03139 <span class="comment">//</span>
03140 
03141 <span class="comment">// Please contact INTEL to get IA64-specific information</span>
03142 <span class="comment">// @@BEGIN_DDKSPLIT</span>
03143 <span class="preprocessor">#define INITIALIZE_DIRECTORY_TABLE_BASE(dirbase, pfn)  </span><span class="comment">/* Intel-IA64-Filler */</span> \
03144     *((PULONGLONG)(dirbase)) = 0;                      <span class="comment">/* Intel-IA64-Filler */</span> \
03145     ((PHARDWARE_PTE)(dirbase))-&gt;PageFrameNumber = pfn; <span class="comment">/* Intel-IA64-Filler */</span> \
03146     ((PHARDWARE_PTE)(dirbase))-&gt;Accessed = 1;          <span class="comment">/* Intel-IA64-Filler */</span> \
03147     ((PHARDWARE_PTE)(dirbase))-&gt;Dirty = 1;             <span class="comment">/* Intel-IA64-Filler */</span> \
03148     ((PHARDWARE_PTE)(dirbase))-&gt;Cache = 0;             <span class="comment">/* Intel-IA64-Filler */</span> \
03149     ((PHARDWARE_PTE)(dirbase))-&gt;Write = 1;             <span class="comment">/* Intel-IA64-Filler */</span> \
03150     ((PHARDWARE_PTE)(dirbase))-&gt;Valid = 1;             // Intel-IA64-Filler
03151 <span class="comment">// @@END_DDKSPLIT</span>
03152 
03153 
03154 <span class="comment">//</span>
03155 <span class="comment">// IA64 function definitions</span>
03156 <span class="comment">//</span>
03157 
03158 <span class="comment">//++</span>
03159 <span class="comment">//</span>
03160 <span class="comment">// BOOLEAN</span>
03161 <span class="comment">// KiIsThreadNumericStateSaved(</span>
03162 <span class="comment">//     IN PKTHREAD Address</span>
03163 <span class="comment">//     )</span>
03164 <span class="comment">//</span>
03165 <span class="comment">//  This call is used on a not running thread to see if it's numeric</span>
03166 <span class="comment">//  state has been saved in it's context information.  On IA64 the</span>
03167 <span class="comment">//  numeric state is always saved.</span>
03168 <span class="comment">//</span>
03169 <span class="comment">//--</span>
03170 <span class="preprocessor">#define KiIsThreadNumericStateSaved(a) TRUE</span>
03171 <span class="preprocessor"></span>
03172 <span class="comment">//++</span>
03173 <span class="comment">//</span>
03174 <span class="comment">// VOID</span>
03175 <span class="comment">// KiRundownThread(</span>
03176 <span class="comment">//     IN PKTHREAD Address</span>
03177 <span class="comment">//     )</span>
03178 <span class="comment">//</span>
03179 <span class="comment">//--</span>
03180 <span class="preprocessor">#define KiRundownThread(a)</span>
03181 <span class="preprocessor"></span>
03182 <span class="comment">//</span>
03183 <span class="comment">// Define macro to test if x86 feature is present.</span>
03184 <span class="comment">//</span>
03185 <span class="comment">// N.B. All x86 features test TRUE on IA64 systems.</span>
03186 <span class="comment">//</span>
03187 
03188 <span class="preprocessor">#define Isx86FeaturePresent(_f_) TRUE</span>
03189 <span class="preprocessor"></span>
03190 
03191 <span class="comment">// begin_nthal begin_ntddk begin_ntndis begin_wdm</span>
03192 <span class="preprocessor">#endif // defined(_IA64_)</span>
03193 <span class="preprocessor"></span><span class="comment">// end_nthal end_ntddk end_ntndis end_wdm</span>
03194 
03195 <span class="preprocessor">#endif // _IA64H_</span>
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:40:19 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
