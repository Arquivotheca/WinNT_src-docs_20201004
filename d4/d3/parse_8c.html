<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: parse.c File Reference</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>parse.c File Reference</h1><code>#include "<a class="el" href="../../d1/d5/iop_8h-source.html">iop.h</a>"</code><br>

<p>
<a href="../../d5/d2/parse_8c-source.html">Go to the source code of this file.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d3/parse_8c.html#a0">RoundNameSize</a>(Length)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d3/parse_8c.html#a1">IO_MAX_REMOUNT_REPARSE_ATTEMPTS</a>&nbsp;&nbsp;&nbsp;32</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d3/parse_8c.html#a2">COPY_ATTRIBUTES</a>(<a class="el" href="../../d7/d0/exts_8h.html#a0">n</a>, b, s)</td></tr>

<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d3/parse_8c.html#a3">IopCheckDeviceAndDriver</a> (<a class="el" href="../../d3/d7/struct__OPEN__PACKET.html">POPEN_PACKET</a> op, <a class="el" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> parseDeviceObject)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="../../d7/d7/struct__VPB.html">PVPB</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d3/parse_8c.html#a4">IopCheckVpbMounted</a> (IN <a class="el" href="../../d3/d7/struct__OPEN__PACKET.html">POPEN_PACKET</a> op, IN <a class="el" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> parseDeviceObject, IN OUT PUNICODE_STRING RemainingName, OUT PNTSTATUS status)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d3/parse_8c.html#a5">IopDereferenceVpbAndFree</a> (IN <a class="el" href="../../d7/d7/struct__VPB.html">PVPB</a> Vpb)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d3/parse_8c.html#a6">IopParseDevice</a> (IN PVOID ParseObject, IN PVOID ObjectType, IN <a class="el" href="../../d2/d5/struct__ACCESS__STATE.html">PACCESS_STATE</a> AccessState, IN <a class="el" href="../../d0/d9/ntosdef_8h.html#a39">KPROCESSOR_MODE</a> AccessMode, IN ULONG Attributes, IN OUT PUNICODE_STRING CompleteName, IN OUT PUNICODE_STRING RemainingName, IN OUT PVOID Context OPTIONAL, IN PSECURITY_QUALITY_OF_SERVICE <a class="el" href="../../d8/d0/ctlpcqos_8c.html#a9">SecurityQos</a> OPTIONAL, OUT PVOID *Object)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d3/parse_8c.html#a7">IopParseFile</a> (IN PVOID ParseObject, IN PVOID ObjectType, IN <a class="el" href="../../d2/d5/struct__ACCESS__STATE.html">PACCESS_STATE</a> AccessState, IN <a class="el" href="../../d0/d9/ntosdef_8h.html#a39">KPROCESSOR_MODE</a> AccessMode, IN ULONG Attributes, IN OUT PUNICODE_STRING CompleteName, IN OUT PUNICODE_STRING RemainingName, IN OUT PVOID Context OPTIONAL, IN PSECURITY_QUALITY_OF_SERVICE <a class="el" href="../../d8/d0/ctlpcqos_8c.html#a9">SecurityQos</a> OPTIONAL, OUT PVOID *Object)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d3/parse_8c.html#a8">IopQueryName</a> (IN PVOID Object, IN BOOLEAN HasObjectName, OUT POBJECT_NAME_INFORMATION ObjectNameInfo, IN ULONG Length, OUT PULONG ReturnLength)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d4/d3/parse_8c.html#a9">IopCheckBackupRestorePrivilege</a> (IN <a class="el" href="../../d2/d5/struct__ACCESS__STATE.html">PACCESS_STATE</a> AccessState, IN OUT PULONG CreateOptions, IN <a class="el" href="../../d0/d9/ntosdef_8h.html#a39">KPROCESSOR_MODE</a> PreviousMode, IN ULONG Disposition)</td></tr>

</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="a2" doxytag="parse.c::COPY_ATTRIBUTES" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define COPY_ATTRIBUTES          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="../../d7/d0/exts_8h.html#a0">n</a>,         <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>b,         <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>s&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><pre class="fragment"><div>{                                    \
        (<a class="code" href="../../d7/d0/exts_8h.html#a0">n</a>)-&gt;CreationTime.QuadPart = (b)-&gt;CreationTime.QuadPart;        \
        (<a class="code" href="../../d7/d0/exts_8h.html#a0">n</a>)-&gt;LastAccessTime.QuadPart = (b)-&gt;LastAccessTime.QuadPart;    \
        (<a class="code" href="../../d7/d0/exts_8h.html#a0">n</a>)-&gt;LastWriteTime.QuadPart = (b)-&gt;LastWriteTime.QuadPart;      \
        (<a class="code" href="../../d7/d0/exts_8h.html#a0">n</a>)-&gt;ChangeTime.QuadPart = (b)-&gt;ChangeTime.QuadPart;            \
        (<a class="code" href="../../d7/d0/exts_8h.html#a0">n</a>)-&gt;AllocationSize.QuadPart = (s)-&gt;AllocationSize.QuadPart;    \
        (<a class="code" href="../../d7/d0/exts_8h.html#a0">n</a>)-&gt;EndOfFile.QuadPart = (s)-&gt;EndOfFile.QuadPart;              \
        (<a class="code" href="../../d7/d0/exts_8h.html#a0">n</a>)-&gt;FileAttributes = (b)-&gt;FileAttributes; }
</div></pre>
<p>
Referenced by <a class="el" href="../../d5/d2/parse_8c-source.html#l00202">IopParseDevice()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a1" doxytag="parse.c::IO_MAX_REMOUNT_REPARSE_ATTEMPTS" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define IO_MAX_REMOUNT_REPARSE_ATTEMPTS&nbsp;&nbsp;&nbsp;32          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d2/parse_8c-source.html#l00037">37</a> of file <a class="el" href="../../d5/d2/parse_8c-source.html">parse.c</a>.
<p>
Referenced by <a class="el" href="../../d5/d2/parse_8c-source.html#l00202">IopParseDevice()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a0" doxytag="parse.c::RoundNameSize" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define RoundNameSize          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Length&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><pre class="fragment"><div>( \
    (Length &lt; 64 - 8) ? 64 - 8 :  \
    (Length &lt; 128 - 8) ? 128 - 8 :\
    (Length &lt; 256 - 8) ? 256 - 8 : Length )
</div></pre>
<p>
Definition at line <a class="el" href="../../d5/d2/parse_8c-source.html#l00032">32</a> of file <a class="el" href="../../d5/d2/parse_8c-source.html">parse.c</a>.
<p>
Referenced by <a class="el" href="../../d5/d2/parse_8c-source.html#l00202">IopParseDevice()</a>.    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a9" doxytag="parse.c::IopCheckBackupRestorePrivilege" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID IopCheckBackupRestorePrivilege           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d2/d5/struct__ACCESS__STATE.html">PACCESS_STATE</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>AccessState</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN OUT PULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>CreateOptions</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d0/d9/ntosdef_8h.html#a39">KPROCESSOR_MODE</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>PreviousMode</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Disposition</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d2/parse_8c-source.html#l02048">2048</a> of file <a class="el" href="../../d5/d2/parse_8c-source.html">parse.c</a>.
<p>
References <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>, <a class="el" href="../../d1/d4/se_8h-source.html#l00085">SE_BACKUP_PRIVILEGES_CHECKED</a>, <a class="el" href="../../d3/d4/seastate_8c-source.html#l00434">SeAppendPrivileges()</a>, <a class="el" href="../../d1/d4/se_8h-source.html#l01685">SeBackupPrivilege</a>, <a class="el" href="../../d9/d3/privileg_8c-source.html#l00158">SePrivilegeCheck()</a>, <a class="el" href="../../d1/d4/se_8h-source.html#l01686">SeRestorePrivilege</a>, <a class="el" href="../../d1/d4/se_8h-source.html#l00073">TOKEN_HAS_BACKUP_PRIVILEGE</a>, <a class="el" href="../../d1/d4/se_8h-source.html#l00074">TOKEN_HAS_RESTORE_PRIVILEGE</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, and <a class="el" href="../../d2/d7/hal_8h.html#a212">VOID()</a>.
<p>
Referenced by <a class="el" href="../../d5/d2/parse_8c-source.html#l00202">IopParseDevice()</a>.
<p>
<pre class="fragment"><div>02057                    :
02058 
02059     This funcion will determine <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> asking <span class="keywordflow">for</span> any accesses
02060     that may be satisfied by Backup or Restore privileges, and <span class="keywordflow">if</span> so,
02061     perform <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> privilge checks.  If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> privilege checks succeed, then
02062     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> appropriate bits will be <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a100">moved</a> <a class="code" href="../../d6/d0/wsprintf_8c.html#a0">out</a> of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> RemainingDesiredAccess
02063     field in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> AccessState structure and placed into <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> PreviouslyGrantedAccess
02064     field.
02065 
02066     Note that access <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> not denied <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller does not have either or
02067     both of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> privileges, since he may be granted <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> desired access
02068     via <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> security descriptor on <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> object.
02069 
02070     This routine will also set a flag in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> AccessState structure so that
02071     <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> will not perform these privilege checks again in <span class="keywordflow">case</span> we come through
02072     <span class="keyword">this</span> way again due to a reparse.
02073 
02074 Arguments:
02075 
02076     AccessState - The AccessState containing <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> current state of <span class="keyword">this</span> access
02077         attempt.
02078 
02079     CreateOptions - The CreateOptions field from <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d3/d7/struct__OPEN__PACKET.html">OPEN_PACKET</a> structure <span class="keywordflow">for</span>
02080         <span class="keyword">this</span> open attempt.
02081 
02082     PreviousMode - The processor mode to be used in checking parameters.
02083 
02084     Disposition - The create disposition <span class="keywordflow">for</span> <span class="keyword">this</span> request.
02085 
02086 Return Value:
02087 
02088     None.
02089 
02090 --*/
02091 
02092 {
02093     ACCESS_MASK desiredAccess;
02094     ACCESS_MASK readAccess;
02095     ACCESS_MASK writeAccess;
02096     PRIVILEGE_SET requiredPrivileges;
02097     BOOLEAN accessGranted;
02098     BOOLEAN keepBackupIntent = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02099     BOOLEAN ForceRestoreCheck = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02100 
02101     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
02102 
02103     <span class="comment">//</span>
02104     <span class="comment">// Check to determine whether or not this check has already been made.</span>
02105     <span class="comment">// If so, simply return back to the caller.</span>
02106     <span class="comment">//</span>
02107 
02108     <span class="keywordflow">if</span> (AccessState-&gt;Flags &amp; <a class="code" href="../../d0/d5/se_8h.html#a6">SE_BACKUP_PRIVILEGES_CHECKED</a>) {
02109         <span class="keywordflow">return</span>;
02110     }
02111 
02112     <span class="keywordflow">if</span> (*CreateOptions &amp; FILE_OPEN_FOR_BACKUP_INTENT) {
02113         AccessState-&gt;Flags |= <a class="code" href="../../d0/d5/se_8h.html#a6">SE_BACKUP_PRIVILEGES_CHECKED</a>;
02114 
02115         readAccess = READ_CONTROL | ACCESS_SYSTEM_SECURITY | FILE_GENERIC_READ | FILE_TRAVERSE;
02116         writeAccess = WRITE_DAC | WRITE_OWNER | ACCESS_SYSTEM_SECURITY | FILE_GENERIC_WRITE | FILE_ADD_FILE | FILE_ADD_SUBDIRECTORY | DELETE;
02117 
02118         desiredAccess = AccessState-&gt;RemainingDesiredAccess;
02119 
02120         <span class="comment">//</span>
02121         <span class="comment">// If the caller has requested MAXIMUM_ALLOWED, then make it appear as</span>
02122         <span class="comment">// if the request was for everything permitted by Backup and Restore,</span>
02123         <span class="comment">// and then grant everything that can actually be granted.</span>
02124         <span class="comment">//</span>
02125 
02126         <span class="keywordflow">if</span> (desiredAccess &amp; MAXIMUM_ALLOWED) {
02127             desiredAccess |= ( readAccess | writeAccess );
02128         }
02129 
02130         <span class="comment">//</span>
02131         <span class="comment">// If the disposition says that we're opening the file, check for both backup</span>
02132         <span class="comment">// and restore privilege, depending on what's in the desired access.</span>
02133         <span class="comment">//</span>
02134         <span class="comment">// If the disposition says that we're creating or trying to overwrite the file,</span>
02135         <span class="comment">// then all we need to do is to check for restore privilege, and if it's there,</span>
02136         <span class="comment">// grant every possible access.</span>
02137         <span class="comment">//</span>
02138 
02139         <span class="keywordflow">if</span> ( Disposition &amp; FILE_OPEN ) {
02140 
02141             <span class="comment">//</span>
02142             <span class="comment">// If the request was for any of the bits in the read access mask, then</span>
02143             <span class="comment">// assume that this is a backup operation, and check for the Backup</span>
02144             <span class="comment">// privielege.  If the caller has it, then grant the intersection of</span>
02145             <span class="comment">// the desired access and read access masks.</span>
02146             <span class="comment">//</span>
02147 
02148             <span class="keywordflow">if</span> (readAccess &amp; desiredAccess) {
02149 
02150                 requiredPrivileges.PrivilegeCount = 1;
02151                 requiredPrivileges.Control = PRIVILEGE_SET_ALL_NECESSARY;
02152                 requiredPrivileges.Privilege[0].Luid = <a class="code" href="../../d0/d5/se_8h.html#a94">SeBackupPrivilege</a>;
02153                 requiredPrivileges.Privilege[0].Attributes = 0;
02154 
02155                 accessGranted = <a class="code" href="../../d8/d4/privileg_8c.html#a1">SePrivilegeCheck</a>( &amp;requiredPrivileges,
02156                                                   &amp;AccessState-&gt;SubjectSecurityContext,
02157                                                   PreviousMode );
02158 
02159                 <span class="keywordflow">if</span> (accessGranted) {
02160 
02161                     <span class="comment">//</span>
02162                     <span class="comment">// The caller has Backup privilege, so grant the appropriate</span>
02163                     <span class="comment">// accesses.</span>
02164                     <span class="comment">//</span>
02165 
02166                     keepBackupIntent = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02167                     (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d2/d5/seastate_8c.html#a5">SeAppendPrivileges</a>( AccessState, &amp;requiredPrivileges );
02168                     AccessState-&gt;PreviouslyGrantedAccess |= ( desiredAccess &amp; readAccess );
02169                     AccessState-&gt;RemainingDesiredAccess &amp;= ~readAccess;
02170                     desiredAccess &amp;= ~readAccess;
02171                     AccessState-&gt;Flags |= <a class="code" href="../../d0/d5/se_8h.html#a2">TOKEN_HAS_BACKUP_PRIVILEGE</a>;
02172                 }
02173             }
02174 
02175         } <span class="keywordflow">else</span> {
02176 
02177             ForceRestoreCheck = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02178         }
02179 
02180         <span class="comment">//</span>
02181         <span class="comment">// If the request was for any of the bits in the write access mask, then</span>
02182         <span class="comment">// assume that this is a restore operation, so check for the Restore</span>
02183         <span class="comment">// privilege.  If the caller has it, then grant the intersection of</span>
02184         <span class="comment">// the desired access and write access masks.</span>
02185         <span class="comment">//</span>
02186 
02187         <span class="keywordflow">if</span> ((writeAccess &amp; desiredAccess) || ForceRestoreCheck) {
02188 
02189             requiredPrivileges.PrivilegeCount = 1;
02190             requiredPrivileges.Control = PRIVILEGE_SET_ALL_NECESSARY;
02191             requiredPrivileges.Privilege[0].Luid = <a class="code" href="../../d0/d5/se_8h.html#a95">SeRestorePrivilege</a>;
02192             requiredPrivileges.Privilege[0].Attributes = 0;
02193 
02194             accessGranted = <a class="code" href="../../d8/d4/privileg_8c.html#a1">SePrivilegeCheck</a>( &amp;requiredPrivileges,
02195                                               &amp;AccessState-&gt;SubjectSecurityContext,
02196                                               PreviousMode );
02197 
02198             <span class="keywordflow">if</span> (accessGranted) {
02199 
02200                 <span class="comment">//</span>
02201                 <span class="comment">// The caller has Restore privilege, so grant the appropriate</span>
02202                 <span class="comment">// accesses.</span>
02203                 <span class="comment">//</span>
02204 
02205                 keepBackupIntent = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02206                 (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d2/d5/seastate_8c.html#a5">SeAppendPrivileges</a>( AccessState, &amp;requiredPrivileges );
02207                 AccessState-&gt;PreviouslyGrantedAccess |= (desiredAccess &amp; writeAccess);
02208                 AccessState-&gt;RemainingDesiredAccess &amp;= ~writeAccess;
02209                 AccessState-&gt;Flags |= <a class="code" href="../../d0/d5/se_8h.html#a3">TOKEN_HAS_RESTORE_PRIVILEGE</a>;
02210             }
02211         }
02212 
02213         <span class="comment">//</span>
02214         <span class="comment">// If either of the access types was granted because the caller had</span>
02215         <span class="comment">// backup or restore privilege, then the backup intent flag is kept.</span>
02216         <span class="comment">// Otherwise, it is cleared so that it is not passed onto the driver</span>
02217         <span class="comment">// so that it is not incorrectly propogated anywhere else, since this</span>
02218         <span class="comment">// caller does not actually have the privilege enabled.</span>
02219         <span class="comment">//</span>
02220 
02221         <span class="keywordflow">if</span> (!keepBackupIntent) {
02222             *CreateOptions &amp;= ~FILE_OPEN_FOR_BACKUP_INTENT;
02223         }
02224     }
02225 }
}
</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="parse.c::IopCheckDeviceAndDriver" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS IopCheckDeviceAndDriver           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="../../d3/d7/struct__OPEN__PACKET.html">POPEN_PACKET</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>op</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>parseDeviceObject</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d2/parse_8c-source.html#l00047">47</a> of file <a class="el" href="../../d5/d2/parse_8c-source.html">parse.c</a>.
<p>
References <a class="el" href="../../d1/d4/io_8h-source.html#l01210">_DEVICE_OBJECT::DeviceObjectExtension</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01159">DO_DEVICE_INITIALIZING</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01155">DO_EXCLUSIVE</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01221">DOE_DELETE_PENDING</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01222">DOE_REMOVE_PENDING</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01223">DOE_REMOVE_PROCESSED</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01224">DOE_START_PENDING</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01220">DOE_UNLOAD_PENDING</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01268">_DEVOBJ_EXTENSION::ExtensionFlags</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01184">_DEVICE_OBJECT::Flags</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l00256">IO_ATTACH_DEVICE</a>, <a class="el" href="../../d4/d4/iodata_8c-source.html#l00054">IopDatabaseLock</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d1/d5/iop_8h-source.html#l00227">_OPEN_PACKET::Options</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01178">_DEVICE_OBJECT::ReferenceCount</a>, and <a class="el" href="../../d1/d5/iop_8h-source.html#l00212">_OPEN_PACKET::RelatedFileObject</a>.
<p>
Referenced by <a class="el" href="../../d5/d2/parse_8c-source.html#l00202">IopParseDevice()</a>.
<p>
<pre class="fragment"><div>00051 {
00052     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
00053     KIRQL irql;
00054 
00055     <span class="comment">//</span>
00056     <span class="comment">// Make sure that the device and its driver are really there and they are</span>
00057     <span class="comment">// going to stay there.  The object itself cannot go away just yet because</span>
00058     <span class="comment">// the object management system has performed a reference which bumps the</span>
00059     <span class="comment">// count of the number of reasons why the object must stick around.</span>
00060     <span class="comment">// However, the driver could be attempting to unload itself, so perform</span>
00061     <span class="comment">// this check.  If the driver is being unloaded, then set the final status</span>
00062     <span class="comment">// of the operation to "No such device" and return with a NULL file object</span>
00063     <span class="comment">// pointer.</span>
00064     <span class="comment">//</span>
00065     <span class="comment">// Note that it is possible to "open" an exclusive device more than once</span>
00066     <span class="comment">// provided that the caller is performing a relative open.  This feature</span>
00067     <span class="comment">// is how users "allocate" a device, and then use it to perform operations.</span>
00068     <span class="comment">//</span>
00069 
00070     ExAcquireFastLock( &amp;IopDatabaseLock, &amp;irql );
00071 
00072     <span class="keywordflow">if</span> (parseDeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o25">DeviceObjectExtension</a>-&gt;<a class="code" href="../../d3/d5/struct__DEVOBJ__EXTENSION.html#o5">ExtensionFlags</a> &amp;
00073             (<a class="code" href="../../d0/d5/io_8h.html#a138">DOE_UNLOAD_PENDING</a> | <a class="code" href="../../d0/d5/io_8h.html#a139">DOE_DELETE_PENDING</a> | <a class="code" href="../../d0/d5/io_8h.html#a140">DOE_REMOVE_PENDING</a> | <a class="code" href="../../d0/d5/io_8h.html#a141">DOE_REMOVE_PROCESSED</a> | <a class="code" href="../../d0/d5/io_8h.html#a142">DOE_START_PENDING</a>) ||
00074         parseDeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o8">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a128">DO_DEVICE_INITIALIZING</a>) {
00075 
00076         status = STATUS_NO_SUCH_DEVICE;
00077 
00078     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (parseDeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o8">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a124">DO_EXCLUSIVE</a> &amp;&amp;
00079                parseDeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o2">ReferenceCount</a> != 0 &amp;&amp;
00080                op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o6">RelatedFileObject</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> &amp;&amp;
00081                !(op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o13">Options</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a111">IO_ATTACH_DEVICE</a>)) {
00082 
00083         status = STATUS_ACCESS_DENIED;
00084 
00085     } <span class="keywordflow">else</span> {
00086 
00087         parseDeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o2">ReferenceCount</a>++;
00088         status = STATUS_SUCCESS;
00089 
00090     }
00091 
00092     ExReleaseFastLock( &amp;IopDatabaseLock, irql );
00093 
00094     <span class="keywordflow">return</span> status;
00095 }
</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="parse.c::IopCheckVpbMounted" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="../../d7/d7/struct__VPB.html">PVPB</a> IopCheckVpbMounted           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d3/d7/struct__OPEN__PACKET.html">POPEN_PACKET</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>op</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>parseDeviceObject</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN OUT PUNICODE_STRING&nbsp;</td>
          <td class="mdname" nowrap> <em>RemainingName</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PNTSTATUS&nbsp;</td>
          <td class="mdname" nowrap> <em>status</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d2/parse_8c-source.html#l00098">98</a> of file <a class="el" href="../../d5/d2/parse_8c-source.html">parse.c</a>.
<p>
References <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01070">_VPB::Flags</a>, <a class="el" href="../../d3/d3/internal_8c-source.html#l04022">IopDecrementDeviceObjectRef()</a>, <a class="el" href="../../d3/d3/internal_8c-source.html#l04282">IopMountVolume()</a>, <a class="el" href="../../d4/d4/iodata_8c-source.html#l00042">IopVpbSpinLock</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01075">_VPB::ReferenceCount</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01055">VPB_LOCKED</a>, and <a class="el" href="../../d1/d4/io_8h-source.html#l01054">VPB_MOUNTED</a>.
<p>
Referenced by <a class="el" href="../../d5/d2/parse_8c-source.html#l00202">IopParseDevice()</a>.
<p>
<pre class="fragment"><div>00104 {
00105     <a class="code" href="../../d7/d7/struct__VPB.html">PVPB</a> vpb;
00106     KIRQL irql;
00107     BOOLEAN alertable;
00108 
00109     <span class="comment">//</span>
00110     <span class="comment">// Loop here until the VPB_MOUNTED test can be passed while holding the</span>
00111     <span class="comment">// VPB spinlock.  After the mount succeeds, it is still necessary to acquire</span>
00112     <span class="comment">// the spinlock to check that the VPB (which may be different from the one</span>
00113     <span class="comment">// before the mount) is still mounted.  If it is, then its reference count</span>
00114     <span class="comment">// is incremented before releasing the spinlock.</span>
00115     <span class="comment">//</span>
00116 
00117     ExAcquireFastLock( &amp;IopVpbSpinLock, &amp;irql );
00118 
00119     alertable = (op-&gt;CreateOptions &amp; FILE_SYNCHRONOUS_IO_ALERT) ? <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> : <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00120     <span class="keywordflow">while</span> (!(parseDeviceObject-&gt;Vpb-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a116">VPB_MOUNTED</a>)) {
00121 
00122         ExReleaseFastLock( &amp;IopVpbSpinLock, irql );
00123 
00124         <span class="comment">//</span>
00125         <span class="comment">// Try to mount the volume, allowing only RAW to perform the mount if</span>
00126         <span class="comment">// this is a DASD open.</span>
00127         <span class="comment">//</span>
00128 
00129         *status = <a class="code" href="../../d0/d6/iop_8h.html#a195">IopMountVolume</a>( parseDeviceObject,
00130                                  (BOOLEAN) (!RemainingName-&gt;Length &amp;&amp; !op-&gt;RelatedFileObject),
00131                                  FALSE,
00132                  alertable );
00133         <span class="comment">//</span>
00134         <span class="comment">// If the mount operation was unsuccessful, adjust the reference</span>
00135         <span class="comment">// count for the device and return now.</span>
00136         <span class="comment">//</span>
00137 
00138         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( *status ) || *status == STATUS_USER_APC || *status == STATUS_ALERTED) {
00139 
00140             <a class="code" href="../../d0/d6/iop_8h.html#a161">IopDecrementDeviceObjectRef</a>( parseDeviceObject, FALSE );
00141 
00142             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( *status )) {
00143                 <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00144             } <span class="keywordflow">else</span> {
00145                 *status = STATUS_WRONG_VOLUME;
00146                 <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00147             }
00148         }
00149 
00150         ExAcquireFastLock( &amp;IopVpbSpinLock, &amp;irql );
00151     }
00152 
00153     <span class="comment">//</span>
00154     <span class="comment">// Synchronize here with the file system to make sure that volumes do not</span>
00155     <span class="comment">// go away while en route to the FS.</span>
00156     <span class="comment">//</span>
00157 
00158     vpb = parseDeviceObject-&gt;Vpb;
00159 
00160     <span class="comment">//</span>
00161     <span class="comment">//  Check here that the VPB is not locked.</span>
00162     <span class="comment">//</span>
00163 
00164     <span class="keywordflow">if</span> (vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o2">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a117">VPB_LOCKED</a>) {
00165 
00166         *status = STATUS_ACCESS_DENIED;
00167         vpb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00168 
00169     } <span class="keywordflow">else</span> {
00170 
00171         vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o7">ReferenceCount</a> += 1;
00172     }
00173 
00174     ExReleaseFastLock( &amp;IopVpbSpinLock, irql );
00175 
00176     <span class="keywordflow">return</span> vpb;
00177 }
</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="parse.c::IopDereferenceVpbAndFree" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID IopDereferenceVpbAndFree           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d7/d7/struct__VPB.html">PVPB</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>Vpb</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d2/parse_8c-source.html#l00180">180</a> of file <a class="el" href="../../d5/d2/parse_8c-source.html">parse.c</a>.
<p>
References <a class="el" href="../../d7/d2/cmwraper_8c-source.html#l00304">ExFreePool()</a>, <a class="el" href="../../d4/d4/iodata_8c-source.html#l00042">IopVpbSpinLock</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, and <a class="el" href="../../d1/d4/io_8h-source.html#l01056">VPB_PERSISTENT</a>.
<p>
Referenced by <a class="el" href="../../d5/d2/parse_8c-source.html#l00202">IopParseDevice()</a>.
<p>
<pre class="fragment"><div>00183 {
00184     KIRQL irql;
00185     <a class="code" href="../../d7/d7/struct__VPB.html">PVPB</a> vpb = (<a class="code" href="../../d7/d7/struct__VPB.html">PVPB</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00186 
00187     ExAcquireFastLock( &amp;IopVpbSpinLock, &amp;irql );
00188     Vpb-&gt;ReferenceCount--;
00189     <span class="keywordflow">if</span> ((Vpb-&gt;ReferenceCount == 0) &amp;&amp;
00190         (Vpb-&gt;RealDevice-&gt;Vpb != Vpb) &amp;&amp;
00191         !(Vpb-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a118">VPB_PERSISTENT</a>)) {
00192         vpb = Vpb;
00193     }
00194     ExReleaseFastLock( &amp;IopVpbSpinLock, irql );
00195     <span class="keywordflow">if</span> (vpb) {
00196         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( vpb );
00197     }
00198 }
</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="parse.c::IopParseDevice" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS IopParseDevice           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>ParseObject</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>ObjectType</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d2/d5/struct__ACCESS__STATE.html">PACCESS_STATE</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>AccessState</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d0/d9/ntosdef_8h.html#a39">KPROCESSOR_MODE</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>AccessMode</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Attributes</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN OUT PUNICODE_STRING&nbsp;</td>
          <td class="mdname" nowrap> <em>CompleteName</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN OUT PUNICODE_STRING&nbsp;</td>
          <td class="mdname" nowrap> <em>RemainingName</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN OUT PVOID Context&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PSECURITY_QUALITY_OF_SERVICE <a class="el" href="../../d8/d0/ctlpcqos_8c.html#a9">SecurityQos</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PVOID *&nbsp;</td>
          <td class="mdname" nowrap> <em>Object</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d2/parse_8c-source.html#l00202">202</a> of file <a class="el" href="../../d5/d2/parse_8c-source.html">parse.c</a>.
<p>
References <a class="el" href="../../d1/d4/io_8h-source.html#l01020">_IO_SECURITY_CONTEXT::AccessState</a>, <a class="el" href="../../d1/d5/iop_8h-source.html#l00221">_OPEN_PACKET::AllocationSize</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00086">APC_LEVEL</a>, <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d0/d2/struct__IRP.html#o7">_IRP::AssociatedIrp</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01181">_DEVICE_OBJECT::AttachedDevice</a>, <a class="el" href="../../d1/d5/iop_8h-source.html#l00235">_OPEN_PACKET::BasicInformation</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00313">_OBJECT_HEADER::Body</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01661">_IRP::Cancel</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01701">_IRP::CancelRoutine</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01185">_DEVICE_OBJECT::Characteristics</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02031">_IO_STACK_LOCATION::Control</a>, <a class="el" href="../../d4/d3/parse_8c.html#a2">COPY_ATTRIBUTES</a>, <a class="el" href="../../d1/d5/iop_8h-source.html#l00248">_OPEN_PACKET::CreateFileType</a>, <a class="el" href="../../d0/d5/io_8h.html#a600a407">CreateFileTypeNamedPipe</a>, <a class="el" href="../../d0/d5/io_8h.html#a600a406">CreateFileTypeNone</a>, <a class="el" href="../../d1/d5/iop_8h-source.html#l00222">_OPEN_PACKET::CreateOptions</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01655">_IRP::CurrentLocation</a>, <a class="el" href="../../d1/d5/iop_8h-source.html#l00283">_OPEN_PACKET::DeleteOnly</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01021">_IO_SECURITY_CONTEXT::DesiredAccess</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02488">_IO_STACK_LOCATION::DeviceObject</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01072">_VPB::DeviceObject</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01517">_FILE_OBJECT::DeviceObject</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01188">_DEVICE_OBJECT::DeviceType</a>, <a class="el" href="../../d1/d5/iop_8h-source.html#l00228">_OPEN_PACKET::Disposition</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01179">_DEVICE_OBJECT::DriverObject</a>, <a class="el" href="../../d1/d5/iop_8h-source.html#l00225">_OPEN_PACKET::EaBuffer</a>, <a class="el" href="../../d1/d5/iop_8h-source.html#l00226">_OPEN_PACKET::EaLength</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01540">_FILE_OBJECT::Event</a>, <a class="el" href="../../d6/d7/ex_8h-source.html#l02474">ExAcquireResourceShared</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00126">ExAllocatePool</a>, <a class="el" href="../../d6/d7/ex_8h-source.html#l00253">ExAllocatePoolWithTag</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00055">EXCEPTION_EXECUTE_HANDLER</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00623">Executive</a>, <a class="el" href="../../d7/d2/cmwraper_8c-source.html#l00304">ExFreePool()</a>, <a class="el" href="../../d5/d8/ex_8h.html#a235">ExInterlockedAddUlong()</a>, <a class="el" href="../../d6/d7/ex_8h-source.html#l02393">ExReleaseResource</a>, <a class="el" href="../../d1/d5/iop_8h-source.html#l00256">_OPEN_PACKET::ExtraCreateParameters</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01403">_DRIVER_OBJECT::FastIoDispatch</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l00946">_FAST_IO_DISPATCH::FastIoQueryBasicInfo</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l00956">_FAST_IO_DISPATCH::FastIoQueryNetworkOpenInfo</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l00966">_FAST_IO_DISPATCH::FastIoQueryOpen</a>, <a class="el" href="../../d0/d5/io_8h.html#a353">FILE_OBJECT</a>, <a class="el" href="../../d1/d5/iop_8h-source.html#l00223">_OPEN_PACKET::FileAttributes</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01534">_FILE_OBJECT::FileName</a>, <a class="el" href="../../d1/d5/iop_8h-source.html#l00208">_OPEN_PACKET::FileObject</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02494">_IO_STACK_LOCATION::FileObject</a>, <a class="el" href="../../d1/d5/iop_8h-source.html#l00209">_OPEN_PACKET::FinalStatus</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02030">_IO_STACK_LOCATION::Flags</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01602">_IRP::Flags</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01533">_FILE_OBJECT::Flags</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01492">FO_ALERTABLE_IO</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01501">FO_DIRECT_DEVICE_OPEN</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01511">FO_FILE_OPEN_CANCELLED</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01493">FO_NO_INTERMEDIATE_BUFFERING</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01507">FO_OPENED_CASE_SENSITIVE</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01510">FO_RANDOM_ACCESS</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01495">FO_SEQUENTIAL_ONLY</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01491">FO_SYNCHRONOUS_IO</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01512">FO_VOLUME_OPEN</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01494">FO_WRITE_THROUGH</a>, <a class="el" href="../../d1/d5/iop_8h-source.html#l00291">_OPEN_PACKET::FullAttributes</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01022">_IO_SECURITY_CONTEXT::FullCreateOptions</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00168">_OBJECT_TYPE_INITIALIZER::GenericMapping</a>, <a class="el" href="../../d5/d8/ke_8h-source.html#l00413">_KEVENT::Header</a>, <a class="el" href="../../d1/d5/iop_8h-source.html#l00210">_OPEN_PACKET::Information</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l00233">IO_FORCE_ACCESS_CHECK</a>, <a class="el" href="../../d5/d2/parse_8c-source.html#l00037">IO_MAX_REMOUNT_REPARSE_ATTEMPTS</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l00251">IO_REMOUNT</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l00250">IO_REPARSE</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l00039">IO_TYPE_FILE</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l00042">IO_TYPE_OPEN_PACKET</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02865">IoCallDriver</a>, <a class="el" href="../../d6/d7/fssup_8c-source.html#l00044">IoFileObjectType</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l06632">IoFreeIrp()</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l06786">IoGetAttachedDevice()</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l03398">IoGetNextIrpStackLocation</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l07247">IoGetRelatedDeviceObject()</a>, <a class="el" href="../../d1/d5/iop_8h-source.html#l00604">IopAllocateIrp</a>, <a class="el" href="../../d5/d2/parse_8c-source.html#l02048">IopCheckBackupRestorePrivilege()</a>, <a class="el" href="../../d5/d2/parse_8c-source.html#l00047">IopCheckDeviceAndDriver()</a>, <a class="el" href="../../d5/d2/parse_8c-source.html#l00098">IopCheckVpbMounted()</a>, <a class="el" href="../../d3/d3/internal_8c-source.html#l04022">IopDecrementDeviceObjectRef()</a>, <a class="el" href="../../d4/d0/objsup_8c-source.html#l00417">IopDeleteFile()</a>, <a class="el" href="../../d1/d5/iop_8h-source.html#l00758">IopDequeueThreadIrp</a>, <a class="el" href="../../d5/d2/parse_8c-source.html#l00180">IopDereferenceVpbAndFree()</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l08130">IopDoNameTransmogrify()</a>, <a class="el" href="../../d1/d5/iop_8h-source.html#l01103">IopQueueThreadIrp</a>, <a class="el" href="../../d4/d4/iodata_8c-source.html#l00074">IopSecurityResource</a>, <a class="el" href="../../d4/d4/iodata_8c-source.html#l00042">IopVpbSpinLock</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l08628">IoQueryFileInformation()</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l03977">IoSetNextIrpStackLocation</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01635">_IRP::IoStatus</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01554">IRP_BUFFERED_IO</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01558">IRP_CREATE_OPERATION</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01555">IRP_DEALLOCATE_BUFFER</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01564">IRP_DEFER_IO_COMPLETION</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l00055">IRP_MJ_CREATE</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l00074">IRP_MJ_CREATE_MAILSLOT</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l00056">IRP_MJ_CREATE_NAMED_PIPE</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01552">IRP_SYNCHRONOUS_API</a>, <a class="el" href="../../d5/d8/ke_8h-source.html#l01598">KeEnterCriticalRegion</a>, <a class="el" href="../../d5/d8/ke_8h-source.html#l01066">KeInitializeEvent</a>, <a class="el" href="../../d5/d8/ke_8h-source.html#l01628">KeLeaveCriticalRegion</a>, <a class="el" href="../../d9/d5/verifier_8c.html#a117">KeLowerIrql()</a>, <a class="el" href="../../d9/d5/verifier_8c.html#a116">KeRaiseIrql()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00624">KernelMode</a>, <a class="el" href="../../d2/d6/wait_8c-source.html#l00810">KeWaitForSingleObject()</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00174">KPROCESSOR_MODE</a>, <a class="el" href="../../d3/d9/aw_8h-source.html#l00031">L</a>, <a class="el" href="../../d1/d5/iop_8h-source.html#l00300">_OPEN_PACKET::LocalFileObject</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02028">_IO_STACK_LOCATION::MajorFunction</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01596">_IRP::MdlAddress</a>, <a class="el" href="../../d1/d5/iop_8h-source.html#l00242">_OPEN_PACKET::NetworkInformation</a>, <a class="el" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d7/d9/obcreate_8c-source.html#l00055">ObCreateObject()</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00494">ObDereferenceObject</a>, <a class="el" href="../../d1/d5/iop_8h-source.html#l00188">_DUMMY_FILE_OBJECT::ObjectHeader</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00514">ObReferenceObject</a>, <a class="el" href="../../d1/d5/iop_8h-source.html#l00196">OPEN_PACKET_PATTERN</a>, <a class="el" href="../../d1/d5/iop_8h-source.html#l00227">_OPEN_PACKET::Options</a>, <a class="el" href="../../d0/d2/struct__IRP.html#o24">_IRP::Overlay</a>, <a class="el" href="../../d1/d5/iop_8h-source.html#l00267">_OPEN_PACKET::Override</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>, <a class="el" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02069">_IO_STACK_LOCATION::Parameters</a>, <a class="el" href="../../d1/d5/iop_8h-source.html#l00211">_OPEN_PACKET::ParseCheck</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l00547">PDRIVER_CANCEL</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01648">_IRP::PendingReturned</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00196">PKNORMAL_ROUTINE</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00297">_OBJECT_HEADER::PointerCount</a>, <a class="el" href="../../d2/d8/ps_8h-source.html#l00645">PsGetCurrentThread</a>, <a class="el" href="../../d1/d5/iop_8h-source.html#l00275">_OPEN_PACKET::QueryOnly</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01075">_VPB::ReferenceCount</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01524">_FILE_OBJECT::RelatedFileObject</a>, <a class="el" href="../../d1/d5/iop_8h-source.html#l00212">_OPEN_PACKET::RelatedFileObject</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01641">_IRP::RequestorMode</a>, <a class="el" href="../../d5/d2/parse_8c-source.html#l00032">RoundNameSize</a>, <a class="el" href="../../d7/d5/nls_8c-source.html#l01763">RtlCopyUnicodeString()</a>, <a class="el" href="../../d9/d5/sertl_8c-source.html#l03381">RtlMapGenericMask()</a>, <a class="el" href="../../d1/d4/se_8h-source.html#l00085">SE_BACKUP_PRIVILEGES_CHECKED</a>, <a class="el" href="../../d1/d3/accessck_8c-source.html#l03323">SeAccessCheck()</a>, <a class="el" href="../../d3/d4/seastate_8c-source.html#l00434">SeAppendPrivileges()</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01204">_DEVICE_OBJECT::SecurityDescriptor</a>, <a class="el" href="../../d8/d9/ctlnpqos_8c-source.html#l00037">SecurityQos</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01019">_IO_SECURITY_CONTEXT::SecurityQos</a>, <a class="el" href="../../d1/d3/accessck_8c-source.html#l03871">SeFastTraverseCheck()</a>, <a class="el" href="../../d1/d3/accessck_8c-source.html#l03294">SeFreePrivileges()</a>, <a class="el" href="../../d1/d7/subject_8c-source.html#l00115">SeLockSubjectContext()</a>, <a class="el" href="../../d4/d4/seaudit_8c-source.html#l02765">SeOpenObjectAuditAlarm()</a>, <a class="el" href="../../d3/d4/seastate_8c-source.html#l00396">SeSetAccessStateGenericMapping()</a>, <a class="el" href="../../d4/d4/seaudit_8c-source.html#l03429">SeTraverseAuditAlarm()</a>, <a class="el" href="../../d1/d7/subject_8c-source.html#l00159">SeUnlockSubjectContext()</a>, <a class="el" href="../../d1/d5/iop_8h-source.html#l00224">_OPEN_PACKET::ShareAccess</a>, <a class="el" href="../../d5/d8/ke_8h-source.html#l00262">_DISPATCHER_HEADER::SignalState</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01516">_FILE_OBJECT::Size</a>, <a class="el" href="../../d1/d5/iop_8h-source.html#l00207">_OPEN_PACKET::Size</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l00942">_FAST_IO_DISPATCH::SizeOfFastIoDispatch</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01867">SL_CASE_SENSITIVE</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01654">_IRP::StackCount</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01189">_DEVICE_OBJECT::StackSize</a>, <a class="el" href="../../d0/d2/struct__IRP.html#o38">_IRP::Tail</a>, <a class="el" href="../../d1/d4/se_8h-source.html#l00072">TOKEN_HAS_TRAVERSE_PRIVILEGE</a>, <a class="el" href="../../d1/d4/se_8h-source.html#l00076">TOKEN_IS_RESTRICTED</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01515">_FILE_OBJECT::Type</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00302">_OBJECT_HEADER::Type</a>, <a class="el" href="../../d1/d5/iop_8h-source.html#l00206">_OPEN_PACKET::Type</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00196">_OBJECT_TYPE::TypeInfo</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01687">_IRP::UserEvent</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01686">_IRP::UserIosb</a>, <a class="el" href="../../d0/d9/ntosdef_8h.html#a76a70">UserMode</a>, <a class="el" href="../../d2/d7/hal_8h.html#a212">VOID()</a>, and <a class="el" href="../../d1/d4/io_8h-source.html#l01518">_FILE_OBJECT::Vpb</a>.
<p>
Referenced by <a class="el" href="../../d0/d5/ioinit_8c-source.html#l01936">IopCreateObjectTypes()</a>, and <a class="el" href="../../d5/d2/parse_8c-source.html#l01690">IopParseFile()</a>.
<p>
<pre class="fragment"><div>00217                    :
00218 
00219     This routine interfaces to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> NT Object <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a79">Manager</a>.  It <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> invoked when
00220     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> object system <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> given <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> name of an entity to create or open and <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
00221     name translates to a device object.  This routine <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> specified as <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> parse
00222     routine <span class="keywordflow">for</span> all device objects.
00223 
00224     In <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> normal <span class="keywordflow">case</span> of an <a class="code" href="../../d6/d9/restrfil_8c.html#a30">NtCreateFile</a>, <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> user specifies either <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> name
00225     of a device or of a <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a>.  In <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> former situation, <span class="keyword">this</span> routine <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> invoked
00226     with a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> device and a null (<span class="stringliteral">""</span>) string.  For this case, the
00227     routine simply allocates an <a class="code" href="../../d0/d2/struct__IRP.html">IRP</a>, fills it in, and passes it to the driver
00228     for the device.  The driver will then perform whatever rudimentary functions
00229     are necessary and will return a status code indicating whether an error was
00230     incurred.  This status code is remembered in the Open Packet (OP).
00231 
00232     In the latter situation, the name string to be opened/created is non-null.
00233     That is, it contains the remainder of the pathname to the file that is to
00234     be opened or created.  For this case, the routine allocates an IRP, fills
00235     it in, and passes it to the driver for the device.  The driver may then
00236     need to take further action or it may complete the request immediately.  If
00237     it needs to perform some work asynchronously, then it can queue the request
00238     and return a status of STATUS_PENDING.  This allows this routine and its
00239     caller to return to the user so that he can continue.  Otherwise, the open/
00240     create is basically finished.
00241 
00242     If the driver supports symbolic links, then it is also possible for the
00243     driver to return a new name.  This name will be returned to the Object
00244     Manager as a new name to look up.  The parsing will then begin again from
00245     the start.
00246 
00247     It is also the responsibility of this routine to create a file object for
00248     the file, if the name specifies a file.  The file object's address is
00249     returned to the NtCreateFile service through the OP.
00250 
00251 Arguments:
00252 
00253     ParseObject - Pointer to the device object the name translated into.
00254 
00255     ObjectType - Type of the object being opened.
00256 
00257     AccessState - Running security access state information for operation.
00258 
00259     AccessMode - Access mode of the original caller.
00260 
00261     Attributes - Attributes to be applied to the object.
00262 
00263     CompleteName - Complete name of the object.
00264 
00265     RemainingName - Remaining name of the object.
00266 
00267     Context - Pointer to an Open Packet (OP) from NtCreateFile service.
00268 
00269     SecurityQos - Optional security quality of service indicator.
00270 
00271     Object - The address of a variable to receive the created file object, if
00272         any.
00273 
00274 Return Value:
00275 
00276     The function return value is one of the following:
00277 
00278         a)  Success - This indicates that the function succeeded and the object
00279             parameter contains the address of the created file object.
00280 
00281         b)  Error - This indicates that the file was not found or created and
00282             no file object was created.
00283 
00284         c)  Reparse - This indicates that the remaining name string has been
00285             replaced by a new name that is to be parsed.
00286 
00287 --*/
00288 
00289 {
00290 
00291 <span class="preprocessor">#define COPY_ATTRIBUTES( n, b, s ) {                                    \</span>
00292 <span class="preprocessor">        (n)-&gt;CreationTime.QuadPart = (b)-&gt;CreationTime.QuadPart;        \</span>
00293 <span class="preprocessor">        (n)-&gt;LastAccessTime.QuadPart = (b)-&gt;LastAccessTime.QuadPart;    \</span>
00294 <span class="preprocessor">        (n)-&gt;LastWriteTime.QuadPart = (b)-&gt;LastWriteTime.QuadPart;      \</span>
00295 <span class="preprocessor">        (n)-&gt;ChangeTime.QuadPart = (b)-&gt;ChangeTime.QuadPart;            \</span>
00296 <span class="preprocessor">        (n)-&gt;AllocationSize.QuadPart = (s)-&gt;AllocationSize.QuadPart;    \</span>
00297 <span class="preprocessor">        (n)-&gt;EndOfFile.QuadPart = (s)-&gt;EndOfFile.QuadPart;              \</span>
00298 <span class="preprocessor">        (n)-&gt;FileAttributes = (b)-&gt;FileAttributes; }</span>
00299 <span class="preprocessor"></span>
00300     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
00301     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpSp;
00302     <a class="code" href="../../d3/d7/struct__OPEN__PACKET.html">POPEN_PACKET</a> op;
00303     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> fileObject;
00304     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
00305     IO_STATUS_BLOCK ioStatus;
00306     <a class="code" href="../../d1/d5/struct__IO__SECURITY__CONTEXT.html">IO_SECURITY_CONTEXT</a> securityContext;
00307     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> deviceObject;
00308     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> parseDeviceObject;
00309     BOOLEAN directDeviceOpen;
00310     <a class="code" href="../../d7/d7/struct__VPB.html">PVPB</a> vpb;
00311     ACCESS_MASK desiredAccess;
00312     <a class="code" href="../../d0/d1/struct__DUMMY__FILE__OBJECT.html">PDUMMY_FILE_OBJECT</a> localFileObject;
00313     BOOLEAN realFileObjectRequired;
00314     <a class="code" href="../../d0/d9/ntosdef_8h.html#a39">KPROCESSOR_MODE</a> modeForPrivilegeCheck;
00315     ULONG retryCount = 0;
00316     BOOLEAN  relativeVolumeOpen = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;     <span class="comment">// True if opening a filesystem volume</span>
00317 
00318     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00319 
00320 reparse_loop:
00321 
00322     <span class="comment">//</span>
00323     <span class="comment">// Assume failure by setting the returned object pointer to NULL.</span>
00324     <span class="comment">//</span>
00325 
00326     *Object = (PVOID) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00327 
00328     <span class="comment">//</span>
00329     <span class="comment">// Get the address of the Open Packet (OP).</span>
00330     <span class="comment">//</span>
00331 
00332     op = Context;
00333 
00334     <span class="comment">//</span>
00335     <span class="comment">// Ensure that this routine is actually being invoked because someone is</span>
00336     <span class="comment">// attempting to open a device or a file through NtCreateFile.  This code</span>
00337     <span class="comment">// must be invoked from there (as opposed to some other random object</span>
00338     <span class="comment">// create or open routine).</span>
00339     <span class="comment">//</span>
00340 
00341     <span class="keywordflow">if</span> (op == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ||
00342         op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o0">Type</a> != <a class="code" href="../../d0/d5/io_8h.html#a7">IO_TYPE_OPEN_PACKET</a> ||
00343         op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o1">Size</a> != <span class="keyword">sizeof</span>( <a class="code" href="../../d3/d7/struct__OPEN__PACKET.html">OPEN_PACKET</a> )) {
00344 
00345         <span class="keywordflow">return</span> STATUS_OBJECT_TYPE_MISMATCH;
00346     }
00347 
00348     <span class="comment">//</span>
00349     <span class="comment">// Obtain a pointer to the parse object as a device object, which is the</span>
00350     <span class="comment">// actual type of the object anyway.</span>
00351     <span class="comment">//</span>
00352 
00353     parseDeviceObject = (<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>) ParseObject;
00354 
00355     <span class="comment">//</span>
00356     <span class="comment">// If this is a relative open, then get the device on which the file</span>
00357     <span class="comment">// is really being opened from the related file object and use that for</span>
00358     <span class="comment">// the remainder of this function and for all operations performed on</span>
00359     <span class="comment">// the file object that is about to be created.</span>
00360     <span class="comment">//</span>
00361 
00362     <span class="keywordflow">if</span> (op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o6">RelatedFileObject</a>) {
00363         parseDeviceObject = op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o6">RelatedFileObject</a>-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o2">DeviceObject</a>;
00364     }
00365 
00366     <span class="comment">//</span>
00367     <span class="comment">// Make sure that the device and its driver are really there and they are</span>
00368     <span class="comment">// going to stay there.  The object itself cannot go away just yet because</span>
00369     <span class="comment">// the object management system has performed a reference which bumps the</span>
00370     <span class="comment">// count of the number of reasons why the object must stick around.</span>
00371     <span class="comment">// However, the driver could be attempting to unload itself, so perform</span>
00372     <span class="comment">// this check.  If the driver is being unloaded, then set the final status</span>
00373     <span class="comment">// of the operation to "No such device" and return with a NULL file object</span>
00374     <span class="comment">// pointer.</span>
00375     <span class="comment">//</span>
00376     <span class="comment">// Note that it is possible to "open" an exclusive device more than once</span>
00377     <span class="comment">// provided that the caller is performing a relative open.  This feature</span>
00378     <span class="comment">// is how users "allocate" a device, and then use it to perform operations.</span>
00379     <span class="comment">//</span>
00380 
00381     status = <a class="code" href="../../d4/d3/parse_8c.html#a3">IopCheckDeviceAndDriver</a>( op, parseDeviceObject );
00382 
00383     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status)) {
00384         <span class="keywordflow">return</span> op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o3">FinalStatus</a> = status;
00385     }
00386 
00387     <span class="comment">//</span>
00388     <span class="comment">// Since ObOpenObjectByName is called without being passed</span>
00389     <span class="comment">// any object type information, we need to map the generic</span>
00390     <span class="comment">// bits in the DesiredAccess mask here.  We also need to save</span>
00391     <span class="comment">// the object's generic mapping in the access state structure</span>
00392     <span class="comment">// here, because this is the earliest opportunity we have</span>
00393     <span class="comment">// to do so.</span>
00394     <span class="comment">//</span>
00395 
00396     <a class="code" href="../../d8/d6/sertl_8c.html#a70">RtlMapGenericMask</a>( &amp;AccessState-&gt;RemainingDesiredAccess,
00397                        &amp;<a class="code" href="../../d5/d8/fssup_8c.html#a3">IoFileObjectType</a>-&gt;<a class="code" href="../../d3/d6/struct__OBJECT__TYPE.html#o9">TypeInfo</a>.<a class="code" href="../../d5/d6/struct__OBJECT__TYPE__INITIALIZER.html#o4">GenericMapping</a> );
00398 
00399     <a class="code" href="../../d8/d6/sertl_8c.html#a70">RtlMapGenericMask</a>( &amp;AccessState-&gt;OriginalDesiredAccess,
00400                        &amp;<a class="code" href="../../d5/d8/fssup_8c.html#a3">IoFileObjectType</a>-&gt;<a class="code" href="../../d3/d6/struct__OBJECT__TYPE.html#o9">TypeInfo</a>.<a class="code" href="../../d5/d6/struct__OBJECT__TYPE__INITIALIZER.html#o4">GenericMapping</a> );
00401 
00402     <a class="code" href="../../d2/d5/seastate_8c.html#a4">SeSetAccessStateGenericMapping</a>( AccessState, &amp;<a class="code" href="../../d5/d8/fssup_8c.html#a3">IoFileObjectType</a>-&gt;<a class="code" href="../../d3/d6/struct__OBJECT__TYPE.html#o9">TypeInfo</a>.<a class="code" href="../../d5/d6/struct__OBJECT__TYPE__INITIALIZER.html#o4">GenericMapping</a> );
00403 
00404     desiredAccess = AccessState-&gt;RemainingDesiredAccess;
00405 
00406     <span class="comment">//</span>
00407     <span class="comment">// Compute the previous mode to be passed in to the privilege check</span>
00408     <span class="comment">//</span>
00409 
00410     <span class="keywordflow">if</span> (AccessMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a> || op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o13">Options</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a104">IO_FORCE_ACCESS_CHECK</a>) {
00411         modeForPrivilegeCheck = <a class="code" href="../../d0/d9/ntosdef_8h.html#a76a70">UserMode</a>;
00412     } <span class="keywordflow">else</span> {
00413         modeForPrivilegeCheck = <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>;
00414     }
00415 
00416     <a class="code" href="../../d4/d3/parse_8c.html#a9">IopCheckBackupRestorePrivilege</a>( AccessState,
00417                                     &amp;op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o8">CreateOptions</a>,
00418                                     modeForPrivilegeCheck,
00419                                     op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o14">Disposition</a>
00420                                     );
00421 
00422     <span class="comment">//</span>
00423     <span class="comment">// If this is not the first time through here for this object, and the</span>
00424     <span class="comment">// object itself is being opened, then the desired access must also</span>
00425     <span class="comment">// include the previously granted access from the last pass.  Likewise,</span>
00426     <span class="comment">// if the privileges have been checked already, then this is another</span>
00427     <span class="comment">// pass through for a file, so add in the previously granted access.</span>
00428     <span class="comment">//</span>
00429 
00430     <span class="keywordflow">if</span> ((op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o19">Override</a> &amp;&amp; !RemainingName-&gt;Length) ||
00431         AccessState-&gt;Flags &amp; <a class="code" href="../../d0/d5/se_8h.html#a6">SE_BACKUP_PRIVILEGES_CHECKED</a>) {
00432         desiredAccess |= AccessState-&gt;PreviouslyGrantedAccess;
00433     }
00434 
00435     <span class="comment">//</span>
00436     <span class="comment">// If its a filesystem volume open and we are doing a relative open to it</span>
00437     <span class="comment">// then do the access check. Note that relative opens can be nested and we propagate</span>
00438     <span class="comment">// the fact that the relative open is for a volume using the FO_VOLUME_OPEN flag.</span>
00439     <span class="comment">//</span>
00440 
00441     <span class="keywordflow">if</span> (op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o6">RelatedFileObject</a>) {
00442         <span class="keywordflow">if</span> ((op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o6">RelatedFileObject</a>-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a172">FO_VOLUME_OPEN</a>) &amp;&amp; RemainingName-&gt;Length == 0) {
00443             relativeVolumeOpen = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00444         }
00445     }
00446 
00447     <span class="comment">//</span>
00448     <span class="comment">// Now determine what type of security check should be made.  This is</span>
00449     <span class="comment">// based on whether the remaining name string is null.  If it is null,</span>
00450     <span class="comment">// then the device itself is being opened, so a full security check is</span>
00451     <span class="comment">// performed.  Otherwise, only a check to ensure that the caller can</span>
00452     <span class="comment">// traverse the device object is made.  Note that these checks are only</span>
00453     <span class="comment">// made if the caller's mode is user, or if access checking is being</span>
00454     <span class="comment">// forced.  Note also that if an access check was already made on the</span>
00455     <span class="comment">// device itself, and this code is being executed again because of a</span>
00456     <span class="comment">// reparse, then the access check need not be made the second time</span>
00457     <span class="comment">// around.</span>
00458     <span class="comment">//</span>
00459 
00460 
00461     <span class="keywordflow">if</span> ((AccessMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a> || op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o13">Options</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a104">IO_FORCE_ACCESS_CHECK</a>) &amp;&amp;
00462         (!op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o6">RelatedFileObject</a> || relativeVolumeOpen) &amp;&amp;
00463         !op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o19">Override</a>) {
00464 
00465         BOOLEAN subjectContextLocked = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00466         BOOLEAN accessGranted;
00467         ACCESS_MASK grantedAccess;
00468 
00469         <span class="comment">//</span>
00470         <span class="comment">// The caller's mode is either user or access checking is being</span>
00471         <span class="comment">// forced.  Perform the appropriate access check on the device</span>
00472         <span class="comment">// object.</span>
00473         <span class="comment">//</span>
00474 
00475         <span class="keywordflow">if</span> (!RemainingName-&gt;Length) {
00476 
00477             UNICODE_STRING nameString;
00478             PPRIVILEGE_SET privileges = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00479 
00480             <span class="comment">//</span>
00481             <span class="comment">// The device itself is being opened.  Make a full security check</span>
00482             <span class="comment">// to ensure that the caller has the appropriate access.</span>
00483             <span class="comment">//</span>
00484 
00485             <a class="code" href="../../d4/d9/ke_8h.html#a28">KeEnterCriticalRegion</a>( );
00486             <a class="code" href="../../d5/d8/ex_8h.html#a69">ExAcquireResourceShared</a>( &amp;IopSecurityResource, TRUE );
00487 
00488             <a class="code" href="../../d0/d8/subject_8c.html#a1">SeLockSubjectContext</a>( &amp;AccessState-&gt;SubjectSecurityContext );
00489             subjectContextLocked = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00490 
00491             accessGranted = <a class="code" href="../../d0/d4/accessck_8c.html#a18">SeAccessCheck</a>( parseDeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o21">SecurityDescriptor</a>,
00492                                            &amp;AccessState-&gt;SubjectSecurityContext,
00493                                            subjectContextLocked,
00494                                            desiredAccess,
00495                                            0,
00496                                            &amp;privileges,
00497                                            &amp;<a class="code" href="../../d5/d8/fssup_8c.html#a3">IoFileObjectType</a>-&gt;<a class="code" href="../../d3/d6/struct__OBJECT__TYPE.html#o9">TypeInfo</a>.<a class="code" href="../../d5/d6/struct__OBJECT__TYPE__INITIALIZER.html#o4">GenericMapping</a>,
00498                                            UserMode,
00499                                            &amp;grantedAccess,
00500                                            &amp;status );
00501 
00502             <span class="keywordflow">if</span> (privileges) {
00503                 (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d2/d5/seastate_8c.html#a5">SeAppendPrivileges</a>( AccessState,
00504                                            privileges );
00505                 <a class="code" href="../../d0/d4/accessck_8c.html#a17">SeFreePrivileges</a>( privileges );
00506             }
00507 
00508             <span class="keywordflow">if</span> (accessGranted) {
00509                 AccessState-&gt;PreviouslyGrantedAccess |= grantedAccess;
00510                 AccessState-&gt;RemainingDesiredAccess &amp;= ~( grantedAccess | MAXIMUM_ALLOWED );
00511                 op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o19">Override</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00512             }
00513 
00514             nameString.Length = 8;
00515             nameString.MaximumLength = 8;
00516             nameString.Buffer = <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="stringliteral">"File"</span>;
00517 
00518             <a class="code" href="../../d3/d5/seaudit_8c.html#a23">SeOpenObjectAuditAlarm</a>( &amp;nameString,
00519                                     parseDeviceObject,
00520                                     CompleteName,
00521                                     parseDeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o21">SecurityDescriptor</a>,
00522                                     AccessState,
00523                                     FALSE,
00524                                     accessGranted,
00525                                     UserMode,
00526                                     &amp;AccessState-&gt;GenerateOnClose );
00527 
00528             <a class="code" href="../../d5/d8/ex_8h.html#a66">ExReleaseResource</a>( &amp;IopSecurityResource );
00529             <a class="code" href="../../d4/d9/ke_8h.html#a29">KeLeaveCriticalRegion</a>();
00530 
00531         } <span class="keywordflow">else</span> {
00532 
00533             <span class="comment">//</span>
00534             <span class="comment">// The device is not being opened, rather, a file on the device</span>
00535             <span class="comment">// is being opened or created.  Therefore, only perform a check</span>
00536             <span class="comment">// here for traverse access to the device.</span>
00537             <span class="comment">//</span>
00538 
00539             <span class="comment">//</span>
00540             <span class="comment">// First determine if we have to perform traverse checking at all.</span>
00541             <span class="comment">// Traverse checking only needs to be done if the device being</span>
00542             <span class="comment">// traversed is a disk, or if the caller does not already have</span>
00543             <span class="comment">// traverse checking privilege.  Note that the former case is so</span>
00544             <span class="comment">// that an administrator can turn off access to the "system</span>
00545             <span class="comment">// partition", or someone would be able to install a trojan horse</span>
00546             <span class="comment">// into the system by simply replacing one of the files there with</span>
00547             <span class="comment">// something of their own.</span>
00548             <span class="comment">//</span>
00549 
00550             <span class="keywordflow">if</span> (!(AccessState-&gt;Flags &amp; <a class="code" href="../../d0/d5/se_8h.html#a1">TOKEN_HAS_TRAVERSE_PRIVILEGE</a>) ||
00551                 parseDeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o12">DeviceType</a> == FILE_DEVICE_DISK ||
00552                 parseDeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o12">DeviceType</a> == FILE_DEVICE_CD_ROM ) {
00553 
00554                 <a class="code" href="../../d4/d9/ke_8h.html#a28">KeEnterCriticalRegion</a>( );
00555                 <a class="code" href="../../d5/d8/ex_8h.html#a69">ExAcquireResourceShared</a>( &amp;IopSecurityResource, TRUE );
00556 
00557                 <span class="comment">//</span>
00558                 <span class="comment">// If the token is restricted we need to do the full</span>
00559                 <span class="comment">// access check.</span>
00560                 <span class="comment">//</span>
00561 
00562                 <span class="keywordflow">if</span> ((AccessState-&gt;Flags &amp; <a class="code" href="../../d0/d5/se_8h.html#a5">TOKEN_IS_RESTRICTED</a>) == 0) {
00563                     accessGranted = <a class="code" href="../../d0/d4/accessck_8c.html#a22">SeFastTraverseCheck</a>( parseDeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o21">SecurityDescriptor</a>,
00564                                                          FILE_TRAVERSE,
00565                                                          UserMode );
00566                 } <span class="keywordflow">else</span> {
00567                     accessGranted = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00568                 }
00569 
00570                 <span class="keywordflow">if</span> (!accessGranted) {
00571 
00572                     PPRIVILEGE_SET privileges = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00573 
00574                     <span class="comment">//</span>
00575                     <span class="comment">// The caller was not granted traverse access through the</span>
00576                     <span class="comment">// normal fast path lookup.  Perform a full-blown access</span>
00577                     <span class="comment">// check to determine whether some other ACE allows traverse</span>
00578                     <span class="comment">// access.</span>
00579                     <span class="comment">//</span>
00580 
00581                     <a class="code" href="../../d0/d8/subject_8c.html#a1">SeLockSubjectContext</a>( &amp;AccessState-&gt;SubjectSecurityContext );
00582 
00583                     subjectContextLocked = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00584 
00585                     accessGranted = <a class="code" href="../../d0/d4/accessck_8c.html#a18">SeAccessCheck</a>( parseDeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o21">SecurityDescriptor</a>,
00586                                                    &amp;AccessState-&gt;SubjectSecurityContext,
00587                                                    subjectContextLocked,
00588                                                    FILE_TRAVERSE,
00589                                                    0,
00590                                                    &amp;privileges,
00591                                                    &amp;<a class="code" href="../../d5/d8/fssup_8c.html#a3">IoFileObjectType</a>-&gt;<a class="code" href="../../d3/d6/struct__OBJECT__TYPE.html#o9">TypeInfo</a>.<a class="code" href="../../d5/d6/struct__OBJECT__TYPE__INITIALIZER.html#o4">GenericMapping</a>,
00592                                                    UserMode,
00593                                                    &amp;grantedAccess,
00594                                                    &amp;status );
00595 
00596                     <span class="keywordflow">if</span> (privileges) {
00597 
00598                         (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d2/d5/seastate_8c.html#a5">SeAppendPrivileges</a>( AccessState,
00599                                                    privileges );
00600                         <a class="code" href="../../d0/d4/accessck_8c.html#a17">SeFreePrivileges</a>( privileges );
00601                     }
00602 
00603                 }
00604 
00605                 <span class="comment">//</span>
00606                 <span class="comment">// Perform the traverse audit alarm if necessary.</span>
00607                 <span class="comment">//</span>
00608 
00609                 <a class="code" href="../../d3/d5/seaudit_8c.html#a25">SeTraverseAuditAlarm</a>( &amp;AccessState-&gt;OperationID,
00610                                       parseDeviceObject,
00611                                       parseDeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o21">SecurityDescriptor</a>,
00612                                       &amp;AccessState-&gt;SubjectSecurityContext,
00613                                       subjectContextLocked,
00614                                       FILE_TRAVERSE,
00615                                       (PPRIVILEGE_SET) NULL,
00616                                       accessGranted,
00617                                       UserMode );
00618                 <a class="code" href="../../d5/d8/ex_8h.html#a66">ExReleaseResource</a>( &amp;IopSecurityResource );
00619                 <a class="code" href="../../d4/d9/ke_8h.html#a29">KeLeaveCriticalRegion</a>();
00620 
00621             } <span class="keywordflow">else</span> {
00622 
00623                     accessGranted = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00624             }
00625         }
00626 
00627         <span class="comment">//</span>
00628         <span class="comment">// Unlock the subject's security context so that it can be changed,</span>
00629         <span class="comment">// if it was locked.</span>
00630         <span class="comment">//</span>
00631 
00632         <span class="keywordflow">if</span> (subjectContextLocked) {
00633             <a class="code" href="../../d0/d8/subject_8c.html#a2">SeUnlockSubjectContext</a>( &amp;AccessState-&gt;SubjectSecurityContext );
00634         }
00635 
00636         <span class="comment">//</span>
00637         <span class="comment">// Finally, determine whether or not access was granted to the device.</span>
00638         <span class="comment">// If not, clean everything up and get out now without even invoking</span>
00639         <span class="comment">// the device driver.</span>
00640         <span class="comment">//</span>
00641 
00642         <span class="keywordflow">if</span> (!accessGranted) {
00643 
00644             <a class="code" href="../../d0/d6/iop_8h.html#a161">IopDecrementDeviceObjectRef</a>( parseDeviceObject, FALSE );
00645             <span class="keywordflow">return</span> STATUS_ACCESS_DENIED;
00646         }
00647 
00648     }
00649 
00650     realFileObjectRequired = !(op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o20">QueryOnly</a> || op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o21">DeleteOnly</a>);
00651 
00652     <span class="keywordflow">if</span> (RemainingName-&gt;Length == 0 &amp;&amp;
00653         op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o6">RelatedFileObject</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> &amp;&amp;
00654         ((desiredAccess &amp; ~(SYNCHRONIZE |
00655                             FILE_READ_ATTRIBUTES |
00656                             READ_CONTROL |
00657                             ACCESS_SYSTEM_SECURITY |
00658                             WRITE_OWNER |
00659                             WRITE_DAC)) == 0) &amp;&amp;
00660         realFileObjectRequired) {
00661 
00662         <span class="comment">//</span>
00663         <span class="comment">// If the name of the object being opened is just the name of the</span>
00664         <span class="comment">// device itself, and there is no related file object, and the caller</span>
00665         <span class="comment">// is opening the device for only read attributes access, then this</span>
00666         <span class="comment">// device will not be mounted.  This allows applications to obtain</span>
00667         <span class="comment">// attributes about the device without actually mounting it.</span>
00668         <span class="comment">//</span>
00669         <span class="comment">// Note that if this *is* a direct device open, then the normal path</span>
00670         <span class="comment">// through the I/O system and drivers may never be used, even if</span>
00671         <span class="comment">// the device appears to be mounted.  This is because the user may</span>
00672         <span class="comment">// remove the media from the drive (even though it is mounted), and</span>
00673         <span class="comment">// now attempting to determine what type of drive it is will still</span>
00674         <span class="comment">// fail, this time very hard, because a whole mount process is now</span>
00675         <span class="comment">// required, thus defeating this feature.</span>
00676         <span class="comment">//</span>
00677 
00678         directDeviceOpen = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00679 
00680     } <span class="keywordflow">else</span> {
00681 
00682         <span class="comment">//</span>
00683         <span class="comment">// Otherwise, this is a normal open of a file, directory, device, or</span>
00684         <span class="comment">// volume.</span>
00685         <span class="comment">//</span>
00686 
00687         directDeviceOpen = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00688     }
00689 
00690     <span class="comment">//</span>
00691     <span class="comment">// There are now five different cases.  These are as follows:</span>
00692     <span class="comment">//</span>
00693     <span class="comment">//    1)  This is a relative open, in which case we want to send the</span>
00694     <span class="comment">//        request to then same device that opened the relative file object.</span>
00695     <span class="comment">//</span>
00696     <span class="comment">//    2)  The VPB pointer in the device object is NULL.  This means that</span>
00697     <span class="comment">//        this device does not support a file system.  This includes</span>
00698     <span class="comment">//        devices such as terminals, etc.</span>
00699     <span class="comment">//</span>
00700     <span class="comment">//    3)  The VPB pointer in the device object is not NULL and:</span>
00701     <span class="comment">//</span>
00702     <span class="comment">//        a)  The VPB is "blank".  That is, the VPB has never been filled</span>
00703     <span class="comment">//            in, which means that the device has never been mounted.</span>
00704     <span class="comment">//</span>
00705     <span class="comment">//        b)  The VPB is non-blank, but the verify flag on the device is</span>
00706     <span class="comment">//            set, indicating that the door to the drive may have been</span>
00707     <span class="comment">//            opened and the media may therefore have been changed.</span>
00708     <span class="comment">//</span>
00709     <span class="comment">//        c)  The VPB is non-blank and the verify flag is not set.</span>
00710     <span class="comment">//</span>
00711     <span class="comment">//        Both of the latter are not explicitly checked for, as #c is</span>
00712     <span class="comment">//        the normal case, and #b is the responsibility of the file</span>
00713     <span class="comment">//        system to check.</span>
00714     <span class="comment">//</span>
00715 
00716     <span class="comment">//</span>
00717     <span class="comment">//  If this is a file system that supports volumes, vpbRefCount will</span>
00718     <span class="comment">//  be filled in to point to the reference count in the Vpb.  Error</span>
00719     <span class="comment">//  exits paths later on key off this value to see if they should</span>
00720     <span class="comment">//  decrement the ref count.  Note that a direct device open does not</span>
00721     <span class="comment">//  make it to the file system, so no increment is needed, and no</span>
00722     <span class="comment">//  decrement will be performed in objsup.c IopDeleteFile().</span>
00723     <span class="comment">//</span>
00724 
00725     vpb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00726 
00727     <span class="comment">//</span>
00728     <span class="comment">// If the related open was a direct device open then we should go through the full mount </span>
00729     <span class="comment">// path for this open as this may not be a direct device open.</span>
00730     <span class="comment">//</span>
00731     <span class="keywordflow">if</span> (op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o6">RelatedFileObject</a> &amp;&amp; (!(op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o6">RelatedFileObject</a>-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a161">FO_DIRECT_DEVICE_OPEN</a>))) {
00732 
00733         deviceObject = (<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>)ParseObject;
00734 
00735         <span class="keywordflow">if</span> (op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o6">RelatedFileObject</a>-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o3">Vpb</a>) {
00736 
00737             vpb = op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o6">RelatedFileObject</a>-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o3">Vpb</a>;
00738 
00739             <span class="comment">//</span>
00740             <span class="comment">// Synchronize here with the file system to make sure that</span>
00741             <span class="comment">// volumes don't go away while en route to the FS.</span>
00742             <span class="comment">//</span>
00743 
00744             <a class="code" href="../../d5/d8/ex_8h.html#a235">ExInterlockedAddUlong</a>( &amp;vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o7">ReferenceCount</a>, 1, &amp;IopVpbSpinLock );
00745         }
00746 
00747     } <span class="keywordflow">else</span> {
00748 
00749         deviceObject = parseDeviceObject;
00750 
00751         <span class="keywordflow">if</span> (parseDeviceObject-&gt;Vpb &amp;&amp; !directDeviceOpen) {
00752             vpb = <a class="code" href="../../d4/d3/parse_8c.html#a4">IopCheckVpbMounted</a>( op,
00753                                       parseDeviceObject,
00754                                       RemainingName,
00755                                       &amp;status );
00756             <span class="keywordflow">if</span> ( !vpb ) {
00757                 <span class="keywordflow">return</span> status;
00758             }
00759 
00760             <span class="comment">//</span>
00761             <span class="comment">// Set the address of the device object associated with the VPB.</span>
00762             <span class="comment">//</span>
00763 
00764             deviceObject = vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o4">DeviceObject</a>;
00765         }
00766 
00767         <span class="comment">//</span>
00768         <span class="comment">// Walk the attached device list.</span>
00769         <span class="comment">//</span>
00770 
00771         <span class="keywordflow">if</span> (deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o5">AttachedDevice</a>) {
00772             deviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a66">IoGetAttachedDevice</a>( deviceObject );
00773         }
00774     }
00775 
00776     <span class="comment">//</span>
00777     <span class="comment">//  If the driver says that the IO manager should do the access checks, lets do it here.</span>
00778     <span class="comment">//  We do the check against the parse device object as that device object has a name</span>
00779     <span class="comment">//  and we can set an ACL against it.</span>
00780     <span class="comment">//  We only worry about related opens of devices as the other case is taken care of in the</span>
00781     <span class="comment">//  filesystem.</span>
00782     <span class="comment">//</span>
00783     <span class="keywordflow">if</span> ((deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o9">Characteristics</a> &amp; FILE_DEVICE_SECURE_OPEN) &amp;&amp;
00784         (op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o6">RelatedFileObject</a> || RemainingName-&gt;Length) &amp;&amp;  (!relativeVolumeOpen)) {
00785 
00786         BOOLEAN subjectContextLocked = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00787         BOOLEAN accessGranted;
00788         ACCESS_MASK grantedAccess;
00789         UNICODE_STRING nameString;
00790         PPRIVILEGE_SET privileges = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00791 
00792         <span class="comment">//</span>
00793         <span class="comment">// If the device wants to ensure secure opens then lets check the two</span>
00794         <span class="comment">// cases which were skipped earlier. These cases are if its a relative</span>
00795         <span class="comment">// open or if there are trailing names.</span>
00796         <span class="comment">//</span>
00797 
00798         <a class="code" href="../../d4/d9/ke_8h.html#a28">KeEnterCriticalRegion</a>( );
00799         <a class="code" href="../../d5/d8/ex_8h.html#a69">ExAcquireResourceShared</a>( &amp;IopSecurityResource, TRUE );
00800 
00801         <a class="code" href="../../d0/d8/subject_8c.html#a1">SeLockSubjectContext</a>( &amp;AccessState-&gt;SubjectSecurityContext );
00802         subjectContextLocked = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00803 
00804         accessGranted = <a class="code" href="../../d0/d4/accessck_8c.html#a18">SeAccessCheck</a>( parseDeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o21">SecurityDescriptor</a>,
00805                                        &amp;AccessState-&gt;SubjectSecurityContext,
00806                                        subjectContextLocked,
00807                                        desiredAccess,
00808                                        0,
00809                                        &amp;privileges,
00810                                        &amp;<a class="code" href="../../d5/d8/fssup_8c.html#a3">IoFileObjectType</a>-&gt;<a class="code" href="../../d3/d6/struct__OBJECT__TYPE.html#o9">TypeInfo</a>.<a class="code" href="../../d5/d6/struct__OBJECT__TYPE__INITIALIZER.html#o4">GenericMapping</a>,
00811                                        UserMode,
00812                                        &amp;grantedAccess,
00813                                        &amp;status );
00814 
00815         <span class="keywordflow">if</span> (privileges) {
00816             (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d2/d5/seastate_8c.html#a5">SeAppendPrivileges</a>( AccessState,
00817                                        privileges );
00818             <a class="code" href="../../d0/d4/accessck_8c.html#a17">SeFreePrivileges</a>( privileges );
00819         }
00820 
00821         <span class="keywordflow">if</span> (accessGranted) {
00822             AccessState-&gt;PreviouslyGrantedAccess |= grantedAccess;
00823             AccessState-&gt;RemainingDesiredAccess &amp;= ~( grantedAccess | MAXIMUM_ALLOWED );
00824         }
00825 
00826         nameString.Length = 8;
00827         nameString.MaximumLength = 8;
00828         nameString.Buffer = <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="stringliteral">"File"</span>;
00829 
00830         <a class="code" href="../../d3/d5/seaudit_8c.html#a23">SeOpenObjectAuditAlarm</a>( &amp;nameString,
00831                                 deviceObject,
00832                                 CompleteName,
00833                                 parseDeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o21">SecurityDescriptor</a>,
00834                                 AccessState,
00835                                 FALSE,
00836                                 accessGranted,
00837                                 UserMode,
00838                                 &amp;AccessState-&gt;GenerateOnClose );
00839 
00840         <a class="code" href="../../d0/d8/subject_8c.html#a2">SeUnlockSubjectContext</a>( &amp;AccessState-&gt;SubjectSecurityContext );
00841         <a class="code" href="../../d5/d8/ex_8h.html#a66">ExReleaseResource</a>( &amp;IopSecurityResource );
00842         <a class="code" href="../../d4/d9/ke_8h.html#a29">KeLeaveCriticalRegion</a>();
00843 
00844         <span class="keywordflow">if</span> (!accessGranted) {
00845             <a class="code" href="../../d0/d6/iop_8h.html#a161">IopDecrementDeviceObjectRef</a>( parseDeviceObject, FALSE );
00846 
00847             <span class="keywordflow">if</span> (vpb) {
00848                 <a class="code" href="../../d4/d3/parse_8c.html#a5">IopDereferenceVpbAndFree</a>(vpb);
00849             }
00850             <span class="keywordflow">return</span> STATUS_ACCESS_DENIED;
00851         }
00852     }
00853 
00854     <span class="comment">//</span>
00855     <span class="comment">// Allocate and fill in the I/O Request Packet (IRP) to use in interfacing</span>
00856     <span class="comment">// to the driver.  The allocation is done using an exception handler in</span>
00857     <span class="comment">// case the caller does not have enough quota to allocate the packet.</span>
00858     <span class="comment">//</span>
00859 
00860     irp = <a class="code" href="../../d0/d6/iop_8h.html#a16">IopAllocateIrp</a>( deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o13">StackSize</a>, TRUE );
00861     <span class="keywordflow">if</span> (!irp) {
00862 
00863         <span class="comment">//</span>
00864         <span class="comment">// An IRP could not be allocated.  Cleanup and return an appropriate</span>
00865         <span class="comment">// error status code.</span>
00866         <span class="comment">//</span>
00867 
00868         <a class="code" href="../../d0/d6/iop_8h.html#a161">IopDecrementDeviceObjectRef</a>( parseDeviceObject, FALSE );
00869 
00870         <span class="keywordflow">if</span> (vpb) {
00871             <a class="code" href="../../d4/d3/parse_8c.html#a5">IopDereferenceVpbAndFree</a>(vpb);
00872         }
00873         <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
00874     }
00875     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.Thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
00876     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o10">RequestorMode</a> = AccessMode;
00877     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> = <a class="code" href="../../d0/d5/io_8h.html#a182">IRP_CREATE_OPERATION</a> | <a class="code" href="../../d0/d5/io_8h.html#a176">IRP_SYNCHRONOUS_API</a> | <a class="code" href="../../d0/d5/io_8h.html#a186">IRP_DEFER_IO_COMPLETION</a>;
00878 
00879     securityContext.<a class="code" href="../../d1/d5/struct__IO__SECURITY__CONTEXT.html#o0">SecurityQos</a> = <a class="code" href="../../d7/d0/ctlnpqos_8c.html#a14">SecurityQos</a>;
00880     securityContext.<a class="code" href="../../d1/d5/struct__IO__SECURITY__CONTEXT.html#o1">AccessState</a> = AccessState;
00881     securityContext.<a class="code" href="../../d1/d5/struct__IO__SECURITY__CONTEXT.html#o2">DesiredAccess</a> = desiredAccess;
00882     securityContext.<a class="code" href="../../d1/d5/struct__IO__SECURITY__CONTEXT.html#o3">FullCreateOptions</a> = op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o8">CreateOptions</a>;
00883 
00884     <span class="comment">//</span>
00885     <span class="comment">// Get a pointer to the stack location for the first driver.  This is where</span>
00886     <span class="comment">// the original function codes and parameters are passed.</span>
00887     <span class="comment">//</span>
00888 
00889     irpSp = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>( irp );
00890     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o3">Control</a> = 0;
00891 
00892     <span class="keywordflow">if</span> (op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o17">CreateFileType</a> == <a class="code" href="../../d0/d5/io_8h.html#a600a406">CreateFileTypeNone</a>) {
00893 
00894         <span class="comment">//</span>
00895         <span class="comment">// This is a normal file open or create function.</span>
00896         <span class="comment">//</span>
00897 
00898         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a> = <a class="code" href="../../d0/d5/io_8h.html#a13">IRP_MJ_CREATE</a>;
00899         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.Create.EaLength = op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o12">EaLength</a>;
00900         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o2">Flags</a> = (UCHAR) op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o13">Options</a>;
00901         <span class="keywordflow">if</span> (!(Attributes &amp; OBJ_CASE_INSENSITIVE)) {
00902             irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o2">Flags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a201">SL_CASE_SENSITIVE</a>;
00903         }
00904 
00905     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o17">CreateFileType</a> == <a class="code" href="../../d0/d5/io_8h.html#a600a407">CreateFileTypeNamedPipe</a>) {
00906 
00907         <span class="comment">//</span>
00908         <span class="comment">// A named pipe is being created.</span>
00909         <span class="comment">//</span>
00910 
00911         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a> = <a class="code" href="../../d0/d5/io_8h.html#a14">IRP_MJ_CREATE_NAMED_PIPE</a>;
00912         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.CreatePipe.Parameters = op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o18">ExtraCreateParameters</a>;
00913 
00914     } <span class="keywordflow">else</span> {
00915 
00916         <span class="comment">//</span>
00917         <span class="comment">// A mailslot is being created.</span>
00918         <span class="comment">//</span>
00919 
00920         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a> = <a class="code" href="../../d0/d5/io_8h.html#a32">IRP_MJ_CREATE_MAILSLOT</a>;
00921         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.CreateMailslot.Parameters = op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o18">ExtraCreateParameters</a>;
00922     }
00923 
00924     <span class="comment">//</span>
00925     <span class="comment">// Also fill in the NtCreateFile service's caller's parameters.</span>
00926     <span class="comment">//</span>
00927 
00928     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o24">Overlay</a>.AllocationSize = op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o7">AllocationSize</a>;
00929     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.SystemBuffer = op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o11">EaBuffer</a>;
00930     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.Create.Options = (op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o14">Disposition</a> &lt;&lt; 24) | (op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o8">CreateOptions</a> &amp; 0x00ffffff);
00931     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.Create.FileAttributes = op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o9">FileAttributes</a>;
00932     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.Create.ShareAccess = op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o10">ShareAccess</a>;
00933     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.Create.SecurityContext = &amp;securityContext;
00934 
00935     <span class="comment">//</span>
00936     <span class="comment">// Fill in local parameters so this routine can determine when the I/O is</span>
00937     <span class="comment">// finished, and the normal I/O completion code will not get any errors.</span>
00938     <span class="comment">//</span>
00939 
00940     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o18">UserIosb</a> = &amp;ioStatus;
00941     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o2">MdlAddress</a> = (<a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00942     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o11">PendingReturned</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00943     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o14">Cancel</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00944     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o19">UserEvent</a> = (<a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00945     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o25">CancelRoutine</a> = (<a class="code" href="../../d0/d5/io_8h.html#a286">PDRIVER_CANCEL</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00946     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.AuxiliaryBuffer = (PVOID) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00947 
00948     <span class="comment">//</span>
00949     <span class="comment">// Allocate and initialize the file object that will be used in dealing</span>
00950     <span class="comment">// with the device for the remainder of this session with the user.  How</span>
00951     <span class="comment">// the file object is allocated is based on whether or not a real file</span>
00952     <span class="comment">// object is actually required.  It is not required for the query and</span>
00953     <span class="comment">// delete only operations.</span>
00954     <span class="comment">//</span>
00955 
00956     <span class="keywordflow">if</span> (realFileObjectRequired) {
00957 
00958         OBJECT_ATTRIBUTES objectAttributes;
00959 
00960         <span class="comment">//</span>
00961         <span class="comment">// A real, full-blown file object is actually required.</span>
00962         <span class="comment">//</span>
00963 
00964         InitializeObjectAttributes( &amp;objectAttributes,
00965                                     (PUNICODE_STRING) NULL,
00966                                     Attributes,
00967                                     (HANDLE) NULL,
00968                                     (PSECURITY_DESCRIPTOR) NULL
00969                                   );
00970 
00971         status = <a class="code" href="../../d6/d0/obcreate_8c.html#a5">ObCreateObject</a>( KernelMode,
00972                                  IoFileObjectType,
00973                                  &amp;objectAttributes,
00974                                  AccessMode,
00975                                  (PVOID) NULL,
00976                                  (ULONG) <span class="keyword">sizeof</span>( <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">FILE_OBJECT</a> ),
00977                                  0,
00978                                  0,
00979                                  (PVOID *) &amp;fileObject );
00980 
00981         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
00982             <a class="code" href="../../d4/d6/iosubs_8c.html#a63">IoFreeIrp</a>( irp );
00983 
00984             <a class="code" href="../../d0/d6/iop_8h.html#a161">IopDecrementDeviceObjectRef</a>( parseDeviceObject, FALSE );
00985 
00986             <span class="keywordflow">if</span> (vpb) {
00987                <a class="code" href="../../d4/d3/parse_8c.html#a5">IopDereferenceVpbAndFree</a>(vpb);
00988             }
00989             <span class="keywordflow">return</span> op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o3">FinalStatus</a> = status;
00990         }
00991 
00992         RtlZeroMemory( fileObject, <span class="keyword">sizeof</span>( FILE_OBJECT ) );
00993         fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o0">Type</a> = <a class="code" href="../../d0/d5/io_8h.html#a4">IO_TYPE_FILE</a>;
00994         fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o1">Size</a> = <span class="keyword">sizeof</span>( <a class="code" href="../../d0/d5/io_8h.html#a353">FILE_OBJECT</a> );
00995         fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o9">RelatedFileObject</a> = op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o6">RelatedFileObject</a>;
00996         <span class="keywordflow">if</span> (op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o8">CreateOptions</a> &amp; (FILE_SYNCHRONOUS_IO_ALERT | FILE_SYNCHRONOUS_IO_NONALERT)) {
00997             fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> = <a class="code" href="../../d0/d5/io_8h.html#a151">FO_SYNCHRONOUS_IO</a>;
00998             <span class="keywordflow">if</span> (op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o8">CreateOptions</a> &amp; FILE_SYNCHRONOUS_IO_ALERT) {
00999                 fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a152">FO_ALERTABLE_IO</a>;
01000             }
01001         }
01002 
01003         <span class="comment">//</span>
01004         <span class="comment">// Now fill in the file object as best is possible at this point and set</span>
01005         <span class="comment">// a pointer to it in the IRP so everyone else can find it.</span>
01006         <span class="comment">//</span>
01007 
01008         <span class="keywordflow">if</span> (fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a151">FO_SYNCHRONOUS_IO</a>) {
01009             <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( &amp;fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o24">Lock</a>, SynchronizationEvent, FALSE );
01010             fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o21">Waiters</a> = 0;
01011             fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o20">CurrentByteOffset</a>.QuadPart = 0;
01012         }
01013         <span class="keywordflow">if</span> (op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o8">CreateOptions</a> &amp; FILE_NO_INTERMEDIATE_BUFFERING) {
01014             fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a153">FO_NO_INTERMEDIATE_BUFFERING</a>;
01015         }
01016         <span class="keywordflow">if</span> (op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o8">CreateOptions</a> &amp; FILE_WRITE_THROUGH) {
01017             fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a154">FO_WRITE_THROUGH</a>;
01018         }
01019         <span class="keywordflow">if</span> (op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o8">CreateOptions</a> &amp; FILE_SEQUENTIAL_ONLY) {
01020             fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a155">FO_SEQUENTIAL_ONLY</a>;
01021         }
01022         <span class="keywordflow">if</span> (op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o8">CreateOptions</a> &amp; FILE_RANDOM_ACCESS) {
01023             fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a170">FO_RANDOM_ACCESS</a>;
01024         }
01025 
01026     } <span class="keywordflow">else</span> {
01027 
01028         <span class="comment">//</span>
01029         <span class="comment">// This is either a quick delete or query operation.  For these cases,</span>
01030         <span class="comment">// it is possible to optimize the Object Manager out of the picture by</span>
01031         <span class="comment">// simply putting together something that "looks" like a file object,</span>
01032         <span class="comment">// and then operating on it.</span>
01033         <span class="comment">//</span>
01034 
01035         localFileObject = op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o23">LocalFileObject</a>;
01036         RtlZeroMemory( localFileObject, <span class="keyword">sizeof</span>( <a class="code" href="../../d0/d1/struct__DUMMY__FILE__OBJECT.html">DUMMY_FILE_OBJECT</a> ) );
01037         fileObject = (<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>) &amp;localFileObject-&gt;<a class="code" href="../../d0/d1/struct__DUMMY__FILE__OBJECT.html#o0">ObjectHeader</a>.<a class="code" href="../../d4/d5/struct__OBJECT__HEADER.html#o11">Body</a>;
01038         localFileObject-&gt;<a class="code" href="../../d0/d1/struct__DUMMY__FILE__OBJECT.html#o0">ObjectHeader</a>.<a class="code" href="../../d4/d5/struct__OBJECT__HEADER.html#o3">Type</a> = <a class="code" href="../../d5/d8/fssup_8c.html#a3">IoFileObjectType</a>;
01039         localFileObject-&gt;<a class="code" href="../../d0/d1/struct__DUMMY__FILE__OBJECT.html#o0">ObjectHeader</a>.<a class="code" href="../../d4/d5/struct__OBJECT__HEADER.html#o0">PointerCount</a> = 1;
01040     }
01041 
01042     <span class="keywordflow">if</span> (directDeviceOpen) {
01043         fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a161">FO_DIRECT_DEVICE_OPEN</a>;
01044     }
01045     <span class="keywordflow">if</span> (!(Attributes &amp; OBJ_CASE_INSENSITIVE)) {
01046         fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a167">FO_OPENED_CASE_SENSITIVE</a>;
01047     }
01048 
01049     fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o0">Type</a> = <a class="code" href="../../d0/d5/io_8h.html#a4">IO_TYPE_FILE</a>;
01050     fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o1">Size</a> = <span class="keyword">sizeof</span>( <a class="code" href="../../d0/d5/io_8h.html#a353">FILE_OBJECT</a> );
01051     fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o9">RelatedFileObject</a> = op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o6">RelatedFileObject</a>;
01052     fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o2">DeviceObject</a> = parseDeviceObject;
01053 
01054     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.OriginalFileObject = fileObject;
01055     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a> = fileObject;
01056 
01057     <span class="comment">//</span>
01058     <span class="comment">// Allocate a file name string buffer which is large enough to contain</span>
01059     <span class="comment">// the entire remaining name string and initialize the maximum length.</span>
01060     <span class="comment">//</span>
01061 
01062     <span class="keywordflow">if</span> (RemainingName-&gt;Length) {
01063         fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o19">FileName</a>.MaximumLength = <a class="code" href="../../d4/d3/parse_8c.html#a0">RoundNameSize</a>( RemainingName-&gt;Length );
01064         fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o19">FileName</a>.Buffer = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( PagedPool,
01065                                                              fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o19">FileName</a>.MaximumLength,
01066                                                              'mNoI' );
01067         <span class="keywordflow">if</span> (!fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o19">FileName</a>.Buffer) {
01068             <a class="code" href="../../d4/d6/iosubs_8c.html#a63">IoFreeIrp</a>( irp );
01069 
01070             <a class="code" href="../../d0/d6/iop_8h.html#a161">IopDecrementDeviceObjectRef</a>( parseDeviceObject, FALSE );
01071 
01072             <span class="keywordflow">if</span> (vpb) {
01073                <a class="code" href="../../d4/d3/parse_8c.html#a5">IopDereferenceVpbAndFree</a>(vpb);
01074             }
01075             fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o2">DeviceObject</a> = (<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01076             <span class="keywordflow">if</span> (realFileObjectRequired) {
01077                 <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
01078             }
01079             <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
01080         }
01081     }
01082 
01083     <span class="comment">//</span>
01084     <span class="comment">// Now copy the name string into the file object from the remaining name</span>
01085     <span class="comment">// that is being reparsed.  If the driver decides to reparse, then it must</span>
01086     <span class="comment">// replace this name.</span>
01087     <span class="comment">//</span>
01088 
01089     <a class="code" href="../../d6/d6/nls_8c.html#a44">RtlCopyUnicodeString</a>( &amp;fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o19">FileName</a>, RemainingName );
01090 
01091     <span class="comment">//</span>
01092     <span class="comment">// Before invoking the driver's open routine, check to see whether or not</span>
01093     <span class="comment">// this is a fast network attributes query and, if so, and the driver</span>
01094     <span class="comment">// implements the function, attempt to call it here.</span>
01095     <span class="comment">//</span>
01096 
01097     <span class="keywordflow">if</span> (op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o20">QueryOnly</a>) {
01098         <a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html">PFAST_IO_DISPATCH</a> fastIoDispatch = deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o3">DriverObject</a>-&gt;<a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html#o10">FastIoDispatch</a>;
01099         BOOLEAN result;
01100 
01101         <span class="keywordflow">if</span> (fastIoDispatch &amp;&amp;
01102             fastIoDispatch-&gt;<a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html#o0">SizeOfFastIoDispatch</a> &gt; FIELD_OFFSET( <a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html">FAST_IO_DISPATCH</a>, FastIoQueryOpen ) &amp;&amp;
01103             fastIoDispatch-&gt;<a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html#o24">FastIoQueryOpen</a>) {
01104 
01105             <a class="code" href="../../d0/d5/io_8h.html#a238">IoSetNextIrpStackLocation</a>( irp );
01106             irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o57">DeviceObject</a> = deviceObject;
01107             result = (fastIoDispatch-&gt;<a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html#o24">FastIoQueryOpen</a>)( irp,
01108                                                         op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o16">NetworkInformation</a>,
01109                                                         deviceObject );
01110             <span class="keywordflow">if</span> (result) {
01111                 op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o3">FinalStatus</a> = irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status;
01112                 op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o4">Information</a> = irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Information;
01113 
01114                 <span class="comment">//</span>
01115                 <span class="comment">// The operation worked, so simply dereference and free the</span>
01116                 <span class="comment">// resources acquired up to this point.</span>
01117                 <span class="comment">//</span>
01118 
01119                 <span class="keywordflow">if</span> ((op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o3">FinalStatus</a> == STATUS_REPARSE) &amp;&amp;
01120                     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.AuxiliaryBuffer) {
01121                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o4">Information</a> &gt; IO_REPARSE_TAG_RESERVED_ONE );
01122                     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.AuxiliaryBuffer );
01123                     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.AuxiliaryBuffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01124                     op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o6">RelatedFileObject</a> = (<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01125                 }
01126 
01127                 <span class="keywordflow">if</span> (fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o19">FileName</a>.Length) {
01128                     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o19">FileName</a>.Buffer );
01129                 }
01130 
01131                 <a class="code" href="../../d0/d6/iop_8h.html#a161">IopDecrementDeviceObjectRef</a>( parseDeviceObject, FALSE );
01132 
01133                 <span class="keywordflow">if</span> (vpb) {
01134                     <a class="code" href="../../d4/d3/parse_8c.html#a5">IopDereferenceVpbAndFree</a>(vpb);
01135                 }
01136 
01137 <span class="preprocessor">#if DBG</span>
01138 <span class="preprocessor"></span>                irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o13">CurrentLocation</a> = irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o12">StackCount</a> + 2;
01139 <span class="preprocessor">#endif // DBG</span>
01140 <span class="preprocessor"></span>
01141                 <a class="code" href="../../d4/d6/iosubs_8c.html#a63">IoFreeIrp</a>( irp );
01142 
01143                 <span class="comment">//</span>
01144                 <span class="comment">// Finally, indicate that the parse routine was actually</span>
01145                 <span class="comment">// invoked and that the information returned herein can be</span>
01146                 <span class="comment">// used.</span>
01147                 <span class="comment">//</span>
01148 
01149                 op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o5">ParseCheck</a> = <a class="code" href="../../d0/d6/iop_8h.html#a3">OPEN_PACKET_PATTERN</a>;
01150                 status = STATUS_SUCCESS;
01151 
01152                 <span class="keywordflow">if</span> (!op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o22">FullAttributes</a>) {
01153                     <span class="keywordflow">try</span> {
01154                         op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o15">BasicInformation</a>-&gt;FileAttributes = op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o16">NetworkInformation</a>-&gt;FileAttributes;
01155                     } except(EXCEPTION_EXECUTE_HANDLER) {
01156                         status = GetExceptionCode();
01157                     }
01158                 }
01159 
01160                 <span class="keywordflow">return</span> status;
01161 
01162             } <span class="keywordflow">else</span> {
01163 
01164                 <span class="comment">//</span>
01165                 <span class="comment">// The fast I/O operation did not work, so take the longer</span>
01166                 <span class="comment">// route.</span>
01167                 <span class="comment">//</span>
01168 
01169                 irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.CurrentStackLocation++;
01170                 irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o13">CurrentLocation</a>++;
01171             }
01172         }
01173     }
01174 
01175     <span class="comment">//</span>
01176     <span class="comment">// Finally, initialize the file object's event to the Not Signaled state</span>
01177     <span class="comment">// and remember that a file object was created.</span>
01178     <span class="comment">//</span>
01179 
01180     <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( &amp;fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o25">Event</a>, NotificationEvent, FALSE );
01181     op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o2">FileObject</a> = fileObject;
01182 
01183     <span class="comment">//</span>
01184     <span class="comment">// Insert the packet at the head of the IRP list for the thread.</span>
01185     <span class="comment">//</span>
01186 
01187     <a class="code" href="../../d0/d6/iop_8h.html#a21">IopQueueThreadIrp</a>( irp );
01188 
01189     <span class="comment">//</span>
01190     <span class="comment">// Now invoke the driver itself to open the file.</span>
01191     <span class="comment">//</span>
01192 
01193     status = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>( deviceObject, irp );
01194 
01195     <span class="comment">//</span>
01196     <span class="comment">// One of four things may have happened when the driver was invoked:</span>
01197     <span class="comment">//</span>
01198     <span class="comment">//    1.  The I/O operation is pending (Status == STATUS_PENDING).  This can</span>
01199     <span class="comment">//        occur on devices which need to perform some sort of device</span>
01200     <span class="comment">//        manipulation (such as opening a file for a file system).</span>
01201     <span class="comment">//</span>
01202     <span class="comment">//    2.  The driver returned an error (Status &lt; 0). This occurs when either</span>
01203     <span class="comment">//        a supplied parameter was in error, or the device or file system</span>
01204     <span class="comment">//        incurred or discovered an error.</span>
01205     <span class="comment">//</span>
01206     <span class="comment">//    3.  The operation ended in a reparse (Status == STATUS_REPARSE).  This</span>
01207     <span class="comment">//        occurs when a file system opens the file, only to discover that it</span>
01208     <span class="comment">//        represents a symbolic link.</span>
01209     <span class="comment">//</span>
01210     <span class="comment">//    4.  The operation is complete and was successful (Status ==</span>
01211     <span class="comment">//        STATUS_SUCCESS).  Note that for this case the only action is to</span>
01212     <span class="comment">//        return a pointer to the file object.</span>
01213     <span class="comment">//</span>
01214 
01215     <span class="keywordflow">if</span> (status == STATUS_PENDING) {
01216 
01217         (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o25">Event</a>,
01218                                       Executive,
01219                                       KernelMode,
01220                                       FALSE,
01221                                       (PLARGE_INTEGER) NULL );
01222         status = ioStatus.Status;
01223 
01224     } <span class="keywordflow">else</span> {
01225 
01226         <span class="comment">//</span>
01227         <span class="comment">// The I/O operation was completed without returning a status of</span>
01228         <span class="comment">// pending.  This means that at this point, the IRP has not been</span>
01229         <span class="comment">// fully completed.  Complete it now.</span>
01230         <span class="comment">//</span>
01231 
01232         <a class="code" href="../../d0/d9/ntosdef_8h.html#a41">PKNORMAL_ROUTINE</a> normalRoutine;
01233         PVOID normalContext;
01234         KIRQL irql;
01235 
01236         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( !irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o11">PendingReturned</a> );
01237         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( !irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o2">MdlAddress</a> );
01238 
01239         <span class="comment">//</span>
01240         <span class="comment">// In the case of name junctions do the transmogrify work.</span>
01241         <span class="comment">//</span>
01242 
01243         <span class="keywordflow">if</span> (irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status == STATUS_REPARSE &amp;&amp;
01244             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Information == IO_REPARSE_TAG_MOUNT_POINT ) {
01245 
01246             PREPARSE_DATA_BUFFER reparseBuffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01247 
01248             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ( irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.AuxiliaryBuffer != NULL );
01249 
01250             reparseBuffer = (PREPARSE_DATA_BUFFER) irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.AuxiliaryBuffer;
01251 
01252             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( reparseBuffer-&gt;ReparseTag == IO_REPARSE_TAG_MOUNT_POINT );
01253             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( reparseBuffer-&gt;ReparseDataLength &lt; MAXIMUM_REPARSE_DATA_BUFFER_SIZE );
01254             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( reparseBuffer-&gt;Reserved &lt; MAXIMUM_REPARSE_DATA_BUFFER_SIZE );
01255 
01256             <a class="code" href="../../d4/d6/iosubs_8c.html#a86">IopDoNameTransmogrify</a>( irp,
01257                                    fileObject,
01258                                    reparseBuffer );
01259         }
01260 
01261         <span class="comment">//</span>
01262         <span class="comment">// Now finish up the request.</span>
01263         <span class="comment">//</span>
01264 
01265         <a class="code" href="../../d9/d5/verifier_8c.html#a116">KeRaiseIrql</a>( APC_LEVEL, &amp;irql );
01266 
01267         <span class="comment">//</span>
01268         <span class="comment">// Note that normally the system would simply call IopCompleteRequest</span>
01269         <span class="comment">// here to complete the packet.  However, because this is a create</span>
01270         <span class="comment">// operation, several assumptions can be made that make it much faster</span>
01271         <span class="comment">// to perform the couple of operations that completing the request</span>
01272         <span class="comment">// would perform.  These include:  copying the I/O status block,</span>
01273         <span class="comment">// dequeueing the IRP and freeing it, and setting the file object's</span>
01274         <span class="comment">// event to the signalled state.  The latter is done here by hand,</span>
01275         <span class="comment">// since it is known that it is not possible for any thread to be</span>
01276         <span class="comment">// waiting on the event.</span>
01277         <span class="comment">//</span>
01278 
01279         ioStatus = irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>;
01280         status = ioStatus.Status;
01281 
01282         fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o25">Event</a>.<a class="code" href="../../d2/d6/struct__KEVENT.html#o0">Header</a>.<a class="code" href="../../d1/d6/struct__DISPATCHER__HEADER.html#o4">SignalState</a> = 1;
01283 
01284         <a class="code" href="../../d0/d6/iop_8h.html#a18">IopDequeueThreadIrp</a>( irp );
01285 
01286         <span class="comment">//</span>
01287         <span class="comment">// The SystemBuffer is in some cases used by the driver, and</span>
01288         <span class="comment">// needs to be freed if present.</span>
01289         <span class="comment">//</span>
01290 
01291         <span class="keywordflow">if</span> ((irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a178">IRP_BUFFERED_IO</a>) &amp;&amp; (irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a179">IRP_DEALLOCATE_BUFFER</a>)) {
01292             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.SystemBuffer);
01293         }
01294 
01295         <a class="code" href="../../d4/d6/iosubs_8c.html#a63">IoFreeIrp</a>( irp );
01296 
01297         <a class="code" href="../../d9/d5/verifier_8c.html#a117">KeLowerIrql</a>( irql );
01298     }
01299 
01300     <span class="comment">//</span>
01301     <span class="comment">// Copy the information field of the I/O status block back to the</span>
01302     <span class="comment">// original caller in case it is required.</span>
01303     <span class="comment">//</span>
01304 
01305     op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o4">Information</a> = ioStatus.Information;
01306 
01307     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
01308         <span class="keywordtype">int</span> openCancelled;
01309 
01310         <span class="comment">//</span>
01311         <span class="comment">// The operation ended in an error.  Kill the file object, dereference</span>
01312         <span class="comment">// the device object, and return a null pointer.</span>
01313         <span class="comment">//</span>
01314 
01315         <span class="keywordflow">if</span> (fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o19">FileName</a>.Length) {
01316             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o19">FileName</a>.Buffer );
01317             fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o19">FileName</a>.Length = 0;
01318         }
01319 
01320         fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o2">DeviceObject</a> = (<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01321 
01322         openCancelled = (fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a171">FO_FILE_OPEN_CANCELLED</a>);
01323 
01324         <span class="keywordflow">if</span> (realFileObjectRequired) {
01325             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
01326         }
01327         op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o2">FileObject</a> = (<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01328 
01329         <a class="code" href="../../d0/d6/iop_8h.html#a161">IopDecrementDeviceObjectRef</a>( parseDeviceObject, FALSE );
01330 
01331         <span class="keywordflow">if</span> ((!openCancelled) &amp;&amp; (vpb )) {
01332             <a class="code" href="../../d4/d3/parse_8c.html#a5">IopDereferenceVpbAndFree</a>(vpb);
01333         }
01334 
01335         <span class="keywordflow">return</span> op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o3">FinalStatus</a> = status;
01336 
01337     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (status == STATUS_REPARSE) {
01338 
01339         <span class="comment">//</span>
01340         <span class="comment">// The operation resulted in a reparse.  This means that the file</span>
01341         <span class="comment">// name in the file object is the new name to be looked up. Replace</span>
01342         <span class="comment">// the complete name string with the new name and return STATUS_REPARSE</span>
01343         <span class="comment">// so the object manager knows to start over again.  Note, however,</span>
01344         <span class="comment">// that the file name buffer in the file object itself is kept intact</span>
01345         <span class="comment">// so that it can be reused when coming back here again.</span>
01346         <span class="comment">//</span>
01347         <span class="comment">// A reparse status may also have been returned from the file system if</span>
01348         <span class="comment">// the volume that was in a drive needed to have been verified, but</span>
01349         <span class="comment">// the verification failed, and a new volume was mounted.  In this</span>
01350         <span class="comment">// case, everything starts over again using the new volume.</span>
01351         <span class="comment">//</span>
01352 
01353         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( IO_REPARSE == IO_REPARSE_TAG_RESERVED_ZERO );
01354 
01355         <span class="keywordflow">if</span> ((ioStatus.Information == <a class="code" href="../../d0/d5/io_8h.html#a108">IO_REPARSE</a>) ||
01356             (ioStatus.Information == IO_REPARSE_TAG_MOUNT_POINT)) {
01357 
01358             <span class="comment">//</span>
01359             <span class="comment">// If the complete name buffer isn't large enough, reallocate it.</span>
01360             <span class="comment">//</span>
01361 
01362             <span class="keywordflow">if</span> (CompleteName-&gt;MaximumLength &lt; fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o19">FileName</a>.Length) {
01363 
01364                 PVOID buffer;
01365 
01366                 buffer = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( PagedPool,
01367                                                 fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o19">FileName</a>.Length,
01368                                                 'cFoI' );
01369                 <span class="keywordflow">if</span> (!buffer) {
01370                     <span class="keywordflow">return</span> op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o3">FinalStatus</a> = STATUS_INSUFFICIENT_RESOURCES;
01371                 } <span class="keywordflow">else</span> {
01372                     <span class="keywordflow">if</span> (CompleteName-&gt;Buffer) {
01373                         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( CompleteName-&gt;Buffer );
01374                     }
01375                     CompleteName-&gt;Buffer = buffer;
01376                     CompleteName-&gt;MaximumLength = fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o19">FileName</a>.Length;
01377                 }
01378             }
01379 
01380             <a class="code" href="../../d6/d6/nls_8c.html#a44">RtlCopyUnicodeString</a>( CompleteName, &amp;fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o19">FileName</a> );
01381 
01382             <span class="comment">//</span>
01383             <span class="comment">// For NTFS directory junction points we NULL the RelatedFileObject.</span>
01384             <span class="comment">// If the prior call was a relative open, the subsequent one will</span>
01385             <span class="comment">// not be.</span>
01386             <span class="comment">//</span>
01387 
01388             <span class="keywordflow">if</span> (ioStatus.Information == IO_REPARSE_TAG_MOUNT_POINT) {
01389 
01390                 op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o6">RelatedFileObject</a> = (<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01391             }
01392         }
01393 
01394         <span class="comment">//</span>
01395         <span class="comment">// Kill the file object, dereference the device object, and return a</span>
01396         <span class="comment">// null pointer.</span>
01397         <span class="comment">//</span>
01398 
01399         <span class="keywordflow">if</span> (fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o19">FileName</a>.Length) {
01400             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o19">FileName</a>.Buffer );
01401             fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o19">FileName</a>.Length = 0;
01402         }
01403 
01404         fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o2">DeviceObject</a> = (<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01405 
01406         <span class="keywordflow">if</span> (realFileObjectRequired) {
01407             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
01408         }
01409         op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o2">FileObject</a> = (<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01410 
01411         <a class="code" href="../../d0/d6/iop_8h.html#a161">IopDecrementDeviceObjectRef</a>( parseDeviceObject, FALSE );
01412 
01413         <span class="keywordflow">if</span> (vpb) {
01414             <a class="code" href="../../d4/d3/parse_8c.html#a5">IopDereferenceVpbAndFree</a>(vpb);
01415         }
01416 
01417         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( IO_REMOUNT == IO_REPARSE_TAG_RESERVED_ONE );
01418 
01419         <span class="keywordflow">if</span> (ioStatus.Information == IO_REPARSE_TAG_RESERVED_ONE) {
01420 
01421             <span class="comment">//</span>
01422             <span class="comment">// If we are reparsing to verify a volume, restart the reparse</span>
01423             <span class="comment">// by attempting to parse the device once again.  Note that it</span>
01424             <span class="comment">// would be best to simply recurse, but it's not possible since</span>
01425             <span class="comment">// there is a limited amount of stack available to kernel mode</span>
01426             <span class="comment">// and a limit needs to be enforced for the number of times that</span>
01427             <span class="comment">// verify reparse can occur.</span>
01428             <span class="comment">//</span>
01429 
01430             <span class="keywordflow">if</span> (++retryCount &gt; <a class="code" href="../../d4/d3/parse_8c.html#a1">IO_MAX_REMOUNT_REPARSE_ATTEMPTS</a>) {
01431 
01432                 <span class="keywordflow">return</span> STATUS_UNSUCCESSFUL;
01433             }
01434             <span class="keywordflow">goto</span> reparse_loop;
01435 
01436         } <span class="keywordflow">else</span> {
01437 
01438             <span class="comment">//</span>
01439             <span class="comment">// Really reparsing a symbolic link, so go back to the object</span>
01440             <span class="comment">// manager so it can begin the parse from the top.</span>
01441             <span class="comment">//</span>
01442 
01443             op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o6">RelatedFileObject</a> = (<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01444             <span class="keywordflow">return</span> STATUS_REPARSE;
01445         }
01446 
01447     } <span class="keywordflow">else</span> {
01448 
01449         <span class="comment">//</span>
01450         <span class="comment">// The operation was successful. The first thing to do is to see if</span>
01451         <span class="comment">// the device that processed the open also opened the file. If</span>
01452         <span class="comment">// not, we need to adjust the vpb reference counts. Then, if this is</span>
01453         <span class="comment">// not a query or a delete, but rather a normal open/create, return</span>
01454         <span class="comment">// the address of the FileObject to the caller and set the</span>
01455         <span class="comment">// information returned in the original requestor's I/O status block.</span>
01456         <span class="comment">// Also set the value of the parse check field in the open packet to</span>
01457         <span class="comment">// a value which will let the caller know that this routine was</span>
01458         <span class="comment">// successful in creating the file object. Finally, return the status</span>
01459         <span class="comment">// of the operation to the caller.</span>
01460         <span class="comment">//</span>
01461 
01462         <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> deviceObjectThatOpenedFile;
01463 
01464         deviceObjectThatOpenedFile = <a class="code" href="../../d4/d6/iosubs_8c.html#a76">IoGetRelatedDeviceObject</a>(fileObject);
01465         <span class="keywordflow">if</span> (deviceObject != deviceObjectThatOpenedFile) {
01466             <span class="comment">//</span>
01467             <span class="comment">// The device that opened the related file is not the one</span>
01468             <span class="comment">// that opened this file. So, readjust the vpb reference</span>
01469             <span class="comment">// counts.</span>
01470             <span class="keywordflow">if</span> (vpb) {
01471                 <a class="code" href="../../d4/d3/parse_8c.html#a5">IopDereferenceVpbAndFree</a>(vpb);
01472             }
01473             vpb = fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o3">Vpb</a>;
01474             <span class="keywordflow">if</span> (vpb) {
01475                 <a class="code" href="../../d5/d8/ex_8h.html#a235">ExInterlockedAddUlong</a>(
01476                     &amp;vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o7">ReferenceCount</a>, 1, &amp;IopVpbSpinLock );
01477             }
01478         }
01479 
01480         <span class="keywordflow">if</span> (realFileObjectRequired) {
01481 
01482             *Object = fileObject;
01483             op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o5">ParseCheck</a> = <a class="code" href="../../d0/d6/iop_8h.html#a3">OPEN_PACKET_PATTERN</a>;
01484 
01485             <span class="comment">//</span>
01486             <span class="comment">// Add a reference so the file object cannot go away before</span>
01487             <span class="comment">// the create routine gets chance to flag the object for handle</span>
01488             <span class="comment">// create.</span>
01489             <span class="comment">//</span>
01490 
01491             <a class="code" href="../../d4/d0/ob_8h.html#a15">ObReferenceObject</a>( fileObject );
01492 
01493             <span class="comment">//</span>
01494             <span class="comment">// If the filename length is zero and its not a relative open or</span>
01495             <span class="comment">// its a relative open to a volume open then set the volume open flag.</span>
01496             <span class="comment">// Also set it only for filesystem device object volume.</span>
01497             <span class="comment">//</span>
01498             <span class="keywordflow">if</span> ((!fileObject-&gt;RelatedFileObject || fileObject-&gt;RelatedFileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a172">FO_VOLUME_OPEN</a>) &amp;&amp;
01499                 (!fileObject-&gt;FileName.Length)) {
01500                 <span class="keywordflow">switch</span> (deviceObjectThatOpenedFile-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o12">DeviceType</a>) {
01501                 <span class="keywordflow">case</span> FILE_DEVICE_DISK_FILE_SYSTEM:
01502                 <span class="keywordflow">case</span> FILE_DEVICE_CD_ROM_FILE_SYSTEM:
01503                 <span class="keywordflow">case</span> FILE_DEVICE_TAPE_FILE_SYSTEM:
01504                 <span class="keywordflow">case</span> FILE_DEVICE_FILE_SYSTEM:
01505 
01506                     fileObject-&gt;Flags |= <a class="code" href="../../d0/d5/io_8h.html#a172">FO_VOLUME_OPEN</a>;
01507                     <span class="keywordflow">break</span>;
01508 
01509                 <span class="keywordflow">default</span>:
01510                     <span class="keywordflow">break</span>;
01511                 }
01512             }
01513 
01514             <span class="keywordflow">return</span> op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o3">FinalStatus</a> = ioStatus.Status;
01515 
01516         } <span class="keywordflow">else</span> {
01517 
01518             <span class="comment">//</span>
01519             <span class="comment">// This is either a quick query or delete operation.  Determine</span>
01520             <span class="comment">// which it is and quickly perform the operation.</span>
01521             <span class="comment">//</span>
01522 
01523             <span class="keywordflow">if</span> (op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o20">QueryOnly</a>) {
01524                 <a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html">PFAST_IO_DISPATCH</a> fastIoDispatch;
01525                 BOOLEAN queryResult = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01526 
01527                 fastIoDispatch = deviceObjectThatOpenedFile-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o3">DriverObject</a>-&gt;<a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html#o10">FastIoDispatch</a>;
01528 
01529                 <span class="keywordflow">if</span> (!op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o22">FullAttributes</a>) {
01530                     PFILE_BASIC_INFORMATION basicInfo = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01531 
01532                     <span class="comment">//</span>
01533                     <span class="comment">// This is a simple FAT file attribute query.  Attempt to</span>
01534                     <span class="comment">// obtain the basic information about the file.</span>
01535                     <span class="comment">//</span>
01536 
01537                     <span class="keywordflow">try</span> {
01538 
01539                         <span class="keywordflow">if</span> (fastIoDispatch &amp;&amp; fastIoDispatch-&gt;<a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html#o4">FastIoQueryBasicInfo</a>) {
01540                             queryResult = fastIoDispatch-&gt;<a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html#o4">FastIoQueryBasicInfo</a>(
01541                                             fileObject,
01542                                             TRUE,
01543                                             op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o15">BasicInformation</a>,
01544                                             &amp;ioStatus,
01545                                             deviceObjectThatOpenedFile
01546                                             );
01547                         }
01548                         <span class="keywordflow">if</span> (!queryResult) {
01549                             ULONG returnedLength;
01550 
01551                             basicInfo = <a class="code" href="../../d5/d5/cc_8h.html#a10">ExAllocatePool</a>( NonPagedPool,
01552                                                         <span class="keyword">sizeof</span>( FILE_BASIC_INFORMATION ) );
01553                             <span class="keywordflow">if</span> (basicInfo) {
01554                                 status = <a class="code" href="../../d4/d6/iosubs_8c.html#a90">IoQueryFileInformation</a>(
01555                                             fileObject,
01556                                             FileBasicInformation,
01557                                             <span class="keyword">sizeof</span>( FILE_BASIC_INFORMATION ),
01558                                             basicInfo,
01559                                             &amp;returnedLength
01560                                             );
01561                                 <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
01562                                     RtlCopyMemory( op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o15">BasicInformation</a>,
01563                                                    basicInfo,
01564                                                    returnedLength );
01565                                 }
01566                                 <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( basicInfo );
01567                             } <span class="keywordflow">else</span> {
01568                                 status = STATUS_INSUFFICIENT_RESOURCES;
01569                             }
01570                         } <span class="keywordflow">else</span> {
01571                             status = ioStatus.Status;
01572                         }
01573                     } except(EXCEPTION_EXECUTE_HANDLER) {
01574                         <span class="keywordflow">if</span> (basicInfo) {
01575                             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( basicInfo );
01576                         }
01577                         status = GetExceptionCode();
01578                     }
01579 
01580                 } <span class="keywordflow">else</span> {
01581 
01582                     <span class="comment">//</span>
01583                     <span class="comment">// This is a full attribute query.  Attempt to obtain the</span>
01584                     <span class="comment">// full network attributes for the file.  This includes</span>
01585                     <span class="comment">// both the basic and standard information about the</span>
01586                     <span class="comment">// file.  Try the fast path first, if it exists.</span>
01587                     <span class="comment">//</span>
01588 
01589                     <span class="keywordflow">if</span> (fastIoDispatch &amp;&amp;
01590                         fastIoDispatch-&gt;<a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html#o0">SizeOfFastIoDispatch</a> &gt; FIELD_OFFSET( <a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html">FAST_IO_DISPATCH</a>, FastIoQueryNetworkOpenInfo ) &amp;&amp;
01591                         fastIoDispatch-&gt;<a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html#o14">FastIoQueryNetworkOpenInfo</a>) {
01592                         queryResult = fastIoDispatch-&gt;<a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html#o14">FastIoQueryNetworkOpenInfo</a>(
01593                                         fileObject,
01594                                         TRUE,
01595                                         op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o16">NetworkInformation</a>,
01596                                         &amp;ioStatus,
01597                                         deviceObjectThatOpenedFile
01598                                         );
01599                     }
01600                     <span class="keywordflow">if</span> (!queryResult) {
01601                         ULONG returnedLength;
01602 
01603                         <span class="comment">//</span>
01604                         <span class="comment">// Either the fast dispatch routine did not exist, or</span>
01605                         <span class="comment">// it simply wasn't callable at this time.  Attempt to</span>
01606                         <span class="comment">// obtain all of the information at once via an IRP-</span>
01607                         <span class="comment">// based call.</span>
01608                         <span class="comment">//</span>
01609 
01610                         status = <a class="code" href="../../d4/d6/iosubs_8c.html#a90">IoQueryFileInformation</a>(
01611                                     fileObject,
01612                                     FileNetworkOpenInformation,
01613                                     <span class="keyword">sizeof</span>( FILE_NETWORK_OPEN_INFORMATION ),
01614                                     op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o16">NetworkInformation</a>,
01615                                     &amp;returnedLength
01616                                     );
01617 
01618                         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
01619                             <span class="keywordflow">if</span> (status == STATUS_INVALID_PARAMETER ||
01620                                 status == STATUS_NOT_IMPLEMENTED) {
01621                                 FILE_BASIC_INFORMATION basicInfo;
01622                                 FILE_STANDARD_INFORMATION stdInfo;
01623 
01624                                 <span class="comment">//</span>
01625                                 <span class="comment">// The IRP-based call did not work either, so</span>
01626                                 <span class="comment">// simply try to obtain the information by</span>
01627                                 <span class="comment">// doing IRP-based queries for the basic and</span>
01628                                 <span class="comment">// standard information and piecing together</span>
01629                                 <span class="comment">// the results into the caller's buffer.  Note</span>
01630                                 <span class="comment">// that it might be possible to perform fast</span>
01631                                 <span class="comment">// I/O operations to get the data, but it</span>
01632                                 <span class="comment">// might also fail because of the above.  So</span>
01633                                 <span class="comment">// simply query the information the long way.</span>
01634                                 <span class="comment">//</span>
01635 
01636                                 status = <a class="code" href="../../d4/d6/iosubs_8c.html#a90">IoQueryFileInformation</a>(
01637                                             fileObject,
01638                                             FileBasicInformation,
01639                                             <span class="keyword">sizeof</span>( FILE_BASIC_INFORMATION ),
01640                                             &amp;basicInfo,
01641                                             &amp;returnedLength
01642                                             );
01643                                 <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
01644                                     status = <a class="code" href="../../d4/d6/iosubs_8c.html#a90">IoQueryFileInformation</a>(
01645                                                 fileObject,
01646                                                 FileStandardInformation,
01647                                                 <span class="keyword">sizeof</span>( FILE_STANDARD_INFORMATION ),
01648                                                 &amp;stdInfo,
01649                                                 &amp;returnedLength
01650                                                 );
01651                                     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
01652                                         <a class="code" href="../../d4/d3/parse_8c.html#a2">COPY_ATTRIBUTES</a>( op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o16">NetworkInformation</a>,
01653                                                          &amp;basicInfo,
01654                                                          &amp;stdInfo );
01655                                     }
01656                                 }
01657                             }
01658                         }
01659                     }
01660                 }
01661 
01662             } <span class="keywordflow">else</span> {
01663 
01664                 <span class="comment">//</span>
01665                 <span class="comment">// There is nothing to do for a quick delete since the caller</span>
01666                 <span class="comment">// set the FILE_DELETE_ON_CLOSE CreateOption so it is already</span>
01667                 <span class="comment">// set in the file system.</span>
01668                 <span class="comment">//</span>
01669 
01670                 NOTHING;
01671 
01672             }
01673 
01674             op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o5">ParseCheck</a> = <a class="code" href="../../d0/d6/iop_8h.html#a3">OPEN_PACKET_PATTERN</a>;
01675             <span class="keywordflow">if</span> (realFileObjectRequired) {
01676                 <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
01677             } <span class="keywordflow">else</span> {
01678                 <a class="code" href="../../d3/d1/objsup_8c.html#a1">IopDeleteFile</a>( fileObject );
01679             }
01680             op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o2">FileObject</a> = (<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01681 
01682             op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o3">FinalStatus</a> = status;
01683 
01684             <span class="keywordflow">return</span> status;
01685         }
01686     }
01687 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a7" doxytag="parse.c::IopParseFile" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS IopParseFile           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>ParseObject</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>ObjectType</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d2/d5/struct__ACCESS__STATE.html">PACCESS_STATE</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>AccessState</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d0/d9/ntosdef_8h.html#a39">KPROCESSOR_MODE</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>AccessMode</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Attributes</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN OUT PUNICODE_STRING&nbsp;</td>
          <td class="mdname" nowrap> <em>CompleteName</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN OUT PUNICODE_STRING&nbsp;</td>
          <td class="mdname" nowrap> <em>RemainingName</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN OUT PVOID Context&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PSECURITY_QUALITY_OF_SERVICE <a class="el" href="../../d8/d0/ctlpcqos_8c.html#a9">SecurityQos</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PVOID *&nbsp;</td>
          <td class="mdname" nowrap> <em>Object</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d2/parse_8c-source.html#l01690">1690</a> of file <a class="el" href="../../d5/d2/parse_8c-source.html">parse.c</a>.
<p>
References <a class="el" href="../../d1/d4/io_8h-source.html#l00042">IO_TYPE_OPEN_PACKET</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l07247">IoGetRelatedDeviceObject()</a>, <a class="el" href="../../d5/d2/parse_8c-source.html#l00202">IopParseDevice()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>, <a class="el" href="../../d1/d5/iop_8h-source.html#l00212">_OPEN_PACKET::RelatedFileObject</a>, <a class="el" href="../../d8/d9/ctlnpqos_8c-source.html#l00037">SecurityQos</a>, <a class="el" href="../../d1/d5/iop_8h-source.html#l00207">_OPEN_PACKET::Size</a>, and <a class="el" href="../../d1/d5/iop_8h-source.html#l00206">_OPEN_PACKET::Type</a>.
<p>
Referenced by <a class="el" href="../../d0/d5/ioinit_8c-source.html#l01936">IopCreateObjectTypes()</a>.
<p>
<pre class="fragment"><div>01705                    :
01706 
01707     This routine interfaces to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> NT Object <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a79">Manager</a>.  It <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> invoked when
01708     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> object system <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> given <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> name of an entity to create or open and <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a>
01709     also given a handle to a directory <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> object that <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> operation <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> to be
01710     performed relative to.  This routine <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> specified as <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> parse routine <span class="keywordflow">for</span>
01711     all <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> objects.
01712 
01713     This routine simply invokes <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> parse routine <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> appropriate device
01714     that <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> associated with <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> object.  It <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> responsibility of that
01715     routine to perform <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> operation.
01716 
01717 Arguments:
01718 
01719     ParseObject - Pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> object that <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> name <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> to be opened or
01720         created relative to.
01721 
01722     ObjectType - Type of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> object being opened.
01723 
01724     AccessState - <a class="code" href="../../d4/d9/ke_8h.html#a406a193">Running</a> security access state information <span class="keywordflow">for</span> operation.
01725 
01726     AccessMode - Access mode of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> original caller.
01727 
01728     Attributes - Attributes to be applied to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> object.
01729 
01730     CompleteName - Complete name of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> object.
01731 
01732     RemainingName - Remaining name of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> object.
01733 
01734     Context - Pointer to an Open Packet (OP) from NtCreateFile service.
01735 
01736     SecurityQos - Supplies a pointer to the captured QOS information
01737         if available.
01738 
01739     Object - The address of a variable to receive the created file object, if
01740         any.
01741 
01742 Return Value:
01743 
01744     The function return value is one of the following:
01745 
01746         a)  Success - This indicates that the function succeeded and the object
01747             parameter contains the address of the created file object.
01748 
01749         b)  Error - This indicates that the file was not found or created and
01750             no file object was created.
01751 
01752         c)  Reparse - This indicates that the remaining name string has been
01753             replaced by a new name that is to be parsed.
01754 
01755 --*/
01756 
01757 {
01758     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> deviceObject;
01759     <a class="code" href="../../d3/d7/struct__OPEN__PACKET.html">POPEN_PACKET</a> op;
01760 
01761     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01762 
01763     <span class="comment">//</span>
01764     <span class="comment">// Get the address of the Open Packet (OP).</span>
01765     <span class="comment">//</span>
01766 
01767     op = (<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html">POPEN_PACKET</a>) Context;
01768 
01769     <span class="comment">//</span>
01770     <span class="comment">// Ensure that this routine is actually being invoked because someone is</span>
01771     <span class="comment">// attempting to open a device or a file through NtCreateFile.  This code</span>
01772     <span class="comment">// must be invoked from there (as opposed to some other random object</span>
01773     <span class="comment">// create or open routine).</span>
01774     <span class="comment">//</span>
01775 
01776     <span class="keywordflow">if</span> (op == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ||
01777         op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o0">Type</a> != <a class="code" href="../../d0/d5/io_8h.html#a7">IO_TYPE_OPEN_PACKET</a> ||
01778         op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o1">Size</a> != <span class="keyword">sizeof</span>( <a class="code" href="../../d3/d7/struct__OPEN__PACKET.html">OPEN_PACKET</a> )) {
01779         <span class="keywordflow">return</span> STATUS_OBJECT_TYPE_MISMATCH;
01780     }
01781 
01782     <span class="comment">//</span>
01783     <span class="comment">// Get a pointer to the device object for this file.</span>
01784     <span class="comment">//</span>
01785 
01786     deviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a76">IoGetRelatedDeviceObject</a>( (<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>) ParseObject );
01787 
01788     <span class="comment">//</span>
01789     <span class="comment">// Pass the related file object to the device object parse routine.</span>
01790     <span class="comment">//</span>
01791 
01792     op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o6">RelatedFileObject</a> = (<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>) ParseObject;
01793 
01794     <span class="comment">//</span>
01795     <span class="comment">// Open or create the specified file.</span>
01796     <span class="comment">//</span>
01797 
01798     <span class="keywordflow">return</span> <a class="code" href="../../d4/d3/parse_8c.html#a6">IopParseDevice</a>( deviceObject,
01799                            ObjectType,
01800                            AccessState,
01801                            AccessMode,
01802                            Attributes,
01803                            CompleteName,
01804                            RemainingName,
01805                            Context,
01806                            SecurityQos,
01807                            Object );
01808 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a8" doxytag="parse.c::IopQueryName" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS IopQueryName           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>Object</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN BOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>HasObjectName</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT POBJECT_NAME_INFORMATION&nbsp;</td>
          <td class="mdname" nowrap> <em>ObjectNameInfo</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Length</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>ReturnLength</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d2/parse_8c-source.html#l01811">1811</a> of file <a class="el" href="../../d5/d2/parse_8c-source.html">parse.c</a>.
<p>
References <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01517">_FILE_OBJECT::DeviceObject</a>, <a class="el" href="../../d6/d7/ex_8h-source.html#l00253">ExAllocatePoolWithTag</a>, <a class="el" href="../../d7/d2/cmwraper_8c-source.html#l00304">ExFreePool()</a>, <a class="el" href="../../d3/d1/rtload_8c-source.html#l00047">FileName</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01533">_FILE_OBJECT::Flags</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01491">FO_SYNCHRONOUS_IO</a>, <a class="el" href="../../d3/d3/internal_8c-source.html#l02256">IopGetFileName()</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l08628">IoQueryFileInformation()</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00048">NT_ERROR</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d7/d0/obquery_8c-source.html#l00713">ObQueryNameString()</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>, <a class="el" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>, <a class="el" href="../../d0/d9/ntosdef_8h.html#a76a70">UserMode</a>, and <a class="el" href="../../d5/d4/aug98_2dll32_2icc__i386_8h-source.html#l00064">USHORT</a>.
<p>
Referenced by <a class="el" href="../../d0/d5/ioinit_8c-source.html#l01936">IopCreateObjectTypes()</a>.
<p>
<pre class="fragment"><div>01821                    :
01822 
01823     This function implements <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> query name <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a69">procedure</a> <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Object <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a79">Manager</a>
01824     <span class="keywordflow">for</span> querying <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> names of <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> objects.
01825 
01826 Arguments:
01827 
01828     Object - Pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> object whose name <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> to be retrieved.
01829 
01830     HasObjectName - Indicates whether or not <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> object has a name.
01831 
01832     ObjectNameInfo - <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> in which to <span class="keywordflow">return</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> name.
01833 
01834     Length - Specifies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> length of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> output buffer, in bytes.
01835 
01836     ReturnLength - Specifies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> number of bytes actually returned in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
01837         output buffer.
01838 
01839 Return Value:
01840 
01841     The function <span class="keywordflow">return</span> value <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <span class="keyword">final</span> status of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> query operation.
01842 
01843 --*/
01844 
01845 {
01846     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
01847     ULONG lengthNeeded;
01848     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> fileObject;
01849     PUCHAR buffer;
01850     PWSTR p;
01851     POBJECT_NAME_INFORMATION deviceNameInfo;
01852     PFILE_NAME_INFORMATION fileNameInfo;
01853     ULONG length;
01854 
01855     UNREFERENCED_PARAMETER( HasObjectName );
01856 
01857     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01858 
01859     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( FIELD_OFFSET( FILE_NAME_INFORMATION, FileName ) &lt; <span class="keyword">sizeof</span>( OBJECT_NAME_INFORMATION ) );
01860 
01861     <span class="comment">//</span>
01862     <span class="comment">// Ensure that the size of the output buffer is at least the minimum</span>
01863     <span class="comment">// size required to include the basic object name information structure.</span>
01864     <span class="comment">//</span>
01865 
01866     <span class="keywordflow">if</span> (Length &lt; <span class="keyword">sizeof</span>( OBJECT_NAME_INFORMATION )) {
01867         <span class="keywordflow">return</span> STATUS_INFO_LENGTH_MISMATCH;
01868         }
01869 
01870     <span class="comment">//</span>
01871     <span class="comment">// Begin by allocating a buffer in which to build the name of the file.</span>
01872     <span class="comment">//</span>
01873 
01874     buffer = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( PagedPool, Length, '  oI' );
01875     <span class="keywordflow">if</span> (!buffer) {
01876         <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
01877         }
01878 
01879     <span class="keywordflow">try</span> {
01880 
01881         <span class="comment">//</span>
01882         <span class="comment">// Query the name of the device on which the file is open.</span>
01883         <span class="comment">//</span>
01884 
01885         fileObject = (<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>) Object;
01886         deviceNameInfo = (POBJECT_NAME_INFORMATION) buffer;
01887 
01888         status = <a class="code" href="../../d6/d1/obquery_8c.html#a7">ObQueryNameString</a>( (PVOID) fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o2">DeviceObject</a>,
01889                                     deviceNameInfo,
01890                                     Length,
01891                                     &amp;lengthNeeded );
01892         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
01893             <span class="keywordflow">return</span> status;
01894             }
01895 
01896         <span class="comment">//</span>
01897         <span class="comment">// Ensure that there is enough room in the output buffer to return the</span>
01898         <span class="comment">// name and copy it.</span>
01899         <span class="comment">//</span>
01900 
01901         RtlCopyMemory( ObjectNameInfo,
01902                        deviceNameInfo,
01903                        lengthNeeded &gt; Length ? Length : lengthNeeded );
01904         p = (PWSTR) (ObjectNameInfo + 1);
01905         ObjectNameInfo-&gt;Name.Buffer = p;
01906         p = (PWSTR) ((PCHAR) p + deviceNameInfo-&gt;Name.Length);
01907 
01908         <span class="comment">//</span>
01909         <span class="comment">// If the buffer is already full, then return.</span>
01910         <span class="comment">//</span>
01911 
01912         <span class="keywordflow">if</span> (lengthNeeded &gt; Length) {
01913             <span class="keywordflow">return</span> STATUS_BUFFER_OVERFLOW;
01914             }
01915 
01916         <span class="comment">//</span>
01917         <span class="comment">// Reset the state for the buffer to obtain the filename portion of the</span>
01918         <span class="comment">// name and calculate the remaining length of the caller's buffer.  Note</span>
01919         <span class="comment">// that in the following calculations, there are two assumptions and</span>
01920         <span class="comment">// and dependencies:</span>
01921         <span class="comment">//</span>
01922         <span class="comment">//     1)  The above query of the device name's returned length needed</span>
01923         <span class="comment">//         include a NULL character which will be included at the end</span>
01924         <span class="comment">//         of the entire name.  This is included in the calculations</span>
01925         <span class="comment">//         although it does not appear to be included.</span>
01926         <span class="comment">//</span>
01927         <span class="comment">//     2)  The sizeof the object name information buffer is assumed</span>
01928         <span class="comment">//         (and guaranteed because it can never change) to be larger</span>
01929         <span class="comment">//         than the filename offset in a file name information buffer.</span>
01930         <span class="comment">//         Therefore it is known that the new length of the "buffer"</span>
01931         <span class="comment">//         variable can be set to the remaining length plus at least 4.</span>
01932         <span class="comment">//</span>
01933 
01934         fileNameInfo = (PFILE_NAME_INFORMATION) buffer;
01935         length = Length - lengthNeeded;
01936 
01937         length += FIELD_OFFSET( FILE_NAME_INFORMATION, FileName );
01938 
01939         <span class="keywordflow">if</span> (KeGetPreviousMode() == <a class="code" href="../../d0/d9/ntosdef_8h.html#a76a70">UserMode</a> ||
01940             !(fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a151">FO_SYNCHRONOUS_IO</a>)) {
01941 
01942             <span class="comment">//</span>
01943             <span class="comment">// Query the name of the file based using an intermediary buffer.</span>
01944             <span class="comment">//</span>
01945 
01946             status = <a class="code" href="../../d4/d6/iosubs_8c.html#a90">IoQueryFileInformation</a>( fileObject,
01947                                              FileNameInformation,
01948                                              length,
01949                                              (PVOID) fileNameInfo,
01950                                              &amp;lengthNeeded );
01951             }
01952         <span class="keywordflow">else</span> {
01953 
01954             <span class="comment">//</span>
01955             <span class="comment">// This is a kernel mode request for a file that was opened for</span>
01956             <span class="comment">// synchronous I/O.  A special function that does not obtain the</span>
01957             <span class="comment">// file object lock is required, otherwise the request may deadlock</span>
01958             <span class="comment">// since the lock is probably already owned.</span>
01959             <span class="comment">//</span>
01960 
01961             status = <a class="code" href="../../d0/d6/iop_8h.html#a177">IopGetFileName</a>( fileObject,
01962                                      length,
01963                                      fileNameInfo,
01964                                      &amp;lengthNeeded );
01965             }
01966 
01967         <span class="comment">//</span>
01968         <span class="comment">// If an error occurred attempting to obtain the filename return now.  Note</span>
01969         <span class="comment">// that buffer overflow is a warning, not an error.</span>
01970         <span class="comment">//</span>
01971 
01972         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a3">NT_ERROR</a>( status )) {
01973             <span class="keywordflow">if</span> (status == STATUS_INVALID_PARAMETER ||
01974                 status == STATUS_INVALID_DEVICE_REQUEST ||
01975                 status == STATUS_NOT_IMPLEMENTED ||
01976                 status == STATUS_INVALID_INFO_CLASS) {
01977                 lengthNeeded = FIELD_OFFSET( FILE_NAME_INFORMATION, FileName );
01978                 fileNameInfo-&gt;FileNameLength = 0;
01979                 fileNameInfo-&gt;FileName[0] = OBJ_NAME_PATH_SEPARATOR;
01980                 status = STATUS_SUCCESS;
01981                 }
01982             <span class="keywordflow">else</span> {
01983                 <span class="keywordflow">return</span> status;
01984                 }
01985             }
01986 
01987         <span class="comment">//</span>
01988         <span class="comment">// Set the remaining length of the caller's buffer as well as the total</span>
01989         <span class="comment">// length needed to contain the entire name of the file.</span>
01990         <span class="comment">//</span>
01991 
01992         length = lengthNeeded - FIELD_OFFSET( FILE_NAME_INFORMATION, FileName );
01993         lengthNeeded = (ULONG)((PUCHAR) p - (PUCHAR) ObjectNameInfo) + fileNameInfo-&gt;FileNameLength;
01994 
01995         <span class="comment">//</span>
01996         <span class="comment">// Attempt to copy the name of the file into the output buffer.  Note</span>
01997         <span class="comment">// that if the file name does not begin w/a '\', then it is not volume</span>
01998         <span class="comment">// relative, so the name of the file cannot be expressed as the</span>
01999         <span class="comment">// concatenation of the name of the device and the file.  Therefore an</span>
02000         <span class="comment">// error is returned.</span>
02001         <span class="comment">//</span>
02002         <span class="comment">// The only example of this situation known at this time is when one</span>
02003         <span class="comment">// opens a directory by file ID, and then opens a file relative to that</span>
02004         <span class="comment">// directory.  When attempting to query the path, if the caller did not</span>
02005         <span class="comment">// have traverse access to open the directory, then the only name that</span>
02006         <span class="comment">// can be returned is the path name to the file from the directory, but</span>
02007         <span class="comment">// the volume-relative name cannot be returned.  Therefore, the file</span>
02008         <span class="comment">// system returns only the name of the directory and the path to the</span>
02009         <span class="comment">// file, but this is not volume-relative so the only recourse is to</span>
02010         <span class="comment">// return an error.</span>
02011         <span class="comment">//</span>
02012         <span class="comment">// Note that if the caller were to call NtQueryInformationFile and</span>
02013         <span class="comment">// request FileNameInformation, then the name above named will be</span>
02014         <span class="comment">// successfully returned from the file system.</span>
02015         <span class="comment">//</span>
02016 
02017         <span class="keywordflow">if</span> (fileNameInfo-&gt;FileName[0] != OBJ_NAME_PATH_SEPARATOR) {
02018             <span class="keywordflow">return</span> STATUS_OBJECT_PATH_INVALID;
02019             }
02020 
02021         RtlMoveMemory( p,
02022                        fileNameInfo-&gt;FileName,
02023                        length );
02024         p = (PWSTR) ((PCH) p + length);
02025         *p = <span class="charliteral">'\0'</span>;
02026         lengthNeeded += <span class="keyword">sizeof</span>( WCHAR );
02027 
02028         *ReturnLength = lengthNeeded;
02029 
02030         length = (ULONG)((PUCHAR) p - (PUCHAR) ObjectNameInfo);
02031         ObjectNameInfo-&gt;Name.Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>) (length - <span class="keyword">sizeof</span>( *ObjectNameInfo ));
02032         ObjectNameInfo-&gt;Name.MaximumLength =  (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>) ((length - <span class="keyword">sizeof</span>( *ObjectNameInfo )) + <span class="keyword">sizeof</span>( WCHAR ));
02033         }
02034 
02035     finally {
02036 
02037         <span class="comment">//</span>
02038         <span class="comment">// Finally, free the temporary buffer.</span>
02039         <span class="comment">//</span>
02040 
02041         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( buffer );
02042         }
02043 
02044     <span class="keywordflow">return</span> status;
02045 }

</div></pre>    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:45:01 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
