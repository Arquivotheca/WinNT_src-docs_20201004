<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: curdir.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>curdir.c</h1><a href="../../d5/d1/curdir_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1990  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    curdir.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    Current directory support</span>
00012 <span class="comment"></span>
00013 <span class="comment">Author:</span>
00014 <span class="comment"></span>
00015 <span class="comment">    Mark Lucovsky (markl) 10-Oct-1990</span>
00016 <span class="comment"></span>
00017 <span class="comment">Revision History:</span>
00018 <span class="comment"></span>
00019 <span class="comment">--*/</span>
00020 
00021 <span class="preprocessor">#include "nt.h"</span>
00022 <span class="preprocessor">#include "ntrtl.h"</span>
00023 <span class="preprocessor">#include "nturtl.h"</span>
00024 <span class="preprocessor">#include "string.h"</span>
00025 <span class="preprocessor">#include "ctype.h"</span>
00026 
<a name="l00027"></a><a class="code" href="../../d5/d1/curdir_8c.html#a0">00027</a> <span class="preprocessor">#define IS_PATH_SEPARATOR_U(ch) ((ch == L'\\') || (ch == L'/'))</span>
<a name="l00028"></a><a class="code" href="../../d5/d1/curdir_8c.html#a1">00028</a> <span class="preprocessor"></span><span class="preprocessor">#define IS_DOT_U(s) ( s[0] == L'.' &amp;&amp; ( IS_PATH_SEPARATOR_U(s[1]) || s[1] == UNICODE_NULL) )</span>
<a name="l00029"></a><a class="code" href="../../d5/d1/curdir_8c.html#a2">00029</a> <span class="preprocessor"></span><span class="preprocessor">#define IS_DOT_DOT_U(s) ( s[0] == L'.' &amp;&amp; s[1] == L'.' &amp;&amp; ( IS_PATH_SEPARATOR_U(s[2]) || s[2] == UNICODE_NULL) )</span>
00030 <span class="preprocessor"></span>
00031 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00032 <a class="code" href="../../d5/d1/curdir_8c.html#a15">RtlpCheckRelativeDrive</a>(
00033     WCHAR NewDrive
00034     );
00035 
00036 ULONG
00037 <a class="code" href="../../d5/d1/curdir_8c.html#a16">RtlIsDosDeviceName_Ustr</a>(
00038     IN PUNICODE_STRING DosFileName
00039     );
00040 
00041 ULONG
00042 <a class="code" href="../../d5/d1/curdir_8c.html#a17">RtlGetFullPathName_Ustr</a>(
00043     PUNICODE_STRING  FileName,
00044     ULONG nBufferLength,
00045     PWSTR lpBuffer,
00046     PWSTR *lpFilePart OPTIONAL,
00047     PBOOLEAN NameInvalid,
00048     RTL_PATH_TYPE *InputPathType
00049     );
00050 
<a name="l00051"></a><a class="code" href="../../d5/d1/curdir_8c.html#a3">00051</a> <span class="preprocessor">#define CONSTANT_UNICODE_STRING(s)   { sizeof( s ) - sizeof( WCHAR ), sizeof( s ), s }</span>
00052 <span class="preprocessor"></span>
<a name="l00053"></a><a class="code" href="../../d5/d1/curdir_8c.html#a5">00053</a> <span class="keyword">const</span> UNICODE_STRING <a class="code" href="../../d5/d1/curdir_8c.html#a5">RtlpDosLPTDevice</a> = <a class="code" href="../../d5/d1/curdir_8c.html#a3">CONSTANT_UNICODE_STRING</a>( L<span class="stringliteral">"LPT"</span> );
<a name="l00054"></a><a class="code" href="../../d5/d1/curdir_8c.html#a6">00054</a> <span class="keyword">const</span> UNICODE_STRING <a class="code" href="../../d5/d1/curdir_8c.html#a6">RtlpDosCOMDevice</a> = <a class="code" href="../../d5/d1/curdir_8c.html#a3">CONSTANT_UNICODE_STRING</a>( L<span class="stringliteral">"COM"</span> );
<a name="l00055"></a><a class="code" href="../../d5/d1/curdir_8c.html#a7">00055</a> <span class="keyword">const</span> UNICODE_STRING <a class="code" href="../../d5/d1/curdir_8c.html#a7">RtlpDosPRNDevice</a> = <a class="code" href="../../d5/d1/curdir_8c.html#a3">CONSTANT_UNICODE_STRING</a>( L<span class="stringliteral">"PRN"</span> );
<a name="l00056"></a><a class="code" href="../../d5/d1/curdir_8c.html#a8">00056</a> <span class="keyword">const</span> UNICODE_STRING <a class="code" href="../../d5/d1/curdir_8c.html#a8">RtlpDosAUXDevice</a> = <a class="code" href="../../d5/d1/curdir_8c.html#a3">CONSTANT_UNICODE_STRING</a>( L<span class="stringliteral">"AUX"</span> );
<a name="l00057"></a><a class="code" href="../../d5/d1/curdir_8c.html#a9">00057</a> <span class="keyword">const</span> UNICODE_STRING <a class="code" href="../../d5/d1/curdir_8c.html#a9">RtlpDosNULDevice</a> = <a class="code" href="../../d5/d1/curdir_8c.html#a3">CONSTANT_UNICODE_STRING</a>( L<span class="stringliteral">"NUL"</span> );
<a name="l00058"></a><a class="code" href="../../d5/d1/curdir_8c.html#a10">00058</a> <span class="keyword">const</span> UNICODE_STRING <a class="code" href="../../d5/d1/curdir_8c.html#a10">RtlpDosCONDevice</a> = <a class="code" href="../../d5/d1/curdir_8c.html#a3">CONSTANT_UNICODE_STRING</a>( L<span class="stringliteral">"CON"</span> );
00059 
<a name="l00060"></a><a class="code" href="../../d5/d1/curdir_8c.html#a11">00060</a> <span class="keyword">const</span> UNICODE_STRING <a class="code" href="../../d5/d1/curdir_8c.html#a11">RtlpDosSlashCONDevice</a>   = <a class="code" href="../../d5/d1/curdir_8c.html#a3">CONSTANT_UNICODE_STRING</a>( L<span class="stringliteral">"\\\\.\\CON"</span> );
<a name="l00061"></a><a class="code" href="../../d5/d1/curdir_8c.html#a12">00061</a> <span class="keyword">const</span> UNICODE_STRING <a class="code" href="../../d5/d1/curdir_8c.html#a12">RtlpSlashSlashDot</a>       = <a class="code" href="../../d5/d1/curdir_8c.html#a3">CONSTANT_UNICODE_STRING</a>( L<span class="stringliteral">"\\\\.\\"</span> );
<a name="l00062"></a><a class="code" href="../../d5/d1/curdir_8c.html#a13">00062</a> <span class="keyword">const</span> UNICODE_STRING <a class="code" href="../../d5/d1/curdir_8c.html#a13">RtlpDosDevicesPrefix</a>    = <a class="code" href="../../d5/d1/curdir_8c.html#a3">CONSTANT_UNICODE_STRING</a>( L<span class="stringliteral">"\\??\\"</span> );
<a name="l00063"></a><a class="code" href="../../d5/d1/curdir_8c.html#a14">00063</a> <span class="keyword">const</span> UNICODE_STRING <a class="code" href="../../d5/d1/curdir_8c.html#a14">RtlpDosDevicesUncPrefix</a> = <a class="code" href="../../d5/d1/curdir_8c.html#a3">CONSTANT_UNICODE_STRING</a>( L<span class="stringliteral">"\\??\\UNC\\"</span> );
00064 
<a name="l00065"></a><a class="code" href="../../d5/d1/curdir_8c.html#a4">00065</a> <span class="preprocessor">#define RtlpLongestPrefix   RtlpDosDevicesUncPrefix.Length</span>
00066 <span class="preprocessor"></span>
00067 ULONG
<a name="l00068"></a><a class="code" href="../../d5/d1/curdir_8c.html#a18">00068</a> <a class="code" href="../../d5/d1/curdir_8c.html#a18">RtlpComputeBackupIndex</a>(
00069     IN PCURDIR CurDir
00070     )
00071 {
00072     ULONG BackupIndex;
00073     PWSTR UncPathPointer;
00074     ULONG NumberOfPathSeparators;
00075     RTL_PATH_TYPE CurDirPathType;
00076 
00077 
00078     <span class="comment">//</span>
00079     <span class="comment">// Get pathType of curdir</span>
00080     <span class="comment">//</span>
00081 
00082     CurDirPathType = <a class="code" href="../../d5/d1/curdir_8c.html#a23">RtlDetermineDosPathNameType_U</a>(CurDir-&gt;DosPath.Buffer);
00083     BackupIndex = 3;
00084     <span class="keywordflow">if</span> ( CurDirPathType == RtlPathTypeUncAbsolute ) {
00085 
00086         <span class="comment">//</span>
00087         <span class="comment">// We want to scan the supplied path to determine where</span>
00088         <span class="comment">// the "share" ends, and set BackupIndex to that point.</span>
00089         <span class="comment">//</span>
00090 
00091         UncPathPointer = CurDir-&gt;DosPath.Buffer + 2;
00092         NumberOfPathSeparators = 0;
00093         <span class="keywordflow">while</span> (*UncPathPointer) {
00094             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d1/curdir_8c.html#a0">IS_PATH_SEPARATOR_U</a>(*UncPathPointer)) {
00095 
00096                 NumberOfPathSeparators++;
00097 
00098                 <span class="keywordflow">if</span> (NumberOfPathSeparators == 2) {
00099                     <span class="keywordflow">break</span>;
00100                     }
00101                 }
00102 
00103             UncPathPointer++;
00104 
00105             }
00106 
00107         BackupIndex = (ULONG)(UncPathPointer - CurDir-&gt;DosPath.Buffer);
00108         }
00109     <span class="keywordflow">return</span> BackupIndex;
00110 }
00111 
00112 
00113 ULONG
<a name="l00114"></a><a class="code" href="../../d5/d1/curdir_8c.html#a19">00114</a> <a class="code" href="../../d5/d1/curdir_8c.html#a19">RtlGetLongestNtPathLength</a>( VOID )
00115 {
00116     <span class="keywordflow">return</span> <a class="code" href="../../d5/d1/curdir_8c.html#a4">RtlpLongestPrefix</a> + DOS_MAX_PATH_LENGTH + 1;
00117 }
00118 
00119 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00120"></a><a class="code" href="../../d5/d1/curdir_8c.html#a20">00120</a> <a class="code" href="../../d5/d1/curdir_8c.html#a20">RtlpResetDriveEnvironment</a>(
00121     IN WCHAR DriveLetter
00122     )
00123 {
00124     WCHAR EnvVarNameBuffer[4];
00125     WCHAR EnvVarNameValue[4];
00126     UNICODE_STRING s1,s2;
00127 
00128     EnvVarNameBuffer[0] = <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'='</span>;
00129     EnvVarNameBuffer[1] = DriveLetter;
00130     EnvVarNameBuffer[2] = <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">':'</span>;
00131     EnvVarNameBuffer[3] = <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\0'</span>;
00132     <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;s1,EnvVarNameBuffer);
00133 
00134     EnvVarNameValue[0] = DriveLetter;
00135     EnvVarNameValue[1] = <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">':'</span>;
00136     EnvVarNameValue[2] = <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span>;
00137     EnvVarNameValue[3] = <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\0'</span>;
00138     <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;s2,EnvVarNameValue);
00139 
00140     <a class="code" href="../../d5/d7/environ_8c.html#a7">RtlSetEnvironmentVariable</a>(<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,&amp;s1,&amp;s2);
00141 }
00142 
00143 
00144 ULONG
<a name="l00145"></a><a class="code" href="../../d5/d1/curdir_8c.html#a21">00145</a> <a class="code" href="../../d5/d1/curdir_8c.html#a21">RtlGetCurrentDirectory_U</a>(
00146     ULONG nBufferLength,
00147     PWSTR lpBuffer
00148     )
00149 
00150 <span class="comment">/*++</span>
00151 <span class="comment"></span>
00152 <span class="comment">Routine Description:</span>
00153 <span class="comment"></span>
00154 <span class="comment">    The current directory for a process can be retreived using</span>
00155 <span class="comment">    GetCurrentDirectory.</span>
00156 <span class="comment"></span>
00157 <span class="comment">Arguments:</span>
00158 <span class="comment"></span>
00159 <span class="comment">    nBufferLength - Supplies the length in bytes of the buffer that is to</span>
00160 <span class="comment">        receive the current directory string.</span>
00161 <span class="comment"></span>
00162 <span class="comment">    lpBuffer - Returns the current directory string for the current</span>
00163 <span class="comment">        process.  The string is a null terminated string and specifies</span>
00164 <span class="comment">        the absolute path to the current directory.</span>
00165 <span class="comment"></span>
00166 <span class="comment">Return Value:</span>
00167 <span class="comment"></span>
00168 <span class="comment">    The return value is the length of the string copied to lpBuffer, not</span>
00169 <span class="comment">    including the terminating null character.  If the return value is</span>
00170 <span class="comment">    greater than nBufferLength, the return value is the size of the buffer</span>
00171 <span class="comment">    required to hold the pathname.  The return value is zero if the</span>
00172 <span class="comment">    function failed.</span>
00173 <span class="comment"></span>
00174 <span class="comment">--*/</span>
00175 
00176 {
00177     PCURDIR CurDir;
00178     ULONG Length;
00179     PWSTR  CurDirName;
00180 
00181     CurDir = &amp;(NtCurrentPeb()-&gt;ProcessParameters-&gt;CurrentDirectory);
00182 
00183     <a class="code" href="../../d2/d4/eballoc_8c.html#a1">RtlAcquirePebLock</a>();
00184     CurDirName = CurDir-&gt;DosPath.Buffer;
00185 
00186     <span class="comment">//</span>
00187     <span class="comment">// Make sure user's buffer is big enough to hold the null</span>
00188     <span class="comment">// terminated current directory</span>
00189     <span class="comment">//</span>
00190 
00191     Length = CurDir-&gt;DosPath.Length&gt;&gt;1;
00192     <span class="keywordflow">if</span> (CurDirName[Length-2] != <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">':'</span>) {
00193         <span class="keywordflow">if</span> ( nBufferLength &lt; (Length)&lt;&lt;1 ) {
00194             <a class="code" href="../../d2/d4/eballoc_8c.html#a2">RtlReleasePebLock</a>();
00195             <span class="keywordflow">return</span> (Length)&lt;&lt;1;
00196             }
00197         }
00198     <span class="keywordflow">else</span> {
00199         <span class="keywordflow">if</span> ( nBufferLength &lt;= (Length&lt;&lt;1) ) {
00200             <a class="code" href="../../d2/d4/eballoc_8c.html#a2">RtlReleasePebLock</a>();
00201             <span class="keywordflow">return</span> ((Length+1)&lt;&lt;1);
00202             }
00203         }
00204 
00205     <span class="keywordflow">try</span> {
00206         RtlMoveMemory(lpBuffer,CurDirName,Length&lt;&lt;1);
00207         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(lpBuffer[Length-1] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span>);
00208         <span class="keywordflow">if</span> (lpBuffer[Length-2] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">':'</span>) {
00209             lpBuffer[Length] = UNICODE_NULL;
00210             }
00211         <span class="keywordflow">else</span> {
00212             lpBuffer[Length-1] = UNICODE_NULL;
00213             Length--;
00214             }
00215         }
00216     except (<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
00217         <a class="code" href="../../d2/d4/eballoc_8c.html#a2">RtlReleasePebLock</a>();
00218         <span class="keywordflow">return</span> 0<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>;
00219         }
00220     <a class="code" href="../../d2/d4/eballoc_8c.html#a2">RtlReleasePebLock</a>();
00221     <span class="keywordflow">return</span> Length&lt;&lt;1;
00222 }
00223 
00224 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00225"></a><a class="code" href="../../d5/d1/curdir_8c.html#a22">00225</a> <a class="code" href="../../d5/d1/curdir_8c.html#a22">RtlSetCurrentDirectory_U</a>(
00226     PUNICODE_STRING PathName
00227     )
00228 
00229 <span class="comment">/*++</span>
00230 <span class="comment"></span>
00231 <span class="comment">Routine Description:</span>
00232 <span class="comment"></span>
00233 <span class="comment">    The current directory for a process is changed using</span>
00234 <span class="comment">    SetCurrentDirectory.</span>
00235 <span class="comment"></span>
00236 <span class="comment">    Each process has a single current directory.  A current directory is</span>
00237 <span class="comment">    made up of type parts.</span>
00238 <span class="comment"></span>
00239 <span class="comment">        - A disk designator either which is either a drive letter followed</span>
00240 <span class="comment">          by a colon, or a UNC servername/sharename "\\servername\sharename".</span>
00241 <span class="comment"></span>
00242 <span class="comment">        - A directory on the disk designator.</span>
00243 <span class="comment"></span>
00244 <span class="comment">    For APIs that manipulate files, the file names may be relative to</span>
00245 <span class="comment">    the current directory.  A filename is relative to the entire current</span>
00246 <span class="comment">    directory if it does not begin with a disk designator or a path name</span>
00247 <span class="comment">    SEPARATOR.  If the file name begins with a path name SEPARATOR, then</span>
00248 <span class="comment">    it is relative to the disk designator of the current directory.  If</span>
00249 <span class="comment">    a file name begins with a disk designator, than it is a fully</span>
00250 <span class="comment">    qualified absolute path name.</span>
00251 <span class="comment"></span>
00252 <span class="comment">    The value of lpPathName supplies the current directory.  The value</span>
00253 <span class="comment">    of lpPathName, may be a relative path name as described above, or a</span>
00254 <span class="comment">    fully qualified absolute path name.  In either case, the fully</span>
00255 <span class="comment">    qualified absolute path name of the specified directory is</span>
00256 <span class="comment">    calculated and is stored as the current directory.</span>
00257 <span class="comment"></span>
00258 <span class="comment">Arguments:</span>
00259 <span class="comment"></span>
00260 <span class="comment">    lpPathName - Supplies the pathname of the directory that is to be</span>
00261 <span class="comment">        made the current directory.</span>
00262 <span class="comment"></span>
00263 <span class="comment">Return Value:</span>
00264 <span class="comment"></span>
00265 <span class="comment">    NT_SUCCESS - The operation was successful</span>
00266 <span class="comment"></span>
00267 <span class="comment">    !NT_SUCCESS - The operation failed</span>
00268 <span class="comment"></span>
00269 <span class="comment">--*/</span>
00270 
00271 {
00272     PCURDIR CurDir;
00273     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00274     BOOLEAN TranslationStatus;
00275     PVOID FreeBuffer;
00276     ULONG DosDirLength;
00277     ULONG IsDevice;
00278     ULONG DosDirCharCount;
00279     UNICODE_STRING DosDir;
00280     UNICODE_STRING NtFileName;
00281     HANDLE NewDirectoryHandle;
00282     OBJECT_ATTRIBUTES Obja;
00283     IO_STATUS_BLOCK IoStatusBlock;
00284     FILE_FS_DEVICE_INFORMATION DeviceInfo;
00285     RTL_PATH_TYPE InputPathType;
00286 
00287     CurDir = &amp;(NtCurrentPeb()-&gt;ProcessParameters-&gt;CurrentDirectory);
00288 
00289 
00290     DosDir.Buffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00291     FreeBuffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00292     NewDirectoryHandle = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00293 
00294     <a class="code" href="../../d2/d4/eballoc_8c.html#a1">RtlAcquirePebLock</a>();
00295 
00296     NtCurrentPeb()-&gt;EnvironmentUpdateCount += 1;
00297 
00298     <span class="comment">//</span>
00299     <span class="comment">// Set current directory is called first by the loader.</span>
00300     <span class="comment">// If current directory is not being inherited, then close</span>
00301     <span class="comment">// it !</span>
00302     <span class="comment">//</span>
00303 
00304     <span class="keywordflow">if</span> ( ((ULONG_PTR)CurDir-&gt;Handle &amp; OBJ_HANDLE_TAGBITS) == RTL_USER_PROC_CURDIR_CLOSE ) {
00305         <a class="code" href="../../d5/d0/obclose_8c.html#a1">NtClose</a>(CurDir-&gt;Handle);
00306         CurDir-&gt;Handle = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00307         }
00308 
00309     <span class="keywordflow">try</span> {
00310         <span class="keywordflow">try</span> {
00311 
00312             <span class="comment">//</span>
00313             <span class="comment">// Compute the length of the Dos style fully qualified current</span>
00314             <span class="comment">// directory</span>
00315             <span class="comment">//</span>
00316 
00317             DosDirLength = CurDir-&gt;DosPath.MaximumLength;
00318             DosDir.Buffer = <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a0">RtlAllocateHeap</a>(RtlProcessHeap(), 0,DosDirLength);
00319             <span class="keywordflow">if</span> ( !DosDir.Buffer ) {
00320                 <span class="keywordflow">return</span> STATUS_NO_MEMORY;
00321                 }
00322             DosDir.Length = 0;
00323             DosDir.MaximumLength = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)DosDirLength;
00324 
00325             <span class="comment">//</span>
00326             <span class="comment">// Now get the full pathname for the Dos style current</span>
00327             <span class="comment">// directory</span>
00328             <span class="comment">//</span>
00329 
00330             IsDevice = <a class="code" href="../../d5/d1/curdir_8c.html#a16">RtlIsDosDeviceName_Ustr</a>(PathName);
00331             <span class="keywordflow">if</span> ( IsDevice ) {
00332                 <span class="keywordflow">return</span> STATUS_NOT_A_DIRECTORY;
00333                 }
00334 
00335             DosDirLength = <a class="code" href="../../d5/d1/curdir_8c.html#a17">RtlGetFullPathName_Ustr</a>(
00336                                 PathName,
00337                                 DosDirLength,
00338                                 DosDir.Buffer,
00339                                 <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00340                                 <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00341                                 &amp;InputPathType
00342                                 );
00343 
00344             <span class="keywordflow">if</span> ( !DosDirLength ) {
00345                 <span class="keywordflow">return</span> STATUS_OBJECT_NAME_INVALID;
00346                 }
00347 
00348             DosDirCharCount = DosDirLength &gt;&gt; 1;
00349 
00350 
00351             <span class="comment">//</span>
00352             <span class="comment">// Get the Nt filename of the new current directory</span>
00353             <span class="comment">//</span>
00354             TranslationStatus = <a class="code" href="../../d5/d1/curdir_8c.html#a29">RtlDosPathNameToNtPathName_U</a>(
00355                                     DosDir.Buffer,
00356                                     &amp;NtFileName,
00357                                     <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00358                                     <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>
00359                                     );
00360 
00361             <span class="keywordflow">if</span> ( !TranslationStatus ) {
00362                 <span class="keywordflow">return</span> STATUS_OBJECT_NAME_INVALID;
00363                 }
00364             FreeBuffer = NtFileName.Buffer;
00365 
00366             InitializeObjectAttributes(
00367                 &amp;Obja,
00368                 &amp;NtFileName,
00369                 OBJ_CASE_INSENSITIVE | OBJ_INHERIT,
00370                 <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00371                 <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>
00372                 );
00373 
00374             <span class="comment">//</span>
00375             <span class="comment">// If we are inheriting current directory, then</span>
00376             <span class="comment">// avoid the open</span>
00377             <span class="comment">//</span>
00378 
00379             <span class="keywordflow">if</span> ( ((ULONG_PTR)CurDir-&gt;Handle &amp; OBJ_HANDLE_TAGBITS) ==  RTL_USER_PROC_CURDIR_INHERIT ) {
00380                 NewDirectoryHandle = (HANDLE)((ULONG_PTR)CurDir-&gt;Handle &amp; ~OBJ_HANDLE_TAGBITS);
00381                 CurDir-&gt;Handle = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00382 
00383                 <span class="comment">//</span>
00384                 <span class="comment">// Test to see if this is removable media. If so</span>
00385                 <span class="comment">// tag the handle this may fail if the process was</span>
00386                 <span class="comment">// created with inherit handles set to false</span>
00387                 <span class="comment">//</span>
00388 
00389                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d8/d2/qsfs_8c.html#a0">NtQueryVolumeInformationFile</a>(
00390                             NewDirectoryHandle,
00391                             &amp;IoStatusBlock,
00392                             &amp;DeviceInfo,
00393                             <span class="keyword">sizeof</span>(DeviceInfo),
00394                             FileFsDeviceInformation
00395                             );
00396                 <span class="keywordflow">if</span> ( !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>) ) {
00397                     <span class="keywordflow">return</span> <a class="code" href="../../d5/d1/curdir_8c.html#a22">RtlSetCurrentDirectory_U</a>(PathName);
00398                     }
00399                 <span class="keywordflow">else</span> {
00400                     <span class="keywordflow">if</span> ( DeviceInfo.Characteristics &amp; FILE_REMOVABLE_MEDIA ) {
00401                         NewDirectoryHandle =(HANDLE)( (ULONG_PTR)NewDirectoryHandle | 1);
00402                         }
00403                     }
00404 
00405                 }
00406             <span class="keywordflow">else</span> {
00407                 <span class="comment">//</span>
00408                 <span class="comment">// Open a handle to the current directory. Don't allow</span>
00409                 <span class="comment">// deletes of the directory.</span>
00410                 <span class="comment">//</span>
00411 
00412                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d4/d2/open_8c.html#a0">NtOpenFile</a>(
00413                             &amp;NewDirectoryHandle,
00414                             FILE_TRAVERSE | SYNCHRONIZE,
00415                             &amp;Obja,
00416                             &amp;IoStatusBlock,
00417                             FILE_SHARE_READ | FILE_SHARE_WRITE,
00418                             FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT
00419                             );
00420 
00421                 <span class="keywordflow">if</span> ( !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>) ) {
00422                     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00423                     }
00424 
00425                 <span class="comment">//</span>
00426                 <span class="comment">// Test to see if this is removable media. If so</span>
00427                 <span class="comment">// tag the handle</span>
00428                 <span class="comment">//</span>
00429                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d8/d2/qsfs_8c.html#a0">NtQueryVolumeInformationFile</a>(
00430                             NewDirectoryHandle,
00431                             &amp;IoStatusBlock,
00432                             &amp;DeviceInfo,
00433                             <span class="keyword">sizeof</span>(DeviceInfo),
00434                             FileFsDeviceInformation
00435                             );
00436                 <span class="keywordflow">if</span> ( !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>) ) {
00437                     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00438                     }
00439                 <span class="keywordflow">else</span> {
00440                     <span class="keywordflow">if</span> ( DeviceInfo.Characteristics &amp; FILE_REMOVABLE_MEDIA ) {
00441                         NewDirectoryHandle =(HANDLE)( (ULONG_PTR)NewDirectoryHandle | 1);
00442                         }
00443                     }
00444                 }
00445 
00446             <span class="comment">//</span>
00447             <span class="comment">// If there is no trailing '\', than place one</span>
00448             <span class="comment">//</span>
00449 
00450             <span class="keywordflow">if</span> ( DosDir.Buffer[DosDirCharCount] != <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span> &amp;&amp;
00451                  DosDir.Buffer[DosDirCharCount-1] != <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span>) {
00452                 DosDir.Buffer[DosDirCharCount] = <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span>;
00453                 DosDir.Buffer[DosDirCharCount+1] = UNICODE_NULL;
00454                 DosDir.Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(DosDirLength + <span class="keyword">sizeof</span>(UNICODE_NULL));
00455                 }
00456             <span class="keywordflow">else</span> {
00457                 DosDir.Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)DosDirLength;
00458                 }
00459 
00460             <span class="comment">//</span>
00461             <span class="comment">// Now we are set to change to the new directory.</span>
00462             <span class="comment">//</span>
00463 
00464             RtlMoveMemory( CurDir-&gt;DosPath.Buffer, DosDir.Buffer, DosDir.Length+<span class="keyword">sizeof</span>(UNICODE_NULL) );
00465             CurDir-&gt;DosPath.Length = DosDir.Length;
00466 
00467             <span class="keywordflow">if</span> ( CurDir-&gt;Handle ) {
00468                 <a class="code" href="../../d5/d0/obclose_8c.html#a1">NtClose</a>(CurDir-&gt;Handle);
00469                 }
00470             CurDir-&gt;Handle = NewDirectoryHandle;
00471             NewDirectoryHandle = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00472             }
00473         finally {
00474             <span class="keywordflow">if</span> ( DosDir.Buffer ) {
00475                 <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>(RtlProcessHeap(), 0, DosDir.Buffer);
00476                 }
00477             <span class="keywordflow">if</span> ( FreeBuffer ) {
00478                 <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>(RtlProcessHeap(), 0, FreeBuffer);
00479                 }
00480             <span class="keywordflow">if</span> ( NewDirectoryHandle ) {
00481                 <a class="code" href="../../d5/d0/obclose_8c.html#a1">NtClose</a>(NewDirectoryHandle);
00482                 }
00483             <a class="code" href="../../d2/d4/eballoc_8c.html#a2">RtlReleasePebLock</a>();
00484             }
00485         }
00486     except (<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
00487         <span class="keywordflow">return</span> STATUS_ACCESS_VIOLATION;
00488         }
00489     <span class="keywordflow">return</span> STATUS_SUCCESS;
00490 }
00491 
00492 RTL_PATH_TYPE
<a name="l00493"></a><a class="code" href="../../d5/d1/curdir_8c.html#a23">00493</a> <a class="code" href="../../d5/d1/curdir_8c.html#a23">RtlDetermineDosPathNameType_U</a>(
00494     IN PCWSTR DosFileName
00495     )
00496 
00497 <span class="comment">/*++</span>
00498 <span class="comment"></span>
00499 <span class="comment">Routine Description:</span>
00500 <span class="comment"></span>
00501 <span class="comment">    This function examines the Dos format file name and determines the</span>
00502 <span class="comment">    type of file name (i.e.  UNC, DriveAbsolute, Current Directory</span>
00503 <span class="comment">    rooted, or Relative.</span>
00504 <span class="comment"></span>
00505 <span class="comment">Arguments:</span>
00506 <span class="comment"></span>
00507 <span class="comment">    DosFileName - Supplies the Dos format file name whose type is to be</span>
00508 <span class="comment">        determined.</span>
00509 <span class="comment"></span>
00510 <span class="comment">Return Value:</span>
00511 <span class="comment"></span>
00512 <span class="comment">    RtlPathTypeUnknown - The path type can not be determined</span>
00513 <span class="comment"></span>
00514 <span class="comment">    RtlPathTypeUncAbsolute - The path specifies a Unc absolute path</span>
00515 <span class="comment">        in the format \\server-name\sharename\rest-of-path</span>
00516 <span class="comment"></span>
00517 <span class="comment">    RtlPathTypeLocalDevice - The path specifies a local device in the format</span>
00518 <span class="comment">        \\.\rest-of-path this can be used for any device where the nt and</span>
00519 <span class="comment">        Win32 names are the same. For example mailslots.</span>
00520 <span class="comment"></span>
00521 <span class="comment">    RtlPathTypeRootLocalDevice - The path specifies the root of the local</span>
00522 <span class="comment">        devices in the format \\.</span>
00523 <span class="comment"></span>
00524 <span class="comment">    RtlPathTypeDriveAbsolute - The path specifies a drive letter absolute</span>
00525 <span class="comment">        path in the form drive:\rest-of-path</span>
00526 <span class="comment"></span>
00527 <span class="comment">    RtlPathTypeDriveRelative - The path specifies a drive letter relative</span>
00528 <span class="comment">        path in the form drive:rest-of-path</span>
00529 <span class="comment"></span>
00530 <span class="comment">    RtlPathTypeRooted - The path is rooted relative to the current disk</span>
00531 <span class="comment">        designator (either Unc disk, or drive). The form is \rest-of-path.</span>
00532 <span class="comment"></span>
00533 <span class="comment">    RtlPathTypeRelative - The path is relative (i.e. not absolute or rooted).</span>
00534 <span class="comment"></span>
00535 <span class="comment">--*/</span>
00536 
00537 {
00538 
00539     RTL_PATH_TYPE ReturnValue;
00540 
00541     <span class="keywordflow">if</span> ( <a class="code" href="../../d5/d1/curdir_8c.html#a0">IS_PATH_SEPARATOR_U</a>(*DosFileName) ) {
00542         <span class="keywordflow">if</span> ( <a class="code" href="../../d5/d1/curdir_8c.html#a0">IS_PATH_SEPARATOR_U</a>(*(DosFileName+1)) ) {
00543             <span class="keywordflow">if</span> ( DosFileName[2] == <span class="charliteral">'.'</span> ) {
00544                 <span class="keywordflow">if</span> ( <a class="code" href="../../d5/d1/curdir_8c.html#a0">IS_PATH_SEPARATOR_U</a>(*(DosFileName+3)) ){
00545                     ReturnValue = RtlPathTypeLocalDevice;
00546                     }
00547                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( (*(DosFileName+3)) == UNICODE_NULL ){
00548                     ReturnValue = RtlPathTypeRootLocalDevice;
00549                     }
00550                 <span class="keywordflow">else</span> {
00551                     ReturnValue = RtlPathTypeUncAbsolute;
00552                     }
00553                 }
00554             <span class="keywordflow">else</span> {
00555                 ReturnValue = RtlPathTypeUncAbsolute;
00556                 }
00557             }
00558         <span class="keywordflow">else</span> {
00559             ReturnValue = RtlPathTypeRooted;
00560             }
00561         }
00562     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*DosFileName &amp;&amp; *(DosFileName+1)==<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">':'</span>) {
00563             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d1/curdir_8c.html#a0">IS_PATH_SEPARATOR_U</a>(*(DosFileName+2))) {
00564                 ReturnValue = RtlPathTypeDriveAbsolute;
00565                 }
00566             <span class="keywordflow">else</span>  {
00567                 ReturnValue = RtlPathTypeDriveRelative;
00568                 }
00569             }
00570     <span class="keywordflow">else</span> {
00571         ReturnValue = RtlPathTypeRelative;
00572         }
00573     <span class="keywordflow">return</span> ReturnValue;
00574 }
00575 
00576 ULONG
<a name="l00577"></a><a class="code" href="../../d5/d1/curdir_8c.html#a16">00577</a> <a class="code" href="../../d5/d1/curdir_8c.html#a16">RtlIsDosDeviceName_Ustr</a>(
00578     IN PUNICODE_STRING DosFileName
00579     )
00580 
00581 <span class="comment">/*++</span>
00582 <span class="comment"></span>
00583 <span class="comment">Routine Description:</span>
00584 <span class="comment"></span>
00585 <span class="comment">    This function examines the Dos format file name and determines if it</span>
00586 <span class="comment">    is a Dos device name (e.g. LPT1, etc.).  Valid Dos device names are:</span>
00587 <span class="comment"></span>
00588 <span class="comment">        LPTn</span>
00589 <span class="comment">        COMn</span>
00590 <span class="comment">        PRN</span>
00591 <span class="comment">        AUX</span>
00592 <span class="comment">        NUL</span>
00593 <span class="comment">        CON</span>
00594 <span class="comment"></span>
00595 <span class="comment">    when n is a digit.  Trailing colon is ignored if present.</span>
00596 <span class="comment"></span>
00597 <span class="comment">Arguments:</span>
00598 <span class="comment"></span>
00599 <span class="comment">    DosFileName - Supplies the Dos format file name that is to be examined.</span>
00600 <span class="comment"></span>
00601 <span class="comment">Return Value:</span>
00602 <span class="comment"></span>
00603 <span class="comment">    0 - Specified Dos file name is not the name of a Dos device.</span>
00604 <span class="comment"></span>
00605 <span class="comment">    &gt; 0 - Specified Dos file name is the name of a Dos device and the</span>
00606 <span class="comment">          return value is a ULONG where the high order 16 bits is the</span>
00607 <span class="comment">          offset in the input buffer where the dos device name beings</span>
00608 <span class="comment">          and the low order 16 bits is the length of the device name</span>
00609 <span class="comment">          the length of the name (excluding any optional</span>
00610 <span class="comment">          trailing colon).</span>
00611 <span class="comment"></span>
00612 <span class="comment">--*/</span>
00613 
00614 {
00615     UNICODE_STRING UnicodeString;
00616     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> NumberOfCharacters;
00617     ULONG ReturnLength;
00618     ULONG ReturnOffset;
00619     LPWSTR p;
00620     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> ColonBias;
00621     RTL_PATH_TYPE PathType;
00622     WCHAR wch;
00623 
00624     ColonBias = 0;
00625 
00626     PathType = <a class="code" href="../../d5/d1/curdir_8c.html#a23">RtlDetermineDosPathNameType_U</a>(DosFileName-&gt;Buffer);
00627     <span class="keywordflow">switch</span> ( PathType ) {
00628 
00629     <span class="keywordflow">case</span> RtlPathTypeLocalDevice:
00630         <span class="comment">//</span>
00631         <span class="comment">// For Unc Absolute, Check for \\.\CON</span>
00632         <span class="comment">// since this really is not a device</span>
00633         <span class="comment">//</span>
00634 
00635         <span class="keywordflow">if</span> ( <a class="code" href="../../d6/d6/nls_8c.html#a42">RtlEqualUnicodeString</a>(DosFileName,&amp;<a class="code" href="../../d5/d1/curdir_8c.html#a11">RtlpDosSlashCONDevice</a>,<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) ) {
00636             <span class="keywordflow">return</span> 0x00080006;
00637         }
00638 
00639         <span class="comment">//</span>
00640         <span class="comment">// FALLTHRU</span>
00641         <span class="comment">//</span>
00642 
00643     <span class="keywordflow">case</span> RtlPathTypeUncAbsolute:
00644     <span class="keywordflow">case</span> RtlPathTypeUnknown:
00645         <span class="keywordflow">return</span> 0;
00646     }
00647 
00648     UnicodeString = *DosFileName;
00649     NumberOfCharacters = DosFileName-&gt;Length &gt;&gt; 1;
00650 
00651     <span class="keywordflow">if</span> (NumberOfCharacters &amp;&amp; DosFileName-&gt;Buffer[NumberOfCharacters-1] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">':'</span>) {
00652         UnicodeString.Length -= <span class="keyword">sizeof</span>(WCHAR);
00653         NumberOfCharacters--;
00654         ColonBias = 1;
00655     }
00656 
00657     <span class="comment">//</span>
00658     <span class="comment">// The above strip the trailing colon logic could have left us with 0</span>
00659     <span class="comment">// for NumberOfCharacters, so that needs to be tested</span>
00660     <span class="comment">//</span>
00661 
00662     <span class="keywordflow">if</span> ( NumberOfCharacters == 0 ) {
00663         <span class="keywordflow">return</span> 0;
00664         }
00665 
00666     wch = UnicodeString.Buffer[NumberOfCharacters-1];
00667     <span class="keywordflow">while</span> ( NumberOfCharacters &amp;&amp; (wch == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'.'</span> || wch == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">' '</span>) ) {
00668         UnicodeString.Length -= <span class="keyword">sizeof</span>(WCHAR);
00669         NumberOfCharacters--;
00670         ColonBias++;
00671         wch = UnicodeString.Buffer[NumberOfCharacters-1];
00672     }
00673 
00674     ReturnLength = NumberOfCharacters &lt;&lt; 1;
00675 
00676     <span class="comment">//</span>
00677     <span class="comment">//  Walk backwards through the string finding the</span>
00678     <span class="comment">//  first slash or the beginning of the string.  We also stop</span>
00679     <span class="comment">//  at the drive: if it is present.</span>
00680     <span class="comment">//</span>
00681 
00682     ReturnOffset = 0;
00683     <span class="keywordflow">if</span> ( NumberOfCharacters ) {
00684         p = UnicodeString.Buffer + NumberOfCharacters-1;
00685         <span class="keywordflow">while</span> ( p &gt;= UnicodeString.Buffer ) {
00686             <span class="keywordflow">if</span> ( *p == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span> || *p == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'/'</span>
00687                  || (*p == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">':'</span> &amp;&amp; p == UnicodeString.Buffer + 1)) {
00688                 p++;
00689 
00690                 <span class="comment">//</span>
00691                 <span class="comment">//  Get the first char of the file name and convert it to</span>
00692                 <span class="comment">//  lower case.  This will be safe since we will be comparing</span>
00693                 <span class="comment">//  it to only lower-case ASCII.</span>
00694                 <span class="comment">//</span>
00695 
00696                 wch = (*p) | 0x20;
00697 
00698                 <span class="comment">//</span>
00699                 <span class="comment">//  check to see if we possibly have a hit on</span>
00700                 <span class="comment">//  lpt, prn, con, com, aux, or nul</span>
00701                 <span class="comment">//</span>
00702 
00703                 <span class="keywordflow">if</span> ( !(wch == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'l'</span> || wch == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'c'</span> || wch == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'p'</span> || wch == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'a'</span>
00704                        || wch == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'n'</span>)
00705                      ) {
00706                     <span class="keywordflow">return</span> 0;
00707                     }
00708                 ReturnOffset = (ULONG)((PSZ)p - (PSZ)UnicodeString.Buffer);
00709                 <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;UnicodeString,p);
00710                 NumberOfCharacters = UnicodeString.Length &gt;&gt; 1;
00711                 NumberOfCharacters -= ColonBias;
00712                 ReturnLength = NumberOfCharacters &lt;&lt; 1;
00713                 UnicodeString.Length -= ColonBias*<span class="keyword">sizeof</span>(WCHAR);
00714                 <span class="keywordflow">break</span>;
00715                 }
00716             p--;
00717             }
00718 
00719         wch = UnicodeString.Buffer[0] | 0x20;
00720 
00721         <span class="comment">//</span>
00722         <span class="comment">// check to see if we possibly have a hit on</span>
00723         <span class="comment">// lpt, prn, con, com, aux, or nul</span>
00724         <span class="comment">//</span>
00725 
00726         <span class="keywordflow">if</span> ( !( wch == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'l'</span> || wch == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'c'</span> || wch == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'p'</span> || wch == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'a'</span>
00727                 || wch == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'n'</span> ) ) {
00728             <span class="keywordflow">return</span> 0;
00729             }
00730         }
00731 
00732     <span class="comment">//</span>
00733     <span class="comment">//  Now we need to see if we are dealing with a device name that has</span>
00734     <span class="comment">//  an extension or a stream name. If so, we need to limit the search to the</span>
00735     <span class="comment">//  file portion only</span>
00736     <span class="comment">//</span>
00737 
00738     p = UnicodeString.Buffer;
00739     <span class="keywordflow">while</span> (p &lt; UnicodeString.Buffer + NumberOfCharacters &amp;&amp; *p != <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'.'</span> &amp;&amp; *p != <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">':'</span>) {
00740         p++;
00741     }
00742 
00743     <span class="comment">//</span>
00744     <span class="comment">//  p either points past end of string or to a dot or :.  We back up over</span>
00745     <span class="comment">//  trailing spaces</span>
00746     <span class="comment">//</span>
00747 
00748     <span class="keywordflow">while</span> (p &gt; UnicodeString.Buffer &amp;&amp; p[-1] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">' '</span>) {
00749         p--;
00750     }
00751 
00752     <span class="comment">//</span>
00753     <span class="comment">//  p either points to the beginning of the string or p[-1] is</span>
00754     <span class="comment">//  the first non-space char found above.</span>
00755     <span class="comment">//</span>
00756 
00757     NumberOfCharacters = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(p - UnicodeString.Buffer);
00758     UnicodeString.Length = NumberOfCharacters * <span class="keyword">sizeof</span>( WCHAR );
00759 
00760     <span class="keywordflow">if</span> ( NumberOfCharacters == 4 &amp;&amp; iswdigit(UnicodeString.Buffer[3] ) ) {
00761         <span class="keywordflow">if</span> ( (WCHAR)UnicodeString.Buffer[3] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'0'</span>) {
00762             <span class="keywordflow">return</span> 0;
00763         } <span class="keywordflow">else</span> {
00764             UnicodeString.Length -= <span class="keyword">sizeof</span>(WCHAR);
00765             <span class="keywordflow">if</span> ( <a class="code" href="../../d6/d6/nls_8c.html#a42">RtlEqualUnicodeString</a>(&amp;UnicodeString,&amp;<a class="code" href="../../d5/d1/curdir_8c.html#a5">RtlpDosLPTDevice</a>,<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) ||
00766                  <a class="code" href="../../d6/d6/nls_8c.html#a42">RtlEqualUnicodeString</a>(&amp;UnicodeString,&amp;<a class="code" href="../../d5/d1/curdir_8c.html#a6">RtlpDosCOMDevice</a>,<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) ) {
00767                 ReturnLength = NumberOfCharacters &lt;&lt; 1;
00768             } <span class="keywordflow">else</span> {
00769                 <span class="keywordflow">return</span> 0;
00770             }
00771         }
00772     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( NumberOfCharacters != 3 ) {
00773         <span class="keywordflow">return</span> 0;
00774     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( <a class="code" href="../../d6/d6/nls_8c.html#a42">RtlEqualUnicodeString</a>(&amp;UnicodeString,&amp;<a class="code" href="../../d5/d1/curdir_8c.html#a7">RtlpDosPRNDevice</a>,<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) ) {
00775             ReturnLength = NumberOfCharacters &lt;&lt; 1;
00776     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( <a class="code" href="../../d6/d6/nls_8c.html#a42">RtlEqualUnicodeString</a>(&amp;UnicodeString,&amp;<a class="code" href="../../d5/d1/curdir_8c.html#a8">RtlpDosAUXDevice</a>,<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) ) {
00777         ReturnLength = NumberOfCharacters &lt;&lt; 1;
00778     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( <a class="code" href="../../d6/d6/nls_8c.html#a42">RtlEqualUnicodeString</a>(&amp;UnicodeString,&amp;<a class="code" href="../../d5/d1/curdir_8c.html#a9">RtlpDosNULDevice</a>,<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) ) {
00779         ReturnLength = NumberOfCharacters &lt;&lt; 1;
00780     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( <a class="code" href="../../d6/d6/nls_8c.html#a42">RtlEqualUnicodeString</a>(&amp;UnicodeString,&amp;<a class="code" href="../../d5/d1/curdir_8c.html#a10">RtlpDosCONDevice</a>,<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) ) {
00781         ReturnLength = NumberOfCharacters &lt;&lt; 1;
00782     } <span class="keywordflow">else</span> {
00783         <span class="keywordflow">return</span> 0;
00784     }
00785 
00786     <span class="keywordflow">return</span> ReturnLength | (ReturnOffset &lt;&lt; 16);
00787 }
00788 
00789 ULONG
<a name="l00790"></a><a class="code" href="../../d5/d1/curdir_8c.html#a24">00790</a> <a class="code" href="../../d5/d1/curdir_8c.html#a24">RtlIsDosDeviceName_U</a>(
00791     IN PWSTR DosFileName
00792     )
00793 {
00794     UNICODE_STRING UnicodeString;
00795 
00796     <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;UnicodeString,DosFileName);
00797 
00798     <span class="keywordflow">return</span> <a class="code" href="../../d5/d1/curdir_8c.html#a16">RtlIsDosDeviceName_Ustr</a>(&amp;UnicodeString);
00799 }
00800 
00801 BOOLEAN
<a name="l00802"></a><a class="code" href="../../d5/d1/curdir_8c.html#a25">00802</a> <a class="code" href="../../d5/d1/curdir_8c.html#a25">RtlpCheckDeviceName</a>(
00803     PUNICODE_STRING DevName,
00804     ULONG DeviceNameOffset
00805     )
00806 {
00807 
00808     BOOLEAN NameInvalid;
00809     PWSTR DevPath;
00810 
00811     DevPath = <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a0">RtlAllocateHeap</a>(RtlProcessHeap(), 0,DevName-&gt;Length);
00812     <span class="keywordflow">if</span> (!DevPath) {
00813         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00814         }
00815 
00816     NameInvalid = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00817     <span class="keywordflow">try</span> {
00818 
00819         RtlCopyMemory(DevPath,DevName-&gt;Buffer,DevName-&gt;Length);
00820         DevPath[DeviceNameOffset&gt;&gt;1]=<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'.'</span>;
00821         DevPath[(DeviceNameOffset&gt;&gt;1)+1]=UNICODE_NULL;
00822 
00823         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d1/curdir_8c.html#a31">RtlDoesFileExists_U</a>(DevPath) ) {
00824             NameInvalid = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00825             }
00826         <span class="keywordflow">else</span> {
00827             NameInvalid = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00828             }
00829 
00830         }
00831     finally {
00832         <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>(RtlProcessHeap(), 0, DevPath);
00833         }
00834     <span class="keywordflow">return</span> NameInvalid;
00835 }
00836 
00837 
00838 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00839"></a><a class="code" href="../../d5/d1/curdir_8c.html#a26">00839</a> <a class="code" href="../../d5/d1/curdir_8c.html#a26">RtlpValidateCurrentDirectory</a>(
00840     PCURDIR CurDir
00841     )
00842 
00843 <span class="comment">/*++</span>
00844 <span class="comment"></span>
00845 <span class="comment">Routine Description:</span>
00846 <span class="comment"></span>
00847 <span class="comment">    This function is used to validate the current directory for the process.</span>
00848 <span class="comment">    The current directory can change in several ways, first, by replacing</span>
00849 <span class="comment">    the media with one that has a different directory structure.  Second</span>
00850 <span class="comment">    by performing a force-dismount. </span>
00851 <span class="comment"></span>
00852 <span class="comment">Arguments:</span>
00853 <span class="comment"></span>
00854 <span class="comment">    CurDir - Current directory structure for process</span>
00855 <span class="comment"></span>
00856 <span class="comment">Return Value:</span>
00857 <span class="comment"></span>
00858 <span class="comment">    None.</span>
00859 <span class="comment"></span>
00860 <span class="comment">--*/</span>
00861 
00862 {
00863     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> FsCtlStatus;
00864     IO_STATUS_BLOCK IoStatusBlock;
00865     WCHAR TrimmedPath[4];
00866     UNICODE_STRING str;
00867 
00868     <span class="comment">//</span>
00869     <span class="comment">// Call Nt to see if the volume that</span>
00870     <span class="comment">// contains the directory is still mounted.</span>
00871     <span class="comment">// If it is, then continue. Otherwise, trim</span>
00872     <span class="comment">// current directory to the root.</span>
00873     <span class="comment">//</span>
00874 
00875     FsCtlStatus = <a class="code" href="../../d8/d7/io_2fsctrl_8c.html#a0">NtFsControlFile</a>(
00876                                  CurDir-&gt;Handle,
00877                                  <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00878                                  <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00879                                  <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00880                                  &amp;IoStatusBlock,
00881                                  FSCTL_IS_VOLUME_MOUNTED,
00882                                  <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00883                                  0,
00884                                  <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00885                                  0
00886                                  );
00887 
00888     <span class="keywordflow">if</span> ( FsCtlStatus == STATUS_WRONG_VOLUME || FsCtlStatus == STATUS_VOLUME_DISMOUNTED) {
00889 
00890         <span class="comment">//</span>
00891         <span class="comment">// Try to get back to where we were, failing that reset current directory</span>
00892         <span class="comment">// to the root of the current drive</span>
00893         <span class="comment">//</span>
00894 
00895         <a class="code" href="../../d5/d0/obclose_8c.html#a1">NtClose</a>( CurDir-&gt;Handle );
00896         CurDir-&gt;Handle = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00897 
00898         FsCtlStatus = <a class="code" href="../../d5/d1/curdir_8c.html#a22">RtlSetCurrentDirectory_U</a>(&amp;CurDir-&gt;DosPath);
00899         <span class="keywordflow">if</span> ( !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(FsCtlStatus) ) {
00900 
00901             TrimmedPath[0] = CurDir-&gt;DosPath.Buffer[0];
00902             TrimmedPath[1] = CurDir-&gt;DosPath.Buffer[1];
00903             TrimmedPath[2] = CurDir-&gt;DosPath.Buffer[2];
00904             TrimmedPath[3] = UNICODE_NULL;
00905             <a class="code" href="../../d5/d1/curdir_8c.html#a20">RtlpResetDriveEnvironment</a>( TrimmedPath[0] );
00906             <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>( &amp;str, TrimmedPath );
00907 
00908             <span class="comment">//</span>
00909             <span class="comment">//  This can still fail if the volume was hard dismounted. We tried.</span>
00910             <span class="comment">//  Ah well.</span>
00911             <span class="comment">//</span>
00912 
00913             (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d5/d1/curdir_8c.html#a22">RtlSetCurrentDirectory_U</a>( &amp;str );
00914         }
00915     }
00916 }
00917 
00918 
00919 ULONG
<a name="l00920"></a><a class="code" href="../../d5/d1/curdir_8c.html#a17">00920</a> <a class="code" href="../../d5/d1/curdir_8c.html#a17">RtlGetFullPathName_Ustr</a>(
00921     PUNICODE_STRING  FileName,
00922     ULONG nBufferLength,
00923     PWSTR lpBuffer,
00924     PWSTR *lpFilePart OPTIONAL,
00925     PBOOLEAN NameInvalid,
00926     RTL_PATH_TYPE *InputPathType
00927     )
00928 
00929 <span class="comment">/*++</span>
00930 <span class="comment"></span>
00931 <span class="comment">Routine Description:</span>
00932 <span class="comment"></span>
00933 <span class="comment">    This function is used to return a fully qualified pathname</span>
00934 <span class="comment">    corresponding to the specified unicode filename.  It does this by</span>
00935 <span class="comment">    merging the current drive and directory together with the specified</span>
00936 <span class="comment">    file name.  In addition to this, it calculates the address of the</span>
00937 <span class="comment">    file name portion of the fully qualified pathname.</span>
00938 <span class="comment"></span>
00939 <span class="comment">Arguments:</span>
00940 <span class="comment"></span>
00941 <span class="comment">    lpFileName - Supplies the unicode file name of the file whose fully</span>
00942 <span class="comment">        qualified pathname is to be returned.</span>
00943 <span class="comment"></span>
00944 <span class="comment">    nBufferLength - Supplies the length in bytes of the buffer that is</span>
00945 <span class="comment">        to receive the fully qualified path.</span>
00946 <span class="comment"></span>
00947 <span class="comment">    lpBuffer - Returns the fully qualified pathname corresponding to the</span>
00948 <span class="comment">        specified file.</span>
00949 <span class="comment"></span>
00950 <span class="comment">    lpFilePart - Optional parameter that if specified, returns the</span>
00951 <span class="comment">        address of the last component of the fully qualified pathname.</span>
00952 <span class="comment"></span>
00953 <span class="comment">Return Value:</span>
00954 <span class="comment"></span>
00955 <span class="comment">    The return value is the length of the string copied to lpBuffer, not</span>
00956 <span class="comment">    including the terminating unicode null character.  If the return</span>
00957 <span class="comment">    value is greater than nBufferLength, the return value is the size of</span>
00958 <span class="comment">    the buffer required to hold the pathname.  The return value is zero</span>
00959 <span class="comment">    if the function failed.</span>
00960 <span class="comment"></span>
00961 <span class="comment">--*/</span>
00962 
00963 {
00964     ULONG DeviceNameLength;
00965     ULONG DeviceNameOffset;
00966     ULONG PrefixSourceLength;
00967     LONG PathNameLength;
00968     UCHAR CurDrive, NewDrive;
00969     WCHAR EnvVarNameBuffer[4];
00970     UNICODE_STRING EnvVarName;
00971     PWSTR Source,Dest;
00972     UNICODE_STRING Prefix;
00973     PCURDIR CurDir;
00974     ULONG MaximumLength;
00975     UNICODE_STRING FullPath;
00976     ULONG BackupIndex;
00977     RTL_PATH_TYPE PathType;
00978     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00979     BOOLEAN StripTrailingSlash;
00980     UNICODE_STRING UnicodeString;
00981     ULONG NumberOfCharacters;
00982     PWSTR lpFileName;
00983     WCHAR wch;
00984     ULONG i,j;
00985 
00986     <span class="keywordflow">if</span> ( ARGUMENT_PRESENT(NameInvalid) ) {
00987         *NameInvalid = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00988         }
00989 
00990     <span class="keywordflow">if</span> ( nBufferLength &gt; MAXUSHORT ) {
00991         nBufferLength = MAXUSHORT-2;
00992         }
00993 
00994     *InputPathType = RtlPathTypeUnknown;
00995 
00996     UnicodeString = *<a class="code" href="../../d2/d2/rtload_8c.html#a3">FileName</a>;
00997     lpFileName = UnicodeString.Buffer;
00998 
00999     NumberOfCharacters = UnicodeString.Length &gt;&gt; 1;
01000     PathNameLength = UnicodeString.Length;
01001 
01002     <span class="keywordflow">if</span> ( PathNameLength == 0 || UnicodeString.Buffer[0] == UNICODE_NULL ) {
01003         <span class="keywordflow">return</span> 0;
01004         }
01005     <span class="keywordflow">else</span> {
01006 
01007         <span class="comment">//</span>
01008         <span class="comment">// trim trailing spaces to check for a null name</span>
01009         <span class="comment">//</span>
01010         DeviceNameLength = PathNameLength;
01011         wch = UnicodeString.Buffer[(DeviceNameLength&gt;&gt;1) - 1];
01012         <span class="keywordflow">while</span> ( DeviceNameLength &amp;&amp; wch == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">' '</span> ) {
01013             DeviceNameLength -= <span class="keyword">sizeof</span>(WCHAR);
01014             <span class="keywordflow">if</span> ( DeviceNameLength ) {
01015                 wch = UnicodeString.Buffer[(DeviceNameLength&gt;&gt;1) - 1];
01016                 }
01017             }
01018         <span class="keywordflow">if</span> ( !DeviceNameLength ) {
01019             <span class="keywordflow">return</span> 0;
01020             }
01021         }
01022 
01023     <span class="keywordflow">if</span> ( lpFileName[NumberOfCharacters-1] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span> || lpFileName[NumberOfCharacters-1] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'/'</span> ) {
01024         StripTrailingSlash = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01025         }
01026     <span class="keywordflow">else</span> {
01027         StripTrailingSlash = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01028         }
01029 
01030     <span class="comment">//</span>
01031     <span class="comment">// If pass Dos file name is a Dos device name, then turn it into</span>
01032     <span class="comment">// \\.\devicename and return its length.</span>
01033     <span class="comment">//</span>
01034 
01035     DeviceNameLength = <a class="code" href="../../d5/d1/curdir_8c.html#a16">RtlIsDosDeviceName_Ustr</a>(&amp;UnicodeString);
01036     <span class="keywordflow">if</span> ( DeviceNameLength ) {
01037 
01038         <span class="keywordflow">if</span> ( ARGUMENT_PRESENT( lpFilePart ) ) {
01039             *lpFilePart = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01040             }
01041 
01042         DeviceNameOffset = DeviceNameLength &gt;&gt; 16;
01043         DeviceNameLength &amp;= 0x0000ffff;
01044 
01045         <span class="keywordflow">if</span> ( ARGUMENT_PRESENT(NameInvalid) &amp;&amp; DeviceNameOffset ) {
01046             <span class="keywordflow">if</span> ( <a class="code" href="../../d5/d1/curdir_8c.html#a25">RtlpCheckDeviceName</a>(&amp;UnicodeString,DeviceNameOffset) ) {
01047                 *NameInvalid = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01048                 <span class="keywordflow">return</span> 0;
01049                 }
01050             }
01051 
01052         PathNameLength = DeviceNameLength + <a class="code" href="../../d5/d1/curdir_8c.html#a12">RtlpSlashSlashDot</a>.Length;
01053         <span class="keywordflow">if</span> ( PathNameLength &lt; (LONG)nBufferLength ) {
01054             RtlMoveMemory(
01055                 lpBuffer,
01056                 <a class="code" href="../../d5/d1/curdir_8c.html#a12">RtlpSlashSlashDot</a>.Buffer,
01057                 <a class="code" href="../../d5/d1/curdir_8c.html#a12">RtlpSlashSlashDot</a>.Length
01058                 );
01059             RtlMoveMemory(
01060                 (PVOID)((PUCHAR)lpBuffer+<a class="code" href="../../d5/d1/curdir_8c.html#a12">RtlpSlashSlashDot</a>.Length),
01061                 (PSZ)lpFileName+DeviceNameOffset,
01062                 DeviceNameLength
01063                 );
01064 
01065             RtlZeroMemory(
01066                 (PVOID)((PUCHAR)lpBuffer+<a class="code" href="../../d5/d1/curdir_8c.html#a12">RtlpSlashSlashDot</a>.Length+DeviceNameLength),
01067                 <span class="keyword">sizeof</span>(UNICODE_NULL)
01068                 );
01069 
01070             <span class="keywordflow">return</span> PathNameLength;
01071             }
01072         <span class="keywordflow">else</span> {
01073             <span class="keywordflow">return</span> PathNameLength+<span class="keyword">sizeof</span>(UNICODE_NULL);
01074             }
01075         }
01076 
01077     <span class="comment">//</span>
01078     <span class="comment">// Setup output string that points to callers buffer.</span>
01079     <span class="comment">//</span>
01080 
01081     FullPath.MaximumLength = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)nBufferLength;
01082     FullPath.Length = 0;
01083     FullPath.Buffer = lpBuffer;
01084     RtlZeroMemory(lpBuffer,nBufferLength);
01085     <span class="comment">//</span>
01086     <span class="comment">// Get a pointer to the current directory structure.</span>
01087     <span class="comment">//</span>
01088 
01089     CurDir = &amp;(NtCurrentPeb()-&gt;ProcessParameters-&gt;CurrentDirectory);
01090 
01091 
01092     <span class="comment">//</span>
01093     <span class="comment">// Determine the type of Dos Path Name specified.</span>
01094     <span class="comment">//</span>
01095 
01096     *InputPathType = PathType = <a class="code" href="../../d5/d1/curdir_8c.html#a23">RtlDetermineDosPathNameType_U</a>(lpFileName);
01097 
01098     <span class="comment">//</span>
01099     <span class="comment">// Determine the prefix and backup index.</span>
01100     <span class="comment">//</span>
01101     <span class="comment">//  Input        Prefix                     Backup Index</span>
01102     <span class="comment">//</span>
01103     <span class="comment">//  \\        -&gt; \\,                            end of \\server\share</span>
01104     <span class="comment">//  \\.\      -&gt; \\.\,                          4</span>
01105     <span class="comment">//  \\.       -&gt; \\.                            3 (\\.)</span>
01106     <span class="comment">//  \         -&gt; Drive: from CurDir.DosPath     3 (Drive:\)</span>
01107     <span class="comment">//  d:        -&gt; Drive:\curdir from environment 3 (Drive:\)</span>
01108     <span class="comment">//  d:\       -&gt; no prefix                      3 (Drive:\)</span>
01109     <span class="comment">//  any       -&gt; CurDir.DosPath                 3 (Drive:\)</span>
01110     <span class="comment">//</span>
01111 
01112     <a class="code" href="../../d2/d4/eballoc_8c.html#a1">RtlAcquirePebLock</a>();
01113     <span class="keywordflow">try</span> {
01114 
01115         <span class="comment">//</span>
01116         <span class="comment">// No prefixes yet.</span>
01117         <span class="comment">//</span>
01118 
01119         Source = lpFileName;
01120         PrefixSourceLength = 0;
01121         Prefix.Length = 0;
01122         Prefix.MaximumLength = 0;
01123         Prefix.Buffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01124 
01125         <span class="keywordflow">switch</span> (PathType) {
01126             <span class="keywordflow">case</span> RtlPathTypeUncAbsolute :
01127                 {
01128                     PWSTR UncPathPointer;
01129                     ULONG NumberOfPathSeparators;
01130 
01131                     <span class="comment">//</span>
01132                     <span class="comment">// We want to scan the supplied path to determine where</span>
01133                     <span class="comment">// the "share" ends, and set BackupIndex to that point.</span>
01134                     <span class="comment">//</span>
01135 
01136                     UncPathPointer = lpFileName + 2;
01137                     NumberOfPathSeparators = 0;
01138                     <span class="keywordflow">while</span> (*UncPathPointer) {
01139                         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d1/curdir_8c.html#a0">IS_PATH_SEPARATOR_U</a>(*UncPathPointer)) {
01140 
01141                             NumberOfPathSeparators++;
01142 
01143                             <span class="keywordflow">if</span> (NumberOfPathSeparators == 2) {
01144                                 <span class="keywordflow">break</span>;
01145                                 }
01146                             }
01147 
01148                         UncPathPointer++;
01149 
01150                         }
01151 
01152                     BackupIndex = (ULONG)(UncPathPointer - lpFileName);
01153 
01154                     <span class="comment">//</span>
01155                     <span class="comment">// Unc name. prefix = \\server\share</span>
01156                     <span class="comment">//</span>
01157 
01158                     PrefixSourceLength = BackupIndex &lt;&lt; 1;
01159 
01160                     Source += BackupIndex;
01161 
01162                     <span class="comment">//</span>
01163                     <span class="comment">//  There is no prefix to place into the buffer.</span>
01164                     <span class="comment">//  The entire path is in Source</span>
01165                     <span class="comment">//</span>
01166 
01167                     }
01168                 <span class="keywordflow">break</span>;
01169 
01170             <span class="keywordflow">case</span> RtlPathTypeLocalDevice :
01171 
01172                 <span class="comment">//</span>
01173                 <span class="comment">// Local device name. prefix = "\\.\"</span>
01174                 <span class="comment">//</span>
01175 
01176                 PrefixSourceLength = <a class="code" href="../../d5/d1/curdir_8c.html#a12">RtlpSlashSlashDot</a>.Length;
01177                 BackupIndex = 4;
01178                 Source += BackupIndex;
01179                 PathNameLength -= BackupIndex * <span class="keyword">sizeof</span>( WCHAR );
01180 
01181                 <span class="comment">//</span>
01182                 <span class="comment">//  There is no prefix to place into the buffer.</span>
01183                 <span class="comment">//  The entire path is in Source</span>
01184                 <span class="comment">//</span>
01185 
01186                 <span class="keywordflow">break</span>;
01187 
01188             <span class="keywordflow">case</span> RtlPathTypeRootLocalDevice :
01189 
01190                 <span class="comment">//</span>
01191                 <span class="comment">// Local Device root. prefix = "\\.\"</span>
01192                 <span class="comment">//</span>
01193 
01194                 Prefix = <a class="code" href="../../d5/d1/curdir_8c.html#a12">RtlpSlashSlashDot</a>;
01195                 Prefix.Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(Prefix.Length - (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(2*<span class="keyword">sizeof</span>(UNICODE_NULL)));
01196                 PrefixSourceLength = Prefix.Length + <span class="keyword">sizeof</span>(UNICODE_NULL);
01197                 BackupIndex = 3;
01198                 Source += BackupIndex;
01199                 PathNameLength -= BackupIndex * <span class="keyword">sizeof</span>( WCHAR );
01200                 <span class="keywordflow">break</span>;
01201 
01202             <span class="keywordflow">case</span> RtlPathTypeDriveAbsolute :
01203 
01204                 CurDrive = (UCHAR)<a class="code" href="../../d6/d6/nls_8c.html#a33">RtlUpcaseUnicodeChar</a>( CurDir-&gt;DosPath.Buffer[0] );
01205                 NewDrive = (UCHAR)<a class="code" href="../../d6/d6/nls_8c.html#a33">RtlUpcaseUnicodeChar</a>( lpFileName[0] );
01206                 <span class="keywordflow">if</span> ( CurDrive == NewDrive ) {
01207 
01208                     <a class="code" href="../../d5/d1/curdir_8c.html#a26">RtlpValidateCurrentDirectory</a>( CurDir );
01209                     
01210                 }
01211 
01212                 <span class="comment">//</span>
01213                 <span class="comment">// Dos drive absolute name</span>
01214                 <span class="comment">//</span>
01215 
01216                 BackupIndex = 3;
01217                 <span class="keywordflow">break</span>;
01218 
01219             <span class="keywordflow">case</span> RtlPathTypeDriveRelative :
01220 
01221                 <span class="comment">//</span>
01222                 <span class="comment">// Dos drive relative name</span>
01223                 <span class="comment">//</span>
01224 
01225                 CurDrive = (UCHAR)<a class="code" href="../../d6/d6/nls_8c.html#a33">RtlUpcaseUnicodeChar</a>( CurDir-&gt;DosPath.Buffer[0] );
01226                 NewDrive = (UCHAR)<a class="code" href="../../d6/d6/nls_8c.html#a33">RtlUpcaseUnicodeChar</a>( lpFileName[0] );
01227                 <span class="keywordflow">if</span> ( CurDrive == NewDrive ) {
01228 
01229                     <a class="code" href="../../d5/d1/curdir_8c.html#a26">RtlpValidateCurrentDirectory</a>( CurDir );
01230 
01231                     Prefix = *(PUNICODE_STRING)&amp;CurDir-&gt;DosPath;
01232                     
01233                 }
01234 
01235                 <span class="keywordflow">else</span> {
01236                     <a class="code" href="../../d5/d1/curdir_8c.html#a15">RtlpCheckRelativeDrive</a>((WCHAR)NewDrive);
01237 
01238                     EnvVarNameBuffer[0] = <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'='</span>;
01239                     EnvVarNameBuffer[1] = (WCHAR)NewDrive;
01240                     EnvVarNameBuffer[2] = <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">':'</span>;
01241                     EnvVarNameBuffer[3] = UNICODE_NULL;
01242                     <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;EnvVarName,EnvVarNameBuffer);
01243 
01244                     Prefix = FullPath;
01245                     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d5/d7/environ_8c.html#a6">RtlQueryEnvironmentVariable_U</a>( <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
01246                                                             &amp;EnvVarName,
01247                                                             &amp;Prefix
01248                                                           );
01249                     <span class="keywordflow">if</span> ( !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> ) ) {
01250                         <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_BUFFER_TOO_SMALL) {
01251                             <span class="keywordflow">return</span> (ULONG)(Prefix.Length) + PathNameLength + 2;
01252                             }
01253                         <span class="keywordflow">else</span> {
01254                             <span class="comment">//</span>
01255                             <span class="comment">// Otherwise default to root directory of drive</span>
01256                             <span class="comment">//</span>
01257 
01258                             EnvVarNameBuffer[0] = (WCHAR)NewDrive;
01259                             EnvVarNameBuffer[1] = <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">':'</span>;
01260                             EnvVarNameBuffer[2] = <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span>;
01261                             EnvVarNameBuffer[3] = UNICODE_NULL;
01262                             <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;Prefix,EnvVarNameBuffer);
01263                             }
01264                         }
01265                     <span class="keywordflow">else</span> {
01266 
01267                             {
01268                             ULONG LastChar;
01269 
01270                             <span class="comment">//</span>
01271                             <span class="comment">// Determine</span>
01272                             <span class="comment">// if a backslash needs to be added</span>
01273                             <span class="comment">//</span>
01274 
01275                             LastChar = Prefix.Length &gt;&gt; 1;
01276 
01277                             <span class="keywordflow">if</span> (LastChar &gt; 3) {
01278                                 Prefix.Buffer[ LastChar ] = <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span>;
01279                                 Prefix.Length += <span class="keyword">sizeof</span>(UNICODE_NULL);
01280                                 }
01281                             }
01282 
01283                         }
01284                     }
01285 
01286                 BackupIndex = 3;
01287                 Source += 2;
01288                 PathNameLength -= 2 * <span class="keyword">sizeof</span>( WCHAR );
01289                 <span class="keywordflow">break</span>;
01290 
01291             <span class="keywordflow">case</span> RtlPathTypeRooted :
01292                 BackupIndex = <a class="code" href="../../d5/d1/curdir_8c.html#a18">RtlpComputeBackupIndex</a>(CurDir);
01293                 <span class="keywordflow">if</span> ( BackupIndex != 3 ) {
01294                     Prefix = CurDir-&gt;DosPath;
01295                     Prefix.Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(BackupIndex &lt;&lt; 1);
01296                     }
01297                 <span class="keywordflow">else</span> {
01298 
01299                     <span class="comment">//</span>
01300                     <span class="comment">// Rooted name. Prefix is drive portion of current directory</span>
01301                     <span class="comment">//</span>
01302 
01303                     Prefix = CurDir-&gt;DosPath;
01304                     Prefix.Length = 2*<span class="keyword">sizeof</span>(UNICODE_NULL);
01305                     }
01306                 <span class="keywordflow">break</span>;
01307 
01308             <span class="keywordflow">case</span> RtlPathTypeRelative :
01309 
01310                 <a class="code" href="../../d5/d1/curdir_8c.html#a26">RtlpValidateCurrentDirectory</a>( CurDir );
01311                 
01312                 <span class="comment">//</span>
01313                 <span class="comment">// Current drive:directory relative name</span>
01314                 <span class="comment">//</span>
01315 
01316                 Prefix = CurDir-&gt;DosPath;
01317                 BackupIndex = <a class="code" href="../../d5/d1/curdir_8c.html#a18">RtlpComputeBackupIndex</a>(CurDir);
01318                 <span class="keywordflow">break</span>;
01319 
01320             <span class="keywordflow">default</span>:
01321                 <span class="keywordflow">return</span> 0;
01322             }
01323 
01324         <span class="comment">//</span>
01325         <span class="comment">// Maximum length required is the length of the prefix plus</span>
01326         <span class="comment">// the length of the specified pathname. If the callers buffer</span>
01327         <span class="comment">// is not at least this large, then return an error.</span>
01328         <span class="comment">//</span>
01329 
01330         MaximumLength = PathNameLength + Prefix.Length;
01331 
01332         <span class="keywordflow">if</span> ( MaximumLength &gt;= nBufferLength ) {
01333             <span class="keywordflow">if</span> ( (NumberOfCharacters &gt; 1) ||
01334                  (*lpFileName != <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'.'</span>) ) {
01335                 <span class="keywordflow">if</span> ( PathType == RtlPathTypeRelative &amp;&amp; NumberOfCharacters == 1 ) {
01336                     <span class="keywordflow">return</span> (ULONG)Prefix.Length - <span class="keyword">sizeof</span>(UNICODE_NULL);
01337                     }
01338                 <span class="keywordflow">return</span> MaximumLength+<span class="keyword">sizeof</span>(UNICODE_NULL);
01339                 }
01340             <span class="keywordflow">else</span> {
01341 
01342                 <span class="comment">//</span>
01343                 <span class="comment">// If we are expanding curdir, then remember the trailing '\'</span>
01344                 <span class="comment">//</span>
01345 
01346                 <span class="keywordflow">if</span> ( NumberOfCharacters == 1 &amp;&amp; *lpFileName == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'.'</span> ) {
01347 
01348                     <span class="comment">//</span>
01349                     <span class="comment">// We are expanding .</span>
01350                     <span class="comment">//</span>
01351 
01352                     <span class="keywordflow">if</span> ( Prefix.Length == 6 ) {
01353                         <span class="keywordflow">if</span> ( nBufferLength &lt;= Prefix.Length ) {
01354                             <span class="keywordflow">return</span> (ULONG)(Prefix.Length+(<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)<span class="keyword">sizeof</span>(UNICODE_NULL));
01355                             }
01356                         }
01357                     <span class="keywordflow">else</span> {
01358                         <span class="keywordflow">if</span> ( nBufferLength &lt; Prefix.Length ) {
01359                             <span class="keywordflow">return</span> (ULONG)Prefix.Length;
01360                             }
01361                         <span class="keywordflow">else</span> {
01362                             <span class="keywordflow">for</span>(i=0,j=0;i&lt;Prefix.Length;i+=<span class="keyword">sizeof</span>(WCHAR),j++){
01363                                 <span class="keywordflow">if</span> ( Prefix.Buffer[j] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span> ||
01364                                      Prefix.Buffer[j] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'/'</span> ) {
01365 
01366                                     FullPath.Buffer[j] = <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span>;
01367                                     }
01368                                 <span class="keywordflow">else</span> {
01369                                     FullPath.Buffer[j] = Prefix.Buffer[j];
01370                                     }
01371                                 }
01372                                 FullPath.Length = Prefix.Length-(<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)<span class="keyword">sizeof</span>(<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span>);
01373                             <span class="keywordflow">goto</span> skipit;
01374                             }
01375                         }
01376                     }
01377                 <span class="keywordflow">else</span> {
01378                     <span class="keywordflow">return</span> MaximumLength;
01379                     }
01380                 }
01381             }
01382 
01383         <span class="keywordflow">if</span> (PrefixSourceLength || Prefix.Buffer != FullPath.Buffer) {
01384             <span class="comment">//</span>
01385             <span class="comment">// Copy the prefix from the source string.</span>
01386             <span class="comment">//</span>
01387 
01388             <span class="comment">//RtlMoveMemory(FullPath.Buffer,lpFileName,PrefixSourceLength);</span>
01389 
01390             <span class="keywordflow">for</span>(i=0,j=0;i&lt;PrefixSourceLength;i+=<span class="keyword">sizeof</span>(WCHAR),j++){
01391                 <span class="keywordflow">if</span> ( lpFileName[j] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span> ||
01392                      lpFileName[j] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'/'</span> ) {
01393 
01394                     FullPath.Buffer[j] = <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span>;
01395                     }
01396                 <span class="keywordflow">else</span> {
01397                     FullPath.Buffer[j] = lpFileName[j];
01398                     }
01399                 }
01400 
01401             FullPath.Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)PrefixSourceLength;
01402 
01403             <span class="comment">//</span>
01404             <span class="comment">// Append any additional prefix</span>
01405             <span class="comment">//</span>
01406 
01407             <span class="keywordflow">for</span>(i=0,j=0;i&lt;Prefix.Length;i+=<span class="keyword">sizeof</span>(WCHAR),j++){
01408                 <span class="keywordflow">if</span> ( Prefix.Buffer[j] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span> ||
01409                      Prefix.Buffer[j] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'/'</span> ) {
01410 
01411                     FullPath.Buffer[j+(FullPath.Length&gt;&gt;1)] = <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span>;
01412                     }
01413                 <span class="keywordflow">else</span> {
01414                     FullPath.Buffer[j+(FullPath.Length&gt;&gt;1)] = Prefix.Buffer[j];
01415                     }
01416                 }
01417             FullPath.Length += Prefix.Length;
01418 
01419             }
01420         <span class="keywordflow">else</span> {
01421             FullPath.Length = Prefix.Length;
01422             }
01423 skipit:
01424         Dest =  (PWSTR)((PUCHAR)FullPath.Buffer + FullPath.Length);
01425         *Dest = UNICODE_NULL;
01426 
01427         <span class="keywordflow">while</span> ( *Source ) {
01428             <span class="keywordflow">switch</span> ( *Source ) {
01429 
01430             <span class="keywordflow">case</span> <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span> :
01431             <span class="keywordflow">case</span> <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'/'</span> :
01432 
01433                 <span class="comment">//</span>
01434                 <span class="comment">// collapse multiple "\" characters.</span>
01435                 <span class="comment">//</span>
01436 
01437                 <span class="keywordflow">if</span>  ( *(Dest-1) != <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span> ) {
01438                     *Dest++ = <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span>;
01439                     }
01440 
01441                 Source++;
01442                 <span class="keywordflow">break</span>;
01443 
01444             <span class="keywordflow">case</span> <span class="charliteral">'.'</span> :
01445 
01446                 <span class="comment">//</span>
01447                 <span class="comment">// Ignore dot in a leading //./</span>
01448                 <span class="comment">// Eat single dots as in /./</span>
01449                 <span class="comment">// Double dots back up one level as in /../</span>
01450                 <span class="comment">// Any other . is just a filename character</span>
01451                 <span class="comment">//</span>
01452                 <span class="keywordflow">if</span> ( <a class="code" href="../../d5/d1/curdir_8c.html#a1">IS_DOT_U</a>(Source) ) {
01453                     Source++;
01454                     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d1/curdir_8c.html#a0">IS_PATH_SEPARATOR_U</a>(*Source)) {
01455                         Source++;
01456                         }
01457                     <span class="keywordflow">break</span>;
01458                     }
01459                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( <a class="code" href="../../d5/d1/curdir_8c.html#a2">IS_DOT_DOT_U</a>(Source) ) {
01460                     <span class="comment">//</span>
01461                     <span class="comment">// backup destination string looking for a '\'</span>
01462                     <span class="comment">//</span>
01463 
01464                     <span class="keywordflow">while</span> (*Dest != <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span>) {
01465                         *Dest = UNICODE_NULL;
01466                         Dest--;
01467                         }
01468 
01469                     <span class="comment">//</span>
01470                     <span class="comment">// backup to previous component..</span>
01471                     <span class="comment">// \a\b\c\.. to \a\b</span>
01472                     <span class="comment">//</span>
01473 
01474                     <span class="keywordflow">do</span> {
01475 
01476                         <span class="comment">//</span>
01477                         <span class="comment">// If we bump into root prefix, then</span>
01478                         <span class="comment">// stay at root</span>
01479                         <span class="comment">//</span>
01480 
01481                         <span class="keywordflow">if</span> ( Dest ==  FullPath.Buffer + (BackupIndex-1) ) {
01482                             <span class="keywordflow">break</span>;
01483                             }
01484 
01485                         *Dest = UNICODE_NULL;
01486                         Dest--;
01487 
01488                         } <span class="keywordflow">while</span> (*Dest != <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span>);
01489                     <span class="keywordflow">if</span> ( Dest ==  FullPath.Buffer + (BackupIndex-1) ) {
01490                         Dest++;
01491                         }
01492 
01493                     <span class="comment">//</span>
01494                     <span class="comment">// Advance source past ..</span>
01495                     <span class="comment">//</span>
01496 
01497                     Source += 2;
01498 
01499                     <span class="keywordflow">break</span>;
01500                     }
01501 
01502                 <span class="comment">//</span>
01503                 <span class="comment">// FALLTHRU</span>
01504                 <span class="comment">//</span>
01505 
01506             <span class="keywordflow">default</span>:
01507 
01508                 <span class="comment">//</span>
01509                 <span class="comment">// Copy the filename. The copy will stop</span>
01510                 <span class="comment">// on "non-portable" characters. Note that</span>
01511                 <span class="comment">// null and /,\ will stop the copy. If any</span>
01512                 <span class="comment">// charcter other than null or /,\ is encountered,</span>
01513                 <span class="comment">// then the pathname is invalid.</span>
01514                 <span class="comment">//</span>
01515 
01516                 <span class="comment">//</span>
01517                 <span class="comment">// strip trailing .'s within a component</span>
01518                 <span class="comment">//</span>
01519 
01520                 <span class="keywordflow">while</span> ( *Source &amp;&amp; !<a class="code" href="../../d5/d1/curdir_8c.html#a0">IS_PATH_SEPARATOR_U</a>(*Source) ) {
01521                     <span class="keywordflow">if</span> ( *Source == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'.'</span> ) {
01522 
01523                         <span class="comment">//</span>
01524                         <span class="comment">// nuke .'s that preceed pathname seperators</span>
01525                         <span class="comment">//</span>
01526 
01527                         <span class="keywordflow">if</span> ( <a class="code" href="../../d5/d1/curdir_8c.html#a0">IS_PATH_SEPARATOR_U</a>(*(Source+1)) ) {
01528                             Source++;
01529                             }
01530                         <span class="keywordflow">else</span> {
01531                             *Dest++ = *Source++;
01532                             }
01533                         }
01534                     <span class="keywordflow">else</span> {
01535                         *Dest++ = *Source++;
01536                         }
01537                     }
01538                 }
01539             }
01540 
01541         *Dest = UNICODE_NULL;
01542 
01543         <span class="keywordflow">if</span> ( StripTrailingSlash ) {
01544             <span class="keywordflow">if</span> ( Dest &gt; (FullPath.Buffer + BackupIndex ) &amp;&amp; *(Dest-1) == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span> ) {
01545                 Dest--;
01546                 *Dest = UNICODE_NULL;
01547                 }
01548             }
01549         FullPath.Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(PtrToUlong(Dest) - PtrToUlong(FullPath.Buffer));
01550 
01551         <span class="comment">//</span>
01552         <span class="comment">// strip trailing spaces and dots</span>
01553         <span class="comment">//</span>
01554 
01555         Source = Dest-1;
01556         <span class="keywordflow">while</span>(Source &gt; FullPath.Buffer ) {
01557             <span class="keywordflow">if</span> ( *Source == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">' '</span> || *Source == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'.'</span> ) {
01558                 *Source = UNICODE_NULL;
01559                 Dest--;
01560                 Source--;
01561                 FullPath.Length -= 2;
01562                 }
01563             <span class="keywordflow">else</span> {
01564                 <span class="keywordflow">break</span>;
01565                 }
01566             }
01567 
01568         <span class="keywordflow">if</span> ( ARGUMENT_PRESENT( lpFilePart ) ) {
01569 
01570             <span class="comment">//</span>
01571             <span class="comment">// Locate the file part...</span>
01572             <span class="comment">//</span>
01573 
01574             Source = Dest-1;
01575             Dest = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01576 
01577             <span class="keywordflow">while</span>(Source &gt; FullPath.Buffer ) {
01578                 <span class="keywordflow">if</span> ( *Source == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span> ) {
01579                     Dest = Source + 1;
01580                     <span class="keywordflow">break</span>;
01581                     }
01582                 Source--;
01583                 }
01584 
01585             <span class="keywordflow">if</span> ( Dest &amp;&amp; *Dest ) {
01586 
01587                 <span class="comment">//</span>
01588                 <span class="comment">// If this is a UNC name, make sure filepart is past the backup index</span>
01589                 <span class="comment">//</span>
01590                 <span class="keywordflow">if</span> ( PathType == RtlPathTypeUncAbsolute ) {
01591                     <span class="keywordflow">if</span> ( Dest &lt; (FullPath.Buffer + BackupIndex ) ) {
01592                         *lpFilePart = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01593                         leave;
01594                         }
01595                     }
01596                 *lpFilePart = Dest;
01597                 }
01598             <span class="keywordflow">else</span> {
01599                 *lpFilePart = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01600                 }
01601             }
01602         }
01603     finally {
01604         <a class="code" href="../../d2/d4/eballoc_8c.html#a2">RtlReleasePebLock</a>();
01605         }
01606 
01607     <span class="keywordflow">return</span> (ULONG)FullPath.Length;
01608 }
01609 
01610 ULONG
<a name="l01611"></a><a class="code" href="../../d5/d1/curdir_8c.html#a27">01611</a> <a class="code" href="../../d5/d1/curdir_8c.html#a27">RtlGetFullPathName_U</a>(
01612     PCWSTR lpFileName,
01613     ULONG nBufferLength,
01614     PWSTR lpBuffer,
01615     PWSTR *lpFilePart OPTIONAL
01616     )
01617 
01618 {
01619     UNICODE_STRING UnicodeString;
01620     RTL_PATH_TYPE PathType;
01621 
01622     <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;UnicodeString,lpFileName);
01623 
01624     <span class="keywordflow">return</span> <a class="code" href="../../d5/d1/curdir_8c.html#a17">RtlGetFullPathName_Ustr</a>(&amp;UnicodeString,nBufferLength,lpBuffer,lpFilePart,<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,&amp;PathType);
01625 }
01626 
01627 BOOLEAN
<a name="l01628"></a><a class="code" href="../../d5/d1/curdir_8c.html#a28">01628</a> <a class="code" href="../../d5/d1/curdir_8c.html#a28">RtlpWin32NTNameToNtPathName_U</a>(
01629     IN PUNICODE_STRING DosFileName,
01630     OUT PUNICODE_STRING NtFileName,
01631     OUT PWSTR *FilePart OPTIONAL,
01632     OUT PRTL_RELATIVE_NAME RelativeName OPTIONAL
01633     )
01634 {
01635 
01636     PWSTR FullNtPathName = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01637     PWSTR Source,Dest;
01638 
01639     FullNtPathName = <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a0">RtlAllocateHeap</a>(
01640                         RtlProcessHeap(),
01641                         0,
01642                         DosFileName-&gt;Length-8+<span class="keyword">sizeof</span>(UNICODE_NULL)+<a class="code" href="../../d5/d1/curdir_8c.html#a13">RtlpDosDevicesPrefix</a>.Length
01643                         );
01644     <span class="keywordflow">if</span> ( !FullNtPathName ) {
01645         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01646         }
01647 
01648     <span class="comment">//</span>
01649     <span class="comment">// Copy the full Win32/NT path next to the name prefix, skipping over</span>
01650     <span class="comment">// the \\?\ at the front of the path.</span>
01651     <span class="comment">//</span>
01652 
01653     RtlMoveMemory(FullNtPathName,<a class="code" href="../../d5/d1/curdir_8c.html#a13">RtlpDosDevicesPrefix</a>.Buffer,<a class="code" href="../../d5/d1/curdir_8c.html#a13">RtlpDosDevicesPrefix</a>.Length);
01654     RtlMoveMemory((PUCHAR)FullNtPathName+<a class="code" href="../../d5/d1/curdir_8c.html#a13">RtlpDosDevicesPrefix</a>.Length,
01655                   DosFileName-&gt;Buffer + 4,
01656                   DosFileName-&gt;Length - 8);
01657 
01658     <span class="comment">//</span>
01659     <span class="comment">// Null terminate the path name to make strlen below happy.</span>
01660     <span class="comment">//</span>
01661 
01662 
01663     NtFileName-&gt;Buffer = FullNtPathName;
01664     NtFileName-&gt;Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(DosFileName-&gt;Length-8+<a class="code" href="../../d5/d1/curdir_8c.html#a13">RtlpDosDevicesPrefix</a>.Length);
01665     NtFileName-&gt;MaximumLength = NtFileName-&gt;Length + <span class="keyword">sizeof</span>(UNICODE_NULL);
01666     FullNtPathName[ NtFileName-&gt;Length &gt;&gt; 1 ] = UNICODE_NULL;
01667 
01668     <span class="comment">//</span>
01669     <span class="comment">// Now we have the passed in path with \DosDevices\ prepended. Blow out the</span>
01670     <span class="comment">// relative name structure (if provided), and possibly compute filepart</span>
01671     <span class="comment">//</span>
01672 
01673     <span class="keywordflow">if</span> ( ARGUMENT_PRESENT(<a class="code" href="../../d2/d2/rtload_8c.html#a7">RelativeName</a>) ) {
01674 
01675         <span class="comment">//</span>
01676         <span class="comment">// If the current directory is a sub-string of the</span>
01677         <span class="comment">// Nt file name, and if a handle exists for the current</span>
01678         <span class="comment">// directory, then return the directory handle and name</span>
01679         <span class="comment">// relative to the directory.</span>
01680         <span class="comment">//</span>
01681 
01682         <a class="code" href="../../d2/d2/rtload_8c.html#a7">RelativeName</a>-&gt;RelativeName.Length = 0;
01683         <a class="code" href="../../d2/d2/rtload_8c.html#a7">RelativeName</a>-&gt;RelativeName.MaximumLength = 0;
01684         <a class="code" href="../../d2/d2/rtload_8c.html#a7">RelativeName</a>-&gt;RelativeName.Buffer = 0;
01685         <a class="code" href="../../d2/d2/rtload_8c.html#a7">RelativeName</a>-&gt;ContainingDirectory = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01686         }
01687 
01688     <span class="keywordflow">if</span> ( ARGUMENT_PRESENT( FilePart ) ) {
01689 
01690         <span class="comment">//</span>
01691         <span class="comment">// Locate the file part...</span>
01692         <span class="comment">//</span>
01693 
01694         Source = &amp;FullNtPathName[ (NtFileName-&gt;Length-1) &gt;&gt; 1 ];
01695         Dest = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01696 
01697         <span class="keywordflow">while</span>(Source &gt; FullNtPathName ) {
01698             <span class="keywordflow">if</span> ( *Source == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span> ) {
01699                 Dest = Source + 1;
01700                 <span class="keywordflow">break</span>;
01701                 }
01702             Source--;
01703             }
01704 
01705         <span class="keywordflow">if</span> ( Dest &amp;&amp; *Dest ) {
01706             *FilePart = Dest;
01707             }
01708         <span class="keywordflow">else</span> {
01709             *FilePart = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01710             }
01711         }
01712 
01713     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01714 }
01715 
01716 BOOLEAN
<a name="l01717"></a><a class="code" href="../../d5/d1/curdir_8c.html#a29">01717</a> <a class="code" href="../../d5/d1/curdir_8c.html#a29">RtlDosPathNameToNtPathName_U</a>(
01718     IN PCWSTR DosFileName,
01719     OUT PUNICODE_STRING NtFileName,
01720     OUT PWSTR *FilePart OPTIONAL,
01721     OUT PRTL_RELATIVE_NAME RelativeName OPTIONAL
01722     )
01723 
01724 <span class="comment">/*++</span>
01725 <span class="comment"></span>
01726 <span class="comment">Routine Description:</span>
01727 <span class="comment"></span>
01728 <span class="comment">    A Dos pathname can be translated into an Nt style pathname</span>
01729 <span class="comment">    using this function.</span>
01730 <span class="comment"></span>
01731 <span class="comment">    This function is used only within the Base dll to translate Dos</span>
01732 <span class="comment">    pathnames to Nt pathnames. Upon successful translation, the</span>
01733 <span class="comment">    pointer (NtFileName-&gt;Buffer) points to memory from RtlProcessHeap()</span>
01734 <span class="comment">    that contains the Nt version of the input dos file name.</span>
01735 <span class="comment"></span>
01736 <span class="comment">Arguments:</span>
01737 <span class="comment"></span>
01738 <span class="comment">    DosFileName - Supplies the unicode Dos style file name that is to be</span>
01739 <span class="comment">        translated into an equivalent unicode Nt file name.</span>
01740 <span class="comment"></span>
01741 <span class="comment">    NtFileName - Returns the address of memory in the RtlProcessHeap() that</span>
01742 <span class="comment">        contains an NT filename that refers to the specified Dos file</span>
01743 <span class="comment">        name.</span>
01744 <span class="comment"></span>
01745 <span class="comment">    FilePart - Optional parameter that if specified, returns the</span>
01746 <span class="comment">        trailing file portion of the file name.  A path of \foo\bar\x.x</span>
01747 <span class="comment">        returns the address of x.x as the file part.</span>
01748 <span class="comment"></span>
01749 <span class="comment">    RelativeName - An optional parameter, that if specified, returns</span>
01750 <span class="comment">        a pathname relative to the current directory of the file. The</span>
01751 <span class="comment">        length field of RelativeName-&gt;RelativeName is 0 if the relative</span>
01752 <span class="comment">        name can not be used.</span>
01753 <span class="comment"></span>
01754 <span class="comment">Return Value:</span>
01755 <span class="comment"></span>
01756 <span class="comment">    TRUE - The path name translation was successful.  Once the caller is</span>
01757 <span class="comment">        done with the translated name, the memory pointed to by</span>
01758 <span class="comment">        NtFileName.Buffer should be returned to the RtlProcessHeap().</span>
01759 <span class="comment"></span>
01760 <span class="comment">    FALSE - The operation failed.</span>
01761 <span class="comment"></span>
01762 <span class="comment">Note:</span>
01763 <span class="comment">    The buffers pointed to by RelativeName, FilePart, and NtFileName must ALL</span>
01764 <span class="comment">    point within the same memory address.  If they don't, code that calls</span>
01765 <span class="comment">    this routine will fail.</span>
01766 <span class="comment"></span>
01767 <span class="comment">--*/</span>
01768 
01769 {
01770 
01771     ULONG BufferLength;
01772     ULONG DosPathLength;
01773     PWSTR FullNtPathName = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01774     PWSTR FullDosPathName = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01775     UNICODE_STRING Prefix;
01776     UNICODE_STRING UnicodeFilePart;
01777     UNICODE_STRING FullDosPathString;
01778     PCURDIR CurDir;
01779     RTL_PATH_TYPE DosPathType;
01780     RTL_PATH_TYPE InputDosPathType;
01781     ULONG DosPathNameOffset;
01782     ULONG FullDosPathNameLength;
01783     ULONG LastCharacter;
01784     UNICODE_STRING UnicodeString;
01785     BOOLEAN NameInvalid;
01786     WCHAR StaticDosBuffer[DOS_MAX_PATH_LENGTH + 1];
01787     BOOLEAN UseWin32Name;
01788 
01789     <span class="comment">//</span>
01790     <span class="comment">// Calculate the size needed for the full pathname. Add in</span>
01791     <span class="comment">// space for the longest Nt prefix</span>
01792     <span class="comment">//</span>
01793 
01794     BufferLength = (DOS_MAX_PATH_LENGTH &lt;&lt; 1 ) + <span class="keyword">sizeof</span>(UNICODE_NULL);
01795     DosPathLength = (DOS_MAX_PATH_LENGTH &lt;&lt; 1 );
01796 
01797     <span class="keywordflow">if</span> ( !BufferLength ) {
01798         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01799         }
01800 
01801 
01802     <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;UnicodeString,DosFileName);
01803 
01804     <span class="comment">//</span>
01805     <span class="comment">// see if this is \\?\ form of name</span>
01806     <span class="comment">//</span>
01807 
01808     <span class="keywordflow">if</span> ( UnicodeString.Length &gt; 8 &amp;&amp; UnicodeString.Buffer[0] == <span class="charliteral">'\\'</span> &amp;&amp;
01809          UnicodeString.Buffer[1] == <span class="charliteral">'\\'</span> &amp;&amp; UnicodeString.Buffer[2] == <span class="charliteral">'?'</span> &amp;&amp;
01810          UnicodeString.Buffer[3] == <span class="charliteral">'\\'</span> ) {
01811 
01812         UseWin32Name = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01813         }
01814     <span class="keywordflow">else</span> {
01815         UseWin32Name = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01816 
01817         <span class="comment">//</span>
01818         <span class="comment">// The dos name starts just after the longest Nt prefix</span>
01819         <span class="comment">//</span>
01820 
01821         FullDosPathName = &amp;StaticDosBuffer[0];
01822 
01823         BufferLength += <a class="code" href="../../d5/d1/curdir_8c.html#a4">RtlpLongestPrefix</a>;
01824 
01825         <span class="comment">//</span>
01826         <span class="comment">// Allocate space for the full Nt Name (including DOS name portion)</span>
01827         <span class="comment">//</span>
01828 
01829         FullNtPathName = <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a0">RtlAllocateHeap</a>(RtlProcessHeap(), 0, BufferLength);
01830 
01831         <span class="keywordflow">if</span> ( !FullNtPathName ) {
01832             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01833             }
01834         }
01835 
01836     <a class="code" href="../../d2/d4/eballoc_8c.html#a1">RtlAcquirePebLock</a>();
01837     <span class="keywordflow">try</span> {
01838 
01839 
01840         <span class="keywordflow">if</span> ( UseWin32Name ) {
01841 
01842             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d1/curdir_8c.html#a28">RtlpWin32NTNameToNtPathName_U</a>(&amp;UnicodeString,NtFileName,FilePart,<a class="code" href="../../d2/d2/rtload_8c.html#a7">RelativeName</a>)) {
01843                 <span class="keywordflow">goto</span> finally_exit;
01844                 }
01845             <span class="keywordflow">else</span> {
01846                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01847                 }
01848 
01849             }
01850 
01851 
01852         FullDosPathNameLength = <a class="code" href="../../d5/d1/curdir_8c.html#a17">RtlGetFullPathName_Ustr</a>(
01853                                     &amp;UnicodeString,
01854                                     DosPathLength,
01855                                     FullDosPathName,
01856                                     FilePart,
01857                                     &amp;NameInvalid,
01858                                     &amp;InputDosPathType
01859                                     );
01860 
01861         <span class="keywordflow">if</span> ( NameInvalid || !FullDosPathNameLength ||
01862               FullDosPathNameLength &gt; DosPathLength ) {
01863             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01864             }
01865 
01866         <span class="comment">//</span>
01867         <span class="comment">// Determine how to format prefix of FullNtPathName base on the</span>
01868         <span class="comment">// the type of Dos path name.  All Nt names begin in the \DosDevices</span>
01869         <span class="comment">// directory.</span>
01870         <span class="comment">//</span>
01871 
01872         Prefix = <a class="code" href="../../d5/d1/curdir_8c.html#a13">RtlpDosDevicesPrefix</a>;
01873 
01874         DosPathType = <a class="code" href="../../d5/d1/curdir_8c.html#a23">RtlDetermineDosPathNameType_U</a>(FullDosPathName);
01875 
01876         <span class="keywordflow">switch</span> (DosPathType) {
01877             <span class="keywordflow">case</span> RtlPathTypeUncAbsolute :
01878 
01879                 <span class="comment">//</span>
01880                 <span class="comment">// Unc name, use \DosDevices\UNC symbolic link to find</span>
01881                 <span class="comment">// redirector.  Skip of \\ in source Dos path.</span>
01882                 <span class="comment">//</span>
01883 
01884                 Prefix = <a class="code" href="../../d5/d1/curdir_8c.html#a14">RtlpDosDevicesUncPrefix</a>;
01885                 DosPathNameOffset = 2;
01886                 <span class="keywordflow">break</span>;
01887 
01888             <span class="keywordflow">case</span> RtlPathTypeLocalDevice :
01889 
01890                 <span class="comment">//</span>
01891                 <span class="comment">// Local device name, so just use \DosDevices prefix and</span>
01892                 <span class="comment">// skip \\.\ in source Dos path.</span>
01893                 <span class="comment">//</span>
01894 
01895                 DosPathNameOffset = 4;
01896                 <span class="keywordflow">break</span>;
01897 
01898             <span class="keywordflow">case</span> RtlPathTypeRootLocalDevice :
01899 
01900                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
01901                 <span class="keywordflow">break</span>;
01902 
01903             <span class="keywordflow">case</span> RtlPathTypeDriveAbsolute :
01904             <span class="keywordflow">case</span> RtlPathTypeDriveRelative :
01905             <span class="keywordflow">case</span> RtlPathTypeRooted :
01906             <span class="keywordflow">case</span> RtlPathTypeRelative :
01907 
01908                 <span class="comment">//</span>
01909                 <span class="comment">// All drive references just use \DosDevices prefix and</span>
01910                 <span class="comment">// do not skip any of the characters in the source Dos path.</span>
01911                 <span class="comment">//</span>
01912 
01913                 DosPathNameOffset = 0;
01914                 <span class="keywordflow">break</span>;
01915 
01916             <span class="keywordflow">default</span>:
01917                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
01918             }
01919 
01920         <span class="comment">//</span>
01921         <span class="comment">// Copy the full DOS path next to the name prefix, skipping over</span>
01922         <span class="comment">// the "\\" at the front of the UNC path or the "\\.\" at the front</span>
01923         <span class="comment">// of a device name.</span>
01924         <span class="comment">//</span>
01925 
01926         RtlMoveMemory(FullNtPathName,Prefix.Buffer,Prefix.Length);
01927         RtlMoveMemory((PUCHAR)FullNtPathName+Prefix.Length,
01928                       FullDosPathName + DosPathNameOffset,
01929                       FullDosPathNameLength - (DosPathNameOffset&lt;&lt;1));
01930 
01931         <span class="comment">//</span>
01932         <span class="comment">// Null terminate the path name to make strlen below happy.</span>
01933         <span class="comment">//</span>
01934 
01935 
01936         NtFileName-&gt;Buffer = FullNtPathName;
01937         NtFileName-&gt;Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(FullDosPathNameLength-(DosPathNameOffset&lt;&lt;1))+Prefix.Length;
01938         NtFileName-&gt;MaximumLength = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)BufferLength;
01939         LastCharacter = NtFileName-&gt;Length &gt;&gt; 1;
01940         FullNtPathName[ LastCharacter ] = UNICODE_NULL;
01941 
01942 
01943         <span class="comment">//</span>
01944         <span class="comment">// Readjust the file part to point to the appropriate position within</span>
01945         <span class="comment">// the FullNtPathName buffer instead of inside the FullDosPathName</span>
01946         <span class="comment">// buffer</span>
01947         <span class="comment">//</span>
01948 
01949 
01950         <span class="keywordflow">if</span> ( ARGUMENT_PRESENT(FilePart) ) {
01951             <span class="keywordflow">if</span> (*FilePart) {
01952                  <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;UnicodeFilePart,*FilePart);
01953                 *FilePart = &amp;FullNtPathName[ LastCharacter ] - (UnicodeFilePart.Length &gt;&gt; 1);
01954                 }
01955             }
01956 
01957         <span class="keywordflow">if</span> ( ARGUMENT_PRESENT(<a class="code" href="../../d2/d2/rtload_8c.html#a7">RelativeName</a>) ) {
01958 
01959             <span class="comment">//</span>
01960             <span class="comment">// If the current directory is a sub-string of the</span>
01961             <span class="comment">// Nt file name, and if a handle exists for the current</span>
01962             <span class="comment">// directory, then return the directory handle and name</span>
01963             <span class="comment">// relative to the directory.</span>
01964             <span class="comment">//</span>
01965 
01966             <a class="code" href="../../d2/d2/rtload_8c.html#a7">RelativeName</a>-&gt;RelativeName.Length = 0;
01967             <a class="code" href="../../d2/d2/rtload_8c.html#a7">RelativeName</a>-&gt;RelativeName.MaximumLength = 0;
01968             <a class="code" href="../../d2/d2/rtload_8c.html#a7">RelativeName</a>-&gt;RelativeName.Buffer = 0;
01969             <a class="code" href="../../d2/d2/rtload_8c.html#a7">RelativeName</a>-&gt;ContainingDirectory = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01970 
01971             <span class="keywordflow">if</span> ( InputDosPathType == RtlPathTypeRelative ) {
01972 
01973                 CurDir = &amp;(NtCurrentPeb()-&gt;ProcessParameters-&gt;CurrentDirectory);
01974 
01975                 <span class="keywordflow">if</span> ( CurDir-&gt;Handle ) {
01976 
01977                     <span class="comment">//</span>
01978                     <span class="comment">// Now compare curdir to full dos path. If curdir length is</span>
01979                     <span class="comment">// greater than full path. It is not a match. Otherwise,</span>
01980                     <span class="comment">// trim full path length to cur dir length and compare.</span>
01981                     <span class="comment">//</span>
01982 
01983                     <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;FullDosPathString,FullDosPathName);
01984                     <span class="keywordflow">if</span> ( CurDir-&gt;DosPath.Length &lt;= FullDosPathString.Length ) {
01985                         FullDosPathString.Length = CurDir-&gt;DosPath.Length;
01986                         <span class="keywordflow">if</span> ( <a class="code" href="../../d6/d6/nls_8c.html#a42">RtlEqualUnicodeString</a>(
01987                                 (PUNICODE_STRING)&amp;CurDir-&gt;DosPath,
01988                                 &amp;FullDosPathString,
01989                                 <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>
01990                                 ) ) {
01991 
01992                             <span class="comment">//</span>
01993                             <span class="comment">// The full dos pathname is a substring of the</span>
01994                             <span class="comment">// current directory.  Compute the start of the</span>
01995                             <span class="comment">// relativename.</span>
01996                             <span class="comment">//</span>
01997 
01998                             <a class="code" href="../../d2/d2/rtload_8c.html#a7">RelativeName</a>-&gt;RelativeName.Buffer = ((PUCHAR)FullNtPathName + Prefix.Length - (DosPathNameOffset&lt;&lt;1) + (CurDir-&gt;DosPath.Length));
01999                             <a class="code" href="../../d2/d2/rtload_8c.html#a7">RelativeName</a>-&gt;RelativeName.Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)FullDosPathNameLength - (CurDir-&gt;DosPath.Length);
02000                             <span class="keywordflow">if</span> ( *(PWSTR)(<a class="code" href="../../d2/d2/rtload_8c.html#a7">RelativeName</a>-&gt;RelativeName.Buffer) == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span> ) {
02001                                 (PWSTR)(<a class="code" href="../../d2/d2/rtload_8c.html#a7">RelativeName</a>-&gt;RelativeName.Buffer)++;
02002                                 <a class="code" href="../../d2/d2/rtload_8c.html#a7">RelativeName</a>-&gt;RelativeName.Length -= 2;
02003                                 }
02004                             <a class="code" href="../../d2/d2/rtload_8c.html#a7">RelativeName</a>-&gt;RelativeName.MaximumLength = <a class="code" href="../../d2/d2/rtload_8c.html#a7">RelativeName</a>-&gt;RelativeName.Length;
02005                             <a class="code" href="../../d2/d2/rtload_8c.html#a7">RelativeName</a>-&gt;ContainingDirectory = CurDir-&gt;Handle;
02006                             }
02007                         }
02008                     }
02009                 }
02010             }
02011 finally_exit:;
02012         }
02013     finally {
02014 
02015         <span class="keywordflow">if</span> ( AbnormalTermination() ) {
02016             <span class="keywordflow">if</span> ( FullNtPathName ) {
02017                 <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>(RtlProcessHeap(), 0, FullNtPathName);
02018                 }
02019 
02020             <a class="code" href="../../d2/d4/eballoc_8c.html#a2">RtlReleasePebLock</a>();
02021 
02022             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02023             }
02024 
02025         <a class="code" href="../../d2/d4/eballoc_8c.html#a2">RtlReleasePebLock</a>();
02026     }
02027 
02028     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02029 }
02030 
02031 
02032 BOOLEAN
<a name="l02033"></a><a class="code" href="../../d5/d1/curdir_8c.html#a30">02033</a> <a class="code" href="../../d5/d1/curdir_8c.html#a30">RtlDoesFileExists_UEx</a>(
02034     IN PCWSTR FileName,
02035     IN BOOLEAN TreatDeniedOrSharingAsHit
02036     )
02037 
02038 <span class="comment">/*++</span>
02039 <span class="comment"></span>
02040 <span class="comment">Routine Description:</span>
02041 <span class="comment"></span>
02042 <span class="comment">    This function checks to see if the specified unicode filename exists.</span>
02043 <span class="comment"></span>
02044 <span class="comment">Arguments:</span>
02045 <span class="comment"></span>
02046 <span class="comment">    FileName - Supplies the file name of the file to find.</span>
02047 <span class="comment"></span>
02048 <span class="comment">Return Value:</span>
02049 <span class="comment"></span>
02050 <span class="comment">    TRUE - The file was found.</span>
02051 <span class="comment"></span>
02052 <span class="comment">    FALSE - The file was not found.</span>
02053 <span class="comment"></span>
02054 <span class="comment">--*/</span>
02055 
02056 {
02057     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
02058     OBJECT_ATTRIBUTES Obja;
02059     UNICODE_STRING NtFileName;
02060     BOOLEAN ReturnValue;
02061     RTL_RELATIVE_NAME <a class="code" href="../../d2/d2/rtload_8c.html#a7">RelativeName</a>;
02062     PVOID FreeBuffer;
02063     FILE_BASIC_INFORMATION BasicInfo;
02064 
02065     ReturnValue = <a class="code" href="../../d5/d1/curdir_8c.html#a29">RtlDosPathNameToNtPathName_U</a>(
02066                     <a class="code" href="../../d2/d2/rtload_8c.html#a3">FileName</a>,
02067                     &amp;NtFileName,
02068                     <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
02069                     &amp;<a class="code" href="../../d2/d2/rtload_8c.html#a7">RelativeName</a>
02070                     );
02071 
02072     <span class="keywordflow">if</span> ( !ReturnValue ) {
02073         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02074         }
02075 
02076     FreeBuffer = NtFileName.Buffer;
02077 
02078     <span class="keywordflow">if</span> ( <a class="code" href="../../d2/d2/rtload_8c.html#a7">RelativeName</a>.RelativeName.Length ) {
02079         NtFileName = *(PUNICODE_STRING)&amp;<a class="code" href="../../d2/d2/rtload_8c.html#a7">RelativeName</a>.RelativeName;
02080         }
02081     <span class="keywordflow">else</span> {
02082         <a class="code" href="../../d2/d2/rtload_8c.html#a7">RelativeName</a>.ContainingDirectory = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02083         }
02084 
02085     InitializeObjectAttributes(
02086         &amp;Obja,
02087         &amp;NtFileName,
02088         OBJ_CASE_INSENSITIVE,
02089         <a class="code" href="../../d2/d2/rtload_8c.html#a7">RelativeName</a>.ContainingDirectory,
02090         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>
02091         );
02092 
02093     <span class="comment">//</span>
02094     <span class="comment">// Query the file's attributes.  Note that the file cannot simply be opened</span>
02095     <span class="comment">// to determine whether or not it exists, as the NT LanMan redirector lies</span>
02096     <span class="comment">// on NtOpenFile to a Lan Manager server because it does not actually open</span>
02097     <span class="comment">// the file until an operation is performed on it.</span>
02098     <span class="comment">//</span>
02099 
02100     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d1/d0/io_2misc_8c.html#a4">NtQueryAttributesFile</a>(
02101                 &amp;Obja,
02102                 &amp;BasicInfo
02103                 );
02104     <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>(RtlProcessHeap(),0,FreeBuffer);
02105 
02106     <span class="keywordflow">if</span> ( !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>) ) {
02107         <span class="keywordflow">if</span> ( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_SHARING_VIOLATION ||
02108              <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_ACCESS_DENIED ) {
02109             <span class="keywordflow">if</span> ( TreatDeniedOrSharingAsHit ) {
02110                 ReturnValue = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02111                 }
02112             <span class="keywordflow">else</span> {
02113                 ReturnValue = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02114                 }
02115             }
02116         <span class="keywordflow">else</span> {
02117             ReturnValue = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02118             }
02119         }
02120     <span class="keywordflow">else</span> {
02121         ReturnValue = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02122         }
02123     <span class="keywordflow">return</span> ReturnValue;
02124 }
02125 
02126 
02127 BOOLEAN
<a name="l02128"></a><a class="code" href="../../d5/d1/curdir_8c.html#a31">02128</a> <a class="code" href="../../d5/d1/curdir_8c.html#a31">RtlDoesFileExists_U</a>(
02129     IN PCWSTR FileName
02130     )
02131 
02132 <span class="comment">/*++</span>
02133 <span class="comment"></span>
02134 <span class="comment">Routine Description:</span>
02135 <span class="comment"></span>
02136 <span class="comment">    This function checks to see if the specified unicode filename exists.</span>
02137 <span class="comment"></span>
02138 <span class="comment">Arguments:</span>
02139 <span class="comment"></span>
02140 <span class="comment">    FileName - Supplies the file name of the file to find.</span>
02141 <span class="comment"></span>
02142 <span class="comment">Return Value:</span>
02143 <span class="comment"></span>
02144 <span class="comment">    TRUE - The file was found.</span>
02145 <span class="comment"></span>
02146 <span class="comment">    FALSE - The file was not found.</span>
02147 <span class="comment"></span>
02148 <span class="comment">--*/</span>
02149 
02150 {
02151 
02152     <span class="keywordflow">return</span> <a class="code" href="../../d5/d1/curdir_8c.html#a30">RtlDoesFileExists_UEx</a>(<a class="code" href="../../d2/d2/rtload_8c.html#a3">FileName</a>,<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
02153 }
02154 
02155 ULONG
<a name="l02156"></a><a class="code" href="../../d5/d1/curdir_8c.html#a32">02156</a> <a class="code" href="../../d5/d1/curdir_8c.html#a32">RtlDosSearchPath_U</a>(
02157     IN PWSTR lpPath,
02158     IN PWSTR lpFileName,
02159     IN PWSTR lpExtension OPTIONAL,
02160     IN ULONG nBufferLength,
02161     OUT PWSTR lpBuffer,
02162     OUT PWSTR *lpFilePart
02163     )
02164 
02165 <span class="comment">/*++</span>
02166 <span class="comment"></span>
02167 <span class="comment">Routine Description:</span>
02168 <span class="comment"></span>
02169 <span class="comment">    This function is used to search for a file specifying a search path</span>
02170 <span class="comment">    and a filename.  It returns with a fully qualified pathname of the</span>
02171 <span class="comment">    found file.</span>
02172 <span class="comment"></span>
02173 <span class="comment">    This function is used to locate a file using the specified path.  If</span>
02174 <span class="comment">    the file is found, its fully qualified pathname is returned.  In</span>
02175 <span class="comment">    addition to this, it calculates the address of the file name portion</span>
02176 <span class="comment">    of the fully qualified pathname.</span>
02177 <span class="comment"></span>
02178 <span class="comment">Arguments:</span>
02179 <span class="comment"></span>
02180 <span class="comment">    lpPath - Supplies the search path to be used when locating the file.</span>
02181 <span class="comment"></span>
02182 <span class="comment">    lpFileName - Supplies the file name of the file to search for.</span>
02183 <span class="comment"></span>
02184 <span class="comment">    lpExtension - An optional parameter, that if specified, supplies an</span>
02185 <span class="comment">        extension to be added to the filename when doing the search.</span>
02186 <span class="comment">        The extension is only added if the specified filename does not</span>
02187 <span class="comment">        end with an extension.</span>
02188 <span class="comment"></span>
02189 <span class="comment">    nBufferLength - Supplies the length in bytes of the buffer that is</span>
02190 <span class="comment">        to receive the fully qualified path.</span>
02191 <span class="comment"></span>
02192 <span class="comment">    lpBuffer - Returns the fully qualified pathname corresponding to the</span>
02193 <span class="comment">        file that was found.</span>
02194 <span class="comment"></span>
02195 <span class="comment">    lpFilePart - Optional parameter that if specified, returns the</span>
02196 <span class="comment">        address of the last component of the fully qualified pathname.</span>
02197 <span class="comment"></span>
02198 <span class="comment">Return Value:</span>
02199 <span class="comment"></span>
02200 <span class="comment">    The return value is the length of the string copied to lpBuffer, not</span>
02201 <span class="comment">    including the terminating null character.  If the return value is</span>
02202 <span class="comment">    greater than nBufferLength, the return value is the size of the buffer</span>
02203 <span class="comment">    required to hold the pathname.  The return value is zero if the</span>
02204 <span class="comment">    function failed.</span>
02205 <span class="comment"></span>
02206 <span class="comment"></span>
02207 <span class="comment">--*/</span>
02208 
02209 {
02210 
02211     PWSTR ComputedFileName;
02212     ULONG ExtensionLength;
02213     ULONG PathLength;
02214     ULONG FileLength;
02215     PWSTR p;
02216     UNICODE_STRING Scratch;
02217 
02218     <span class="comment">//</span>
02219     <span class="comment">// if the file name is not a relative name, then</span>
02220     <span class="comment">// return an if the file does not exist.</span>
02221     <span class="comment">//</span>
02222     <span class="comment">// If a fully qualified pathname is used in the search, then</span>
02223     <span class="comment">// allow access_denied or sharing violations to terminate the</span>
02224     <span class="comment">// search. This was the nt 3.1-4.0 behavior, and was changed for the</span>
02225     <span class="comment">// loader to handle cases where when walking through a search, we didn't</span>
02226     <span class="comment">// terminate the search early because of an inaccessible UNC path component</span>
02227     <span class="comment">// be restoring the old behavior in this case, we give the correct (access_denied)</span>
02228     <span class="comment">// error codes on fully qualified module lookups, but keep going when bumping</span>
02229     <span class="comment">// through search path components</span>
02230     <span class="comment">//</span>
02231 
02232     <span class="keywordflow">if</span> ( <a class="code" href="../../d5/d1/curdir_8c.html#a23">RtlDetermineDosPathNameType_U</a>(lpFileName) != RtlPathTypeRelative ) {
02233         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d1/curdir_8c.html#a30">RtlDoesFileExists_UEx</a>(lpFileName,<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) ) {
02234             PathLength = <a class="code" href="../../d5/d1/curdir_8c.html#a27">RtlGetFullPathName_U</a>(
02235                            lpFileName,
02236                            nBufferLength,
02237                            lpBuffer,
02238                            lpFilePart
02239                            );
02240             <span class="keywordflow">return</span> PathLength;
02241             }
02242         <span class="keywordflow">else</span> {
02243             <span class="keywordflow">return</span> 0;
02244             }
02245         }
02246 
02247     <span class="comment">//</span>
02248     <span class="comment">// Determine if the file name contains an extension</span>
02249     <span class="comment">//</span>
02250 
02251     ExtensionLength = 1;
02252     p = lpFileName;
02253     <span class="keywordflow">while</span> (*p) {
02254         <span class="keywordflow">if</span> ( *p == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'.'</span> ) {
02255             ExtensionLength = 0;
02256             <span class="keywordflow">break</span>;
02257             }
02258         p++;
02259         }
02260 
02261     <span class="comment">//</span>
02262     <span class="comment">// If no extension was found, then determine the extension length</span>
02263     <span class="comment">// that should be used to search for the file</span>
02264     <span class="comment">//</span>
02265 
02266     <span class="keywordflow">if</span> ( ExtensionLength ) {
02267         <span class="keywordflow">if</span> ( ARGUMENT_PRESENT(lpExtension) ) {
02268             <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;Scratch,lpExtension);
02269             ExtensionLength = Scratch.Length;
02270             }
02271         <span class="keywordflow">else</span> {
02272             ExtensionLength = 0;
02273             }
02274         }
02275 
02276     <span class="comment">//</span>
02277     <span class="comment">// Compute the file name length and the path length;</span>
02278     <span class="comment">//</span>
02279 
02280     <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;Scratch,lpPath);
02281     PathLength = Scratch.Length;
02282     <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;Scratch,lpFileName);
02283     FileLength = Scratch.Length;
02284 
02285     ComputedFileName = <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a0">RtlAllocateHeap</a>(
02286                             RtlProcessHeap(), 0,
02287                             PathLength + FileLength + ExtensionLength + 3*<span class="keyword">sizeof</span>(UNICODE_NULL)
02288                             );
02289 
02290     <span class="keywordflow">if</span> ( !ComputedFileName ) {
02291         <span class="keywordflow">return</span> 0;
02292         }
02293 
02294     <span class="comment">//</span>
02295     <span class="comment">// find ; 's in path and copy path component to computed file name</span>
02296     <span class="comment">//</span>
02297 
02298     <span class="keywordflow">do</span> {
02299         p = ComputedFileName;
02300         <span class="keywordflow">while</span> (*lpPath) {
02301             <span class="keywordflow">if</span> (*lpPath == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">';'</span>) {
02302                 lpPath++;
02303                 <span class="keywordflow">break</span>;
02304                 }
02305             *p++ = *lpPath++;
02306             }
02307 
02308         <span class="keywordflow">if</span> (p != ComputedFileName &amp;&amp;
02309             p [ -1 ] != <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span> ) {
02310             *p++ = <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span>;
02311             }
02312         <span class="keywordflow">if</span> (*lpPath == UNICODE_NULL) {
02313             lpPath = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02314             }
02315         RtlMoveMemory(p,lpFileName,FileLength);
02316         <span class="keywordflow">if</span> ( ExtensionLength ) {
02317             RtlMoveMemory((PUCHAR)p+FileLength,lpExtension,ExtensionLength+<span class="keyword">sizeof</span>(UNICODE_NULL));
02318             }
02319         <span class="keywordflow">else</span> {
02320             *(PWSTR)((PUCHAR)p+FileLength) = UNICODE_NULL;
02321             }
02322 
02323         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d1/curdir_8c.html#a30">RtlDoesFileExists_UEx</a>(ComputedFileName,<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) ) {
02324             PathLength = <a class="code" href="../../d5/d1/curdir_8c.html#a27">RtlGetFullPathName_U</a>(
02325                            ComputedFileName,
02326                            nBufferLength,
02327                            lpBuffer,
02328                            lpFilePart
02329                            );
02330             <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>(RtlProcessHeap(), 0, ComputedFileName);
02331             <span class="keywordflow">return</span> PathLength;
02332             }
02333         }
02334     <span class="keywordflow">while</span> ( lpPath );
02335 
02336     <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>(RtlProcessHeap(), 0, ComputedFileName);
02337     <span class="keywordflow">return</span> 0;
02338 }
02339 
02340 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l02341"></a><a class="code" href="../../d5/d1/curdir_8c.html#a15">02341</a> <a class="code" href="../../d5/d1/curdir_8c.html#a15">RtlpCheckRelativeDrive</a>(
02342     WCHAR NewDrive
02343     )
02344 
02345 <span class="comment">/*++</span>
02346 <span class="comment"></span>
02347 <span class="comment">Routine Description:</span>
02348 <span class="comment"></span>
02349 <span class="comment">    This function is called whenever we are asked to expand a non</span>
02350 <span class="comment">    current directory drive relative name ( f:this\is\my\file ).  In</span>
02351 <span class="comment">    this case, we validate the environment variable string to make sure</span>
02352 <span class="comment">    the current directory at that drive is valid. If not, we trim back to</span>
02353 <span class="comment">    the root.</span>
02354 <span class="comment"></span>
02355 <span class="comment">Arguments:</span>
02356 <span class="comment"></span>
02357 <span class="comment">    NewDrive - Supplies the drive to check</span>
02358 <span class="comment"></span>
02359 <span class="comment">Return Value:</span>
02360 <span class="comment"></span>
02361 <span class="comment">    None.</span>
02362 <span class="comment"></span>
02363 <span class="comment">--*/</span>
02364 
02365 {
02366 
02367     WCHAR EnvVarValueBuffer[DOS_MAX_PATH_LENGTH+12]; <span class="comment">// + sizeof (\DosDevices\)</span>
02368     WCHAR EnvVarNameBuffer[4];
02369     UNICODE_STRING EnvVarName;
02370     UNICODE_STRING EnvValue;
02371     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
02372     OBJECT_ATTRIBUTES Obja;
02373     IO_STATUS_BLOCK IoStatusBlock;
02374     HANDLE DirHandle;
02375     ULONG HardErrorValue;
02376     PTEB Teb;
02377 
02378     EnvVarNameBuffer[0] = <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'='</span>;
02379     EnvVarNameBuffer[1] = (WCHAR)NewDrive;
02380     EnvVarNameBuffer[2] = <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">':'</span>;
02381     EnvVarNameBuffer[3] = UNICODE_NULL;
02382     <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;EnvVarName,EnvVarNameBuffer);
02383 
02384 
02385     <span class="comment">//</span>
02386     <span class="comment">// capture the value in a buffer that has space at the front for the dos devices</span>
02387     <span class="comment">// prefix</span>
02388     <span class="comment">//</span>
02389 
02390     EnvValue.Length = 0;
02391     EnvValue.MaximumLength = DOS_MAX_PATH_LENGTH&lt;&lt;1;
02392     EnvValue.Buffer = &amp;EnvVarValueBuffer[<a class="code" href="../../d5/d1/curdir_8c.html#a13">RtlpDosDevicesPrefix</a>.Length&gt;&gt;1];
02393 
02394     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d5/d7/environ_8c.html#a6">RtlQueryEnvironmentVariable_U</a>( <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
02395                                             &amp;EnvVarName,
02396                                             &amp;EnvValue
02397                                           );
02398     <span class="keywordflow">if</span> ( !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> ) ) {
02399 
02400         <span class="comment">//</span>
02401         <span class="comment">// Otherwise default to root directory of drive</span>
02402         <span class="comment">//</span>
02403 
02404         EnvValue.Buffer[0] = (WCHAR)NewDrive;
02405         EnvValue.Buffer[1] = <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">':'</span>;
02406         EnvValue.Buffer[2] = <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span>;
02407         EnvValue.Buffer[3] = UNICODE_NULL;
02408         EnvValue.Length = 6;
02409         }
02410 
02411     <span class="comment">//</span>
02412     <span class="comment">// Form the NT name for this directory</span>
02413     <span class="comment">//</span>
02414 
02415     EnvValue.Length = EnvValue.Length + <a class="code" href="../../d5/d1/curdir_8c.html#a13">RtlpDosDevicesPrefix</a>.Length;
02416     EnvValue.MaximumLength = <span class="keyword">sizeof</span>(EnvValue);
02417     EnvValue.Buffer = EnvVarValueBuffer;
02418     RtlCopyMemory(EnvVarValueBuffer,<a class="code" href="../../d5/d1/curdir_8c.html#a13">RtlpDosDevicesPrefix</a>.Buffer,<a class="code" href="../../d5/d1/curdir_8c.html#a13">RtlpDosDevicesPrefix</a>.Length);
02419 
02420     InitializeObjectAttributes(
02421         &amp;Obja,
02422         &amp;EnvValue,
02423         OBJ_CASE_INSENSITIVE,
02424         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
02425         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>
02426         );
02427 
02428 
02429     Teb = NtCurrentTeb();
02430     HardErrorValue = Teb-&gt;HardErrorsAreDisabled;
02431     Teb-&gt;HardErrorsAreDisabled = 1;
02432 
02433     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d4/d2/open_8c.html#a0">NtOpenFile</a>(
02434                 &amp;DirHandle,
02435                 SYNCHRONIZE,
02436                 &amp;Obja,
02437                 &amp;IoStatusBlock,
02438                 FILE_SHARE_READ | FILE_SHARE_WRITE,
02439                 FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT
02440                 );
02441 
02442     Teb-&gt;HardErrorsAreDisabled = HardErrorValue;
02443 
02444     <span class="comment">//</span>
02445     <span class="comment">// If the open succeeds, then the directory is valid... No need to do anything</span>
02446     <span class="comment">// further. If the open fails, then trim back the environment to the root.</span>
02447     <span class="comment">//</span>
02448 
02449     <span class="keywordflow">if</span> ( <a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>) ) {
02450         <a class="code" href="../../d5/d0/obclose_8c.html#a1">NtClose</a>(DirHandle);
02451         <span class="keywordflow">return</span>;
02452         }
02453 
02454     <a class="code" href="../../d5/d1/curdir_8c.html#a20">RtlpResetDriveEnvironment</a>(NewDrive);
02455 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:39:38 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
