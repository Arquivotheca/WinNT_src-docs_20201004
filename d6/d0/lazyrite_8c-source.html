<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: lazyrite.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>lazyrite.c</h1><a href="../../d5/d1/lazyrite_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1990  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    lazyrite.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module implements the lazy writer for the Cache subsystem.</span>
00012 <span class="comment"></span>
00013 <span class="comment">Author:</span>
00014 <span class="comment"></span>
00015 <span class="comment">    Tom Miller      [TomM]      22-July-1990</span>
00016 <span class="comment"></span>
00017 <span class="comment">Revision History:</span>
00018 <span class="comment"></span>
00019 <span class="comment">--*/</span>
00020 
00021 <span class="preprocessor">#include "<a class="code" href="../../d5/d5/cc_8h.html">cc.h</a>"</span>
00022 
00023 <span class="comment">//</span>
00024 <span class="comment">//  The Bug check file id for this module</span>
00025 <span class="comment">//</span>
00026 
<a name="l00027"></a><a class="code" href="../../d5/d1/lazyrite_8c.html#a0">00027</a> <span class="preprocessor">#define BugCheckFileId                   (CACHE_BUG_CHECK_LAZYRITE)</span>
00028 <span class="preprocessor"></span>
00029 <span class="comment">//</span>
00030 <span class="comment">//  Define our debug constant</span>
00031 <span class="comment">//</span>
00032 
<a name="l00033"></a><a class="code" href="../../d5/d1/lazyrite_8c.html#a1">00033</a> <span class="preprocessor">#define me 0x00000020</span>
00034 <span class="preprocessor"></span>
00035 <span class="comment">//</span>
00036 <span class="comment">//  Local support routines</span>
00037 <span class="comment">//</span>
00038 
00039 <a class="code" href="../../d2/d9/struct__WORK__QUEUE__ENTRY.html">PWORK_QUEUE_ENTRY</a>
00040 <a class="code" href="../../d5/d1/lazyrite_8c.html#a2">CcReadWorkQueue</a> (
00041     );
00042 
00043 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00044 <a class="code" href="../../d5/d1/lazyrite_8c.html#a3">CcLazyWriteScan</a> (
00045     );
00046 
00047 
00048 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00049"></a><a class="code" href="../../d5/d1/lazyrite_8c.html#a4">00049</a> <a class="code" href="../../d5/d5/cc_8h.html#a185">CcScheduleLazyWriteScan</a> (
00050     )
00051 
00052 <span class="comment">/*++</span>
00053 <span class="comment"></span>
00054 <span class="comment">Routine Description:</span>
00055 <span class="comment"></span>
00056 <span class="comment">    This routine may be called to schedule the next lazy writer scan,</span>
00057 <span class="comment">    during which lazy write and lazy close activity is posted to other</span>
00058 <span class="comment">    worker threads.  Callers should acquire the lazy writer spin lock</span>
00059 <span class="comment">    to see if the scan is currently active, and then call this routine</span>
00060 <span class="comment">    still holding the spin lock if not.  One special call is used at</span>
00061 <span class="comment">    the end of the lazy write scan to propagate lazy write active once</span>
00062 <span class="comment">    we go active.  This call is "the" scan thread, and it can therefore</span>
00063 <span class="comment">    safely schedule the next scan without taking out the spin lock.</span>
00064 <span class="comment"></span>
00065 <span class="comment">Arguments:</span>
00066 <span class="comment"></span>
00067 <span class="comment">    None</span>
00068 <span class="comment"></span>
00069 <span class="comment">Return Value:</span>
00070 <span class="comment"></span>
00071 <span class="comment">    None.</span>
00072 <span class="comment"></span>
00073 <span class="comment">--*/</span>
00074 
00075 {
00076     <span class="comment">//</span>
00077     <span class="comment">//  It is important to set the active flag TRUE first for the propagate</span>
00078     <span class="comment">//  case, because it is conceivable that once the timer is set, another</span>
00079     <span class="comment">//  thread could actually run and make the scan go idle before we then</span>
00080     <span class="comment">//  jam the flag TRUE.</span>
00081     <span class="comment">//</span>
00082     <span class="comment">//  When going from idle to active, we delay a little longer to let the</span>
00083     <span class="comment">//  app finish saving its file.</span>
00084     <span class="comment">//</span>
00085 
00086     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o5">ScanActive</a>) {
00087 
00088         <a class="code" href="../../d3/d2/timerobj_8c.html#a6">KeSetTimer</a>( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o4">ScanTimer</a>, <a class="code" href="../../d5/d2/cachedat_8c.html#a15">CcIdleDelay</a>, &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o3">ScanDpc</a> );
00089 
00090     } <span class="keywordflow">else</span> {
00091 
00092         <a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o5">ScanActive</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00093         <a class="code" href="../../d3/d2/timerobj_8c.html#a6">KeSetTimer</a>( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o4">ScanTimer</a>, <a class="code" href="../../d5/d2/cachedat_8c.html#a14">CcFirstDelay</a>, &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o3">ScanDpc</a> );
00094     }
00095 }
00096 
00097 
00098 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00099"></a><a class="code" href="../../d5/d1/lazyrite_8c.html#a5">00099</a> <a class="code" href="../../d5/d1/lazyrite_8c.html#a5">CcScanDpc</a> (
00100     IN <a class="code" href="../../d1/d6/struct__KDPC.html">PKDPC</a> Dpc,
00101     IN PVOID DeferredContext,
00102     IN PVOID SystemArgument1,
00103     IN PVOID SystemArgument2
00104     )
00105 
00106 <span class="comment">/*++</span>
00107 <span class="comment"></span>
00108 <span class="comment">Routine Description:</span>
00109 <span class="comment"></span>
00110 <span class="comment">    This is the Dpc routine which runs when the scan timer goes off.  It</span>
00111 <span class="comment">    simply posts an element for an Ex Worker thread to do the scan.</span>
00112 <span class="comment"></span>
00113 <span class="comment">Arguments:</span>
00114 <span class="comment"></span>
00115 <span class="comment">    (All are ignored)</span>
00116 <span class="comment"></span>
00117 <span class="comment">Return Value:</span>
00118 <span class="comment"></span>
00119 <span class="comment">    None.</span>
00120 <span class="comment"></span>
00121 <span class="comment">--*/</span>
00122 
00123 {
00124     <a class="code" href="../../d2/d9/struct__WORK__QUEUE__ENTRY.html">PWORK_QUEUE_ENTRY</a> WorkQueueEntry;
00125 
00126     UNREFERENCED_PARAMETER(Dpc);
00127     UNREFERENCED_PARAMETER(DeferredContext);
00128     UNREFERENCED_PARAMETER(SystemArgument1);
00129     UNREFERENCED_PARAMETER(SystemArgument2);
00130 
00131     WorkQueueEntry = <a class="code" href="../../d5/d5/cc_8h.html#a88">CcAllocateWorkQueueEntry</a>();
00132 
00133     <span class="comment">//</span>
00134     <span class="comment">//  If we failed to allocate a WorkQueueEntry, things must</span>
00135     <span class="comment">//  be in pretty bad shape.  However, all we have to do is</span>
00136     <span class="comment">//  say we are not active, and wait for another event to</span>
00137     <span class="comment">//  wake things up again.</span>
00138     <span class="comment">//</span>
00139 
00140     <span class="keywordflow">if</span> (WorkQueueEntry == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00141 
00142         <a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o5">ScanActive</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00143 
00144     } <span class="keywordflow">else</span> {
00145 
00146         <span class="comment">//</span>
00147         <span class="comment">//  Otherwise post a work queue entry to do the scan.</span>
00148         <span class="comment">//</span>
00149 
00150         WorkQueueEntry-&gt;<a class="code" href="../../d2/d9/struct__WORK__QUEUE__ENTRY.html#o8">Function</a> = (UCHAR)<a class="code" href="../../d5/d5/cc_8h.html#a210a169">LazyWriteScan</a>;
00151 
00152         <a class="code" href="../../d5/d1/lazyrite_8c.html#a8">CcPostWorkQueue</a>( WorkQueueEntry, &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a9">CcRegularWorkQueue</a> );
00153     }
00154 }
00155 
00156 
00157 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00158"></a><a class="code" href="../../d4/d2/cache_8h.html#a85">00158</a> <a class="code" href="../../d5/d1/lazyrite_8c.html#a6">CcWaitForCurrentLazyWriterActivity</a> (
00159     )
00160 
00161 <span class="comment">/*++</span>
00162 <span class="comment"></span>
00163 <span class="comment">Routine Description:</span>
00164 <span class="comment"></span>
00165 <span class="comment">    This routine allows a thread to receive notification when the current tick</span>
00166 <span class="comment">    of lazy writer work has completed.  It must not be called within a lazy</span>
00167 <span class="comment">    writer workitem!  The caller must not be holding synchronization that could</span>
00168 <span class="comment">    block a Cc workitem!</span>
00169 <span class="comment">    </span>
00170 <span class="comment">    In particular, this lets a caller insure that all avaliable lazy closes at</span>
00171 <span class="comment">    the time of the call have completed.</span>
00172 <span class="comment"></span>
00173 <span class="comment">Arguments:</span>
00174 <span class="comment"></span>
00175 <span class="comment">    None.</span>
00176 <span class="comment"></span>
00177 <span class="comment">Return Value:</span>
00178 <span class="comment"></span>
00179 <span class="comment">    Final result of the wait.    </span>
00180 <span class="comment"></span>
00181 <span class="comment">--*/</span>
00182 
00183 {
00184     KIRQL OldIrql;
00185     <a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a> <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>;
00186     <a class="code" href="../../d2/d9/struct__WORK__QUEUE__ENTRY.html">PWORK_QUEUE_ENTRY</a> WorkQueueEntry;
00187 
00188     WorkQueueEntry = <a class="code" href="../../d5/d5/cc_8h.html#a88">CcAllocateWorkQueueEntry</a>();
00189 
00190     <span class="keywordflow">if</span> (WorkQueueEntry == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00191         <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
00192     }
00193 
00194     WorkQueueEntry-&gt;<a class="code" href="../../d2/d9/struct__WORK__QUEUE__ENTRY.html#o8">Function</a> = (UCHAR)<a class="code" href="../../d5/d5/cc_8h.html#a210a170">EventSet</a>;
00195     <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( &amp;<a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>, NotificationEvent, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00196     WorkQueueEntry-&gt;<a class="code" href="../../d2/d9/struct__WORK__QUEUE__ENTRY.html#o7">Parameters</a>.Event.Event = &amp;<a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>;
00197 
00198     <span class="comment">//</span>
00199     <span class="comment">//  Add this to the post-tick work queue and wake the lazy writer for it.</span>
00200     <span class="comment">//  The lazy writer will add this to the end of the next batch of work</span>
00201     <span class="comment">//  he issues.</span>
00202     <span class="comment">//</span>
00203 
00204     <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
00205 
00206     InsertTailList( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a10">CcPostTickWorkQueue</a>, &amp;WorkQueueEntry-&gt;<a class="code" href="../../d2/d9/struct__WORK__QUEUE__ENTRY.html#o0">WorkQueueLinks</a> );
00207 
00208     <a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o6">OtherWork</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00209     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o5">ScanActive</a>) {
00210         <a class="code" href="../../d5/d5/cc_8h.html#a185">CcScheduleLazyWriteScan</a>();
00211     }
00212 
00213     <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
00214 
00215     <span class="keywordflow">return</span> <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;<a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a455">Executive</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00216 }
00217 
00218 
00219 
00220 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00221"></a><a class="code" href="../../d5/d1/lazyrite_8c.html#a3">00221</a> <a class="code" href="../../d5/d1/lazyrite_8c.html#a3">CcLazyWriteScan</a> (
00222     )
00223 
00224 <span class="comment">/*++</span>
00225 <span class="comment"></span>
00226 <span class="comment">Routine Description:</span>
00227 <span class="comment"></span>
00228 <span class="comment">    This routine implements the Lazy Writer scan for dirty data to flush</span>
00229 <span class="comment">    or any other work to do (lazy close).  This routine is scheduled by</span>
00230 <span class="comment">    calling CcScheduleLazyWriteScan.</span>
00231 <span class="comment"></span>
00232 <span class="comment">Arguments:</span>
00233 <span class="comment"></span>
00234 <span class="comment">    None.</span>
00235 <span class="comment"></span>
00236 <span class="comment">Return Value:</span>
00237 <span class="comment"></span>
00238 <span class="comment">    None.</span>
00239 <span class="comment"></span>
00240 <span class="comment">--*/</span>
00241 
00242 {
00243     ULONG PagesToWrite, ForegroundRate, EstimatedDirtyNextInterval;
00244     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap, FirstVisited;
00245     KIRQL OldIrql;
00246     ULONG LoopsWithLockHeld = 0;
00247     BOOLEAN AlreadyMoved = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00248 
00249     LIST_ENTRY PostTickWorkQueue;
00250 
00251     <span class="comment">//</span>
00252     <span class="comment">//  Top of Lazy Writer scan.</span>
00253     <span class="comment">//</span>
00254 
00255     <span class="keywordflow">try</span> {
00256 
00257         <span class="comment">//</span>
00258         <span class="comment">//  If there is no work to do, then we will go inactive, and return.</span>
00259         <span class="comment">//</span>
00260 
00261         <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
00262 
00263         <span class="keywordflow">if</span> ((<a class="code" href="../../d5/d2/cachedat_8c.html#a36">CcTotalDirtyPages</a> == 0) &amp;&amp; !<a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o6">OtherWork</a>) {
00264 
00265             <span class="comment">//</span>
00266             <span class="comment">//  Sleep if there are no deferred writes.  It is important to check</span>
00267             <span class="comment">//  proactively because writes may be blocked for reasons external</span>
00268             <span class="comment">//  to the cache manager.  The lazy writer must keep poking since it</span>
00269             <span class="comment">//  may have no bytes to write itself.</span>
00270             <span class="comment">//</span>
00271         
00272             <span class="keywordflow">if</span> (IsListEmpty(&amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a29">CcDeferredWrites</a>)) {
00273                 
00274                 <a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o5">ScanActive</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00275                 <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
00276             
00277             } <span class="keywordflow">else</span> {
00278 
00279                 <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
00280         
00281                 <span class="comment">//</span>
00282                 <span class="comment">//  Check for writes and schedule the next scan.</span>
00283                 <span class="comment">//</span>
00284         
00285                 <a class="code" href="../../d5/d5/cc_8h.html#a174">CcPostDeferredWrites</a>();
00286                 <a class="code" href="../../d5/d5/cc_8h.html#a185">CcScheduleLazyWriteScan</a>();
00287             }
00288 
00289             <span class="keywordflow">return</span>;
00290         }
00291 
00292         <span class="comment">//</span>
00293         <span class="comment">//  Pull out the post tick workitems for this pass.  It is important that</span>
00294         <span class="comment">//  we are doing this at the top since more could be queued as we rummage</span>
00295         <span class="comment">//  for work to do.  Post tick workitems are guaranteed to occur after all</span>
00296         <span class="comment">//  work generated in a complete scan.</span>
00297         <span class="comment">//</span>
00298 
00299         InitializeListHead( &amp;PostTickWorkQueue );
00300         <span class="keywordflow">while</span> (!IsListEmpty( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a10">CcPostTickWorkQueue</a> )) {
00301 
00302             PLIST_ENTRY Entry = RemoveHeadList( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a10">CcPostTickWorkQueue</a> );
00303             InsertTailList( &amp;PostTickWorkQueue, Entry );
00304         }
00305 
00306         <span class="comment">//</span>
00307         <span class="comment">//  Calculate the next sweep time stamp, then update all relevant fields for</span>
00308         <span class="comment">//  the next time around.  Also we can clear the OtherWork flag.</span>
00309         <span class="comment">//</span>
00310 
00311         <a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o6">OtherWork</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00312 
00313         <span class="comment">//</span>
00314         <span class="comment">//  Assume we will write our usual fraction of dirty pages.  Do not do the</span>
00315         <span class="comment">//  divide if there is not enough dirty pages, or else we will never write</span>
00316         <span class="comment">//  the last few pages.</span>
00317         <span class="comment">//</span>
00318 
00319         PagesToWrite = <a class="code" href="../../d5/d2/cachedat_8c.html#a36">CcTotalDirtyPages</a>;
00320         <span class="keywordflow">if</span> (PagesToWrite &gt; <a class="code" href="../../d5/d5/cc_8h.html#a55">LAZY_WRITER_MAX_AGE_TARGET</a>) {
00321             PagesToWrite /= <a class="code" href="../../d5/d5/cc_8h.html#a55">LAZY_WRITER_MAX_AGE_TARGET</a>;
00322         }
00323 
00324         <span class="comment">//</span>
00325         <span class="comment">//  Estimate the rate of dirty pages being produced in the foreground.</span>
00326         <span class="comment">//  This is the total number of dirty pages now plus the number of dirty</span>
00327         <span class="comment">//  pages we scheduled to write last time, minus the number of dirty</span>
00328         <span class="comment">//  pages we have now.  Throw out any cases which would not produce a</span>
00329         <span class="comment">//  positive rate.</span>
00330         <span class="comment">//</span>
00331 
00332         ForegroundRate = 0;
00333 
00334         <span class="keywordflow">if</span> ((<a class="code" href="../../d5/d2/cachedat_8c.html#a36">CcTotalDirtyPages</a> + <a class="code" href="../../d5/d2/cachedat_8c.html#a33">CcPagesWrittenLastTime</a>) &gt; <a class="code" href="../../d5/d2/cachedat_8c.html#a34">CcDirtyPagesLastScan</a>) {
00335             ForegroundRate = (<a class="code" href="../../d5/d2/cachedat_8c.html#a36">CcTotalDirtyPages</a> + <a class="code" href="../../d5/d2/cachedat_8c.html#a33">CcPagesWrittenLastTime</a>) -
00336                              <a class="code" href="../../d5/d2/cachedat_8c.html#a34">CcDirtyPagesLastScan</a>;
00337         }
00338 
00339         <span class="comment">//</span>
00340         <span class="comment">//  If we estimate that we will exceed our dirty page target by the end</span>
00341         <span class="comment">//  of this interval, then we must write more.  Try to arrive on target.</span>
00342         <span class="comment">//</span>
00343 
00344         EstimatedDirtyNextInterval = <a class="code" href="../../d5/d2/cachedat_8c.html#a36">CcTotalDirtyPages</a> - PagesToWrite + ForegroundRate;
00345 
00346         <span class="keywordflow">if</span> (EstimatedDirtyNextInterval &gt; <a class="code" href="../../d5/d2/cachedat_8c.html#a31">CcDirtyPageTarget</a>) {
00347             PagesToWrite += EstimatedDirtyNextInterval - <a class="code" href="../../d5/d2/cachedat_8c.html#a31">CcDirtyPageTarget</a>;
00348         }
00349 
00350         <span class="comment">//</span>
00351         <span class="comment">//  Now save away the number of dirty pages and the number of pages we</span>
00352         <span class="comment">//  just calculated to write.</span>
00353         <span class="comment">//</span>
00354 
00355         <a class="code" href="../../d5/d2/cachedat_8c.html#a34">CcDirtyPagesLastScan</a> = <a class="code" href="../../d5/d2/cachedat_8c.html#a36">CcTotalDirtyPages</a>;
00356         <a class="code" href="../../d5/d2/cachedat_8c.html#a32">CcPagesYetToWrite</a> = <a class="code" href="../../d5/d2/cachedat_8c.html#a33">CcPagesWrittenLastTime</a> = PagesToWrite;
00357 
00358         <span class="comment">//</span>
00359         <span class="comment">//  Loop to flush enough Shared Cache Maps to write the number of pages</span>
00360         <span class="comment">//  we just calculated.</span>
00361         <span class="comment">//</span>
00362 
00363         SharedCacheMap = CONTAINING_RECORD( <a class="code" href="../../d5/d2/cachedat_8c.html#a3">CcLazyWriterCursor</a>.<a class="code" href="../../d1/d3/struct__SHARED__CACHE__MAP__LIST__CURSOR.html#o0">SharedCacheMapLinks</a>.Flink,
00364                                             <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">SHARED_CACHE_MAP</a>,
00365                                             SharedCacheMapLinks );
00366 
00367         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"Start of Lazy Writer Scan\n"</span>, 0 );
00368 
00369         <span class="comment">//</span>
00370         <span class="comment">//  Normally we would just like to visit every Cache Map once on each scan,</span>
00371         <span class="comment">//  so the scan will terminate normally when we return to FirstVisited.  But</span>
00372         <span class="comment">//  in the off chance that FirstVisited gets deleted, we are guaranteed to stop</span>
00373         <span class="comment">//  when we get back to our own listhead.</span>
00374         <span class="comment">//</span>
00375 
00376         FirstVisited = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00377         <span class="keywordflow">while</span> ((SharedCacheMap != FirstVisited) &amp;&amp;
00378                (&amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a> != &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a3">CcLazyWriterCursor</a>.<a class="code" href="../../d1/d3/struct__SHARED__CACHE__MAP__LIST__CURSOR.html#o0">SharedCacheMapLinks</a>)) {
00379 
00380             <span class="keywordflow">if</span> (FirstVisited == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00381                 FirstVisited = SharedCacheMap;
00382             }
00383 
00384             <span class="comment">//</span>
00385             <span class="comment">//  Skip the SharedCacheMap if a write behind request is</span>
00386             <span class="comment">//  already queued, write behind has been disabled, or</span>
00387             <span class="comment">//  if there is no work to do (either dirty data to be written</span>
00388             <span class="comment">//  or a delete is required).</span>
00389             <span class="comment">//</span>
00390             <span class="comment">//  Note that for streams where modified writing is disabled, we</span>
00391             <span class="comment">//  need to take out Bcbs exclusive, which serializes with foreground</span>
00392             <span class="comment">//  activity.  Therefore we use a special counter in the SharedCacheMap</span>
00393             <span class="comment">//  to only service these once every n intervals.</span>
00394             <span class="comment">//</span>
00395             <span class="comment">//  Skip temporary files unless we currently could not write as many</span>
00396             <span class="comment">//  bytes as we might charge some hapless thread for throttling.</span>
00397             <span class="comment">//</span>
00398             <span class="comment">//  When considering lazy closes, decline to work on SharedCacheMaps</span>
00399             <span class="comment">//  that would require additional IO already prohibited by our normal</span>
00400             <span class="comment">//  tests.</span>
00401             <span class="comment">//</span>
00402 
00403             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, <a class="code" href="../../d5/d5/cc_8h.html#a74">WRITE_QUEUED</a> | <a class="code" href="../../d5/d5/cc_8h.html#a80">IS_CURSOR</a>)
00404 
00405                     &amp;&amp;
00406 
00407                 (((PagesToWrite != 0) &amp;&amp; (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o20">DirtyPages</a> != 0) &amp;&amp;
00408                   (((++SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o33">LazyWritePassCount</a> &amp; 0xF) == 0) ||
00409                    !<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, <a class="code" href="../../d5/d5/cc_8h.html#a78">MODIFIED_WRITE_DISABLED</a>) ||
00410                    (<a class="code" href="../../d5/d2/cachedat_8c.html#a37">CcCapturedSystemSize</a> == <a class="code" href="../../d2/d1/mm_8h.html#a343a165">MmSmallSystem</a>) ||
00411                    (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o20">DirtyPages</a> &gt;= (4 * (<a class="code" href="../../d5/d5/cc_8h.html#a33">MAX_WRITE_BEHIND</a> / <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>)))) &amp;&amp;
00412                   (!<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o10">FileObject</a>-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a>, <a class="code" href="../../d0/d5/io_8h.html#a165">FO_TEMPORARY_FILE</a>) ||
00413                    !<a class="code" href="../../d4/d2/cache_8h.html#a72">CcCanIWrite</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o10">FileObject</a>, <a class="code" href="../../d5/d5/cc_8h.html#a34">WRITE_CHARGE_THRESHOLD</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, MAXUCHAR)))
00414 
00415                     ||
00416 
00417                  ((SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o2">OpenCount</a> == 0) &amp;&amp;
00418                   ((SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o20">DirtyPages</a> == 0) ||
00419                    (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o3">FileSize</a>.QuadPart == 0))))) {
00420 
00421                 <a class="code" href="../../d2/d9/struct__WORK__QUEUE__ENTRY.html">PWORK_QUEUE_ENTRY</a> WorkQueueEntry;
00422 
00423                 <span class="comment">//</span>
00424                 <span class="comment">//  If this is a metadata stream with at least 4 times</span>
00425                 <span class="comment">//  the maximum write behind I/O size, then let's tell</span>
00426                 <span class="comment">//  this guy to write 1/8 of his dirty data on this pass</span>
00427                 <span class="comment">//  so it doesn't build up.</span>
00428                 <span class="comment">//</span>
00429                 <span class="comment">//  Else assume we can write everything (PagesToWrite only affects</span>
00430                 <span class="comment">//  metadata streams - otherwise writing is controlled by the Mbcb).</span>
00431                 <span class="comment">//</span>
00432 
00433                 SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o25">PagesToWrite</a> = SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o20">DirtyPages</a>;
00434 
00435                 <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, <a class="code" href="../../d5/d5/cc_8h.html#a78">MODIFIED_WRITE_DISABLED</a>) &amp;&amp;
00436                     (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o25">PagesToWrite</a> &gt;= (4 * (<a class="code" href="../../d5/d5/cc_8h.html#a33">MAX_WRITE_BEHIND</a> / <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>))) &amp;&amp;
00437                     (<a class="code" href="../../d5/d2/cachedat_8c.html#a37">CcCapturedSystemSize</a> != <a class="code" href="../../d2/d1/mm_8h.html#a343a165">MmSmallSystem</a>)) {
00438 
00439                     SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o25">PagesToWrite</a> /= 8;
00440                 }
00441 
00442                 <span class="comment">//</span>
00443                 <span class="comment">//  If still searching for pages to write, adjust our targets.</span>
00444                 <span class="comment">//</span>
00445 
00446                 <span class="keywordflow">if</span> (!AlreadyMoved) {
00447 
00448                     <span class="comment">//</span>
00449                     <span class="comment">//  See if he exhausts the number of pages to write.  (We</span>
00450                     <span class="comment">//  keep going in case there are any closes to do.)</span>
00451                     <span class="comment">//</span>
00452 
00453                     <span class="keywordflow">if</span> (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o25">PagesToWrite</a> &gt;= PagesToWrite) {
00454 
00455                         <span class="comment">//</span>
00456                         <span class="comment">//  If we met our write quota on a given SharedCacheMap, then make sure</span>
00457                         <span class="comment">//  we start at him on the next scan, unless it is a metadata stream.</span>
00458                         <span class="comment">//</span>
00459 
00460                         RemoveEntryList( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a3">CcLazyWriterCursor</a>.<a class="code" href="../../d1/d3/struct__SHARED__CACHE__MAP__LIST__CURSOR.html#o0">SharedCacheMapLinks</a> );
00461 
00462                         <span class="comment">//</span>
00463                         <span class="comment">//  For Metadata streams, set up to resume on the next stream on the</span>
00464                         <span class="comment">//  next scan.</span>
00465                         <span class="comment">//</span>
00466 
00467                         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, <a class="code" href="../../d5/d5/cc_8h.html#a78">MODIFIED_WRITE_DISABLED</a>)) {
00468                             InsertHeadList( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a>, &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a3">CcLazyWriterCursor</a>.<a class="code" href="../../d1/d3/struct__SHARED__CACHE__MAP__LIST__CURSOR.html#o0">SharedCacheMapLinks</a> );
00469 
00470                             <span class="comment">//</span>
00471                             <span class="comment">//  For other streams, set up to resume on the same stream on the</span>
00472                             <span class="comment">//  next scan.</span>
00473                             <span class="comment">//</span>
00474 
00475                         } <span class="keywordflow">else</span> {
00476                             InsertTailList( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a>, &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a3">CcLazyWriterCursor</a>.<a class="code" href="../../d1/d3/struct__SHARED__CACHE__MAP__LIST__CURSOR.html#o0">SharedCacheMapLinks</a> );
00477                         }
00478 
00479                         PagesToWrite = 0;
00480                         AlreadyMoved = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00481 
00482                     } <span class="keywordflow">else</span> {
00483 
00484                         PagesToWrite -= SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o25">PagesToWrite</a>;
00485                     }
00486                 }
00487 
00488                 <span class="comment">//</span>
00489                 <span class="comment">//  Otherwise show we are actively writing, and keep it in the dirty</span>
00490                 <span class="comment">//  list.</span>
00491                 <span class="comment">//</span>
00492 
00493                 <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, <a class="code" href="../../d5/d5/cc_8h.html#a74">WRITE_QUEUED</a>);
00494                 SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o20">DirtyPages</a> += 1;
00495 
00496                 <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
00497 
00498                 <span class="comment">//</span>
00499                 <span class="comment">//  Queue the request to do the work to a worker thread.</span>
00500                 <span class="comment">//</span>
00501 
00502                 WorkQueueEntry = <a class="code" href="../../d5/d5/cc_8h.html#a88">CcAllocateWorkQueueEntry</a>();
00503 
00504                 <span class="comment">//</span>
00505                 <span class="comment">//  If we failed to allocate a WorkQueueEntry, things must</span>
00506                 <span class="comment">//  be in pretty bad shape.  However, all we have to do is</span>
00507                 <span class="comment">//  break out of our current loop, and try to go back and</span>
00508                 <span class="comment">//  delay a while.  Even if the current guy should have gone</span>
00509                 <span class="comment">//  away when we clear WRITE_QUEUED, we will find him again</span>
00510                 <span class="comment">//  in the LW scan.</span>
00511                 <span class="comment">//</span>
00512 
00513                 <span class="keywordflow">if</span> (WorkQueueEntry == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00514 
00515                     <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
00516                     <a class="code" href="../../d5/d5/cc_8h.html#a61">ClearFlag</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, <a class="code" href="../../d5/d5/cc_8h.html#a74">WRITE_QUEUED</a>);
00517                     SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o20">DirtyPages</a> -= 1;
00518                     <span class="keywordflow">break</span>;
00519                 }
00520 
00521                 WorkQueueEntry-&gt;<a class="code" href="../../d2/d9/struct__WORK__QUEUE__ENTRY.html#o8">Function</a> = (UCHAR)<a class="code" href="../../d5/d5/cc_8h.html#a210a168">WriteBehind</a>;
00522                 WorkQueueEntry-&gt;<a class="code" href="../../d2/d9/struct__WORK__QUEUE__ENTRY.html#o7">Parameters</a>.Write.SharedCacheMap = SharedCacheMap;
00523 
00524                 <span class="comment">//</span>
00525                 <span class="comment">//  Post it to the regular work queue.</span>
00526                 <span class="comment">//</span>
00527 
00528                 <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
00529                 SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o20">DirtyPages</a> -= 1;
00530                 <a class="code" href="../../d5/d1/lazyrite_8c.html#a8">CcPostWorkQueue</a>( WorkQueueEntry, &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a9">CcRegularWorkQueue</a> );
00531 
00532                 LoopsWithLockHeld = 0;
00533 
00534             <span class="comment">//</span>
00535             <span class="comment">//  Make sure we occassionally drop the lock.  Set WRITE_QUEUED</span>
00536             <span class="comment">//  to keep the guy from going away.</span>
00537             <span class="comment">//</span>
00538 
00539             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((++LoopsWithLockHeld &gt;= 20) &amp;&amp;
00540                        !<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, <a class="code" href="../../d5/d5/cc_8h.html#a74">WRITE_QUEUED</a> | <a class="code" href="../../d5/d5/cc_8h.html#a80">IS_CURSOR</a>)) {
00541 
00542                 <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, <a class="code" href="../../d5/d5/cc_8h.html#a74">WRITE_QUEUED</a>);
00543                 SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o20">DirtyPages</a> += 1;
00544                 <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
00545                 LoopsWithLockHeld = 0;
00546                 <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
00547                 <a class="code" href="../../d5/d5/cc_8h.html#a61">ClearFlag</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, <a class="code" href="../../d5/d5/cc_8h.html#a74">WRITE_QUEUED</a>);
00548                 SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o20">DirtyPages</a> -= 1;
00549             }
00550 
00551             <span class="comment">//</span>
00552             <span class="comment">//  Now loop back.</span>
00553             <span class="comment">//</span>
00554 
00555             SharedCacheMap =
00556                 CONTAINING_RECORD( SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a>.Flink,
00557                                    <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">SHARED_CACHE_MAP</a>,
00558                                    SharedCacheMapLinks );
00559         }
00560 
00561         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"End of Lazy Writer Scan\n"</span>, 0 );
00562 
00563         <span class="comment">//</span>
00564         <span class="comment">//  Queue up our  post tick workitems for this pass.</span>
00565         <span class="comment">//</span>
00566 
00567         <span class="keywordflow">while</span> (!IsListEmpty( &amp;PostTickWorkQueue )) {
00568 
00569             PLIST_ENTRY Entry = RemoveHeadList( &amp;PostTickWorkQueue );
00570             <a class="code" href="../../d5/d1/lazyrite_8c.html#a8">CcPostWorkQueue</a>( CONTAINING_RECORD( Entry, <a class="code" href="../../d2/d9/struct__WORK__QUEUE__ENTRY.html">WORK_QUEUE_ENTRY</a>, WorkQueueLinks ),
00571                              &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a9">CcRegularWorkQueue</a> );
00572         }
00573         
00574         <span class="comment">//</span>
00575         <span class="comment">//  Now we can release the global list and loop back, per chance to sleep.</span>
00576         <span class="comment">//</span>
00577 
00578         <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
00579 
00580         <span class="comment">//</span>
00581         <span class="comment">//  Once again we need to give the deferred writes a poke.  We can have all dirty</span>
00582         <span class="comment">//  pages on disable_write_behind files but also have an external condition that</span>
00583         <span class="comment">//  caused the cached IO to be deferred. If so, this serves as our only chance to</span>
00584         <span class="comment">//  issue it when the condition clears.</span>
00585         <span class="comment">//</span>
00586         <span class="comment">//  Case hit on ForrestF's 5gb Alpha, 1/12/99.</span>
00587         <span class="comment">//</span>
00588         
00589         <span class="keywordflow">if</span> (!IsListEmpty(&amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a29">CcDeferredWrites</a>)) {
00590             
00591             <a class="code" href="../../d5/d5/cc_8h.html#a174">CcPostDeferredWrites</a>();
00592         }
00593 
00594         <span class="comment">//</span>
00595         <span class="comment">//  Now go ahead and schedule the next scan.</span>
00596         <span class="comment">//</span>
00597 
00598         <a class="code" href="../../d5/d5/cc_8h.html#a185">CcScheduleLazyWriteScan</a>();
00599 
00600     <span class="comment">//</span>
00601     <span class="comment">//  Basically, the Lazy Writer thread should never get an exception,</span>
00602     <span class="comment">//  so we put a try-except around it that bug checks one way or the other.</span>
00603     <span class="comment">//  Better we bug check here than worry about what happens if we let one</span>
00604     <span class="comment">//  get by.</span>
00605     <span class="comment">//</span>
00606 
00607     } except( <a class="code" href="../../d5/d1/lazyrite_8c.html#a7">CcExceptionFilter</a>( GetExceptionCode() )) {
00608 
00609         <a class="code" href="../../d5/d5/cc_8h.html#a28">CcBugCheck</a>( GetExceptionCode(), 0, 0 );
00610     }
00611 }
00612 
00613 
00614 <span class="comment">//</span>
00615 <span class="comment">//  Internal support routine</span>
00616 <span class="comment">//</span>
00617 
00618 LONG
<a name="l00619"></a><a class="code" href="../../d5/d1/lazyrite_8c.html#a7">00619</a> <a class="code" href="../../d5/d1/lazyrite_8c.html#a7">CcExceptionFilter</a> (
00620     IN NTSTATUS ExceptionCode
00621     )
00622 
00623 <span class="comment">/*++</span>
00624 <span class="comment"></span>
00625 <span class="comment">Routine Description:</span>
00626 <span class="comment"></span>
00627 <span class="comment">    This is the standard exception filter for worker threads which simply</span>
00628 <span class="comment">    calls an FsRtl routine to see if an expected status is being raised.</span>
00629 <span class="comment">    If so, the exception is handled, else we bug check.</span>
00630 <span class="comment"></span>
00631 <span class="comment">Arguments:</span>
00632 <span class="comment"></span>
00633 <span class="comment">    ExceptionCode - the exception code which was raised.</span>
00634 <span class="comment"></span>
00635 <span class="comment">Return Value:</span>
00636 <span class="comment"></span>
00637 <span class="comment">    EXCEPTION_EXECUTE_HANDLER if expected, else a Bug Check occurs.</span>
00638 <span class="comment"></span>
00639 <span class="comment">--*/</span>
00640 
00641 {
00642     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(0, 0, <span class="stringliteral">"CcExceptionFilter %08lx\n"</span>, ExceptionCode);
00643 
00644     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d8/fsrtl_8h.html#a137">FsRtlIsNtstatusExpected</a>( ExceptionCode )) {
00645 
00646         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>;
00647 
00648     } <span class="keywordflow">else</span> {
00649 
00650         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a34">EXCEPTION_CONTINUE_SEARCH</a>;
00651     }
00652 }
00653 
00654 
00655 
00656 <span class="comment">//</span>
00657 <span class="comment">//  Internal support routine</span>
00658 <span class="comment">//</span>
00659 
00660 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00661 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l00662"></a><a class="code" href="../../d5/d1/lazyrite_8c.html#a8">00662</a> <a class="code" href="../../d5/d1/lazyrite_8c.html#a8">CcPostWorkQueue</a> (
00663     IN <a class="code" href="../../d2/d9/struct__WORK__QUEUE__ENTRY.html">PWORK_QUEUE_ENTRY</a> WorkQueueEntry,
00664     IN PLIST_ENTRY WorkQueue
00665     )
00666 
00667 <span class="comment">/*++</span>
00668 <span class="comment"></span>
00669 <span class="comment">Routine Description:</span>
00670 <span class="comment"></span>
00671 <span class="comment">    This routine queues a WorkQueueEntry, which has been allocated and</span>
00672 <span class="comment">    initialized by the caller, to the WorkQueue for FIFO processing by</span>
00673 <span class="comment">    the work threads.</span>
00674 <span class="comment"></span>
00675 <span class="comment">Arguments:</span>
00676 <span class="comment"></span>
00677 <span class="comment">    WorkQueueEntry - supplies a pointer to the entry to queue</span>
00678 <span class="comment"></span>
00679 <span class="comment">Return Value:</span>
00680 <span class="comment"></span>
00681 <span class="comment">    None</span>
00682 <span class="comment"></span>
00683 <span class="comment">--*/</span>
00684 
00685 {
00686     KIRQL OldIrql;
00687     PLIST_ENTRY WorkerThreadEntry = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00688 
00689     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(FIELD_OFFSET(<a class="code" href="../../d7/d9/struct__WORK__QUEUE__ITEM.html">WORK_QUEUE_ITEM</a>, <a class="code" href="../../d1/d0/cmchek_8c.html#a12">List</a>) == 0);
00690 
00691     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcPostWorkQueue:\n"</span>, 0 );
00692     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"    WorkQueueEntry = %08lx\n"</span>, WorkQueueEntry );
00693 
00694     <span class="comment">//</span>
00695     <span class="comment">//  Queue the entry to the respective work queue.</span>
00696     <span class="comment">//</span>
00697 
00698     ExAcquireFastLock( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a4">CcWorkQueueSpinlock</a>, &amp;OldIrql );
00699     InsertTailList( WorkQueue, &amp;WorkQueueEntry-&gt;WorkQueueLinks );
00700 
00701     <span class="comment">//</span>
00702     <span class="comment">//  Now, if we aren't throttled and have any more idle threads we can</span>
00703     <span class="comment">//  use, activate one.</span>
00704     <span class="comment">//</span>
00705 
00706     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d2/cachedat_8c.html#a11">CcQueueThrottle</a> &amp;&amp; !IsListEmpty(&amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a7">CcIdleWorkerThreadList</a>)) {
00707         WorkerThreadEntry = RemoveHeadList( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a7">CcIdleWorkerThreadList</a> );
00708         <a class="code" href="../../d5/d2/cachedat_8c.html#a6">CcNumberActiveWorkerThreads</a> += 1;
00709     }
00710     ExReleaseFastLock( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a4">CcWorkQueueSpinlock</a>, OldIrql );
00711 
00712     <span class="keywordflow">if</span> (WorkerThreadEntry != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00713 
00714         <span class="comment">//</span>
00715         <span class="comment">//  I had to peak in the sources to verify that this routine</span>
00716         <span class="comment">//  is a noop if the Flink is not NULL.  Sheeeeit!</span>
00717         <span class="comment">//</span>
00718 
00719         ((<a class="code" href="../../d7/d9/struct__WORK__QUEUE__ITEM.html">PWORK_QUEUE_ITEM</a>)WorkerThreadEntry)-&gt;List.Flink = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00720         <a class="code" href="../../d5/d8/ex_8h.html#a261">ExQueueWorkItem</a>( (<a class="code" href="../../d7/d9/struct__WORK__QUEUE__ITEM.html">PWORK_QUEUE_ITEM</a>)WorkerThreadEntry, <a class="code" href="../../d5/d8/ex_8h.html#a332a205">CriticalWorkQueue</a> );
00721     }
00722 
00723     <span class="comment">//</span>
00724     <span class="comment">//  And return to our caller</span>
00725     <span class="comment">//</span>
00726 
00727     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcPostWorkQueue -&gt; VOID\n"</span>, 0 );
00728 
00729     <span class="keywordflow">return</span>;
00730 }
00731 
00732 
00733 <span class="comment">//</span>
00734 <span class="comment">//  Internal support routine</span>
00735 <span class="comment">//</span>
00736 
00737 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00738"></a><a class="code" href="../../d5/d1/lazyrite_8c.html#a9">00738</a> <a class="code" href="../../d5/d1/lazyrite_8c.html#a9">CcWorkerThread</a> (
00739     PVOID ExWorkQueueItem
00740     )
00741 
00742 <span class="comment">/*++</span>
00743 <span class="comment"></span>
00744 <span class="comment">Routine Description:</span>
00745 <span class="comment"></span>
00746 <span class="comment">    This is worker thread routine for processing cache manager work queue</span>
00747 <span class="comment">    entries.</span>
00748 <span class="comment"></span>
00749 <span class="comment">Arguments:</span>
00750 <span class="comment"></span>
00751 <span class="comment">    ExWorkQueueItem - The work item used for this thread</span>
00752 <span class="comment"></span>
00753 <span class="comment">Return Value:</span>
00754 <span class="comment"></span>
00755 <span class="comment">    None</span>
00756 <span class="comment"></span>
00757 <span class="comment">--*/</span>
00758 
00759 {
00760     KIRQL OldIrql;
00761     PLIST_ENTRY WorkQueue;
00762     <a class="code" href="../../d2/d9/struct__WORK__QUEUE__ENTRY.html">PWORK_QUEUE_ENTRY</a> WorkQueueEntry;
00763     BOOLEAN RescanOk = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00764     BOOLEAN DropThrottle = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00765     IO_STATUS_BLOCK IoStatus;
00766 
00767     IoStatus.Status = STATUS_SUCCESS;
00768     IoStatus.Information = 0;
00769 
00770     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(FIELD_OFFSET(<a class="code" href="../../d2/d9/struct__WORK__QUEUE__ENTRY.html">WORK_QUEUE_ENTRY</a>, WorkQueueLinks) == 0);
00771 
00772     <span class="keywordflow">while</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
00773 
00774         ExAcquireFastLock( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a4">CcWorkQueueSpinlock</a>, &amp;OldIrql );
00775 
00776         <span class="comment">//</span>
00777         <span class="comment">//  If we just processed a throttled operation, drop the flag.</span>
00778         <span class="comment">//</span>
00779 
00780         <span class="keywordflow">if</span> (DropThrottle) {
00781 
00782             DropThrottle = <a class="code" href="../../d5/d2/cachedat_8c.html#a11">CcQueueThrottle</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00783         }
00784 
00785         <span class="comment">//</span>
00786         <span class="comment">//  On requeue, push at end of the regular queue and clear hint.</span>
00787         <span class="comment">//</span>
00788         
00789         <span class="keywordflow">if</span> (IoStatus.Information == <a class="code" href="../../d5/d5/cc_8h.html#a56">CC_REQUEUE</a>) {
00790 
00791             InsertTailList( WorkQueue, &amp;WorkQueueEntry-&gt;<a class="code" href="../../d2/d9/struct__WORK__QUEUE__ENTRY.html#o0">WorkQueueLinks</a> );
00792             IoStatus.Information = 0;
00793         }
00794         
00795         <span class="comment">//</span>
00796         <span class="comment">//  First see if there is something in the express queue.</span>
00797         <span class="comment">//</span>
00798 
00799         <span class="keywordflow">if</span> (!IsListEmpty(&amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a8">CcExpressWorkQueue</a>)) {
00800             WorkQueue = &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a8">CcExpressWorkQueue</a>;
00801 
00802         <span class="comment">//</span>
00803         <span class="comment">//  If there was nothing there, then try the regular queue.</span>
00804         <span class="comment">//</span>
00805 
00806         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!IsListEmpty(&amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a9">CcRegularWorkQueue</a>)) {
00807             WorkQueue = &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a9">CcRegularWorkQueue</a>;
00808 
00809         <span class="comment">//</span>
00810         <span class="comment">//  Else we can break and go idle.</span>
00811         <span class="comment">//</span>
00812         
00813         } <span class="keywordflow">else</span> {
00814 
00815             <span class="keywordflow">break</span>;
00816         }
00817 
00818         WorkQueueEntry = CONTAINING_RECORD( WorkQueue-&gt;Flink, <a class="code" href="../../d2/d9/struct__WORK__QUEUE__ENTRY.html">WORK_QUEUE_ENTRY</a>, WorkQueueLinks );
00819 
00820         <span class="comment">//</span>
00821         <span class="comment">//  If this is an EventSet, throttle down to a single thread to be sure</span>
00822         <span class="comment">//  that this event fires after all preceeding workitems have completed.</span>
00823         <span class="comment">//</span>
00824 
00825         <span class="keywordflow">if</span> (WorkQueueEntry-&gt;<a class="code" href="../../d2/d9/struct__WORK__QUEUE__ENTRY.html#o8">Function</a> == <a class="code" href="../../d5/d5/cc_8h.html#a210a170">EventSet</a> &amp;&amp; <a class="code" href="../../d5/d2/cachedat_8c.html#a6">CcNumberActiveWorkerThreads</a> &gt; 1) {
00826 
00827             <a class="code" href="../../d5/d2/cachedat_8c.html#a11">CcQueueThrottle</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00828             <span class="keywordflow">break</span>;
00829         }
00830 
00831         <span class="comment">//</span>
00832         <span class="comment">//  Pop the workitem off: we will execute it now.</span>
00833         <span class="comment">//</span>
00834 
00835         RemoveHeadList( WorkQueue );
00836 
00837         ExReleaseFastLock( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a4">CcWorkQueueSpinlock</a>, OldIrql );
00838 
00839         <span class="comment">//</span>
00840         <span class="comment">//  Process the entry within a try-except clause, so that any errors</span>
00841         <span class="comment">//  will cause us to continue after the called routine has unwound.</span>
00842         <span class="comment">//</span>
00843 
00844         <span class="keywordflow">try</span> {
00845 
00846             <span class="keywordflow">switch</span> (WorkQueueEntry-&gt;<a class="code" href="../../d2/d9/struct__WORK__QUEUE__ENTRY.html#o8">Function</a>) {
00847 
00848             <span class="comment">//</span>
00849             <span class="comment">//  Perform read ahead</span>
00850             <span class="comment">//</span>
00851 
00852             <span class="keywordflow">case</span> <a class="code" href="../../d5/d5/cc_8h.html#a210a167">ReadAhead</a>:
00853 
00854                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcWorkerThread Read Ahead FileObject = %08lx\n"</span>,
00855                             WorkQueueEntry-&gt;<a class="code" href="../../d2/d9/struct__WORK__QUEUE__ENTRY.html#o7">Parameters</a>.Read.FileObject );
00856 
00857                 <a class="code" href="../../d5/d5/cc_8h.html#a178">CcPerformReadAhead</a>( WorkQueueEntry-&gt;<a class="code" href="../../d2/d9/struct__WORK__QUEUE__ENTRY.html#o7">Parameters</a>.Read.FileObject );
00858 
00859                 <span class="keywordflow">break</span>;
00860 
00861             <span class="comment">//</span>
00862             <span class="comment">//  Perform write behind</span>
00863             <span class="comment">//</span>
00864 
00865             <span class="keywordflow">case</span> <a class="code" href="../../d5/d5/cc_8h.html#a210a168">WriteBehind</a>:
00866 
00867                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcWorkerThread WriteBehind SharedCacheMap = %08lx\n"</span>,
00868                             WorkQueueEntry-&gt;<a class="code" href="../../d2/d9/struct__WORK__QUEUE__ENTRY.html#o7">Parameters</a>.Write.SharedCacheMap );
00869 
00870                 <a class="code" href="../../d5/d5/cc_8h.html#a180">CcWriteBehind</a>( WorkQueueEntry-&gt;<a class="code" href="../../d2/d9/struct__WORK__QUEUE__ENTRY.html#o7">Parameters</a>.Write.SharedCacheMap, &amp;IoStatus );
00871                 RescanOk = (BOOLEAN)<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(IoStatus.Status);
00872                 <span class="keywordflow">break</span>;
00873 
00874             
00875             <span class="comment">//</span>
00876             <span class="comment">//  Perform set event</span>
00877             <span class="comment">//</span>
00878             
00879             <span class="keywordflow">case</span> <a class="code" href="../../d5/d5/cc_8h.html#a210a170">EventSet</a>:
00880                 
00881                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcWorkerThread SetEvent Event = %08lx\n"</span>,
00882                             WorkQueueEntry-&gt;<a class="code" href="../../d2/d9/struct__WORK__QUEUE__ENTRY.html#o7">Parameters</a>.Event.Event );
00883 
00884                 <a class="code" href="../../d2/d8/eventobj_8c.html#a8">KeSetEvent</a>( WorkQueueEntry-&gt;<a class="code" href="../../d2/d9/struct__WORK__QUEUE__ENTRY.html#o7">Parameters</a>.Event.Event, 0, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00885                 DropThrottle = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00886                 <span class="keywordflow">break</span>;
00887 
00888             <span class="comment">//</span>
00889             <span class="comment">//  Perform Lazy Write Scan</span>
00890             <span class="comment">//</span>
00891 
00892             <span class="keywordflow">case</span> <a class="code" href="../../d5/d5/cc_8h.html#a210a169">LazyWriteScan</a>:
00893 
00894                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcWorkerThread Lazy Write Scan\n"</span>, 0 );
00895 
00896                 <a class="code" href="../../d5/d1/lazyrite_8c.html#a3">CcLazyWriteScan</a>();
00897                 <span class="keywordflow">break</span>;
00898             }
00899 
00900         }
00901         except( <a class="code" href="../../d5/d1/lazyrite_8c.html#a7">CcExceptionFilter</a>( GetExceptionCode() )) {
00902 
00903             NOTHING;
00904         }
00905 
00906         <span class="comment">//</span>
00907         <span class="comment">//  If not a requeue request, free the workitem.</span>
00908         <span class="comment">//</span>
00909         
00910         <span class="keywordflow">if</span> (IoStatus.Information != <a class="code" href="../../d5/d5/cc_8h.html#a56">CC_REQUEUE</a>) {
00911             
00912             <a class="code" href="../../d5/d5/cc_8h.html#a89">CcFreeWorkQueueEntry</a>( WorkQueueEntry );
00913         }
00914     }
00915 
00916     <span class="comment">//</span>
00917     <span class="comment">//  No more work.  Requeue our worker thread entry and get out.</span>
00918     <span class="comment">//</span>
00919 
00920     InsertTailList( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a7">CcIdleWorkerThreadList</a>,
00921                     &amp;((<a class="code" href="../../d7/d9/struct__WORK__QUEUE__ITEM.html">PWORK_QUEUE_ITEM</a>)ExWorkQueueItem)-&gt;<a class="code" href="../../d1/d0/cmchek_8c.html#a12">List</a> );
00922     <a class="code" href="../../d5/d2/cachedat_8c.html#a6">CcNumberActiveWorkerThreads</a> -= 1;
00923 
00924     ExReleaseFastLock( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a4">CcWorkQueueSpinlock</a>, OldIrql );
00925 
00926     <span class="keywordflow">if</span> (!IsListEmpty(&amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a29">CcDeferredWrites</a>) &amp;&amp; (<a class="code" href="../../d5/d2/cachedat_8c.html#a36">CcTotalDirtyPages</a> &gt;= 20) &amp;&amp; RescanOk) {
00927         <a class="code" href="../../d5/d1/lazyrite_8c.html#a3">CcLazyWriteScan</a>();
00928     }
00929 
00930     <span class="keywordflow">return</span>;
00931 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:40:36 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
