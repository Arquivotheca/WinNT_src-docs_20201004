<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: fssup.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>fssup.c</h1><a href="../../d5/d8/fssup_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1990  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    fssup.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module implements the File System support routines for the</span>
00012 <span class="comment">    Cache subsystem.</span>
00013 <span class="comment"></span>
00014 <span class="comment">Author:</span>
00015 <span class="comment"></span>
00016 <span class="comment">    Tom Miller      [TomM]      4-May-1990</span>
00017 <span class="comment"></span>
00018 <span class="comment">Revision History:</span>
00019 <span class="comment"></span>
00020 <span class="comment">--*/</span>
00021 
00022 <span class="preprocessor">#include "<a class="code" href="../../d5/d5/cc_8h.html">cc.h</a>"</span>
00023 
00024 <span class="comment">//</span>
00025 <span class="comment">//  The Bug check file id for this module</span>
00026 <span class="comment">//</span>
00027 
<a name="l00028"></a><a class="code" href="../../d5/d8/fssup_8c.html#a0">00028</a> <span class="preprocessor">#define BugCheckFileId                   (CACHE_BUG_CHECK_FSSUP)</span>
00029 <span class="preprocessor"></span>
00030 <span class="comment">//</span>
00031 <span class="comment">//  Define our debug constant</span>
00032 <span class="comment">//</span>
00033 
<a name="l00034"></a><a class="code" href="../../d5/d8/fssup_8c.html#a1">00034</a> <span class="preprocessor">#define me 0x00000001</span>
00035 <span class="preprocessor"></span>
00036 <span class="comment">//</span>
00037 <span class="comment">//  For your debugging pleasure, if the flag doesn't move!  (Currently not used)</span>
00038 <span class="comment">//</span>
00039 
<a name="l00040"></a><a class="code" href="../../d5/d8/fssup_8c.html#a2">00040</a> <span class="preprocessor">#define IsSyscacheFile(FO) (((FO) != NULL) &amp;&amp;                                               \</span>
00041 <span class="preprocessor">                            (*(PUSHORT)(FO)-&gt;FsContext == 0X705) &amp;&amp;                         \</span>
00042 <span class="preprocessor">                            FlagOn(*(PULONG)((PCHAR)(FO)-&gt;FsContext + 0x48), 0x80000000))</span>
00043 <span class="preprocessor"></span>
<a name="l00044"></a><a class="code" href="../../d5/d8/fssup_8c.html#a3">00044</a> <span class="keyword">extern</span> <a class="code" href="../../d3/d6/struct__OBJECT__TYPE.html">POBJECT_TYPE</a> <a class="code" href="../../d5/d8/fssup_8c.html#a3">IoFileObjectType</a>;
<a name="l00045"></a><a class="code" href="../../d5/d8/fssup_8c.html#a4">00045</a> <span class="keyword">extern</span> ULONG <a class="code" href="../../d5/d8/fssup_8c.html#a4">MmLargeSystemCache</a>;
00046 
00047 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00048 <a class="code" href="../../d5/d8/fssup_8c.html#a5">CcUnmapAndPurge</a>(
00049     IN <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap
00050     );
00051 
00052 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00053 <a class="code" href="../../d5/d8/fssup_8c.html#a6">CcDeleteMbcb</a>(
00054     IN <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap
00055     );
00056 
00057 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00058 <a class="code" href="../../d5/d8/fssup_8c.html#a7">CcPurgeAndClearCacheSection</a> (
00059     IN <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap,
00060     IN PLARGE_INTEGER FileOffset
00061     );
00062 
00063 <span class="preprocessor">#ifdef ALLOC_PRAGMA</span>
00064 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(INIT,CcInitializeCacheManager)</span>
00065 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00066 <span class="preprocessor"></span>
00067 
00068 BOOLEAN
<a name="l00069"></a><a class="code" href="../../d4/d2/cache_8h.html#a57">00069</a> <a class="code" href="../../d5/d8/fssup_8c.html#a8">CcInitializeCacheManager</a> (
00070     )
00071 
00072 <span class="comment">/*++</span>
00073 <span class="comment"></span>
00074 <span class="comment">Routine Description:</span>
00075 <span class="comment"></span>
00076 <span class="comment">    This routine must be called during system initialization before the</span>
00077 <span class="comment">    first call to any file system, to allow the Cache Manager to initialize</span>
00078 <span class="comment">    its global data structures.  This routine has no dependencies on other</span>
00079 <span class="comment">    system components being initialized.</span>
00080 <span class="comment"></span>
00081 <span class="comment">Arguments:</span>
00082 <span class="comment"></span>
00083 <span class="comment">    None</span>
00084 <span class="comment"></span>
00085 <span class="comment">Return Value:</span>
00086 <span class="comment"></span>
00087 <span class="comment">    TRUE if initialization was successful</span>
00088 <span class="comment"></span>
00089 <span class="comment">--*/</span>
00090 
00091 {
00092     CLONG i;
00093     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
00094     <a class="code" href="../../d1/d4/struct__NPAGED__LOOKASIDE__LIST.html">PNPAGED_LOOKASIDE_LIST</a> Lookaside;
00095     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> NumberOfItems;
00096     PKPRCB Prcb;
00097     <a class="code" href="../../d7/d9/struct__WORK__QUEUE__ITEM.html">PWORK_QUEUE_ITEM</a> WorkItem;
00098 
00099 <span class="preprocessor">#ifdef CCDBG_LOCK</span>
00100 <span class="preprocessor"></span>    <a class="code" href="../../d4/d9/ke_8h.html#a354">KeInitializeSpinLock</a>( &amp;<a class="code" href="../../d4/d4/alpha_2splocks_8c.html#a2">CcDebugTraceLock</a> );
00101 <span class="preprocessor">#endif</span>
00102 <span class="preprocessor"></span>
00103 <span class="preprocessor">#if DBG</span>
00104 <span class="preprocessor"></span>    CcBcbCount = 0;
00105     InitializeListHead( &amp;CcBcbList );
00106     <a class="code" href="../../d4/d9/ke_8h.html#a354">KeInitializeSpinLock</a>( &amp;<a class="code" href="../../d5/d5/cc_8h.html#a122">CcBcbSpinLock</a> );
00107 <span class="preprocessor">#endif</span>
00108 <span class="preprocessor"></span>
00109     <span class="comment">//</span>
00110     <span class="comment">//  Figure out the timeout clock tick for the lazy writer.</span>
00111     <span class="comment">//</span>
00112 
00113     <a class="code" href="../../d5/d2/cachedat_8c.html#a12">CcIdleDelayTick</a> = <a class="code" href="../../d5/d5/cc_8h.html#a53">LAZY_WRITER_IDLE_DELAY</a> / <a class="code" href="../../d7/d0/ke_2miscc_8c.html#a5">KeQueryTimeIncrement</a>();
00114     
00115     <span class="comment">//</span>
00116     <span class="comment">//  Initialize shared cache map list structures</span>
00117     <span class="comment">//</span>
00118 
00119     <a class="code" href="../../d4/d9/ke_8h.html#a354">KeInitializeSpinLock</a>( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a0">CcMasterSpinLock</a> );
00120     InitializeListHead( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a1">CcCleanSharedCacheMapList</a> );
00121     InitializeListHead( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a2">CcDirtySharedCacheMapList</a>.<a class="code" href="../../d1/d3/struct__SHARED__CACHE__MAP__LIST__CURSOR.html#o0">SharedCacheMapLinks</a> );
00122     <a class="code" href="../../d5/d2/cachedat_8c.html#a2">CcDirtySharedCacheMapList</a>.<a class="code" href="../../d1/d3/struct__SHARED__CACHE__MAP__LIST__CURSOR.html#o1">Flags</a> = <a class="code" href="../../d5/d5/cc_8h.html#a80">IS_CURSOR</a>;
00123     InsertTailList( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a2">CcDirtySharedCacheMapList</a>.<a class="code" href="../../d1/d3/struct__SHARED__CACHE__MAP__LIST__CURSOR.html#o0">SharedCacheMapLinks</a>,
00124                     &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a3">CcLazyWriterCursor</a>.<a class="code" href="../../d1/d3/struct__SHARED__CACHE__MAP__LIST__CURSOR.html#o0">SharedCacheMapLinks</a> );
00125     <a class="code" href="../../d5/d2/cachedat_8c.html#a3">CcLazyWriterCursor</a>.<a class="code" href="../../d1/d3/struct__SHARED__CACHE__MAP__LIST__CURSOR.html#o1">Flags</a> = <a class="code" href="../../d5/d5/cc_8h.html#a80">IS_CURSOR</a>;
00126 
00127     <span class="comment">//</span>
00128     <span class="comment">//  Initialize worker thread structures</span>
00129     <span class="comment">//</span>
00130 
00131     <a class="code" href="../../d4/d9/ke_8h.html#a354">KeInitializeSpinLock</a>( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a4">CcWorkQueueSpinlock</a> );
00132     InitializeListHead( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a7">CcIdleWorkerThreadList</a> );
00133     InitializeListHead( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a8">CcExpressWorkQueue</a> );
00134     InitializeListHead( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a9">CcRegularWorkQueue</a> );
00135     InitializeListHead( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a10">CcPostTickWorkQueue</a> );
00136 
00137     <span class="comment">//</span>
00138     <span class="comment">//  Set the number of worker threads based on the system size.</span>
00139     <span class="comment">//</span>
00140 
00141     <a class="code" href="../../d5/d2/cachedat_8c.html#a37">CcCapturedSystemSize</a> = <a class="code" href="../../d5/d1/mminit_8c.html#a57">MmQuerySystemSize</a>();
00142     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d2/cachedat_8c.html#a5">CcNumberWorkerThreads</a> == 0) {
00143 
00144         <span class="keywordflow">switch</span> (<a class="code" href="../../d5/d2/cachedat_8c.html#a37">CcCapturedSystemSize</a>) {
00145         <span class="keywordflow">case</span> <a class="code" href="../../d2/d1/mm_8h.html#a343a165">MmSmallSystem</a>:
00146             <a class="code" href="../../d5/d2/cachedat_8c.html#a5">CcNumberWorkerThreads</a> = <a class="code" href="../../d1/d9/worker_8c.html#a15">ExCriticalWorkerThreads</a> - 1;
00147             <a class="code" href="../../d5/d2/cachedat_8c.html#a30">CcDirtyPageThreshold</a> = <a class="code" href="../../d2/d1/mm_8h.html#a136">MmNumberOfPhysicalPages</a> / 8;
00148             <a class="code" href="../../d5/d2/cachedat_8c.html#a39">CcAggressiveZeroThreshold</a> = 1;
00149             <span class="keywordflow">break</span>;
00150 
00151         <span class="keywordflow">case</span> <a class="code" href="../../d2/d1/mm_8h.html#a343a166">MmMediumSystem</a>:
00152             <a class="code" href="../../d5/d2/cachedat_8c.html#a5">CcNumberWorkerThreads</a> = <a class="code" href="../../d1/d9/worker_8c.html#a15">ExCriticalWorkerThreads</a> - 1;
00153             <a class="code" href="../../d5/d2/cachedat_8c.html#a30">CcDirtyPageThreshold</a> = <a class="code" href="../../d2/d1/mm_8h.html#a136">MmNumberOfPhysicalPages</a> / 4;
00154             <a class="code" href="../../d5/d2/cachedat_8c.html#a39">CcAggressiveZeroThreshold</a> = 2;
00155             <span class="keywordflow">break</span>;
00156 
00157         <span class="keywordflow">case</span> <a class="code" href="../../d2/d1/mm_8h.html#a343a167">MmLargeSystem</a>:
00158             <a class="code" href="../../d5/d2/cachedat_8c.html#a5">CcNumberWorkerThreads</a> = <a class="code" href="../../d1/d9/worker_8c.html#a15">ExCriticalWorkerThreads</a> - 2;
00159             <a class="code" href="../../d5/d2/cachedat_8c.html#a30">CcDirtyPageThreshold</a> = <a class="code" href="../../d2/d1/mm_8h.html#a136">MmNumberOfPhysicalPages</a> / 4 +
00160                                     <a class="code" href="../../d2/d1/mm_8h.html#a136">MmNumberOfPhysicalPages</a> / 8;
00161             <a class="code" href="../../d5/d2/cachedat_8c.html#a39">CcAggressiveZeroThreshold</a> = 4;
00162 <span class="preprocessor">#if 0</span>
00163 <span class="preprocessor"></span>            <span class="comment">//</span>
00164             <span class="comment">//  Use more memory if we are a large server.</span>
00165             <span class="comment">//</span>
00166 
00167             <span class="keywordflow">if</span> ((<a class="code" href="../../d5/d8/fssup_8c.html#a4">MmLargeSystemCache</a> != 0) &amp;&amp;
00168                 (<a class="code" href="../../d5/d2/cachedat_8c.html#a30">CcDirtyPageThreshold</a> &lt; (<a class="code" href="../../d2/d1/mm_8h.html#a136">MmNumberOfPhysicalPages</a> - (0xE00000 / <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>)))) {
00169 
00170                 <a class="code" href="../../d5/d2/cachedat_8c.html#a30">CcDirtyPageThreshold</a> = <a class="code" href="../../d2/d1/mm_8h.html#a136">MmNumberOfPhysicalPages</a> - (0xE00000 / <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
00171             }
00172 <span class="preprocessor">#endif</span>
00173 <span class="preprocessor"></span>            <span class="keywordflow">break</span>;
00174 
00175         <span class="keywordflow">default</span>:
00176             <a class="code" href="../../d5/d2/cachedat_8c.html#a5">CcNumberWorkerThreads</a> = 1;
00177             <a class="code" href="../../d5/d2/cachedat_8c.html#a30">CcDirtyPageThreshold</a> = <a class="code" href="../../d2/d1/mm_8h.html#a136">MmNumberOfPhysicalPages</a> / 8;
00178         }
00179 
00180 <span class="comment">//        CcDirtyPageThreshold = (2*1024*1024)/PAGE_SIZE;</span>
00181 
00182         <span class="keywordflow">if</span> (<a class="code" href="../../d6/d8/sysinfo_8c.html#a21">MmSystemCacheWs</a>.<a class="code" href="../../d3/d6/struct__MMSUPPORT.html#o6">MaximumWorkingSetSize</a> &gt; ((4*1024*1024)/<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>)) {
00183             <a class="code" href="../../d5/d2/cachedat_8c.html#a30">CcDirtyPageThreshold</a> = <a class="code" href="../../d6/d8/sysinfo_8c.html#a21">MmSystemCacheWs</a>.<a class="code" href="../../d3/d6/struct__MMSUPPORT.html#o6">MaximumWorkingSetSize</a> -
00184                                                     ((2*1024*1024)/<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
00185         }
00186 
00187         <a class="code" href="../../d5/d2/cachedat_8c.html#a31">CcDirtyPageTarget</a> = <a class="code" href="../../d5/d2/cachedat_8c.html#a30">CcDirtyPageThreshold</a> / 2 +
00188                             <a class="code" href="../../d5/d2/cachedat_8c.html#a30">CcDirtyPageThreshold</a> / 4;
00189     }
00190 
00191     <a class="code" href="../../d5/d2/cachedat_8c.html#a38">CcAggressiveZeroCount</a> = 0;
00192 
00193     <span class="comment">//</span>
00194     <span class="comment">//  Now allocate and initialize the above number of worker thread</span>
00195     <span class="comment">//  items.</span>
00196     <span class="comment">//</span>
00197 
00198     <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="../../d5/d2/cachedat_8c.html#a5">CcNumberWorkerThreads</a>; i++) {
00199 
00200         WorkItem = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, <span class="keyword">sizeof</span>(<a class="code" href="../../d7/d9/struct__WORK__QUEUE__ITEM.html">WORK_QUEUE_ITEM</a>), 'qWcC' );
00201 
00202         <span class="keywordflow">if</span> (WorkItem == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00203             
00204             <a class="code" href="../../d5/d5/cc_8h.html#a28">CcBugCheck</a>( 0, 0, 0 );
00205         }
00206 
00207         <span class="comment">//</span>
00208         <span class="comment">//  Initialize the work queue item and insert in our queue</span>
00209         <span class="comment">//  of potential worker threads.</span>
00210         <span class="comment">//</span>
00211 
00212         <a class="code" href="../../d5/d8/ex_8h.html#a55">ExInitializeWorkItem</a>( WorkItem, <a class="code" href="../../d5/d5/cc_8h.html#a188">CcWorkerThread</a>, WorkItem );
00213         InsertTailList( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a7">CcIdleWorkerThreadList</a>, &amp;WorkItem-&gt;<a class="code" href="../../d7/d9/struct__WORK__QUEUE__ITEM.html#o0">List</a> );
00214     }
00215 
00216     <span class="comment">//</span>
00217     <span class="comment">//  Initialize the Lazy Writer thread structure, and start him up.</span>
00218     <span class="comment">//</span>
00219 
00220     RtlZeroMemory( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>, <span class="keyword">sizeof</span>(<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html">LAZY_WRITER</a>) );
00221 
00222     <a class="code" href="../../d4/d9/ke_8h.html#a354">KeInitializeSpinLock</a>( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a4">CcWorkQueueSpinlock</a> );
00223     InitializeListHead( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o1">WorkQueue</a> );
00224 
00225     <span class="comment">//</span>
00226     <span class="comment">//  Store process address</span>
00227     <span class="comment">//</span>
00228 
00229     <a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o0">OurProcess</a> = <a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a>();
00230 
00231     <span class="comment">//</span>
00232     <span class="comment">//  Initialize the Scan Dpc and Timer.</span>
00233     <span class="comment">//</span>
00234 
00235     <a class="code" href="../../d4/d1/dpcobj_8c.html#a1">KeInitializeDpc</a>( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o3">ScanDpc</a>, &amp;<a class="code" href="../../d5/d5/cc_8h.html#a184">CcScanDpc</a>, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00236     <a class="code" href="../../d3/d2/timerobj_8c.html#a1">KeInitializeTimer</a>( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o4">ScanTimer</a> );
00237 
00238     <span class="comment">//</span>
00239     <span class="comment">//  Now initialize the lookaside list for allocating Work Queue entries.</span>
00240     <span class="comment">//</span>
00241 
00242     <span class="keywordflow">switch</span> ( <a class="code" href="../../d5/d2/cachedat_8c.html#a37">CcCapturedSystemSize</a> ) {
00243 
00244         <span class="comment">//</span>
00245         <span class="comment">// ~512 bytes</span>
00246         <span class="comment">//</span>
00247 
00248     <span class="keywordflow">case</span> <a class="code" href="../../d2/d1/mm_8h.html#a343a165">MmSmallSystem</a> :
00249         NumberOfItems = 32;
00250         <span class="keywordflow">break</span>;
00251 
00252         <span class="comment">//</span>
00253         <span class="comment">// ~1k bytes</span>
00254         <span class="comment">//</span>
00255 
00256     <span class="keywordflow">case</span> <a class="code" href="../../d2/d1/mm_8h.html#a343a166">MmMediumSystem</a> :
00257         NumberOfItems = 64;
00258         <span class="keywordflow">break</span>;
00259 
00260         <span class="comment">//</span>
00261         <span class="comment">// ~2k bytes</span>
00262         <span class="comment">//</span>
00263 
00264     <span class="keywordflow">case</span> <a class="code" href="../../d2/d1/mm_8h.html#a343a167">MmLargeSystem</a> :
00265         NumberOfItems = 128;
00266         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d1/mminit_8c.html#a58">MmIsThisAnNtAsSystem</a>()) {
00267             NumberOfItems += 128;
00268         }
00269 
00270         <span class="keywordflow">break</span>;
00271     }
00272 
00273     <a class="code" href="../../d5/d8/ex_8h.html#a246">ExInitializeNPagedLookasideList</a>( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a42">CcTwilightLookasideList</a>,
00274                                      <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00275                                      <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00276                                      0,
00277                                      <span class="keyword">sizeof</span>( <a class="code" href="../../d2/d9/struct__WORK__QUEUE__ENTRY.html">WORK_QUEUE_ENTRY</a> ),
00278                                      'kWcC',
00279                                      NumberOfItems );
00280 
00281     <span class="comment">//</span>
00282     <span class="comment">// Initialize the per processor nonpaged lookaside lists and descriptors.</span>
00283     <span class="comment">//</span>
00284 
00285     <span class="keywordflow">for</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = 0; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &lt; (ULONG)<a class="code" href="../../d4/d9/ke_8h.html#a133">KeNumberProcessors</a>; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> += 1) {
00286         Prcb = <a class="code" href="../../d4/d9/ke_8h.html#a139">KiProcessorBlock</a>[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>];
00287 
00288         <span class="comment">//</span>
00289         <span class="comment">// Initialize the large IRP per processor lookaside pointers.</span>
00290         <span class="comment">//</span>
00291 
00292         Prcb-&gt;PPLookasideList[<a class="code" href="../../d5/d8/ex_8h.html#a331a202">LookasideTwilightList</a>].L = &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a42">CcTwilightLookasideList</a>;
00293         Lookaside = (<a class="code" href="../../d1/d4/struct__NPAGED__LOOKASIDE__LIST.html">PNPAGED_LOOKASIDE_LIST</a>)<a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>,
00294                                                                    <span class="keyword">sizeof</span>(<a class="code" href="../../d1/d4/struct__NPAGED__LOOKASIDE__LIST.html">NPAGED_LOOKASIDE_LIST</a>),
00295                                                                    'KWcC');
00296 
00297         <span class="keywordflow">if</span> (Lookaside != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00298             <a class="code" href="../../d5/d8/ex_8h.html#a246">ExInitializeNPagedLookasideList</a>( Lookaside,
00299                                              <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00300                                              <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00301                                              0,
00302                                              <span class="keyword">sizeof</span>( <a class="code" href="../../d5/d5/cc_8h.html#a117">WORK_QUEUE_ENTRY</a> ),
00303                                              'KWcC',
00304                                              NumberOfItems );
00305 
00306         } <span class="keywordflow">else</span> {
00307             Lookaside = &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a42">CcTwilightLookasideList</a>;
00308         }
00309 
00310         Prcb-&gt;PPLookasideList[<a class="code" href="../../d5/d8/ex_8h.html#a331a202">LookasideTwilightList</a>].P = Lookaside;
00311     }
00312 
00313     <span class="comment">//</span>
00314     <span class="comment">//  Now initialize the Bcb zone</span>
00315     <span class="comment">//</span>
00316 
00317     {
00318         PVOID InitialSegment;
00319         ULONG InitialSegmentSize;
00320         ULONG RoundedBcbSize = (<span class="keyword">sizeof</span>(<a class="code" href="../../d4/d3/struct__BCB.html">BCB</a>) + 7) &amp; ~7;
00321 
00322         <span class="keywordflow">switch</span> ( <a class="code" href="../../d5/d2/cachedat_8c.html#a37">CcCapturedSystemSize</a> ) {
00323 
00324                 <span class="comment">//</span>
00325                 <span class="comment">// ~1.5k bytes</span>
00326                 <span class="comment">//</span>
00327 
00328             <span class="keywordflow">case</span> <a class="code" href="../../d2/d1/mm_8h.html#a343a165">MmSmallSystem</a> :
00329                 InitialSegmentSize = <span class="keyword">sizeof</span>(<a class="code" href="../../d1/d0/struct__ZONE__SEGMENT__HEADER.html">ZONE_SEGMENT_HEADER</a>) + RoundedBcbSize * 8;
00330                 <span class="keywordflow">break</span>;
00331 
00332                 <span class="comment">//</span>
00333                 <span class="comment">// 1 Page</span>
00334                 <span class="comment">//</span>
00335 
00336             <span class="keywordflow">case</span> <a class="code" href="../../d2/d1/mm_8h.html#a343a166">MmMediumSystem</a> :
00337                 InitialSegmentSize = <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
00338                 <span class="keywordflow">break</span>;
00339 
00340                 <span class="comment">//</span>
00341                 <span class="comment">// 3 Pages</span>
00342                 <span class="comment">//</span>
00343 
00344             <span class="keywordflow">case</span> <a class="code" href="../../d2/d1/mm_8h.html#a343a167">MmLargeSystem</a> :
00345                 InitialSegmentSize = 3 * <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
00346                 <span class="keywordflow">break</span>;
00347             }
00348 
00349         <span class="comment">//</span>
00350         <span class="comment">//  Allocate the initial allocation for the zone.  If we cannot get it,</span>
00351         <span class="comment">//  something must really be wrong, so we will just bugcheck.</span>
00352         <span class="comment">//</span>
00353 
00354         <span class="keywordflow">if</span> ((InitialSegment = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>,
00355                                                      InitialSegmentSize,
00356                                                      'zBcC' )) == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00357 
00358             <a class="code" href="../../d5/d5/cc_8h.html#a28">CcBugCheck</a>( 0, 0, 0 );
00359         }
00360 
00361         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d5/d8/ex_8h.html#a263">ExInitializeZone</a>( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o2">BcbZone</a>,
00362                                           RoundedBcbSize,
00363                                           InitialSegment,
00364                                           InitialSegmentSize ))) {
00365             <a class="code" href="../../d5/d5/cc_8h.html#a28">CcBugCheck</a>( 0, 0, 0 );
00366         }
00367     }
00368 
00369     <span class="comment">//</span>
00370     <span class="comment">//  Initialize the Deferred Write List.</span>
00371     <span class="comment">//</span>
00372 
00373     <a class="code" href="../../d4/d9/ke_8h.html#a354">KeInitializeSpinLock</a>( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a28">CcDeferredWriteSpinLock</a> );
00374     InitializeListHead( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a29">CcDeferredWrites</a> );
00375 
00376     <span class="comment">//</span>
00377     <span class="comment">//  Initialize the Vacbs.</span>
00378     <span class="comment">//</span>
00379 
00380     <a class="code" href="../../d5/d5/cc_8h.html#a192">CcInitializeVacbs</a>();
00381 
00382     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00383 }
00384 
00385 
00386 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00387"></a><a class="code" href="../../d4/d2/cache_8h.html#a58">00387</a> <a class="code" href="../../d4/d2/cache_8h.html#a58">CcInitializeCacheMap</a> (
00388     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
00389     IN <a class="code" href="../../d1/d9/struct__CC__FILE__SIZES.html">PCC_FILE_SIZES</a> FileSizes,
00390     IN BOOLEAN PinAccess,
00391     IN <a class="code" href="../../d3/d6/struct__CACHE__MANAGER__CALLBACKS.html">PCACHE_MANAGER_CALLBACKS</a> Callbacks,
00392     IN PVOID LazyWriteContext
00393     )
00394 
00395 <span class="comment">/*++</span>
00396 <span class="comment"></span>
00397 <span class="comment">Routine Description:</span>
00398 <span class="comment"></span>
00399 <span class="comment">    This routine is intended to be called by File Systems only.  It</span>
00400 <span class="comment">    initializes the cache maps for data caching.  It should be called</span>
00401 <span class="comment">    every time a file is open or created, and NO_INTERMEDIATE_BUFFERING</span>
00402 <span class="comment">    was specified as FALSE.</span>
00403 <span class="comment"></span>
00404 <span class="comment">Arguments:</span>
00405 <span class="comment"></span>
00406 <span class="comment">    FileObject - A pointer to the newly-created file object.</span>
00407 <span class="comment"></span>
00408 <span class="comment">    FileSizes - A pointer to AllocationSize, FileSize and ValidDataLength</span>
00409 <span class="comment">                for the file.  ValidDataLength should contain MAXLONGLONG if</span>
00410 <span class="comment">                valid data length tracking and callbacks are not desired.</span>
00411 <span class="comment"></span>
00412 <span class="comment">    PinAccess - FALSE if file will be used exclusively for Copy and Mdl</span>
00413 <span class="comment">                access, or TRUE if file will be used for Pin access.</span>
00414 <span class="comment">                (Files for Pin access are not limited in size as the caller</span>
00415 <span class="comment">                must access multiple areas of the file at once.)</span>
00416 <span class="comment"></span>
00417 <span class="comment">    Callbacks - Structure of callbacks used by the Lazy Writer</span>
00418 <span class="comment"></span>
00419 <span class="comment">    LazyWriteContext - Parameter to be passed in to above routine.</span>
00420 <span class="comment"></span>
00421 <span class="comment">Return Value:</span>
00422 <span class="comment"></span>
00423 <span class="comment">    None.  If an error occurs, this routine will Raise the status.</span>
00424 <span class="comment"></span>
00425 <span class="comment">--*/</span>
00426 
00427 {
00428     KIRQL OldIrql;
00429     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00430     PVOID CacheMapToFree = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00431     <a class="code" href="../../d1/d9/struct__CC__FILE__SIZES.html">CC_FILE_SIZES</a> LocalSizes;
00432     BOOLEAN WeSetBeingCreated = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00433     BOOLEAN SharedListOwned = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00434     BOOLEAN MustUninitialize = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00435     BOOLEAN WeCreated = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00436 
00437     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcInitializeCacheMap:\n"</span>, 0 );
00438     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"    FileObject = %08lx\n"</span>, FileObject );
00439     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"    FileSizes = %08lx\n"</span>, FileSizes );
00440 
00441     <span class="comment">//</span>
00442     <span class="comment">//  Make a local copy of the passed in file sizes before acquiring</span>
00443     <span class="comment">//  the spin lock.</span>
00444     <span class="comment">//</span>
00445 
00446     LocalSizes = *FileSizes;
00447 
00448     <span class="comment">//</span>
00449     <span class="comment">//  If no FileSize was given, set to one byte before maximizing below.</span>
00450     <span class="comment">//</span>
00451 
00452     <span class="keywordflow">if</span> (LocalSizes.<a class="code" href="../../d1/d9/struct__CC__FILE__SIZES.html#o0">AllocationSize</a>.QuadPart == 0) {
00453         LocalSizes.<a class="code" href="../../d1/d9/struct__CC__FILE__SIZES.html#o0">AllocationSize</a>.LowPart += 1;
00454     }
00455 
00456     <span class="comment">//</span>
00457     <span class="comment">//  If caller has Write access or will allow write, then round</span>
00458     <span class="comment">//  size to next create modulo.  (***Temp*** there may be too many</span>
00459     <span class="comment">//  apps that end up allowing shared write, thanks to our Dos heritage,</span>
00460     <span class="comment">//  to keep that part of the check in.)</span>
00461     <span class="comment">//</span>
00462 
00463     <span class="keywordflow">if</span> (FileObject-&gt;WriteAccess <span class="comment">/*|| FileObject-&gt;SharedWrite */</span>) {
00464 
00465         LocalSizes.<a class="code" href="../../d1/d9/struct__CC__FILE__SIZES.html#o0">AllocationSize</a>.QuadPart = LocalSizes.<a class="code" href="../../d1/d9/struct__CC__FILE__SIZES.html#o0">AllocationSize</a>.QuadPart + (LONGLONG)(<a class="code" href="../../d5/d5/cc_8h.html#a29">DEFAULT_CREATE_MODULO</a> - 1);
00466         LocalSizes.<a class="code" href="../../d1/d9/struct__CC__FILE__SIZES.html#o0">AllocationSize</a>.LowPart &amp;= ~(<a class="code" href="../../d5/d5/cc_8h.html#a29">DEFAULT_CREATE_MODULO</a> - 1);
00467 
00468     } <span class="keywordflow">else</span> {
00469 
00470         LocalSizes.<a class="code" href="../../d1/d9/struct__CC__FILE__SIZES.html#o0">AllocationSize</a>.QuadPart = LocalSizes.<a class="code" href="../../d1/d9/struct__CC__FILE__SIZES.html#o0">AllocationSize</a>.QuadPart + (LONGLONG)(<a class="code" href="../../d4/d2/cache_8h.html#a0">VACB_MAPPING_GRANULARITY</a> - 1);
00471         LocalSizes.<a class="code" href="../../d1/d9/struct__CC__FILE__SIZES.html#o0">AllocationSize</a>.LowPart &amp;= ~(<a class="code" href="../../d4/d2/cache_8h.html#a0">VACB_MAPPING_GRANULARITY</a> - 1);
00472     }
00473 
00474     <span class="comment">//</span>
00475     <span class="comment">//  Do the allocate of the SharedCacheMap, based on an unsafe test,</span>
00476     <span class="comment">//  while not holding a spinlock.  Allocation failures look like we</span>
00477     <span class="comment">//  never decided to allocate one here!</span>
00478     <span class="comment">//</span>
00479 
00480     <span class="keywordflow">if</span> (FileObject-&gt;SectionObjectPointer-&gt;SharedCacheMap == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00481         CacheMapToFree = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, <span class="keyword">sizeof</span>(<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">SHARED_CACHE_MAP</a>), 'cScC' );
00482     }
00483 
00484     <span class="comment">//</span>
00485     <span class="comment">//  Serialize Creation/Deletion of all Shared CacheMaps</span>
00486     <span class="comment">//</span>
00487 
00488     <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
00489     SharedListOwned = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00490 
00491     <span class="comment">//</span>
00492     <span class="comment">//  Insure release of our global resource</span>
00493     <span class="comment">//</span>
00494 
00495     <span class="keywordflow">try</span> {
00496 
00497         <span class="comment">//</span>
00498         <span class="comment">//  Check for second initialization of same file object</span>
00499         <span class="comment">//</span>
00500 
00501         <span class="keywordflow">if</span> (FileObject-&gt;PrivateCacheMap != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00502 
00503             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, 0, <span class="stringliteral">"CacheMap already initialized\n"</span>, 0 );
00504             <a class="code" href="../../d5/d5/cc_8h.html#a90">try_return</a>( NOTHING );
00505         }
00506 
00507         <span class="comment">//</span>
00508         <span class="comment">//  Get current Shared Cache Map pointer indirectly off of the file object.</span>
00509         <span class="comment">//  (The actual pointer is typically in a file system data structure, such</span>
00510         <span class="comment">//  as an Fcb.)</span>
00511         <span class="comment">//</span>
00512 
00513         SharedCacheMap = FileObject-&gt;SectionObjectPointer-&gt;SharedCacheMap;
00514 
00515         <span class="comment">//</span>
00516         <span class="comment">//  If there is no SharedCacheMap, then we must create a section and</span>
00517         <span class="comment">//  the SharedCacheMap structure.</span>
00518         <span class="comment">//</span>
00519 
00520         <span class="keywordflow">if</span> (SharedCacheMap == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00521 
00522             <span class="comment">//</span>
00523             <span class="comment">//  After successfully creating the section, allocate the SharedCacheMap.</span>
00524             <span class="comment">//</span>
00525 
00526             WeCreated = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00527 
00528             <span class="keywordflow">if</span> (CacheMapToFree == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00529                 CacheMapToFree = (<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a>)<a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>,
00530                                                                            <span class="keyword">sizeof</span>(<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">SHARED_CACHE_MAP</a>),
00531                                                                            'cScC' );
00532             }
00533 
00534             SharedCacheMap = CacheMapToFree;
00535             CacheMapToFree = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00536 
00537             <span class="keywordflow">if</span> (SharedCacheMap == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00538 
00539                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, 0, <span class="stringliteral">"Failed to allocate SharedCacheMap\n"</span>, 0 );
00540 
00541                 <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
00542                 SharedListOwned = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00543 
00544                 <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INSUFFICIENT_RESOURCES );
00545             }
00546 
00547             <span class="comment">//</span>
00548             <span class="comment">//  Zero the SharedCacheMap and fill in the nonzero portions later.</span>
00549             <span class="comment">//</span>
00550 
00551             RtlZeroMemory( SharedCacheMap, <span class="keyword">sizeof</span>(<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">SHARED_CACHE_MAP</a>) );
00552 
00553 <span class="preprocessor">#if DANLO</span>
00554 <span class="preprocessor"></span>            SharedCacheMap-&gt;OpenCountLog.Size = <span class="keyword">sizeof</span>(SharedCacheMap-&gt;OpenCountLog.Log)/<span class="keyword">sizeof</span>(CC_LOG_ENTRY);
00555 <span class="preprocessor">#endif</span>
00556 <span class="preprocessor"></span>
00557             <span class="comment">//</span>
00558             <span class="comment">//  Now initialize the Shared Cache Map.</span>
00559             <span class="comment">//</span>
00560 
00561             SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o0">NodeTypeCode</a> = <a class="code" href="../../d5/d5/cc_8h.html#a12">CACHE_NTC_SHARED_CACHE_MAP</a>;
00562             SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o1">NodeByteSize</a> = <span class="keyword">sizeof</span>(<a class="code" href="../../d5/d5/cc_8h.html#a101">SHARED_CACHE_MAP</a>);
00563             SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o10">FileObject</a> = FileObject;
00564             SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o3">FileSize</a> = LocalSizes.<a class="code" href="../../d1/d9/struct__CC__FILE__SIZES.html#o1">FileSize</a>;
00565             SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o6">ValidDataLength</a> = LocalSizes.<a class="code" href="../../d1/d9/struct__CC__FILE__SIZES.html#o2">ValidDataLength</a>;
00566             SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o7">ValidDataGoal</a> = LocalSizes.<a class="code" href="../../d1/d9/struct__CC__FILE__SIZES.html#o2">ValidDataLength</a>;
00567             <span class="comment">//  SharedCacheMap-&gt;Section set below</span>
00568 
00569             <span class="comment">//</span>
00570             <span class="comment">//  Initialize the spin locks.</span>
00571             <span class="comment">//</span>
00572 
00573             <a class="code" href="../../d4/d9/ke_8h.html#a354">KeInitializeSpinLock</a>( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o15">ActiveVacbSpinLock</a> );
00574             <a class="code" href="../../d4/d9/ke_8h.html#a354">KeInitializeSpinLock</a>( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o36">BcbSpinLock</a> );
00575 
00576             <span class="keywordflow">if</span> (PinAccess) {
00577                 <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, <a class="code" href="../../d5/d5/cc_8h.html#a72">PIN_ACCESS</a>);
00578             }
00579 
00580             <span class="comment">//</span>
00581             <span class="comment">//  Initialize our allocation hint for the local event.</span>
00582             <span class="comment">//</span>
00583 
00584             SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o37">LocalEvent</a> = &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o38">Event</a>;
00585 
00586             <span class="comment">//</span>
00587             <span class="comment">//  If this file has FO_SEQUENTIAL_ONLY set, then remember that</span>
00588             <span class="comment">//  in the SharedCacheMap.</span>
00589             <span class="comment">//</span>
00590 
00591             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(FileObject-&gt;Flags, <a class="code" href="../../d0/d5/io_8h.html#a155">FO_SEQUENTIAL_ONLY</a>)) {
00592                 <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, <a class="code" href="../../d5/d5/cc_8h.html#a75">ONLY_SEQUENTIAL_ONLY_SEEN</a>);
00593             }
00594 
00595             <span class="comment">//</span>
00596             <span class="comment">//  Do the round-robin allocation of the spinlock for the shared</span>
00597             <span class="comment">//  cache map.  Note the manipulation of the next</span>
00598             <span class="comment">//  counter is safe, since we have the CcMasterSpinLock</span>
00599             <span class="comment">//  exclusive.</span>
00600             <span class="comment">//</span>
00601 
00602             InitializeListHead( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o4">BcbList</a> );
00603             SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o27">Callbacks</a> = Callbacks;
00604             SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o28">LazyWriteContext</a> = LazyWriteContext;
00605 
00606             <span class="comment">//</span>
00607             <span class="comment">//  Initialize listhead for all PrivateCacheMaps</span>
00608             <span class="comment">//</span>
00609 
00610             InitializeListHead( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o29">PrivateList</a> );
00611 
00612             <span class="comment">//</span>
00613             <span class="comment">//  Insert the new Shared Cache Map in the global list</span>
00614             <span class="comment">//</span>
00615 
00616             InsertTailList( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a1">CcCleanSharedCacheMapList</a>,
00617                             &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a> );
00618 
00619             <span class="comment">//</span>
00620             <span class="comment">//  Finally, store the pointer to the Shared Cache Map back</span>
00621             <span class="comment">//  via the indirect pointer in the File Object.</span>
00622             <span class="comment">//</span>
00623 
00624             FileObject-&gt;SectionObjectPointer-&gt;SharedCacheMap = SharedCacheMap;
00625 
00626             <span class="comment">//</span>
00627             <span class="comment">//  We must reference this file object so that it cannot go away</span>
00628             <span class="comment">//  until we do CcUninitializeCacheMap below.  Note we cannot</span>
00629             <span class="comment">//  find or rely on the FileObject that Memory Management has,</span>
00630             <span class="comment">//  although normally it will be this same one anyway.</span>
00631             <span class="comment">//</span>
00632 
00633             <a class="code" href="../../d4/d0/ob_8h.html#a15">ObReferenceObject</a> ( FileObject );
00634 
00635         } <span class="keywordflow">else</span> {
00636 
00637             <span class="comment">//</span>
00638             <span class="comment">//  If this file has FO_SEQUENTIAL_ONLY clear, then remember that</span>
00639             <span class="comment">//  in the SharedCacheMap.</span>
00640             <span class="comment">//</span>
00641 
00642             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(FileObject-&gt;Flags, <a class="code" href="../../d0/d5/io_8h.html#a155">FO_SEQUENTIAL_ONLY</a>)) {
00643                 <a class="code" href="../../d5/d5/cc_8h.html#a61">ClearFlag</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, <a class="code" href="../../d5/d5/cc_8h.html#a75">ONLY_SEQUENTIAL_ONLY_SEEN</a>);
00644             }
00645         }
00646 
00647         <span class="comment">//</span>
00648         <span class="comment">//  If this file is opened for random access, remember this in</span>
00649         <span class="comment">//  the SharedCacheMap.</span>
00650         <span class="comment">//</span>
00651 
00652         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(FileObject-&gt;Flags, <a class="code" href="../../d0/d5/io_8h.html#a170">FO_RANDOM_ACCESS</a>)) {
00653             <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, <a class="code" href="../../d5/d5/cc_8h.html#a81">RANDOM_ACCESS_SEEN</a>);
00654         }
00655 
00656         <span class="comment">//</span>
00657         <span class="comment">//  Make sure that no one is trying to lazy delete it in the case</span>
00658         <span class="comment">//  that the Cache Map was already there.</span>
00659         <span class="comment">//</span>
00660 
00661         <a class="code" href="../../d5/d5/cc_8h.html#a61">ClearFlag</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, <a class="code" href="../../d5/d5/cc_8h.html#a73">TRUNCATE_REQUIRED</a>);
00662 
00663         <span class="comment">//</span>
00664         <span class="comment">//  In case there has been a CcUnmapAndPurge call, we check here if we</span>
00665         <span class="comment">//  if we need to recreate the section and map it.</span>
00666         <span class="comment">//</span>
00667 
00668         <span class="keywordflow">if</span> ((SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o9">Vacbs</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
00669             !<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, <a class="code" href="../../d5/d5/cc_8h.html#a77">BEING_CREATED</a>)) {
00670 
00671             <span class="comment">//</span>
00672             <span class="comment">//  Increment the OpenCount on the CacheMap.</span>
00673             <span class="comment">//</span>
00674 
00675             <a class="code" href="../../d5/d5/cc_8h.html#a68">CcIncrementOpenCount</a>( SharedCacheMap, 'onnI' );
00676             MustUninitialize = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00677 
00678             <span class="comment">//</span>
00679             <span class="comment">//  We still want anyone else to wait.</span>
00680             <span class="comment">//</span>
00681 
00682             <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, <a class="code" href="../../d5/d5/cc_8h.html#a77">BEING_CREATED</a>);
00683             WeSetBeingCreated = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00684 
00685             <span class="comment">//</span>
00686             <span class="comment">//  If there is a create event, then this must be the path where we</span>
00687             <span class="comment">//  we were only unmapped.  We will just clear it here again in case</span>
00688             <span class="comment">//  someone needs to wait again this time too.</span>
00689             <span class="comment">//</span>
00690 
00691             <span class="keywordflow">if</span> (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o23">CreateEvent</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00692 
00693                 <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o23">CreateEvent</a>,
00694                                    NotificationEvent,
00695                                    <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00696             }
00697 
00698             <span class="comment">//</span>
00699             <span class="comment">//  Release global resource</span>
00700             <span class="comment">//</span>
00701 
00702             <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
00703             SharedListOwned = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00704 
00705             <span class="comment">//</span>
00706             <span class="comment">//  We have to test this, because the section may only be unmapped.</span>
00707             <span class="comment">//</span>
00708 
00709             <span class="keywordflow">if</span> (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o21">Section</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00710 
00711                 LARGE_INTEGER LargeZero = {0,0};
00712 
00713                 <span class="comment">//</span>
00714                 <span class="comment">//  Call MM to create a section for this file, for the calculated</span>
00715                 <span class="comment">//  section size.  Note that we have the choice in this service to</span>
00716                 <span class="comment">//  pass in a FileHandle or a FileObject pointer, but not both.</span>
00717                 <span class="comment">//  Naturally we want to pass in the handle.</span>
00718                 <span class="comment">//</span>
00719 
00720                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d5/d5/cc_8h.html#a57">mm</a>, <span class="stringliteral">"MmCreateSection:\n"</span>, 0 );
00721                 <a class="code" href="../../d5/d5/cc_8h.html#a92">DebugTrace2</a>(0, <a class="code" href="../../d5/d5/cc_8h.html#a57">mm</a>, <span class="stringliteral">"    MaximumSize = %08lx, %08lx\n"</span>,
00722                             LocalSizes.<a class="code" href="../../d1/d9/struct__CC__FILE__SIZES.html#o0">AllocationSize</a>.LowPart,
00723                             LocalSizes.<a class="code" href="../../d1/d9/struct__CC__FILE__SIZES.html#o0">AllocationSize</a>.HighPart );
00724                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d5/d5/cc_8h.html#a57">mm</a>, <span class="stringliteral">"    FileObject = %08lx\n"</span>, FileObject );
00725 
00726                 SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o22">Status</a> = <a class="code" href="../../d0/d8/creasect_8c.html#a20">MmCreateSection</a>( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o21">Section</a>,
00727                                                           SECTION_MAP_READ
00728                                                             | SECTION_MAP_WRITE
00729                                                             | SECTION_QUERY,
00730                                                           <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00731                                                           &amp;LocalSizes.<a class="code" href="../../d1/d9/struct__CC__FILE__SIZES.html#o0">AllocationSize</a>,
00732                                                           PAGE_READWRITE,
00733                                                           SEC_COMMIT,
00734                                                           <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00735                                                           FileObject );
00736 
00737                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d5/d5/cc_8h.html#a57">mm</a>, <span class="stringliteral">"    &lt;Section = %08lx\n"</span>, SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o21">Section</a> );
00738 
00739                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o22">Status</a> )){
00740                     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, 0, <span class="stringliteral">"Error from MmCreateSection = %08lx\n"</span>,
00741                                 SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o22">Status</a> );
00742 
00743                     SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o21">Section</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00744                     <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( <a class="code" href="../../d1/d8/fsrtl_8h.html#a136">FsRtlNormalizeNtstatus</a>( SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o22">Status</a>,
00745                                                            STATUS_UNEXPECTED_MM_CREATE_ERR ));
00746                 }
00747 
00748                 <a class="code" href="../../d6/d0/obcreate_8c.html#a10">ObDeleteCapturedInsertInfo</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o21">Section</a>);
00749 
00750                 <span class="comment">//</span>
00751                 <span class="comment">//  If this is a stream file object, then no user can map it,</span>
00752                 <span class="comment">//  and we should keep the modified page writer out of it.</span>
00753                 <span class="comment">//</span>
00754 
00755                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(((<a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html">PFSRTL_COMMON_FCB_HEADER</a>)FileObject-&gt;FsContext)-&gt;Flags2,
00756                             <a class="code" href="../../d1/d8/fsrtl_8h.html#a8">FSRTL_FLAG2_DO_MODIFIED_WRITE</a>) &amp;&amp;
00757                     (FileObject-&gt;FsContext2 == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
00758 
00759                     BOOLEAN Disabled;
00760 
00761                     Disabled = <a class="code" href="../../d6/d3/modwrite_8c.html#a54">MmDisableModifiedWriteOfSection</a>( FileObject-&gt;SectionObjectPointer );
00762                     <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
00763                     <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, <a class="code" href="../../d5/d5/cc_8h.html#a78">MODIFIED_WRITE_DISABLED</a>);
00764                     <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
00765 
00766                     <span class="comment">//**** ASSERT( Disabled );</span>
00767                 }
00768 
00769                 <span class="comment">//</span>
00770                 <span class="comment">//  Create the Vacb array.</span>
00771                 <span class="comment">//</span>
00772 
00773                 <a class="code" href="../../d5/d3/vacbsup_8c.html#a20">CcCreateVacbArray</a>( SharedCacheMap, LocalSizes.<a class="code" href="../../d1/d9/struct__CC__FILE__SIZES.html#o0">AllocationSize</a> );
00774             }
00775 
00776             <span class="comment">//</span>
00777             <span class="comment">//  If the section already exists, we still have to call MM to</span>
00778             <span class="comment">//  extend, in case it is not large enough.</span>
00779             <span class="comment">//</span>
00780 
00781             <span class="keywordflow">else</span> {
00782 
00783                 <span class="keywordflow">if</span> ( LocalSizes.<a class="code" href="../../d1/d9/struct__CC__FILE__SIZES.html#o0">AllocationSize</a>.QuadPart &gt; SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o5">SectionSize</a>.QuadPart ) {
00784 
00785                     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00786 
00787                     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d5/d5/cc_8h.html#a57">mm</a>, <span class="stringliteral">"MmExtendSection:\n"</span>, 0 );
00788                     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d5/d5/cc_8h.html#a57">mm</a>, <span class="stringliteral">"    Section = %08lx\n"</span>, SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o21">Section</a> );
00789                     <a class="code" href="../../d5/d5/cc_8h.html#a92">DebugTrace2</a>(0, <a class="code" href="../../d5/d5/cc_8h.html#a57">mm</a>, <span class="stringliteral">"    Size = %08lx, %08lx\n"</span>,
00790                                 LocalSizes.<a class="code" href="../../d1/d9/struct__CC__FILE__SIZES.html#o0">AllocationSize</a>.LowPart,
00791                                 LocalSizes.<a class="code" href="../../d1/d9/struct__CC__FILE__SIZES.html#o0">AllocationSize</a>.HighPart );
00792 
00793                     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d8/d0/extsect_8c.html#a1">MmExtendSection</a>( SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o21">Section</a>,
00794                                               &amp;LocalSizes.<a class="code" href="../../d1/d9/struct__CC__FILE__SIZES.html#o0">AllocationSize</a>,
00795                                               <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
00796 
00797                     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
00798 
00799                         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, 0, <span class="stringliteral">"Error from MmExtendSection, Status = %08lx\n"</span>,
00800                                     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> );
00801 
00802                         <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( <a class="code" href="../../d1/d8/fsrtl_8h.html#a136">FsRtlNormalizeNtstatus</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>,
00803                                                                STATUS_UNEXPECTED_MM_EXTEND_ERR ));
00804                     }
00805                 }
00806 
00807                 <span class="comment">//</span>
00808                 <span class="comment">//  Extend the Vacb array.</span>
00809                 <span class="comment">//</span>
00810 
00811                 <a class="code" href="../../d5/d3/vacbsup_8c.html#a21">CcExtendVacbArray</a>( SharedCacheMap, LocalSizes.<a class="code" href="../../d1/d9/struct__CC__FILE__SIZES.html#o0">AllocationSize</a> );
00812             }
00813 
00814             <span class="comment">//</span>
00815             <span class="comment">//  Now show that we are all done and resume any waiters.</span>
00816             <span class="comment">//</span>
00817 
00818             <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
00819             <a class="code" href="../../d5/d5/cc_8h.html#a61">ClearFlag</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, <a class="code" href="../../d5/d5/cc_8h.html#a77">BEING_CREATED</a>);
00820             WeSetBeingCreated = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00821             <span class="keywordflow">if</span> (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o23">CreateEvent</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00822                 <a class="code" href="../../d2/d8/eventobj_8c.html#a8">KeSetEvent</a>( SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o23">CreateEvent</a>, 0, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00823             }
00824             <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
00825         }
00826 
00827         <span class="comment">//</span>
00828         <span class="comment">//  Else if the section is already there, we make sure it is large</span>
00829         <span class="comment">//  enough by calling CcExtendCacheSection.</span>
00830         <span class="comment">//</span>
00831 
00832         <span class="keywordflow">else</span> {
00833 
00834             <span class="comment">//</span>
00835             <span class="comment">//  If the SharedCacheMap is currently being created we have</span>
00836             <span class="comment">//  to optionally create and wait on an event for it.  Note that</span>
00837             <span class="comment">//  the only safe time to delete the event is in</span>
00838             <span class="comment">//  CcUninitializeCacheMap, because we otherwise have no way of</span>
00839             <span class="comment">//  knowing when everyone has reached the KeWaitForSingleObject.</span>
00840             <span class="comment">//</span>
00841 
00842             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, <a class="code" href="../../d5/d5/cc_8h.html#a77">BEING_CREATED</a>)) {
00843 
00844                 <span class="keywordflow">if</span> (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o23">CreateEvent</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00845 
00846                     <span class="comment">//</span>
00847                     <span class="comment">//  If the local event is not being used then we can grab it.</span>
00848                     <span class="comment">//  (Should be quite rare that it is in use.)</span>
00849                     <span class="comment">//</span>
00850 
00851                     SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o23">CreateEvent</a> = InterlockedExchangePointer( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o37">LocalEvent</a>, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00852                     
00853                     <span class="keywordflow">if</span> (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o23">CreateEvent</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00854 
00855                         SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o23">CreateEvent</a> = (<a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>)<a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>,
00856                                                                                       <span class="keyword">sizeof</span>(<a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a>),
00857                                                                                       'vEcC' );
00858                     }
00859 
00860                     <span class="keywordflow">if</span> (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o23">CreateEvent</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00861                         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, 0, <span class="stringliteral">"Failed to allocate CreateEvent\n"</span>, 0 );
00862 
00863                         <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
00864                         SharedListOwned = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00865 
00866                         <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>(STATUS_INSUFFICIENT_RESOURCES);
00867                     }
00868 
00869                     <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o23">CreateEvent</a>,
00870                                        NotificationEvent,
00871                                        <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00872                 }
00873 
00874                 <span class="comment">//</span>
00875                 <span class="comment">//  Increment the OpenCount on the CacheMap.</span>
00876                 <span class="comment">//</span>
00877 
00878                 <a class="code" href="../../d5/d5/cc_8h.html#a68">CcIncrementOpenCount</a>( SharedCacheMap, 'ecnI' );
00879                 MustUninitialize = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00880 
00881                 <span class="comment">//</span>
00882                 <span class="comment">//  Release global resource before waiting</span>
00883                 <span class="comment">//</span>
00884 
00885                 <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
00886                 SharedListOwned = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00887 
00888                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, 0, <span class="stringliteral">"Waiting on CreateEvent\n"</span>, 0 );
00889 
00890                 <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o23">CreateEvent</a>,
00891                                        <a class="code" href="../../d6/d7/halmips_8h.html#a455">Executive</a>,
00892                                        <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
00893                                        <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00894                                        (PLARGE_INTEGER)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00895 
00896                 <span class="comment">//</span>
00897                 <span class="comment">//  If the real creator got an error, then we must bomb</span>
00898                 <span class="comment">//  out too.</span>
00899                 <span class="comment">//</span>
00900 
00901                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o22">Status</a>)) {
00902                     <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( <a class="code" href="../../d1/d8/fsrtl_8h.html#a136">FsRtlNormalizeNtstatus</a>( SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o22">Status</a>,
00903                                                            STATUS_UNEXPECTED_MM_CREATE_ERR ));
00904                 }
00905             }
00906             <span class="keywordflow">else</span> {
00907 
00908                 <a class="code" href="../../d4/d6/struct__CACHE__UNINITIALIZE__EVENT.html">PCACHE_UNINITIALIZE_EVENT</a> CUEvent, EventNext;
00909 
00910                 <span class="comment">//</span>
00911                 <span class="comment">//  Increment the OpenCount on the CacheMap.</span>
00912                 <span class="comment">//</span>
00913 
00914                 <a class="code" href="../../d5/d5/cc_8h.html#a68">CcIncrementOpenCount</a>( SharedCacheMap, 'esnI' );
00915                 MustUninitialize = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00916 
00917                 <span class="comment">//</span>
00918                 <span class="comment">//  If there is a process waiting on an uninitialize on this</span>
00919                 <span class="comment">//  cache map to complete, let the thread that is waiting go,</span>
00920                 <span class="comment">//  since the uninitialize is now complete.</span>
00921                 <span class="comment">//</span>
00922                 CUEvent = SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o34">UninitializeEvent</a>;
00923 
00924                 <span class="keywordflow">while</span> (CUEvent != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00925                     EventNext = CUEvent-&gt;<a class="code" href="../../d4/d6/struct__CACHE__UNINITIALIZE__EVENT.html#o0">Next</a>;
00926                     <a class="code" href="../../d2/d8/eventobj_8c.html#a8">KeSetEvent</a>(&amp;CUEvent-&gt;<a class="code" href="../../d4/d6/struct__CACHE__UNINITIALIZE__EVENT.html#o1">Event</a>, 0, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
00927                     CUEvent = EventNext;
00928                 }
00929 
00930                 SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o34">UninitializeEvent</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00931 
00932                 <span class="comment">//</span>
00933                 <span class="comment">//  Release global resource</span>
00934                 <span class="comment">//</span>
00935 
00936                 <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
00937                 SharedListOwned = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00938             }
00939         }
00940 
00941         {
00942             <a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html">PPRIVATE_CACHE_MAP</a> PrivateCacheMap;
00943 
00944             <span class="comment">//</span>
00945             <span class="comment">//  Now allocate (if local one already in use) and initialize</span>
00946             <span class="comment">//  the Private Cache Map.</span>
00947             <span class="comment">//</span>
00948 
00949             PrivateCacheMap = &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o39">PrivateCacheMap</a>;
00950 
00951             <span class="comment">//</span>
00952             <span class="comment">//  See if we should allocate a PrivateCacheMap while not holding</span>
00953             <span class="comment">//  a spinlock.</span>
00954             <span class="comment">//</span>
00955 
00956             <span class="keywordflow">if</span> (CacheMapToFree != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00957                 <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( CacheMapToFree );
00958                 CacheMapToFree = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00959             }
00960 
00961             <span class="keywordflow">if</span> (PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o0">NodeTypeCode</a> != 0) {
00962                 CacheMapToFree = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, <span class="keyword">sizeof</span>(<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html">PRIVATE_CACHE_MAP</a>), 'cPcC' );
00963             }
00964 
00965             <span class="comment">//</span>
00966             <span class="comment">//  Insert the new PrivateCacheMap in the list off the SharedCacheMap.</span>
00967             <span class="comment">//</span>
00968 
00969             <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
00970             SharedListOwned = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00971 
00972             <span class="comment">//</span>
00973             <span class="comment">//  Now make sure there is still no PrivateCacheMap, and if so just get out.</span>
00974             <span class="comment">//</span>
00975 
00976             <span class="keywordflow">if</span> (FileObject-&gt;PrivateCacheMap == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00977 
00978                 <span class="comment">//</span>
00979                 <span class="comment">//  Is the local one already in use?</span>
00980                 <span class="comment">//</span>
00981 
00982                 <span class="keywordflow">if</span> (PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o0">NodeTypeCode</a> != 0) {
00983 
00984                     <span class="comment">//</span>
00985                     <span class="comment">//  Use the one allocated above, if there is one, else go to pool now.</span>
00986                     <span class="comment">//</span>
00987 
00988                     <span class="keywordflow">if</span> (CacheMapToFree == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00989                         CacheMapToFree =
00990                             (<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html">PPRIVATE_CACHE_MAP</a>)<a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>,
00991                                                                        <span class="keyword">sizeof</span>(<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html">PRIVATE_CACHE_MAP</a>),
00992                                                                        'cPcC' );
00993                     }
00994                     PrivateCacheMap = CacheMapToFree;
00995                     CacheMapToFree = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00996                 }
00997 
00998                 <span class="keywordflow">if</span> (PrivateCacheMap == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00999 
01000                     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, 0, <span class="stringliteral">"Failed to allocate PrivateCacheMap\n"</span>, 0 );
01001 
01002                     <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
01003                     SharedListOwned = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01004 
01005                     <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>(STATUS_INSUFFICIENT_RESOURCES);
01006                 }
01007 
01008                 RtlZeroMemory( PrivateCacheMap, <span class="keyword">sizeof</span>(<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html">PRIVATE_CACHE_MAP</a>) );
01009 
01010                 PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o0">NodeTypeCode</a> = <a class="code" href="../../d5/d5/cc_8h.html#a13">CACHE_NTC_PRIVATE_CACHE_MAP</a>;
01011                 PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o1">NodeByteSize</a> = <span class="keyword">sizeof</span>(<a class="code" href="../../d5/d5/cc_8h.html#a99">PRIVATE_CACHE_MAP</a>);
01012                 PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o2">FileObject</a> = FileObject;
01013                 PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o10">ReadAheadMask</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1;
01014 
01015                 <span class="comment">//</span>
01016                 <span class="comment">//  Initialize the spin lock.</span>
01017                 <span class="comment">//</span>
01018 
01019                 <a class="code" href="../../d4/d9/ke_8h.html#a354">KeInitializeSpinLock</a>( &amp;PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o9">ReadAheadSpinLock</a> );
01020 
01021                 InsertTailList( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o29">PrivateList</a>, &amp;PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o11">PrivateLinks</a> );
01022 
01023                 FileObject-&gt;PrivateCacheMap = PrivateCacheMap;
01024             
01025             } <span class="keywordflow">else</span> {
01026 
01027                 <span class="comment">//</span>
01028                 <span class="comment">//  We raced with another initializer for the same fileobject and must</span>
01029                 <span class="comment">//  drop our (to this point speculative) opencount.</span>
01030                 <span class="comment">//</span>
01031 
01032                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o2">OpenCount</a> &gt; 1 );
01033                 
01034                 <a class="code" href="../../d5/d5/cc_8h.html#a69">CcDecrementOpenCount</a>( SharedCacheMap, 'rpnI' );
01035                 SharedCacheMap = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01036             }
01037         }  
01038 
01039         MustUninitialize = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01040     try_exit: NOTHING;
01041     }
01042     finally {
01043 
01044         <span class="comment">//</span>
01045         <span class="comment">//  See if we got an error and must uninitialize the SharedCacheMap</span>
01046         <span class="comment">//</span>
01047 
01048         <span class="keywordflow">if</span> (MustUninitialize) {
01049 
01050             <span class="keywordflow">if</span> (!SharedListOwned) {
01051                 <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
01052             }
01053             <span class="keywordflow">if</span> (WeSetBeingCreated) {
01054                 <span class="keywordflow">if</span> (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o23">CreateEvent</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01055                     <a class="code" href="../../d2/d8/eventobj_8c.html#a8">KeSetEvent</a>( SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o23">CreateEvent</a>, 0, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
01056                 }
01057                 <a class="code" href="../../d5/d5/cc_8h.html#a61">ClearFlag</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, <a class="code" href="../../d5/d5/cc_8h.html#a77">BEING_CREATED</a>);
01058             }
01059 
01060             <span class="comment">//</span>
01061             <span class="comment">//  Now release our open count.</span>
01062             <span class="comment">//</span>
01063 
01064             <a class="code" href="../../d5/d5/cc_8h.html#a69">CcDecrementOpenCount</a>( SharedCacheMap, 'umnI' );
01065 
01066             <span class="keywordflow">if</span> ((SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o2">OpenCount</a> == 0) &amp;&amp;
01067                 !<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, <a class="code" href="../../d5/d5/cc_8h.html#a74">WRITE_QUEUED</a>) &amp;&amp;
01068                 (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o20">DirtyPages</a> == 0)) {
01069 
01070                 <span class="comment">//</span>
01071                 <span class="comment">//  On PinAccess it is safe and necessary to eliminate</span>
01072                 <span class="comment">//  the structure immediately.</span>
01073                 <span class="comment">//</span>
01074 
01075                 <span class="keywordflow">if</span> (PinAccess) {
01076 
01077                     <a class="code" href="../../d5/d8/fssup_8c.html#a11">CcDeleteSharedCacheMap</a>( SharedCacheMap, OldIrql, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
01078 
01079                 <span class="comment">//</span>
01080                 <span class="comment">//  If it is not PinAccess, we must lazy delete, because</span>
01081                 <span class="comment">//  we could get into a deadlock trying to acquire the</span>
01082                 <span class="comment">//  stream exclusive when we dereference the file object.</span>
01083                 <span class="comment">//</span>
01084 
01085                 } <span class="keywordflow">else</span> {
01086 
01087                     <span class="comment">//</span>
01088                     <span class="comment">//  Move it to the dirty list so the lazy write scan will</span>
01089                     <span class="comment">//  see it.</span>
01090                     <span class="comment">//</span>
01091 
01092                     RemoveEntryList( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a> );
01093                     InsertTailList( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a2">CcDirtySharedCacheMapList</a>.<a class="code" href="../../d1/d3/struct__SHARED__CACHE__MAP__LIST__CURSOR.html#o0">SharedCacheMapLinks</a>,
01094                                     &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a> );
01095 
01096                     <span class="comment">//</span>
01097                     <span class="comment">//  Make sure the Lazy Writer will wake up, because we</span>
01098                     <span class="comment">//  want him to delete this SharedCacheMap.</span>
01099                     <span class="comment">//</span>
01100 
01101                     <a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o6">OtherWork</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01102                     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o5">ScanActive</a>) {
01103                         <a class="code" href="../../d5/d5/cc_8h.html#a185">CcScheduleLazyWriteScan</a>();
01104                     }
01105 
01106                     <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
01107                 }
01108 
01109             } <span class="keywordflow">else</span> {
01110 
01111                 <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
01112             }
01113 
01114             SharedListOwned = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01115 
01116         <span class="comment">//</span>
01117         <span class="comment">//  If we did not create this SharedCacheMap, then there is a</span>
01118         <span class="comment">//  possibility that it is in the dirty list.  Once we are sure</span>
01119         <span class="comment">//  we have the spinlock, just make sure it is in the clean list</span>
01120         <span class="comment">//  if there are no dirty bytes and the open count is nonzero.</span>
01121         <span class="comment">//  (The latter test is almost guaranteed, of course, but we check</span>
01122         <span class="comment">//  it to be safe.)</span>
01123         <span class="comment">//</span>
01124 
01125         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!WeCreated &amp;&amp;
01126                    (SharedCacheMap != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
01127 
01128             <span class="keywordflow">if</span> (!SharedListOwned) {
01129 
01130                 <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
01131                 SharedListOwned = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01132             }
01133 
01134             <span class="keywordflow">if</span> ((SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o20">DirtyPages</a> == 0) &amp;&amp;
01135                 (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o2">OpenCount</a> != 0)) {
01136 
01137                 RemoveEntryList( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a> );
01138                 InsertTailList( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a1">CcCleanSharedCacheMapList</a>,
01139                                 &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a> );
01140             }
01141         }
01142 
01143         <span class="comment">//</span>
01144         <span class="comment">//  Release global resource</span>
01145         <span class="comment">//</span>
01146 
01147         <span class="keywordflow">if</span> (SharedListOwned) {
01148             <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
01149         }
01150 
01151         <span class="keywordflow">if</span> (CacheMapToFree != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01152             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(CacheMapToFree);
01153         }
01154 
01155     }
01156 
01157     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcInitializeCacheMap -&gt; VOID\n"</span>, 0 );
01158 
01159     <span class="keywordflow">return</span>;
01160 }
01161 
01162 
01163 BOOLEAN
<a name="l01164"></a><a class="code" href="../../d5/d8/fssup_8c.html#a10">01164</a> <a class="code" href="../../d4/d2/cache_8h.html#a59">CcUninitializeCacheMap</a> (
01165     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
01166     IN PLARGE_INTEGER TruncateSize OPTIONAL,
01167     IN <a class="code" href="../../d4/d6/struct__CACHE__UNINITIALIZE__EVENT.html">PCACHE_UNINITIALIZE_EVENT</a> UninitializeEvent OPTIONAL
01168     )
01169 
01170 <span class="comment">/*++</span>
01171 <span class="comment"></span>
01172 <span class="comment">Routine Description:</span>
01173 <span class="comment"></span>
01174 <span class="comment">    This routine uninitializes the previously initialized Shared and Private</span>
01175 <span class="comment">    Cache Maps.  This routine is only intended to be called by File Systems.</span>
01176 <span class="comment">    It should be called when the File System receives a cleanup call on the</span>
01177 <span class="comment">    File Object.</span>
01178 <span class="comment"></span>
01179 <span class="comment">    A File System which supports data caching must always call this routine</span>
01180 <span class="comment">    whenever it closes a file, whether the caller opened the file with</span>
01181 <span class="comment">    NO_INTERMEDIATE_BUFFERING as FALSE or not.  This is because the final</span>
01182 <span class="comment">    cleanup of a file related to truncation or deletion of the file, can</span>
01183 <span class="comment">    only occur on the last close, whether the last closer cached the file</span>
01184 <span class="comment">    or not.  When CcUnitializeCacheMap is called on a file object for which</span>
01185 <span class="comment">    CcInitializeCacheMap was never called, the call has a benign effect</span>
01186 <span class="comment">    iff no one has truncated or deleted the file; otherwise the necessary</span>
01187 <span class="comment">    cleanup relating to the truncate or close is performed.</span>
01188 <span class="comment"></span>
01189 <span class="comment">    In summary, CcUnitializeCacheMap does the following:</span>
01190 <span class="comment"></span>
01191 <span class="comment">        If the caller had Write or Delete access, the cache is flushed.</span>
01192 <span class="comment">        (This could change with lazy writing.)</span>
01193 <span class="comment"></span>
01194 <span class="comment">        If a Cache Map was initialized on this File Object, it is</span>
01195 <span class="comment">        unitialized (unmap any views, delete section, and delete</span>
01196 <span class="comment">        Cache Map structures).</span>
01197 <span class="comment"></span>
01198 <span class="comment">        On the last Cleanup, if the file has been deleted, the</span>
01199 <span class="comment">        Section is forced closed.  If the file has been truncated, then</span>
01200 <span class="comment">        the truncated pages are purged from the cache.</span>
01201 <span class="comment"></span>
01202 <span class="comment">Arguments:</span>
01203 <span class="comment"></span>
01204 <span class="comment">    FileObject - File Object which was previously supplied to</span>
01205 <span class="comment">                 CcInitializeCacheMap.</span>
01206 <span class="comment"></span>
01207 <span class="comment">    TruncateSize - If specified, the file was truncated to the specified</span>
01208 <span class="comment">                   size, and the cache should be purged accordingly.</span>
01209 <span class="comment"></span>
01210 <span class="comment">    UninitializeEvent - If specified, then the provided event</span>
01211 <span class="comment">                   will be set to the signalled state when the actual flush is</span>
01212 <span class="comment">                   completed.  This is only of interest to file systems that</span>
01213 <span class="comment">                   require that they be notified when a cache flush operation</span>
01214 <span class="comment">                   has completed.  Due to network protocol restrictions, it</span>
01215 <span class="comment">                   is critical that network file systems know exactly when</span>
01216 <span class="comment">                   a cache flush operation completes, by specifying this</span>
01217 <span class="comment">                   event, they can be notified when the cache section is</span>
01218 <span class="comment">                   finally purged if the section is "lazy-deleted".</span>
01219 <span class="comment"></span>
01220 <span class="comment">ReturnValue:</span>
01221 <span class="comment"></span>
01222 <span class="comment">    FALSE if Section was not closed.</span>
01223 <span class="comment">    TRUE if Section was closed.</span>
01224 <span class="comment"></span>
01225 <span class="comment">--*/</span>
01226 
01227 {
01228     KIRQL OldIrql;
01229     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap;
01230     ULONG ActivePage;
01231     ULONG PageIsDirty;
01232     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> ActiveVacb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01233     BOOLEAN SectionClosed = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01234     BOOLEAN SharedListAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01235     <a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html">PPRIVATE_CACHE_MAP</a> PrivateCacheMap;
01236 
01237     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcUninitializeCacheMap:\n"</span>, 0 );
01238     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"    FileObject = %08lx\n"</span>, FileObject );
01239     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"    &amp;TruncateSize = %08lx\n"</span>, TruncateSize );
01240 
01241     <span class="comment">//</span>
01242     <span class="comment">//  Insure release of resources</span>
01243     <span class="comment">//</span>
01244 
01245     <span class="keywordflow">try</span> {
01246 
01247         <span class="comment">//</span>
01248         <span class="comment">//  Serialize Creation/Deletion of all Shared CacheMaps</span>
01249         <span class="comment">//</span>
01250 
01251         <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
01252         SharedListAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01253 
01254         <span class="comment">//</span>
01255         <span class="comment">//  Get pointer to SharedCacheMap via File Object.</span>
01256         <span class="comment">//</span>
01257 
01258         SharedCacheMap = FileObject-&gt;SectionObjectPointer-&gt;SharedCacheMap;
01259         PrivateCacheMap = FileObject-&gt;PrivateCacheMap;
01260 
01261         <span class="comment">//</span>
01262         <span class="comment">//  Decrement Open Count on SharedCacheMap, if we did a cached open.</span>
01263         <span class="comment">//  Also unmap PrivateCacheMap if it is mapped and deallocate it.</span>
01264         <span class="comment">//</span>
01265 
01266         <span class="keywordflow">if</span> (PrivateCacheMap != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01267 
01268             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o2">FileObject</a> == FileObject );
01269             
01270             <a class="code" href="../../d5/d5/cc_8h.html#a69">CcDecrementOpenCount</a>( SharedCacheMap, 'ninU' );
01271 
01272             <span class="comment">//</span>
01273             <span class="comment">//  Remove PrivateCacheMap from list in SharedCacheMap.</span>
01274             <span class="comment">//</span>
01275 
01276             RemoveEntryList( &amp;PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o11">PrivateLinks</a> );
01277 
01278             <span class="comment">//</span>
01279             <span class="comment">//  Free local or allocated PrivateCacheMap</span>
01280             <span class="comment">//</span>
01281 
01282             <span class="keywordflow">if</span> (PrivateCacheMap == &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o39">PrivateCacheMap</a>) {
01283                 PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o0">NodeTypeCode</a> = 0;
01284                 PrivateCacheMap = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01285             }
01286 
01287             FileObject-&gt;PrivateCacheMap = (<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html">PPRIVATE_CACHE_MAP</a>)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01288         }
01289 
01290         <span class="comment">//</span>
01291         <span class="comment">//  Now if we have a SharedCacheMap whose Open Count went to 0, we</span>
01292         <span class="comment">//  have some additional cleanup.</span>
01293         <span class="comment">//</span>
01294 
01295         <span class="keywordflow">if</span> (SharedCacheMap != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01296 
01297             <span class="comment">//</span>
01298             <span class="comment">//  If a Truncate Size was specified, then remember that we want to</span>
01299             <span class="comment">//  truncate the FileSize and purge the unneeded pages when OpenCount</span>
01300             <span class="comment">//  goes to 0.</span>
01301             <span class="comment">//</span>
01302 
01303             <span class="keywordflow">if</span> (ARGUMENT_PRESENT(TruncateSize)) {
01304 
01305                 <span class="keywordflow">if</span> ( (TruncateSize-&gt;QuadPart == 0) &amp;&amp; (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o3">FileSize</a>.QuadPart != 0) ) {
01306                     
01307                     <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, <a class="code" href="../../d5/d5/cc_8h.html#a73">TRUNCATE_REQUIRED</a>);
01308                 
01309                 } <span class="keywordflow">else</span>
01310 
01311                 <span class="comment">//</span>
01312                 <span class="comment">//  If this is the last guy, I can drop the file size down</span>
01313                 <span class="comment">//  now.</span>
01314                 <span class="comment">//</span>
01315 
01316                 <span class="keywordflow">if</span> (IsListEmpty(&amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o29">PrivateList</a>)) {
01317                     SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o3">FileSize</a> = *TruncateSize;
01318                 }
01319             }
01320 
01321             <span class="comment">//</span>
01322             <span class="comment">//  If other file objects are still using this SharedCacheMap,</span>
01323             <span class="comment">//  then we are done now.</span>
01324             <span class="comment">//</span>
01325 
01326             <span class="keywordflow">if</span> (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o2">OpenCount</a> != 0) {
01327 
01328                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"SharedCacheMap OpenCount != 0\n"</span>, 0);
01329 
01330                 <span class="comment">//</span>
01331                 <span class="comment">//  If the caller specified an event to be set when</span>
01332                 <span class="comment">//  the cache uninitialize is completed, set the event</span>
01333                 <span class="comment">//  now, because the uninitialize is complete for this file.</span>
01334                 <span class="comment">//  (Note, we make him wait if he is the last guy.)</span>
01335                 <span class="comment">//</span>
01336 
01337                 <span class="keywordflow">if</span> (ARGUMENT_PRESENT(UninitializeEvent)) {
01338 
01339                     <span class="keywordflow">if</span> (!IsListEmpty(&amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o29">PrivateList</a>)) {
01340                         <a class="code" href="../../d2/d8/eventobj_8c.html#a8">KeSetEvent</a>(&amp;UninitializeEvent-&gt;Event, 0, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
01341                     } <span class="keywordflow">else</span> {
01342                         UninitializeEvent-&gt;Next = SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o34">UninitializeEvent</a>;
01343                         SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o34">UninitializeEvent</a> = UninitializeEvent;
01344                     }
01345                 }
01346 
01347                 <a class="code" href="../../d5/d5/cc_8h.html#a90">try_return</a>( SectionClosed = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
01348             }
01349 
01350             <span class="comment">//</span>
01351             <span class="comment">//  The private cache map list better be empty!</span>
01352             <span class="comment">//</span>
01353 
01354             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(IsListEmpty(&amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o29">PrivateList</a>));
01355 
01356             <span class="comment">//</span>
01357             <span class="comment">//  Set the "uninitialize complete" in the shared cache map</span>
01358             <span class="comment">//  so that CcDeleteSharedCacheMap will delete it.</span>
01359             <span class="comment">//</span>
01360 
01361             <span class="keywordflow">if</span> (ARGUMENT_PRESENT(UninitializeEvent)) {
01362                 UninitializeEvent-&gt;Next = SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o34">UninitializeEvent</a>;
01363                 SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o34">UninitializeEvent</a> = UninitializeEvent;
01364             }
01365 
01366             <span class="comment">//</span>
01367             <span class="comment">//  We are in the process of deleting this cache map.  If the</span>
01368             <span class="comment">//  Lazy Writer is active or the Bcb list is not empty or the Lazy</span>
01369             <span class="comment">//  Writer will hit this SharedCacheMap because we are purging</span>
01370             <span class="comment">//  the file to 0, then get out and let the Lazy Writer clean</span>
01371             <span class="comment">//  up.</span>
01372             <span class="comment">//</span>
01373 
01374             <span class="keywordflow">if</span> ((!<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, <a class="code" href="../../d5/d5/cc_8h.html#a72">PIN_ACCESS</a>) &amp;&amp;
01375                  !ARGUMENT_PRESENT(UninitializeEvent))
01376 
01377                     ||
01378 
01379                 <a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, <a class="code" href="../../d5/d5/cc_8h.html#a74">WRITE_QUEUED</a>)
01380 
01381                     ||
01382 
01383                 (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o20">DirtyPages</a> != 0)) {
01384 
01385                 <span class="comment">//</span>
01386                 <span class="comment">//  Move it to the dirty list so the lazy write scan will</span>
01387                 <span class="comment">//  see it.</span>
01388                 <span class="comment">//</span>
01389 
01390                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, <a class="code" href="../../d5/d5/cc_8h.html#a74">WRITE_QUEUED</a>)) {
01391                     RemoveEntryList( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a> );
01392                     InsertTailList( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a2">CcDirtySharedCacheMapList</a>.<a class="code" href="../../d1/d3/struct__SHARED__CACHE__MAP__LIST__CURSOR.html#o0">SharedCacheMapLinks</a>,
01393                                     &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a> );
01394                 }
01395 
01396                 <span class="comment">//</span>
01397                 <span class="comment">//  Make sure the Lazy Writer will wake up, because we</span>
01398                 <span class="comment">//  want him to delete this SharedCacheMap.</span>
01399                 <span class="comment">//</span>
01400 
01401                 <a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o6">OtherWork</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01402                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o5">ScanActive</a>) {
01403                     <a class="code" href="../../d5/d5/cc_8h.html#a185">CcScheduleLazyWriteScan</a>();
01404                 }
01405 
01406                 <span class="comment">//</span>
01407                 <span class="comment">//  Get the active Vacb if we are going to lazy delete, to</span>
01408                 <span class="comment">//  free it for someone who can use it.</span>
01409                 <span class="comment">//</span>
01410 
01411                 <a class="code" href="../../d5/d5/cc_8h.html#a83">GetActiveVacbAtDpcLevel</a>( SharedCacheMap, ActiveVacb, ActivePage, PageIsDirty );
01412 
01413                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"SharedCacheMap has Bcbs and not purging to 0\n"</span>, 0);
01414 
01415                 <a class="code" href="../../d5/d5/cc_8h.html#a90">try_return</a>( SectionClosed = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
01416             }
01417 
01418             <span class="comment">//</span>
01419             <span class="comment">//  Now we can delete the SharedCacheMap.  If there are any Bcbs,</span>
01420             <span class="comment">//  then we must be truncating to 0, and they will also be deleted.</span>
01421             <span class="comment">//  On return the Shared Cache Map List Spinlock will be released.</span>
01422             <span class="comment">//</span>
01423 
01424             <a class="code" href="../../d5/d8/fssup_8c.html#a11">CcDeleteSharedCacheMap</a>( SharedCacheMap, OldIrql, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
01425 
01426             SharedListAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01427 
01428             <a class="code" href="../../d5/d5/cc_8h.html#a90">try_return</a>( SectionClosed = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
01429         }
01430 
01431         <span class="comment">//</span>
01432         <span class="comment">//  No Shared Cache Map.  To make the file go away, we still need to</span>
01433         <span class="comment">//  purge the section, if one exists.  (And we still need to release</span>
01434         <span class="comment">//  our global list first to avoid deadlocks.)</span>
01435         <span class="comment">//</span>
01436 
01437         <span class="keywordflow">else</span> {
01438             <span class="keywordflow">if</span> (ARGUMENT_PRESENT(TruncateSize) &amp;&amp;
01439                 ( TruncateSize-&gt;QuadPart == 0 ) &amp;&amp;
01440                 (*(PCHAR *)FileObject-&gt;SectionObjectPointer != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
01441 
01442                 <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
01443                 SharedListAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01444 
01445                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d5/d5/cc_8h.html#a57">mm</a>, <span class="stringliteral">"MmPurgeSection:\n"</span>, 0 );
01446                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d5/d5/cc_8h.html#a57">mm</a>, <span class="stringliteral">"    SectionObjectPointer = %08lx\n"</span>,
01447                             FileObject-&gt;SectionObjectPointer );
01448                 <a class="code" href="../../d5/d5/cc_8h.html#a92">DebugTrace2</a>(0, <a class="code" href="../../d5/d5/cc_8h.html#a57">mm</a>, <span class="stringliteral">"    Offset = %08lx\n"</span>,
01449                             TruncateSize-&gt;LowPart,
01450                             TruncateSize-&gt;HighPart );
01451 
01452                 <span class="comment">//</span>
01453                 <span class="comment">//  0 Length means to purge from the TruncateSize on.</span>
01454                 <span class="comment">//</span>
01455 
01456                 <a class="code" href="../../d4/d2/cache_8h.html#a61">CcPurgeCacheSection</a>( FileObject-&gt;SectionObjectPointer,
01457                                      TruncateSize,
01458                                      0,
01459                                      <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
01460             }
01461 
01462             <span class="comment">//</span>
01463             <span class="comment">//  If the caller specified an event to be set when</span>
01464             <span class="comment">//  the cache uninitialize is completed, set the event</span>
01465             <span class="comment">//  now, because the uninitialize is complete for this file.</span>
01466             <span class="comment">//</span>
01467 
01468             <span class="keywordflow">if</span> (ARGUMENT_PRESENT(UninitializeEvent)) {
01469                 <a class="code" href="../../d2/d8/eventobj_8c.html#a8">KeSetEvent</a>(&amp;UninitializeEvent-&gt;Event, 0, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
01470             }
01471 
01472         }
01473 
01474     try_exit: NOTHING;
01475     }
01476     finally {
01477 
01478         <span class="comment">//</span>
01479         <span class="comment">//  Release global resources</span>
01480         <span class="comment">//</span>
01481 
01482         <span class="keywordflow">if</span> (SharedListAcquired) {
01483             <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
01484         }
01485 
01486         <span class="comment">//</span>
01487         <span class="comment">//  Free the active vacb, if we found one.</span>
01488         <span class="comment">//</span>
01489 
01490         <span class="keywordflow">if</span> (ActiveVacb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01491 
01492             <a class="code" href="../../d5/d5/cc_8h.html#a182">CcFreeActiveVacb</a>( ActiveVacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o1">SharedCacheMap</a>, ActiveVacb, ActivePage, PageIsDirty );
01493         }
01494 
01495         <span class="comment">//</span>
01496         <span class="comment">//  Free PrivateCacheMap now that we no longer have the spinlock.</span>
01497         <span class="comment">//</span>
01498 
01499         <span class="keywordflow">if</span> (PrivateCacheMap != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01500             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( PrivateCacheMap );
01501         }
01502     }
01503 
01504     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcUnitializeCacheMap -&gt; %02lx\n"</span>, SectionClosed );
01505 
01506     <span class="keywordflow">return</span> SectionClosed;
01507 
01508 }
01509 
01510 
01511 <span class="comment">//</span>
01512 <span class="comment">//  Internal support routine.</span>
01513 <span class="comment">//</span>
01514 
01515 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01516 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l01517"></a><a class="code" href="../../d5/d8/fssup_8c.html#a11">01517</a> <a class="code" href="../../d5/d8/fssup_8c.html#a11">CcDeleteSharedCacheMap</a> (
01518     IN <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap,
01519     IN KIRQL ListIrql,
01520     IN ULONG ReleaseFile
01521     )
01522 
01523 <span class="comment">/*++</span>
01524 <span class="comment"></span>
01525 <span class="comment">Routine Description:</span>
01526 <span class="comment"></span>
01527 <span class="comment">    The specified SharedCacheMap is removed from the global list of</span>
01528 <span class="comment">    SharedCacheMap's and deleted with all of its related structures.</span>
01529 <span class="comment">    Other objects which were referenced in CcInitializeCacheMap are</span>
01530 <span class="comment">    dereferenced here.</span>
01531 <span class="comment"></span>
01532 <span class="comment">    NOTE:   The CcMasterSpinLock must already be acquired</span>
01533 <span class="comment">            on entry.  It is released on return.</span>
01534 <span class="comment"></span>
01535 <span class="comment">Arguments:</span>
01536 <span class="comment"></span>
01537 <span class="comment">    SharedCacheMap - Pointer to Cache Map to delete</span>
01538 <span class="comment"></span>
01539 <span class="comment">    ListIrql - priority to restore to when releasing shared cache map list</span>
01540 <span class="comment"></span>
01541 <span class="comment">    ReleaseFile - Supplied as nonzero if file was acquired exclusive and</span>
01542 <span class="comment">                  should be released.</span>
01543 <span class="comment"></span>
01544 <span class="comment">ReturnValue:</span>
01545 <span class="comment"></span>
01546 <span class="comment">    None.</span>
01547 <span class="comment"></span>
01548 <span class="comment">--*/</span>
01549 
01550 {
01551     LIST_ENTRY LocalList;
01552     PLIST_ENTRY NextEntry;
01553     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject;
01554     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> ActiveVacb;
01555     ULONG ActivePage;
01556     ULONG PageIsDirty;
01557     KIRQL OldIrql;
01558     <a class="code" href="../../d9/d6/struct__MBCB.html">PMBCB</a> Mbcb;
01559 
01560     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcDeleteSharedCacheMap:\n"</span>, 0 );
01561     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"    SharedCacheMap = %08lx\n"</span>, SharedCacheMap );
01562 
01563     <span class="comment">//</span>
01564     <span class="comment">//  Remove it from the global list and clear the pointer to it via</span>
01565     <span class="comment">//  the File Object.</span>
01566     <span class="comment">//</span>
01567 
01568     RemoveEntryList( &amp;SharedCacheMap-&gt;SharedCacheMapLinks );
01569 
01570     <span class="comment">//</span>
01571     <span class="comment">//  Zero pointer to SharedCacheMap.  Once we have cleared the pointer,</span>
01572     <span class="comment">//  we can/must release the global list to avoid deadlocks.</span>
01573     <span class="comment">//</span>
01574 
01575     FileObject = SharedCacheMap-&gt;FileObject;
01576 
01577     FileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o6">SectionObjectPointer</a>-&gt;<a class="code" href="../../d7/d0/struct__SECTION__OBJECT__POINTERS.html#o1">SharedCacheMap</a> = (<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a>)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01578     <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>( SharedCacheMap-&gt;Flags, <a class="code" href="../../d5/d5/cc_8h.html#a74">WRITE_QUEUED</a> );
01579 
01580     <span class="comment">//</span>
01581     <span class="comment">//  The OpenCount is 0, but we still need to flush out any dangling</span>
01582     <span class="comment">//  cache read or writes.</span>
01583     <span class="comment">//</span>
01584 
01585     <span class="keywordflow">if</span> ((SharedCacheMap-&gt;VacbActiveCount != 0) || (SharedCacheMap-&gt;NeedToZero != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
01586 
01587         <span class="comment">//</span>
01588         <span class="comment">//  We will put it in a local list and set a flag</span>
01589         <span class="comment">//  to keep the Lazy Writer away from it, so that we can wrip it out</span>
01590         <span class="comment">//  below if someone manages to sneak in and set something dirty, etc.</span>
01591         <span class="comment">//  If the file system does not synchronize cleanup calls with an</span>
01592         <span class="comment">//  exclusive on the stream, then this case is possible.</span>
01593         <span class="comment">//</span>
01594 
01595         InitializeListHead( &amp;LocalList );
01596         InsertTailList( &amp;LocalList, &amp;SharedCacheMap-&gt;SharedCacheMapLinks );
01597 
01598         <span class="comment">//</span>
01599         <span class="comment">//  If there is an active Vacb, then nuke it now (before waiting!).</span>
01600         <span class="comment">//</span>
01601 
01602         <a class="code" href="../../d5/d5/cc_8h.html#a83">GetActiveVacbAtDpcLevel</a>( SharedCacheMap, ActiveVacb, ActivePage, PageIsDirty );
01603 
01604         <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( ListIrql );
01605 
01606         <span class="comment">//</span>
01607         <span class="comment">//  No point in saying the page is dirty (which can cause an allocation</span>
01608         <span class="comment">//  failure), since we are deleting this SharedCacheMap anyway.</span>
01609         <span class="comment">//</span>
01610 
01611         <a class="code" href="../../d5/d5/cc_8h.html#a182">CcFreeActiveVacb</a>( SharedCacheMap, ActiveVacb, ActivePage, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
01612 
01613         <span class="keywordflow">while</span> (SharedCacheMap-&gt;VacbActiveCount != 0) {
01614             <a class="code" href="../../d5/d3/vacbsup_8c.html#a19">CcWaitOnActiveCount</a>( SharedCacheMap );
01615         }
01616 
01617         <span class="comment">//</span>
01618         <span class="comment">//  Now in case we hit the rare path where someone moved the</span>
01619         <span class="comment">//  SharedCacheMap again, do a remove again now.  It may be</span>
01620         <span class="comment">//  from our local list or it may be from the dirty list,</span>
01621         <span class="comment">//  but who cares?  The important thing is to remove it in</span>
01622         <span class="comment">//  the case it was the dirty list, since we will delete it</span>
01623         <span class="comment">//  below.</span>
01624         <span class="comment">//</span>
01625 
01626         <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;ListIrql );
01627         RemoveEntryList( &amp;SharedCacheMap-&gt;SharedCacheMapLinks );
01628     }
01629 
01630     <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( ListIrql );
01631 
01632     <span class="comment">//</span>
01633     <span class="comment">//  If there are Bcbs, then empty the list, asserting that none of them</span>
01634     <span class="comment">//  can be pinned now if we have gotten this far!</span>
01635     <span class="comment">//</span>
01636 
01637     NextEntry = SharedCacheMap-&gt;BcbList.Flink;
01638     <span class="keywordflow">while</span> (NextEntry != &amp;SharedCacheMap-&gt;BcbList) {
01639 
01640         <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> Bcb;
01641 
01642         Bcb = (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)CONTAINING_RECORD( NextEntry,
01643                                        <a class="code" href="../../d4/d3/struct__BCB.html">BCB</a>,
01644                                        BcbLinks );
01645         NextEntry = Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o4">BcbLinks</a>.Flink;
01646 
01647         <span class="comment">//</span>
01648         <span class="comment">//  Skip over the pendaflex entries, only removing true Bcbs</span>
01649         <span class="comment">//  so that level teardown doesn't need to special case unhooking</span>
01650         <span class="comment">//  the pendaflex.  This has the side benefit of dramatically</span>
01651         <span class="comment">//  reducing write traffic to memory on teardown of large files.</span>
01652         <span class="comment">//</span>
01653         <span class="comment">//  I really wonder how often we have Bcbs at teardown.  This is</span>
01654         <span class="comment">//  a lot of work that could be avoided otherwise.</span>
01655         <span class="comment">//</span>
01656 
01657         <span class="keywordflow">if</span> (Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o0">NodeTypeCode</a> == <a class="code" href="../../d5/d5/cc_8h.html#a14">CACHE_NTC_BCB</a>) {
01658 
01659             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o9">PinCount</a> == 0 );
01660 
01661             RemoveEntryList( &amp;Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o4">BcbLinks</a> );
01662 
01663             <span class="comment">//</span>
01664             <span class="comment">//  For large metadata streams we unlock the Vacb level when removing.</span>
01665             <span class="comment">//  We do not need spinlocks since no other thread can be accessing</span>
01666             <span class="comment">//  this list when we are deleting the SharedCacheMap.</span>
01667             <span class="comment">//</span>
01668 
01669             <a class="code" href="../../d5/d5/cc_8h.html#a51">CcUnlockVacbLevel</a>( SharedCacheMap, Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o3">FileOffset</a>.QuadPart );
01670 
01671             <span class="comment">//</span>
01672             <span class="comment">//  There is a small window where the data could still be mapped</span>
01673             <span class="comment">//  if (for example) the Lazy Writer collides with a CcCopyWrite</span>
01674             <span class="comment">//  in the foreground, and then someone calls CcUninitializeCacheMap</span>
01675             <span class="comment">//  while the Lazy Writer is active.  This is because the Lazy</span>
01676             <span class="comment">//  Writer biases the pin count.  Deal with that here.</span>
01677             <span class="comment">//</span>
01678 
01679             <span class="keywordflow">if</span> (Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o12">BaseAddress</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01680                 <a class="code" href="../../d5/d3/vacbsup_8c.html#a16">CcFreeVirtualAddress</a>( Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o8">Vacb</a> );
01681             }
01682 
01683             <span class="comment">//</span>
01684             <span class="comment">//  Debug routines used to remove Bcbs from the global list</span>
01685             <span class="comment">//</span>
01686 
01687 <span class="preprocessor">#if LIST_DBG</span>
01688 <span class="preprocessor"></span>
01689             {
01690                 KIRQL OldIrql;
01691 
01692                 ExAcquireSpinLock( &amp;<a class="code" href="../../d5/d5/cc_8h.html#a122">CcBcbSpinLock</a>, &amp;OldIrql );
01693 
01694                 <span class="keywordflow">if</span> (Bcb-&gt;CcBcbLinks.Flink != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01695 
01696                     RemoveEntryList( &amp;Bcb-&gt;CcBcbLinks );
01697                     CcBcbCount -= 1;
01698                 }
01699 
01700                 ExReleaseSpinLock( &amp;<a class="code" href="../../d5/d5/cc_8h.html#a122">CcBcbSpinLock</a>, OldIrql );
01701             }
01702 
01703 <span class="preprocessor">#endif</span>
01704 <span class="preprocessor"></span>
01705             <span class="comment">//</span>
01706             <span class="comment">//  If the Bcb is dirty, we have to synchronize with the Lazy Writer</span>
01707             <span class="comment">//  and reduce the total number of dirty.</span>
01708             <span class="comment">//</span>
01709 
01710             <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;ListIrql );
01711             <span class="keywordflow">if</span> (Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o13">Dirty</a>) {
01712 
01713                 SharedCacheMap-&gt;DirtyPages -= Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o2">ByteLength</a> &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>;
01714                 <a class="code" href="../../d5/d2/cachedat_8c.html#a36">CcTotalDirtyPages</a> -= Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o2">ByteLength</a> &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>;
01715             }
01716 
01717             <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( ListIrql );
01718 
01719             <a class="code" href="../../d5/d5/cc_8h.html#a177">CcDeallocateBcb</a>( Bcb );
01720         }
01721     }
01722 
01723     <span class="comment">//</span>
01724     <span class="comment">//  Call local routine to unmap, and purge if necessary.</span>
01725     <span class="comment">//</span>
01726 
01727     <a class="code" href="../../d5/d8/fssup_8c.html#a5">CcUnmapAndPurge</a>( SharedCacheMap );
01728 
01729     <span class="comment">//</span>
01730     <span class="comment">//  Now release the file now that the purge is done.</span>
01731     <span class="comment">//</span>
01732 
01733     <span class="keywordflow">if</span> (ReleaseFile) {
01734         <a class="code" href="../../d1/d8/fsrtl_8h.html#a108">FsRtlReleaseFile</a>( SharedCacheMap-&gt;FileObject );
01735     }
01736 
01737     <span class="comment">//</span>
01738     <span class="comment">//  Dereference our pointer to the Section and FileObject</span>
01739     <span class="comment">//  (We have to test the Section pointer since CcInitializeCacheMap</span>
01740     <span class="comment">//  calls this routine for error recovery.  Release our global</span>
01741     <span class="comment">//  resource before dereferencing the FileObject to avoid deadlocks.</span>
01742     <span class="comment">//</span>
01743 
01744     <span class="keywordflow">if</span> (SharedCacheMap-&gt;Section != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01745         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( SharedCacheMap-&gt;Section );
01746     }
01747     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( FileObject );
01748 
01749     <span class="comment">//</span>
01750     <span class="comment">//  If there is an Mbcb, deduct any dirty pages and deallocate.</span>
01751     <span class="comment">//</span>
01752 
01753     <span class="keywordflow">if</span> (SharedCacheMap-&gt;Mbcb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01754         <a class="code" href="../../d5/d8/fssup_8c.html#a6">CcDeleteMbcb</a>( SharedCacheMap );
01755     }
01756 
01757     <span class="comment">//</span>
01758     <span class="comment">//  If there was an uninitialize event specified for this shared cache</span>
01759     <span class="comment">//  map, then set it to the signalled state, indicating that we are</span>
01760     <span class="comment">//  removing the section and deleting the shared cache map.</span>
01761     <span class="comment">//</span>
01762 
01763     <span class="keywordflow">if</span> (SharedCacheMap-&gt;UninitializeEvent != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01764         <a class="code" href="../../d4/d6/struct__CACHE__UNINITIALIZE__EVENT.html">PCACHE_UNINITIALIZE_EVENT</a> CUEvent, EventNext;
01765 
01766         CUEvent = SharedCacheMap-&gt;UninitializeEvent;
01767         <span class="keywordflow">while</span> (CUEvent != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01768             EventNext = CUEvent-&gt;<a class="code" href="../../d4/d6/struct__CACHE__UNINITIALIZE__EVENT.html#o0">Next</a>;
01769             <a class="code" href="../../d2/d8/eventobj_8c.html#a8">KeSetEvent</a>(&amp;CUEvent-&gt;<a class="code" href="../../d4/d6/struct__CACHE__UNINITIALIZE__EVENT.html#o1">Event</a>, 0, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
01770             CUEvent = EventNext;
01771         }
01772     }
01773 
01774     <span class="comment">//</span>
01775     <span class="comment">//  Now delete the Vacb vector.</span>
01776     <span class="comment">//</span>
01777 
01778     <span class="keywordflow">if</span> ((SharedCacheMap-&gt;Vacbs != &amp;SharedCacheMap-&gt;InitialVacbs[0])
01779 
01780             &amp;&amp;
01781 
01782         (SharedCacheMap-&gt;Vacbs != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
01783 
01784         <span class="comment">//</span>
01785         <span class="comment">//  If there are Vacb levels, then the Vacb Array better be in an empty state.</span>
01786         <span class="comment">//</span>
01787 
01788         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>((SharedCacheMap-&gt;SectionSize.QuadPart &lt;= <a class="code" href="../../d5/d5/cc_8h.html#a41">VACB_SIZE_OF_FIRST_LEVEL</a>) ||
01789                !<a class="code" href="../../d5/d5/cc_8h.html#a209">IsVacbLevelReferenced</a>( SharedCacheMap, SharedCacheMap-&gt;Vacbs, 1 ));
01790 
01791         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( SharedCacheMap-&gt;Vacbs );
01792     }
01793 
01794     <span class="comment">//</span>
01795     <span class="comment">//  If an event had to be allocated for this SharedCacheMap,</span>
01796     <span class="comment">//  deallocate it.</span>
01797     <span class="comment">//</span>
01798 
01799     <span class="keywordflow">if</span> ((SharedCacheMap-&gt;CreateEvent != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp; (SharedCacheMap-&gt;CreateEvent != &amp;SharedCacheMap-&gt;Event)) {
01800         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( SharedCacheMap-&gt;CreateEvent );
01801     }
01802 
01803     <span class="keywordflow">if</span> ((SharedCacheMap-&gt;WaitOnActiveCount != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp; (SharedCacheMap-&gt;WaitOnActiveCount != &amp;SharedCacheMap-&gt;Event)) {
01804         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( SharedCacheMap-&gt;WaitOnActiveCount );
01805     }
01806 
01807     <span class="comment">//</span>
01808     <span class="comment">//  Deallocate the storeage for the SharedCacheMap.</span>
01809     <span class="comment">//</span>
01810 
01811     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( SharedCacheMap );
01812 
01813     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcDeleteSharedCacheMap -&gt; VOID\n"</span>, 0 );
01814 
01815     <span class="keywordflow">return</span>;
01816 
01817 }
01818 
01819 
01820 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01821"></a><a class="code" href="../../d4/d2/cache_8h.html#a60">01821</a> <a class="code" href="../../d4/d2/cache_8h.html#a60">CcSetFileSizes</a> (
01822     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
01823     IN <a class="code" href="../../d1/d9/struct__CC__FILE__SIZES.html">PCC_FILE_SIZES</a> FileSizes
01824     )
01825 
01826 <span class="comment">/*++</span>
01827 <span class="comment"></span>
01828 <span class="comment">Routine Description:</span>
01829 <span class="comment"></span>
01830 <span class="comment">    This routine must be called whenever a file has been extended to reflect</span>
01831 <span class="comment">    this extension in the cache maps and underlying section.  Calling this</span>
01832 <span class="comment">    routine has a benign effect if the current size of the section is</span>
01833 <span class="comment">    already greater than or equal to the new AllocationSize.</span>
01834 <span class="comment"></span>
01835 <span class="comment">    This routine must also be called whenever the FileSize for a file changes</span>
01836 <span class="comment">    to reflect these changes in the Cache Manager.</span>
01837 <span class="comment"></span>
01838 <span class="comment">    This routine seems rather large, but in the normal case it only acquires</span>
01839 <span class="comment">    a spinlock, updates some fields, and exits.  Less often it will either</span>
01840 <span class="comment">    extend the section, or truncate/purge the file, but it would be unexpected</span>
01841 <span class="comment">    to do both.  On the other hand, the idea of this routine is that it does</span>
01842 <span class="comment">    "everything" required when AllocationSize or FileSize change.</span>
01843 <span class="comment"></span>
01844 <span class="comment">Arguments:</span>
01845 <span class="comment"></span>
01846 <span class="comment">    FileObject - A file object for which CcInitializeCacheMap has been</span>
01847 <span class="comment">                 previously called.</span>
01848 <span class="comment"></span>
01849 <span class="comment">    FileSizes - A pointer to AllocationSize, FileSize and ValidDataLength</span>
01850 <span class="comment">                for the file.  AllocationSize is ignored if it is not larger</span>
01851 <span class="comment">                than the current section size (i.e., it is ignored unless it</span>
01852 <span class="comment">                has grown).  ValidDataLength is not used.</span>
01853 <span class="comment"></span>
01854 <span class="comment"></span>
01855 <span class="comment">Return Value:</span>
01856 <span class="comment"></span>
01857 <span class="comment">    None</span>
01858 <span class="comment"></span>
01859 <span class="comment">--*/</span>
01860 
01861 {
01862     LARGE_INTEGER NewSectionSize;
01863     LARGE_INTEGER NewFileSize;
01864     LARGE_INTEGER NewValidDataLength;
01865     IO_STATUS_BLOCK IoStatus;
01866     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap;
01867     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01868     KIRQL OldIrql;
01869     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> ActiveVacb;
01870     ULONG ActivePage;
01871     ULONG PageIsDirty;
01872 
01873     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcSetFileSizes:\n"</span>, 0 );
01874     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"    FileObject = %08lx\n"</span>, FileObject );
01875     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"    FileSizes = %08lx\n"</span>, FileSizes );
01876 
01877     <span class="comment">//</span>
01878     <span class="comment">//  Make a local copy of the new file size and section size.</span>
01879     <span class="comment">//</span>
01880 
01881     NewSectionSize = FileSizes-&gt;AllocationSize;
01882     NewFileSize = FileSizes-&gt;FileSize;
01883     NewValidDataLength = FileSizes-&gt;ValidDataLength;
01884 
01885     <span class="comment">//</span>
01886     <span class="comment">//  Serialize Creation/Deletion of all Shared CacheMaps</span>
01887     <span class="comment">//</span>
01888 
01889     <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
01890 
01891     <span class="comment">//</span>
01892     <span class="comment">//  Get pointer to SharedCacheMap via File Object.</span>
01893     <span class="comment">//</span>
01894 
01895     SharedCacheMap = FileObject-&gt;SectionObjectPointer-&gt;SharedCacheMap;
01896 
01897     <span class="comment">//</span>
01898     <span class="comment">//  If the file is not cached, just get out.</span>
01899     <span class="comment">//</span>
01900 
01901     <span class="keywordflow">if</span> ((SharedCacheMap == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) || (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o21">Section</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
01902 
01903         <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
01904 
01905         <span class="comment">//</span>
01906         <span class="comment">//  Let's try to purge the file incase this is a truncate.  In the</span>
01907         <span class="comment">//  vast majority of cases when there is no shared cache map, there</span>
01908         <span class="comment">//  is no data section either, so this call will eventually be</span>
01909         <span class="comment">//  no-oped in Mm.</span>
01910         <span class="comment">//</span>
01911 
01912         <span class="comment">//</span>
01913         <span class="comment">//  First flush the first page we are keeping, if it has data, before</span>
01914         <span class="comment">//  we throw it away.</span>
01915         <span class="comment">//</span>
01916 
01917         <span class="keywordflow">if</span> (NewFileSize.LowPart &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1)) {
01918             <a class="code" href="../../d6/d5/flushsec_8c.html#a8">MmFlushSection</a>( FileObject-&gt;SectionObjectPointer, &amp;NewFileSize, 1, &amp;IoStatus, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
01919         }
01920 
01921         <a class="code" href="../../d4/d2/cache_8h.html#a61">CcPurgeCacheSection</a>( FileObject-&gt;SectionObjectPointer,
01922                              &amp;NewFileSize,
01923                              0,
01924                              <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
01925 
01926         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcSetFileSizes -&gt; VOID\n"</span>, 0 );
01927 
01928         <span class="keywordflow">return</span>;
01929     }
01930 
01931     <span class="comment">//</span>
01932     <span class="comment">//  Make call a Noop if file is not mapped, or section already big enough.</span>
01933     <span class="comment">//</span>
01934 
01935     <span class="keywordflow">if</span> ( NewSectionSize.QuadPart &gt; SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o5">SectionSize</a>.QuadPart ) {
01936 
01937         <span class="comment">//</span>
01938         <span class="comment">//  Increment open count to make sure the SharedCacheMap stays around,</span>
01939         <span class="comment">//  then release the spinlock so that we can call Mm.</span>
01940         <span class="comment">//</span>
01941 
01942         <a class="code" href="../../d5/d5/cc_8h.html#a68">CcIncrementOpenCount</a>( SharedCacheMap, '1fSS' );
01943         <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
01944 
01945         <span class="comment">//</span>
01946         <span class="comment">//  Round new section size to pages.</span>
01947         <span class="comment">//</span>
01948 
01949         NewSectionSize.QuadPart = NewSectionSize.QuadPart + (LONGLONG)(<a class="code" href="../../d5/d5/cc_8h.html#a30">DEFAULT_EXTEND_MODULO</a> - 1);
01950         NewSectionSize.LowPart &amp;= ~(<a class="code" href="../../d5/d5/cc_8h.html#a30">DEFAULT_EXTEND_MODULO</a> - 1);
01951 
01952         <span class="comment">//</span>
01953         <span class="comment">//  Use try-finally to make sure we get the open count decremented.</span>
01954         <span class="comment">//</span>
01955 
01956         <span class="keywordflow">try</span> {
01957 
01958             <span class="comment">//</span>
01959             <span class="comment">//  Call MM to extend the section.</span>
01960             <span class="comment">//</span>
01961 
01962             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d5/d5/cc_8h.html#a57">mm</a>, <span class="stringliteral">"MmExtendSection:\n"</span>, 0 );
01963             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d5/d5/cc_8h.html#a57">mm</a>, <span class="stringliteral">"    Section = %08lx\n"</span>, SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o21">Section</a> );
01964             <a class="code" href="../../d5/d5/cc_8h.html#a92">DebugTrace2</a>(0, <a class="code" href="../../d5/d5/cc_8h.html#a57">mm</a>, <span class="stringliteral">"    Size = %08lx, %08lx\n"</span>,
01965                         NewSectionSize.LowPart, NewSectionSize.HighPart );
01966 
01967             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d8/d0/extsect_8c.html#a1">MmExtendSection</a>( SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o21">Section</a>, &amp;NewSectionSize, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
01968 
01969             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
01970 
01971                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, 0, <span class="stringliteral">"Error from MmExtendSection, Status = %08lx\n"</span>,
01972                             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> );
01973 
01974                 <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( <a class="code" href="../../d1/d8/fsrtl_8h.html#a136">FsRtlNormalizeNtstatus</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>,
01975                                                        STATUS_UNEXPECTED_MM_EXTEND_ERR ));
01976             }
01977 
01978             <span class="comment">//</span>
01979             <span class="comment">//  Extend the Vacb array.</span>
01980             <span class="comment">//</span>
01981 
01982             <a class="code" href="../../d5/d3/vacbsup_8c.html#a21">CcExtendVacbArray</a>( SharedCacheMap, NewSectionSize );
01983 
01984         } finally {
01985 
01986             <span class="comment">//</span>
01987             <span class="comment">//  Serialize again to decrement the open count.</span>
01988             <span class="comment">//</span>
01989 
01990             <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
01991 
01992             <a class="code" href="../../d5/d5/cc_8h.html#a69">CcDecrementOpenCount</a>( SharedCacheMap, '1fSF' );
01993 
01994             <span class="keywordflow">if</span> ((SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o2">OpenCount</a> == 0) &amp;&amp;
01995                 !<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, <a class="code" href="../../d5/d5/cc_8h.html#a74">WRITE_QUEUED</a>) &amp;&amp;
01996                 (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o20">DirtyPages</a> == 0)) {
01997 
01998                 <span class="comment">//</span>
01999                 <span class="comment">//  Move to the dirty list.</span>
02000                 <span class="comment">//</span>
02001 
02002                 RemoveEntryList( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a> );
02003                 InsertTailList( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a2">CcDirtySharedCacheMapList</a>.<a class="code" href="../../d1/d3/struct__SHARED__CACHE__MAP__LIST__CURSOR.html#o0">SharedCacheMapLinks</a>,
02004                                 &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a> );
02005 
02006                 <span class="comment">//</span>
02007                 <span class="comment">//  Make sure the Lazy Writer will wake up, because we</span>
02008                 <span class="comment">//  want him to delete this SharedCacheMap.</span>
02009                 <span class="comment">//</span>
02010 
02011                 <a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o6">OtherWork</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02012                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o5">ScanActive</a>) {
02013                     <a class="code" href="../../d5/d5/cc_8h.html#a185">CcScheduleLazyWriteScan</a>();
02014                 }
02015             }
02016 
02017             <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
02018         }
02019 
02020         <span class="comment">//</span>
02021         <span class="comment">//  It is now very unlikely that we have any more work to do, but just</span>
02022         <span class="comment">//  in case we reacquire the spinlock and check again if we are cached.</span>
02023         <span class="comment">//</span>
02024 
02025         <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
02026 
02027         <span class="comment">//</span>
02028         <span class="comment">//  Get pointer to SharedCacheMap via File Object.</span>
02029         <span class="comment">//</span>
02030 
02031         SharedCacheMap = FileObject-&gt;SectionObjectPointer-&gt;SharedCacheMap;
02032 
02033         <span class="comment">//</span>
02034         <span class="comment">//  If the file is not cached, just get out.</span>
02035         <span class="comment">//</span>
02036 
02037         <span class="keywordflow">if</span> (SharedCacheMap == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02038 
02039             <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
02040 
02041             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcSetFileSizes -&gt; VOID\n"</span>, 0 );
02042 
02043             <span class="keywordflow">return</span>;
02044         }
02045     }
02046 
02047     <span class="comment">//</span>
02048     <span class="comment">//  If we are shrinking either of these two sizes, then we must free the</span>
02049     <span class="comment">//  active page, since it may be locked.</span>
02050     <span class="comment">//</span>
02051 
02052     <a class="code" href="../../d5/d5/cc_8h.html#a68">CcIncrementOpenCount</a>( SharedCacheMap, '2fSS' );
02053 
02054     <span class="keywordflow">try</span> {
02055 
02056         <span class="keywordflow">if</span> ( ( NewFileSize.QuadPart &lt; SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o7">ValidDataGoal</a>.QuadPart ) ||
02057              ( NewFileSize.QuadPart &lt; SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o3">FileSize</a>.QuadPart )) {
02058 
02059             <a class="code" href="../../d5/d5/cc_8h.html#a83">GetActiveVacbAtDpcLevel</a>( SharedCacheMap, ActiveVacb, ActivePage, PageIsDirty );
02060 
02061             <span class="keywordflow">if</span> ((ActiveVacb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) || (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o13">NeedToZero</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
02062 
02063                 <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
02064 
02065                 <a class="code" href="../../d5/d5/cc_8h.html#a182">CcFreeActiveVacb</a>( SharedCacheMap, ActiveVacb, ActivePage, PageIsDirty );
02066 
02067                 <span class="comment">//</span>
02068                 <span class="comment">//  Serialize again to reduce ValidDataLength.  It cannot change</span>
02069                 <span class="comment">//  because the caller must have the file exclusive.</span>
02070                 <span class="comment">//</span>
02071 
02072                 <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
02073             }
02074         }
02075 
02076         <span class="comment">//</span>
02077         <span class="comment">//  If the section did not grow, see if the file system supports ValidDataLength,</span>
02078         <span class="comment">//  then update the valid data length in the file system.</span>
02079         <span class="comment">//</span>
02080 
02081         <span class="keywordflow">if</span> ( SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o6">ValidDataLength</a>.QuadPart != MAXLONGLONG ) {
02082 
02083             <span class="keywordflow">if</span> ( NewFileSize.QuadPart &lt; SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o6">ValidDataLength</a>.QuadPart ) {
02084                 SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o6">ValidDataLength</a> = NewFileSize;
02085             }
02086 
02087             <span class="comment">//</span>
02088             <span class="comment">//  Update our notion of ValidDataGoal (how far the file has been written</span>
02089             <span class="comment">//  in the cache) with caller's ValidDataLength.  (Our ValidDataLength controls</span>
02090             <span class="comment">//  when we issue ValidDataLength callbacks.)  *** For now play it safe by</span>
02091             <span class="comment">//  only growing here, which is the historical problem at hand, as with</span>
02092             <span class="comment">//  compressed and uncompressed stream caches.</span>
02093             <span class="comment">//</span>
02094 
02095             <span class="keywordflow">if</span> (NewValidDataLength.QuadPart &gt; SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o7">ValidDataGoal</a>.QuadPart) {
02096                 SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o7">ValidDataGoal</a> = NewValidDataLength;
02097             }
02098         }
02099 
02100         <span class="comment">//</span>
02101         <span class="comment">//  On truncate, be nice guys and actually purge away user data from</span>
02102         <span class="comment">//  the cache.  However, the PinAccess check is important to avoid deadlocks</span>
02103         <span class="comment">//  in Ntfs.</span>
02104         <span class="comment">//</span>
02105         <span class="comment">//  It is also important to check the Vacb Active count.  The caller</span>
02106         <span class="comment">//  must have the file exclusive, therefore, no one else can be actively</span>
02107         <span class="comment">//  doing anything in the file.  Normally the Active count will be zero</span>
02108         <span class="comment">//  (like in a normal call from Set File Info), and we can go ahead and truncate.</span>
02109         <span class="comment">//  However, if the active count is nonzero, chances are this very thread has</span>
02110         <span class="comment">//  something pinned or mapped, and we will deadlock if we try to purge and</span>
02111         <span class="comment">//  wait for the count to go zero.  A rare case of this which deadlocked DaveC</span>
02112         <span class="comment">//  on Christmas Day of 1992, is where Ntfs was trying to convert an attribute</span>
02113         <span class="comment">//  from resident to nonresident - which is a good example of a case where the</span>
02114         <span class="comment">//  purge was not needed.</span>
02115         <span class="comment">//</span>
02116 
02117         <span class="keywordflow">if</span> ( (NewFileSize.QuadPart &lt; SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o3">FileSize</a>.QuadPart ) &amp;&amp;
02118             !<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, <a class="code" href="../../d5/d5/cc_8h.html#a72">PIN_ACCESS</a>) &amp;&amp;
02119             (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o16">VacbActiveCount</a> == 0)) {
02120 
02121             <span class="comment">//</span>
02122             <span class="comment">//  Release the spinlock so that we can call Mm.</span>
02123             <span class="comment">//</span>
02124 
02125             <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
02126 
02127             <span class="comment">//</span>
02128             <span class="comment">//  If we are actually truncating to zero (a size which has particular</span>
02129             <span class="comment">//  meaning to the Lazy Writer scan!), then we must reset the Mbcb if</span>
02130             <span class="comment">//  there is one, so that we do not keep dirty pages around forever.</span>
02131             <span class="comment">//</span>
02132 
02133             <span class="keywordflow">if</span> ((NewFileSize.QuadPart == 0) &amp;&amp; (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o19">Mbcb</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
02134                 <a class="code" href="../../d5/d8/fssup_8c.html#a6">CcDeleteMbcb</a>( SharedCacheMap );
02135             }
02136 
02137             <a class="code" href="../../d5/d8/fssup_8c.html#a7">CcPurgeAndClearCacheSection</a>( SharedCacheMap, &amp;NewFileSize );
02138 
02139             <span class="comment">//</span>
02140             <span class="comment">//  Serialize again to decrement the open count.</span>
02141             <span class="comment">//</span>
02142 
02143             <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
02144         }
02145 
02146     } finally {
02147 
02148         <span class="comment">//</span>
02149         <span class="comment">//  We should only be raising without owning the spinlock.</span>
02150         <span class="comment">//</span>
02151 
02152         <span class="keywordflow">if</span> (AbnormalTermination()) {
02153 
02154             <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
02155         }
02156 
02157         <a class="code" href="../../d5/d5/cc_8h.html#a69">CcDecrementOpenCount</a>( SharedCacheMap, '2fSF' );
02158 
02159         SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o3">FileSize</a> = NewFileSize;
02160 
02161         <span class="keywordflow">if</span> ((SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o2">OpenCount</a> == 0) &amp;&amp;
02162             !<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, <a class="code" href="../../d5/d5/cc_8h.html#a74">WRITE_QUEUED</a>) &amp;&amp;
02163             (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o20">DirtyPages</a> == 0)) {
02164 
02165             <span class="comment">//</span>
02166             <span class="comment">//  Move to the dirty list.</span>
02167             <span class="comment">//</span>
02168 
02169             RemoveEntryList( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a> );
02170             InsertTailList( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a2">CcDirtySharedCacheMapList</a>.<a class="code" href="../../d1/d3/struct__SHARED__CACHE__MAP__LIST__CURSOR.html#o0">SharedCacheMapLinks</a>,
02171                             &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a> );
02172 
02173             <span class="comment">//</span>
02174             <span class="comment">//  Make sure the Lazy Writer will wake up, because we</span>
02175             <span class="comment">//  want him to delete this SharedCacheMap.</span>
02176             <span class="comment">//</span>
02177 
02178             <a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o6">OtherWork</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02179             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o5">ScanActive</a>) {
02180                 <a class="code" href="../../d5/d5/cc_8h.html#a185">CcScheduleLazyWriteScan</a>();
02181             }
02182         }
02183 
02184         <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
02185     }
02186 
02187     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcSetFileSizes -&gt; VOID\n"</span>, 0 );
02188 
02189     <span class="keywordflow">return</span>;
02190 }
02191 
02192 
02193 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l02194"></a><a class="code" href="../../d5/d8/fssup_8c.html#a7">02194</a> <a class="code" href="../../d5/d8/fssup_8c.html#a7">CcPurgeAndClearCacheSection</a> (
02195     IN <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap,
02196     IN PLARGE_INTEGER FileOffset
02197     )
02198 
02199 <span class="comment">/*++</span>
02200 <span class="comment"></span>
02201 <span class="comment">Routine Description:</span>
02202 <span class="comment"></span>
02203 <span class="comment">    This routine calls CcPurgeCacheSection after zeroing the end any</span>
02204 <span class="comment">    partial page at the start of the range.  If the file is not cached</span>
02205 <span class="comment">    it flushes this page before the purge.</span>
02206 <span class="comment"></span>
02207 <span class="comment">Arguments:</span>
02208 <span class="comment"></span>
02209 <span class="comment">    SectionObjectPointer - A pointer to the Section Object Pointers</span>
02210 <span class="comment">                           structure in the nonpaged Fcb.</span>
02211 <span class="comment"></span>
02212 <span class="comment">    FileOffset - Offset from which file should be purged - rounded down</span>
02213 <span class="comment">               to page boundary.  If NULL, purge the entire file.</span>
02214 <span class="comment"></span>
02215 <span class="comment">ReturnValue:</span>
02216 <span class="comment"></span>
02217 <span class="comment">    FALSE - if the section was not successfully purged</span>
02218 <span class="comment">    TRUE - if the section was successfully purged</span>
02219 <span class="comment"></span>
02220 <span class="comment">--*/</span>
02221 
02222 {
02223     ULONG TempLength, Length;
02224     LARGE_INTEGER LocalFileOffset;
02225     IO_STATUS_BLOCK IoStatus;
02226     PVOID TempVa;
02227     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> Vacb;
02228 
02229     <span class="comment">//</span>
02230     <span class="comment">//  If a range was specified, then we have to see if we need to</span>
02231     <span class="comment">//  save any user data before purging.</span>
02232     <span class="comment">//</span>
02233 
02234     <span class="keywordflow">if</span> ((FileOffset-&gt;LowPart &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1)) != 0) {
02235 
02236         <span class="comment">//</span>
02237         <span class="comment">//  Switch to LocalFileOffset.  We do it this way because we</span>
02238         <span class="comment">//  still pass it on as an optional parameter.</span>
02239         <span class="comment">//</span>
02240 
02241         LocalFileOffset = *FileOffset;
02242         FileOffset = &amp;LocalFileOffset;
02243 
02244         <span class="comment">//</span>
02245         <span class="comment">//  If the file is cached, then we can actually zero the data to</span>
02246         <span class="comment">//  be purged in memory, and not purge those pages.  This is a huge</span>
02247         <span class="comment">//  savings, because sometimes the flushes in the other case cause</span>
02248         <span class="comment">//  us to kill lots of stack, time and I/O doing CcZeroData in especially</span>
02249         <span class="comment">//  large user-mapped files.</span>
02250         <span class="comment">//</span>
02251 
02252         <span class="keywordflow">if</span> ((SharedCacheMap-&gt;Section != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
02253             (SharedCacheMap-&gt;Vacbs != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
02254 
02255             <span class="comment">//</span>
02256             <span class="comment">//  First zero the first page we are keeping, if it has data, and</span>
02257             <span class="comment">//  adjust FileOffset and Length to allow it to stay.</span>
02258             <span class="comment">//</span>
02259 
02260             TempLength = <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - (FileOffset-&gt;LowPart &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1));
02261 
02262             TempVa = <a class="code" href="../../d5/d3/vacbsup_8c.html#a15">CcGetVirtualAddress</a>( SharedCacheMap, *FileOffset, &amp;Vacb, &amp;Length );
02263 
02264             <span class="keywordflow">try</span> {
02265 
02266                 <span class="comment">//</span>
02267                 <span class="comment">//  Do not map and zero the page if we are not reducing our notion</span>
02268                 <span class="comment">//  of Valid Data, because that does two bad things.  First CcSetDirtyInMask</span>
02269                 <span class="comment">//  will arbitrarily smash up ValidDataGoal (causing a potential invalid</span>
02270                 <span class="comment">//  CcSetValidData call).  Secondly, if the Lazy Writer writes the last</span>
02271                 <span class="comment">//  page ahead of another flush through MM, then the file system will</span>
02272                 <span class="comment">//  never see a write from MM, and will not include the last page in</span>
02273                 <span class="comment">//  ValidDataLength on disk.</span>
02274                 <span class="comment">//</span>
02275 
02276                 RtlZeroMemory( TempVa, TempLength );
02277 
02278                 <span class="keywordflow">if</span> (FileOffset-&gt;QuadPart &lt;= SharedCacheMap-&gt;ValidDataGoal.QuadPart) {
02279 
02280                     <span class="comment">//</span>
02281                     <span class="comment">//  Make sure the Lazy Writer writes it.</span>
02282                     <span class="comment">//</span>
02283 
02284                     <a class="code" href="../../d5/d5/cc_8h.html#a179">CcSetDirtyInMask</a>( SharedCacheMap, FileOffset, TempLength );
02285 
02286                 <span class="comment">//</span>
02287                 <span class="comment">//  Otherwise, we are mapped, so make sure at least that Mm</span>
02288                 <span class="comment">//  knows the page is dirty since we zeroed it.</span>
02289                 <span class="comment">//</span>
02290 
02291                 } <span class="keywordflow">else</span> {
02292 
02293                     <a class="code" href="../../d5/d6/iosup_8c.html#a74">MmSetAddressRangeModified</a>( TempVa, 1 );
02294                 }
02295 
02296                 FileOffset-&gt;QuadPart += (LONGLONG)TempLength;
02297 
02298             <span class="comment">//</span>
02299             <span class="comment">//  If we get any kind of error, like failing to read the page from</span>
02300             <span class="comment">//  the network, just charge on.  Note that we only read it in order</span>
02301             <span class="comment">//  to zero it and avoid the flush below, so if we cannot read it</span>
02302             <span class="comment">//  there is really no stale data problem.</span>
02303             <span class="comment">//</span>
02304 
02305             } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
02306 
02307                 NOTHING;
02308             }
02309 
02310             <a class="code" href="../../d5/d3/vacbsup_8c.html#a16">CcFreeVirtualAddress</a>( Vacb );
02311 
02312         } <span class="keywordflow">else</span> {
02313 
02314             <span class="comment">//</span>
02315             <span class="comment">//  First flush the first page we are keeping, if it has data, before</span>
02316             <span class="comment">//  we throw it away.</span>
02317             <span class="comment">//</span>
02318 
02319             <a class="code" href="../../d6/d5/flushsec_8c.html#a8">MmFlushSection</a>( SharedCacheMap-&gt;FileObject-&gt;SectionObjectPointer, FileOffset, 1, &amp;IoStatus, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
02320         }
02321     }
02322 
02323     <a class="code" href="../../d4/d2/cache_8h.html#a61">CcPurgeCacheSection</a>( SharedCacheMap-&gt;FileObject-&gt;SectionObjectPointer,
02324                          FileOffset,
02325                          0,
02326                          <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
02327 }
02328 
02329 
02330 BOOLEAN
<a name="l02331"></a><a class="code" href="../../d4/d2/cache_8h.html#a61">02331</a> <a class="code" href="../../d4/d2/cache_8h.html#a61">CcPurgeCacheSection</a> (
02332     IN <a class="code" href="../../d7/d0/struct__SECTION__OBJECT__POINTERS.html">PSECTION_OBJECT_POINTERS</a> SectionObjectPointer,
02333     IN PLARGE_INTEGER FileOffset,
02334     IN ULONG Length,
02335     IN BOOLEAN UninitializeCacheMaps
02336     )
02337 
02338 <span class="comment">/*++</span>
02339 <span class="comment"></span>
02340 <span class="comment">Routine Description:</span>
02341 <span class="comment"></span>
02342 <span class="comment">    This routine may be called to force a purge of the cache section,</span>
02343 <span class="comment">    even if it is cached.  Note, if a user has the file mapped, then the purge</span>
02344 <span class="comment">    will *not* take effect, and this must be considered part of normal application</span>
02345 <span class="comment">    interaction.  The purpose of purge is to throw away potentially nonzero</span>
02346 <span class="comment">    data, so that it will be read in again and presumably zeroed.  This is</span>
02347 <span class="comment">    not really a security issue, but rather an effort to not confuse the</span>
02348 <span class="comment">    application when it sees nonzero data.  We cannot help the fact that</span>
02349 <span class="comment">    a user-mapped view forces us to hang on to stale data.</span>
02350 <span class="comment"></span>
02351 <span class="comment">    This routine is intended to be called whenever previously written</span>
02352 <span class="comment">    data is being truncated from the file, and the file is not being</span>
02353 <span class="comment">    deleted.</span>
02354 <span class="comment"></span>
02355 <span class="comment">    The file must be acquired exclusive in order to call this routine.</span>
02356 <span class="comment"></span>
02357 <span class="comment">Arguments:</span>
02358 <span class="comment"></span>
02359 <span class="comment">    SectionObjectPointer - A pointer to the Section Object Pointers</span>
02360 <span class="comment">                           structure in the nonpaged Fcb.</span>
02361 <span class="comment"></span>
02362 <span class="comment">    FileOffset - Offset from which file should be purged - rounded down</span>
02363 <span class="comment">               to page boundary.  If NULL, purge the entire file.</span>
02364 <span class="comment"></span>
02365 <span class="comment">    Length - Defines the length of the byte range to purge, starting at</span>
02366 <span class="comment">             FileOffset.  This parameter is ignored if FileOffset is</span>
02367 <span class="comment">             specified as NULL.  If FileOffset is specified and Length</span>
02368 <span class="comment">             is 0, then purge from FileOffset to the end of the file.</span>
02369 <span class="comment"></span>
02370 <span class="comment">    UninitializeCacheMaps - If TRUE, we should uninitialize all the private</span>
02371 <span class="comment">                            cache maps before purging the data.</span>
02372 <span class="comment"></span>
02373 <span class="comment">ReturnValue:</span>
02374 <span class="comment"></span>
02375 <span class="comment">    FALSE - if the section was not successfully purged</span>
02376 <span class="comment">    TRUE - if the section was successfully purged</span>
02377 <span class="comment"></span>
02378 <span class="comment">--*/</span>
02379 
02380 {
02381     KIRQL OldIrql;
02382     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap;
02383     <a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html">PPRIVATE_CACHE_MAP</a> PrivateCacheMap;
02384     ULONG ActivePage;
02385     ULONG PageIsDirty;
02386     BOOLEAN PurgeWorked = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02387     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> Vacb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02388 
02389     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcPurgeCacheSection:\n"</span>, 0 );
02390     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d5/d5/cc_8h.html#a57">mm</a>, <span class="stringliteral">"    SectionObjectPointer = %08lx\n"</span>, SectionObjectPointer );
02391     <a class="code" href="../../d5/d5/cc_8h.html#a92">DebugTrace2</a>(0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"    FileOffset = %08lx, %08lx\n"</span>,
02392                             ARGUMENT_PRESENT(FileOffset) ? FileOffset-&gt;LowPart
02393                                                          : 0,
02394                             ARGUMENT_PRESENT(FileOffset) ? FileOffset-&gt;HighPart
02395                                                          : 0 );
02396     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"    Length = %08lx\n"</span>, Length );
02397 
02398 
02399     <span class="comment">//</span>
02400     <span class="comment">//  If you want us to uninitialize cache maps, the RtlZeroMemory paths</span>
02401     <span class="comment">//  below depend on actually having to purge something after zeroing.</span>
02402     <span class="comment">//</span>
02403 
02404     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(!UninitializeCacheMaps || (Length == 0) || (Length &gt;= <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> * 2));
02405 
02406     <span class="comment">//</span>
02407     <span class="comment">//  Serialize Creation/Deletion of all Shared CacheMaps</span>
02408     <span class="comment">//</span>
02409 
02410     <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
02411 
02412     <span class="comment">//</span>
02413     <span class="comment">//  Get pointer to SharedCacheMap via File Object.</span>
02414     <span class="comment">//</span>
02415 
02416     SharedCacheMap = SectionObjectPointer-&gt;SharedCacheMap;
02417 
02418     <span class="comment">//</span>
02419     <span class="comment">//  Increment open count to make sure the SharedCacheMap stays around,</span>
02420     <span class="comment">//  then release the spinlock so that we can call Mm.</span>
02421     <span class="comment">//</span>
02422 
02423     <span class="keywordflow">if</span> (SharedCacheMap != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02424 
02425         <a class="code" href="../../d5/d5/cc_8h.html#a68">CcIncrementOpenCount</a>( SharedCacheMap, 'scPS' );
02426 
02427         <span class="comment">//</span>
02428         <span class="comment">//  If there is an active Vacb, then nuke it now (before waiting!).</span>
02429         <span class="comment">//</span>
02430 
02431         <a class="code" href="../../d5/d5/cc_8h.html#a83">GetActiveVacbAtDpcLevel</a>( SharedCacheMap, Vacb, ActivePage, PageIsDirty );
02432     }
02433 
02434     <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
02435 
02436     <span class="keywordflow">if</span> (Vacb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02437 
02438         <a class="code" href="../../d5/d5/cc_8h.html#a182">CcFreeActiveVacb</a>( SharedCacheMap, Vacb, ActivePage, PageIsDirty );
02439     }
02440 
02441     <span class="comment">//</span>
02442     <span class="comment">//  Use try-finally to insure cleanup of the Open Count and Vacb on the</span>
02443     <span class="comment">//  way out.</span>
02444     <span class="comment">//</span>
02445 
02446     <span class="keywordflow">try</span> {
02447 
02448         <span class="comment">//</span>
02449         <span class="comment">//  Increment open count to make sure the SharedCacheMap stays around,</span>
02450         <span class="comment">//  then release the spinlock so that we can call Mm.</span>
02451         <span class="comment">//</span>
02452 
02453         <span class="keywordflow">if</span> (SharedCacheMap != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02454 
02455             <span class="comment">//</span>
02456             <span class="comment">// Now loop to make sure that no one is currently caching the file.</span>
02457             <span class="comment">//</span>
02458 
02459             <span class="keywordflow">if</span> (UninitializeCacheMaps) {
02460 
02461                 <span class="keywordflow">while</span> (!IsListEmpty( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o29">PrivateList</a> )) {
02462 
02463                     PrivateCacheMap = CONTAINING_RECORD( SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o29">PrivateList</a>.Flink,
02464                                                          <a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html">PRIVATE_CACHE_MAP</a>,
02465                                                          PrivateLinks );
02466 
02467                     <a class="code" href="../../d4/d2/cache_8h.html#a59">CcUninitializeCacheMap</a>( PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o2">FileObject</a>, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
02468                 }
02469             }
02470 
02471             <span class="comment">//</span>
02472             <span class="comment">//  Now, let's unmap and purge here.</span>
02473             <span class="comment">//</span>
02474             <span class="comment">//  We still need to wait for any dangling cache read or writes.</span>
02475             <span class="comment">//</span>
02476             <span class="comment">//  In fact we have to loop and wait because the lazy writer can</span>
02477             <span class="comment">//  sneak in and do an CcGetVirtualAddressIfMapped, and we are not</span>
02478             <span class="comment">//  synchronized.</span>
02479             <span class="comment">//</span>
02480 
02481             <span class="keywordflow">while</span> ((SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o9">Vacbs</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
02482                    !<a class="code" href="../../d5/d3/vacbsup_8c.html#a22">CcUnmapVacbArray</a>( SharedCacheMap, FileOffset, Length, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> )) {
02483 
02484                 <a class="code" href="../../d5/d3/vacbsup_8c.html#a19">CcWaitOnActiveCount</a>( SharedCacheMap );
02485             }
02486         }
02487 
02488         <span class="comment">//</span>
02489         <span class="comment">//  Purge failures are extremely rare if there are no user mapped sections.</span>
02490         <span class="comment">//  However, it is possible that we will get one from our own mapping, if</span>
02491         <span class="comment">//  the file is being lazy deleted from a previous open.  For that case</span>
02492         <span class="comment">//  we wait here until the purge succeeds, so that we are not left with</span>
02493         <span class="comment">//  old user file data.  Although Length is actually invariant in this loop,</span>
02494         <span class="comment">//  we do need to keep checking that we are allowed to truncate in case a</span>
02495         <span class="comment">//  user maps the file during a delay.</span>
02496         <span class="comment">//</span>
02497 
02498         <span class="keywordflow">while</span> (!(PurgeWorked = <a class="code" href="../../d6/d5/flushsec_8c.html#a12">MmPurgeSection</a>(SectionObjectPointer,
02499                                               FileOffset,
02500                                               Length,
02501                                               (BOOLEAN)((SharedCacheMap !=<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
02502                                                         ARGUMENT_PRESENT(FileOffset)))) &amp;&amp;
02503                (Length == 0) &amp;&amp;
02504                <a class="code" href="../../d5/d5/sectsup_8c.html#a30">MmCanFileBeTruncated</a>(SectionObjectPointer, FileOffset)) {
02505 
02506             (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>)<a class="code" href="../../d1/d7/wait_8c.html#a2">KeDelayExecutionThread</a>( <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a16">CcCollisionDelay</a> );
02507         }
02508     
02509     } finally {
02510 
02511         <span class="comment">//</span>
02512         <span class="comment">//  Reduce the open count on the SharedCacheMap if there was one.</span>
02513         <span class="comment">//</span>
02514 
02515         <span class="keywordflow">if</span> (SharedCacheMap != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02516 
02517             <span class="comment">//</span>
02518             <span class="comment">//  Serialize again to decrement the open count.</span>
02519             <span class="comment">//</span>
02520 
02521             <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
02522 
02523             <a class="code" href="../../d5/d5/cc_8h.html#a69">CcDecrementOpenCount</a>( SharedCacheMap, 'scPF' );
02524 
02525             <span class="keywordflow">if</span> ((SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o2">OpenCount</a> == 0) &amp;&amp;
02526                 !<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, <a class="code" href="../../d5/d5/cc_8h.html#a74">WRITE_QUEUED</a>) &amp;&amp;
02527                 (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o20">DirtyPages</a> == 0)) {
02528 
02529                 <span class="comment">//</span>
02530                 <span class="comment">//  Move to the dirty list.</span>
02531                 <span class="comment">//</span>
02532 
02533                 RemoveEntryList( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a> );
02534                 InsertTailList( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a2">CcDirtySharedCacheMapList</a>.<a class="code" href="../../d1/d3/struct__SHARED__CACHE__MAP__LIST__CURSOR.html#o0">SharedCacheMapLinks</a>,
02535                                 &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a> );
02536 
02537                 <span class="comment">//</span>
02538                 <span class="comment">//  Make sure the Lazy Writer will wake up, because we</span>
02539                 <span class="comment">//  want him to delete this SharedCacheMap.</span>
02540                 <span class="comment">//</span>
02541 
02542                 <a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o6">OtherWork</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02543                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o5">ScanActive</a>) {
02544                     <a class="code" href="../../d5/d5/cc_8h.html#a185">CcScheduleLazyWriteScan</a>();
02545                 }
02546             }
02547 
02548             <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
02549         }
02550     }
02551 
02552     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcPurgeCacheSection -&gt; %02lx\n"</span>, PurgeWorked );
02553 
02554     <span class="keywordflow">return</span> PurgeWorked;
02555 }
02556 
02557 
02558 <span class="comment">//</span>
02559 <span class="comment">//  Internal support routine.</span>
02560 <span class="comment">//</span>
02561 
02562 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l02563"></a><a class="code" href="../../d5/d8/fssup_8c.html#a5">02563</a> <a class="code" href="../../d5/d8/fssup_8c.html#a5">CcUnmapAndPurge</a>(
02564     IN <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap
02565     )
02566 
02567 <span class="comment">/*++</span>
02568 <span class="comment"></span>
02569 <span class="comment">Routine Description:</span>
02570 <span class="comment"></span>
02571 <span class="comment">    This routine may be called to unmap and purge a section, causing Memory</span>
02572 <span class="comment">    Management to throw the pages out and reset his notion of file size.</span>
02573 <span class="comment"></span>
02574 <span class="comment">Arguments:</span>
02575 <span class="comment"></span>
02576 <span class="comment">    SharedCacheMap - Pointer to SharedCacheMap of section to purge.</span>
02577 <span class="comment"></span>
02578 <span class="comment">Return Value:</span>
02579 <span class="comment"></span>
02580 <span class="comment">    None.</span>
02581 <span class="comment"></span>
02582 <span class="comment">--*/</span>
02583 
02584 {
02585     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject;
02586     KIRQL OldIrql;
02587 
02588     FileObject = SharedCacheMap-&gt;FileObject;
02589 
02590     <span class="comment">//</span>
02591     <span class="comment">//  Unmap all Vacbs</span>
02592     <span class="comment">//</span>
02593 
02594     <span class="keywordflow">if</span> (SharedCacheMap-&gt;Vacbs != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02595         (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>)<a class="code" href="../../d5/d3/vacbsup_8c.html#a22">CcUnmapVacbArray</a>( SharedCacheMap, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, 0, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
02596     }
02597 
02598     <span class="comment">//</span>
02599     <span class="comment">//  Now that the file is unmapped, we can purge the truncated</span>
02600     <span class="comment">//  pages from memory, if TRUNCATE_REQUIRED.  Note that since the</span>
02601     <span class="comment">//  entire section is being purged (FileSize == NULL), the purge</span>
02602     <span class="comment">//  and subsequent delete  of the SharedCacheMap should drop</span>
02603     <span class="comment">//  all references on the section and file object clearing the</span>
02604     <span class="comment">//  way for the Close Call and actual file delete to occur</span>
02605     <span class="comment">//  immediately.</span>
02606     <span class="comment">//</span>
02607 
02608     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;Flags, <a class="code" href="../../d5/d5/cc_8h.html#a73">TRUNCATE_REQUIRED</a>)) {
02609 
02610         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d5/d5/cc_8h.html#a57">mm</a>, <span class="stringliteral">"MmPurgeSection:\n"</span>, 0 );
02611         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d5/d5/cc_8h.html#a57">mm</a>, <span class="stringliteral">"    SectionObjectPointer = %08lx\n"</span>,
02612                     FileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o6">SectionObjectPointer</a> );
02613         <a class="code" href="../../d5/d5/cc_8h.html#a92">DebugTrace2</a>(0, <a class="code" href="../../d5/d5/cc_8h.html#a57">mm</a>, <span class="stringliteral">"    Offset = %08lx\n"</span>,
02614                     SharedCacheMap-&gt;FileSize.LowPart,
02615                     SharedCacheMap-&gt;FileSize.HighPart );
02616 
02617         <a class="code" href="../../d4/d2/cache_8h.html#a61">CcPurgeCacheSection</a>( FileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o6">SectionObjectPointer</a>,
02618                              <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
02619                              0,
02620                              <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
02621     }
02622 }
02623 
02624 
02625 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l02626"></a><a class="code" href="../../d5/d8/fssup_8c.html#a6">02626</a> <a class="code" href="../../d5/d8/fssup_8c.html#a6">CcDeleteMbcb</a>(
02627     IN <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap
02628     )
02629 
02630 <span class="comment">/*++</span>
02631 <span class="comment"></span>
02632 <span class="comment">Routine Description:</span>
02633 <span class="comment"></span>
02634 <span class="comment">    This routine may be called to reset the Mbcb for a stream to say</span>
02635 <span class="comment">    there are no dirty pages, and free all auxillary allocation.</span>
02636 <span class="comment"></span>
02637 <span class="comment">Arguments:</span>
02638 <span class="comment"></span>
02639 <span class="comment">    SharedCacheMap - Pointer to SharedCacheMap.</span>
02640 <span class="comment"></span>
02641 <span class="comment">Return Value:</span>
02642 <span class="comment"></span>
02643 <span class="comment">    None.</span>
02644 <span class="comment"></span>
02645 <span class="comment">--*/</span>
02646 
02647 {
02648     <a class="code" href="../../d9/d6/struct__MBCB.html">PMBCB</a> Mbcb;
02649     <a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html">PBITMAP_RANGE</a> BitmapRange;
02650     KIRQL OldIrql;
02651     ULONG DoDrain = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02652 
02653     ExAcquireSpinLock( &amp;SharedCacheMap-&gt;BcbSpinLock, &amp;OldIrql );
02654 
02655     Mbcb = SharedCacheMap-&gt;Mbcb;
02656 
02657     <span class="comment">//</span>
02658     <span class="comment">//  Is there an Mbcb?</span>
02659     <span class="comment">//</span>
02660 
02661     <span class="keywordflow">if</span> (Mbcb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02662 
02663         <span class="comment">//</span>
02664         <span class="comment">//  First deduct the dirty pages we are getting rid of.</span>
02665         <span class="comment">//</span>
02666 
02667         <a class="code" href="../../d5/d5/cc_8h.html#a2">CcAcquireMasterLockAtDpcLevel</a>();
02668         <a class="code" href="../../d5/d2/cachedat_8c.html#a36">CcTotalDirtyPages</a> -= Mbcb-&gt;<a class="code" href="../../d9/d6/struct__MBCB.html#o3">DirtyPages</a>;
02669         SharedCacheMap-&gt;DirtyPages -= Mbcb-&gt;<a class="code" href="../../d9/d6/struct__MBCB.html#o3">DirtyPages</a>;
02670         <a class="code" href="../../d5/d5/cc_8h.html#a3">CcReleaseMasterLockFromDpcLevel</a>();
02671 
02672         <span class="comment">//</span>
02673         <span class="comment">//  Now loop through all of the ranges.</span>
02674         <span class="comment">//</span>
02675 
02676         <span class="keywordflow">while</span> (!IsListEmpty(&amp;Mbcb-&gt;<a class="code" href="../../d9/d6/struct__MBCB.html#o5">BitmapRanges</a>)) {
02677 
02678             <span class="comment">//</span>
02679             <span class="comment">//  Get next range and remove it from the list.</span>
02680             <span class="comment">//</span>
02681 
02682             BitmapRange = (<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html">PBITMAP_RANGE</a>)CONTAINING_RECORD( Mbcb-&gt;<a class="code" href="../../d9/d6/struct__MBCB.html#o5">BitmapRanges</a>.Flink,
02683                                                             <a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html">BITMAP_RANGE</a>,
02684                                                             Links );
02685 
02686             RemoveEntryList( &amp;BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o0">Links</a> );
02687 
02688             <span class="comment">//</span>
02689             <span class="comment">//  If there is a bitmap, and it is not the initial embedded one, then</span>
02690             <span class="comment">//  delete it.</span>
02691             <span class="comment">//</span>
02692 
02693             <span class="keywordflow">if</span> ((BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o5">Bitmap</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
02694                 (BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o5">Bitmap</a> != (PULONG)&amp;Mbcb-&gt;<a class="code" href="../../d9/d6/struct__MBCB.html#o8">BitmapRange2</a>)) {
02695 
02696                 DoDrain = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02697 
02698                 <span class="comment">//</span>
02699                 <span class="comment">//  Usually the bitmap is all zeros at this point, but it may not be.</span>
02700                 <span class="comment">//</span>
02701 
02702                 <span class="keywordflow">if</span> (BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o4">DirtyPages</a> != 0) {
02703                     RtlZeroMemory( BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o5">Bitmap</a>, <a class="code" href="../../d5/d5/cc_8h.html#a43">MBCB_BITMAP_BLOCK_SIZE</a> );
02704                 }
02705                 <a class="code" href="../../d5/d5/cc_8h.html#a6">CcAcquireVacbLockAtDpcLevel</a>();
02706                 <a class="code" href="../../d5/d5/cc_8h.html#a207">CcDeallocateVacbLevel</a>( (<a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> *)BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o5">Bitmap</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
02707                 <a class="code" href="../../d5/d5/cc_8h.html#a7">CcReleaseVacbLockFromDpcLevel</a>();
02708             }
02709 
02710             <span class="comment">//</span>
02711             <span class="comment">//  If the range is not one of the initial embedded ranges, then delete it.</span>
02712             <span class="comment">//</span>
02713 
02714             <span class="keywordflow">if</span> ((BitmapRange &lt; (<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html">PBITMAP_RANGE</a>)Mbcb) &amp;&amp;
02715                 (BitmapRange &gt; (<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html">PBITMAP_RANGE</a>)((PCHAR)Mbcb + <span class="keyword">sizeof</span>(<a class="code" href="../../d9/d6/struct__MBCB.html">MBCB</a>)))) {
02716 
02717                 <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( BitmapRange );
02718             }
02719         }
02720 
02721         <span class="comment">//</span>
02722         <span class="comment">//  Zero the pointer and get out.</span>
02723         <span class="comment">//</span>
02724 
02725         SharedCacheMap-&gt;Mbcb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02726 
02727         ExReleaseSpinLock( &amp;SharedCacheMap-&gt;BcbSpinLock, OldIrql );
02728 
02729         <span class="comment">//</span>
02730         <span class="comment">//  Now delete the Mbcb.</span>
02731         <span class="comment">//</span>
02732 
02733         <a class="code" href="../../d5/d5/cc_8h.html#a177">CcDeallocateBcb</a>( (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)Mbcb );
02734 
02735     } <span class="keywordflow">else</span> {
02736 
02737         ExReleaseSpinLock( &amp;SharedCacheMap-&gt;BcbSpinLock, OldIrql );
02738     }
02739 
02740     <span class="keywordflow">if</span> (DoDrain) {
02741         <a class="code" href="../../d5/d5/cc_8h.html#a205">CcDrainVacbLevelZone</a>();
02742     }
02743 }
02744 
02745 
02746 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l02747"></a><a class="code" href="../../d4/d2/cache_8h.html#a62">02747</a> <a class="code" href="../../d4/d2/cache_8h.html#a62">CcSetDirtyPageThreshold</a> (
02748     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
02749     IN ULONG DirtyPageThreshold
02750     )
02751 
02752 <span class="comment">/*++</span>
02753 <span class="comment"></span>
02754 <span class="comment">Routine Description:</span>
02755 <span class="comment"></span>
02756 <span class="comment">    This routine may be called to set a dirty page threshold for this</span>
02757 <span class="comment">    stream.  The write throttling will kick in whenever the file system</span>
02758 <span class="comment">    attempts to exceed the dirty page threshold for this file.</span>
02759 <span class="comment"></span>
02760 <span class="comment">Arguments:</span>
02761 <span class="comment"></span>
02762 <span class="comment">    FileObject - Supplies file object for the stream</span>
02763 <span class="comment"></span>
02764 <span class="comment">    DirtyPageThreshold - Supplies the dirty page threshold for this stream,</span>
02765 <span class="comment">                         or 0 for no threshold.</span>
02766 <span class="comment"></span>
02767 <span class="comment">Return Value:</span>
02768 <span class="comment"></span>
02769 <span class="comment">    None</span>
02770 <span class="comment"></span>
02771 <span class="comment">Environment:</span>
02772 <span class="comment"></span>
02773 <span class="comment">    The caller must guarantee exclusive access to the FsRtl header flags,</span>
02774 <span class="comment">    for example, by calling this routine once during create of the structure</span>
02775 <span class="comment">    containing the header.  Then it would call the routine again when actually</span>
02776 <span class="comment">    caching the stream.</span>
02777 <span class="comment"></span>
02778 <span class="comment">--*/</span>
02779 
02780 {
02781     KIRQL OldIrql;
02782     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap = FileObject-&gt;SectionObjectPointer-&gt;SharedCacheMap;
02783 
02784     <span class="keywordflow">if</span> (SharedCacheMap != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02785 
02786         SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o32">DirtyPageThreshold</a> = DirtyPageThreshold;
02787     }
02788 
02789     <span class="comment">//</span>
02790     <span class="comment">//  Test the flag before setting, in case the caller is no longer properly</span>
02791     <span class="comment">//  synchronized.</span>
02792     <span class="comment">//</span>
02793 
02794     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(((<a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html">PFSRTL_COMMON_FCB_HEADER</a>)(FileObject-&gt;FsContext))-&gt;Flags,
02795                 <a class="code" href="../../d1/d8/fsrtl_8h.html#a2">FSRTL_FLAG_LIMIT_MODIFIED_PAGES</a>)) {
02796 
02797         <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>(((<a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html">PFSRTL_COMMON_FCB_HEADER</a>)(FileObject-&gt;FsContext))-&gt;Flags,
02798                 <a class="code" href="../../d1/d8/fsrtl_8h.html#a2">FSRTL_FLAG_LIMIT_MODIFIED_PAGES</a>);
02799     }
02800 }
02801 
02802 
02803 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l02804"></a><a class="code" href="../../d4/d2/cache_8h.html#a65">02804</a> <a class="code" href="../../d4/d2/cache_8h.html#a65">CcZeroEndOfLastPage</a> (
02805     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject
02806     )
02807 
02808 <span class="comment">/*++</span>
02809 <span class="comment"></span>
02810 <span class="comment">Routine Description:</span>
02811 <span class="comment"></span>
02812 <span class="comment">    This routine is only called by Mm before mapping a user view to</span>
02813 <span class="comment">    a section.  If there is an uninitialized page at the end of the</span>
02814 <span class="comment">    file, we zero it by freeing that page.</span>
02815 <span class="comment"></span>
02816 <span class="comment">Parameters:</span>
02817 <span class="comment"></span>
02818 <span class="comment">    FileObject - File object for section to be mapped</span>
02819 <span class="comment"></span>
02820 <span class="comment">Return Value:</span>
02821 <span class="comment"></span>
02822 <span class="comment">    None</span>
02823 <span class="comment">--*/</span>
02824 
02825 {
02826     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap;
02827     ULONG ActivePage;
02828     ULONG PageIsDirty;
02829     KIRQL OldIrql;
02830     PVOID NeedToZero = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02831     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> ActiveVacb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02832     IO_STATUS_BLOCK Iosb;
02833     BOOLEAN PurgeResult;
02834 
02835     <span class="comment">//</span>
02836     <span class="comment">//  See if we have an active Vacb, that we need to free.</span>
02837     <span class="comment">//</span>
02838 
02839     <a class="code" href="../../d1/d8/fsrtl_8h.html#a107">FsRtlAcquireFileExclusive</a>( FileObject );
02840     <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
02841     SharedCacheMap = FileObject-&gt;SectionObjectPointer-&gt;SharedCacheMap;
02842 
02843     <span class="keywordflow">if</span> (SharedCacheMap != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02844 
02845         <span class="comment">//</span>
02846         <span class="comment">//  See if there is an active vacb.</span>
02847         <span class="comment">//</span>
02848 
02849         <span class="keywordflow">if</span> ((SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o11">ActiveVacb</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) || ((NeedToZero = SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o13">NeedToZero</a>) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
02850 
02851             <a class="code" href="../../d5/d5/cc_8h.html#a68">CcIncrementOpenCount</a>( SharedCacheMap, 'peZS' );
02852             <a class="code" href="../../d5/d5/cc_8h.html#a83">GetActiveVacbAtDpcLevel</a>( SharedCacheMap, ActiveVacb, ActivePage, PageIsDirty );
02853         }
02854     }
02855 
02856     <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
02857 
02858     <span class="comment">//</span>
02859     <span class="comment">//  Remember in FsRtl header is there is a user section.</span>
02860     <span class="comment">//  If this is an advanced header then also acquire the mutex to access</span>
02861     <span class="comment">//  this field.</span>
02862     <span class="comment">//</span>
02863 
02864     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( ((<a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html">PFSRTL_COMMON_FCB_HEADER</a>)FileObject-&gt;FsContext)-&gt;Flags,
02865                 <a class="code" href="../../d1/d8/fsrtl_8h.html#a6">FSRTL_FLAG_ADVANCED_HEADER</a> )) {
02866 
02867         ExAcquireFastMutex( ((<a class="code" href="../../d9/d0/struct__FSRTL__ADVANCED__FCB__HEADER.html">PFSRTL_ADVANCED_FCB_HEADER</a>)FileObject-&gt;FsContext)-&gt;FastMutex );
02868 
02869         <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>( ((<a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html">PFSRTL_COMMON_FCB_HEADER</a>)FileObject-&gt;FsContext)-&gt;Flags,
02870                  <a class="code" href="../../d1/d8/fsrtl_8h.html#a5">FSRTL_FLAG_USER_MAPPED_FILE</a> );
02871 
02872         ExReleaseFastMutex( ((<a class="code" href="../../d9/d0/struct__FSRTL__ADVANCED__FCB__HEADER.html">PFSRTL_ADVANCED_FCB_HEADER</a>)FileObject-&gt;FsContext)-&gt;FastMutex );
02873 
02874     } <span class="keywordflow">else</span> {
02875 
02876         <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>( ((<a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html">PFSRTL_COMMON_FCB_HEADER</a>)FileObject-&gt;FsContext)-&gt;Flags,
02877                  <a class="code" href="../../d1/d8/fsrtl_8h.html#a5">FSRTL_FLAG_USER_MAPPED_FILE</a> );
02878     }
02879 
02880     <span class="comment">//</span>
02881     <span class="comment">//  Free the active vacb now so we don't deadlock if we have to purge</span>
02882     <span class="comment">//</span>
02883 
02884 
02885     <span class="keywordflow">if</span> ((ActiveVacb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) || (NeedToZero != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
02886         <a class="code" href="../../d5/d5/cc_8h.html#a182">CcFreeActiveVacb</a>( SharedCacheMap, ActiveVacb, ActivePage, PageIsDirty );
02887     }
02888 
02889 
02890     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( ((<a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html">PFSRTL_COMMON_FCB_HEADER</a>)FileObject-&gt;FsContext)-&gt;Flags2, <a class="code" href="../../d1/d8/fsrtl_8h.html#a10">FSRTL_FLAG2_PURGE_WHEN_MAPPED</a> )) {
02891 
02892         <span class="keywordflow">if</span> (FileObject-&gt;SectionObjectPointer-&gt;SharedCacheMap) {
02893             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( ((<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a>)(FileObject-&gt;SectionObjectPointer-&gt;SharedCacheMap))-&gt;VacbActiveCount == 0 );
02894         }
02895 
02896         <a class="code" href="../../d4/d2/cache_8h.html#a63">CcFlushCache</a>( FileObject-&gt;SectionObjectPointer, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, 0, &amp;Iosb );
02897         PurgeResult = <a class="code" href="../../d4/d2/cache_8h.html#a61">CcPurgeCacheSection</a>( FileObject-&gt;SectionObjectPointer, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, 0, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
02898 
02899         <span class="keywordflow">if</span> (FileObject-&gt;SectionObjectPointer-&gt;SharedCacheMap) {
02900             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( ((<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a>)(FileObject-&gt;SectionObjectPointer-&gt;SharedCacheMap))-&gt;VacbActiveCount == 0 );
02901         }
02902     }
02903 
02904 
02905     <a class="code" href="../../d1/d8/fsrtl_8h.html#a108">FsRtlReleaseFile</a>( FileObject );
02906 
02907     <span class="comment">//</span>
02908     <span class="comment">//  If the file is cached and we have a Vacb to free, we need to</span>
02909     <span class="comment">//  use the lazy writer callback to synchronize so no one will be</span>
02910     <span class="comment">//  extending valid data.</span>
02911     <span class="comment">//</span>
02912 
02913     <span class="keywordflow">if</span> ((ActiveVacb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) || (NeedToZero != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
02914 
02915         <span class="comment">//</span>
02916         <span class="comment">//  Serialize again to decrement the open count.</span>
02917         <span class="comment">//</span>
02918 
02919         <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
02920 
02921         <a class="code" href="../../d5/d5/cc_8h.html#a69">CcDecrementOpenCount</a>( SharedCacheMap, 'peZF' );
02922 
02923         <span class="keywordflow">if</span> ((SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o2">OpenCount</a> == 0) &amp;&amp;
02924             !<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, <a class="code" href="../../d5/d5/cc_8h.html#a74">WRITE_QUEUED</a>) &amp;&amp;
02925             (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o20">DirtyPages</a> == 0)) {
02926 
02927             <span class="comment">//</span>
02928             <span class="comment">//  Move to the dirty list.</span>
02929             <span class="comment">//</span>
02930 
02931             RemoveEntryList( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a> );
02932             InsertTailList( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a2">CcDirtySharedCacheMapList</a>.<a class="code" href="../../d1/d3/struct__SHARED__CACHE__MAP__LIST__CURSOR.html#o0">SharedCacheMapLinks</a>,
02933                             &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a> );
02934 
02935             <span class="comment">//</span>
02936             <span class="comment">//  Make sure the Lazy Writer will wake up, because we</span>
02937             <span class="comment">//  want him to delete this SharedCacheMap.</span>
02938             <span class="comment">//</span>
02939 
02940             <a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o6">OtherWork</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02941             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o5">ScanActive</a>) {
02942                 <a class="code" href="../../d5/d5/cc_8h.html#a185">CcScheduleLazyWriteScan</a>();
02943             }
02944         }
02945 
02946         <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
02947     }
02948 }
02949 
02950 
02951 BOOLEAN
<a name="l02952"></a><a class="code" href="../../d4/d2/cache_8h.html#a66">02952</a> <a class="code" href="../../d4/d2/cache_8h.html#a66">CcZeroData</a> (
02953     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
02954     IN PLARGE_INTEGER StartOffset,
02955     IN PLARGE_INTEGER EndOffset,
02956     IN BOOLEAN Wait
02957     )
02958 
02959 <span class="comment">/*++</span>
02960 <span class="comment"></span>
02961 <span class="comment">Routine Description:</span>
02962 <span class="comment"></span>
02963 <span class="comment">    This routine attempts to zero the specified file data and deliver the</span>
02964 <span class="comment">    correct I/O status.</span>
02965 <span class="comment"></span>
02966 <span class="comment">    If the caller does not want to block (such as for disk I/O), then</span>
02967 <span class="comment">    Wait should be supplied as FALSE.  If Wait was supplied as FALSE and</span>
02968 <span class="comment">    it is currently impossible to zero all of the requested data without</span>
02969 <span class="comment">    blocking, then this routine will return FALSE.  However, if the</span>
02970 <span class="comment">    required space is immediately accessible in the cache and no blocking is</span>
02971 <span class="comment">    required, this routine zeros the data and returns TRUE.</span>
02972 <span class="comment"></span>
02973 <span class="comment">    If the caller supplies Wait as TRUE, then this routine is guaranteed</span>
02974 <span class="comment">    to zero the data and return TRUE.  If the correct space is immediately</span>
02975 <span class="comment">    accessible in the cache, then no blocking will occur.  Otherwise,</span>
02976 <span class="comment">    the necessary work will be initiated to read and/or free cache data,</span>
02977 <span class="comment">    and the caller will be blocked until the data can be received.</span>
02978 <span class="comment"></span>
02979 <span class="comment">    File system Fsd's should typically supply Wait = TRUE if they are</span>
02980 <span class="comment">    processing a synchronous I/O requests, or Wait = FALSE if they are</span>
02981 <span class="comment">    processing an asynchronous request.</span>
02982 <span class="comment"></span>
02983 <span class="comment">    File system threads should supply Wait = TRUE.</span>
02984 <span class="comment"></span>
02985 <span class="comment">    IMPORTANT NOTE: File systems which call this routine must be prepared</span>
02986 <span class="comment">    to handle a special form of a write call where the Mdl is already</span>
02987 <span class="comment">    supplied.  Namely, if Irp-&gt;MdlAddress is supplied, the file system</span>
02988 <span class="comment">    must check the low order bit of Irp-&gt;MdlAddress-&gt;ByteOffset.  If it</span>
02989 <span class="comment">    is set, that means that the Irp was generated in this routine and</span>
02990 <span class="comment">    the file system must do two things:</span>
02991 <span class="comment"></span>
02992 <span class="comment">        Decrement Irp-&gt;MdlAddress-&gt;ByteOffset and Irp-&gt;UserBuffer</span>
02993 <span class="comment"></span>
02994 <span class="comment">        Clear Irp-&gt;MdlAddress immediately prior to completing the</span>
02995 <span class="comment">        request, as this routine expects to reuse the Mdl and</span>
02996 <span class="comment">        ultimately deallocate the Mdl itself.</span>
02997 <span class="comment"></span>
02998 <span class="comment">Arguments:</span>
02999 <span class="comment"></span>
03000 <span class="comment">    FileObject - pointer to the FileObject for which a range of bytes</span>
03001 <span class="comment">                 is to be zeroed.  This FileObject may either be for</span>
03002 <span class="comment">                 a cached file or a noncached file.  If the file is</span>
03003 <span class="comment">                 not cached, then WriteThrough must be TRUE and</span>
03004 <span class="comment">                 StartOffset and EndOffset must be on sector boundaries.</span>
03005 <span class="comment"></span>
03006 <span class="comment">    StartOffset - Start offset in file to be zeroed.</span>
03007 <span class="comment"></span>
03008 <span class="comment">    EndOffset - End offset in file to be zeroed.</span>
03009 <span class="comment"></span>
03010 <span class="comment">    Wait - FALSE if caller may not block, TRUE otherwise (see description</span>
03011 <span class="comment">           above)</span>
03012 <span class="comment"></span>
03013 <span class="comment">Return Value:</span>
03014 <span class="comment"></span>
03015 <span class="comment">    FALSE - if Wait was supplied as FALSE and the data was not zeroed.</span>
03016 <span class="comment"></span>
03017 <span class="comment">    TRUE - if the data has been zeroed.</span>
03018 <span class="comment"></span>
03019 <span class="comment">Raises:</span>
03020 <span class="comment"></span>
03021 <span class="comment">    STATUS_INSUFFICIENT_RESOURCES - If a pool allocation failure occurs.</span>
03022 <span class="comment">        This can only occur if Wait was specified as TRUE.  (If Wait is</span>
03023 <span class="comment">        specified as FALSE, and an allocation failure occurs, this</span>
03024 <span class="comment">        routine simply returns FALSE.)</span>
03025 <span class="comment"></span>
03026 <span class="comment">--*/</span>
03027 
03028 {
03029     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap;
03030     PVOID CacheBuffer;
03031     LARGE_INTEGER FOffset;
03032     LARGE_INTEGER ToGo;
03033     ULONG ZeroBytes, ZeroTransfer;
03034     ULONG SectorMask;
03035     ULONG i;
03036     BOOLEAN WriteThrough;
03037     BOOLEAN AggressiveZero = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03038     ULONG SavedState = 0;
03039     ULONG MaxZerosInCache = <a class="code" href="../../d5/d5/cc_8h.html#a37">MAX_ZEROS_IN_CACHE</a>;
03040     ULONG NumberOfColors = 1;
03041 
03042     <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> Bcb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03043     PCHAR Zeros = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03044     <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> ZeroMdl = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03045     ULONG MaxBytesMappedInMdl = 0;
03046     BOOLEAN Result = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03047 
03048     PPFN_NUMBER Page;
03049     ULONG SavedByteCount;
03050     LARGE_INTEGER SizeLeft;
03051 
03052     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcZeroData\n"</span>, 0 );
03053 
03054     WriteThrough = (BOOLEAN)(((FileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a154">FO_WRITE_THROUGH</a>) != 0) ||
03055                    (FileObject-&gt;PrivateCacheMap == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>));
03056 
03057     <span class="comment">//</span>
03058     <span class="comment">//  If the caller specified Wait, but the FileObject is WriteThrough,</span>
03059     <span class="comment">//  then we need to just get out.</span>
03060     <span class="comment">//</span>
03061 
03062     <span class="keywordflow">if</span> (WriteThrough &amp;&amp; !Wait) {
03063 
03064         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcZeroData-&gt;FALSE (WriteThrough &amp;&amp; !Wait)\n"</span>, 0 );
03065 
03066         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03067     }
03068 
03069     SharedCacheMap = FileObject-&gt;SectionObjectPointer-&gt;SharedCacheMap;
03070 
03071     SectorMask = <a class="code" href="../../d4/d6/iosubs_8c.html#a76">IoGetRelatedDeviceObject</a>(FileObject)-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o23">SectorSize</a> - 1;
03072 
03073     FOffset = *StartOffset;
03074 
03075     <span class="comment">//</span>
03076     <span class="comment">//  Calculate how much to zero this time.</span>
03077     <span class="comment">//</span>
03078 
03079     ToGo.QuadPart = EndOffset-&gt;QuadPart - FOffset.QuadPart;
03080 
03081     <span class="comment">//</span>
03082     <span class="comment">//  This magic number is what the fastpaths throttle on, and they will present</span>
03083     <span class="comment">//  non-sector aligned zeroing requests. As long as we will always handle them</span>
03084     <span class="comment">//  on the cached path, we are OK.</span>
03085     <span class="comment">//</span>
03086     <span class="comment">//  If we will not make the cached path, the request must be aligned.</span>
03087     <span class="comment">//</span>
03088     
03089     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( ToGo.QuadPart &lt;= 0x2000 ||
03090             ((ToGo.LowPart &amp; SectorMask) == 0  &amp;&amp;
03091              (FOffset.LowPart &amp; SectorMask) == 0));
03092 
03093     <span class="comment">//</span>
03094     <span class="comment">//  We will only do zeroing in the cache if the caller is using a</span>
03095     <span class="comment">//  cached file object, and did not specify WriteThrough.  We are</span>
03096     <span class="comment">//  willing to zero some data in the cache if our total is not too</span>
03097     <span class="comment">//  much, or there is sufficient available pages.</span>
03098     <span class="comment">//</span>
03099 
03100     <span class="keywordflow">if</span> (((ToGo.QuadPart &lt;= 0x2000) ||
03101          (<a class="code" href="../../d5/d5/cc_8h.html#a94">MmAvailablePages</a> &gt;= ((<a class="code" href="../../d5/d5/cc_8h.html#a37">MAX_ZEROS_IN_CACHE</a> / <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>) * 4))) &amp;&amp; !WriteThrough) {
03102 
03103         <span class="keywordflow">try</span> {
03104 
03105             <span class="keywordflow">while</span> (MaxZerosInCache != 0) {
03106 
03107                 ULONG ReceivedLength;
03108                 LARGE_INTEGER BeyondLastByte;
03109 
03110                 <span class="keywordflow">if</span> ( ToGo.QuadPart &gt; (LONGLONG)MaxZerosInCache ) {
03111 
03112                     <span class="comment">//</span>
03113                     <span class="comment">//  If Wait == FALSE, then there is no point in getting started,</span>
03114                     <span class="comment">//  because we would have to start all over again zeroing with</span>
03115                     <span class="comment">//  Wait == TRUE, since we would fall out of this loop and</span>
03116                     <span class="comment">//  start synchronously writing pages to disk.</span>
03117                     <span class="comment">//</span>
03118 
03119                     <span class="keywordflow">if</span> (!Wait) {
03120 
03121                         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcZeroData -&gt; FALSE\n"</span>, 0 );
03122 
03123                         <a class="code" href="../../d5/d5/cc_8h.html#a90">try_return</a>( Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
03124                     }
03125                 }
03126                 <span class="keywordflow">else</span> {
03127                     MaxZerosInCache = ToGo.LowPart;
03128                 }
03129 
03130                 <span class="comment">//</span>
03131                 <span class="comment">//  Call local routine to Map or Access the file data, then zero the data,</span>
03132                 <span class="comment">//  then call another local routine to free the data.  If we cannot map</span>
03133                 <span class="comment">//  the data because of a Wait condition, return FALSE.</span>
03134                 <span class="comment">//</span>
03135                 <span class="comment">//  Note that this call may result in an exception, however, if it</span>
03136                 <span class="comment">//  does no Bcb is returned and this routine has absolutely no</span>
03137                 <span class="comment">//  cleanup to perform.  Therefore, we do not have a try-finally</span>
03138                 <span class="comment">//  and we allow the possibility that we will simply be unwound</span>
03139                 <span class="comment">//  without notice.</span>
03140                 <span class="comment">//</span>
03141 
03142                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/cc_8h.html#a175">CcPinFileData</a>( FileObject,
03143                                     &amp;FOffset,
03144                                     MaxZerosInCache,
03145                                     <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
03146                                     <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
03147                                     Wait,
03148                                     &amp;Bcb,
03149                                     &amp;CacheBuffer,
03150                                     &amp;BeyondLastByte )) {
03151 
03152                     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcZeroData -&gt; FALSE\n"</span>, 0 );
03153 
03154                     <a class="code" href="../../d5/d5/cc_8h.html#a90">try_return</a>( Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
03155                 }
03156 
03157                 <span class="comment">//</span>
03158                 <span class="comment">//  Calculate how much data is described by Bcb starting at our desired</span>
03159                 <span class="comment">//  file offset.  If it is more than we need, we will zero the whole thing</span>
03160                 <span class="comment">//  anyway.</span>
03161                 <span class="comment">//</span>
03162 
03163                 ReceivedLength = (ULONG)(BeyondLastByte.QuadPart - FOffset.QuadPart );
03164 
03165                 <span class="comment">//</span>
03166                 <span class="comment">//  Now attempt to allocate an Mdl to describe the mapped data.</span>
03167                 <span class="comment">//</span>
03168 
03169                 ZeroMdl = <a class="code" href="../../d4/d6/iosubs_8c.html#a19">IoAllocateMdl</a>( CacheBuffer,
03170                                          ReceivedLength,
03171                                          <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
03172                                          <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
03173                                          <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
03174 
03175                 <span class="keywordflow">if</span> (ZeroMdl == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03176 
03177                     <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INSUFFICIENT_RESOURCES );
03178                 }
03179 
03180                 <span class="comment">//</span>
03181                 <span class="comment">//  It is necessary to probe and lock the pages, or else</span>
03182                 <span class="comment">//  the pages may not still be in memory when we do the</span>
03183                 <span class="comment">//  MmSetAddressRangeModified for the dirty Bcb.</span>
03184                 <span class="comment">//</span>
03185 
03186                 <a class="code" href="../../d2/d1/mm_8h.html#a17">MmDisablePageFaultClustering</a>(&amp;SavedState);
03187                 <a class="code" href="../../d5/d6/iosup_8c.html#a41">MmProbeAndLockPages</a>( ZeroMdl, <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>, <a class="code" href="../../d2/d1/mm_8h.html#a344a168">IoReadAccess</a> );
03188                 <a class="code" href="../../d2/d1/mm_8h.html#a18">MmEnablePageFaultClustering</a>(SavedState);
03189                 SavedState = 0;
03190 
03191                 <span class="comment">//</span>
03192                 <span class="comment">//  Assume we did not get all the data we wanted, and set FOffset</span>
03193                 <span class="comment">//  to the end of the returned data, and advance buffer pointer.</span>
03194                 <span class="comment">//</span>
03195 
03196                 FOffset = BeyondLastByte;
03197 
03198                 <span class="comment">//</span>
03199                 <span class="comment">//  Figure out how many bytes we are allowed to zero in the cache.</span>
03200                 <span class="comment">//  Note it is possible we have zeroed a little more than our maximum,</span>
03201                 <span class="comment">//  because we hit an existing Bcb that extended beyond the range.</span>
03202                 <span class="comment">//</span>
03203 
03204                 <span class="keywordflow">if</span> (MaxZerosInCache &lt;= ReceivedLength) {
03205                     MaxZerosInCache = 0;
03206                 }
03207                 <span class="keywordflow">else</span> {
03208                     MaxZerosInCache -= ReceivedLength;
03209                 }
03210 
03211                 <span class="comment">//</span>
03212                 <span class="comment">//  Now set the Bcb dirty.  We have to explicitly set the address</span>
03213                 <span class="comment">//  range modified here, because that work otherwise gets deferred</span>
03214                 <span class="comment">//  to the Lazy Writer.</span>
03215                 <span class="comment">//</span>
03216 
03217                 <a class="code" href="../../d5/d6/iosup_8c.html#a74">MmSetAddressRangeModified</a>( CacheBuffer, ReceivedLength );
03218                 <a class="code" href="../../d4/d2/cache_8h.html#a91">CcSetDirtyPinnedData</a>( Bcb, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
03219 
03220                 <span class="comment">//</span>
03221                 <span class="comment">//  Unmap the data now</span>
03222                 <span class="comment">//</span>
03223 
03224                 <a class="code" href="../../d5/d5/cc_8h.html#a176">CcUnpinFileData</a>( Bcb, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, <a class="code" href="../../d5/d5/cc_8h.html#a211a171">UNPIN</a> );
03225                 Bcb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03226 
03227                 <span class="comment">//</span>
03228                 <span class="comment">//  Unlock and free the Mdl (we only loop back if we crossed</span>
03229                 <span class="comment">//  a 256KB boundary.</span>
03230                 <span class="comment">//</span>
03231 
03232                 <a class="code" href="../../d5/d6/iosup_8c.html#a45">MmUnlockPages</a>( ZeroMdl );
03233                 <a class="code" href="../../d4/d6/iosubs_8c.html#a65">IoFreeMdl</a>( ZeroMdl );
03234                 ZeroMdl = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03235             }
03236 
03237         try_exit: NOTHING;
03238         } finally {
03239 
03240             <span class="keywordflow">if</span> (SavedState != 0) {
03241                 <a class="code" href="../../d2/d1/mm_8h.html#a18">MmEnablePageFaultClustering</a>(SavedState);
03242             }
03243 
03244             <span class="comment">//</span>
03245             <span class="comment">//  Clean up only necessary in abnormal termination.</span>
03246             <span class="comment">//</span>
03247 
03248             <span class="keywordflow">if</span> (Bcb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03249 
03250                 <a class="code" href="../../d5/d5/cc_8h.html#a176">CcUnpinFileData</a>( Bcb, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, <a class="code" href="../../d5/d5/cc_8h.html#a211a171">UNPIN</a> );
03251             }
03252 
03253             <span class="comment">//</span>
03254             <span class="comment">//  Since the last thing in the above loop which can</span>
03255             <span class="comment">//  fail is the MmProbeAndLockPages, we only need to</span>
03256             <span class="comment">//  free the Mdl here.</span>
03257             <span class="comment">//</span>
03258 
03259             <span class="keywordflow">if</span> (ZeroMdl != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03260 
03261                 <a class="code" href="../../d4/d6/iosubs_8c.html#a65">IoFreeMdl</a>( ZeroMdl );
03262             }
03263         }
03264 
03265         <span class="comment">//</span>
03266         <span class="comment">//  If hit a wait condition above, return it now.</span>
03267         <span class="comment">//</span>
03268 
03269         <span class="keywordflow">if</span> (!Result) {
03270             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03271         }
03272 
03273         <span class="comment">//</span>
03274         <span class="comment">//  If we finished, get out nbow.</span>
03275         <span class="comment">//</span>
03276 
03277         <span class="keywordflow">if</span> ( FOffset.QuadPart &gt;= EndOffset-&gt;QuadPart ) {
03278             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03279         }
03280     }
03281 
03282     <span class="comment">//</span>
03283     <span class="comment">//  We either get here because we decided above not to zero anything in</span>
03284     <span class="comment">//  the cache directly, or else we zeroed up to our maximum and still</span>
03285     <span class="comment">//  have some left to zero direct to the file on disk.  In either case,</span>
03286     <span class="comment">//  we will now zero from FOffset to *EndOffset, and then flush this</span>
03287     <span class="comment">//  range in case the file is cached/mapped, and there are modified</span>
03288     <span class="comment">//  changes in memory.</span>
03289     <span class="comment">//</span>
03290 
03291     <span class="comment">//</span>
03292     <span class="comment">//  Round FOffset and EndOffset up to sector boundaries, since</span>
03293     <span class="comment">//  we will be doing disk I/O, and calculate size left.</span>
03294     <span class="comment">//</span>
03295 
03296     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( (FOffset.LowPart &amp; SectorMask) == 0 );
03297 
03298     FOffset.QuadPart += (LONGLONG)SectorMask;
03299     FOffset.LowPart &amp;= ~SectorMask;
03300     SizeLeft.QuadPart = EndOffset-&gt;QuadPart + (LONGLONG)SectorMask;
03301     SizeLeft.LowPart &amp;= ~SectorMask;
03302     SizeLeft.QuadPart -= FOffset.QuadPart;
03303 
03304     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( (FOffset.LowPart &amp; SectorMask) == 0 );
03305     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( (SizeLeft.LowPart &amp; SectorMask) == 0 );
03306 
03307     <span class="keywordflow">if</span> (SizeLeft.QuadPart == 0) {
03308         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03309     }
03310 
03311     <span class="comment">//</span>
03312     <span class="comment">//  try-finally to guarantee cleanup.</span>
03313     <span class="comment">//</span>
03314 
03315     <span class="keywordflow">try</span> {
03316         
03317         <span class="comment">//</span>
03318         <span class="comment">//  Allocate a page to hold the zeros we will write, and</span>
03319         <span class="comment">//  zero it.</span>
03320         <span class="comment">//</span>
03321 
03322         ZeroBytes = NumberOfColors * <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
03323 
03324         <span class="keywordflow">if</span> (SizeLeft.HighPart == 0 &amp;&amp; SizeLeft.LowPart &lt; ZeroBytes) {
03325             ZeroBytes = SizeLeft.LowPart;
03326         }
03327 
03328         Zeros = (PCHAR)<a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a177">NonPagedPoolCacheAligned</a>, ZeroBytes, 'eZcC' );
03329 
03330         <span class="keywordflow">if</span> (Zeros != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03331 
03332             <span class="comment">//</span>
03333             <span class="comment">//  Allocate and initialize an Mdl to describe the zeros</span>
03334             <span class="comment">//  we need to transfer.  Allocate to cover the maximum</span>
03335             <span class="comment">//  size required, and we will use and reuse it in the</span>
03336             <span class="comment">//  loop below, initialized correctly.</span>
03337             <span class="comment">//</span>
03338 
03339             <span class="keywordflow">if</span> (SizeLeft.HighPart == 0 &amp;&amp; SizeLeft.LowPart &lt; <a class="code" href="../../d5/d5/cc_8h.html#a35">MAX_ZERO_TRANSFER</a>) {
03340 
03341                 ZeroTransfer = SizeLeft.LowPart;
03342 
03343             } <span class="keywordflow">else</span> {
03344 
03345                 <span class="comment">//</span>
03346                 <span class="comment">//  See how aggressive we can afford to be.</span>
03347                 <span class="comment">//</span>
03348 
03349                 <span class="keywordflow">if</span> (InterlockedIncrement( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a38">CcAggressiveZeroCount</a> ) &lt;= <a class="code" href="../../d5/d2/cachedat_8c.html#a39">CcAggressiveZeroThreshold</a>) {
03350                     AggressiveZero = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03351                     ZeroTransfer = <a class="code" href="../../d5/d5/cc_8h.html#a35">MAX_ZERO_TRANSFER</a>;
03352                 } <span class="keywordflow">else</span> {
03353                     InterlockedDecrement( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a38">CcAggressiveZeroCount</a> );
03354                     ZeroTransfer = <a class="code" href="../../d5/d5/cc_8h.html#a36">MIN_ZERO_TRANSFER</a>;
03355                 }
03356             }
03357 
03358             <span class="comment">//</span>
03359             <span class="comment">//  Since the maximum zero may start at a very aggresive level, fall back</span>
03360             <span class="comment">//  until we really have to give up.  Since filter drivers, filesystems and</span>
03361             <span class="comment">//  even storage drivers may need to map this Mdl, we have to pre-map it</span>
03362             <span class="comment">//  into system space so that we know enough PTEs are avaliable.  We also</span>
03363             <span class="comment">//  need to throttle our consumption of virtual addresses based on the size</span>
03364             <span class="comment">//  of the system and the number of parallel instances of this work outstanding.</span>
03365             <span class="comment">//  This may be a bit of overkill, but since running out of PTEs is a fatal</span>
03366             <span class="comment">//  event for the rest of the system, try to help out while still being fast.</span>
03367             <span class="comment">//</span>
03368 
03369             <span class="keywordflow">while</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
03370 
03371                 <span class="comment">//</span>
03372                 <span class="comment">//  Spin down trying to get an MDL which can describe our operation.</span>
03373                 <span class="comment">//</span>
03374                 
03375                 <span class="keywordflow">while</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
03376 
03377                     ZeroMdl = <a class="code" href="../../d4/d6/iosubs_8c.html#a19">IoAllocateMdl</a>( Zeros, ZeroTransfer, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
03378                     
03379                     <span class="comment">//</span>
03380                     <span class="comment">//  Throttle ourselves to what we've physically allocated.  Note that</span>
03381                     <span class="comment">//  we could have started with an odd multiple of this number.  If we</span>
03382                     <span class="comment">//  tried for exactly that size and failed, we're toast.</span>
03383                     <span class="comment">//</span>
03384                     
03385                     <span class="keywordflow">if</span> (ZeroMdl || ZeroTransfer == ZeroBytes) {
03386                         
03387                         <span class="keywordflow">break</span>;
03388                     }
03389                     
03390                     Fall_Back:
03391                     
03392                     <span class="comment">//</span>
03393                     <span class="comment">//  Fallback by half and round down to a sector multiple.</span>
03394                     <span class="comment">//</span>
03395                         
03396                     ZeroTransfer /= 2;
03397                     ZeroTransfer &amp;= ~SectorMask;
03398                     <span class="keywordflow">if</span> (ZeroTransfer &lt; ZeroBytes) {
03399                         ZeroTransfer = ZeroBytes;
03400                     }
03401 
03402                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( (ZeroTransfer &amp; SectorMask) == 0 &amp;&amp; ZeroTransfer != 0);
03403                 }
03404 
03405                 <span class="keywordflow">if</span> (ZeroMdl == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03406                     
03407                     <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INSUFFICIENT_RESOURCES );
03408                 }
03409 
03410                 <span class="comment">//</span>
03411                 <span class="comment">//  If we have throttled all the way down, stop and just build a</span>
03412                 <span class="comment">//  simple MDL describing our previous allocation.</span>
03413                 <span class="comment">//</span>
03414 
03415                 <span class="keywordflow">if</span> (ZeroTransfer == ZeroBytes) {
03416 
03417                     <a class="code" href="../../d5/d6/iosup_8c.html#a46">MmBuildMdlForNonPagedPool</a>( ZeroMdl );
03418                     <span class="keywordflow">break</span>;
03419                 }
03420 
03421                 <span class="comment">//</span>
03422                 <span class="comment">//  Now we will temporarily lock the allocated pages</span>
03423                 <span class="comment">//  only, and then replicate the page frame numbers through</span>
03424                 <span class="comment">//  the entire Mdl to keep writing the same pages of zeros.</span>
03425                 <span class="comment">//</span>
03426                 <span class="comment">//  It would be nice if Mm exported a way for us to not have</span>
03427                 <span class="comment">//  to pull the Mdl apart and rebuild it ourselves, but this</span>
03428                 <span class="comment">//  is so bizzare a purpose as to be tolerable.</span>
03429                 <span class="comment">//</span>
03430 
03431                 SavedByteCount = ZeroMdl-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o6">ByteCount</a>;
03432                 ZeroMdl-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o6">ByteCount</a> = ZeroBytes;
03433                 <a class="code" href="../../d5/d6/iosup_8c.html#a46">MmBuildMdlForNonPagedPool</a>( ZeroMdl );
03434 
03435                 ZeroMdl-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o2">MdlFlags</a> &amp;= ~<a class="code" href="../../d0/d9/ntosdef_8h.html#a14">MDL_SOURCE_IS_NONPAGED_POOL</a>;
03436                 ZeroMdl-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o2">MdlFlags</a> |= <a class="code" href="../../d0/d9/ntosdef_8h.html#a13">MDL_PAGES_LOCKED</a>;
03437                 ZeroMdl-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o4">MappedSystemVa</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03438                 ZeroMdl-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o6">ByteCount</a> = SavedByteCount;
03439                 Page = <a class="code" href="../../d2/d1/mm_8h.html#a11">MmGetMdlPfnArray</a>( ZeroMdl );
03440                 <span class="keywordflow">for</span> (i = NumberOfColors;
03441                      i &lt; (<a class="code" href="../../d2/d1/mm_8h.html#a9">COMPUTE_PAGES_SPANNED</a>( 0, SavedByteCount ));
03442                      i++) {
03443 
03444                     *(Page + i) = *(Page + i - NumberOfColors);
03445                 }
03446 
03447                 <span class="keywordflow">if</span> (<a class="code" href="../../d2/d1/mm_8h.html#a25">MmGetSystemAddressForMdlSafe</a>( ZeroMdl, <a class="code" href="../../d2/d1/mm_8h.html#a347a181">LowPagePriority</a> ) == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03448 
03449                     <span class="comment">//</span>
03450                     <span class="comment">//  Blow away this Mdl and trim for the retry.  Since it didn't</span>
03451                     <span class="comment">//  get mapped, there is nothing fancy to do. </span>
03452                     <span class="comment">//</span>
03453 
03454                     <a class="code" href="../../d4/d6/iosubs_8c.html#a65">IoFreeMdl</a>( ZeroMdl );
03455                     <span class="keywordflow">goto</span> Fall_Back;
03456                 }
03457 
03458                 <span class="keywordflow">break</span>;
03459             }
03460 
03461         <span class="comment">//</span>
03462         <span class="comment">//  We failed to allocate the space we wanted, so we will go to</span>
03463         <span class="comment">//  half of a page and limp along.</span>
03464         <span class="comment">//</span>
03465 
03466         } <span class="keywordflow">else</span> {
03467 
03468             <span class="comment">//</span>
03469             <span class="comment">//  Of course, if we have a device which has large sectors, that defines</span>
03470             <span class="comment">//  the lower limit of our attempt.</span>
03471             <span class="comment">//</span>
03472 
03473             <span class="keywordflow">if</span> (<a class="code" href="../../d4/d6/iosubs_8c.html#a76">IoGetRelatedDeviceObject</a>(FileObject)-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o23">SectorSize</a> &lt; <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> / 2) {
03474                 
03475                 ZeroBytes = <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> / 2;
03476                 Zeros = (PCHAR)<a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a177">NonPagedPoolCacheAligned</a>, ZeroBytes, 'eZcC' );
03477             }
03478 
03479             <span class="comment">//</span>
03480             <span class="comment">//  If we cannot get even that much, then let's write a sector at a time.</span>
03481             <span class="comment">//</span>
03482 
03483             <span class="keywordflow">if</span> (Zeros == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03484                 
03485                 ZeroBytes = <a class="code" href="../../d4/d6/iosubs_8c.html#a76">IoGetRelatedDeviceObject</a>(FileObject)-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o23">SectorSize</a>;
03486                 Zeros = (PCHAR)<a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a177">NonPagedPoolCacheAligned</a>, ZeroBytes, 'eZcC' );
03487 
03488                 <span class="comment">//</span>
03489                 <span class="comment">//  If we cannot get even the minimum, we have to give up.</span>
03490                 <span class="comment">//</span>
03491 
03492                 <span class="keywordflow">if</span> (Zeros == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03493                     <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INSUFFICIENT_RESOURCES );
03494                 }
03495             }
03496 
03497             <span class="comment">//</span>
03498             <span class="comment">//  Allocate and initialize an Mdl to describe the zeros</span>
03499             <span class="comment">//  we need to transfer.  Allocate to cover the maximum</span>
03500             <span class="comment">//  size required, and we will use and reuse it in the</span>
03501             <span class="comment">//  loop below, initialized correctly.</span>
03502             <span class="comment">//</span>
03503 
03504             ZeroTransfer = ZeroBytes;
03505             ZeroMdl = <a class="code" href="../../d4/d6/iosubs_8c.html#a19">IoAllocateMdl</a>( Zeros, ZeroBytes, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
03506 
03507             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( (ZeroTransfer &amp; SectorMask) == 0 );
03508 
03509             <span class="keywordflow">if</span> (ZeroMdl == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03510                 <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INSUFFICIENT_RESOURCES );
03511             }
03512 
03513             <span class="comment">//</span>
03514             <span class="comment">//  Now we will lock and map the allocated pages.</span>
03515             <span class="comment">//</span>
03516 
03517             <a class="code" href="../../d5/d6/iosup_8c.html#a46">MmBuildMdlForNonPagedPool</a>( ZeroMdl );
03518 
03519             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( ZeroMdl-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o4">MappedSystemVa</a> == Zeros );
03520         }
03521 
03522 <span class="preprocessor">#ifdef MIPS</span>
03523 <span class="preprocessor"></span><span class="preprocessor">#ifdef MIPS_PREFILL</span>
03524 <span class="preprocessor"></span>        RtlFillMemory( Zeros, ZeroBytes, 0xDD );
03525         <a class="code" href="../../d3/d5/ppc_2flush_8c.html#a6">KeSweepDcache</a>( <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
03526 <span class="preprocessor">#endif</span>
03527 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
03528 <span class="preprocessor"></span>
03529         <span class="comment">//</span>
03530         <span class="comment">//  Zero the buffer now.</span>
03531         <span class="comment">//</span>
03532 
03533         RtlZeroMemory( Zeros, ZeroBytes );
03534 
03535         <span class="comment">//</span>
03536         <span class="comment">//  We have a mapped and zeroed range back by an MDL to use.  Note the</span>
03537         <span class="comment">//  size we have for cleanup, since we will possibly wind this down</span>
03538         <span class="comment">//  over the operation.</span>
03539         <span class="comment">//</span>
03540 
03541         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d2/d1/mm_8h.html#a26">MmGetSystemAddressForMdl</a>(ZeroMdl) );
03542         MaxBytesMappedInMdl = ZeroMdl-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o6">ByteCount</a>;
03543 
03544         <span class="comment">//</span>
03545         <span class="comment">//  Now loop to write buffers full of zeros through to the file</span>
03546         <span class="comment">//  until we reach the starting Vbn for the transfer.</span>
03547         <span class="comment">//</span>
03548 
03549         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( ZeroTransfer != 0 &amp;&amp;
03550                 (ZeroTransfer &amp; SectorMask) == 0 &amp;&amp;
03551                 (SizeLeft.LowPart &amp; SectorMask) == 0 );
03552 
03553         <span class="keywordflow">while</span> ( SizeLeft.QuadPart != 0 ) {
03554 
03555             IO_STATUS_BLOCK IoStatus;
03556             <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
03557             <a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a> <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>;
03558 
03559             <span class="comment">//</span>
03560             <span class="comment">//  See if we really need to write that many zeros, and</span>
03561             <span class="comment">//  trim the size back if not.</span>
03562             <span class="comment">//</span>
03563 
03564             <span class="keywordflow">if</span> ( (LONGLONG)ZeroTransfer &gt; SizeLeft.QuadPart ) {
03565 
03566                 ZeroTransfer = SizeLeft.LowPart;
03567             }
03568 
03569             <span class="comment">//</span>
03570             <span class="comment">//  (Re)initialize the kernel event to FALSE.</span>
03571             <span class="comment">//</span>
03572 
03573             <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( &amp;<a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>, NotificationEvent, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
03574 
03575             <span class="comment">//</span>
03576             <span class="comment">//  Initiate and wait for the synchronous transfer.</span>
03577             <span class="comment">//</span>
03578 
03579             ZeroMdl-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o6">ByteCount</a> = ZeroTransfer;
03580 
03581             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d4/d6/iosubs_8c.html#a116">IoSynchronousPageWrite</a>( FileObject,
03582                                              ZeroMdl,
03583                                              &amp;FOffset,
03584                                              &amp;<a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>,
03585                                              &amp;IoStatus );
03586 
03587             <span class="comment">//</span>
03588             <span class="comment">//  If pending is returned (which is a successful status),</span>
03589             <span class="comment">//  we must wait for the request to complete.</span>
03590             <span class="comment">//</span>
03591 
03592             <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_PENDING) {
03593                 <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;<a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>,
03594                                        <a class="code" href="../../d6/d7/halmips_8h.html#a455">Executive</a>,
03595                                        <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
03596                                        <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
03597                                        (PLARGE_INTEGER)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
03598             }
03599 
03600 
03601             <span class="comment">//</span>
03602             <span class="comment">//  If we got an error back in Status, then the Iosb</span>
03603             <span class="comment">//  was not written, so we will just copy the status</span>
03604             <span class="comment">//  there, then test the final status after that.</span>
03605             <span class="comment">//</span>
03606 
03607             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
03608                 <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> );
03609             }
03610 
03611             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(IoStatus.Status)) {
03612                 <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( IoStatus.Status );
03613             }
03614 
03615             <span class="comment">//</span>
03616             <span class="comment">//  If we succeeded, then update where we are at by how much</span>
03617             <span class="comment">//  we wrote, and loop back to see if there is more.</span>
03618             <span class="comment">//</span>
03619 
03620             FOffset.QuadPart = FOffset.QuadPart + (LONGLONG)ZeroTransfer;
03621             SizeLeft.QuadPart = SizeLeft.QuadPart - (LONGLONG)ZeroTransfer;
03622         }
03623     }
03624     finally{
03625 
03626         <span class="comment">//</span>
03627         <span class="comment">//  Clean up anything from zeroing pages on a noncached</span>
03628         <span class="comment">//  write.</span>
03629         <span class="comment">//</span>
03630 
03631         <span class="keywordflow">if</span> (ZeroMdl != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03632 
03633             <span class="keywordflow">if</span> ((MaxBytesMappedInMdl != 0) &amp;&amp;
03634                 !<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(ZeroMdl-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o2">MdlFlags</a>, <a class="code" href="../../d0/d9/ntosdef_8h.html#a14">MDL_SOURCE_IS_NONPAGED_POOL</a>)) {
03635                 ZeroMdl-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o6">ByteCount</a> = MaxBytesMappedInMdl;
03636                 <a class="code" href="../../d5/d6/iosup_8c.html#a56">MmUnmapLockedPages</a> (ZeroMdl-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o4">MappedSystemVa</a>, ZeroMdl);
03637             }
03638 
03639             <a class="code" href="../../d4/d6/iosubs_8c.html#a65">IoFreeMdl</a>( ZeroMdl );
03640         }
03641 
03642         <span class="keywordflow">if</span> (AggressiveZero) {
03643             InterlockedDecrement( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a38">CcAggressiveZeroCount</a> );
03644         }
03645 
03646         <span class="keywordflow">if</span> (Zeros != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03647             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( Zeros );
03648         }
03649 
03650         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcZeroData -&gt; TRUE\n"</span>, 0 );
03651     }
03652 
03653     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03654 }
03655 
03656 
03657 <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>
<a name="l03658"></a><a class="code" href="../../d4/d2/cache_8h.html#a70">03658</a> <a class="code" href="../../d4/d2/cache_8h.html#a70">CcGetFileObjectFromSectionPtrs</a> (
03659     IN <a class="code" href="../../d7/d0/struct__SECTION__OBJECT__POINTERS.html">PSECTION_OBJECT_POINTERS</a> SectionObjectPointer
03660     )
03661 
03662 <span class="comment">/*++</span>
03663 <span class="comment"></span>
03664 <span class="comment">This routine may be used to retrieve a pointer to the FileObject that the</span>
03665 <span class="comment">Cache Manager is using for a given file from the Section Object Pointers</span>
03666 <span class="comment">in the nonpaged File System structure Fcb.  The use of this function is</span>
03667 <span class="comment">intended for exceptional use unrelated to the processing of user requests,</span>
03668 <span class="comment">when the File System would otherwise not have a FileObject at its disposal.</span>
03669 <span class="comment">An example is for mount verification.</span>
03670 <span class="comment"></span>
03671 <span class="comment">Note that the File System is responsible for insuring that the File</span>
03672 <span class="comment">Object does not go away while in use.  It is impossible for the Cache</span>
03673 <span class="comment">Manager to guarantee this.</span>
03674 <span class="comment"></span>
03675 <span class="comment">Arguments:</span>
03676 <span class="comment"></span>
03677 <span class="comment">    SectionObjectPointer - A pointer to the Section Object Pointers</span>
03678 <span class="comment">                           structure in the nonpaged Fcb.</span>
03679 <span class="comment"></span>
03680 <span class="comment">Return Value:</span>
03681 <span class="comment"></span>
03682 <span class="comment">    Pointer to the File Object, or NULL if the file is not cached or no</span>
03683 <span class="comment">    longer cached</span>
03684 <span class="comment"></span>
03685 <span class="comment">--*/</span>
03686 
03687 {
03688     KIRQL OldIrql;
03689     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03690 
03691     <span class="comment">//</span>
03692     <span class="comment">//  Serialize with Creation/Deletion of all Shared CacheMaps</span>
03693     <span class="comment">//</span>
03694 
03695     <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
03696 
03697     <span class="keywordflow">if</span> (SectionObjectPointer-&gt;SharedCacheMap != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03698 
03699         FileObject = ((<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a>)SectionObjectPointer-&gt;SharedCacheMap)-&gt;FileObject;
03700     }
03701 
03702     <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
03703 
03704     <span class="keywordflow">return</span> FileObject;
03705 }
03706 
03707 
03708 <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>
<a name="l03709"></a><a class="code" href="../../d4/d2/cache_8h.html#a71">03709</a> <a class="code" href="../../d4/d2/cache_8h.html#a71">CcGetFileObjectFromBcb</a> (
03710     IN PVOID Bcb
03711     )
03712 
03713 <span class="comment">/*++</span>
03714 <span class="comment"></span>
03715 <span class="comment">This routine may be used to retrieve a pointer to the FileObject that the</span>
03716 <span class="comment">Cache Manager is using for a given file from a Bcb of that file.</span>
03717 <span class="comment"></span>
03718 <span class="comment">Note that the File System is responsible for insuring that the File</span>
03719 <span class="comment">Object does not go away while in use.  It is impossible for the Cache</span>
03720 <span class="comment">Manager to guarantee this.</span>
03721 <span class="comment"></span>
03722 <span class="comment">Arguments:</span>
03723 <span class="comment"></span>
03724 <span class="comment">    Bcb - A pointer to the pinned Bcb.</span>
03725 <span class="comment"></span>
03726 <span class="comment">Return Value:</span>
03727 <span class="comment"></span>
03728 <span class="comment">    Pointer to the File Object, or NULL if the file is not cached or no</span>
03729 <span class="comment">    longer cached</span>
03730 <span class="comment"></span>
03731 <span class="comment">--*/</span>
03732 
03733 {
03734     <span class="keywordflow">return</span> ((<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)Bcb)-&gt;SharedCacheMap-&gt;FileObject;
03735 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:40:04 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
