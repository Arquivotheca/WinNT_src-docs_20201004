<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: lpcreply.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>lpcreply.c</h1><a href="../../d5/d7/lpcreply_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1989  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    lpcreply.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    Local Inter-Process Communication (LPC) reply system services.</span>
00012 <span class="comment"></span>
00013 <span class="comment">Author:</span>
00014 <span class="comment"></span>
00015 <span class="comment">    Steve Wood (stevewo) 15-May-1989</span>
00016 <span class="comment"></span>
00017 <span class="comment">Revision History:</span>
00018 <span class="comment"></span>
00019 <span class="comment">--*/</span>
00020 
00021 <span class="preprocessor">#include "<a class="code" href="../../d0/d7/lpcp_8h.html">lpcp.h</a>"</span>
00022 
00023 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00024 <a class="code" href="../../d5/d7/lpcreply_8c.html#a0">LpcpCopyRequestData</a> (
00025     IN BOOLEAN WriteToMessageData,
00026     IN HANDLE PortHandle,
00027     IN PPORT_MESSAGE Message,
00028     IN ULONG DataEntryIndex,
00029     IN PVOID Buffer,
00030     IN ULONG BufferSize,
00031     OUT PULONG NumberOfBytesCopied OPTIONAL
00032     );
00033 
00034 <span class="preprocessor">#ifdef ALLOC_PRAGMA</span>
00035 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,NtReplyPort)</span>
00036 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,NtReplyWaitReplyPort)</span>
00037 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,NtReadRequestData)</span>
00038 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,NtWriteRequestData)</span>
00039 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,LpcpCopyRequestData)</span>
00040 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00041 <span class="preprocessor"></span>
00042 
00043 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00044"></a><a class="code" href="../../d5/d7/lpcreply_8c.html#a1">00044</a> <a class="code" href="../../d5/d7/lpcreply_8c.html#a1">NtReplyPort</a> (
00045     IN HANDLE PortHandle,
00046     IN PPORT_MESSAGE ReplyMessage
00047     )
00048 
00049 <span class="comment">/*++</span>
00050 <span class="comment"></span>
00051 <span class="comment">Routine Description:</span>
00052 <span class="comment"></span>
00053 <span class="comment">    A client and server process can send a reply to a previous request</span>
00054 <span class="comment">    message with the NtReplyPort service:</span>
00055 <span class="comment"></span>
00056 <span class="comment">    The Type field of the message is set to LPC_REPLY by the service.  If the</span>
00057 <span class="comment">    MapInfoOffset field of the reply message is non-zero, then the</span>
00058 <span class="comment">    PORT_MAP_INFORMATION structure it points to will be processed and the</span>
00059 <span class="comment">    relevant pages in the caller's address space will be unmapped.</span>
00060 <span class="comment"></span>
00061 <span class="comment">    The ClientId and MessageId fields of the ReplyMessage structure are used</span>
00062 <span class="comment">    to identify the thread waiting for this reply.  If the target thread is</span>
00063 <span class="comment">    in fact waiting for this reply message, then the reply message is copied</span>
00064 <span class="comment">    into the thread's message buffer and the thread's wait is satisfied.</span>
00065 <span class="comment"></span>
00066 <span class="comment">    If the thread is not waiting for a reply or is waiting for a reply to</span>
00067 <span class="comment">    some other MessageId, then the message is placed in the message queue of</span>
00068 <span class="comment">    the port that is connected to the communication port specified by the</span>
00069 <span class="comment">    PortHandle parameter and the Type field of the message is set to</span>
00070 <span class="comment">    LPC_LOST_REPLY.</span>
00071 <span class="comment"></span>
00072 <span class="comment">Arguments:</span>
00073 <span class="comment"></span>
00074 <span class="comment">    PortHandle - Specifies the handle of the communication port that the</span>
00075 <span class="comment">        original message was received from.</span>
00076 <span class="comment"></span>
00077 <span class="comment">    ReplyMessage - Specifies a pointer to the reply message to be sent.</span>
00078 <span class="comment">        The ClientId and MessageId fields determine which thread will</span>
00079 <span class="comment">        get the reply.</span>
00080 <span class="comment"></span>
00081 <span class="comment">Return Value:</span>
00082 <span class="comment"></span>
00083 <span class="comment">    Status code that indicates whether or not the operation was</span>
00084 <span class="comment">    successful.</span>
00085 <span class="comment"></span>
00086 <span class="comment">--*/</span>
00087 
00088 {
00089     <a class="code" href="../../d0/d9/ntosdef_8h.html#a39">KPROCESSOR_MODE</a> PreviousMode;
00090     <a class="code" href="../../d9/d4/struct__LPCP__PORT__OBJECT.html">PLPCP_PORT_OBJECT</a> PortObject;
00091     PORT_MESSAGE CapturedReplyMessage;
00092     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00093     <a class="code" href="../../d5/d4/struct__LPCP__MESSAGE.html">PLPCP_MESSAGE</a> Msg;
00094     <a class="code" href="../../d5/d6/struct__ETHREAD.html">PETHREAD</a> CurrentThread;
00095     <a class="code" href="../../d5/d6/struct__ETHREAD.html">PETHREAD</a> WakeupThread;
00096 
00097     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00098 
00099     CurrentThread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
00100 
00101     <span class="comment">//</span>
00102     <span class="comment">//  Get previous processor mode and probe output arguments if necessary.</span>
00103     <span class="comment">//</span>
00104 
00105     PreviousMode = KeGetPreviousMode();
00106 
00107     <span class="keywordflow">if</span> (PreviousMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
00108 
00109         <span class="keywordflow">try</span> {
00110 
00111             <a class="code" href="../../d5/d8/ex_8h.html#a11">ProbeForRead</a>( <a class="code" href="../../d3/d8/client_8c.html#a125">ReplyMessage</a>,
00112                           <span class="keyword">sizeof</span>( *<a class="code" href="../../d3/d8/client_8c.html#a125">ReplyMessage</a> ),
00113                           <span class="keyword">sizeof</span>( ULONG ));
00114 
00115             CapturedReplyMessage = *<a class="code" href="../../d3/d8/client_8c.html#a125">ReplyMessage</a>;
00116 
00117         } except( <a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a> ) {
00118 
00119             <span class="keywordflow">return</span> GetExceptionCode();
00120         }
00121 
00122     } <span class="keywordflow">else</span> {
00123 
00124         CapturedReplyMessage = *<a class="code" href="../../d3/d8/client_8c.html#a125">ReplyMessage</a>;
00125     }
00126 
00127     <span class="comment">//</span>
00128     <span class="comment">//  Make sure DataLength is valid with respect to header size and total</span>
00129     <span class="comment">//  length</span>
00130     <span class="comment">//</span>
00131 
00132     <span class="keywordflow">if</span> ((((CLONG)CapturedReplyMessage.u1.s1.DataLength) + <span class="keyword">sizeof</span>( PORT_MESSAGE )) &gt;
00133         ((CLONG)CapturedReplyMessage.u1.s1.TotalLength)) {
00134 
00135         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
00136     }
00137 
00138     <span class="comment">//</span>
00139     <span class="comment">//  Make sure the user didn't give us a bogus reply message id</span>
00140     <span class="comment">//</span>
00141 
00142     <span class="keywordflow">if</span> (CapturedReplyMessage.MessageId == 0) {
00143 
00144         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
00145     }
00146 
00147     <span class="comment">//</span>
00148     <span class="comment">//  Reference the port object by handle</span>
00149     <span class="comment">//</span>
00150 
00151     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d0/d7/lpcp_8h.html#a10">LpcpReferencePortObject</a>( <a class="code" href="../../d7/d7/uclient_8c.html#a3">PortHandle</a>,
00152                                       0,
00153                                       PreviousMode,
00154                                       &amp;PortObject );
00155 
00156     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
00157 
00158         <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00159     }
00160 
00161     <a class="code" href="../../d0/d7/lpcp_8h.html#a7">LpcpSaveThread</a> (PortObject);
00162 
00163     <span class="comment">//</span>
00164     <span class="comment">//  Validate the message length</span>
00165     <span class="comment">//</span>
00166 
00167     <span class="keywordflow">if</span> (((ULONG)CapturedReplyMessage.u1.s1.TotalLength &gt; PortObject-&gt;<a class="code" href="../../d9/d4/struct__LPCP__PORT__OBJECT.html#o9">MaxMessageLength</a>) ||
00168         ((ULONG)CapturedReplyMessage.u1.s1.TotalLength &lt;= (ULONG)CapturedReplyMessage.u1.s1.DataLength)) {
00169 
00170         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( PortObject );
00171 
00172         <span class="keywordflow">return</span> STATUS_PORT_MESSAGE_TOO_LONG;
00173     }
00174 
00175     <span class="comment">//</span>
00176     <span class="comment">//  Translate the ClientId from the connection request into a thread</span>
00177     <span class="comment">//  pointer.  This is a referenced pointer to keep the thread from</span>
00178     <span class="comment">//  evaporating out from under us.</span>
00179     <span class="comment">//</span>
00180 
00181     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d1/d0/pscid_8c.html#a0">PsLookupProcessThreadByCid</a>( &amp;CapturedReplyMessage.ClientId,
00182                                          <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00183                                          &amp;WakeupThread );
00184 
00185     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
00186 
00187         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( PortObject );
00188 
00189         <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00190     }
00191 
00192     <span class="comment">//</span>
00193     <span class="comment">//  Acquire the mutex that guards the LpcReplyMessage field of the thread</span>
00194     <span class="comment">//  and get the pointer to the message that the thread is waiting for a</span>
00195     <span class="comment">//  reply to.</span>
00196     <span class="comment">//</span>
00197 
00198     <a class="code" href="../../d0/d7/lpcp_8h.html#a3">LpcpAcquireLpcpLock</a>();
00199 
00200     Msg = (<a class="code" href="../../d5/d4/struct__LPCP__MESSAGE.html">PLPCP_MESSAGE</a>)<a class="code" href="../../d3/d7/lpcqueue_8c.html#a4">LpcpAllocateFromPortZone</a>( CapturedReplyMessage.u1.s1.TotalLength );
00201 
00202     <span class="keywordflow">if</span> (Msg == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00203 
00204         <a class="code" href="../../d0/d7/lpcp_8h.html#a4">LpcpReleaseLpcpLock</a>();
00205 
00206         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( WakeupThread );
00207         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( PortObject );
00208 
00209         <span class="keywordflow">return</span> STATUS_NO_MEMORY;
00210     }
00211 
00212     <span class="comment">//</span>
00213     <span class="comment">//  See if the thread is waiting for a reply to the message specified on</span>
00214     <span class="comment">//  this call.  If not then a bogus message has been specified, so</span>
00215     <span class="comment">//  release the mutex, dereference the thread and return failure.</span>
00216     <span class="comment">//</span>
00217     <span class="comment">//  We also fail this request if the caller isn't replying to a request</span>
00218     <span class="comment">//  message.  For example, if the caller is replying to a connection</span>
00219     <span class="comment">//  request</span>
00220     <span class="comment">//</span>
00221 
00222     <span class="keywordflow">if</span> ((WakeupThread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o15">LpcReplyMessageId</a> != CapturedReplyMessage.MessageId)
00223 
00224             ||
00225 
00226         ((WakeupThread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o14">LpcReplyMessage</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
00227          (((<a class="code" href="../../d5/d4/struct__LPCP__MESSAGE.html">PLPCP_MESSAGE</a>)(WakeupThread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o14">LpcReplyMessage</a>))-&gt;Request.u2.s2.Type &amp; ~LPC_KERNELMODE_MESSAGE) != LPC_REQUEST)) {
00228 
00229         <a class="code" href="../../d0/d7/lpcp_8h.html#a12">LpcpPrint</a>(( <span class="stringliteral">"%s Attempted reply to Thread %lx (%s)\n"</span>,
00230                     <a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a>()-&gt;ImageFileName,
00231                     WakeupThread,
00232                     <a class="code" href="../../d1/d9/ps_8h.html#a17">THREAD_TO_PROCESS</a>( WakeupThread )-&gt;ImageFileName ));
00233 
00234         <a class="code" href="../../d0/d7/lpcp_8h.html#a12">LpcpPrint</a>(( <span class="stringliteral">"failed.  MessageId == %u  Client Id: %x.%x\n"</span>,
00235                     CapturedReplyMessage.MessageId,
00236                     CapturedReplyMessage.ClientId.UniqueProcess,
00237                     CapturedReplyMessage.ClientId.UniqueThread ));
00238 
00239         <a class="code" href="../../d0/d7/lpcp_8h.html#a12">LpcpPrint</a>(( <span class="stringliteral">"         Thread MessageId == %u  Client Id: %x.%x\n"</span>,
00240                     WakeupThread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o15">LpcReplyMessageId</a>,
00241                     WakeupThread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o12">Cid</a>.UniqueProcess,
00242                     WakeupThread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o12">Cid</a>.UniqueThread ));
00243 
00244 <span class="preprocessor">#if DBG</span>
00245 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (LpcpStopOnReplyMismatch) {
00246 
00247             DbgBreakPoint();
00248         }
00249 <span class="preprocessor">#endif</span>
00250 <span class="preprocessor"></span>
00251         <a class="code" href="../../d3/d7/lpcqueue_8c.html#a5">LpcpFreeToPortZone</a>( Msg, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
00252 
00253         <a class="code" href="../../d0/d7/lpcp_8h.html#a4">LpcpReleaseLpcpLock</a>();
00254 
00255         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( WakeupThread );
00256         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( PortObject );
00257 
00258         <span class="keywordflow">return</span> STATUS_REPLY_MESSAGE_MISMATCH;
00259     }
00260 
00261     <span class="comment">//</span>
00262     <span class="comment">//  Copy the reply message to the request message buffer.  Do this before</span>
00263     <span class="comment">//  we actually fiddle with the wakeup threads fields.  Otherwise we</span>
00264     <span class="comment">//  could mess up its state</span>
00265     <span class="comment">//</span>
00266 
00267     <span class="keywordflow">try</span> {
00268 
00269         <a class="code" href="../../d0/d7/lpcp_8h.html#a31">LpcpMoveMessage</a>( &amp;Msg-&gt;<a class="code" href="../../d5/d4/struct__LPCP__MESSAGE.html#o8">Request</a>,
00270                          &amp;CapturedReplyMessage,
00271                          (<a class="code" href="../../d3/d8/client_8c.html#a125">ReplyMessage</a> + 1),
00272                          LPC_REPLY,
00273                          <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00274 
00275     } except( <a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a> ) {
00276 
00277         <a class="code" href="../../d3/d7/lpcqueue_8c.html#a5">LpcpFreeToPortZone</a>( Msg, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
00278 
00279         <a class="code" href="../../d0/d7/lpcp_8h.html#a4">LpcpReleaseLpcpLock</a>();
00280 
00281         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( WakeupThread );
00282         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( PortObject );
00283 
00284         <span class="keywordflow">return</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = GetExceptionCode());
00285     }
00286 
00287     <span class="comment">//</span>
00288     <span class="comment">//  At this point we know the thread is waiting for our reply</span>
00289     <span class="comment">//</span>
00290 
00291     <a class="code" href="../../d0/d7/lpcp_8h.html#a13">LpcpTrace</a>(( <span class="stringliteral">"%s Sending Reply Msg %lx (%u, %x) [%08x %08x %08x %08x] to Thread %lx (%s)\n"</span>,
00292                 <a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a>()-&gt;ImageFileName,
00293                 Msg,
00294                 CapturedReplyMessage.MessageId,
00295                 CapturedReplyMessage.u2.s2.DataInfoOffset,
00296                 *((PULONG)(Msg+1)+0),
00297                 *((PULONG)(Msg+1)+1),
00298                 *((PULONG)(Msg+1)+2),
00299                 *((PULONG)(Msg+1)+3),
00300                 WakeupThread,
00301                 <a class="code" href="../../d1/d9/ps_8h.html#a17">THREAD_TO_PROCESS</a>( WakeupThread )-&gt;ImageFileName ));
00302 
00303     <span class="comment">//</span>
00304     <span class="comment">//  Locate and free the messsage from the port.  This call use to</span>
00305     <span class="comment">//  test for (CapturedReplyMessage.u2.s2.DataInfoOffset != 0) as a</span>
00306     <span class="comment">//  prerequisite for doing the call.</span>
00307     <span class="comment">//</span>
00308 
00309     <a class="code" href="../../d3/d7/lpcqueue_8c.html#a7">LpcpFreeDataInfoMessage</a>( PortObject,
00310                              CapturedReplyMessage.MessageId,
00311                              CapturedReplyMessage.CallbackId );
00312 
00313     <span class="comment">//</span>
00314     <span class="comment">//  Add an extra reference so LpcExitThread does not evaporate the</span>
00315     <span class="comment">//  pointer before we get to the wait below</span>
00316     <span class="comment">//</span>
00317 
00318     <a class="code" href="../../d4/d0/ob_8h.html#a15">ObReferenceObject</a>( WakeupThread );
00319 
00320     <span class="comment">//</span>
00321     <span class="comment">//  Release the mutex that guards the LpcReplyMessage field after marking</span>
00322     <span class="comment">//  message as being replied to.</span>
00323     <span class="comment">//</span>
00324 
00325     Msg-&gt;RepliedToThread = WakeupThread;
00326 
00327     WakeupThread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o15">LpcReplyMessageId</a> = 0;
00328     WakeupThread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o14">LpcReplyMessage</a> = (PVOID)Msg;
00329 
00330     <span class="comment">//</span>
00331     <span class="comment">//  Remove the thread from the reply rundown list as we are sending the</span>
00332     <span class="comment">//  reply.</span>
00333     <span class="comment">//</span>
00334 
00335     <span class="keywordflow">if</span> (!WakeupThread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o32">LpcExitThreadCalled</a> &amp;&amp; !IsListEmpty( &amp;WakeupThread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o5">LpcReplyChain</a> )) {
00336 
00337         RemoveEntryList( &amp;WakeupThread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o5">LpcReplyChain</a> );
00338 
00339         InitializeListHead( &amp;WakeupThread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o5">LpcReplyChain</a> );
00340     }
00341 
00342     <span class="keywordflow">if</span> ((CurrentThread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o34">LpcReceivedMsgIdValid</a>) &amp;&amp;
00343         (CurrentThread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o31">LpcReceivedMessageId</a> == CapturedReplyMessage.MessageId)) {
00344 
00345         CurrentThread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o31">LpcReceivedMessageId</a> = 0;
00346         CurrentThread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o34">LpcReceivedMsgIdValid</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00347     }
00348 
00349     <a class="code" href="../../d0/d7/lpcp_8h.html#a4">LpcpReleaseLpcpLock</a>();
00350 
00351     <span class="comment">//</span>
00352     <span class="comment">//  Wake up the thread that is waiting for an answer to its request</span>
00353     <span class="comment">//  inside of NtRequestWaitReplyPort or NtReplyWaitReplyPort.  That</span>
00354     <span class="comment">//  will dereference itself when it wakes up.</span>
00355     <span class="comment">//</span>
00356 
00357     <a class="code" href="../../d1/d6/semphobj_8c.html#a3">KeReleaseSemaphore</a>( &amp;WakeupThread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o13">LpcReplySemaphore</a>,
00358                         0,
00359                         1<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>,
00360                         <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00361 
00362     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( WakeupThread );
00363 
00364     <span class="comment">//</span>
00365     <span class="comment">//  Dereference port object and return the system service status.</span>
00366     <span class="comment">//</span>
00367 
00368     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( PortObject );
00369 
00370     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00371 }
00372 
00373 
00374 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00375"></a><a class="code" href="../../d5/d7/lpcreply_8c.html#a2">00375</a> <a class="code" href="../../d5/d7/lpcreply_8c.html#a2">NtReplyWaitReplyPort</a> (
00376     IN HANDLE PortHandle,
00377     IN OUT PPORT_MESSAGE ReplyMessage
00378     )
00379 
00380 <span class="comment">/*++</span>
00381 <span class="comment"></span>
00382 <span class="comment">Routine Description:</span>
00383 <span class="comment"></span>
00384 <span class="comment">    A client and server process can send a reply to a previous message and</span>
00385 <span class="comment">    block waiting for a reply using the NtReplyWaitReplyPort service:</span>
00386 <span class="comment"></span>
00387 <span class="comment">    This service works the same as NtReplyPort, except that after delivering</span>
00388 <span class="comment">    the reply message, it blocks waiting for a reply to a previous message.</span>
00389 <span class="comment">    When the reply is received, it will be placed in the location specified</span>
00390 <span class="comment">    by the ReplyMessage parameter.</span>
00391 <span class="comment"></span>
00392 <span class="comment">Arguments:</span>
00393 <span class="comment"></span>
00394 <span class="comment">    PortHandle - Specifies the handle of the communication port that the</span>
00395 <span class="comment">        original message was received from.</span>
00396 <span class="comment"></span>
00397 <span class="comment">    ReplyMessage - Specifies a pointer to the reply message to be sent.</span>
00398 <span class="comment">        The ClientId and MessageId fields determine which thread will</span>
00399 <span class="comment">        get the reply.  This buffer also receives any reply that comes</span>
00400 <span class="comment">        back from the wait.</span>
00401 <span class="comment"></span>
00402 <span class="comment">Return Value:</span>
00403 <span class="comment"></span>
00404 <span class="comment">    Status code that indicates whether or not the operation was</span>
00405 <span class="comment">    successful.</span>
00406 <span class="comment"></span>
00407 <span class="comment">--*/</span>
00408 
00409 {
00410     <a class="code" href="../../d0/d9/ntosdef_8h.html#a39">KPROCESSOR_MODE</a> PreviousMode;
00411     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00412     <a class="code" href="../../d9/d4/struct__LPCP__PORT__OBJECT.html">PLPCP_PORT_OBJECT</a> PortObject;
00413     PORT_MESSAGE CapturedReplyMessage;
00414     <a class="code" href="../../d5/d4/struct__LPCP__MESSAGE.html">PLPCP_MESSAGE</a> Msg;
00415     <a class="code" href="../../d5/d6/struct__ETHREAD.html">PETHREAD</a> CurrentThread;
00416     <a class="code" href="../../d5/d6/struct__ETHREAD.html">PETHREAD</a> WakeupThread;
00417 
00418     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00419 
00420     CurrentThread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
00421 
00422     <span class="comment">//</span>
00423     <span class="comment">//  Get previous processor mode and probe output arguments if necessary.</span>
00424     <span class="comment">//</span>
00425 
00426     PreviousMode = KeGetPreviousMode();
00427 
00428     <span class="keywordflow">if</span> (PreviousMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
00429 
00430         <span class="keywordflow">try</span> {
00431 
00432             <a class="code" href="../../d5/d8/ex_8h.html#a259">ProbeForWrite</a>( <a class="code" href="../../d3/d8/client_8c.html#a125">ReplyMessage</a>,
00433                            <span class="keyword">sizeof</span>( *<a class="code" href="../../d3/d8/client_8c.html#a125">ReplyMessage</a> ),
00434                            <span class="keyword">sizeof</span>( ULONG ));
00435 
00436             CapturedReplyMessage = *<a class="code" href="../../d3/d8/client_8c.html#a125">ReplyMessage</a>;
00437 
00438         } except( <a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a> ) {
00439 
00440             <span class="keywordflow">return</span> GetExceptionCode();
00441         }
00442 
00443     } <span class="keywordflow">else</span> {
00444 
00445         CapturedReplyMessage = *<a class="code" href="../../d3/d8/client_8c.html#a125">ReplyMessage</a>;
00446     }
00447 
00448     <span class="comment">//</span>
00449     <span class="comment">//  Make sure DataLength is valid with respect to header size and total length</span>
00450     <span class="comment">//</span>
00451 
00452     <span class="keywordflow">if</span> ((((CLONG)CapturedReplyMessage.u1.s1.DataLength) + <span class="keyword">sizeof</span>( PORT_MESSAGE )) &gt;
00453         ((CLONG)CapturedReplyMessage.u1.s1.TotalLength)) {
00454 
00455         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
00456     }
00457 
00458     <span class="comment">//</span>
00459     <span class="comment">//  Make sure the user didn't give us a bogus reply message id</span>
00460     <span class="comment">//</span>
00461 
00462     <span class="keywordflow">if</span> (CapturedReplyMessage.MessageId == 0) {
00463 
00464         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
00465     }
00466 
00467     <span class="comment">//</span>
00468     <span class="comment">//  Reference the communication port object by handle.  Return status if</span>
00469     <span class="comment">//  unsuccessful.</span>
00470     <span class="comment">//</span>
00471 
00472     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d0/d7/lpcp_8h.html#a10">LpcpReferencePortObject</a>( <a class="code" href="../../d7/d7/uclient_8c.html#a3">PortHandle</a>,
00473                                       0,
00474                                       PreviousMode,
00475                                       &amp;PortObject );
00476 
00477     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
00478 
00479         <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00480     }
00481 
00482     <a class="code" href="../../d0/d7/lpcp_8h.html#a7">LpcpSaveThread</a> (PortObject);
00483 
00484     <span class="comment">//</span>
00485     <span class="comment">//  Validate the message length</span>
00486     <span class="comment">//</span>
00487 
00488     <span class="keywordflow">if</span> (((ULONG)CapturedReplyMessage.u1.s1.TotalLength &gt; PortObject-&gt;<a class="code" href="../../d9/d4/struct__LPCP__PORT__OBJECT.html#o9">MaxMessageLength</a>) ||
00489         ((ULONG)CapturedReplyMessage.u1.s1.TotalLength &lt;= (ULONG)CapturedReplyMessage.u1.s1.DataLength)) {
00490 
00491         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( PortObject );
00492 
00493         <span class="keywordflow">return</span> STATUS_PORT_MESSAGE_TOO_LONG;
00494     }
00495 
00496     <span class="comment">//</span>
00497     <span class="comment">//  Translate the ClientId from the connection request into a</span>
00498     <span class="comment">//  thread pointer.  This is a referenced pointer to keep the thread</span>
00499     <span class="comment">//  from evaporating out from under us.</span>
00500     <span class="comment">//</span>
00501 
00502     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d1/d0/pscid_8c.html#a0">PsLookupProcessThreadByCid</a>( &amp;CapturedReplyMessage.ClientId,
00503                                          <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00504                                          &amp;WakeupThread );
00505 
00506     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
00507 
00508         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( PortObject );
00509 
00510         <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00511     }
00512 
00513     <span class="comment">//</span>
00514     <span class="comment">//  Acquire the mutex that gaurds the LpcReplyMessage field of</span>
00515     <span class="comment">//  the thread and get the pointer to the message that the thread</span>
00516     <span class="comment">//  is waiting for a reply to.</span>
00517     <span class="comment">//</span>
00518 
00519     <a class="code" href="../../d0/d7/lpcp_8h.html#a3">LpcpAcquireLpcpLock</a>();
00520 
00521     Msg = (<a class="code" href="../../d5/d4/struct__LPCP__MESSAGE.html">PLPCP_MESSAGE</a>)<a class="code" href="../../d3/d7/lpcqueue_8c.html#a4">LpcpAllocateFromPortZone</a>( CapturedReplyMessage.u1.s1.TotalLength );
00522 
00523     <span class="keywordflow">if</span> (Msg == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00524 
00525         <a class="code" href="../../d0/d7/lpcp_8h.html#a4">LpcpReleaseLpcpLock</a>();
00526 
00527         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( WakeupThread );
00528         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( PortObject );
00529 
00530         <span class="keywordflow">return</span> STATUS_NO_MEMORY;
00531     }
00532 
00533     <span class="comment">//</span>
00534     <span class="comment">//  See if the thread is waiting for a reply to the message</span>
00535     <span class="comment">//  specified on this call.  If not then a bogus message</span>
00536     <span class="comment">//  has been specified, so release the mutex, dereference the thread</span>
00537     <span class="comment">//  and return failure.</span>
00538     <span class="comment">//</span>
00539     <span class="comment">//  We also fail this request if the caller isn't replying to a request</span>
00540     <span class="comment">//  message.  For example, if the caller is replying to a connection</span>
00541     <span class="comment">//  request</span>
00542     <span class="comment">//</span>
00543 
00544     <span class="keywordflow">if</span> ((WakeupThread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o15">LpcReplyMessageId</a> != CapturedReplyMessage.MessageId)
00545 
00546             ||
00547 
00548         ((WakeupThread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o14">LpcReplyMessage</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
00549          (((<a class="code" href="../../d5/d4/struct__LPCP__MESSAGE.html">PLPCP_MESSAGE</a>)(WakeupThread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o14">LpcReplyMessage</a>))-&gt;Request.u2.s2.Type &amp; ~LPC_KERNELMODE_MESSAGE) != LPC_REQUEST)) {
00550 
00551         <a class="code" href="../../d0/d7/lpcp_8h.html#a12">LpcpPrint</a>(( <span class="stringliteral">"%s Attempted reply wait reply to Thread %lx (%s)\n"</span>,
00552                     <a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a>()-&gt;ImageFileName,
00553                     WakeupThread,
00554                     <a class="code" href="../../d1/d9/ps_8h.html#a17">THREAD_TO_PROCESS</a>( WakeupThread )-&gt;ImageFileName ));
00555 
00556         <a class="code" href="../../d0/d7/lpcp_8h.html#a12">LpcpPrint</a>(( <span class="stringliteral">"failed.  MessageId == %u  Client Id: %x.%x\n"</span>,
00557                     CapturedReplyMessage.MessageId,
00558                     CapturedReplyMessage.ClientId.UniqueProcess,
00559                     CapturedReplyMessage.ClientId.UniqueThread ));
00560 
00561         <a class="code" href="../../d0/d7/lpcp_8h.html#a12">LpcpPrint</a>(( <span class="stringliteral">"         Thread MessageId == %u  Client Id: %x.%x\n"</span>,
00562                     WakeupThread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o15">LpcReplyMessageId</a>,
00563                     WakeupThread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o12">Cid</a>.UniqueProcess,
00564                     WakeupThread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o12">Cid</a>.UniqueThread ));
00565 
00566 <span class="preprocessor">#if DBG</span>
00567 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (LpcpStopOnReplyMismatch) {
00568 
00569             DbgBreakPoint();
00570         }
00571 <span class="preprocessor">#endif</span>
00572 <span class="preprocessor"></span>
00573         <a class="code" href="../../d3/d7/lpcqueue_8c.html#a5">LpcpFreeToPortZone</a>( Msg, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
00574 
00575         <a class="code" href="../../d0/d7/lpcp_8h.html#a4">LpcpReleaseLpcpLock</a>();
00576 
00577         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( WakeupThread );
00578         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( PortObject );
00579 
00580         <span class="keywordflow">return</span> STATUS_REPLY_MESSAGE_MISMATCH;
00581     }
00582 
00583     <span class="comment">//</span>
00584     <span class="comment">//  Copy the reply message to the request message buffer.  Do this before</span>
00585     <span class="comment">//  we actually fiddle with the wakeup threads fields.  Otherwise we</span>
00586     <span class="comment">//  could mess up its state</span>
00587     <span class="comment">//</span>
00588 
00589     <span class="keywordflow">try</span> {
00590 
00591         <a class="code" href="../../d0/d7/lpcp_8h.html#a31">LpcpMoveMessage</a>( &amp;Msg-&gt;<a class="code" href="../../d5/d4/struct__LPCP__MESSAGE.html#o8">Request</a>,
00592                          &amp;CapturedReplyMessage,
00593                          (<a class="code" href="../../d3/d8/client_8c.html#a125">ReplyMessage</a> + 1),
00594                          LPC_REPLY,
00595                          <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00596 
00597     } except( <a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a> ) {
00598 
00599         <a class="code" href="../../d3/d7/lpcqueue_8c.html#a5">LpcpFreeToPortZone</a>( Msg, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
00600 
00601         <a class="code" href="../../d0/d7/lpcp_8h.html#a4">LpcpReleaseLpcpLock</a>();
00602 
00603         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( WakeupThread );
00604         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( PortObject );
00605 
00606         <span class="keywordflow">return</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = GetExceptionCode());
00607     }
00608 
00609     <span class="comment">//</span>
00610     <span class="comment">//  At this point we know the thread is waiting for our reply</span>
00611     <span class="comment">//</span>
00612 
00613     <a class="code" href="../../d0/d7/lpcp_8h.html#a13">LpcpTrace</a>(( <span class="stringliteral">"%s Sending Reply Wait Reply Msg %lx (%u, %x) [%08x %08x %08x %08x] to Thread %lx (%s)\n"</span>,
00614                 <a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a>()-&gt;ImageFileName,
00615                 Msg,
00616                 CapturedReplyMessage.MessageId,
00617                 CapturedReplyMessage.u2.s2.DataInfoOffset,
00618                 *((PULONG)(Msg+1)+0),
00619                 *((PULONG)(Msg+1)+1),
00620                 *((PULONG)(Msg+1)+2),
00621                 *((PULONG)(Msg+1)+3),
00622                 WakeupThread,
00623                 <a class="code" href="../../d1/d9/ps_8h.html#a17">THREAD_TO_PROCESS</a>( WakeupThread )-&gt;ImageFileName ));
00624 
00625     <span class="comment">//</span>
00626     <span class="comment">//  Locate and free the messsage from the port.  This call use to</span>
00627     <span class="comment">//  test for (CapturedReplyMessage.u2.s2.DataInfoOffset != 0) as a</span>
00628     <span class="comment">//  prerequisite for doing the call.</span>
00629     <span class="comment">//</span>
00630 
00631     <a class="code" href="../../d3/d7/lpcqueue_8c.html#a7">LpcpFreeDataInfoMessage</a>( PortObject,
00632                              CapturedReplyMessage.MessageId,
00633                              CapturedReplyMessage.CallbackId );
00634 
00635     <span class="comment">//</span>
00636     <span class="comment">//  Add an extra reference so LpcExitThread does not evaporate</span>
00637     <span class="comment">//  the pointer before we get to the wait below</span>
00638     <span class="comment">//</span>
00639 
00640     <a class="code" href="../../d4/d0/ob_8h.html#a15">ObReferenceObject</a>( WakeupThread );
00641 
00642     <span class="comment">//</span>
00643     <span class="comment">//  Release the mutex that guards the LpcReplyMessage field</span>
00644     <span class="comment">//  after marking message as being replied to.</span>
00645     <span class="comment">//</span>
00646 
00647     Msg-&gt;RepliedToThread = WakeupThread;
00648 
00649     WakeupThread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o15">LpcReplyMessageId</a> = 0;
00650     WakeupThread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o14">LpcReplyMessage</a> = (PVOID)Msg;
00651 
00652     <span class="comment">//</span>
00653     <span class="comment">//  Remove the thread from the reply rundown list as we are sending the reply.</span>
00654     <span class="comment">//</span>
00655 
00656     <span class="keywordflow">if</span> (!WakeupThread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o32">LpcExitThreadCalled</a> &amp;&amp; !IsListEmpty( &amp;WakeupThread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o5">LpcReplyChain</a> )) {
00657 
00658         RemoveEntryList( &amp;WakeupThread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o5">LpcReplyChain</a> );
00659 
00660         InitializeListHead( &amp;WakeupThread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o5">LpcReplyChain</a> );
00661     }
00662 
00663     <span class="comment">//</span>
00664     <span class="comment">//  Set ourselves up to get the following reply</span>
00665     <span class="comment">//</span>
00666 
00667     CurrentThread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o15">LpcReplyMessageId</a> = CapturedReplyMessage.MessageId;
00668     CurrentThread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o14">LpcReplyMessage</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00669 
00670     <span class="keywordflow">if</span> ((CurrentThread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o34">LpcReceivedMsgIdValid</a>) &amp;&amp;
00671         (CurrentThread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o31">LpcReceivedMessageId</a> == CapturedReplyMessage.MessageId)) {
00672 
00673         CurrentThread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o31">LpcReceivedMessageId</a> = 0;
00674         CurrentThread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o34">LpcReceivedMsgIdValid</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00675     }
00676 
00677     <a class="code" href="../../d0/d7/lpcp_8h.html#a4">LpcpReleaseLpcpLock</a>();
00678 
00679     <span class="comment">//</span>
00680     <span class="comment">//  Wake up the thread that is waiting for an answer to its request</span>
00681     <span class="comment">//  inside of NtRequestWaitReplyPort or NtReplyWaitReplyPort.  That</span>
00682     <span class="comment">//  will dereference itself when it wakes up.</span>
00683     <span class="comment">//</span>
00684 
00685     <a class="code" href="../../d1/d6/semphobj_8c.html#a3">KeReleaseSemaphore</a>( &amp;WakeupThread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o13">LpcReplySemaphore</a>,
00686                         1,
00687                         1,
00688                         <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00689 
00690     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( WakeupThread );
00691 
00692     <span class="comment">//</span>
00693     <span class="comment">//  And wait for a reply</span>
00694     <span class="comment">//</span>
00695 
00696     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;CurrentThread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o13">LpcReplySemaphore</a>,
00697                                     <a class="code" href="../../d6/d7/halmips_8h.html#a455">Executive</a>,
00698                                     PreviousMode,
00699                                     <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00700                                     <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00701 
00702     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_USER_APC) {
00703 
00704         <span class="comment">//</span>
00705         <span class="comment">//  if the semaphore is signaled, then clear it</span>
00706         <span class="comment">//</span>
00707 
00708         <span class="keywordflow">if</span> (<a class="code" href="../../d1/d6/semphobj_8c.html#a2">KeReadStateSemaphore</a>( &amp;CurrentThread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o13">LpcReplySemaphore</a> )) {
00709 
00710             <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;CurrentThread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o13">LpcReplySemaphore</a>,
00711                                    <a class="code" href="../../d6/d7/halmips_8h.html#a0">WrExecutive</a>,
00712                                    <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
00713                                    <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00714                                    <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00715 
00716             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
00717         }
00718     }
00719 
00720     <span class="comment">//</span>
00721     <span class="comment">//  If the wait succeeded, copy the reply to the reply buffer.</span>
00722     <span class="comment">//</span>
00723 
00724     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_SUCCESS) {
00725 
00726         <span class="comment">//</span>
00727         <span class="comment">//  Acquire the mutex that guards the request message queue.  Remove</span>
00728         <span class="comment">//  the request message from the list of messages being processed and</span>
00729         <span class="comment">//  free the message back to the queue's zone.  If the zone's free</span>
00730         <span class="comment">//  list was zero before freeing this message then pulse the free</span>
00731         <span class="comment">//  event after free the message so that threads waiting to allocate</span>
00732         <span class="comment">//  a request message buffer will wake up.  Finally, release the mutex</span>
00733         <span class="comment">//  and return the system service status.</span>
00734         <span class="comment">//</span>
00735 
00736         <a class="code" href="../../d0/d7/lpcp_8h.html#a3">LpcpAcquireLpcpLock</a>();
00737 
00738         Msg = CurrentThread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o14">LpcReplyMessage</a>;
00739         CurrentThread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o14">LpcReplyMessage</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00740 
00741 <span class="preprocessor">#if DBG</span>
00742 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (Msg != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00743 
00744             <a class="code" href="../../d0/d7/lpcp_8h.html#a13">LpcpTrace</a>(( <span class="stringliteral">"%s Got Reply Msg %lx (%u) [%08x %08x %08x %08x] for Thread %lx (%s)\n"</span>,
00745                         <a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a>()-&gt;ImageFileName,
00746                         Msg,
00747                         Msg-&gt;Request.MessageId,
00748                         *((PULONG)(Msg+1)+0),
00749                         *((PULONG)(Msg+1)+1),
00750                         *((PULONG)(Msg+1)+2),
00751                         *((PULONG)(Msg+1)+3),
00752                         CurrentThread,
00753                         <a class="code" href="../../d1/d9/ps_8h.html#a17">THREAD_TO_PROCESS</a>( CurrentThread )-&gt;ImageFileName ));
00754 
00755             <span class="keywordflow">if</span> (!IsListEmpty( &amp;Msg-&gt;Entry )) {
00756 
00757                 <a class="code" href="../../d0/d7/lpcp_8h.html#a13">LpcpTrace</a>(( <span class="stringliteral">"Reply Msg %lx has non-empty list entry\n"</span>, Msg ));
00758             }
00759         }
00760 <span class="preprocessor">#endif</span>
00761 <span class="preprocessor"></span>
00762         <a class="code" href="../../d0/d7/lpcp_8h.html#a4">LpcpReleaseLpcpLock</a>();
00763 
00764         <span class="keywordflow">if</span> (Msg != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00765 
00766             <span class="keywordflow">try</span> {
00767 
00768                 <a class="code" href="../../d0/d7/lpcp_8h.html#a31">LpcpMoveMessage</a>( <a class="code" href="../../d3/d8/client_8c.html#a125">ReplyMessage</a>,
00769                                  &amp;Msg-&gt;Request,
00770                                  (&amp;Msg-&gt;Request) + 1,
00771                                  0,
00772                                  <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00773 
00774             } except( <a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a> ) {
00775 
00776                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = GetExceptionCode();
00777             }
00778 
00779             <span class="comment">//</span>
00780             <span class="comment">//  Acquire the LPC mutex and decrement the reference count for the</span>
00781             <span class="comment">//  message.  If the reference count goes to zero the message will be</span>
00782             <span class="comment">//  deleted.</span>
00783             <span class="comment">//</span>
00784 
00785             <a class="code" href="../../d0/d7/lpcp_8h.html#a3">LpcpAcquireLpcpLock</a>();
00786 
00787             <span class="keywordflow">if</span> (Msg-&gt;RepliedToThread != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00788 
00789                 <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( Msg-&gt;RepliedToThread );
00790 
00791                 Msg-&gt;RepliedToThread = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00792             }
00793 
00794             <a class="code" href="../../d3/d7/lpcqueue_8c.html#a5">LpcpFreeToPortZone</a>( Msg, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
00795 
00796             <a class="code" href="../../d0/d7/lpcp_8h.html#a4">LpcpReleaseLpcpLock</a>();
00797         }
00798     }
00799 
00800     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( PortObject );
00801 
00802     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00803 }
00804 
00805 
00806 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00807"></a><a class="code" href="../../d5/d7/lpcreply_8c.html#a3">00807</a> <a class="code" href="../../d5/d7/lpcreply_8c.html#a3">NtReadRequestData</a> (
00808     IN HANDLE PortHandle,
00809     IN PPORT_MESSAGE Message,
00810     IN ULONG DataEntryIndex,
00811     OUT PVOID Buffer,
00812     IN ULONG BufferSize,
00813     OUT PULONG NumberOfBytesRead OPTIONAL
00814     )
00815 
00816 <span class="comment">/*++</span>
00817 <span class="comment"></span>
00818 <span class="comment">Routine Description:</span>
00819 <span class="comment"></span>
00820 <span class="comment">    This routine is used to copy data from a port message into the user</span>
00821 <span class="comment">    supplied buffer.</span>
00822 <span class="comment"></span>
00823 <span class="comment">Arguments:</span>
00824 <span class="comment"></span>
00825 <span class="comment">    PortHandle - Supplies the port from which the message is being read</span>
00826 <span class="comment"></span>
00827 <span class="comment">    Message - Supplies the message that we are trying to read</span>
00828 <span class="comment"></span>
00829 <span class="comment">    DataEntryIndex - Supplies the index of the port data entry in the</span>
00830 <span class="comment">        preceeding message that we are reading</span>
00831 <span class="comment"></span>
00832 <span class="comment">    Buffer - Supplies the location into which the data is to be read</span>
00833 <span class="comment"></span>
00834 <span class="comment">    BufferSize - Supplies the size, in bytes, of the preceeding buffer</span>
00835 <span class="comment"></span>
00836 <span class="comment">    NumberOfBytesRead - Optionally returns the number of bytes read into</span>
00837 <span class="comment">        the buffer</span>
00838 <span class="comment"></span>
00839 <span class="comment">Return Value:</span>
00840 <span class="comment"></span>
00841 <span class="comment">    NTSTATUS - An appropriate status value</span>
00842 <span class="comment"></span>
00843 <span class="comment">--*/</span>
00844 
00845 {
00846     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00847 
00848     <span class="keywordflow">return</span> <a class="code" href="../../d5/d7/lpcreply_8c.html#a0">LpcpCopyRequestData</a>( <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00849                                 <a class="code" href="../../d7/d7/uclient_8c.html#a3">PortHandle</a>,
00850                                 Message,
00851                                 DataEntryIndex,
00852                                 <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>,
00853                                 <a class="code" href="../../d6/d2/rtqkey_8c.html#a5">BufferSize</a>,
00854                                 NumberOfBytesRead );
00855 }
00856 
00857 
00858 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00859"></a><a class="code" href="../../d5/d7/lpcreply_8c.html#a4">00859</a> <a class="code" href="../../d5/d7/lpcreply_8c.html#a4">NtWriteRequestData</a> (
00860     IN HANDLE PortHandle,
00861     IN PPORT_MESSAGE Message,
00862     IN ULONG DataEntryIndex,
00863     IN PVOID Buffer,
00864     IN ULONG BufferSize,
00865     OUT PULONG NumberOfBytesWritten OPTIONAL
00866     )
00867 
00868 <span class="comment">/*++</span>
00869 <span class="comment"></span>
00870 <span class="comment">Routine Description:</span>
00871 <span class="comment"></span>
00872 <span class="comment">    This routine is used to copy data from the user supplied buffer into the</span>
00873 <span class="comment">    port message</span>
00874 <span class="comment"></span>
00875 <span class="comment">Arguments:</span>
00876 <span class="comment"></span>
00877 <span class="comment">    PortHandle - Supplies the port into which the message is being written</span>
00878 <span class="comment"></span>
00879 <span class="comment">    Message - Supplies the message that we are trying to write</span>
00880 <span class="comment"></span>
00881 <span class="comment">    DataEntryIndex - Supplies the index of the port data entry in the</span>
00882 <span class="comment">        preceeding message that we are writing</span>
00883 <span class="comment"></span>
00884 <span class="comment">    Buffer - Supplies the location into which the data is to be written</span>
00885 <span class="comment"></span>
00886 <span class="comment">    BufferSize - Supplies the size, in bytes, of the preceeding buffer</span>
00887 <span class="comment"></span>
00888 <span class="comment">    NumberOfBytesRead - Optionally returns the number of bytes written from</span>
00889 <span class="comment">        the buffer</span>
00890 <span class="comment"></span>
00891 <span class="comment">Return Value:</span>
00892 <span class="comment"></span>
00893 <span class="comment">    NTSTATUS - An appropriate status value</span>
00894 <span class="comment"></span>
00895 <span class="comment">--*/</span>
00896 
00897 {
00898     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00899 
00900     <span class="keywordflow">return</span> <a class="code" href="../../d5/d7/lpcreply_8c.html#a0">LpcpCopyRequestData</a>( <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
00901                                 <a class="code" href="../../d7/d7/uclient_8c.html#a3">PortHandle</a>,
00902                                 Message,
00903                                 DataEntryIndex,
00904                                 <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>,
00905                                 <a class="code" href="../../d6/d2/rtqkey_8c.html#a5">BufferSize</a>,
00906                                 NumberOfBytesWritten );
00907 }
00908 
00909 
00910 <span class="comment">//</span>
00911 <span class="comment">//  Local support routine</span>
00912 <span class="comment">//</span>
00913 
00914 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00915"></a><a class="code" href="../../d5/d7/lpcreply_8c.html#a0">00915</a> <a class="code" href="../../d5/d7/lpcreply_8c.html#a0">LpcpCopyRequestData</a> (
00916     IN BOOLEAN WriteToMessageData,
00917     IN HANDLE PortHandle,
00918     IN PPORT_MESSAGE Message,
00919     IN ULONG DataEntryIndex,
00920     IN PVOID Buffer,
00921     IN ULONG BufferSize,
00922     OUT PULONG NumberOfBytesCopied OPTIONAL
00923     )
00924 
00925 <span class="comment">/*++</span>
00926 <span class="comment"></span>
00927 <span class="comment">Routine Description:</span>
00928 <span class="comment"></span>
00929 <span class="comment">    This routine will copy data to or from the user supplied buffer and the</span>
00930 <span class="comment">    port message data information buffer</span>
00931 <span class="comment"></span>
00932 <span class="comment">Arguments:</span>
00933 <span class="comment"></span>
00934 <span class="comment">    WriteToMessageData - TRUE if the data is to be copied from the user buffer</span>
00935 <span class="comment">        to the message and FALSE otherwise</span>
00936 <span class="comment"></span>
00937 <span class="comment">    PortHandle - Supplies the port into which the message is being manipulated</span>
00938 <span class="comment"></span>
00939 <span class="comment">    Message - Supplies the message that we are trying to manipulate</span>
00940 <span class="comment"></span>
00941 <span class="comment">    DataEntryIndex - Supplies the index of the port data entry in the</span>
00942 <span class="comment">        preceeding message that we are transfering</span>
00943 <span class="comment"></span>
00944 <span class="comment">    Buffer - Supplies the location into which the data is to be transfered</span>
00945 <span class="comment"></span>
00946 <span class="comment">    BufferSize - Supplies the size, in bytes, of the preceeding buffer</span>
00947 <span class="comment"></span>
00948 <span class="comment">    NumberOfBytesRead - Optionally returns the number of bytes transfered from</span>
00949 <span class="comment">        the buffer</span>
00950 <span class="comment"></span>
00951 <span class="comment">Return Value:</span>
00952 <span class="comment"></span>
00953 <span class="comment">    NTSTATUS - An appropriate status value</span>
00954 <span class="comment"></span>
00955 <span class="comment">--*/</span>
00956 
00957 {
00958     <a class="code" href="../../d0/d9/ntosdef_8h.html#a39">KPROCESSOR_MODE</a> PreviousMode;
00959     <a class="code" href="../../d9/d4/struct__LPCP__PORT__OBJECT.html">PLPCP_PORT_OBJECT</a> PortObject;
00960     <a class="code" href="../../d5/d4/struct__LPCP__MESSAGE.html">PLPCP_MESSAGE</a> Msg;
00961     PLIST_ENTRY Head, Next;
00962     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00963     <a class="code" href="../../d5/d6/struct__ETHREAD.html">PETHREAD</a> <a class="code" href="../../d7/d7/uclient_8c.html#a6">ClientThread</a>;
00964     PPORT_DATA_INFORMATION DataInfo;
00965     PPORT_DATA_ENTRY DataEntry;
00966     PORT_MESSAGE CapturedMessage;
00967     PORT_DATA_INFORMATION CapturedDataInfo;
00968     PORT_DATA_ENTRY CapturedDataEntry;
00969     ULONG BytesCopied;
00970 
00971     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00972 
00973     <span class="comment">//</span>
00974     <span class="comment">//  Get previous processor mode and probe output arguments if necessary.</span>
00975     <span class="comment">//</span>
00976 
00977     PreviousMode = KeGetPreviousMode();
00978 
00979     <span class="keywordflow">if</span> (PreviousMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
00980 
00981         <span class="keywordflow">try</span> {
00982 
00983             <span class="comment">//</span>
00984             <span class="comment">//  We are either reading or writing the user buffer</span>
00985             <span class="comment">//</span>
00986 
00987             <span class="keywordflow">if</span> (WriteToMessageData) {
00988 
00989                 <a class="code" href="../../d5/d8/ex_8h.html#a11">ProbeForRead</a>( <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>,
00990                               <a class="code" href="../../d6/d2/rtqkey_8c.html#a5">BufferSize</a>,
00991                               1 );
00992 
00993             } <span class="keywordflow">else</span> {
00994 
00995                 <a class="code" href="../../d5/d8/ex_8h.html#a259">ProbeForWrite</a>( <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>,
00996                                <a class="code" href="../../d6/d2/rtqkey_8c.html#a5">BufferSize</a>,
00997                                1 );
00998             }
00999 
01000             <a class="code" href="../../d5/d8/ex_8h.html#a11">ProbeForRead</a>( Message,
01001                           <span class="keyword">sizeof</span>( *Message ),
01002                           <span class="keyword">sizeof</span>( ULONG ));
01003 
01004             CapturedMessage = *Message;
01005 
01006             <span class="keywordflow">if</span> (ARGUMENT_PRESENT( NumberOfBytesCopied )) {
01007 
01008                 <a class="code" href="../../d5/d8/ex_8h.html#a40">ProbeForWriteUlong</a>( NumberOfBytesCopied );
01009             }
01010 
01011         } except( <a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a> ) {
01012 
01013             <span class="keywordflow">return</span> GetExceptionCode();
01014         }
01015 
01016     } <span class="keywordflow">else</span> {
01017 
01018         CapturedMessage = *Message;
01019     }
01020 
01021     <span class="comment">//</span>
01022     <span class="comment">//  The message better have at least one data entry</span>
01023     <span class="comment">//</span>
01024 
01025     <span class="keywordflow">if</span> (CapturedMessage.u2.s2.DataInfoOffset == 0) {
01026 
01027         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
01028     }
01029 
01030     <span class="comment">//</span>
01031     <span class="comment">//  Reference the port object by handle</span>
01032     <span class="comment">//</span>
01033 
01034     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d0/d7/lpcp_8h.html#a10">LpcpReferencePortObject</a>( <a class="code" href="../../d7/d7/uclient_8c.html#a3">PortHandle</a>,
01035                                       0,
01036                                       PreviousMode,
01037                                       &amp;PortObject );
01038 
01039     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
01040 
01041         <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01042     }
01043 
01044     <a class="code" href="../../d0/d7/lpcp_8h.html#a7">LpcpSaveThread</a> (PortObject);
01045 
01046     <span class="comment">//</span>
01047     <span class="comment">//  Translate the ClientId from the connection request into a</span>
01048     <span class="comment">//  thread pointer.  This is a referenced pointer to keep the thread</span>
01049     <span class="comment">//  from evaporating out from under us.</span>
01050     <span class="comment">//</span>
01051 
01052     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d1/d0/pscid_8c.html#a0">PsLookupProcessThreadByCid</a>( &amp;CapturedMessage.ClientId,
01053                                          <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
01054                                          &amp;<a class="code" href="../../d7/d7/uclient_8c.html#a6">ClientThread</a> );
01055 
01056     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
01057 
01058         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( PortObject );
01059 
01060         <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01061     }
01062 
01063     <span class="comment">//</span>
01064     <span class="comment">//  Acquire the mutex that guards the LpcReplyMessage field of</span>
01065     <span class="comment">//  the thread and get the pointer to the message that the thread</span>
01066     <span class="comment">//  is waiting for a reply to.</span>
01067     <span class="comment">//</span>
01068 
01069     <a class="code" href="../../d0/d7/lpcp_8h.html#a3">LpcpAcquireLpcpLock</a>();
01070 
01071     <span class="comment">//</span>
01072     <span class="comment">//  See if the thread is waiting for a reply to the message</span>
01073     <span class="comment">//  specified on this call.  If not then a bogus message</span>
01074     <span class="comment">//  has been specified, so release the mutex, dereference the thread</span>
01075     <span class="comment">//  and return failure.</span>
01076     <span class="comment">//</span>
01077 
01078     <span class="keywordflow">if</span> (<a class="code" href="../../d7/d7/uclient_8c.html#a6">ClientThread</a>-&gt;LpcReplyMessageId != CapturedMessage.MessageId) {
01079 
01080         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_REPLY_MESSAGE_MISMATCH;
01081 
01082     } <span class="keywordflow">else</span> {
01083 
01084         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_PARAMETER;
01085 
01086         Msg = <a class="code" href="../../d3/d7/lpcqueue_8c.html#a8">LpcpFindDataInfoMessage</a>( PortObject,
01087                                        CapturedMessage.MessageId,
01088                                        CapturedMessage.CallbackId );
01089 
01090         <span class="keywordflow">if</span> (Msg != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01091 
01092             DataInfo = (PPORT_DATA_INFORMATION)((PUCHAR)&amp;Msg-&gt;<a class="code" href="../../d5/d4/struct__LPCP__MESSAGE.html#o8">Request</a> +
01093                                                 Msg-&gt;<a class="code" href="../../d5/d4/struct__LPCP__MESSAGE.html#o8">Request</a>.u2.s2.DataInfoOffset);
01094 
01095             <span class="comment">//</span>
01096             <span class="comment">//  Make sure the caller isn't asking for an index beyond what's</span>
01097             <span class="comment">//  in the message</span>
01098             <span class="comment">//</span>
01099 
01100             <span class="keywordflow">if</span> (DataInfo-&gt;CountDataEntries &gt; DataEntryIndex) {
01101 
01102                 DataEntry = &amp;DataInfo-&gt;DataEntries[ DataEntryIndex ];
01103                 CapturedDataEntry = *DataEntry;
01104 
01105                 <span class="keywordflow">if</span> (CapturedDataEntry.Size &gt;= <a class="code" href="../../d6/d2/rtqkey_8c.html#a5">BufferSize</a>) {
01106 
01107                     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
01108                 }
01109             }
01110         }
01111     }
01112 
01113     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
01114 
01115         <a class="code" href="../../d0/d7/lpcp_8h.html#a4">LpcpReleaseLpcpLock</a>();
01116 
01117         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( <a class="code" href="../../d7/d7/uclient_8c.html#a6">ClientThread</a> );
01118         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( PortObject );
01119 
01120         <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01121     }
01122 
01123     <span class="comment">//</span>
01124     <span class="comment">//  Release the mutex that guards the LpcReplyMessage field</span>
01125     <span class="comment">//</span>
01126 
01127     <a class="code" href="../../d0/d7/lpcp_8h.html#a4">LpcpReleaseLpcpLock</a>();
01128 
01129     <span class="comment">//</span>
01130     <span class="comment">//  Copy the message data</span>
01131     <span class="comment">//</span>
01132 
01133     <span class="keywordflow">if</span> (WriteToMessageData) {
01134 
01135         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d5/readwrt_8c.html#a11">MmCopyVirtualMemory</a>( <a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a>(),
01136                                       <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>,
01137                                       <a class="code" href="../../d1/d9/ps_8h.html#a17">THREAD_TO_PROCESS</a>( <a class="code" href="../../d7/d7/uclient_8c.html#a6">ClientThread</a> ),
01138                                       CapturedDataEntry.Base,
01139                                       <a class="code" href="../../d6/d2/rtqkey_8c.html#a5">BufferSize</a>,
01140                                       PreviousMode,
01141                                       &amp;BytesCopied );
01142 
01143     } <span class="keywordflow">else</span> {
01144 
01145         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d5/readwrt_8c.html#a11">MmCopyVirtualMemory</a>( <a class="code" href="../../d1/d9/ps_8h.html#a17">THREAD_TO_PROCESS</a>( <a class="code" href="../../d7/d7/uclient_8c.html#a6">ClientThread</a> ),
01146                                       CapturedDataEntry.Base,
01147                                       <a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a>(),
01148                                       <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>,
01149                                       <a class="code" href="../../d6/d2/rtqkey_8c.html#a5">BufferSize</a>,
01150                                       PreviousMode,
01151                                       &amp;BytesCopied );
01152     }
01153 
01154     <span class="keywordflow">if</span> (ARGUMENT_PRESENT( NumberOfBytesCopied )) {
01155 
01156         <span class="keywordflow">try</span> {
01157 
01158             *NumberOfBytesCopied = BytesCopied;
01159 
01160         } except( <a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a> ) {
01161 
01162             NOTHING;
01163         }
01164     }
01165 
01166     <span class="comment">//</span>
01167     <span class="comment">//  Dereference client thread and return the system service status.</span>
01168     <span class="comment">//</span>
01169 
01170     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( <a class="code" href="../../d7/d7/uclient_8c.html#a6">ClientThread</a> );
01171     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( PortObject );
01172 
01173     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01174 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:40:40 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
