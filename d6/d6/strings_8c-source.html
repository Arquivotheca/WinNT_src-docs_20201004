<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: strings.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>strings.c</h1><a href="../../d5/d7/strings_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/****************************** Module Header ******************************\</span>
00002 <span class="comment">* Module Name: strings.c</span>
00003 <span class="comment">*</span>
00004 <span class="comment">* Copyright (c) 1985 - 1999, Microsoft Corporation</span>
00005 <span class="comment">*</span>
00006 <span class="comment">* This module contains all the string handling APIs and functions.  Since</span>
00007 <span class="comment">* they don't access server-specific data they belong here in the client DLL.</span>
00008 <span class="comment">*</span>
00009 <span class="comment">* History:</span>
00010 <span class="comment">* 10-18-90 DarrinM      Created.</span>
00011 <span class="comment">\***************************************************************************/</span>
00012 
00013 <span class="preprocessor">#include "<a class="code" href="../../d7/d3/w32_2ntuser_2client_2precomp_8h.html">precomp.h</a>"</span>
00014 <span class="preprocessor">#pragma hdrstop</span>
00015 <span class="preprocessor"></span>
00016 <span class="comment">/* LATER these should be in a public header file!!!</span>
00017 <span class="comment"> * Assorted defines used to support the standard Windows ANSI code page</span>
00018 <span class="comment"> * (now known as code page 1252 and officially registered by IBM).</span>
00019 <span class="comment"> * This is intended only for the PDK release.  Subsequent releases will</span>
00020 <span class="comment"> * use the NLSAPI and Unicode.</span>
00021 <span class="comment"> */</span>
<a name="l00022"></a><a class="code" href="../../d5/d7/strings_8c.html#a0">00022</a> <span class="preprocessor">#define LATIN_CAPITAL_LETTER_A_GRAVE    (CHAR)0xc0</span>
<a name="l00023"></a><a class="code" href="../../d5/d7/strings_8c.html#a1">00023</a> <span class="preprocessor"></span><span class="preprocessor">#define LATIN_CAPITAL_LETTER_THORN      (CHAR)0xde</span>
<a name="l00024"></a><a class="code" href="../../d5/d7/strings_8c.html#a2">00024</a> <span class="preprocessor"></span><span class="preprocessor">#define LATIN_SMALL_LETTER_SHARP_S      (CHAR)0xdf</span>
<a name="l00025"></a><a class="code" href="../../d5/d7/strings_8c.html#a3">00025</a> <span class="preprocessor"></span><span class="preprocessor">#define LATIN_SMALL_LETTER_Y_DIAERESIS  (CHAR)0xff</span>
<a name="l00026"></a><a class="code" href="../../d5/d7/strings_8c.html#a4">00026</a> <span class="preprocessor"></span><span class="preprocessor">#define DIVISION_SIGN                   (CHAR)0xf7</span>
<a name="l00027"></a><a class="code" href="../../d5/d7/strings_8c.html#a5">00027</a> <span class="preprocessor"></span><span class="preprocessor">#define MULTIPLICATION_SIGN             (CHAR)0xd7</span>
00028 <span class="preprocessor"></span>
00029 
00030 <span class="comment">/***************************************************************************\</span>
00031 <span class="comment">* CharLowerA (API)</span>
00032 <span class="comment">*</span>
00033 <span class="comment">* Convert either a single character or an entire string to lower case.  The</span>
00034 <span class="comment">* two cases are differentiated by checking the high-word of psz.  If it is</span>
00035 <span class="comment">* 0 then we just convert the low-word of psz.</span>
00036 <span class="comment">*</span>
00037 <span class="comment">* History:</span>
00038 <span class="comment">* 11-26-90 DarrinM      Created non-NLS version.</span>
00039 <span class="comment">* 06-22-91 GregoryW     Modified to support code page 1252.  This is for</span>
00040 <span class="comment">*                       the PDK release only.  After the PDK this routine</span>
00041 <span class="comment">*                       will be modified to use the NLSAPI.  Also renamed</span>
00042 <span class="comment">*                       API to conform to new naming conventions.  AnsiLower</span>
00043 <span class="comment">*                       is now a #define which resolves to this routine.</span>
00044 <span class="comment">\***************************************************************************/</span>
00045 
<a name="l00046"></a><a class="code" href="../../d5/d7/strings_8c.html#a7">00046</a> LPSTR WINAPI <a class="code" href="../../d5/d7/strings_8c.html#a7">CharLowerA</a>(
00047     LPSTR psz)
00048 {
00049     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> st;
00050 
00051     <span class="comment">/*</span>
00052 <span class="comment">     * Early out for NULL string or '\0'</span>
00053 <span class="comment">     */</span>
00054     <span class="keywordflow">if</span> (psz == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00055         <span class="keywordflow">return</span> psz;
00056     }
00057 
00058     <span class="keywordflow">if</span> (!<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a98">IS_PTR</a>(psz)) {
00059         WCHAR wch;
00060 
00061 <span class="preprocessor">#ifdef FE_SB // CharLowerA()</span>
00062 <span class="preprocessor"></span>        <span class="comment">/*</span>
00063 <span class="comment">         * if only DBCS Leadbyte was passed, just return the character.</span>
00064 <span class="comment">         * Same behavior as Windows 3.1J and Windows 95 FarEast version.</span>
00065 <span class="comment">         */</span>
00066         <span class="keywordflow">if</span> (<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a125">IS_DBCS_ENABLED</a>() &amp;&amp; IsDBCSLeadByte((<a class="code" href="../../d9/d7/halvprnt_8c.html#a0">BYTE</a>)(ULONG_PTR)psz)) {
00067             <span class="keywordflow">return</span> psz;
00068         }
00069 <span class="preprocessor">#endif // FE_SB</span>
00070 <span class="preprocessor"></span>
00071         <span class="comment">//</span>
00072         <span class="comment">// LATER 14 Feb 92 GregoryW</span>
00073         <span class="comment">//    For DBCS code pages is a double byte character ever</span>
00074         <span class="comment">//    passed in the low word of psz or is the high nibble</span>
00075         <span class="comment">//    of the low word always ignored?</span>
00076         <span class="comment">//</span>
00077         st = <a class="code" href="../../d9/d6/nlsxlat_8c.html#a33">RtlMultiByteToUnicodeN</a>(&amp;wch, <span class="keyword">sizeof</span>(WCHAR), <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, (PCH)&amp;psz, <span class="keyword">sizeof</span>(<a class="code" href="../../d1/d1/bench_8c.html#a16">CHAR</a>));
00078         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(st)) {
00079             <span class="comment">/*</span>
00080 <span class="comment">             * Failed!  Caller is not expecting failure, CharLowerA does not</span>
00081 <span class="comment">             * have a failure indicator, so just return the original character.</span>
00082 <span class="comment">             */</span>
00083             RIPMSG1(RIP_WARNING, <span class="stringliteral">"CharLowerA(%#p) failed\n"</span>, psz);
00084         } <span class="keywordflow">else</span> {
00085             <span class="comment">/*</span>
00086 <span class="comment">             * The next two calls never fail.</span>
00087 <span class="comment">             */</span>
00088             LCMapStringW(LOCALE_USER_DEFAULT, LCMAP_LOWERCASE, &amp;wch, 1, &amp;wch, 1);
00089             <a class="code" href="../../d9/d6/nlsxlat_8c.html#a37">RtlUnicodeToMultiByteN</a>((PCH)&amp;psz, <span class="keyword">sizeof</span>(<a class="code" href="../../d1/d1/bench_8c.html#a16">CHAR</a>), <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, &amp;wch, <span class="keyword">sizeof</span>(WCHAR));
00090         }
00091         <span class="keywordflow">return</span> psz;
00092 
00093     }
00094 
00095     <span class="comment">/*</span>
00096 <span class="comment">     * psz is a null-terminated string</span>
00097 <span class="comment">     */</span>
00098     <a class="code" href="../../d5/d7/strings_8c.html#a13">CharLowerBuffA</a>(psz, <a class="code" href="../../d2/d7/regtest_8c.html#a2">strlen</a>(psz)+1);
00099     <span class="keywordflow">return</span> psz;
00100 }
00101 
00102 
00103 <span class="comment">/***************************************************************************\</span>
00104 <span class="comment">* CharUpperA (API)</span>
00105 <span class="comment">*</span>
00106 <span class="comment">* Convert either a single character or an entire string to upper case.  The</span>
00107 <span class="comment">* two cases are differentiated by checking the high-word of psz.  If it is</span>
00108 <span class="comment">* 0 then we just convert the low-word of psz.</span>
00109 <span class="comment">*</span>
00110 <span class="comment">* History:</span>
00111 <span class="comment">* 12-03-90 IanJa        derived from DarrinM's non-NLS AnsiLower</span>
00112 <span class="comment">* 06-22-91 GregoryW     Modified to support code page 1252.  This is for</span>
00113 <span class="comment">*                       the PDK release only.  After the PDK this routine</span>
00114 <span class="comment">*                       will be modified to use the NLSAPI.  Also renamed</span>
00115 <span class="comment">*                       API to conform to new naming conventions.  AnsiUpper</span>
00116 <span class="comment">*                       is now a #define which resolves to this routine.</span>
00117 <span class="comment">\***************************************************************************/</span>
00118 
<a name="l00119"></a><a class="code" href="../../d5/d7/strings_8c.html#a8">00119</a> LPSTR WINAPI <a class="code" href="../../d5/d7/strings_8c.html#a8">CharUpperA</a>(
00120     LPSTR psz)
00121 {
00122     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> st;
00123 
00124     <span class="comment">/*</span>
00125 <span class="comment">     * Early out for NULL string or '\0'</span>
00126 <span class="comment">     */</span>
00127     <span class="keywordflow">if</span> (psz == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00128         <span class="keywordflow">return</span> psz;
00129     }
00130 
00131     <span class="keywordflow">if</span> (!<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a98">IS_PTR</a>(psz)) {
00132         WCHAR wch;
00133 
00134 <span class="preprocessor">#ifdef FE_SB // CharLowerA()</span>
00135 <span class="preprocessor"></span>        <span class="comment">/*</span>
00136 <span class="comment">         * if only DBCS Leadbyte was passed, just return the character.</span>
00137 <span class="comment">         * Same behavior as Windows 3.1J and Windows 95 FarEast version.</span>
00138 <span class="comment">         */</span>
00139         <span class="keywordflow">if</span> (<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a125">IS_DBCS_ENABLED</a>() &amp;&amp; IsDBCSLeadByte((<a class="code" href="../../d9/d7/halvprnt_8c.html#a0">BYTE</a>)(ULONG_PTR)psz)) {
00140             <span class="keywordflow">return</span> psz;
00141         }
00142 <span class="preprocessor">#endif // FE_SB</span>
00143 <span class="preprocessor"></span>
00144         <span class="comment">//</span>
00145         <span class="comment">// LATER 14 Feb 92 GregoryW</span>
00146         <span class="comment">//    For DBCS code pages is a double byte character ever</span>
00147         <span class="comment">//    passed in the low word of psz or is the high nibble</span>
00148         <span class="comment">//    of the low word always ignored?</span>
00149         <span class="comment">//</span>
00150         st = <a class="code" href="../../d9/d6/nlsxlat_8c.html#a33">RtlMultiByteToUnicodeN</a>(&amp;wch, <span class="keyword">sizeof</span>(WCHAR), <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, (PCH)&amp;psz, <span class="keyword">sizeof</span>(<a class="code" href="../../d1/d1/bench_8c.html#a16">CHAR</a>));
00151         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(st)) {
00152             <span class="comment">/*</span>
00153 <span class="comment">             * Failed!  Caller is not expecting failure, CharUpperA does not</span>
00154 <span class="comment">             * have a failure indicator, so return the original character.</span>
00155 <span class="comment">             */</span>
00156             RIPMSG1(RIP_WARNING, <span class="stringliteral">"CharUpperA(%#p) failed\n"</span>, psz);
00157         } <span class="keywordflow">else</span> {
00158             <span class="comment">/*</span>
00159 <span class="comment">             * The next two calls never fail.</span>
00160 <span class="comment">             */</span>
00161             LCMapStringW(LOCALE_USER_DEFAULT, LCMAP_UPPERCASE, &amp;wch, 1, &amp;wch, 1);
00162             <a class="code" href="../../d9/d6/nlsxlat_8c.html#a37">RtlUnicodeToMultiByteN</a>((PCH)&amp;psz, <span class="keyword">sizeof</span>(<a class="code" href="../../d1/d1/bench_8c.html#a16">CHAR</a>), <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, &amp;wch, <span class="keyword">sizeof</span>(WCHAR));
00163         }
00164         <span class="keywordflow">return</span> psz;
00165 
00166     }
00167 
00168     <span class="comment">/*</span>
00169 <span class="comment">     * psz is a null-terminated string</span>
00170 <span class="comment">     */</span>
00171     <a class="code" href="../../d5/d7/strings_8c.html#a14">CharUpperBuffA</a>(psz, <a class="code" href="../../d2/d7/regtest_8c.html#a2">strlen</a>(psz)+1);
00172     <span class="keywordflow">return</span> psz;
00173 }
00174 
00175 
00176 <span class="comment">/***************************************************************************\</span>
00177 <span class="comment">* CharNextA (API)</span>
00178 <span class="comment">*</span>
00179 <span class="comment">* Move to next character in string unless already at '\0' terminator</span>
00180 <span class="comment">* DOES NOT WORK CORRECTLY FOR DBCS (eg: Japanese)</span>
00181 <span class="comment">*</span>
00182 <span class="comment">* History:</span>
00183 <span class="comment">* 12-03-90 IanJa        Created non-NLS version.</span>
00184 <span class="comment">* 06-22-91 GregoryW     Renamed API to conform to new naming conventions.</span>
00185 <span class="comment">*                       AnsiNext is now a #define which resolves to this</span>
00186 <span class="comment">*                       routine.  This routine is only intended to support</span>
00187 <span class="comment">*                       code page 1252 for the PDK release.</span>
00188 <span class="comment">\***************************************************************************/</span>
00189 
<a name="l00190"></a><a class="code" href="../../d5/d7/strings_8c.html#a9">00190</a> LPSTR WINAPI <a class="code" href="../../d5/d7/strings_8c.html#a9">CharNextA</a>(
00191     LPCSTR lpCurrentChar)
00192 {
00193 <span class="preprocessor">#ifdef FE_SB // CharNextA(): dbcs enabling</span>
00194 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a125">IS_DBCS_ENABLED</a>() &amp;&amp; IsDBCSLeadByte(*lpCurrentChar)) {
00195         lpCurrentChar++;
00196     }
00197     <span class="comment">/*</span>
00198 <span class="comment">     * if we have only DBCS LeadingByte, we will point string-terminaler.</span>
00199 <span class="comment">     */</span>
00200 <span class="preprocessor">#endif // FE_SB</span>
00201 <span class="preprocessor"></span>
00202     <span class="keywordflow">if</span> (*lpCurrentChar) {
00203         lpCurrentChar++;
00204     }
00205     <span class="keywordflow">return</span> (LPSTR)lpCurrentChar;
00206 }
00207 
00208 
00209 <span class="comment">/***************************************************************************\</span>
00210 <span class="comment">* CharNextExA (API)</span>
00211 <span class="comment">*</span>
00212 <span class="comment">* Move to next character in string unless already at '\0' terminator.</span>
00213 <span class="comment">*</span>
00214 <span class="comment">* History:</span>
00215 <span class="comment">* 05-01-95 GregoryW     Ported from Win95.</span>
00216 <span class="comment">\***************************************************************************/</span>
00217 
<a name="l00218"></a><a class="code" href="../../d5/d7/strings_8c.html#a10">00218</a> LPSTR WINAPI <a class="code" href="../../d5/d7/strings_8c.html#a10">CharNextExA</a>(
00219     WORD CodePage,
00220     LPCSTR lpCurrentChar,
00221     DWORD dwFlags)
00222 {
00223     <span class="keywordflow">if</span> (lpCurrentChar == (LPSTR)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)
00224     {
00225         <span class="keywordflow">return</span> (LPSTR)lpCurrentChar;
00226     }
00227 
00228     <span class="keywordflow">if</span> (IsDBCSLeadByteEx(CodePage, *lpCurrentChar))
00229     {
00230         lpCurrentChar++;
00231     }
00232 
00233     <span class="keywordflow">if</span> (*lpCurrentChar)
00234     {
00235         lpCurrentChar++;
00236     }
00237     <span class="keywordflow">return</span> (LPSTR)lpCurrentChar;
00238 
00239     UNREFERENCED_PARAMETER(<a class="code" href="../../d3/d8/propapi_8h.html#a34">dwFlags</a>);
00240 }
00241 
00242 
00243 <span class="comment">/***************************************************************************\</span>
00244 <span class="comment">* CharPrevA (API)</span>
00245 <span class="comment">*</span>
00246 <span class="comment">* Move to previous character in string, unless already at start</span>
00247 <span class="comment">* DOES NOT WORK CORRECTLY FOR DBCS (eg: Japanese)</span>
00248 <span class="comment">*</span>
00249 <span class="comment">* History:</span>
00250 <span class="comment">* 12-03-90 IanJa        Created non-NLS version.</span>
00251 <span class="comment">* 06-22-91 GregoryW     Renamed API to conform to new naming conventions.</span>
00252 <span class="comment">*                       AnsiPrev is now a #define which resolves to this</span>
00253 <span class="comment">*                       routine.  This routine is only intended to support</span>
00254 <span class="comment">*                       code page 1252 for the PDK release.</span>
00255 <span class="comment">\***************************************************************************/</span>
00256 
<a name="l00257"></a><a class="code" href="../../d5/d7/strings_8c.html#a11">00257</a> LPSTR WINAPI <a class="code" href="../../d5/d7/strings_8c.html#a11">CharPrevA</a>(
00258     LPCSTR lpStart,
00259     LPCSTR lpCurrentChar)
00260 {
00261 <span class="preprocessor">#ifdef FE_SB // CharPrevA : dbcs enabling</span>
00262 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (lpCurrentChar &gt; lpStart) {
00263         <span class="keywordflow">if</span> (<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a125">IS_DBCS_ENABLED</a>()) {
00264             LPCSTR lpChar;
00265             <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a11">BOOL</a> bDBC = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00266 
00267             <span class="keywordflow">for</span> (lpChar = --lpCurrentChar - 1 ; lpChar &gt;= lpStart ; lpChar--) {
00268                 <span class="keywordflow">if</span> (!IsDBCSLeadByte(*lpChar))
00269                     <span class="keywordflow">break</span>;
00270                 bDBC = !bDBC;
00271             }
00272 
00273             <span class="keywordflow">if</span> (bDBC)
00274                 lpCurrentChar--;
00275         }
00276         <span class="keywordflow">else</span>
00277             lpCurrentChar--;
00278     }
00279     <span class="keywordflow">return</span> (LPSTR)lpCurrentChar;
00280 <span class="preprocessor">#else</span>
00281 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (lpCurrentChar &gt; lpStart) {
00282         lpCurrentChar--;
00283     }
00284     <span class="keywordflow">return</span> (LPSTR)lpCurrentChar;
00285 <span class="preprocessor">#endif // FE_SB</span>
00286 <span class="preprocessor"></span>}
00287 
00288 <span class="comment">/***************************************************************************\</span>
00289 <span class="comment">* CharPrevExA (API)</span>
00290 <span class="comment">*</span>
00291 <span class="comment">* Move to previous character in string, unless already at start.</span>
00292 <span class="comment">*</span>
00293 <span class="comment">* History:</span>
00294 <span class="comment">* 05-01-95 GregoryW     Ported from Win95.</span>
00295 <span class="comment">\***************************************************************************/</span>
00296 
<a name="l00297"></a><a class="code" href="../../d5/d7/strings_8c.html#a12">00297</a> LPSTR WINAPI <a class="code" href="../../d5/d7/strings_8c.html#a12">CharPrevExA</a>(
00298     WORD CodePage,
00299     LPCSTR lpStart,
00300     LPCSTR lpCurrentChar,
00301     DWORD dwFlags)
00302 {
00303     <span class="keywordflow">if</span> (lpCurrentChar &gt; lpStart) {
00304         LPCSTR lpChar;
00305         <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a11">BOOL</a> bDBC = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00306 
00307         <span class="keywordflow">for</span> (lpChar = --lpCurrentChar - 1 ; lpChar &gt;= lpStart ; lpChar--) {
00308             <span class="keywordflow">if</span> (!IsDBCSLeadByteEx(CodePage, *lpChar))
00309                 <span class="keywordflow">break</span>;
00310             bDBC = !bDBC;
00311         }
00312 
00313         <span class="keywordflow">if</span> (bDBC)
00314             lpCurrentChar--;
00315     }
00316     <span class="keywordflow">return</span> (LPSTR)lpCurrentChar;
00317 
00318     UNREFERENCED_PARAMETER(<a class="code" href="../../d3/d8/propapi_8h.html#a34">dwFlags</a>);
00319 }
00320 
00321 
00322 <span class="comment">/***************************************************************************\</span>
00323 <span class="comment">* CharLowerBuffA (API)</span>
00324 <span class="comment">*</span>
00325 <span class="comment">* History:</span>
00326 <span class="comment">* 14-Jan-1991 mikeke from win 3.0</span>
00327 <span class="comment">* 06-22-91 GregoryW     Renamed API to conform to new naming conventions.</span>
00328 <span class="comment">*                       AnsiLowerBuff is now a #define which resolves to this</span>
00329 <span class="comment">*                       routine.  This routine is only intended to support</span>
00330 <span class="comment">*                       code page 1252 for the PDK release.</span>
00331 <span class="comment">* 02-20-1992 GregoryW   Modified to use NLS API.</span>
00332 <span class="comment">\***************************************************************************/</span>
<a name="l00333"></a><a class="code" href="../../d5/d7/strings_8c.html#a6">00333</a> <span class="preprocessor">#define CCH_LOCAL_BUFF 256</span>
00334 <span class="preprocessor"></span>
<a name="l00335"></a><a class="code" href="../../d5/d7/strings_8c.html#a13">00335</a> <a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a> WINAPI <a class="code" href="../../d5/d7/strings_8c.html#a13">CharLowerBuffA</a>(
00336     LPSTR psz,
00337     DWORD nLength)
00338 {
00339     ULONG cb;
00340     WCHAR awchLocal[<a class="code" href="../../d5/d7/strings_8c.html#a6">CCH_LOCAL_BUFF</a>];
00341     LPWSTR pwszT = awchLocal;
00342     <span class="keywordtype">int</span> cwch;
00343 
00344     <span class="keywordflow">if</span> (nLength == 0) {
00345         <span class="keywordflow">return</span>(0);
00346     }
00347 
00348     <span class="comment">/*</span>
00349 <span class="comment">     * Convert ANSI to Unicode.</span>
00350 <span class="comment">     * Use awchLocal if it is big enough, otherwise allocate space.</span>
00351 <span class="comment">     */</span>
00352     cwch = MBToWCS(
00353             psz,       <span class="comment">// ANSI buffer</span>
00354             nLength,   <span class="comment">// length of buffer</span>
00355             &amp;pwszT,    <span class="comment">// address of Unicode string</span>
00356             (nLength &gt; <a class="code" href="../../d5/d7/strings_8c.html#a6">CCH_LOCAL_BUFF</a> ? -1 : nLength),
00357             (nLength &gt; <a class="code" href="../../d5/d7/strings_8c.html#a6">CCH_LOCAL_BUFF</a>) );
00358 
00359     <span class="keywordflow">if</span> (cwch != 0) {
00360         <a class="code" href="../../d8/d0/wstrings_8c.html#a12">CharLowerBuffW</a>(pwszT, cwch);
00361 
00362         <span class="comment">/*</span>
00363 <span class="comment">         * This can't fail</span>
00364 <span class="comment">         */</span>
00365         <a class="code" href="../../d9/d6/nlsxlat_8c.html#a37">RtlUnicodeToMultiByteN</a>(
00366                   psz,                   <span class="comment">// ANSI string</span>
00367                   nLength,               <span class="comment">// given to us</span>
00368                   &amp;cb,                   <span class="comment">// result length</span>
00369                   pwszT,                 <span class="comment">// Unicode string</span>
00370                   cwch * <span class="keyword">sizeof</span>(WCHAR)); <span class="comment">// length IN BYTES</span>
00371 
00372         <span class="keywordflow">if</span> (pwszT != awchLocal) {
00373             <a class="code" href="../../d6/d0/usercli_8h.html#a138">UserLocalFree</a>(pwszT);
00374         }
00375 
00376         <span class="keywordflow">return</span> (<a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a>)cb;
00377     }
00378 
00379     <span class="comment">/*</span>
00380 <span class="comment">     * MBToWCS failed!  The caller is not expecting failure,</span>
00381 <span class="comment">     * so we convert the string to lower case as best we can.</span>
00382 <span class="comment">     */</span>
00383     RIPMSG2(RIP_WARNING,
00384             <span class="stringliteral">"CharLowerBuffA(%#p, %lx) failed\n"</span>, psz, nLength);
00385 
00386     <span class="keywordflow">for</span> (cb=0; cb &lt; nLength; cb++) {
00387 <span class="preprocessor">#ifdef FE_SB // CharLowerBuffA(): skip double byte character</span>
00388 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a125">IS_DBCS_ENABLED</a>() &amp;&amp; IsDBCSLeadByte(psz[cb])) {
00389             cb++;
00390         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="../../d5/d7/strings_8c.html#a16">IsCharUpperA</a>(psz[cb])) {
00391             psz[cb] += <span class="charliteral">'a'</span>-<span class="charliteral">'A'</span>;
00392         }
00393 <span class="preprocessor">#else</span>
00394 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (<a class="code" href="../../d5/d7/strings_8c.html#a16">IsCharUpperA</a>(psz[cb])) {
00395             psz[cb] += <span class="charliteral">'a'</span>-<span class="charliteral">'A'</span>;
00396         }
00397 <span class="preprocessor">#endif // FE_SB</span>
00398 <span class="preprocessor"></span>    }
00399 
00400     <span class="keywordflow">return</span> nLength;
00401 }
00402 
00403 
00404 <span class="comment">/***************************************************************************\</span>
00405 <span class="comment">* CharUpperBuffA (API)</span>
00406 <span class="comment">*</span>
00407 <span class="comment">* History:</span>
00408 <span class="comment">* 14-Jan-1991 mikeke from win 3.0</span>
00409 <span class="comment">* 06-22-91 GregoryW     Renamed API to conform to new naming conventions.</span>
00410 <span class="comment">*                       AnsiUpperBuff is now a #define which resolves to this</span>
00411 <span class="comment">*                       routine.  This routine is only intended to support</span>
00412 <span class="comment">*                       code page 1252 for the PDK release.</span>
00413 <span class="comment">* 02-Feb-1992 GregoryW   Modified to use NLS API.</span>
00414 <span class="comment">\***************************************************************************/</span>
00415 
<a name="l00416"></a><a class="code" href="../../d5/d7/strings_8c.html#a14">00416</a> <a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a> WINAPI <a class="code" href="../../d5/d7/strings_8c.html#a14">CharUpperBuffA</a>(
00417     LPSTR psz,
00418     DWORD nLength)
00419 {
00420     <a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a> cb;
00421     WCHAR awchLocal[<a class="code" href="../../d5/d7/strings_8c.html#a6">CCH_LOCAL_BUFF</a>];
00422     LPWSTR pwszT = awchLocal;
00423     <span class="keywordtype">int</span> cwch;
00424 
00425     <span class="keywordflow">if</span> (nLength==0) {
00426         <span class="keywordflow">return</span>(0);
00427     }
00428 
00429     <span class="comment">/*</span>
00430 <span class="comment">     * Convert ANSI to Unicode.</span>
00431 <span class="comment">     * Use awchLocal if it is big enough, otherwise allocate space.</span>
00432 <span class="comment">     */</span>
00433     cwch = MBToWCS(
00434             psz,       <span class="comment">// ANSI buffer</span>
00435             nLength,   <span class="comment">// length of buffer</span>
00436             &amp;pwszT,    <span class="comment">// address of Unicode string</span>
00437             (nLength &gt; <a class="code" href="../../d5/d7/strings_8c.html#a6">CCH_LOCAL_BUFF</a> ? -1 : nLength),
00438             (nLength &gt; <a class="code" href="../../d5/d7/strings_8c.html#a6">CCH_LOCAL_BUFF</a>) );
00439 
00440     <span class="keywordflow">if</span> (cwch != 0) {
00441         <a class="code" href="../../d8/d0/wstrings_8c.html#a13">CharUpperBuffW</a>(pwszT, cwch);
00442 
00443         <a class="code" href="../../d9/d6/nlsxlat_8c.html#a37">RtlUnicodeToMultiByteN</a>(
00444                   psz,                   <span class="comment">// address of ANSI string</span>
00445                   nLength,               <span class="comment">// given to us</span>
00446                   &amp;cb,                   <span class="comment">// result length</span>
00447                   pwszT,                 <span class="comment">// Unicode string</span>
00448                   cwch * <span class="keyword">sizeof</span>(WCHAR)); <span class="comment">// length IN BYTES</span>
00449 
00450         <span class="keywordflow">if</span> (pwszT != awchLocal) {
00451             <a class="code" href="../../d6/d0/usercli_8h.html#a138">UserLocalFree</a>(pwszT);
00452         }
00453 
00454         <span class="keywordflow">return</span> (<a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a>)cb;
00455     }
00456 
00457     <span class="comment">/*</span>
00458 <span class="comment">     * MBToWCS failed!  The caller is not expecting failure,</span>
00459 <span class="comment">     * so we convert the string to upper case as best we can.</span>
00460 <span class="comment">     */</span>
00461     RIPMSG2(RIP_WARNING,
00462             <span class="stringliteral">"CharLowerBuffA(%#p, %lx) failed\n"</span>, psz, nLength);
00463 
00464     <span class="keywordflow">for</span> (cb=0; cb &lt; nLength; cb++) {
00465 <span class="preprocessor">#ifdef FE_SB // CharUpperBuffA(): skip double byte characters</span>
00466 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a125">IS_DBCS_ENABLED</a>() &amp;&amp; IsDBCSLeadByte(psz[cb])) {
00467             cb++;
00468         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="../../d5/d7/strings_8c.html#a15">IsCharLowerA</a>(psz[cb]) &amp;&amp;
00469                    <span class="comment">/*</span>
00470 <span class="comment">                    * Sometime, LATIN_xxxx code is DBCS LeadingByte depending on ACP.</span>
00471 <span class="comment">                    * In that case, we never come here...</span>
00472 <span class="comment">                    */</span>
00473                    (psz[cb] != <a class="code" href="../../d5/d7/strings_8c.html#a2">LATIN_SMALL_LETTER_SHARP_S</a>) &amp;&amp;
00474                    (psz[cb] != <a class="code" href="../../d5/d7/strings_8c.html#a3">LATIN_SMALL_LETTER_Y_DIAERESIS</a>)) {
00475             psz[cb] += <span class="charliteral">'A'</span>-<span class="charliteral">'a'</span>;
00476         }
00477 <span class="preprocessor">#else</span>
00478 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (<a class="code" href="../../d5/d7/strings_8c.html#a15">IsCharLowerA</a>(psz[cb]) &amp;&amp;
00479             (psz[cb] != <a class="code" href="../../d5/d7/strings_8c.html#a2">LATIN_SMALL_LETTER_SHARP_S</a>) &amp;&amp;
00480             (psz[cb] != <a class="code" href="../../d5/d7/strings_8c.html#a3">LATIN_SMALL_LETTER_Y_DIAERESIS</a>)) {
00481             psz[cb] += <span class="charliteral">'A'</span>-<span class="charliteral">'a'</span>;
00482         }
00483 <span class="preprocessor">#endif // FE_SB</span>
00484 <span class="preprocessor"></span>    }
00485 
00486     <span class="keywordflow">return</span> nLength;
00487 }
00488 
00489 
00490 <span class="comment">/***************************************************************************\</span>
00491 <span class="comment">* IsCharLowerA (API)</span>
00492 <span class="comment">*</span>
00493 <span class="comment">* History:</span>
00494 <span class="comment">* 14-Jan-1991 mikeke from win 3.0</span>
00495 <span class="comment">* 22-Jun-1991 GregoryW   Modified to support code page 1252 (Windows ANSI</span>
00496 <span class="comment">*                        code page).  This is for the PDK only.  After the</span>
00497 <span class="comment">*                        PDK this routine will be rewritten to use the</span>
00498 <span class="comment">*                        NLSAPI.</span>
00499 <span class="comment">* 02-Feb-1992 GregoryW   Modified to use NLS API.</span>
00500 <span class="comment">\***************************************************************************/</span>
00501 
<a name="l00502"></a><a class="code" href="../../d5/d7/strings_8c.html#a15">00502</a> <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a11">BOOL</a> WINAPI <a class="code" href="../../d5/d7/strings_8c.html#a15">IsCharLowerA</a>(
00503     <span class="keywordtype">char</span> cChar)
00504 {
00505     WORD ctype1info = 0;
00506     WCHAR wChar = 0;
00507 
00508 <span class="preprocessor">#ifdef FE_SB // IsCharLowerA()</span>
00509 <span class="preprocessor"></span>    <span class="comment">/*</span>
00510 <span class="comment">     * if only DBCS Leadbyte was passed, just return FALSE.</span>
00511 <span class="comment">     * Same behavior as Windows 3.1J and Windows 95 FarEast version.</span>
00512 <span class="comment">     */</span>
00513     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a125">IS_DBCS_ENABLED</a>() &amp;&amp; IsDBCSLeadByte(cChar)) {
00514         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00515     }
00516 <span class="preprocessor">#endif // FE_SB</span>
00517 <span class="preprocessor"></span>
00518     <span class="comment">/*</span>
00519 <span class="comment">     * The following 2 calls cannot fail here</span>
00520 <span class="comment">     */</span>
00521     <a class="code" href="../../d9/d6/nlsxlat_8c.html#a33">RtlMultiByteToUnicodeN</a>(&amp;wChar, <span class="keyword">sizeof</span>(WCHAR), <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, &amp;cChar, <span class="keyword">sizeof</span>(<a class="code" href="../../d1/d1/bench_8c.html#a16">CHAR</a>));
00522     GetStringTypeW(CT_CTYPE1, &amp;wChar, 1, &amp;ctype1info);
00523     <span class="keywordflow">return</span> (ctype1info &amp; C1_LOWER) == C1_LOWER;
00524 }
00525 
00526 
00527 <span class="comment">/***************************************************************************\</span>
00528 <span class="comment">* IsCharUpperA (API)</span>
00529 <span class="comment">*</span>
00530 <span class="comment">* History:</span>
00531 <span class="comment">* 22-Jun-1991 GregoryW   Created to support code page 1252 (Windows ANSI</span>
00532 <span class="comment">*                        code page).  This is for the PDK only.  After the</span>
00533 <span class="comment">*                        PDK this routine will be rewritten to use the</span>
00534 <span class="comment">*                        NLSAPI.</span>
00535 <span class="comment">* 02-Feb-1992 GregoryW   Modified to use NLS API.</span>
00536 <span class="comment">\***************************************************************************/</span>
00537 
<a name="l00538"></a><a class="code" href="../../d5/d7/strings_8c.html#a16">00538</a> <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a11">BOOL</a> WINAPI <a class="code" href="../../d5/d7/strings_8c.html#a16">IsCharUpperA</a>(
00539     <span class="keywordtype">char</span> cChar)
00540 {
00541     WORD ctype1info = 0;
00542     WCHAR wChar = 0;
00543 
00544 <span class="preprocessor">#ifdef FE_SB // IsCharUpperA()</span>
00545 <span class="preprocessor"></span>    <span class="comment">/*</span>
00546 <span class="comment">     * if only DBCS Leadbyte was passed, just return FALSE.</span>
00547 <span class="comment">     * Same behavior as Windows 3.1J and Windows 95 FarEast version.</span>
00548 <span class="comment">     */</span>
00549     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a125">IS_DBCS_ENABLED</a>() &amp;&amp; IsDBCSLeadByte(cChar)) {
00550         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00551     }
00552 <span class="preprocessor">#endif // FE_SB</span>
00553 <span class="preprocessor"></span>
00554     <span class="comment">/*</span>
00555 <span class="comment">     * The following 2 calls cannot fail here</span>
00556 <span class="comment">     */</span>
00557     <a class="code" href="../../d9/d6/nlsxlat_8c.html#a33">RtlMultiByteToUnicodeN</a>(&amp;wChar, <span class="keyword">sizeof</span>(WCHAR), <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, &amp;cChar, <span class="keyword">sizeof</span>(<a class="code" href="../../d1/d1/bench_8c.html#a16">CHAR</a>));
00558     GetStringTypeW(CT_CTYPE1, &amp;wChar, 1, &amp;ctype1info);
00559     <span class="keywordflow">return</span> (ctype1info &amp; C1_UPPER) == C1_UPPER;
00560 }
00561 
00562 
00563 <span class="comment">/***************************************************************************\</span>
00564 <span class="comment">* IsCharAlphaNumericA (API)</span>
00565 <span class="comment">*</span>
00566 <span class="comment">* Returns TRUE if character is alphabetical or numerical, otherwise FALSE</span>
00567 <span class="comment">*</span>
00568 <span class="comment">* History:</span>
00569 <span class="comment">* 12-03-90 IanJa        Created non-NLS stub version.</span>
00570 <span class="comment">* 06-22-91 GregoryW     Modified to support code page 1252 (Windows ANSI</span>
00571 <span class="comment">*                       code page).  This is for the PDK only.  After the</span>
00572 <span class="comment">*                       PDK this routine will be rewritten to use the</span>
00573 <span class="comment">*                       NLSAPI.</span>
00574 <span class="comment">* 02-20-92 GregoryW     Modified to use the NLS API.</span>
00575 <span class="comment">\***************************************************************************/</span>
00576 
<a name="l00577"></a><a class="code" href="../../d5/d7/strings_8c.html#a17">00577</a> <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a11">BOOL</a> WINAPI <a class="code" href="../../d5/d7/strings_8c.html#a17">IsCharAlphaNumericA</a>(
00578     <span class="keywordtype">char</span> cChar)
00579 {
00580     WORD ctype1info = 0;
00581     WCHAR wChar = 0;
00582 
00583     <span class="comment">/*</span>
00584 <span class="comment">     * The following 2 calls cannot fail here</span>
00585 <span class="comment">     */</span>
00586     <a class="code" href="../../d9/d6/nlsxlat_8c.html#a33">RtlMultiByteToUnicodeN</a>(&amp;wChar, <span class="keyword">sizeof</span>(WCHAR), <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, &amp;cChar, <span class="keyword">sizeof</span>(<a class="code" href="../../d1/d1/bench_8c.html#a16">CHAR</a>));
00587     GetStringTypeW(CT_CTYPE1, &amp;wChar, 1, &amp;ctype1info);
00588 <span class="preprocessor">#ifdef FE_SB // IsCharAlphaNumericA()</span>
00589 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (ctype1info &amp; C1_ALPHA) {
00590         WORD ctype3info = 0;
00591         <span class="keywordflow">if</span> (!<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a125">IS_DBCS_ENABLED</a>()) {
00592             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00593         }
00594         <span class="comment">/*</span>
00595 <span class="comment">         * We don't want to return TRUE for halfwidth katakana.</span>
00596 <span class="comment">         * Katakana is linguistic character (C1_ALPHA), but it is not</span>
00597 <span class="comment">         * alphabet character.</span>
00598 <span class="comment">         */</span>
00599         GetStringTypeW(CT_CTYPE3, &amp;wChar, 1, &amp;ctype3info);
00600         <span class="keywordflow">return</span> ((ctype3info &amp; (C3_KATAKANA|C3_HIRAGANA)) ? <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> : <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
00601     }
00602     <span class="comment">/* Otherwise, it might be digits ? */</span>
00603     <span class="keywordflow">return</span> !!(ctype1info &amp; C1_DIGIT);
00604 <span class="preprocessor">#else</span>
00605 <span class="preprocessor"></span>    <span class="keywordflow">return</span> (ctype1info &amp; C1_ALPHA) || (ctype1info &amp; C1_DIGIT);
00606 <span class="preprocessor">#endif // FE_SB</span>
00607 <span class="preprocessor"></span>}
00608 
00609 
00610 <span class="comment">/***************************************************************************\</span>
00611 <span class="comment">* IsCharAlphaA (API)</span>
00612 <span class="comment">*</span>
00613 <span class="comment">* Returns TRUE if character is alphabetical, otherwise FALSE</span>
00614 <span class="comment">*</span>
00615 <span class="comment">* History:</span>
00616 <span class="comment">* 06-22-91 GregoryW     Created to support code page 1252 (Windows ANSI</span>
00617 <span class="comment">*                       code page).  This is for the PDK only.  After the</span>
00618 <span class="comment">*                       PDK this routine will be rewritten to use the</span>
00619 <span class="comment">*                       NLSAPI.</span>
00620 <span class="comment">* 02-20-92 GregoryW     Modified to use the NLS API.</span>
00621 <span class="comment">\***************************************************************************/</span>
00622 
<a name="l00623"></a><a class="code" href="../../d5/d7/strings_8c.html#a18">00623</a> <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a11">BOOL</a> WINAPI <a class="code" href="../../d5/d7/strings_8c.html#a18">IsCharAlphaA</a>(
00624     <span class="keywordtype">char</span> cChar)
00625 {
00626     WORD ctype1info = 0;
00627     WCHAR wChar = 0;
00628 
00629     <span class="comment">/*</span>
00630 <span class="comment">     * The following 2 calls cannot fail here</span>
00631 <span class="comment">     */</span>
00632     <a class="code" href="../../d9/d6/nlsxlat_8c.html#a33">RtlMultiByteToUnicodeN</a>(&amp;wChar, <span class="keyword">sizeof</span>(WCHAR), <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, &amp;cChar, <span class="keyword">sizeof</span>(<a class="code" href="../../d1/d1/bench_8c.html#a16">CHAR</a>));
00633     GetStringTypeW(CT_CTYPE1, &amp;wChar, 1, &amp;ctype1info);
00634 <span class="preprocessor">#ifdef FE_SB // IsCharAlphaA()</span>
00635 <span class="preprocessor"></span>    <span class="keywordflow">if</span> ((ctype1info &amp; C1_ALPHA) == C1_ALPHA) {
00636         WORD ctype3info = 0;
00637         <span class="keywordflow">if</span> (!<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a125">IS_DBCS_ENABLED</a>()) {
00638             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00639         }
00640         <span class="comment">/*</span>
00641 <span class="comment">         * We don't want to return TRUE for halfwidth katakana.</span>
00642 <span class="comment">         * Katakana is linguistic character (C1_ALPHA), but it is not</span>
00643 <span class="comment">         * alphabet character.</span>
00644 <span class="comment">         */</span>
00645         GetStringTypeW(CT_CTYPE3, &amp;wChar, 1, &amp;ctype3info);
00646         <span class="keywordflow">return</span> ((ctype3info &amp; (C3_KATAKANA|C3_HIRAGANA)) ? <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> : <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
00647     }
00648     <span class="keywordflow">return</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
00649 <span class="preprocessor">#else</span>
00650 <span class="preprocessor"></span>    <span class="keywordflow">return</span> (ctype1info &amp; C1_ALPHA) == C1_ALPHA;
00651 <span class="preprocessor">#endif // FE_SB</span>
00652 <span class="preprocessor"></span>}
00653 
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:41:53 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
