<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: winable.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>winable.c</h1><a href="../../d5/d7/kernel_2winable_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/**************************** Module Header ********************************\</span>
00002 <span class="comment">* Module Name: winable.c</span>
00003 <span class="comment">*</span>
00004 <span class="comment">* This has the stuff for WinEvents:</span>
00005 <span class="comment">*     NotifyWinEvent</span>
00006 <span class="comment">*     _SetWinEventHook</span>
00007 <span class="comment">*     UnhookWinEventHook</span>
00008 <span class="comment">*</span>
00009 <span class="comment">* All other additions to USER for Active Accessibility are in WINABLE2.C</span>
00010 <span class="comment">* and its helper ASM file, ABLEASM.ASM.</span>
00011 <span class="comment">*</span>
00012 <span class="comment">* Copyright (c) 1985 - 1999, Microsoft Corporation</span>
00013 <span class="comment">*</span>
00014 <span class="comment">* History:</span>
00015 <span class="comment">* Based on snapshot taken from:</span>
00016 <span class="comment">*  \\trango\slmro\proj\win\src\CORE\access\user_40\user32 on 8/29/96</span>
00017 <span class="comment">* 08-30-96 IanJa  Ported from Windows '95</span>
00018 <span class="comment">\***************************************************************************/</span>
00019 
00020 <span class="preprocessor">#include "<a class="code" href="../../d0/d4/w32_2ntuser_2kernel_2precomp_8h.html">precomp.h</a>"</span>
00021 <span class="preprocessor">#pragma hdrstop</span>
00022 <span class="preprocessor"></span>
00023 <span class="preprocessor">#if DBG</span>
00024 <span class="preprocessor"></span><span class="keywordtype">int</span> gnNotifies = 0;
00025 <span class="preprocessor">#define DBGVERIFYEVENTHOOK(peh)                                              \</span>
00026 <span class="preprocessor">        HMValidateCatHandleNoSecure(PtoH(peh), TYPE_WINEVENTHOOK);           \</span>
00027 <span class="preprocessor">        UserAssertMsg1((IsValidTag(peh, TAG_WINEVENT)), "event hook %#p: bad tag", peh); \</span>
00028 <span class="preprocessor">        UserAssertMsg1((peh-&gt;eventMin &lt;= peh-&gt;eventMax), "event hook %#p: bad range", peh)</span>
00029 <span class="preprocessor"></span><span class="preprocessor">#define DBGVERIFYNOTIFY(pNotify)                                  \</span>
00030 <span class="preprocessor">        UserAssert(pNotify-&gt;spEventHook != NULL);                 \</span>
00031 <span class="preprocessor">        UserAssert(pNotify-&gt;spEventHook-&gt;fSync || (pNotify-&gt;dwWEFlags &amp; WEF_ASYNC))</span>
00032 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00033"></a><a class="code" href="../../d5/d7/kernel_2winable_8c.html#a0">00033</a> <span class="preprocessor"></span><span class="preprocessor">#define DBGVERIFYEVENTHOOK(peh)</span>
<a name="l00034"></a><a class="code" href="../../d5/d7/kernel_2winable_8c.html#a1">00034</a> <span class="preprocessor"></span><span class="preprocessor">#define DBGVERIFYNOTIFY(pNotify)</span>
00035 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00036 <span class="preprocessor"></span>
00037 <span class="comment">/*</span>
00038 <span class="comment"> * Pending Event Notifications (sync and async)</span>
00039 <span class="comment"> */</span>
00040 
<a name="l00041"></a><a class="code" href="../../d5/d7/kernel_2winable_8c.html#a2">00041</a> <span class="keyword">static</span> <a class="code" href="../../d9/d2/structtagNOTIFY.html">NOTIFY</a>   <a class="code" href="../../d5/d7/kernel_2winable_8c.html#a2">notifyCache</a>;
<a name="l00042"></a><a class="code" href="../../d5/d7/kernel_2winable_8c.html#a3">00042</a> <span class="keyword">static</span> <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a11">BOOL</a>     <a class="code" href="../../d5/d7/kernel_2winable_8c.html#a3">fNotifyCacheInUse</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00043 
00044 
00045 <span class="comment">/*</span>
00046 <span class="comment"> * Local to this module</span>
00047 <span class="comment"> */</span>
00048 WINEVENTPROC <a class="code" href="../../d5/d7/kernel_2winable_8c.html#a4">xxxGetEventProc</a>(<a class="code" href="../../d8/d4/structtagEVENTHOOK.html">PEVENTHOOK</a> pEventOrg);
00049 <a class="code" href="../../d9/d2/structtagNOTIFY.html">PNOTIFY</a> <a class="code" href="../../d5/d7/kernel_2winable_8c.html#a5">CreateNotify</a>(<a class="code" href="../../d8/d4/structtagEVENTHOOK.html">PEVENTHOOK</a> peh, DWORD event, <a class="code" href="../../d6/d9/structtagWND.html">PWND</a> pwnd, LONG idObject,
00050         LONG idChild, <a class="code" href="../../d2/d8/structtagTHREADINFO.html">PTHREADINFO</a> ptiEvent, DWORD dwTime);
00051 
00052 
00053 <span class="comment">/*****************************************************************************\</span>
00054 <span class="comment">*</span>
00055 <span class="comment">*  xxxProcessNotifyWinEvent()</span>
00056 <span class="comment">*</span>
00057 <span class="comment">*  Posts or Sends a WinEvent notification.</span>
00058 <span class="comment">*  Post: uses PostEventMesage - does not leave the critical section.</span>
00059 <span class="comment">*  Send: makes a callback to user-mode - does leave the critical section.</span>
00060 <span class="comment">*</span>
00061 <span class="comment">*  If this is a system thread (RIT, Desktop or Console) then synchronously</span>
00062 <span class="comment">*  hooked (WINEVENT_INCONTEXT) events are forced to be asynchronous.</span>
00063 <span class="comment">*</span>
00064 <span class="comment">*  We return the next win event hook in the list.</span>
00065 <span class="comment">*</span>
00066 <span class="comment">\*****************************************************************************/</span>
00067 <a class="code" href="../../d8/d4/structtagEVENTHOOK.html">PEVENTHOOK</a>
<a name="l00068"></a><a class="code" href="../../d5/d7/kernel_2winable_8c.html#a6">00068</a> <a class="code" href="../../d5/d7/kernel_2winable_8c.html#a6">xxxProcessNotifyWinEvent</a>(<a class="code" href="../../d9/d2/structtagNOTIFY.html">PNOTIFY</a> pNotify)
00069 {
00070     WINEVENTPROC   pfn;
00071     <a class="code" href="../../d8/d4/structtagEVENTHOOK.html">PEVENTHOOK</a>     pEventHook;
00072     <a class="code" href="../../d5/d1/struct__TL.html">TL</a>             tlpEventHook;
00073     <a class="code" href="../../d2/d8/structtagTHREADINFO.html">PTHREADINFO</a>    ptiCurrent = <a class="code" href="../../d4/d1/userk_8h.html#a9">PtiCurrent</a>();
00074 
00075     pEventHook = pNotify-&gt;<a class="code" href="../../d9/d2/structtagNOTIFY.html#o1">spEventHook</a>;
00076     <a class="code" href="../../d5/d7/kernel_2winable_8c.html#a0">DBGVERIFYEVENTHOOK</a>(pEventHook);
00077     UserAssert(pEventHook-&gt;<a class="code" href="../../d8/d4/structtagEVENTHOOK.html#o0">head</a>.cLockObj);
00078 
00079     <span class="keywordflow">if</span> (((pNotify-&gt;<a class="code" href="../../d9/d2/structtagNOTIFY.html#o8">dwWEFlags</a> &amp; (<a class="code" href="../../d4/d1/userk_8h.html#a612">WEF_ASYNC</a> | <a class="code" href="../../d4/d1/userk_8h.html#a613">WEF_POSTED</a>)) == <a class="code" href="../../d4/d1/userk_8h.html#a612">WEF_ASYNC</a>)
00080         ||
00081         (ptiCurrent-&gt;<a class="code" href="../../d2/d8/structtagTHREADINFO.html#o9">TIF_flags</a> &amp; (<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a797">TIF_SYSTEMTHREAD</a> | <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a798">TIF_CSRSSTHREAD</a> | <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a795">TIF_INCLEANUP</a>))
00082 
00083         ||
00084         (!<a class="code" href="../../d8/d6/sertl_8c.html#a50">RtlEqualLuid</a>(&amp;<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a455">GETPTI</a>(pEventHook)-&gt;ppi-&gt;luidSession, &amp;ptiCurrent-&gt;<a class="code" href="../../d2/d8/structtagTHREADINFO.html#o2">ppi</a>-&gt;<a class="code" href="../../d7/d3/structtagPROCESSINFO.html#o27">luidSession</a>) &amp;&amp;
00085          !(ptiCurrent-&gt;<a class="code" href="../../d2/d8/structtagTHREADINFO.html#o9">TIF_flags</a> &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a815">TIF_ALLOWOTHERACCOUNTHOOK</a>))
00086 
00087         ||
00088         (<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a455">GETPTI</a>(pEventHook)-&gt;ppi != ptiCurrent-&gt;<a class="code" href="../../d2/d8/structtagTHREADINFO.html#o2">ppi</a> &amp;&amp;
00089          <a class="code" href="../../d6/d9/restrfil_8c.html#a29">IsRestricted</a>(<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a455">GETPTI</a>(pEventHook)-&gt;pEThread))
00090 
00091 <span class="preprocessor">#if defined(_WIN64)</span>
00092 <span class="preprocessor"></span>        ||
00093         ((<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a455">GETPTI</a>(pEventHook)-&gt;TIF_flags &amp; <a class="code" href="../../d1/d0/inc_2user_8h.html#a796">TIF_WOW64</a>) != (ptiCurrent-&gt;<a class="code" href="../../d2/d8/structtagTHREADINFO.html#o9">TIF_flags</a> &amp; <a class="code" href="../../d1/d0/inc_2user_8h.html#a796">TIF_WOW64</a>))
00094 <span class="preprocessor">#endif</span>
00095 <span class="preprocessor"></span>        ) {
00096         <span class="comment">/*</span>
00097 <span class="comment">         * POST</span>
00098 <span class="comment">         *</span>
00099 <span class="comment">         * WinEvent Hook set without WINEVENT_INCONTEXT flag are posted;</span>
00100 <span class="comment">         * Events from system threads are posted because there is no user-mode</span>
00101 <span class="comment">         *    part to callback to;</span>
00102 <span class="comment">         * Console is not permitted to load DLLs, so we must post back to the</span>
00103 <span class="comment">         *    hooking application;</span>
00104 <span class="comment">         * DLLs can not be loaded cross bit type(32bit to 64bit) on 64bit NT</span>
00105 <span class="comment">         *    so we must post(It may be usefull to let the app be aware and</span>
00106 <span class="comment">         *    even supply both a 32bit and a 64bit DLL that are aware of each other);</span>
00107 <span class="comment">         * Threads in cleanup can't get called back, so turn their</span>
00108 <span class="comment">         *    notifications into async ones. (Better late than never).</span>
00109 <span class="comment">         *</span>
00110 <span class="comment">         * If forcing these events ASYNC is unacceptable, we might consider</span>
00111 <span class="comment">         * doing system/console SYNC events like low-level hooks (sync with</span>
00112 <span class="comment">         * timeout: but may have to post it if the timeout expires) - IanJa</span>
00113 <span class="comment">         */</span>
00114         <a class="code" href="../../d7/d4/structtagQ.html">PQ</a>  pqReceiver = <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a455">GETPTI</a>(pEventHook)-&gt;pq;
00115         <a class="code" href="../../d8/d4/structtagEVENTHOOK.html">PEVENTHOOK</a> pEventHookNext = pEventHook-&gt;<a class="code" href="../../d8/d4/structtagEVENTHOOK.html#o1">pehNext</a>;
00116 
00117         <a class="code" href="../../d4/d1/userk_8h.html#a159">BEGINATOMICCHECK</a>();
00118 
00119         <a class="code" href="../../d5/d7/kernel_2winable_8c.html#a1">DBGVERIFYNOTIFY</a>(pNotify);
00120         pNotify-&gt;<a class="code" href="../../d9/d2/structtagNOTIFY.html#o8">dwWEFlags</a> |= <a class="code" href="../../d4/d1/userk_8h.html#a613">WEF_POSTED</a> | <a class="code" href="../../d4/d1/userk_8h.html#a612">WEF_ASYNC</a>;
00121         <span class="keywordflow">if</span> (!pqReceiver || (<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a455">GETPTI</a>(pEventHook) == <a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a175">gptiRit</a>) ||
00122                 pEventHook-&gt;<a class="code" href="../../d8/d4/structtagEVENTHOOK.html#o4">fDestroyed</a> ||
00123                 !<a class="code" href="../../d4/d1/userk_8h.html#a1217">PostEventMessage</a>(<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a455">GETPTI</a>(pEventHook), pqReceiver,
00124                                   <a class="code" href="../../d4/d1/userk_8h.html#a347">QEVENT_NOTIFYWINEVENT</a>,
00125                                   <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, 0, 0, (LPARAM)pNotify)) {
00126             <span class="comment">/*</span>
00127 <span class="comment">             * If the receiver doesn't have a queue or the</span>
00128 <span class="comment">             * post failed (low memory), cleanup what we just</span>
00129 <span class="comment">             * created.</span>
00130 <span class="comment">             * Note: destroying the notification may destroy pEventHook too.</span>
00131 <span class="comment">             */</span>
00132             RIPMSG2(RIP_WARNING, <span class="stringliteral">"failed to post NOTIFY at %#p, time %lx\n"</span>,
00133                       pNotify, pNotify-&gt;dwEventTime);
00134             <a class="code" href="../../d5/d7/kernel_2winable_8c.html#a10">DestroyNotify</a>(pNotify);
00135         }
00136 
00137         <a class="code" href="../../d4/d1/userk_8h.html#a163">ENDATOMICCHECK</a>();
00138 
00139         <span class="keywordflow">if</span> (pEventHookNext) {
00140             <a class="code" href="../../d5/d7/kernel_2winable_8c.html#a0">DBGVERIFYEVENTHOOK</a>(pEventHookNext);
00141         }
00142         <span class="keywordflow">return</span> pEventHookNext;
00143     }
00144 
00145     <span class="comment">/*</span>
00146 <span class="comment">     * Don't call back if the hook has been destroyed (unhooked).</span>
00147 <span class="comment">     */</span>
00148     <span class="keywordflow">if</span> (pEventHook-&gt;<a class="code" href="../../d8/d4/structtagEVENTHOOK.html#o4">fDestroyed</a>) {
00149         <span class="comment">/*</span>
00150 <span class="comment">         * Save the next hook since DestroyNotify may cause pEventHook to</span>
00151 <span class="comment">         * be freed by unlocking it.</span>
00152 <span class="comment">         */</span>
00153         pEventHook = pEventHook-&gt;<a class="code" href="../../d8/d4/structtagEVENTHOOK.html#o1">pehNext</a>;
00154         <a class="code" href="../../d5/d7/kernel_2winable_8c.html#a10">DestroyNotify</a>(pNotify);
00155         <span class="keywordflow">return</span> pEventHook;
00156     }
00157 
00158     <span class="comment">/*</span>
00159 <span class="comment">     * CALLBACK</span>
00160 <span class="comment">     *</span>
00161 <span class="comment">     * This leaves the critical section.</span>
00162 <span class="comment">     * We return the next Event Hook in the list so that the caller doesn't</span>
00163 <span class="comment">     * have to lock pEventHook.</span>
00164 <span class="comment">     */</span>
00165     UserAssert((pNotify-&gt;<a class="code" href="../../d9/d2/structtagNOTIFY.html#o8">dwWEFlags</a> &amp; <a class="code" href="../../d4/d1/userk_8h.html#a611">WEF_DEFERNOTIFY</a>) == 0);
00166 
00167     <a class="code" href="../../d6/d0/usercli_8h.html#a37">ThreadLockAlways</a>(pEventHook, &amp;tlpEventHook);
00168 
00169     UserAssertMsg1(pNotify-&gt;<a class="code" href="../../d9/d2/structtagNOTIFY.html#o9">ptiReceiver</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00170          <span class="stringliteral">"pNotify %#p is already in callback!  Reentrant?"</span>, pNotify);
00171     pNotify-&gt;<a class="code" href="../../d9/d2/structtagNOTIFY.html#o9">ptiReceiver</a> = ptiCurrent;
00172 
00173     <span class="keywordflow">if</span> (!pEventHook-&gt;<a class="code" href="../../d8/d4/structtagEVENTHOOK.html#o7">fSync</a>) {
00174         UserAssert(pEventHook-&gt;<a class="code" href="../../d8/d4/structtagEVENTHOOK.html#o12">ihmod</a> == -1);
00175         pfn = (WINEVENTPROC)pEventHook-&gt;<a class="code" href="../../d8/d4/structtagEVENTHOOK.html#o11">offPfn</a>;
00176     } <span class="keywordflow">else</span> {
00177         pfn = <a class="code" href="../../d5/d7/kernel_2winable_8c.html#a4">xxxGetEventProc</a>(pEventHook);
00178     }
00179     <span class="keywordflow">if</span> (pfn) {
00180         <a class="code" href="../../d4/d1/userk_8h.html#a1950">xxxClientCallWinEventProc</a>(pfn, pEventHook, pNotify);
00181         <a class="code" href="../../d5/d7/kernel_2winable_8c.html#a1">DBGVERIFYNOTIFY</a>(pNotify);
00182         <a class="code" href="../../d5/d7/kernel_2winable_8c.html#a0">DBGVERIFYEVENTHOOK</a>(pEventHook);
00183         UserAssert(pEventHook-&gt;<a class="code" href="../../d8/d4/structtagEVENTHOOK.html#o0">head</a>.cLockObj);
00184     }
00185 
00186     pNotify-&gt;<a class="code" href="../../d9/d2/structtagNOTIFY.html#o9">ptiReceiver</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00187 
00188     <span class="comment">/*</span>
00189 <span class="comment">     * Save the next item in the list, ThreadUnlock() may destroy pEventHook.</span>
00190 <span class="comment">     * DestroyNotify() may also kill the event if it is a zombie (destroyed</span>
00191 <span class="comment">     * but being used, waiting for use count to go to 0 before being freed).</span>
00192 <span class="comment">     */</span>
00193     pEventHook = pEventHook-&gt;<a class="code" href="../../d8/d4/structtagEVENTHOOK.html#o1">pehNext</a>;
00194     <a class="code" href="../../d6/d0/usercli_8h.html#a40">ThreadUnlock</a>(&amp;tlpEventHook);
00195 
00196     <span class="comment">/*</span>
00197 <span class="comment">     * We are done with the notification.  Kill it.</span>
00198 <span class="comment">     *</span>
00199 <span class="comment">     * NOTE that DestroyNotify does not yield, which is why we can hang on</span>
00200 <span class="comment">     * to the pehNext field above around this call.</span>
00201 <span class="comment">     *</span>
00202 <span class="comment">     * NOTE ALSO that DestroyNotify will kill the event it references if the</span>
00203 <span class="comment">     * ref count goes down to zero and it was zombied earlier.</span>
00204 <span class="comment">     */</span>
00205     <a class="code" href="../../d5/d7/kernel_2winable_8c.html#a10">DestroyNotify</a>(pNotify);
00206 
00207     <span class="keywordflow">return</span> pEventHook;
00208 }
00209 
00210 
00211 <span class="comment">/****************************************************************************\</span>
00212 <span class="comment">* xxxFlushDeferredWindowEvents()</span>
00213 <span class="comment">*</span>
00214 <span class="comment">* Process notifications that were queued up during DeferWinEventNotify()</span>
00215 <span class="comment">\****************************************************************************/</span>
00216 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00217"></a><a class="code" href="../../d5/d7/kernel_2winable_8c.html#a7">00217</a> <a class="code" href="../../d4/d1/userk_8h.html#a1949">xxxFlushDeferredWindowEvents</a>()
00218 {
00219     <a class="code" href="../../d9/d2/structtagNOTIFY.html">PNOTIFY</a> pNotify;
00220     <a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a> idCurrentThread = W32GetCurrentTID();
00221 
00222     <span class="keywordflow">if</span> (idCurrentThread == 0) {
00223         RIPMSG0(RIP_ERROR, <span class="stringliteral">"processing deferred notifications before we have a pti!"</span>);
00224         <span class="comment">// return;</span>
00225     }
00226 
00227     UserAssert(<a class="code" href="../../d4/d1/userk_8h.html#a616">IsWinEventNotifyDeferredOK</a>());
00228 
00229     pNotify = <a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a256">gpPendingNotifies</a>;
00230     <span class="keywordflow">while</span> (pNotify) {
00231         <span class="keywordflow">if</span> (((pNotify-&gt;<a class="code" href="../../d9/d2/structtagNOTIFY.html#o8">dwWEFlags</a> &amp; <a class="code" href="../../d4/d1/userk_8h.html#a611">WEF_DEFERNOTIFY</a>) == 0) ||
00232                 (pNotify-&gt;<a class="code" href="../../d9/d2/structtagNOTIFY.html#o6">idSenderThread</a> != idCurrentThread)) {
00233             <span class="comment">// UserAssert(pNotify-&gt;idSenderThread == idCurrentThread); // just testing!</span>
00234             pNotify = pNotify-&gt;<a class="code" href="../../d9/d2/structtagNOTIFY.html#o0">pNotifyNext</a>;
00235         } <span class="keywordflow">else</span> {
00236             <span class="comment">/*</span>
00237 <span class="comment">             * Clear WEF_DEFERNOTIFY so that if we recurse in the callback</span>
00238 <span class="comment">             * we won't try to send this notification again.</span>
00239 <span class="comment">             */</span>
00240             pNotify-&gt;<a class="code" href="../../d9/d2/structtagNOTIFY.html#o8">dwWEFlags</a> &amp;= ~<a class="code" href="../../d4/d1/userk_8h.html#a611">WEF_DEFERNOTIFY</a>;
00241 <span class="preprocessor">#if DBG</span>
00242 <span class="preprocessor"></span>            gnDeferredWinEvents--;
00243 <span class="preprocessor">#endif</span>
00244 <span class="preprocessor"></span>            <span class="comment">/*</span>
00245 <span class="comment">             * We shouldn't have deferred ASYNC notifications: we should have</span>
00246 <span class="comment">             * posted them immediately.</span>
00247 <span class="comment">             */</span>
00248             UserAssert((pNotify-&gt;<a class="code" href="../../d9/d2/structtagNOTIFY.html#o8">dwWEFlags</a> &amp; <a class="code" href="../../d4/d1/userk_8h.html#a612">WEF_ASYNC</a>) == 0);
00249             <a class="code" href="../../d5/d7/kernel_2winable_8c.html#a6">xxxProcessNotifyWinEvent</a>(pNotify);
00250             <span class="comment">/*</span>
00251 <span class="comment">             * Start again at the head of the list, in case it munged during</span>
00252 <span class="comment">             * the callback.</span>
00253 <span class="comment">             */</span>
00254             pNotify = <a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a256">gpPendingNotifies</a>;
00255         }
00256     }
00257 }
00258 
00259 
00260 <span class="comment">/*****************************************************************************\</span>
00261 <span class="comment">*</span>
00262 <span class="comment">* xxxWindowEvent</span>
00263 <span class="comment">*</span>
00264 <span class="comment">* Send, Post or Defer a Win Event notification, depending on what Win Event</span>
00265 <span class="comment">* hooks are installed and what the context of the caller is.</span>
00266 <span class="comment">*</span>
00267 <span class="comment">* The caller should test FWINABLE() and only call xxxWindowEvent if it is TRUE,</span>
00268 <span class="comment">* that way only costs a few clocks if no Win Event hooks are set.</span>
00269 <span class="comment">*</span>
00270 <span class="comment">* Caller shouldn't lock pwnd, because xxxWindowEvent() will do it.</span>
00271 <span class="comment">*</span>
00272 <span class="comment">\*****************************************************************************/</span>
00273 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00274"></a><a class="code" href="../../d5/d7/kernel_2winable_8c.html#a8">00274</a> <a class="code" href="../../d5/d7/kernel_2winable_8c.html#a8">xxxWindowEvent</a>(
00275     DWORD   event,
00276     <a class="code" href="../../d6/d9/structtagWND.html">PWND</a>    pwnd,
00277     LONG    idObject,
00278     LONG    idChild,
00279     DWORD   dwFlags)
00280 {
00281     <a class="code" href="../../d8/d4/structtagEVENTHOOK.html">PEVENTHOOK</a> peh;
00282     <a class="code" href="../../d8/d4/structtagEVENTHOOK.html">PEVENTHOOK</a> pehNext;
00283     <a class="code" href="../../d2/d8/structtagTHREADINFO.html">PTHREADINFO</a> ptiCurrent, ptiEvent;
00284     <a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a>   dwTime;
00285     <a class="code" href="../../d7/d3/structtagPROCESSINFO.html">PPROCESSINFO</a> ppiEvent;
00286     <a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a> idEventThread;
00287     HANDLE hEventProcess;
00288     <a class="code" href="../../d9/d2/structtagNOTIFY.html">PNOTIFY</a> pNotify;
00289     <a class="code" href="../../d5/d1/struct__TL.html">TL</a> tlpwnd;
00290     <a class="code" href="../../d5/d1/struct__TL.html">TL</a> tlpti;
00291 
00292     <span class="comment">/*</span>
00293 <span class="comment">     * Do not bother with CheckLock(pwnd) - we ThreadLock it below.</span>
00294 <span class="comment">     */</span>
00295     UserAssert(<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a405">FWINABLE</a>());
00296 
00297     <span class="comment">/*</span>
00298 <span class="comment">     * This thread is in startup, and has not yet had it's pti set up</span>
00299 <span class="comment">     * This is pretty rare, but sometimes encountered in stress.</span>
00300 <span class="comment">     * Test gptiCurrent to avoid the UserAssert(gptiCurrent) in PtiCurrent()</span>
00301 <span class="comment">     */</span>
00302     <span class="keywordflow">if</span> (<a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a246">gptiCurrent</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00303         RIPMSG3(RIP_WARNING, <span class="stringliteral">"Ignore WinEvent %lx %#p %lx... no PtiCurrent yet"</span>,
00304                 event, pwnd, idObject);
00305         <span class="keywordflow">return</span>;
00306     }
00307     ptiCurrent = <a class="code" href="../../d4/d1/userk_8h.html#a9">PtiCurrent</a>();
00308 
00309     <span class="comment">/*</span>
00310 <span class="comment">     * Don't bother with destroyed windows</span>
00311 <span class="comment">     */</span>
00312     <span class="keywordflow">if</span> (pwnd &amp;&amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a731">TestWF</a>(pwnd, <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a583">WFDESTROYED</a>)) {
00313         RIPMSG3(RIP_WARNING,
00314                 <span class="stringliteral">"Ignore WinEvent %lx %#p %lx... pwnd already destroyed"</span>,
00315                 event, pwnd, idObject);
00316         <span class="keywordflow">return</span>;
00317     }
00318 
00319     <span class="comment">/*</span>
00320 <span class="comment">     * Under some special circumstances we have to defer</span>
00321 <span class="comment">     */</span>
00322     <span class="keywordflow">if</span> (ptiCurrent-&gt;<a class="code" href="../../d2/d8/structtagTHREADINFO.html#o9">TIF_flags</a> &amp; (<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a820">TIF_DISABLEHOOKS</a> | <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a795">TIF_INCLEANUP</a>)) {
00323         <a class="code" href="../../d3/d8/propapi_8h.html#a34">dwFlags</a> |= <a class="code" href="../../d4/d1/userk_8h.html#a611">WEF_DEFERNOTIFY</a>;
00324     }
00325 
00326     <span class="comment">/*</span>
00327 <span class="comment">     * Determine process and thread issuing the event notification</span>
00328 <span class="comment">     */</span>
00329     <span class="keywordflow">if</span> ((<a class="code" href="../../d3/d8/propapi_8h.html#a34">dwFlags</a> &amp; <a class="code" href="../../d4/d1/userk_8h.html#a610">WEF_USEPWNDTHREAD</a>) &amp;&amp; pwnd) {
00330         ptiEvent = <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a455">GETPTI</a>(pwnd);
00331     } <span class="keywordflow">else</span> {
00332         ptiEvent = ptiCurrent;
00333     }
00334     idEventThread = <a class="code" href="../../d4/d1/userk_8h.html#a107">TIDq</a>(ptiEvent);
00335     ppiEvent = ptiEvent-&gt;<a class="code" href="../../d2/d8/structtagTHREADINFO.html#o2">ppi</a>;
00336     hEventProcess = ptiEvent-&gt;pEThread-&gt;Cid.UniqueProcess;
00337 
00338     dwTime = <a class="code" href="../../d9/d5/gettickc_8c.html#a0">NtGetTickCount</a>();
00339 
00340     <a class="code" href="../../d6/d0/usercli_8h.html#a38">ThreadLockWithPti</a>(ptiCurrent, pwnd, &amp;tlpwnd);
00341     <a class="code" href="../../d4/d1/userk_8h.html#a134">ThreadLockPti</a>(ptiCurrent, ptiEvent, &amp;tlpti);
00342 
00343     <span class="comment">/*</span>
00344 <span class="comment">     * If we're not deferring the current notification process any pending</span>
00345 <span class="comment">     * deferred notifications before proceeding with the current notification</span>
00346 <span class="comment">     */</span>
00347     <span class="keywordflow">if</span> (!(<a class="code" href="../../d3/d8/propapi_8h.html#a34">dwFlags</a> &amp; <a class="code" href="../../d4/d1/userk_8h.html#a611">WEF_DEFERNOTIFY</a>)) {
00348         <a class="code" href="../../d4/d1/userk_8h.html#a1949">xxxFlushDeferredWindowEvents</a>();
00349     }
00350 
00351     <span class="keywordflow">for</span> (peh = <a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a255">gpWinEventHooks</a>; peh; peh = pehNext) {
00352         <a class="code" href="../../d5/d7/kernel_2winable_8c.html#a0">DBGVERIFYEVENTHOOK</a>(peh);
00353         pehNext = peh-&gt;<a class="code" href="../../d8/d4/structtagEVENTHOOK.html#o1">pehNext</a>;
00354 
00355         <span class="comment">//</span>
00356         <span class="comment">// Is event in the right range?  And is it for this process/thread?</span>
00357         <span class="comment">// Note that we skip destroyed events.  They will be freed any</span>
00358         <span class="comment">// second now, it's just that yielding may have caused reentrancy.</span>
00359         <span class="comment">//</span>
00360         <span class="comment">// If the caller said to ignore events on his own thread, make sure</span>
00361         <span class="comment">// we skip them.</span>
00362         <span class="comment">//</span>
00363         <span class="keywordflow">if</span> (!peh-&gt;<a class="code" href="../../d8/d4/structtagEVENTHOOK.html#o4">fDestroyed</a>                &amp;&amp;
00364             (peh-&gt;<a class="code" href="../../d8/d4/structtagEVENTHOOK.html#o2">eventMin</a> &lt;= event)        &amp;&amp;
00365             (event &lt;= peh-&gt;<a class="code" href="../../d8/d4/structtagEVENTHOOK.html#o3">eventMax</a>)        &amp;&amp;
00366             (!peh-&gt;<a class="code" href="../../d8/d4/structtagEVENTHOOK.html#o9">hEventProcess</a> || (peh-&gt;<a class="code" href="../../d8/d4/structtagEVENTHOOK.html#o9">hEventProcess</a> == hEventProcess)) &amp;&amp;
00367             (!peh-&gt;<a class="code" href="../../d8/d4/structtagEVENTHOOK.html#o6">fIgnoreOwnProcess</a> || (ppiEvent != <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a455">GETPTI</a>(peh)-&gt;ppi)) &amp;&amp;
00368             (!peh-&gt;<a class="code" href="../../d8/d4/structtagEVENTHOOK.html#o10">idEventThread</a> || (peh-&gt;<a class="code" href="../../d8/d4/structtagEVENTHOOK.html#o10">idEventThread</a> == idEventThread))  &amp;&amp;
00369             (!peh-&gt;<a class="code" href="../../d8/d4/structtagEVENTHOOK.html#o5">fIgnoreOwnThread</a> || (ptiEvent != <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a455">GETPTI</a>(peh))) &amp;&amp;
00370             <span class="comment">// temp fix from SP3 - best to architect events on a per-desktop</span>
00371             <span class="comment">// basis, with a separate pWinEventHook list per desktop. (IanJa)</span>
00372             (peh-&gt;<a class="code" href="../../d8/d4/structtagEVENTHOOK.html#o0">head</a>.<a class="code" href="../../d1/d1/struct__THROBJHEAD.html#o1">pti</a>-&gt;<a class="code" href="../../d2/d8/structtagTHREADINFO.html#o6">rpdesk</a> == ptiCurrent-&gt;<a class="code" href="../../d2/d8/structtagTHREADINFO.html#o6">rpdesk</a>))
00373         {
00374             <span class="comment">/*</span>
00375 <span class="comment">             * Don't create new notifications for zombie event hooks.</span>
00376 <span class="comment">             * When an event is destroyed, it stays as a zombie until the in-use</span>
00377 <span class="comment">             * count goes to zero (all it's async and deferred notifies gone)</span>
00378 <span class="comment">             */</span>
00379             <span class="keywordflow">if</span> (<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a438">HMIsMarkDestroy</a>(peh)) {
00380                 <span class="keywordflow">break</span>;
00381             }
00382 
00383             UserAssert(peh-&gt;<a class="code" href="../../d8/d4/structtagEVENTHOOK.html#o4">fDestroyed</a> == 0);
00384 
00385             <span class="keywordflow">if</span> ((pNotify = <a class="code" href="../../d5/d7/kernel_2winable_8c.html#a5">CreateNotify</a>(peh, event, pwnd, idObject,
00386                     idChild, ptiEvent, dwTime)) == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00387                 <span class="keywordflow">break</span>;
00388             }
00389             pNotify-&gt;<a class="code" href="../../d9/d2/structtagNOTIFY.html#o8">dwWEFlags</a> |= <a class="code" href="../../d3/d8/propapi_8h.html#a34">dwFlags</a>;
00390 
00391             <span class="comment">/*</span>
00392 <span class="comment">             * If it's async, don't defer it: post it straight away.</span>
00393 <span class="comment">             */</span>
00394             <span class="keywordflow">if</span> (pNotify-&gt;<a class="code" href="../../d9/d2/structtagNOTIFY.html#o8">dwWEFlags</a> &amp; <a class="code" href="../../d4/d1/userk_8h.html#a612">WEF_ASYNC</a>) {
00395                 pNotify-&gt;<a class="code" href="../../d9/d2/structtagNOTIFY.html#o8">dwWEFlags</a> &amp;= ~<a class="code" href="../../d4/d1/userk_8h.html#a611">WEF_DEFERNOTIFY</a>;
00396             }
00397 
00398             <span class="keywordflow">if</span> (pNotify-&gt;<a class="code" href="../../d9/d2/structtagNOTIFY.html#o8">dwWEFlags</a> &amp; <a class="code" href="../../d4/d1/userk_8h.html#a611">WEF_DEFERNOTIFY</a>) {
00399 <span class="preprocessor">#if DBG</span>
00400 <span class="preprocessor"></span>                gnDeferredWinEvents++;
00401 <span class="preprocessor">#endif</span>
00402 <span class="preprocessor"></span>                <a class="code" href="../../d5/d7/kernel_2winable_8c.html#a1">DBGVERIFYNOTIFY</a>(pNotify);
00403             } <span class="keywordflow">else</span> {
00404                 pehNext = <a class="code" href="../../d5/d7/kernel_2winable_8c.html#a6">xxxProcessNotifyWinEvent</a>(pNotify);
00405             }
00406         }
00407     }
00408 
00409     <a class="code" href="../../d4/d1/userk_8h.html#a136">ThreadUnlockPti</a>(ptiCurrent, &amp;tlpti);
00410     <a class="code" href="../../d6/d0/usercli_8h.html#a40">ThreadUnlock</a>(&amp;tlpwnd);
00411 }
00412 
00413 <span class="comment">/****************************************************************************\</span>
00414 <span class="comment">*</span>
00415 <span class="comment">* CreateNotify()</span>
00416 <span class="comment">*</span>
00417 <span class="comment">* Gets a pointer to a NOTIFY struct that we can then propagate to our</span>
00418 <span class="comment">* event window via Send/PostMessage.  We have to do this since we want to</span>
00419 <span class="comment">* (pass on a lot more data then can be packed in the parameters.</span>
00420 <span class="comment">*</span>
00421 <span class="comment">*  We have one cached struct so we avoid lots of allocs and frees in the</span>
00422 <span class="comment">*  most common case of just one outstanding notification.</span>
00423 <span class="comment">\****************************************************************************/</span>
00424 <a class="code" href="../../d9/d2/structtagNOTIFY.html">PNOTIFY</a>
<a name="l00425"></a><a class="code" href="../../d5/d7/kernel_2winable_8c.html#a5">00425</a> <a class="code" href="../../d5/d7/kernel_2winable_8c.html#a5">CreateNotify</a>(<a class="code" href="../../d8/d4/structtagEVENTHOOK.html">PEVENTHOOK</a> pEvent, DWORD event, <a class="code" href="../../d6/d9/structtagWND.html">PWND</a> pwnd, LONG idObject,
00426     LONG idChild, <a class="code" href="../../d2/d8/structtagTHREADINFO.html">PTHREADINFO</a> ptiSender, DWORD dwTime)
00427 {
00428     <a class="code" href="../../d9/d2/structtagNOTIFY.html">PNOTIFY</a> pNotify;
00429     UserAssert(pEvent != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00430 
00431     <span class="comment">//</span>
00432     <span class="comment">// Get a pointer.  From cache if available.</span>
00433     <span class="comment">// IanJa - change this to allocate from zone a la AllocQEntry??</span>
00434     <span class="comment">//</span>
00435     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d7/kernel_2winable_8c.html#a3">fNotifyCacheInUse</a>) {
00436         <a class="code" href="../../d5/d7/kernel_2winable_8c.html#a3">fNotifyCacheInUse</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00437         pNotify = &amp;<a class="code" href="../../d5/d7/kernel_2winable_8c.html#a2">notifyCache</a>;
00438 <span class="preprocessor">#if DBG</span>
00439 <span class="preprocessor"></span>        <span class="comment">//</span>
00440         <span class="comment">// Make sure we aren't forgetting to set any fields.</span>
00441         <span class="comment">//</span>
00442         <span class="comment">// DebugFillBuffer(pNotify, sizeof(NOTIFY));</span>
00443 <span class="preprocessor">#endif</span>
00444 <span class="preprocessor"></span>    } <span class="keywordflow">else</span> {
00445         pNotify = (<a class="code" href="../../d9/d2/structtagNOTIFY.html">PNOTIFY</a>)UserAllocPool(<span class="keyword">sizeof</span>(<a class="code" href="../../d9/d2/structtagNOTIFY.html">NOTIFY</a>), TAG_NOTIFY);
00446         <span class="keywordflow">if</span> (!pNotify)
00447             <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00448     }
00449 
00450 
00451     <span class="comment">/*</span>
00452 <span class="comment">     * Fill in the notify block.</span>
00453 <span class="comment">     */</span>
00454     pNotify-&gt;<a class="code" href="../../d9/d2/structtagNOTIFY.html#o1">spEventHook</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00455     <a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>(&amp;pNotify-&gt;<a class="code" href="../../d9/d2/structtagNOTIFY.html#o1">spEventHook</a>, pEvent);
00456     pNotify-&gt;<a class="code" href="../../d9/d2/structtagNOTIFY.html#o3">hwnd</a> = <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a450">HW</a>(pwnd);
00457     pNotify-&gt;<a class="code" href="../../d9/d2/structtagNOTIFY.html#o2">event</a> = event;
00458     pNotify-&gt;<a class="code" href="../../d9/d2/structtagNOTIFY.html#o4">idObject</a> = idObject;
00459     pNotify-&gt;<a class="code" href="../../d9/d2/structtagNOTIFY.html#o5">idChild</a> = idChild;
00460     pNotify-&gt;<a class="code" href="../../d9/d2/structtagNOTIFY.html#o6">idSenderThread</a> = <a class="code" href="../../d4/d1/userk_8h.html#a107">TIDq</a>(ptiSender);
00461     UserAssert(pNotify-&gt;<a class="code" href="../../d9/d2/structtagNOTIFY.html#o6">idSenderThread</a> != 0);
00462     pNotify-&gt;<a class="code" href="../../d9/d2/structtagNOTIFY.html#o7">dwEventTime</a> = dwTime;
00463     pNotify-&gt;<a class="code" href="../../d9/d2/structtagNOTIFY.html#o8">dwWEFlags</a> = pEvent-&gt;<a class="code" href="../../d8/d4/structtagEVENTHOOK.html#o7">fSync</a> ? 0 : <a class="code" href="../../d4/d1/userk_8h.html#a612">WEF_ASYNC</a>;
00464     pNotify-&gt;<a class="code" href="../../d9/d2/structtagNOTIFY.html#o0">pNotifyNext</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00465     pNotify-&gt;<a class="code" href="../../d9/d2/structtagNOTIFY.html#o9">ptiReceiver</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00466 <span class="preprocessor">#if DBG</span>
00467 <span class="preprocessor"></span>    gnNotifies++;
00468 <span class="preprocessor">#endif</span>
00469 <span class="preprocessor"></span>
00470     <span class="comment">/*</span>
00471 <span class="comment">     * The order of non-deferred notifications doesn't matter; they are here</span>
00472 <span class="comment">     * simply for cleanup/in-use tracking. However, deferred notifications must</span>
00473 <span class="comment">     * be ordered with most recent at the end, so just order them all that way.</span>
00474 <span class="comment">     */</span>
00475     <span class="keywordflow">if</span> (<a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a256">gpPendingNotifies</a>) {
00476         UserAssert(<a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a257">gpLastPendingNotify</a>);
00477         UserAssert(<a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a257">gpLastPendingNotify</a>-&gt;<a class="code" href="../../d9/d2/structtagNOTIFY.html#o0">pNotifyNext</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00478         <a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a257">gpLastPendingNotify</a>-&gt;<a class="code" href="../../d9/d2/structtagNOTIFY.html#o0">pNotifyNext</a> = pNotify;
00479     } <span class="keywordflow">else</span> {
00480         <a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a256">gpPendingNotifies</a> = pNotify;
00481     }
00482     <a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a257">gpLastPendingNotify</a> = pNotify;
00483 
00484     <span class="keywordflow">return</span> pNotify;
00485 }
00486 
00487 
00488 <span class="comment">/****************************************************************************\</span>
00489 <span class="comment">*</span>
00490 <span class="comment">*  RemoveNotify()</span>
00491 <span class="comment">*</span>
00492 <span class="comment">*  NOTE:  This does NOT yield.</span>
00493 <span class="comment">\****************************************************************************/</span>
00494 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00495"></a><a class="code" href="../../d5/d7/kernel_2winable_8c.html#a9">00495</a> <a class="code" href="../../d5/d7/kernel_2winable_8c.html#a9">RemoveNotify</a>(<a class="code" href="../../d9/d2/structtagNOTIFY.html">PNOTIFY</a> *ppNotify)
00496 {
00497     <a class="code" href="../../d9/d2/structtagNOTIFY.html">PNOTIFY</a> pNotifyRemove;
00498 
00499     pNotifyRemove = *ppNotify;
00500 
00501     <span class="comment">/*</span>
00502 <span class="comment">     * First, get it out of the pending list.</span>
00503 <span class="comment">     */</span>
00504     *ppNotify = pNotifyRemove-&gt;<a class="code" href="../../d9/d2/structtagNOTIFY.html#o0">pNotifyNext</a>;
00505 
00506 <span class="preprocessor">#if DBG</span>
00507 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (pNotifyRemove-&gt;<a class="code" href="../../d9/d2/structtagNOTIFY.html#o8">dwWEFlags</a> &amp; <a class="code" href="../../d4/d1/userk_8h.html#a611">WEF_DEFERNOTIFY</a>) {
00508         UserAssert(gnDeferredWinEvents &gt; 0);
00509         gnDeferredWinEvents--;
00510     }
00511 <span class="preprocessor">#endif</span>
00512 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (*ppNotify == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00513         <span class="comment">/*</span>
00514 <span class="comment">         * Removing last notify, so fix up gpLastPendingNotify:</span>
00515 <span class="comment">         * If list now empty, there is no last item.</span>
00516 <span class="comment">         */</span>
00517         <span class="keywordflow">if</span> (<a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a256">gpPendingNotifies</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00518             <a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a257">gpLastPendingNotify</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00519         } <span class="keywordflow">else</span> {
00520             <a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a257">gpLastPendingNotify</a> = CONTAINING_RECORD(ppNotify, <a class="code" href="../../d9/d2/structtagNOTIFY.html">NOTIFY</a>, pNotifyNext);
00521         }
00522     }
00523     UserAssert((<a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a256">gpPendingNotifies</a> == 0) || (<a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a256">gpPendingNotifies</a> &gt; (<a class="code" href="../../d9/d2/structtagNOTIFY.html">PNOTIFY</a>)100));
00524 
00525     <a class="code" href="../../d5/d7/kernel_2winable_8c.html#a0">DBGVERIFYEVENTHOOK</a>(pNotifyRemove-&gt;<a class="code" href="../../d9/d2/structtagNOTIFY.html#o1">spEventHook</a>);
00526 
00527     <span class="comment">/*</span>
00528 <span class="comment">     * This may cause the win event hook to be freed.</span>
00529 <span class="comment">     */</span>
00530     <a class="code" href="../../d6/d0/usercli_8h.html#a42">Unlock</a>(&amp;pNotifyRemove-&gt;<a class="code" href="../../d9/d2/structtagNOTIFY.html#o1">spEventHook</a>);
00531 
00532     <span class="comment">//</span>
00533     <span class="comment">// Now free it.  Either put it back in the cache if it is the cache,</span>
00534     <span class="comment">// or really free it otherwise.</span>
00535     <span class="comment">//</span>
00536     <span class="keywordflow">if</span> (pNotifyRemove == &amp;<a class="code" href="../../d5/d7/kernel_2winable_8c.html#a2">notifyCache</a>) {
00537         UserAssert(<a class="code" href="../../d5/d7/kernel_2winable_8c.html#a3">fNotifyCacheInUse</a>);
00538         <a class="code" href="../../d5/d7/kernel_2winable_8c.html#a3">fNotifyCacheInUse</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00539     } <span class="keywordflow">else</span> {
00540         UserFreePool(pNotifyRemove);
00541     }
00542 <span class="preprocessor">#if DBG</span>
00543 <span class="preprocessor"></span>    UserAssert(gnNotifies &gt; 0);
00544     gnNotifies--;
00545 <span class="preprocessor">#endif</span>
00546 <span class="preprocessor"></span>}
00547 
00548 
00549 <span class="comment">/*****************************************************************************\</span>
00550 <span class="comment">*</span>
00551 <span class="comment">* DestroyNotify()</span>
00552 <span class="comment">*</span>
00553 <span class="comment">* NOTE:  This does NOT yield.</span>
00554 <span class="comment">*</span>
00555 <span class="comment">* This gets the notification out of our pending list and frees the local</span>
00556 <span class="comment">* memory it uses.</span>
00557 <span class="comment">*</span>
00558 <span class="comment">* This function is called</span>
00559 <span class="comment">* (1) NORMALLY:   After returning from calling the notify proc</span>
00560 <span class="comment">* (2) CLEANUP:    When a thread goes away, we cleanup async notifies it</span>
00561 <span class="comment">*     hasn't received, and sync notifies it was in the middle of trying</span>
00562 <span class="comment">*     to call (i.e. the event proc faulted).</span>
00563 <span class="comment">*</span>
00564 <span class="comment">\*****************************************************************************/</span>
00565 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00566"></a><a class="code" href="../../d5/d7/kernel_2winable_8c.html#a10">00566</a> <a class="code" href="../../d5/d7/kernel_2winable_8c.html#a10">DestroyNotify</a>(<a class="code" href="../../d9/d2/structtagNOTIFY.html">PNOTIFY</a> pNotifyDestroy)
00567 {
00568     <a class="code" href="../../d9/d2/structtagNOTIFY.html">PNOTIFY</a>  *ppNotify;
00569     <a class="code" href="../../d9/d2/structtagNOTIFY.html">PNOTIFY</a>  pNotifyT;
00570 
00571     <a class="code" href="../../d5/d7/kernel_2winable_8c.html#a1">DBGVERIFYNOTIFY</a>(pNotifyDestroy);
00572 
00573     <span class="comment">/*</span>
00574 <span class="comment">     * Either this notify isn't currently in the process of calling back</span>
00575 <span class="comment">     * (which means ptiReceiver is NULL) or the thread destroying it</span>
00576 <span class="comment">     * must be the one that was calling back (which means this thread</span>
00577 <span class="comment">     * was destroyed during the callback and is cleaning up).</span>
00578 <span class="comment">     */</span>
00579     UserAssert((pNotifyDestroy-&gt;<a class="code" href="../../d9/d2/structtagNOTIFY.html#o9">ptiReceiver</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) ||
00580             (pNotifyDestroy-&gt;<a class="code" href="../../d9/d2/structtagNOTIFY.html#o9">ptiReceiver</a> == <a class="code" href="../../d4/d1/userk_8h.html#a9">PtiCurrent</a>()));
00581 
00582     ppNotify = &amp;<a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a256">gpPendingNotifies</a>;
00583     <span class="keywordflow">while</span> (pNotifyT = *ppNotify) {
00584         <span class="keywordflow">if</span> (pNotifyT == pNotifyDestroy) {
00585             <a class="code" href="../../d5/d7/kernel_2winable_8c.html#a9">RemoveNotify</a>(ppNotify);
00586             <span class="keywordflow">return</span>;
00587         } <span class="keywordflow">else</span> {
00588             ppNotify = &amp;pNotifyT-&gt;<a class="code" href="../../d9/d2/structtagNOTIFY.html#o0">pNotifyNext</a>;
00589         }
00590     }
00591     RIPMSG1(RIP_ERROR, <span class="stringliteral">"DestroyNotify %#p - not found"</span>, pNotifyDestroy);
00592 }
00593 
00594 
00595 
00596 <span class="comment">/***************************************************************************\</span>
00597 <span class="comment">* FreeThreadsWinEvents</span>
00598 <span class="comment">*</span>
00599 <span class="comment">* During 'exit-list' processing this function is called to free any WinEvent</span>
00600 <span class="comment">* notifications and WinEvent hooks created by the current thread.</span>
00601 <span class="comment">*</span>
00602 <span class="comment">* Notifications that remain may be:</span>
00603 <span class="comment">*  o  Posted notifications (async)</span>
00604 <span class="comment">*  o  Notifications in xxxClientCallWinEventProc (sync)</span>
00605 <span class="comment">*  o  Deferred notifications (should be sync only)</span>
00606 <span class="comment">* Destroy the sync notifications, because we cannot do callbacks</span>
00607 <span class="comment">* while in thread cleanup.</span>
00608 <span class="comment">* Leave the posted (async) notifications alone: they're on their way already.</span>
00609 <span class="comment">*</span>
00610 <span class="comment">* History:</span>
00611 <span class="comment">* 11-11-96 IanJa         Created.</span>
00612 <span class="comment">\***************************************************************************/</span>
00613 
00614 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00615"></a><a class="code" href="../../d5/d7/kernel_2winable_8c.html#a11">00615</a> <a class="code" href="../../d5/d7/kernel_2winable_8c.html#a11">FreeThreadsWinEvents</a>(<a class="code" href="../../d2/d8/structtagTHREADINFO.html">PTHREADINFO</a> pti)
00616 {
00617     <a class="code" href="../../d8/d4/structtagEVENTHOOK.html">PEVENTHOOK</a> peh, pehNext;
00618     <a class="code" href="../../d9/d2/structtagNOTIFY.html">PNOTIFY</a> pn, pnNext;
00619     <a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a> idCurrentThread = W32GetCurrentTID();
00620 
00621     <span class="comment">/*</span>
00622 <span class="comment">     * Loop through all the notifications</span>
00623 <span class="comment">     */</span>
00624     <span class="keywordflow">for</span> (pn = <a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a256">gpPendingNotifies</a>; pn; pn = pnNext) {
00625         pnNext = pn-&gt;<a class="code" href="../../d9/d2/structtagNOTIFY.html#o0">pNotifyNext</a>;
00626 
00627         <span class="comment">/*</span>
00628 <span class="comment">         * Only destroy sync notifications that belong to this thread</span>
00629 <span class="comment">         * and are not currently calling back i.e. ptiReceiver must be NULL.</span>
00630 <span class="comment">         * Otherwise, when we come back from the callback in</span>
00631 <span class="comment">         * xxxProcessNotifyWinEvent we will operate on a freed notify.</span>
00632 <span class="comment">         * Also destroy the notification if the receiver is going away</span>
00633 <span class="comment">         * or else it gets leaked as long as the sender is alive.</span>
00634 <span class="comment">         */</span>
00635         <span class="keywordflow">if</span> ((pn-&gt;<a class="code" href="../../d9/d2/structtagNOTIFY.html#o6">idSenderThread</a> == idCurrentThread &amp;&amp;
00636                 pn-&gt;<a class="code" href="../../d9/d2/structtagNOTIFY.html#o9">ptiReceiver</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) || (pn-&gt;<a class="code" href="../../d9/d2/structtagNOTIFY.html#o9">ptiReceiver</a> == pti)) {
00637             <span class="keywordflow">if</span> ((pn-&gt;<a class="code" href="../../d9/d2/structtagNOTIFY.html#o8">dwWEFlags</a> &amp; <a class="code" href="../../d4/d1/userk_8h.html#a612">WEF_ASYNC</a>) == 0) {
00638                 UserAssert((pn-&gt;<a class="code" href="../../d9/d2/structtagNOTIFY.html#o8">dwWEFlags</a> &amp; <a class="code" href="../../d4/d1/userk_8h.html#a613">WEF_POSTED</a>) == 0);
00639                 <a class="code" href="../../d5/d7/kernel_2winable_8c.html#a10">DestroyNotify</a>(pn);
00640             }
00641         }
00642     }
00643 
00644     peh = <a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a255">gpWinEventHooks</a>;
00645     <span class="keywordflow">while</span> (peh) {
00646         pehNext = peh-&gt;<a class="code" href="../../d8/d4/structtagEVENTHOOK.html#o1">pehNext</a>;
00647         <span class="keywordflow">if</span> (<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a455">GETPTI</a>(peh) == pti) {
00648             <a class="code" href="../../d5/d7/kernel_2winable_8c.html#a14">DestroyEventHook</a>(peh);
00649         }
00650         peh = pehNext;
00651     }
00652     <span class="comment">// Async notification not yet processed may still be posted in a queue,</span>
00653     <span class="comment">// pending being read and processed (gnNotifies &gt; 0), although the</span>
00654     <span class="comment">// originating hook has now been unhooked (maybe gpWinEventHooks == NULL)</span>
00655     <span class="comment">// so the following assert is no good:</span>
00656     <span class="comment">// UserAssert(gpWinEventHooks || (!gpWinEventHooks &amp;&amp; !gnNotifies));</span>
00657 }
00658 
00659 
00660 <span class="comment">// --------------------------------------------------------------------------</span>
00661 <span class="comment">//</span>
00662 <span class="comment">//  _SetWinEventHook()</span>
00663 <span class="comment">//</span>
00664 <span class="comment">//  This installs a win event hook.</span>
00665 <span class="comment">//</span>
00666 <span class="comment">//</span>
00667 <span class="comment">// If hEventProcess set but idEventThread = 0, hook all threads in process.</span>
00668 <span class="comment">// If idEventThread set but hEventProcess = NULL, hook single thread only.</span>
00669 <span class="comment">// If neither are set, hook everything.</span>
00670 <span class="comment">// If both are set ??</span>
00671 <span class="comment">//</span>
00672 <span class="comment">// --------------------------------------------------------------------------</span>
00673 <a class="code" href="../../d8/d4/structtagEVENTHOOK.html">PEVENTHOOK</a>
<a name="l00674"></a><a class="code" href="../../d5/d7/kernel_2winable_8c.html#a12">00674</a> <a class="code" href="../../d5/d7/kernel_2winable_8c.html#a12">_SetWinEventHook</a>(
00675     DWORD           eventMin,
00676     DWORD           eventMax,
00677     HMODULE         hmodWinEventProc,
00678     PUNICODE_STRING pstrLib,
00679     WINEVENTPROC    pfnWinEventProc,
00680     HANDLE          hEventProcess,
00681     DWORD           idEventThread,
00682     DWORD           dwFlags)
00683 {
00684     <a class="code" href="../../d8/d4/structtagEVENTHOOK.html">PEVENTHOOK</a> pEventNew;
00685     <a class="code" href="../../d2/d8/structtagTHREADINFO.html">PTHREADINFO</a> ptiCurrent;
00686 
00687     <span class="keywordtype">int</span> ihmod;
00688 
00689     ptiCurrent = <a class="code" href="../../d4/d1/userk_8h.html#a9">PtiCurrent</a>();
00690 
00691     <span class="comment">//</span>
00692     <span class="comment">// If exiting, fail the call.</span>
00693     <span class="comment">//</span>
00694     <span class="keywordflow">if</span> (ptiCurrent-&gt;<a class="code" href="../../d2/d8/structtagTHREADINFO.html#o9">TIF_flags</a> &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a795">TIF_INCLEANUP</a>) {
00695         RIPMSG1(RIP_ERROR, <span class="stringliteral">"SetWinEventHook: Fail call - thread %#p in cleanup"</span>, ptiCurrent);
00696         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00697     }
00698 
00699     <span class="comment">/*</span>
00700 <span class="comment">     * Check to see if filter proc is valid.</span>
00701 <span class="comment">     */</span>
00702     <span class="keywordflow">if</span> (pfnWinEventProc == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00703         RIPERR0(ERROR_INVALID_FILTER_PROC, RIP_VERBOSE, <span class="stringliteral">"pfnWinEventProc == NULL"</span>);
00704         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00705     }
00706 
00707     <span class="keywordflow">if</span> (eventMin &gt; eventMax) {
00708         RIPERR0(ERROR_INVALID_HOOK_FILTER, RIP_VERBOSE, <span class="stringliteral">"eventMin &gt; eventMax"</span>);
00709         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00710     }
00711 
00712     <span class="keywordflow">if</span> (<a class="code" href="../../d3/d8/propapi_8h.html#a34">dwFlags</a> &amp; WINEVENT_INCONTEXT) {
00713         <span class="comment">/*</span>
00714 <span class="comment">         * WinEventProc to be called in context of hooked thread, so needs a DLL</span>
00715 <span class="comment">         */</span>
00716         <span class="keywordflow">if</span> (hmodWinEventProc == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00717             RIPERR0(ERROR_HOOK_NEEDS_HMOD, RIP_VERBOSE, <span class="stringliteral">""</span>);
00718             <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00719         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pstrLib == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00720             <span class="comment">/*</span>
00721 <span class="comment">             * If we got an hmod, we should get a DLL name too!</span>
00722 <span class="comment">             */</span>
00723             RIPERR1(ERROR_DLL_NOT_FOUND, RIP_ERROR,
00724                     <span class="stringliteral">"hmod %#p, but no lib name"</span>, hmodWinEventProc);
00725             <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00726         }
00727         ihmod = <a class="code" href="../../d4/d1/userk_8h.html#a1541">GetHmodTableIndex</a>(pstrLib);
00728         <span class="keywordflow">if</span> (ihmod == -1) {
00729             RIPERR0(ERROR_MOD_NOT_FOUND, RIP_VERBOSE, <span class="stringliteral">""</span>);
00730             <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00731         }
00732     } <span class="keywordflow">else</span> {
00733         ihmod = -1;            <span class="comment">// means no DLL is required</span>
00734         hmodWinEventProc = 0;
00735     }
00736 
00737     <span class="comment">/*</span>
00738 <span class="comment">     * Check the thread id, check it is a GUI thread.</span>
00739 <span class="comment">     */</span>
00740     <span class="keywordflow">if</span> (idEventThread != 0) {
00741         <a class="code" href="../../d2/d8/structtagTHREADINFO.html">PTHREADINFO</a> ptiT;
00742 
00743         ptiT = <a class="code" href="../../d4/d1/userk_8h.html#a1201">PtiFromThreadId</a>(idEventThread);
00744         <span class="keywordflow">if</span> ((ptiT == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) ||
00745                 !(ptiT-&gt;<a class="code" href="../../d2/d8/structtagTHREADINFO.html#o9">TIF_flags</a> &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a816">TIF_GUITHREADINITIALIZED</a>)) {
00746             RIPERR1(ERROR_INVALID_THREAD_ID, RIP_VERBOSE, <span class="stringliteral">"pti %#p"</span>, ptiT);
00747             <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00748         }
00749     }
00750 
00751     <span class="comment">//</span>
00752     <span class="comment">// Create the window for async events first.  Creating it might yield,</span>
00753     <span class="comment">// so we want to do this before we've touched our event array.</span>
00754     <span class="comment">//</span>
00755     <span class="comment">// NOTE that USER itself will not pass on window creation/destruction</span>
00756     <span class="comment">// notifications for</span>
00757     <span class="comment">//      * IME windows</span>
00758     <span class="comment">//      * OLE windows</span>
00759     <span class="comment">//      * RPC windows</span>
00760     <span class="comment">//      * Event windows</span>
00761     <span class="comment">//</span>
00762 
00763     <span class="comment">//</span>
00764     <span class="comment">// Get a new event.</span>
00765     <span class="comment">//</span>
00766     pEventNew = (<a class="code" href="../../d8/d4/structtagEVENTHOOK.html">PEVENTHOOK</a>)<a class="code" href="../../d4/d1/userk_8h.html#a969">HMAllocObject</a>(ptiCurrent, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00767             <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a251">TYPE_WINEVENTHOOK</a>, <span class="keyword">sizeof</span>(<a class="code" href="../../d8/d4/structtagEVENTHOOK.html">EVENTHOOK</a>));
00768     <span class="keywordflow">if</span> (!pEventNew)
00769         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00770 
00771     <span class="comment">//</span>
00772     <span class="comment">// Fill in the new event.</span>
00773     <span class="comment">//</span>
00774     pEventNew-&gt;<a class="code" href="../../d8/d4/structtagEVENTHOOK.html#o2">eventMin</a> = (<a class="code" href="../../d9/d5/ndismain_8h.html#a265">UINT</a>)eventMin;
00775     pEventNew-&gt;<a class="code" href="../../d8/d4/structtagEVENTHOOK.html#o3">eventMax</a> = (<a class="code" href="../../d9/d5/ndismain_8h.html#a265">UINT</a>)eventMax;
00776 
00777     <span class="comment">// pEventNew-&gt;f32Bit = ((dwFlags &amp; WINEVENT_32BITCALLER) != 0);</span>
00778     pEventNew-&gt;<a class="code" href="../../d8/d4/structtagEVENTHOOK.html#o5">fIgnoreOwnThread</a> = ((<a class="code" href="../../d3/d8/propapi_8h.html#a34">dwFlags</a> &amp; WINEVENT_SKIPOWNTHREAD) != 0);
00779     pEventNew-&gt;<a class="code" href="../../d8/d4/structtagEVENTHOOK.html#o6">fIgnoreOwnProcess</a> = ((<a class="code" href="../../d3/d8/propapi_8h.html#a34">dwFlags</a> &amp; WINEVENT_SKIPOWNPROCESS) != 0);
00780     pEventNew-&gt;<a class="code" href="../../d8/d4/structtagEVENTHOOK.html#o4">fDestroyed</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00781     pEventNew-&gt;<a class="code" href="../../d8/d4/structtagEVENTHOOK.html#o7">fSync</a> = ((<a class="code" href="../../d3/d8/propapi_8h.html#a34">dwFlags</a> &amp; WINEVENT_INCONTEXT) != 0);
00782 
00783     pEventNew-&gt;<a class="code" href="../../d8/d4/structtagEVENTHOOK.html#o9">hEventProcess</a> = hEventProcess;
00784     pEventNew-&gt;<a class="code" href="../../d8/d4/structtagEVENTHOOK.html#o10">idEventThread</a> = idEventThread;
00785     <span class="comment">// pEventNew-&gt;cInUse = 0;</span>
00786 
00787     pEventNew-&gt;<a class="code" href="../../d8/d4/structtagEVENTHOOK.html#o12">ihmod</a> = ihmod;
00788 
00789     <span class="comment">/*</span>
00790 <span class="comment">     * Add a dependency on this module - meaning, increment a count</span>
00791 <span class="comment">     * that simply counts the number of hooks set into this module.</span>
00792 <span class="comment">     */</span>
00793     <span class="keywordflow">if</span> (pEventNew-&gt;<a class="code" href="../../d8/d4/structtagEVENTHOOK.html#o12">ihmod</a> &gt;= 0) {
00794         <a class="code" href="../../d4/d1/userk_8h.html#a1542">AddHmodDependency</a>(pEventNew-&gt;<a class="code" href="../../d8/d4/structtagEVENTHOOK.html#o12">ihmod</a>);
00795     }
00796 
00797     <span class="comment">/*</span>
00798 <span class="comment">     * If pfnWinEventProc is in caller's process and no DLL is involved,</span>
00799 <span class="comment">     * then pEventNew-&gt;offPfn is the actual address.</span>
00800 <span class="comment">     */</span>
00801     pEventNew-&gt;<a class="code" href="../../d8/d4/structtagEVENTHOOK.html#o11">offPfn</a> = ((ULONG_PTR)pfnWinEventProc) - ((ULONG_PTR)hmodWinEventProc);
00802 
00803     <span class="comment">//</span>
00804     <span class="comment">//</span>
00805     <span class="comment">// Link our event into the master list.</span>
00806     <span class="comment">//</span>
00807     <span class="comment">// Note that we count on USER to not generate any events when installing</span>
00808     <span class="comment">// our hook.  The caller can't handle it yet since he hasn't got back</span>
00809     <span class="comment">// his event handle from this call.</span>
00810     <span class="comment">//</span>
00811     pEventNew-&gt;<a class="code" href="../../d8/d4/structtagEVENTHOOK.html#o1">pehNext</a> = <a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a255">gpWinEventHooks</a>;
00812     <a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a255">gpWinEventHooks</a> = pEventNew;
00813     <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a381">SET_SRVIF</a>(<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a375">SRVIF_WINEVENTHOOKS</a>);
00814 
00815     <span class="keywordflow">return</span> pEventNew;
00816 }
00817 
00818 <span class="comment">/****************************************************************************\</span>
00819 <span class="comment">*  UnhookWinEvent()</span>
00820 <span class="comment">*</span>
00821 <span class="comment">*  Unhooks a win event hook.  We of course sanity check that this thread is</span>
00822 <span class="comment">*  the one which installed the hook.  We have to:  We are going to destroy</span>
00823 <span class="comment">*  the IPC window and that must be in context.</span>
00824 <span class="comment">*</span>
00825 <span class="comment">\****************************************************************************/</span>
00826 <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a11">BOOL</a>
<a name="l00827"></a><a class="code" href="../../d5/d7/kernel_2winable_8c.html#a13">00827</a> <a class="code" href="../../d5/d7/kernel_2winable_8c.html#a13">_UnhookWinEvent</a>(<a class="code" href="../../d8/d4/structtagEVENTHOOK.html">PEVENTHOOK</a> pEventUnhook)
00828 {
00829     <a class="code" href="../../d5/d7/kernel_2winable_8c.html#a0">DBGVERIFYEVENTHOOK</a>(pEventUnhook);
00830 
00831     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a438">HMIsMarkDestroy</a>(pEventUnhook) || (<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a455">GETPTI</a>(pEventUnhook) != <a class="code" href="../../d4/d1/userk_8h.html#a9">PtiCurrent</a>())) {
00832         <span class="comment">//</span>
00833         <span class="comment">// We do this to avoid someone calling UnhookWinEvent() the first</span>
00834         <span class="comment">// time, then somehow getting control again and calling it a second</span>
00835         <span class="comment">// time before we've managed to free up the event since someone was</span>
00836         <span class="comment">// in the middle of using it at the first UWE call.</span>
00837         <span class="comment">//</span>
00838 
00839         RIPERR0(ERROR_INVALID_HANDLE, RIP_WARNING, <span class="stringliteral">"_UnhookWinEvent: Invalid event hook"</span>);
00840         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00841     }
00842 
00843     <span class="comment">//</span>
00844     <span class="comment">// Purge this baby if all notifications are done.</span>
00845     <span class="comment">//      * if there are SYNC ones pending, the caller will clean this up</span>
00846     <span class="comment">//          upon the return from calling the event</span>
00847     <span class="comment">//      * if there are ASYNC ones pending, the receiver will not call</span>
00848     <span class="comment">//          the event and clean it up when he gets it.</span>
00849     <span class="comment">//</span>
00850 
00851     <span class="comment">//</span>
00852     <span class="comment">// NOTE that DestroyEventHook() does not yield!</span>
00853     <span class="comment">//</span>
00854     <a class="code" href="../../d5/d7/kernel_2winable_8c.html#a14">DestroyEventHook</a>(pEventUnhook);
00855 
00856     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00857 }
00858 
00859 
00860 
00861 
00862 <span class="comment">/*****************************************************************************\</span>
00863 <span class="comment">*</span>
00864 <span class="comment">* DestroyEventHook()</span>
00865 <span class="comment">*</span>
00866 <span class="comment">* NOTE that this does NOT yield</span>
00867 <span class="comment">*</span>
00868 <span class="comment">* Destroys an event when the ref count has gone down to zero.  It may</span>
00869 <span class="comment">* happen</span>
00870 <span class="comment">*     * in the event generator's context, after returning from a callback</span>
00871 <span class="comment">*         and the ref count dropped to zero, if sync</span>
00872 <span class="comment">*     * in the event installer's context, after returning from a callback</span>
00873 <span class="comment">*         and the ref count dropped to zero if async</span>
00874 <span class="comment">*     * in the event installer's context, if on _UnhookWinEvent() the event</span>
00875 <span class="comment">*         was not in use at all</span>
00876 <span class="comment">*</span>
00877 <span class="comment">\*****************************************************************************/</span>
00878 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00879"></a><a class="code" href="../../d5/d7/kernel_2winable_8c.html#a14">00879</a> <a class="code" href="../../d5/d7/kernel_2winable_8c.html#a14">DestroyEventHook</a>(<a class="code" href="../../d8/d4/structtagEVENTHOOK.html">PEVENTHOOK</a> pEventDestroy)
00880 {
00881     <a class="code" href="../../d8/d4/structtagEVENTHOOK.html">PEVENTHOOK</a> *ppEvent;
00882     <a class="code" href="../../d8/d4/structtagEVENTHOOK.html">PEVENTHOOK</a> pEventT;
00883 
00884     <a class="code" href="../../d5/d7/kernel_2winable_8c.html#a0">DBGVERIFYEVENTHOOK</a>(pEventDestroy);
00885     UserAssert(<a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a255">gpWinEventHooks</a>);
00886 
00887     <span class="comment">/*</span>
00888 <span class="comment">     * Mark this event as destroyed, but don't remove it from the event list</span>
00889 <span class="comment">     * until its lock count goes to 0 - we may be traversing the list</span>
00890 <span class="comment">     * within xxxWindowEvent, so we mustn't break the link to the next hook.</span>
00891 <span class="comment">     */</span>
00892     pEventDestroy-&gt;<a class="code" href="../../d8/d4/structtagEVENTHOOK.html#o4">fDestroyed</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00893 
00894     <span class="comment">/*</span>
00895 <span class="comment">     * If the object is locked, mark it for destroy but don't free it yet.</span>
00896 <span class="comment">     */</span>
00897     <span class="keywordflow">if</span> (!<a class="code" href="../../d4/d1/userk_8h.html#a971">HMMarkObjectDestroy</a>(pEventDestroy))
00898         <span class="keywordflow">return</span>;
00899 
00900     <span class="comment">/*</span>
00901 <span class="comment">     * Remove this from our event list.</span>
00902 <span class="comment">     */</span>
00903     <span class="keywordflow">for</span> (ppEvent = &amp;<a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a255">gpWinEventHooks</a>; pEventT = *ppEvent; ppEvent = &amp;pEventT-&gt;<a class="code" href="../../d8/d4/structtagEVENTHOOK.html#o1">pehNext</a>) {
00904         <span class="keywordflow">if</span> (pEventT == pEventDestroy) {
00905             *ppEvent = pEventDestroy-&gt;<a class="code" href="../../d8/d4/structtagEVENTHOOK.html#o1">pehNext</a>;
00906             <span class="keywordflow">break</span>;
00907         }
00908     }
00909     UserAssert(pEventT);
00910     <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a383">SET_OR_CLEAR_SRVIF</a>(<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a375">SRVIF_WINEVENTHOOKS</a>, <a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a255">gpWinEventHooks</a>);
00911 
00912     <span class="comment">/*</span>
00913 <span class="comment">     * Make sure each hooked thread will unload the hook proc DLL</span>
00914 <span class="comment">     */</span>
00915     <span class="keywordflow">if</span> (pEventDestroy-&gt;<a class="code" href="../../d8/d4/structtagEVENTHOOK.html#o12">ihmod</a> &gt;= 0) {
00916         <a class="code" href="../../d4/d1/userk_8h.html#a1543">RemoveHmodDependency</a>(pEventDestroy-&gt;<a class="code" href="../../d8/d4/structtagEVENTHOOK.html#o12">ihmod</a>);
00917     }
00918 
00919     <span class="comment">/*</span>
00920 <span class="comment">     * Free this pointer.</span>
00921 <span class="comment">     */</span>
00922     <a class="code" href="../../d4/d1/userk_8h.html#a970">HMFreeObject</a>(pEventDestroy);
00923 
00924     <span class="keywordflow">return</span>;
00925 }
00926 
00927 <span class="comment">/***************************************************************************\</span>
00928 <span class="comment">*</span>
00929 <span class="comment">* xxxGetEventProc()</span>
00930 <span class="comment">*</span>
00931 <span class="comment">* For sync events, this gets the address to call.  If 16-bits, then just</span>
00932 <span class="comment">* return the installed address.  If 32-bits, we need to load the library</span>
00933 <span class="comment">* if not in the same process as the installer.</span>
00934 <span class="comment">\***************************************************************************/</span>
00935 WINEVENTPROC
<a name="l00936"></a><a class="code" href="../../d5/d7/kernel_2winable_8c.html#a4">00936</a> <a class="code" href="../../d5/d7/kernel_2winable_8c.html#a4">xxxGetEventProc</a>(<a class="code" href="../../d8/d4/structtagEVENTHOOK.html">PEVENTHOOK</a> pEventOrg) {
00937     <a class="code" href="../../d2/d8/structtagTHREADINFO.html">PTHREADINFO</a> ptiCurrent;
00938 
00939     UserAssert(pEventOrg);
00940     UserAssert(pEventOrg-&gt;<a class="code" href="../../d8/d4/structtagEVENTHOOK.html#o7">fSync</a>);
00941     UserAssert(pEventOrg-&gt;<a class="code" href="../../d8/d4/structtagEVENTHOOK.html#o12">ihmod</a> &gt;= 0);
00942     UserAssert(pEventOrg-&gt;<a class="code" href="../../d8/d4/structtagEVENTHOOK.html#o11">offPfn</a> != 0);
00943 
00944     <a class="code" href="../../d6/d0/usercli_8h.html#a35">CheckLock</a>(pEventOrg);
00945 
00946     <span class="comment">/*</span>
00947 <span class="comment">     * Make sure the hook is still around before we</span>
00948 <span class="comment">     * try and call it.</span>
00949 <span class="comment">     */</span>
00950     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a438">HMIsMarkDestroy</a>(pEventOrg)) {
00951         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00952     }
00953 
00954     ptiCurrent = <a class="code" href="../../d4/d1/userk_8h.html#a9">PtiCurrent</a>();
00955 
00956     <span class="comment">/*</span>
00957 <span class="comment">     * Make sure the DLL for this hook, if any, has been loaded</span>
00958 <span class="comment">     * for the current process.</span>
00959 <span class="comment">     */</span>
00960     <span class="keywordflow">if</span> ((pEventOrg-&gt;<a class="code" href="../../d8/d4/structtagEVENTHOOK.html#o12">ihmod</a> != -1) &amp;&amp;
00961             (<a class="code" href="../../d4/d1/userk_8h.html#a420">TESTHMODLOADED</a>(ptiCurrent, pEventOrg-&gt;<a class="code" href="../../d8/d4/structtagEVENTHOOK.html#o12">ihmod</a>) == 0)) {
00962 
00963         <span class="comment">/*</span>
00964 <span class="comment">         * Try loading the library, since it isn't loaded in this processes</span>
00965 <span class="comment">         * context.  The hook is alrerady locked, so it won't go away while</span>
00966 <span class="comment">         * we're loading this library.</span>
00967 <span class="comment">         */</span>
00968         <span class="keywordflow">if</span> (<a class="code" href="../../d4/d1/userk_8h.html#a1544">xxxLoadHmodIndex</a>(pEventOrg-&gt;<a class="code" href="../../d8/d4/structtagEVENTHOOK.html#o12">ihmod</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00969             <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00970         }
00971     }
00972 
00973     <span class="comment">/*</span>
00974 <span class="comment">     * While we're still inside the critical section make sure the</span>
00975 <span class="comment">     * hook hasn't been 'freed'.  If so just return NULL.</span>
00976 <span class="comment">     * IanJa - since WinEvent has already been called, you might think that we</span>
00977 <span class="comment">     * should pass the event on, but the hooker may not be expecting this after</span>
00978 <span class="comment">     * having cancelled the hook!  In any case, seems we may have two ways</span>
00979 <span class="comment">     * of detecting that this hook has been removed:</span>
00980 <span class="comment">     */</span>
00981 
00982     <span class="comment">/*</span>
00983 <span class="comment">     * Make sure the hook is still around before we</span>
00984 <span class="comment">     * try and call it.</span>
00985 <span class="comment">     */</span>
00986     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a438">HMIsMarkDestroy</a>(pEventOrg)) {
00987         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00988     }
00989 
00990     <span class="keywordflow">return</span> (WINEVENTPROC)<a class="code" href="../../d4/d1/userk_8h.html#a423">PFNHOOK</a>(pEventOrg);
00991 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:42:25 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
