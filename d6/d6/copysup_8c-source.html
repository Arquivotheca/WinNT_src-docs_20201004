<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: copysup.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>copysup.c</h1><a href="../../d5/d7/copysup_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1990  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    copysup.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module implements the copy support routines for the Cache subsystem.</span>
00012 <span class="comment"></span>
00013 <span class="comment">Author:</span>
00014 <span class="comment"></span>
00015 <span class="comment">    Tom Miller      [TomM]      4-May-1990</span>
00016 <span class="comment"></span>
00017 <span class="comment">Revision History:</span>
00018 <span class="comment"></span>
00019 <span class="comment">--*/</span>
00020 
00021 <span class="preprocessor">#include "<a class="code" href="../../d5/d5/cc_8h.html">cc.h</a>"</span>
00022 
00023 <span class="comment">//</span>
00024 <span class="comment">//  Define our debug constant</span>
00025 <span class="comment">//</span>
00026 
<a name="l00027"></a><a class="code" href="../../d5/d7/copysup_8c.html#a0">00027</a> <span class="preprocessor">#define me 0x00000004</span>
00028 <span class="preprocessor"></span>
00029 
00030 BOOLEAN
<a name="l00031"></a><a class="code" href="../../d4/d2/cache_8h.html#a74">00031</a> <a class="code" href="../../d4/d2/cache_8h.html#a74">CcCopyRead</a> (
00032     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
00033     IN PLARGE_INTEGER FileOffset,
00034     IN ULONG Length,
00035     IN BOOLEAN Wait,
00036     OUT PVOID Buffer,
00037     OUT PIO_STATUS_BLOCK IoStatus
00038     )
00039 
00040 <span class="comment">/*++</span>
00041 <span class="comment"></span>
00042 <span class="comment">Routine Description:</span>
00043 <span class="comment"></span>
00044 <span class="comment">    This routine attempts to copy the specified file data from the cache</span>
00045 <span class="comment">    into the output buffer, and deliver the correct I/O status.  It is *not*</span>
00046 <span class="comment">    safe to call this routine from Dpc level.</span>
00047 <span class="comment"></span>
00048 <span class="comment">    If the caller does not want to block (such as for disk I/O), then</span>
00049 <span class="comment">    Wait should be supplied as FALSE.  If Wait was supplied as FALSE and</span>
00050 <span class="comment">    it is currently impossible to supply all of the requested data without</span>
00051 <span class="comment">    blocking, then this routine will return FALSE.  However, if the</span>
00052 <span class="comment">    data is immediately accessible in the cache and no blocking is</span>
00053 <span class="comment">    required, this routine copies the data and returns TRUE.</span>
00054 <span class="comment"></span>
00055 <span class="comment">    If the caller supplies Wait as TRUE, then this routine is guaranteed</span>
00056 <span class="comment">    to copy the data and return TRUE.  If the data is immediately</span>
00057 <span class="comment">    accessible in the cache, then no blocking will occur.  Otherwise,</span>
00058 <span class="comment">    the the data transfer from the file into the cache will be initiated,</span>
00059 <span class="comment">    and the caller will be blocked until the data can be returned.</span>
00060 <span class="comment"></span>
00061 <span class="comment">    File system Fsd's should typically supply Wait = TRUE if they are</span>
00062 <span class="comment">    processing a synchronous I/O requests, or Wait = FALSE if they are</span>
00063 <span class="comment">    processing an asynchronous request.</span>
00064 <span class="comment"></span>
00065 <span class="comment">    File system or Server Fsp threads should supply Wait = TRUE.</span>
00066 <span class="comment"></span>
00067 <span class="comment">Arguments:</span>
00068 <span class="comment"></span>
00069 <span class="comment">    FileObject - Pointer to the file object for a file which was</span>
00070 <span class="comment">                 opened with NO_INTERMEDIATE_BUFFERING clear, i.e., for</span>
00071 <span class="comment">                 which CcInitializeCacheMap was called by the file system.</span>
00072 <span class="comment"></span>
00073 <span class="comment">    FileOffset - Byte offset in file for desired data.</span>
00074 <span class="comment"></span>
00075 <span class="comment">    Length - Length of desired data in bytes.</span>
00076 <span class="comment"></span>
00077 <span class="comment">    Wait - FALSE if caller may not block, TRUE otherwise (see description</span>
00078 <span class="comment">           above)</span>
00079 <span class="comment"></span>
00080 <span class="comment">    Buffer - Pointer to output buffer to which data should be copied.</span>
00081 <span class="comment"></span>
00082 <span class="comment">    IoStatus - Pointer to standard I/O status block to receive the status</span>
00083 <span class="comment">               for the transfer.  (STATUS_SUCCESS guaranteed for cache</span>
00084 <span class="comment">               hits, otherwise the actual I/O status is returned.)</span>
00085 <span class="comment"></span>
00086 <span class="comment">               Note that even if FALSE is returned, the IoStatus.Information</span>
00087 <span class="comment">               field will return the count of any bytes successfully</span>
00088 <span class="comment">               transferred before a blocking condition occured.  The caller</span>
00089 <span class="comment">               may either choose to ignore this information, or resume</span>
00090 <span class="comment">               the copy later accounting for bytes transferred.</span>
00091 <span class="comment"></span>
00092 <span class="comment">Return Value:</span>
00093 <span class="comment"></span>
00094 <span class="comment">    FALSE - if Wait was supplied as FALSE and the data was not delivered</span>
00095 <span class="comment"></span>
00096 <span class="comment">    TRUE - if the data is being delivered</span>
00097 <span class="comment"></span>
00098 <span class="comment">--*/</span>
00099 
00100 {
00101     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap;
00102     <a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html">PPRIVATE_CACHE_MAP</a> PrivateCacheMap;
00103     PVOID CacheBuffer;
00104     LARGE_INTEGER FOffset;
00105     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> Vacb;
00106     <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> Bcb;
00107     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> ActiveVacb;
00108     ULONG ActivePage;
00109     ULONG PageIsDirty;
00110     ULONG SavedState;
00111     ULONG PagesToGo;
00112     ULONG MoveLength;
00113     ULONG LengthToGo;
00114     KIRQL OldIrql;
00115     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00116     ULONG OriginalLength = Length;
00117     ULONG PageCount = <a class="code" href="../../d2/d1/mm_8h.html#a9">COMPUTE_PAGES_SPANNED</a>((ULongToPtr(FileOffset-&gt;LowPart)), Length);
00118     <a class="code" href="../../d5/d6/struct__ETHREAD.html">PETHREAD</a> Thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
00119     ULONG GotAMiss = 0;
00120 
00121     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcCopyRead\n"</span>, 0 );
00122 
00123     <a class="code" href="../../d2/d1/mm_8h.html#a19">MmSavePageFaultReadAhead</a>( Thread, &amp;SavedState );
00124 
00125     <span class="comment">//</span>
00126     <span class="comment">//  Get pointer to shared and private cache maps</span>
00127     <span class="comment">//</span>
00128 
00129     SharedCacheMap = FileObject-&gt;SectionObjectPointer-&gt;SharedCacheMap;
00130     PrivateCacheMap = FileObject-&gt;PrivateCacheMap;
00131 
00132     <span class="comment">//</span>
00133     <span class="comment">//  Check for read past file size, the caller must filter this case out.</span>
00134     <span class="comment">//</span>
00135 
00136     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( ( FileOffset-&gt;QuadPart + (LONGLONG)Length) &lt;= SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o3">FileSize</a>.QuadPart );
00137 
00138     <span class="comment">//</span>
00139     <span class="comment">//  If read ahead is enabled, then do the read ahead here so it</span>
00140     <span class="comment">//  overlaps with the copy (otherwise we will do it below).</span>
00141     <span class="comment">//  Note that we are assuming that we will not get ahead of our</span>
00142     <span class="comment">//  current transfer - if read ahead is working it should either</span>
00143     <span class="comment">//  already be in memory or else underway.</span>
00144     <span class="comment">//</span>
00145 
00146     <span class="keywordflow">if</span> (PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o13">ReadAheadEnabled</a> &amp;&amp; (PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o8">ReadAheadLength</a>[1] == 0)) {
00147         <a class="code" href="../../d4/d2/cache_8h.html#a84">CcScheduleReadAhead</a>( FileObject, FileOffset, Length );
00148     }
00149 
00150     FOffset = *FileOffset;
00151 
00152     <span class="comment">//</span>
00153     <span class="comment">//  Increment performance counters</span>
00154     <span class="comment">//</span>
00155 
00156     <span class="keywordflow">if</span> (Wait) {
00157         <a class="code" href="../../d0/d9/ntosdef_8h.html#a11">HOT_STATISTIC</a>(<a class="code" href="../../d5/d2/cachedat_8c.html#a62">CcCopyReadWait</a>) += 1;
00158 
00159         <span class="comment">//</span>
00160         <span class="comment">//  This is not an exact solution, but when IoPageRead gets a miss,</span>
00161         <span class="comment">//  it cannot tell whether it was CcCopyRead or CcMdlRead, but since</span>
00162         <span class="comment">//  the miss should occur very soon, by loading the pointer here</span>
00163         <span class="comment">//  probably the right counter will get incremented, and in any case,</span>
00164         <span class="comment">//  we hope the errrors average out!</span>
00165         <span class="comment">//</span>
00166 
00167         <a class="code" href="../../d5/d2/cachedat_8c.html#a75">CcMissCounter</a> = &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a64">CcCopyReadWaitMiss</a>;
00168 
00169     } <span class="keywordflow">else</span> {
00170         <a class="code" href="../../d0/d9/ntosdef_8h.html#a11">HOT_STATISTIC</a>(<a class="code" href="../../d5/d2/cachedat_8c.html#a61">CcCopyReadNoWait</a>) += 1;
00171     }
00172 
00173     <span class="comment">//</span>
00174     <span class="comment">//  See if we have an active Vacb, that we can just copy to.</span>
00175     <span class="comment">//</span>
00176 
00177     <a class="code" href="../../d5/d5/cc_8h.html#a82">GetActiveVacb</a>( SharedCacheMap, OldIrql, ActiveVacb, ActivePage, PageIsDirty );
00178 
00179     <span class="keywordflow">if</span> (ActiveVacb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00180 
00181         <span class="keywordflow">if</span> ((ULONG)(FOffset.QuadPart &gt;&gt; <a class="code" href="../../d4/d2/cache_8h.html#a1">VACB_OFFSET_SHIFT</a>) == (ActivePage &gt;&gt; (<a class="code" href="../../d4/d2/cache_8h.html#a1">VACB_OFFSET_SHIFT</a> - <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>))) {
00182 
00183             ULONG LengthToCopy = <a class="code" href="../../d4/d2/cache_8h.html#a0">VACB_MAPPING_GRANULARITY</a> - (FOffset.LowPart &amp; (<a class="code" href="../../d4/d2/cache_8h.html#a0">VACB_MAPPING_GRANULARITY</a> - 1));
00184 
00185             <span class="keywordflow">if</span> (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o13">NeedToZero</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00186                 <a class="code" href="../../d5/d5/cc_8h.html#a182">CcFreeActiveVacb</a>( SharedCacheMap, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, 0, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00187             }
00188 
00189             <span class="comment">//</span>
00190             <span class="comment">//  Get the starting point in the view.</span>
00191             <span class="comment">//</span>
00192 
00193             CacheBuffer = (PVOID)((PCHAR)ActiveVacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o0">BaseAddress</a> +
00194                                           (FOffset.LowPart &amp; (<a class="code" href="../../d4/d2/cache_8h.html#a0">VACB_MAPPING_GRANULARITY</a> - 1)));
00195 
00196             <span class="comment">//</span>
00197             <span class="comment">//  Reduce LengthToCopy if it is greater than our caller's length.</span>
00198             <span class="comment">//</span>
00199 
00200             <span class="keywordflow">if</span> (LengthToCopy &gt; Length) {
00201                 LengthToCopy = Length;
00202             }
00203 
00204             <span class="comment">//</span>
00205             <span class="comment">//  Like the logic for the normal case below, we want to spin around</span>
00206             <span class="comment">//  making sure Mm only reads the pages we will need.</span>
00207             <span class="comment">//</span>
00208             
00209             PagesToGo = <a class="code" href="../../d2/d1/mm_8h.html#a9">COMPUTE_PAGES_SPANNED</a>( CacheBuffer,
00210                                                LengthToCopy ) - 1;
00211 
00212             <span class="comment">//</span>
00213             <span class="comment">//  Copy the data to the user buffer.</span>
00214             <span class="comment">//</span>
00215 
00216             <span class="keywordflow">try</span> {
00217 
00218                 <span class="keywordflow">if</span> (PagesToGo != 0) {
00219     
00220                     LengthToGo = LengthToCopy;
00221     
00222                     <span class="keywordflow">while</span> (LengthToGo != 0) {
00223     
00224                         MoveLength = (ULONG)((PCHAR)(<a class="code" href="../../d2/d1/mm_8h.html#a4">ROUND_TO_PAGES</a>(((PCHAR)CacheBuffer + 1))) -
00225                                      (PCHAR)CacheBuffer);
00226     
00227                         <span class="keywordflow">if</span> (MoveLength &gt; LengthToGo) {
00228                             MoveLength = LengthToGo;
00229                         }
00230     
00231                         <span class="comment">//</span>
00232                         <span class="comment">//  Here's hoping that it is cheaper to call Mm to see if</span>
00233                         <span class="comment">//  the page is valid.  If not let Mm know how many pages</span>
00234                         <span class="comment">//  we are after before doing the move.</span>
00235                         <span class="comment">//</span>
00236     
00237                         <a class="code" href="../../d2/d1/mm_8h.html#a20">MmSetPageFaultReadAhead</a>( Thread, PagesToGo );
00238                         GotAMiss |= !<a class="code" href="../../d1/d5/mapcache_8c.html#a13">MmCheckCachedPageState</a>( CacheBuffer, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00239     
00240                         RtlCopyBytes( <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>, CacheBuffer, MoveLength );
00241     
00242                         PagesToGo -= 1;
00243     
00244                         LengthToGo -= MoveLength;
00245                         <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> = (PCHAR)<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> + MoveLength;
00246                         CacheBuffer = (PCHAR)CacheBuffer + MoveLength;
00247                     }
00248     
00249                 <span class="comment">//</span>
00250                 <span class="comment">//  Handle the read here that stays on a single page.</span>
00251                 <span class="comment">//</span>
00252     
00253                 } <span class="keywordflow">else</span> {
00254     
00255                     <span class="comment">//</span>
00256                     <span class="comment">//  Here's hoping that it is cheaper to call Mm to see if</span>
00257                     <span class="comment">//  the page is valid.  If not let Mm know how many pages</span>
00258                     <span class="comment">//  we are after before doing the move.</span>
00259                     <span class="comment">//</span>
00260     
00261                     <a class="code" href="../../d2/d1/mm_8h.html#a20">MmSetPageFaultReadAhead</a>( Thread, 0 );
00262                     GotAMiss |= !<a class="code" href="../../d1/d5/mapcache_8c.html#a13">MmCheckCachedPageState</a>( CacheBuffer, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00263     
00264                     RtlCopyBytes( <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>, CacheBuffer, LengthToCopy );
00265     
00266                     <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> = (PCHAR)<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> + LengthToCopy;
00267                 }
00268                 
00269             } except( <a class="code" href="../../d5/d7/copysup_8c.html#a5">CcCopyReadExceptionFilter</a>( GetExceptionInformation(),
00270                                                  &amp;<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> ) ) {
00271 
00272                 <a class="code" href="../../d2/d1/mm_8h.html#a21">MmResetPageFaultReadAhead</a>( Thread, SavedState );
00273 
00274                 <a class="code" href="../../d5/d5/cc_8h.html#a84">SetActiveVacb</a>( SharedCacheMap, OldIrql, ActiveVacb, ActivePage, PageIsDirty );
00275 
00276                 <span class="comment">//</span>
00277                 <span class="comment">//  If we got an access violation, then the user buffer went</span>
00278                 <span class="comment">//  away.  Otherwise we must have gotten an I/O error trying</span>
00279                 <span class="comment">//  to bring the data in.</span>
00280                 <span class="comment">//</span>
00281 
00282                 <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_ACCESS_VIOLATION) {
00283                     <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INVALID_USER_BUFFER );
00284                 }
00285                 <span class="keywordflow">else</span> {
00286                     <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( <a class="code" href="../../d1/d8/fsrtl_8h.html#a136">FsRtlNormalizeNtstatus</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>,
00287                                                            STATUS_UNEXPECTED_IO_ERROR ));
00288                 }
00289             }
00290 
00291             <span class="comment">//</span>
00292             <span class="comment">//  Now adjust FOffset and Length by what we copied.</span>
00293             <span class="comment">//</span>
00294 
00295             FOffset.QuadPart = FOffset.QuadPart + (LONGLONG)LengthToCopy;
00296             Length -= LengthToCopy;
00297 
00298         }
00299 
00300         <span class="comment">//</span>
00301         <span class="comment">//  If that was all the data, then remember the Vacb</span>
00302         <span class="comment">//</span>
00303 
00304         <span class="keywordflow">if</span> (Length == 0) {
00305 
00306             <a class="code" href="../../d5/d5/cc_8h.html#a84">SetActiveVacb</a>( SharedCacheMap, OldIrql, ActiveVacb, ActivePage, PageIsDirty );
00307 
00308         <span class="comment">//</span>
00309         <span class="comment">//  Otherwise we must free it because we will map other vacbs below.</span>
00310         <span class="comment">//</span>
00311 
00312         } <span class="keywordflow">else</span> {
00313 
00314             <a class="code" href="../../d5/d5/cc_8h.html#a182">CcFreeActiveVacb</a>( SharedCacheMap, ActiveVacb, ActivePage, PageIsDirty );
00315         }
00316     }
00317 
00318     <span class="comment">//</span>
00319     <span class="comment">//  Not all of the transfer will come back at once, so we have to loop</span>
00320     <span class="comment">//  until the entire transfer is complete.</span>
00321     <span class="comment">//</span>
00322 
00323     <span class="keywordflow">while</span> (Length != 0) {
00324 
00325         ULONG ReceivedLength;
00326         LARGE_INTEGER BeyondLastByte;
00327 
00328         <span class="comment">//</span>
00329         <span class="comment">//  Call local routine to Map or Access the file data, then move the data,</span>
00330         <span class="comment">//  then call another local routine to free the data.  If we cannot map</span>
00331         <span class="comment">//  the data because of a Wait condition, return FALSE.</span>
00332         <span class="comment">//</span>
00333         <span class="comment">//  Note that this call may result in an exception, however, if it</span>
00334         <span class="comment">//  does no Bcb is returned and this routine has absolutely no</span>
00335         <span class="comment">//  cleanup to perform.  Therefore, we do not have a try-finally</span>
00336         <span class="comment">//  and we allow the possibility that we will simply be unwound</span>
00337         <span class="comment">//  without notice.</span>
00338         <span class="comment">//</span>
00339 
00340         <span class="keywordflow">if</span> (Wait) {
00341 
00342             CacheBuffer = <a class="code" href="../../d5/d3/vacbsup_8c.html#a15">CcGetVirtualAddress</a>( SharedCacheMap,
00343                                                FOffset,
00344                                                &amp;Vacb,
00345                                                &amp;ReceivedLength );
00346 
00347             BeyondLastByte.QuadPart = FOffset.QuadPart + (LONGLONG)ReceivedLength;
00348 
00349         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/cc_8h.html#a175">CcPinFileData</a>( FileObject,
00350                                    &amp;FOffset,
00351                                    Length,
00352                                    <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
00353                                    <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00354                                    <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00355                                    &amp;Bcb,
00356                                    &amp;CacheBuffer,
00357                                    &amp;BeyondLastByte )) {
00358 
00359             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcCopyRead -&gt; FALSE\n"</span>, 0 );
00360 
00361             <a class="code" href="../../d0/d9/ntosdef_8h.html#a11">HOT_STATISTIC</a>(<a class="code" href="../../d5/d2/cachedat_8c.html#a63">CcCopyReadNoWaitMiss</a>) += 1;
00362 
00363             <span class="comment">//</span>
00364             <span class="comment">//  Enable ReadAhead if we missed.</span>
00365             <span class="comment">//</span>
00366 
00367             PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o13">ReadAheadEnabled</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00368 
00369             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00370 
00371         } <span class="keywordflow">else</span> {
00372 
00373             <span class="comment">//</span>
00374             <span class="comment">//  Calculate how much data is described by Bcb starting at our desired</span>
00375             <span class="comment">//  file offset.</span>
00376             <span class="comment">//</span>
00377 
00378             ReceivedLength = (ULONG)(BeyondLastByte.QuadPart - FOffset.QuadPart);
00379         }
00380 
00381         <span class="comment">//</span>
00382         <span class="comment">//  If we got more than we need, make sure to only transfer</span>
00383         <span class="comment">//  the right amount.</span>
00384         <span class="comment">//</span>
00385 
00386         <span class="keywordflow">if</span> (ReceivedLength &gt; Length) {
00387             ReceivedLength = Length;
00388         }
00389 
00390         <span class="comment">//</span>
00391         <span class="comment">//  It is possible for the user buffer to become no longer accessible</span>
00392         <span class="comment">//  since it was last checked by the I/O system.  If we fail to access</span>
00393         <span class="comment">//  the buffer we must raise a status that the caller's exception</span>
00394         <span class="comment">//  filter considers as "expected".  Also we unmap the Bcb here, since</span>
00395         <span class="comment">//  we otherwise would have no other reason to put a try-finally around</span>
00396         <span class="comment">//  this loop.</span>
00397         <span class="comment">//</span>
00398 
00399         <span class="keywordflow">try</span> {
00400 
00401             PagesToGo = <a class="code" href="../../d2/d1/mm_8h.html#a9">COMPUTE_PAGES_SPANNED</a>( CacheBuffer,
00402                                                ReceivedLength ) - 1;
00403 
00404             <span class="comment">//</span>
00405             <span class="comment">//  We know exactly how much we want to read here, and we do not</span>
00406             <span class="comment">//  want to read any more in case the caller is doing random access.</span>
00407             <span class="comment">//  Our read ahead logic takes care of detecting sequential reads,</span>
00408             <span class="comment">//  and tends to do large asynchronous read aheads.  So far we have</span>
00409             <span class="comment">//  only mapped the data and we have not forced any in.  What we</span>
00410             <span class="comment">//  do now is get into a loop where we copy a page at a time and</span>
00411             <span class="comment">//  just prior to each move, we tell MM how many additional pages</span>
00412             <span class="comment">//  we would like to have read in, in the event that we take a</span>
00413             <span class="comment">//  fault.  With this strategy, for cache hits we never make a single</span>
00414             <span class="comment">//  expensive call to MM to guarantee that the data is in, yet if we</span>
00415             <span class="comment">//  do take a fault, we are guaranteed to only take one fault because</span>
00416             <span class="comment">//  we will read all of the data in for the rest of the transfer.</span>
00417             <span class="comment">//</span>
00418             <span class="comment">//  We test first for the multiple page case, to keep the small</span>
00419             <span class="comment">//  reads faster.</span>
00420             <span class="comment">//</span>
00421 
00422             <span class="keywordflow">if</span> (PagesToGo != 0) {
00423 
00424                 LengthToGo = ReceivedLength;
00425 
00426                 <span class="keywordflow">while</span> (LengthToGo != 0) {
00427 
00428                     MoveLength = (ULONG)((PCHAR)(<a class="code" href="../../d2/d1/mm_8h.html#a4">ROUND_TO_PAGES</a>(((PCHAR)CacheBuffer + 1))) -
00429                                  (PCHAR)CacheBuffer);
00430 
00431                     <span class="keywordflow">if</span> (MoveLength &gt; LengthToGo) {
00432                         MoveLength = LengthToGo;
00433                     }
00434 
00435                     <span class="comment">//</span>
00436                     <span class="comment">//  Here's hoping that it is cheaper to call Mm to see if</span>
00437                     <span class="comment">//  the page is valid.  If not let Mm know how many pages</span>
00438                     <span class="comment">//  we are after before doing the move.</span>
00439                     <span class="comment">//</span>
00440 
00441                     <a class="code" href="../../d2/d1/mm_8h.html#a20">MmSetPageFaultReadAhead</a>( Thread, PagesToGo );
00442                     GotAMiss |= !<a class="code" href="../../d1/d5/mapcache_8c.html#a13">MmCheckCachedPageState</a>( CacheBuffer, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00443 
00444                     RtlCopyBytes( <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>, CacheBuffer, MoveLength );
00445 
00446                     PagesToGo -= 1;
00447 
00448                     LengthToGo -= MoveLength;
00449                     <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> = (PCHAR)<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> + MoveLength;
00450                     CacheBuffer = (PCHAR)CacheBuffer + MoveLength;
00451                 }
00452 
00453             <span class="comment">//</span>
00454             <span class="comment">//  Handle the read here that stays on a single page.</span>
00455             <span class="comment">//</span>
00456 
00457             } <span class="keywordflow">else</span> {
00458 
00459                 <span class="comment">//</span>
00460                 <span class="comment">//  Here's hoping that it is cheaper to call Mm to see if</span>
00461                 <span class="comment">//  the page is valid.  If not let Mm know how many pages</span>
00462                 <span class="comment">//  we are after before doing the move.</span>
00463                 <span class="comment">//</span>
00464 
00465                 <a class="code" href="../../d2/d1/mm_8h.html#a20">MmSetPageFaultReadAhead</a>( Thread, 0 );
00466                 GotAMiss |= !<a class="code" href="../../d1/d5/mapcache_8c.html#a13">MmCheckCachedPageState</a>( CacheBuffer, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00467 
00468                 RtlCopyBytes( <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>, CacheBuffer, ReceivedLength );
00469 
00470                 <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> = (PCHAR)<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> + ReceivedLength;
00471             }
00472 
00473         }
00474         except( <a class="code" href="../../d5/d7/copysup_8c.html#a5">CcCopyReadExceptionFilter</a>( GetExceptionInformation(),
00475                                            &amp;<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> ) ) {
00476 
00477             <a class="code" href="../../d5/d2/cachedat_8c.html#a75">CcMissCounter</a> = &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a43">CcThrowAway</a>;
00478 
00479             <span class="comment">//</span>
00480             <span class="comment">//  If we get an exception, then we have to renable page fault</span>
00481             <span class="comment">//  clustering and unmap on the way out.</span>
00482             <span class="comment">//</span>
00483 
00484             <a class="code" href="../../d2/d1/mm_8h.html#a21">MmResetPageFaultReadAhead</a>( Thread, SavedState );
00485 
00486 
00487             <span class="keywordflow">if</span> (Wait) {
00488                 <a class="code" href="../../d5/d3/vacbsup_8c.html#a16">CcFreeVirtualAddress</a>( Vacb );
00489             } <span class="keywordflow">else</span> {
00490                 <a class="code" href="../../d5/d5/cc_8h.html#a176">CcUnpinFileData</a>( Bcb, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, <a class="code" href="../../d5/d5/cc_8h.html#a211a171">UNPIN</a> );
00491             }
00492 
00493             <span class="comment">//</span>
00494             <span class="comment">//  If we got an access violation, then the user buffer went</span>
00495             <span class="comment">//  away.  Otherwise we must have gotten an I/O error trying</span>
00496             <span class="comment">//  to bring the data in.</span>
00497             <span class="comment">//</span>
00498 
00499             <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_ACCESS_VIOLATION) {
00500                 <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INVALID_USER_BUFFER );
00501             }
00502             <span class="keywordflow">else</span> {
00503                 <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( <a class="code" href="../../d1/d8/fsrtl_8h.html#a136">FsRtlNormalizeNtstatus</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>,
00504                                                        STATUS_UNEXPECTED_IO_ERROR ));
00505             }
00506         }
00507 
00508         <span class="comment">//</span>
00509         <span class="comment">//  Update number of bytes transferred.</span>
00510         <span class="comment">//</span>
00511 
00512         Length -= ReceivedLength;
00513 
00514         <span class="comment">//</span>
00515         <span class="comment">//  Unmap the data now, and calculate length left to transfer.</span>
00516         <span class="comment">//</span>
00517 
00518         <span class="keywordflow">if</span> (Wait) {
00519 
00520             <span class="comment">//</span>
00521             <span class="comment">//  If there is more to go, just free this vacb.</span>
00522             <span class="comment">//</span>
00523 
00524             <span class="keywordflow">if</span> (Length != 0) {
00525 
00526                 <a class="code" href="../../d5/d3/vacbsup_8c.html#a16">CcFreeVirtualAddress</a>( Vacb );
00527 
00528             <span class="comment">//</span>
00529             <span class="comment">//  Otherwise save it for the next time through.</span>
00530             <span class="comment">//</span>
00531 
00532             } <span class="keywordflow">else</span> {
00533 
00534                 <a class="code" href="../../d5/d5/cc_8h.html#a84">SetActiveVacb</a>( SharedCacheMap, OldIrql, Vacb, (ULONG)(FOffset.QuadPart &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>), 0 );
00535                 <span class="keywordflow">break</span>;
00536             }
00537 
00538         } <span class="keywordflow">else</span> {
00539             <a class="code" href="../../d5/d5/cc_8h.html#a176">CcUnpinFileData</a>( Bcb, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, <a class="code" href="../../d5/d5/cc_8h.html#a211a171">UNPIN</a> );
00540         }
00541 
00542         <span class="comment">//</span>
00543         <span class="comment">//  Assume we did not get all the data we wanted, and set FOffset</span>
00544         <span class="comment">//  to the end of the returned data.</span>
00545         <span class="comment">//</span>
00546 
00547         FOffset = BeyondLastByte;
00548     }
00549 
00550     <a class="code" href="../../d2/d1/mm_8h.html#a21">MmResetPageFaultReadAhead</a>( Thread, SavedState );
00551 
00552     <a class="code" href="../../d5/d2/cachedat_8c.html#a75">CcMissCounter</a> = &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a43">CcThrowAway</a>;
00553 
00554     <span class="comment">//</span>
00555     <span class="comment">//  Now enable read ahead if it looks like we got any misses, and do</span>
00556     <span class="comment">//  the first one.</span>
00557     <span class="comment">//</span>
00558 
00559     <span class="keywordflow">if</span> (GotAMiss &amp;&amp;
00560         !<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( FileObject-&gt;Flags, <a class="code" href="../../d0/d5/io_8h.html#a170">FO_RANDOM_ACCESS</a> ) &amp;&amp;
00561         !PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o13">ReadAheadEnabled</a>) {
00562 
00563         PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o13">ReadAheadEnabled</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00564         <a class="code" href="../../d4/d2/cache_8h.html#a84">CcScheduleReadAhead</a>( FileObject, FileOffset, OriginalLength );
00565     }
00566 
00567     <span class="comment">//</span>
00568     <span class="comment">//  Now that we have described our desired read ahead, let's</span>
00569     <span class="comment">//  shift the read history down.</span>
00570     <span class="comment">//</span>
00571 
00572     PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o3">FileOffset1</a> = PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o5">FileOffset2</a>;
00573     PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o4">BeyondLastByte1</a> = PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o6">BeyondLastByte2</a>;
00574     PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o5">FileOffset2</a> = *FileOffset;
00575     PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o6">BeyondLastByte2</a>.QuadPart =
00576                                 FileOffset-&gt;QuadPart + (LONGLONG)OriginalLength;
00577 
00578     IoStatus-&gt;Status = STATUS_SUCCESS;
00579     IoStatus-&gt;Information = OriginalLength;
00580 
00581     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcCopyRead -&gt; TRUE\n"</span>, 0 );
00582 
00583     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00584 }
00585 
00586 
00587 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00588"></a><a class="code" href="../../d4/d2/cache_8h.html#a75">00588</a> <a class="code" href="../../d4/d2/cache_8h.html#a75">CcFastCopyRead</a> (
00589     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
00590     IN ULONG FileOffset,
00591     IN ULONG Length,
00592     IN ULONG PageCount,
00593     OUT PVOID Buffer,
00594     OUT PIO_STATUS_BLOCK IoStatus
00595     )
00596 
00597 <span class="comment">/*++</span>
00598 <span class="comment"></span>
00599 <span class="comment">Routine Description:</span>
00600 <span class="comment"></span>
00601 <span class="comment">    This routine attempts to copy the specified file data from the cache</span>
00602 <span class="comment">    into the output buffer, and deliver the correct I/O status.</span>
00603 <span class="comment"></span>
00604 <span class="comment">    This is a faster version of CcCopyRead which only supports 32-bit file</span>
00605 <span class="comment">    offsets and synchronicity (Wait = TRUE).</span>
00606 <span class="comment"></span>
00607 <span class="comment">Arguments:</span>
00608 <span class="comment"></span>
00609 <span class="comment">    FileObject - Pointer to the file object for a file which was</span>
00610 <span class="comment">                 opened with NO_INTERMEDIATE_BUFFERING clear, i.e., for</span>
00611 <span class="comment">                 which CcInitializeCacheMap was called by the file system.</span>
00612 <span class="comment"></span>
00613 <span class="comment">    FileOffset - Byte offset in file for desired data.</span>
00614 <span class="comment"></span>
00615 <span class="comment">    Length - Length of desired data in bytes.</span>
00616 <span class="comment"></span>
00617 <span class="comment">    PageCount - Number of pages spanned by the read.</span>
00618 <span class="comment"></span>
00619 <span class="comment">    Buffer - Pointer to output buffer to which data should be copied.</span>
00620 <span class="comment"></span>
00621 <span class="comment">    IoStatus - Pointer to standard I/O status block to receive the status</span>
00622 <span class="comment">               for the transfer.  (STATUS_SUCCESS guaranteed for cache</span>
00623 <span class="comment">               hits, otherwise the actual I/O status is returned.)</span>
00624 <span class="comment"></span>
00625 <span class="comment">               Note that even if FALSE is returned, the IoStatus.Information</span>
00626 <span class="comment">               field will return the count of any bytes successfully</span>
00627 <span class="comment">               transferred before a blocking condition occured.  The caller</span>
00628 <span class="comment">               may either choose to ignore this information, or resume</span>
00629 <span class="comment">               the copy later accounting for bytes transferred.</span>
00630 <span class="comment"></span>
00631 <span class="comment">Return Value:</span>
00632 <span class="comment"></span>
00633 <span class="comment">    None</span>
00634 <span class="comment"></span>
00635 <span class="comment">--*/</span>
00636 
00637 {
00638     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap;
00639     <a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html">PPRIVATE_CACHE_MAP</a> PrivateCacheMap;
00640     PVOID CacheBuffer;
00641     LARGE_INTEGER FOffset;
00642     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> Vacb;
00643     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> ActiveVacb;
00644     ULONG ActivePage;
00645     ULONG PageIsDirty;
00646     ULONG SavedState;
00647     ULONG PagesToGo;
00648     ULONG MoveLength;
00649     ULONG LengthToGo;
00650     KIRQL OldIrql;
00651     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00652     LARGE_INTEGER OriginalOffset;
00653     ULONG OriginalLength = Length;
00654     <a class="code" href="../../d5/d6/struct__ETHREAD.html">PETHREAD</a> Thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
00655     ULONG GotAMiss = 0;
00656 
00657     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcFastCopyRead\n"</span>, 0 );
00658 
00659     <a class="code" href="../../d2/d1/mm_8h.html#a19">MmSavePageFaultReadAhead</a>( Thread, &amp;SavedState );
00660 
00661     <span class="comment">//</span>
00662     <span class="comment">//  Get pointer to shared and private cache maps</span>
00663     <span class="comment">//</span>
00664 
00665     SharedCacheMap = FileObject-&gt;SectionObjectPointer-&gt;SharedCacheMap;
00666     PrivateCacheMap = FileObject-&gt;PrivateCacheMap;
00667 
00668     <span class="comment">//</span>
00669     <span class="comment">//  Check for read past file size, the caller must filter this case out.</span>
00670     <span class="comment">//</span>
00671 
00672     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( (FileOffset + Length) &lt;= SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o3">FileSize</a>.LowPart );
00673 
00674     <span class="comment">//</span>
00675     <span class="comment">//  If read ahead is enabled, then do the read ahead here so it</span>
00676     <span class="comment">//  overlaps with the copy (otherwise we will do it below).</span>
00677     <span class="comment">//  Note that we are assuming that we will not get ahead of our</span>
00678     <span class="comment">//  current transfer - if read ahead is working it should either</span>
00679     <span class="comment">//  already be in memory or else underway.</span>
00680     <span class="comment">//</span>
00681 
00682     OriginalOffset.LowPart = FileOffset;
00683     OriginalOffset.HighPart = 0;
00684 
00685     <span class="keywordflow">if</span> (PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o13">ReadAheadEnabled</a> &amp;&amp; (PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o8">ReadAheadLength</a>[1] == 0)) {
00686         <a class="code" href="../../d4/d2/cache_8h.html#a84">CcScheduleReadAhead</a>( FileObject, &amp;OriginalOffset, Length );
00687     }
00688 
00689     <span class="comment">//</span>
00690     <span class="comment">//  This is not an exact solution, but when IoPageRead gets a miss,</span>
00691     <span class="comment">//  it cannot tell whether it was CcCopyRead or CcMdlRead, but since</span>
00692     <span class="comment">//  the miss should occur very soon, by loading the pointer here</span>
00693     <span class="comment">//  probably the right counter will get incremented, and in any case,</span>
00694     <span class="comment">//  we hope the errrors average out!</span>
00695     <span class="comment">//</span>
00696 
00697     <a class="code" href="../../d5/d2/cachedat_8c.html#a75">CcMissCounter</a> = &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a64">CcCopyReadWaitMiss</a>;
00698 
00699     <span class="comment">//</span>
00700     <span class="comment">//  Increment performance counters</span>
00701     <span class="comment">//</span>
00702 
00703     <a class="code" href="../../d0/d9/ntosdef_8h.html#a11">HOT_STATISTIC</a>(<a class="code" href="../../d5/d2/cachedat_8c.html#a62">CcCopyReadWait</a>) += 1;
00704 
00705     <span class="comment">//</span>
00706     <span class="comment">//  See if we have an active Vacb, that we can just copy to.</span>
00707     <span class="comment">//</span>
00708 
00709     <a class="code" href="../../d5/d5/cc_8h.html#a82">GetActiveVacb</a>( SharedCacheMap, OldIrql, ActiveVacb, ActivePage, PageIsDirty );
00710 
00711     <span class="keywordflow">if</span> (ActiveVacb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00712 
00713         <span class="keywordflow">if</span> ((FileOffset &gt;&gt; <a class="code" href="../../d4/d2/cache_8h.html#a1">VACB_OFFSET_SHIFT</a>) == (ActivePage &gt;&gt; (<a class="code" href="../../d4/d2/cache_8h.html#a1">VACB_OFFSET_SHIFT</a> - <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>))) {
00714 
00715             ULONG LengthToCopy = <a class="code" href="../../d4/d2/cache_8h.html#a0">VACB_MAPPING_GRANULARITY</a> - (FileOffset &amp; (<a class="code" href="../../d4/d2/cache_8h.html#a0">VACB_MAPPING_GRANULARITY</a> - 1));
00716 
00717             <span class="keywordflow">if</span> (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o13">NeedToZero</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00718                 <a class="code" href="../../d5/d5/cc_8h.html#a182">CcFreeActiveVacb</a>( SharedCacheMap, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, 0, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00719             }
00720 
00721             <span class="comment">//</span>
00722             <span class="comment">//  Get the starting point in the view.</span>
00723             <span class="comment">//</span>
00724 
00725             CacheBuffer = (PVOID)((PCHAR)ActiveVacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o0">BaseAddress</a> +
00726                                           (FileOffset &amp; (<a class="code" href="../../d4/d2/cache_8h.html#a0">VACB_MAPPING_GRANULARITY</a> - 1)));
00727 
00728             <span class="comment">//</span>
00729             <span class="comment">//  Reduce LengthToCopy if it is greater than our caller's length.</span>
00730             <span class="comment">//</span>
00731 
00732             <span class="keywordflow">if</span> (LengthToCopy &gt; Length) {
00733                 LengthToCopy = Length;
00734             }
00735 
00736             <span class="comment">//</span>
00737             <span class="comment">//  Like the logic for the normal case below, we want to spin around</span>
00738             <span class="comment">//  making sure Mm only reads the pages we will need.</span>
00739             <span class="comment">//</span>
00740             
00741             PagesToGo = <a class="code" href="../../d2/d1/mm_8h.html#a9">COMPUTE_PAGES_SPANNED</a>( CacheBuffer,
00742                                                LengthToCopy ) - 1;
00743 
00744             <span class="comment">//</span>
00745             <span class="comment">//  Copy the data to the user buffer.</span>
00746             <span class="comment">//</span>
00747 
00748             <span class="keywordflow">try</span> {
00749 
00750                 <span class="keywordflow">if</span> (PagesToGo != 0) {
00751     
00752                     LengthToGo = LengthToCopy;
00753     
00754                     <span class="keywordflow">while</span> (LengthToGo != 0) {
00755     
00756                         MoveLength = (ULONG)((PCHAR)(<a class="code" href="../../d2/d1/mm_8h.html#a4">ROUND_TO_PAGES</a>(((PCHAR)CacheBuffer + 1))) -
00757                                      (PCHAR)CacheBuffer);
00758     
00759                         <span class="keywordflow">if</span> (MoveLength &gt; LengthToGo) {
00760                             MoveLength = LengthToGo;
00761                         }
00762     
00763                         <span class="comment">//</span>
00764                         <span class="comment">//  Here's hoping that it is cheaper to call Mm to see if</span>
00765                         <span class="comment">//  the page is valid.  If not let Mm know how many pages</span>
00766                         <span class="comment">//  we are after before doing the move.</span>
00767                         <span class="comment">//</span>
00768     
00769                         <a class="code" href="../../d2/d1/mm_8h.html#a20">MmSetPageFaultReadAhead</a>( Thread, PagesToGo );
00770                         GotAMiss |= !<a class="code" href="../../d1/d5/mapcache_8c.html#a13">MmCheckCachedPageState</a>( CacheBuffer, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00771     
00772                         RtlCopyBytes( <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>, CacheBuffer, MoveLength );
00773     
00774                         PagesToGo -= 1;
00775     
00776                         LengthToGo -= MoveLength;
00777                         <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> = (PCHAR)<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> + MoveLength;
00778                         CacheBuffer = (PCHAR)CacheBuffer + MoveLength;
00779                     }
00780     
00781                 <span class="comment">//</span>
00782                 <span class="comment">//  Handle the read here that stays on a single page.</span>
00783                 <span class="comment">//</span>
00784     
00785                 } <span class="keywordflow">else</span> {
00786     
00787                     <span class="comment">//</span>
00788                     <span class="comment">//  Here's hoping that it is cheaper to call Mm to see if</span>
00789                     <span class="comment">//  the page is valid.  If not let Mm know how many pages</span>
00790                     <span class="comment">//  we are after before doing the move.</span>
00791                     <span class="comment">//</span>
00792     
00793                     <a class="code" href="../../d2/d1/mm_8h.html#a20">MmSetPageFaultReadAhead</a>( Thread, 0 );
00794                     GotAMiss |= !<a class="code" href="../../d1/d5/mapcache_8c.html#a13">MmCheckCachedPageState</a>( CacheBuffer, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00795     
00796                     RtlCopyBytes( <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>, CacheBuffer, LengthToCopy );
00797     
00798                     <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> = (PCHAR)<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> + LengthToCopy;
00799                 }
00800                 
00801             } except( <a class="code" href="../../d5/d7/copysup_8c.html#a5">CcCopyReadExceptionFilter</a>( GetExceptionInformation(),
00802                                                  &amp;<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> ) ) {
00803 
00804                 <a class="code" href="../../d2/d1/mm_8h.html#a21">MmResetPageFaultReadAhead</a>( Thread, SavedState );
00805 
00806 
00807                 <a class="code" href="../../d5/d5/cc_8h.html#a84">SetActiveVacb</a>( SharedCacheMap, OldIrql, ActiveVacb, ActivePage, PageIsDirty );
00808 
00809                 <span class="comment">//</span>
00810                 <span class="comment">//  If we got an access violation, then the user buffer went</span>
00811                 <span class="comment">//  away.  Otherwise we must have gotten an I/O error trying</span>
00812                 <span class="comment">//  to bring the data in.</span>
00813                 <span class="comment">//</span>
00814 
00815                 <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_ACCESS_VIOLATION) {
00816                     <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INVALID_USER_BUFFER );
00817                 }
00818                 <span class="keywordflow">else</span> {
00819                     <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( <a class="code" href="../../d1/d8/fsrtl_8h.html#a136">FsRtlNormalizeNtstatus</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>,
00820                                                            STATUS_UNEXPECTED_IO_ERROR ));
00821                 }
00822             }
00823 
00824             <span class="comment">//</span>
00825             <span class="comment">//  Now adjust FileOffset and Length by what we copied.</span>
00826             <span class="comment">//</span>
00827 
00828             FileOffset += LengthToCopy;
00829             Length -= LengthToCopy;
00830         }
00831 
00832         <span class="comment">//</span>
00833         <span class="comment">//  If that was all the data, then remember the Vacb</span>
00834         <span class="comment">//</span>
00835 
00836         <span class="keywordflow">if</span> (Length == 0) {
00837 
00838             <a class="code" href="../../d5/d5/cc_8h.html#a84">SetActiveVacb</a>( SharedCacheMap, OldIrql, ActiveVacb, ActivePage, PageIsDirty );
00839 
00840         <span class="comment">//</span>
00841         <span class="comment">//  Otherwise we must free it because we will map other vacbs below.</span>
00842         <span class="comment">//</span>
00843 
00844         } <span class="keywordflow">else</span> {
00845 
00846             <a class="code" href="../../d5/d5/cc_8h.html#a182">CcFreeActiveVacb</a>( SharedCacheMap, ActiveVacb, ActivePage, PageIsDirty );
00847         }
00848     }
00849 
00850     <span class="comment">//</span>
00851     <span class="comment">//  Not all of the transfer will come back at once, so we have to loop</span>
00852     <span class="comment">//  until the entire transfer is complete.</span>
00853     <span class="comment">//</span>
00854 
00855     FOffset.HighPart = 0;
00856     FOffset.LowPart = FileOffset;
00857 
00858     <span class="keywordflow">while</span> (Length != 0) {
00859 
00860         ULONG ReceivedLength;
00861         ULONG BeyondLastByte;
00862 
00863         <span class="comment">//</span>
00864         <span class="comment">//  Call local routine to Map or Access the file data, then move the data,</span>
00865         <span class="comment">//  then call another local routine to free the data.  If we cannot map</span>
00866         <span class="comment">//  the data because of a Wait condition, return FALSE.</span>
00867         <span class="comment">//</span>
00868         <span class="comment">//  Note that this call may result in an exception, however, if it</span>
00869         <span class="comment">//  does no Bcb is returned and this routine has absolutely no</span>
00870         <span class="comment">//  cleanup to perform.  Therefore, we do not have a try-finally</span>
00871         <span class="comment">//  and we allow the possibility that we will simply be unwound</span>
00872         <span class="comment">//  without notice.</span>
00873         <span class="comment">//</span>
00874 
00875         CacheBuffer = <a class="code" href="../../d5/d3/vacbsup_8c.html#a15">CcGetVirtualAddress</a>( SharedCacheMap,
00876                                            FOffset,
00877                                            &amp;Vacb,
00878                                            &amp;ReceivedLength );
00879 
00880         BeyondLastByte = FOffset.LowPart + ReceivedLength;
00881 
00882         <span class="comment">//</span>
00883         <span class="comment">//  If we got more than we need, make sure to only transfer</span>
00884         <span class="comment">//  the right amount.</span>
00885         <span class="comment">//</span>
00886 
00887         <span class="keywordflow">if</span> (ReceivedLength &gt; Length) {
00888             ReceivedLength = Length;
00889         }
00890 
00891         <span class="comment">//</span>
00892         <span class="comment">//  It is possible for the user buffer to become no longer accessible</span>
00893         <span class="comment">//  since it was last checked by the I/O system.  If we fail to access</span>
00894         <span class="comment">//  the buffer we must raise a status that the caller's exception</span>
00895         <span class="comment">//  filter considers as "expected".  Also we unmap the Bcb here, since</span>
00896         <span class="comment">//  we otherwise would have no other reason to put a try-finally around</span>
00897         <span class="comment">//  this loop.</span>
00898         <span class="comment">//</span>
00899 
00900         <span class="keywordflow">try</span> {
00901 
00902             PagesToGo = <a class="code" href="../../d2/d1/mm_8h.html#a9">COMPUTE_PAGES_SPANNED</a>( CacheBuffer,
00903                                                ReceivedLength ) - 1;
00904 
00905             <span class="comment">//</span>
00906             <span class="comment">//  We know exactly how much we want to read here, and we do not</span>
00907             <span class="comment">//  want to read any more in case the caller is doing random access.</span>
00908             <span class="comment">//  Our read ahead logic takes care of detecting sequential reads,</span>
00909             <span class="comment">//  and tends to do large asynchronous read aheads.  So far we have</span>
00910             <span class="comment">//  only mapped the data and we have not forced any in.  What we</span>
00911             <span class="comment">//  do now is get into a loop where we copy a page at a time and</span>
00912             <span class="comment">//  just prior to each move, we tell MM how many additional pages</span>
00913             <span class="comment">//  we would like to have read in, in the event that we take a</span>
00914             <span class="comment">//  fault.  With this strategy, for cache hits we never make a single</span>
00915             <span class="comment">//  expensive call to MM to guarantee that the data is in, yet if we</span>
00916             <span class="comment">//  do take a fault, we are guaranteed to only take one fault because</span>
00917             <span class="comment">//  we will read all of the data in for the rest of the transfer.</span>
00918             <span class="comment">//</span>
00919             <span class="comment">//  We test first for the multiple page case, to keep the small</span>
00920             <span class="comment">//  reads faster.</span>
00921             <span class="comment">//</span>
00922 
00923             <span class="keywordflow">if</span> (PagesToGo != 0) {
00924 
00925                 LengthToGo = ReceivedLength;
00926 
00927                 <span class="keywordflow">while</span> (LengthToGo != 0) {
00928 
00929                     MoveLength = (ULONG)((PCHAR)(<a class="code" href="../../d2/d1/mm_8h.html#a4">ROUND_TO_PAGES</a>(((PCHAR)CacheBuffer + 1))) -
00930                                  (PCHAR)CacheBuffer);
00931 
00932                     <span class="keywordflow">if</span> (MoveLength &gt; LengthToGo) {
00933                         MoveLength = LengthToGo;
00934                     }
00935 
00936                     <span class="comment">//</span>
00937                     <span class="comment">//  Here's hoping that it is cheaper to call Mm to see if</span>
00938                     <span class="comment">//  the page is valid.  If not let Mm know how many pages</span>
00939                     <span class="comment">//  we are after before doing the move.</span>
00940                     <span class="comment">//</span>
00941 
00942                     <a class="code" href="../../d2/d1/mm_8h.html#a20">MmSetPageFaultReadAhead</a>( Thread, PagesToGo );
00943                     GotAMiss |= !<a class="code" href="../../d1/d5/mapcache_8c.html#a13">MmCheckCachedPageState</a>( CacheBuffer, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00944 
00945                     RtlCopyBytes( <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>, CacheBuffer, MoveLength );
00946 
00947                     PagesToGo -= 1;
00948 
00949                     LengthToGo -= MoveLength;
00950                     <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> = (PCHAR)<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> + MoveLength;
00951                     CacheBuffer = (PCHAR)CacheBuffer + MoveLength;
00952                 }
00953 
00954             <span class="comment">//</span>
00955             <span class="comment">//  Handle the read here that stays on a single page.</span>
00956             <span class="comment">//</span>
00957 
00958             } <span class="keywordflow">else</span> {
00959 
00960                 <span class="comment">//</span>
00961                 <span class="comment">//  Here's hoping that it is cheaper to call Mm to see if</span>
00962                 <span class="comment">//  the page is valid.  If not let Mm know how many pages</span>
00963                 <span class="comment">//  we are after before doing the move.</span>
00964                 <span class="comment">//</span>
00965 
00966                 <a class="code" href="../../d2/d1/mm_8h.html#a20">MmSetPageFaultReadAhead</a>( Thread, 0 );
00967                 GotAMiss |= !<a class="code" href="../../d1/d5/mapcache_8c.html#a13">MmCheckCachedPageState</a>( CacheBuffer, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00968 
00969                 RtlCopyBytes( <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>, CacheBuffer, ReceivedLength );
00970 
00971                 <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> = (PCHAR)<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> + ReceivedLength;
00972             }
00973         }
00974         except( <a class="code" href="../../d5/d7/copysup_8c.html#a5">CcCopyReadExceptionFilter</a>( GetExceptionInformation(),
00975                                            &amp;<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> ) ) {
00976 
00977             <a class="code" href="../../d5/d2/cachedat_8c.html#a75">CcMissCounter</a> = &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a43">CcThrowAway</a>;
00978 
00979             <span class="comment">//</span>
00980             <span class="comment">//  If we get an exception, then we have to renable page fault</span>
00981             <span class="comment">//  clustering and unmap on the way out.</span>
00982             <span class="comment">//</span>
00983 
00984             <a class="code" href="../../d2/d1/mm_8h.html#a21">MmResetPageFaultReadAhead</a>( Thread, SavedState );
00985 
00986 
00987             <a class="code" href="../../d5/d3/vacbsup_8c.html#a16">CcFreeVirtualAddress</a>( Vacb );
00988 
00989             <span class="comment">//</span>
00990             <span class="comment">//  If we got an access violation, then the user buffer went</span>
00991             <span class="comment">//  away.  Otherwise we must have gotten an I/O error trying</span>
00992             <span class="comment">//  to bring the data in.</span>
00993             <span class="comment">//</span>
00994 
00995             <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_ACCESS_VIOLATION) {
00996                 <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INVALID_USER_BUFFER );
00997             }
00998             <span class="keywordflow">else</span> {
00999                 <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( <a class="code" href="../../d1/d8/fsrtl_8h.html#a136">FsRtlNormalizeNtstatus</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>,
01000                                                        STATUS_UNEXPECTED_IO_ERROR ));
01001             }
01002         }
01003 
01004         <span class="comment">//</span>
01005         <span class="comment">//  Update number of bytes transferred.</span>
01006         <span class="comment">//</span>
01007 
01008         Length -= ReceivedLength;
01009 
01010         <span class="comment">//</span>
01011         <span class="comment">//  Unmap the data now, and calculate length left to transfer.</span>
01012         <span class="comment">//</span>
01013 
01014         <span class="keywordflow">if</span> (Length != 0) {
01015 
01016             <span class="comment">//</span>
01017             <span class="comment">//  If there is more to go, just free this vacb.</span>
01018             <span class="comment">//</span>
01019 
01020             <a class="code" href="../../d5/d3/vacbsup_8c.html#a16">CcFreeVirtualAddress</a>( Vacb );
01021 
01022         } <span class="keywordflow">else</span> {
01023 
01024             <span class="comment">//</span>
01025             <span class="comment">//  Otherwise save it for the next time through.</span>
01026             <span class="comment">//</span>
01027 
01028             <a class="code" href="../../d5/d5/cc_8h.html#a84">SetActiveVacb</a>( SharedCacheMap, OldIrql, Vacb, (FOffset.LowPart &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>), 0 );
01029             <span class="keywordflow">break</span>;
01030         }
01031 
01032         <span class="comment">//</span>
01033         <span class="comment">//  Assume we did not get all the data we wanted, and set FOffset</span>
01034         <span class="comment">//  to the end of the returned data.</span>
01035         <span class="comment">//</span>
01036 
01037         FOffset.LowPart = BeyondLastByte;
01038     }
01039 
01040     <a class="code" href="../../d2/d1/mm_8h.html#a21">MmResetPageFaultReadAhead</a>( Thread, SavedState );
01041 
01042     <a class="code" href="../../d5/d2/cachedat_8c.html#a75">CcMissCounter</a> = &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a43">CcThrowAway</a>;
01043 
01044     <span class="comment">//</span>
01045     <span class="comment">//  Now enable read ahead if it looks like we got any misses, and do</span>
01046     <span class="comment">//  the first one.</span>
01047     <span class="comment">//</span>
01048 
01049     <span class="keywordflow">if</span> (GotAMiss &amp;&amp;
01050         !<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( FileObject-&gt;Flags, <a class="code" href="../../d0/d5/io_8h.html#a170">FO_RANDOM_ACCESS</a> ) &amp;&amp;
01051         !PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o13">ReadAheadEnabled</a>) {
01052 
01053         PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o13">ReadAheadEnabled</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01054         <a class="code" href="../../d4/d2/cache_8h.html#a84">CcScheduleReadAhead</a>( FileObject, &amp;OriginalOffset, OriginalLength );
01055     }
01056 
01057     <span class="comment">//</span>
01058     <span class="comment">//  Now that we have described our desired read ahead, let's</span>
01059     <span class="comment">//  shift the read history down.</span>
01060     <span class="comment">//</span>
01061 
01062     PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o3">FileOffset1</a>.LowPart = PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o5">FileOffset2</a>.LowPart;
01063     PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o4">BeyondLastByte1</a>.LowPart = PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o6">BeyondLastByte2</a>.LowPart;
01064     PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o5">FileOffset2</a>.LowPart = OriginalOffset.LowPart;
01065     PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o6">BeyondLastByte2</a>.LowPart = OriginalOffset.LowPart + OriginalLength;
01066 
01067     IoStatus-&gt;Status = STATUS_SUCCESS;
01068     IoStatus-&gt;Information = OriginalLength;
01069 
01070     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcFastCopyRead -&gt; VOID\n"</span>, 0 );
01071 }
01072 
01073 
01074 BOOLEAN
<a name="l01075"></a><a class="code" href="../../d4/d2/cache_8h.html#a76">01075</a> <a class="code" href="../../d4/d2/cache_8h.html#a76">CcCopyWrite</a> (
01076     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
01077     IN PLARGE_INTEGER FileOffset,
01078     IN ULONG Length,
01079     IN BOOLEAN Wait,
01080     IN PVOID Buffer
01081     )
01082 
01083 <span class="comment">/*++</span>
01084 <span class="comment"></span>
01085 <span class="comment">Routine Description:</span>
01086 <span class="comment"></span>
01087 <span class="comment">    This routine attempts to copy the specified file data from the specified</span>
01088 <span class="comment">    buffer into the Cache, and deliver the correct I/O status.  It is *not*</span>
01089 <span class="comment">    safe to call this routine from Dpc level.</span>
01090 <span class="comment"></span>
01091 <span class="comment">    If the caller does not want to block (such as for disk I/O), then</span>
01092 <span class="comment">    Wait should be supplied as FALSE.  If Wait was supplied as FALSE and</span>
01093 <span class="comment">    it is currently impossible to receive all of the requested data without</span>
01094 <span class="comment">    blocking, then this routine will return FALSE.  However, if the</span>
01095 <span class="comment">    correct space is immediately accessible in the cache and no blocking is</span>
01096 <span class="comment">    required, this routine copies the data and returns TRUE.</span>
01097 <span class="comment"></span>
01098 <span class="comment">    If the caller supplies Wait as TRUE, then this routine is guaranteed</span>
01099 <span class="comment">    to copy the data and return TRUE.  If the correct space is immediately</span>
01100 <span class="comment">    accessible in the cache, then no blocking will occur.  Otherwise,</span>
01101 <span class="comment">    the necessary work will be initiated to read and/or free cache data,</span>
01102 <span class="comment">    and the caller will be blocked until the data can be received.</span>
01103 <span class="comment"></span>
01104 <span class="comment">    File system Fsd's should typically supply Wait = TRUE if they are</span>
01105 <span class="comment">    processing a synchronous I/O requests, or Wait = FALSE if they are</span>
01106 <span class="comment">    processing an asynchronous request.</span>
01107 <span class="comment"></span>
01108 <span class="comment">    File system or Server Fsp threads should supply Wait = TRUE.</span>
01109 <span class="comment"></span>
01110 <span class="comment">Arguments:</span>
01111 <span class="comment"></span>
01112 <span class="comment">    FileObject - Pointer to the file object for a file which was</span>
01113 <span class="comment">                 opened with NO_INTERMEDIATE_BUFFERING clear, i.e., for</span>
01114 <span class="comment">                 which CcInitializeCacheMap was called by the file system.</span>
01115 <span class="comment"></span>
01116 <span class="comment">    FileOffset - Byte offset in file to receive the data.</span>
01117 <span class="comment"></span>
01118 <span class="comment">    Length - Length of data in bytes.</span>
01119 <span class="comment"></span>
01120 <span class="comment">    Wait - FALSE if caller may not block, TRUE otherwise (see description</span>
01121 <span class="comment">           above)</span>
01122 <span class="comment"></span>
01123 <span class="comment">    Buffer - Pointer to input buffer from which data should be copied.</span>
01124 <span class="comment"></span>
01125 <span class="comment">Return Value:</span>
01126 <span class="comment"></span>
01127 <span class="comment">    FALSE - if Wait was supplied as FALSE and the data was not copied.</span>
01128 <span class="comment"></span>
01129 <span class="comment">    TRUE - if the data has been copied.</span>
01130 <span class="comment"></span>
01131 <span class="comment">Raises:</span>
01132 <span class="comment"></span>
01133 <span class="comment">    STATUS_INSUFFICIENT_RESOURCES - If a pool allocation failure occurs.</span>
01134 <span class="comment">        This can only occur if Wait was specified as TRUE.  (If Wait is</span>
01135 <span class="comment">        specified as FALSE, and an allocation failure occurs, this</span>
01136 <span class="comment">        routine simply returns FALSE.)</span>
01137 <span class="comment"></span>
01138 <span class="comment">--*/</span>
01139 
01140 {
01141     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap;
01142     <a class="code" href="../../d9/d0/struct__FSRTL__ADVANCED__FCB__HEADER.html">PFSRTL_ADVANCED_FCB_HEADER</a> FcbHeader;
01143     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> ActiveVacb;
01144     ULONG ActivePage;
01145     PVOID ActiveAddress;
01146     ULONG PageIsDirty;
01147     KIRQL OldIrql;
01148     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01149     PVOID CacheBuffer;
01150     LARGE_INTEGER FOffset;
01151     <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> Bcb;
01152     ULONG ZeroFlags;
01153     LARGE_INTEGER Temp;
01154 
01155     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcCopyWrite\n"</span>, 0 );
01156 
01157     <span class="comment">//</span>
01158     <span class="comment">//  If the caller specified Wait == FALSE, but the FileObject is WriteThrough,</span>
01159     <span class="comment">//  then we need to just get out.</span>
01160     <span class="comment">//</span>
01161 
01162     <span class="keywordflow">if</span> ((FileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a154">FO_WRITE_THROUGH</a>) &amp;&amp; !Wait) {
01163 
01164         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcCopyWrite-&gt;FALSE (WriteThrough &amp;&amp; !Wait)\n"</span>, 0 );
01165 
01166         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01167     }
01168 
01169     <span class="comment">//</span>
01170     <span class="comment">//  Get pointer to shared cache map</span>
01171     <span class="comment">//</span>
01172 
01173     SharedCacheMap = FileObject-&gt;SectionObjectPointer-&gt;SharedCacheMap;
01174     FOffset = *FileOffset;
01175 
01176     <span class="comment">//</span>
01177     <span class="comment">//  See if we have an active Vacb, that we can just copy to.</span>
01178     <span class="comment">//</span>
01179 
01180     <a class="code" href="../../d5/d5/cc_8h.html#a82">GetActiveVacb</a>( SharedCacheMap, OldIrql, ActiveVacb, ActivePage, PageIsDirty );
01181 
01182     <span class="keywordflow">if</span> (ActiveVacb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01183 
01184         <span class="comment">//</span>
01185         <span class="comment">//  See if the request starts in the ActivePage.  WriteThrough requests must</span>
01186         <span class="comment">//  go the longer route through CcMapAndCopy, where WriteThrough flushes are</span>
01187         <span class="comment">//  implemented.</span>
01188         <span class="comment">//</span>
01189 
01190         <span class="keywordflow">if</span> (((ULONG)(FOffset.QuadPart &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>) == ActivePage) &amp;&amp; (Length != 0) &amp;&amp;
01191             !<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( FileObject-&gt;Flags, <a class="code" href="../../d0/d5/io_8h.html#a154">FO_WRITE_THROUGH</a> )) {
01192 
01193             ULONG LengthToCopy = <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - (FOffset.LowPart &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1));
01194 
01195             <span class="comment">//</span>
01196             <span class="comment">//  Reduce LengthToCopy if it is greater than our caller's length.</span>
01197             <span class="comment">//</span>
01198 
01199             <span class="keywordflow">if</span> (LengthToCopy &gt; Length) {
01200                 LengthToCopy = Length;
01201             }
01202 
01203             <span class="comment">//</span>
01204             <span class="comment">//  Copy the data to the user buffer.</span>
01205             <span class="comment">//</span>
01206 
01207             <span class="keywordflow">try</span> {
01208 
01209                 <span class="comment">//</span>
01210                 <span class="comment">//  If we are copying to a page that is locked down, then</span>
01211                 <span class="comment">//  we have to do it under our spinlock, and update the</span>
01212                 <span class="comment">//  NeedToZero field.</span>
01213                 <span class="comment">//</span>
01214 
01215                 OldIrql = 0xFF;
01216 
01217                 CacheBuffer = (PVOID)((PCHAR)ActiveVacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o0">BaseAddress</a> +
01218                                       (FOffset.LowPart &amp; (<a class="code" href="../../d4/d2/cache_8h.html#a0">VACB_MAPPING_GRANULARITY</a> - 1)));
01219 
01220                 <span class="keywordflow">if</span> (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o13">NeedToZero</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01221 
01222                     <span class="comment">//</span>
01223                     <span class="comment">//  The FastLock may not write our "flag".</span>
01224                     <span class="comment">//</span>
01225 
01226                     OldIrql = 0;
01227 
01228                     ExAcquireFastLock( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o15">ActiveVacbSpinLock</a>, &amp;OldIrql );
01229 
01230                     <span class="comment">//</span>
01231                     <span class="comment">//  Note that the NeedToZero could be cleared, since we</span>
01232                     <span class="comment">//  tested it without the spinlock.</span>
01233                     <span class="comment">//</span>
01234 
01235                     ActiveAddress = SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o13">NeedToZero</a>;
01236                     <span class="keywordflow">if</span> ((ActiveAddress != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
01237                         (ActiveVacb == SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o35">NeedToZeroVacb</a>) &amp;&amp;
01238                         (((PCHAR)CacheBuffer + LengthToCopy) &gt; (PCHAR)ActiveAddress)) {
01239 
01240                         <span class="comment">//</span>
01241                         <span class="comment">//  If we are skipping some bytes in the page, then we need</span>
01242                         <span class="comment">//  to zero them.</span>
01243                         <span class="comment">//</span>
01244 
01245                         <span class="keywordflow">if</span> ((PCHAR)CacheBuffer &gt; (PCHAR)ActiveAddress) {
01246 
01247                             RtlZeroMemory( ActiveAddress, (PCHAR)CacheBuffer - (PCHAR)ActiveAddress );
01248                         }
01249                         SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o13">NeedToZero</a> = (PVOID)((PCHAR)CacheBuffer + LengthToCopy);
01250                     }
01251 
01252                     ExReleaseFastLock( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o15">ActiveVacbSpinLock</a>, OldIrql );
01253                 }
01254 
01255                 RtlCopyBytes( CacheBuffer, <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>, LengthToCopy );
01256 
01257             } except( <a class="code" href="../../d5/d7/copysup_8c.html#a5">CcCopyReadExceptionFilter</a>( GetExceptionInformation(),
01258                                                  &amp;<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> ) ) {
01259 
01260                 <span class="comment">//</span>
01261                 <span class="comment">//  If we failed to overwrite the uninitialized data,</span>
01262                 <span class="comment">//  zero it now (we cannot safely restore NeedToZero).</span>
01263                 <span class="comment">//</span>
01264 
01265                 <span class="keywordflow">if</span> (OldIrql != 0xFF) {
01266                     RtlZeroBytes( CacheBuffer, LengthToCopy );
01267                 }
01268 
01269                 <a class="code" href="../../d5/d5/cc_8h.html#a84">SetActiveVacb</a>( SharedCacheMap, OldIrql, ActiveVacb, ActivePage, <a class="code" href="../../d5/d5/cc_8h.html#a76">ACTIVE_PAGE_IS_DIRTY</a> );
01270 
01271                 <span class="comment">//</span>
01272                 <span class="comment">//  If we got an access violation, then the user buffer went</span>
01273                 <span class="comment">//  away.  Otherwise we must have gotten an I/O error trying</span>
01274                 <span class="comment">//  to bring the data in.</span>
01275                 <span class="comment">//</span>
01276 
01277                 <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_ACCESS_VIOLATION) {
01278                     <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INVALID_USER_BUFFER );
01279                 }
01280                 <span class="keywordflow">else</span> {
01281                     <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( <a class="code" href="../../d1/d8/fsrtl_8h.html#a136">FsRtlNormalizeNtstatus</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>,
01282                                                            STATUS_UNEXPECTED_IO_ERROR ));
01283                 }
01284             }
01285 
01286             <span class="comment">//</span>
01287             <span class="comment">//  Now adjust FOffset and Length by what we copied.</span>
01288             <span class="comment">//</span>
01289 
01290             <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> = (PVOID)((PCHAR)<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> + LengthToCopy);
01291             FOffset.QuadPart = FOffset.QuadPart + (LONGLONG)LengthToCopy;
01292             Length -= LengthToCopy;
01293 
01294             <span class="comment">//</span>
01295             <span class="comment">//  If that was all the data, then get outski...</span>
01296             <span class="comment">//</span>
01297 
01298             <span class="keywordflow">if</span> (Length == 0) {
01299 
01300                 <a class="code" href="../../d5/d5/cc_8h.html#a84">SetActiveVacb</a>( SharedCacheMap, OldIrql, ActiveVacb, ActivePage, <a class="code" href="../../d5/d5/cc_8h.html#a76">ACTIVE_PAGE_IS_DIRTY</a> );
01301                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01302             }
01303 
01304             <span class="comment">//</span>
01305             <span class="comment">//  Remember that the page is dirty now.</span>
01306             <span class="comment">//</span>
01307 
01308             PageIsDirty |= <a class="code" href="../../d5/d5/cc_8h.html#a76">ACTIVE_PAGE_IS_DIRTY</a>;
01309         }
01310 
01311         <a class="code" href="../../d5/d5/cc_8h.html#a182">CcFreeActiveVacb</a>( SharedCacheMap, ActiveVacb, ActivePage, PageIsDirty );
01312 
01313     <span class="comment">//</span>
01314     <span class="comment">//  Else someone else could have the active page, and may want to zero</span>
01315     <span class="comment">//  the range we plan to write!</span>
01316     <span class="comment">//</span>
01317 
01318     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o13">NeedToZero</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01319 
01320         <a class="code" href="../../d5/d5/cc_8h.html#a182">CcFreeActiveVacb</a>( SharedCacheMap, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, 0, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
01321     }
01322 
01323     <span class="comment">//</span>
01324     <span class="comment">//  At this point we can calculate the ZeroFlags.</span>
01325     <span class="comment">//</span>
01326 
01327     <span class="comment">//</span>
01328     <span class="comment">//  We can always zero middle pages, if any.</span>
01329     <span class="comment">//</span>
01330 
01331     ZeroFlags = <a class="code" href="../../d5/d5/cc_8h.html#a86">ZERO_MIDDLE_PAGES</a>;
01332 
01333     <span class="keywordflow">if</span> (((FOffset.LowPart &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1)) == 0) &amp;&amp;
01334         (Length &gt;= <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>)) {
01335         ZeroFlags |= <a class="code" href="../../d5/d5/cc_8h.html#a85">ZERO_FIRST_PAGE</a>;
01336     }
01337 
01338     <span class="keywordflow">if</span> (((FOffset.LowPart + Length) &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1)) == 0) {
01339         ZeroFlags |= <a class="code" href="../../d5/d5/cc_8h.html#a87">ZERO_LAST_PAGE</a>;
01340     }
01341 
01342     Temp = FOffset;
01343     Temp.LowPart &amp;= ~(<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> -1);
01344 
01345     <span class="comment">//</span>
01346     <span class="comment">//  If there is an advanced header, then we can acquire the FastMutex to</span>
01347     <span class="comment">//  make capturing ValidDataLength atomic.  Currently our other file systems</span>
01348     <span class="comment">//  are either RO or do not really support 64-bits.</span>
01349     <span class="comment">//</span>
01350 
01351     FcbHeader = (<a class="code" href="../../d9/d0/struct__FSRTL__ADVANCED__FCB__HEADER.html">PFSRTL_ADVANCED_FCB_HEADER</a>)FileObject-&gt;FsContext;
01352     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(FcbHeader-&gt;Flags, <a class="code" href="../../d1/d8/fsrtl_8h.html#a6">FSRTL_FLAG_ADVANCED_HEADER</a>)) {
01353         ExAcquireFastMutex( FcbHeader-&gt;FastMutex );
01354         Temp.QuadPart = ((<a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html">PFSRTL_COMMON_FCB_HEADER</a>)FileObject-&gt;FsContext)-&gt;ValidDataLength.QuadPart -
01355                         Temp.QuadPart;
01356         ExReleaseFastMutex( FcbHeader-&gt;FastMutex );
01357     } <span class="keywordflow">else</span> {
01358         Temp.QuadPart = ((<a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html">PFSRTL_COMMON_FCB_HEADER</a>)FileObject-&gt;FsContext)-&gt;ValidDataLength.QuadPart -
01359                         Temp.QuadPart;
01360     }
01361 
01362     <span class="keywordflow">if</span> (Temp.QuadPart &lt;= 0) {
01363         ZeroFlags |= <a class="code" href="../../d5/d5/cc_8h.html#a85">ZERO_FIRST_PAGE</a> | <a class="code" href="../../d5/d5/cc_8h.html#a86">ZERO_MIDDLE_PAGES</a> | <a class="code" href="../../d5/d5/cc_8h.html#a87">ZERO_LAST_PAGE</a>;
01364     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((Temp.HighPart == 0) &amp;&amp; (Temp.LowPart &lt;= <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>)) {
01365         ZeroFlags |= <a class="code" href="../../d5/d5/cc_8h.html#a86">ZERO_MIDDLE_PAGES</a> | <a class="code" href="../../d5/d5/cc_8h.html#a87">ZERO_LAST_PAGE</a>;
01366     }
01367 
01368     <span class="comment">//</span>
01369     <span class="comment">//  Call a routine to map and copy the data in Mm and get out.</span>
01370     <span class="comment">//</span>
01371 
01372     <span class="keywordflow">if</span> (Wait) {
01373 
01374         <a class="code" href="../../d5/d5/cc_8h.html#a183">CcMapAndCopy</a>( SharedCacheMap,
01375                       <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>,
01376                       &amp;FOffset,
01377                       Length,
01378                       ZeroFlags,
01379                       <a class="code" href="../../d5/d5/cc_8h.html#a59">BooleanFlagOn</a>( FileObject-&gt;Flags, <a class="code" href="../../d0/d5/io_8h.html#a154">FO_WRITE_THROUGH</a> ));
01380 
01381         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01382     }
01383 
01384     <span class="comment">//</span>
01385     <span class="comment">//  The rest of this routine is the Wait == FALSE case.</span>
01386     <span class="comment">//</span>
01387     <span class="comment">//  Not all of the transfer will come back at once, so we have to loop</span>
01388     <span class="comment">//  until the entire transfer is complete.</span>
01389     <span class="comment">//</span>
01390 
01391     <span class="keywordflow">while</span> (Length != 0) {
01392 
01393         ULONG ReceivedLength;
01394         LARGE_INTEGER BeyondLastByte;
01395 
01396         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/cc_8h.html#a175">CcPinFileData</a>( FileObject,
01397                             &amp;FOffset,
01398                             Length,
01399                             <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
01400                             <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
01401                             <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
01402                             &amp;Bcb,
01403                             &amp;CacheBuffer,
01404                             &amp;BeyondLastByte )) {
01405 
01406             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcCopyWrite -&gt; FALSE\n"</span>, 0 );
01407 
01408             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01409 
01410         } <span class="keywordflow">else</span> {
01411 
01412             <span class="comment">//</span>
01413             <span class="comment">//  Calculate how much data is described by Bcb starting at our desired</span>
01414             <span class="comment">//  file offset.</span>
01415             <span class="comment">//</span>
01416 
01417             ReceivedLength = (ULONG)(BeyondLastByte.QuadPart - FOffset.QuadPart);
01418 
01419             <span class="comment">//</span>
01420             <span class="comment">//  If we got more than we need, make sure to only transfer</span>
01421             <span class="comment">//  the right amount.</span>
01422             <span class="comment">//</span>
01423 
01424             <span class="keywordflow">if</span> (ReceivedLength &gt; Length) {
01425                 ReceivedLength = Length;
01426             }
01427         }
01428 
01429         <span class="comment">//</span>
01430         <span class="comment">//  It is possible for the user buffer to become no longer accessible</span>
01431         <span class="comment">//  since it was last checked by the I/O system.  If we fail to access</span>
01432         <span class="comment">//  the buffer we must raise a status that the caller's exception</span>
01433         <span class="comment">//  filter considers as "expected".  Also we unmap the Bcb here, since</span>
01434         <span class="comment">//  we otherwise would have no other reason to put a try-finally around</span>
01435         <span class="comment">//  this loop.</span>
01436         <span class="comment">//</span>
01437 
01438         <span class="keywordflow">try</span> {
01439 
01440             RtlCopyBytes( CacheBuffer, <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>, ReceivedLength );
01441 
01442             <a class="code" href="../../d4/d2/cache_8h.html#a91">CcSetDirtyPinnedData</a>( Bcb, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
01443             <a class="code" href="../../d5/d5/cc_8h.html#a176">CcUnpinFileData</a>( Bcb, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, <a class="code" href="../../d5/d5/cc_8h.html#a211a171">UNPIN</a> );
01444         }
01445         except( <a class="code" href="../../d5/d7/copysup_8c.html#a5">CcCopyReadExceptionFilter</a>( GetExceptionInformation(),
01446                                            &amp;<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> ) ) {
01447 
01448             <a class="code" href="../../d5/d5/cc_8h.html#a176">CcUnpinFileData</a>( Bcb, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, <a class="code" href="../../d5/d5/cc_8h.html#a211a171">UNPIN</a> );
01449 
01450             <span class="comment">//</span>
01451             <span class="comment">//  If we got an access violation, then the user buffer went</span>
01452             <span class="comment">//  away.  Otherwise we must have gotten an I/O error trying</span>
01453             <span class="comment">//  to bring the data in.</span>
01454             <span class="comment">//</span>
01455 
01456             <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_ACCESS_VIOLATION) {
01457                 <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INVALID_USER_BUFFER );
01458             }
01459             <span class="keywordflow">else</span> {
01460 
01461                 <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>(<a class="code" href="../../d1/d8/fsrtl_8h.html#a136">FsRtlNormalizeNtstatus</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>, STATUS_UNEXPECTED_IO_ERROR ));
01462             }
01463         }
01464 
01465         <span class="comment">//</span>
01466         <span class="comment">//  Assume we did not get all the data we wanted, and set FOffset</span>
01467         <span class="comment">//  to the end of the returned data and adjust the Buffer and Length.</span>
01468         <span class="comment">//</span>
01469 
01470         FOffset = BeyondLastByte;
01471         <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> = (PCHAR)<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> + ReceivedLength;
01472         Length -= ReceivedLength;
01473     }
01474 
01475     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcCopyWrite -&gt; TRUE\n"</span>, 0 );
01476 
01477     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01478 }
01479 
01480 
01481 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01482"></a><a class="code" href="../../d4/d2/cache_8h.html#a77">01482</a> <a class="code" href="../../d4/d2/cache_8h.html#a77">CcFastCopyWrite</a> (
01483     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
01484     IN ULONG FileOffset,
01485     IN ULONG Length,
01486     IN PVOID Buffer
01487     )
01488 
01489 <span class="comment">/*++</span>
01490 <span class="comment"></span>
01491 <span class="comment">Routine Description:</span>
01492 <span class="comment"></span>
01493 <span class="comment">    This routine attempts to copy the specified file data from the specified</span>
01494 <span class="comment">    buffer into the Cache, and deliver the correct I/O status.</span>
01495 <span class="comment"></span>
01496 <span class="comment">    This is a faster version of CcCopyWrite which only supports 32-bit file</span>
01497 <span class="comment">    offsets and synchronicity (Wait = TRUE) and no Write Through.</span>
01498 <span class="comment"></span>
01499 <span class="comment">Arguments:</span>
01500 <span class="comment"></span>
01501 <span class="comment">    FileObject - Pointer to the file object for a file which was</span>
01502 <span class="comment">                 opened with NO_INTERMEDIATE_BUFFERING clear, i.e., for</span>
01503 <span class="comment">                 which CcInitializeCacheMap was called by the file system.</span>
01504 <span class="comment"></span>
01505 <span class="comment">    FileOffset - Byte offset in file to receive the data.</span>
01506 <span class="comment"></span>
01507 <span class="comment">    Length - Length of data in bytes.</span>
01508 <span class="comment"></span>
01509 <span class="comment">    Buffer - Pointer to input buffer from which data should be copied.</span>
01510 <span class="comment"></span>
01511 <span class="comment">Return Value:</span>
01512 <span class="comment"></span>
01513 <span class="comment">    None</span>
01514 <span class="comment"></span>
01515 <span class="comment">Raises:</span>
01516 <span class="comment"></span>
01517 <span class="comment">    STATUS_INSUFFICIENT_RESOURCES - If a pool allocation failure occurs.</span>
01518 <span class="comment">        This can only occur if Wait was specified as TRUE.  (If Wait is</span>
01519 <span class="comment">        specified as FALSE, and an allocation failure occurs, this</span>
01520 <span class="comment">        routine simply returns FALSE.)</span>
01521 <span class="comment"></span>
01522 <span class="comment">--*/</span>
01523 
01524 {
01525     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap;
01526     PVOID CacheBuffer;
01527     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> ActiveVacb;
01528     ULONG ActivePage;
01529     PVOID ActiveAddress;
01530     ULONG PageIsDirty;
01531     KIRQL OldIrql;
01532     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01533     ULONG ZeroFlags;
01534     ULONG ValidDataLength;
01535     LARGE_INTEGER FOffset;
01536 
01537     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcFastCopyWrite\n"</span>, 0 );
01538 
01539     <span class="comment">//</span>
01540     <span class="comment">//  Get pointer to shared cache map and a copy of valid data length</span>
01541     <span class="comment">//</span>
01542 
01543     SharedCacheMap = FileObject-&gt;SectionObjectPointer-&gt;SharedCacheMap;
01544 
01545     <span class="comment">//</span>
01546     <span class="comment">//  See if we have an active Vacb, that we can just copy to.</span>
01547     <span class="comment">//</span>
01548 
01549     <a class="code" href="../../d5/d5/cc_8h.html#a82">GetActiveVacb</a>( SharedCacheMap, OldIrql, ActiveVacb, ActivePage, PageIsDirty );
01550 
01551     <span class="keywordflow">if</span> (ActiveVacb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01552 
01553         <span class="comment">//</span>
01554         <span class="comment">//  See if the request starts in the ActivePage.  WriteThrough requests must</span>
01555         <span class="comment">//  go the longer route through CcMapAndCopy, where WriteThrough flushes are</span>
01556         <span class="comment">//  implemented.</span>
01557         <span class="comment">//</span>
01558 
01559         <span class="keywordflow">if</span> (((FileOffset &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>) == ActivePage) &amp;&amp; (Length != 0) &amp;&amp;
01560             !<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( FileObject-&gt;Flags, <a class="code" href="../../d0/d5/io_8h.html#a154">FO_WRITE_THROUGH</a> )) {
01561 
01562             ULONG LengthToCopy = <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - (FileOffset &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1));
01563 
01564             <span class="comment">//</span>
01565             <span class="comment">//  Reduce LengthToCopy if it is greater than our caller's length.</span>
01566             <span class="comment">//</span>
01567 
01568             <span class="keywordflow">if</span> (LengthToCopy &gt; Length) {
01569                 LengthToCopy = Length;
01570             }
01571 
01572             <span class="comment">//</span>
01573             <span class="comment">//  Copy the data to the user buffer.</span>
01574             <span class="comment">//</span>
01575 
01576             <span class="keywordflow">try</span> {
01577 
01578                 <span class="comment">//</span>
01579                 <span class="comment">//  If we are copying to a page that is locked down, then</span>
01580                 <span class="comment">//  we have to do it under our spinlock, and update the</span>
01581                 <span class="comment">//  NeedToZero field.</span>
01582                 <span class="comment">//</span>
01583 
01584                 OldIrql = 0xFF;
01585 
01586                 CacheBuffer = (PVOID)((PCHAR)ActiveVacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o0">BaseAddress</a> +
01587                                       (FileOffset &amp; (<a class="code" href="../../d4/d2/cache_8h.html#a0">VACB_MAPPING_GRANULARITY</a> - 1)));
01588 
01589                 <span class="keywordflow">if</span> (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o13">NeedToZero</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01590 
01591                     <span class="comment">//</span>
01592                     <span class="comment">//  The FastLock may not write our "flag".</span>
01593                     <span class="comment">//</span>
01594 
01595                     OldIrql = 0;
01596 
01597                     ExAcquireFastLock( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o15">ActiveVacbSpinLock</a>, &amp;OldIrql );
01598 
01599                     <span class="comment">//</span>
01600                     <span class="comment">//  Note that the NeedToZero could be cleared, since we</span>
01601                     <span class="comment">//  tested it without the spinlock.</span>
01602                     <span class="comment">//</span>
01603 
01604                     ActiveAddress = SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o13">NeedToZero</a>;
01605                     <span class="keywordflow">if</span> ((ActiveAddress != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
01606                         (ActiveVacb == SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o35">NeedToZeroVacb</a>) &amp;&amp;
01607                         (((PCHAR)CacheBuffer + LengthToCopy) &gt; (PCHAR)ActiveAddress)) {
01608 
01609                         <span class="comment">//</span>
01610                         <span class="comment">//  If we are skipping some bytes in the page, then we need</span>
01611                         <span class="comment">//  to zero them.</span>
01612                         <span class="comment">//</span>
01613 
01614                         <span class="keywordflow">if</span> ((PCHAR)CacheBuffer &gt; (PCHAR)ActiveAddress) {
01615 
01616                             RtlZeroMemory( ActiveAddress, (PCHAR)CacheBuffer - (PCHAR)ActiveAddress );
01617                         }
01618                         SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o13">NeedToZero</a> = (PVOID)((PCHAR)CacheBuffer + LengthToCopy);
01619                     }
01620 
01621                     ExReleaseFastLock( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o15">ActiveVacbSpinLock</a>, OldIrql );
01622                 }
01623 
01624                 RtlCopyBytes( CacheBuffer, <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>, LengthToCopy );
01625 
01626             } except( <a class="code" href="../../d5/d7/copysup_8c.html#a5">CcCopyReadExceptionFilter</a>( GetExceptionInformation(),
01627                                                  &amp;<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> ) ) {
01628 
01629                 <span class="comment">//</span>
01630                 <span class="comment">//  If we failed to overwrite the uninitialized data,</span>
01631                 <span class="comment">//  zero it now (we cannot safely restore NeedToZero).</span>
01632                 <span class="comment">//</span>
01633 
01634                 <span class="keywordflow">if</span> (OldIrql != 0xFF) {
01635                     RtlZeroBytes( CacheBuffer, LengthToCopy );
01636                 }
01637 
01638                 <a class="code" href="../../d5/d5/cc_8h.html#a84">SetActiveVacb</a>( SharedCacheMap, OldIrql, ActiveVacb, ActivePage, <a class="code" href="../../d5/d5/cc_8h.html#a76">ACTIVE_PAGE_IS_DIRTY</a> );
01639 
01640                 <span class="comment">//</span>
01641                 <span class="comment">//  If we got an access violation, then the user buffer went</span>
01642                 <span class="comment">//  away.  Otherwise we must have gotten an I/O error trying</span>
01643                 <span class="comment">//  to bring the data in.</span>
01644                 <span class="comment">//</span>
01645 
01646                 <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_ACCESS_VIOLATION) {
01647                     <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INVALID_USER_BUFFER );
01648                 }
01649                 <span class="keywordflow">else</span> {
01650                     <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( <a class="code" href="../../d1/d8/fsrtl_8h.html#a136">FsRtlNormalizeNtstatus</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>,
01651                                                            STATUS_UNEXPECTED_IO_ERROR ));
01652                 }
01653             }
01654 
01655             <span class="comment">//</span>
01656             <span class="comment">//  Now adjust FileOffset and Length by what we copied.</span>
01657             <span class="comment">//</span>
01658 
01659             <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> = (PVOID)((PCHAR)<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> + LengthToCopy);
01660             FileOffset += LengthToCopy;
01661             Length -= LengthToCopy;
01662 
01663             <span class="comment">//</span>
01664             <span class="comment">//  If that was all the data, then get outski...</span>
01665             <span class="comment">//</span>
01666 
01667             <span class="keywordflow">if</span> (Length == 0) {
01668 
01669                 <a class="code" href="../../d5/d5/cc_8h.html#a84">SetActiveVacb</a>( SharedCacheMap, OldIrql, ActiveVacb, ActivePage, <a class="code" href="../../d5/d5/cc_8h.html#a76">ACTIVE_PAGE_IS_DIRTY</a> );
01670                 <span class="keywordflow">return</span>;
01671             }
01672 
01673             <span class="comment">//</span>
01674             <span class="comment">//  Remember that the page is dirty now.</span>
01675             <span class="comment">//</span>
01676 
01677             PageIsDirty |= <a class="code" href="../../d5/d5/cc_8h.html#a76">ACTIVE_PAGE_IS_DIRTY</a>;
01678         }
01679 
01680         <a class="code" href="../../d5/d5/cc_8h.html#a182">CcFreeActiveVacb</a>( SharedCacheMap, ActiveVacb, ActivePage, PageIsDirty );
01681 
01682     <span class="comment">//</span>
01683     <span class="comment">//  Else someone else could have the active page, and may want to zero</span>
01684     <span class="comment">//  the range we plan to write!</span>
01685     <span class="comment">//</span>
01686 
01687     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o13">NeedToZero</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01688 
01689         <a class="code" href="../../d5/d5/cc_8h.html#a182">CcFreeActiveVacb</a>( SharedCacheMap, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, 0, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
01690     }
01691 
01692     <span class="comment">//</span>
01693     <span class="comment">//  Set up for call to CcMapAndCopy</span>
01694     <span class="comment">//</span>
01695 
01696     FOffset.LowPart = FileOffset;
01697     FOffset.HighPart = 0;
01698 
01699     ValidDataLength = ((<a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html">PFSRTL_COMMON_FCB_HEADER</a>)FileObject-&gt;FsContext)-&gt;ValidDataLength.LowPart;
01700 
01701     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>((ValidDataLength == MAXULONG) ||
01702            (((<a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html">PFSRTL_COMMON_FCB_HEADER</a>)FileObject-&gt;FsContext)-&gt;ValidDataLength.HighPart == 0));
01703 
01704     <span class="comment">//</span>
01705     <span class="comment">//  At this point we can calculate the ReadOnly flag for</span>
01706     <span class="comment">//  the purposes of whether to use the Bcb resource, and</span>
01707     <span class="comment">//  we can calculate the ZeroFlags.</span>
01708     <span class="comment">//</span>
01709 
01710     <span class="comment">//</span>
01711     <span class="comment">//  We can always zero middle pages, if any.</span>
01712     <span class="comment">//</span>
01713 
01714     ZeroFlags = <a class="code" href="../../d5/d5/cc_8h.html#a86">ZERO_MIDDLE_PAGES</a>;
01715 
01716     <span class="keywordflow">if</span> (((FileOffset &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1)) == 0) &amp;&amp;
01717         (Length &gt;= <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>)) {
01718         ZeroFlags |= <a class="code" href="../../d5/d5/cc_8h.html#a85">ZERO_FIRST_PAGE</a>;
01719     }
01720 
01721     <span class="keywordflow">if</span> (((FileOffset + Length) &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1)) == 0) {
01722         ZeroFlags |= <a class="code" href="../../d5/d5/cc_8h.html#a87">ZERO_LAST_PAGE</a>;
01723     }
01724 
01725     <span class="keywordflow">if</span> ((FileOffset &amp; ~(<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1)) &gt;= ValidDataLength) {
01726         ZeroFlags |= <a class="code" href="../../d5/d5/cc_8h.html#a85">ZERO_FIRST_PAGE</a> | <a class="code" href="../../d5/d5/cc_8h.html#a86">ZERO_MIDDLE_PAGES</a> | <a class="code" href="../../d5/d5/cc_8h.html#a87">ZERO_LAST_PAGE</a>;
01727     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (((FileOffset &amp; ~(<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1)) + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>) &gt;= ValidDataLength) {
01728         ZeroFlags |= <a class="code" href="../../d5/d5/cc_8h.html#a86">ZERO_MIDDLE_PAGES</a> | <a class="code" href="../../d5/d5/cc_8h.html#a87">ZERO_LAST_PAGE</a>;
01729     }
01730 
01731     <span class="comment">//</span>
01732     <span class="comment">//  Call a routine to map and copy the data in Mm and get out.</span>
01733     <span class="comment">//</span>
01734 
01735     <a class="code" href="../../d5/d5/cc_8h.html#a183">CcMapAndCopy</a>( SharedCacheMap,
01736                   <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>,
01737                   &amp;FOffset,
01738                   Length,
01739                   ZeroFlags,
01740                   <a class="code" href="../../d5/d5/cc_8h.html#a59">BooleanFlagOn</a>( FileObject-&gt;Flags, <a class="code" href="../../d0/d5/io_8h.html#a154">FO_WRITE_THROUGH</a> ));
01741 
01742     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcFastCopyWrite -&gt; VOID\n"</span>, 0 );
01743 }
01744 
01745 
01746 LONG
<a name="l01747"></a><a class="code" href="../../d5/d7/copysup_8c.html#a5">01747</a> <a class="code" href="../../d5/d7/copysup_8c.html#a5">CcCopyReadExceptionFilter</a>(
01748     IN PEXCEPTION_POINTERS ExceptionPointer,
01749     IN PNTSTATUS ExceptionCode
01750     )
01751 
01752 <span class="comment">/*++</span>
01753 <span class="comment"></span>
01754 <span class="comment">Routine Description:</span>
01755 <span class="comment"></span>
01756 <span class="comment">    This routine serves as a exception filter and has the special job of</span>
01757 <span class="comment">    extracting the "real" I/O error when Mm raises STATUS_IN_PAGE_ERROR</span>
01758 <span class="comment">    beneath us.</span>
01759 <span class="comment"></span>
01760 <span class="comment">Arguments:</span>
01761 <span class="comment"></span>
01762 <span class="comment">    ExceptionPointer - A pointer to the exception record that contains</span>
01763 <span class="comment">                       the real Io Status.</span>
01764 <span class="comment"></span>
01765 <span class="comment">    ExceptionCode - A pointer to an NTSTATUS that is to receive the real</span>
01766 <span class="comment">                    status.</span>
01767 <span class="comment"></span>
01768 <span class="comment">Return Value:</span>
01769 <span class="comment"></span>
01770 <span class="comment">    EXCEPTION_EXECUTE_HANDLER</span>
01771 <span class="comment"></span>
01772 <span class="comment">--*/</span>
01773 
01774 {
01775     *ExceptionCode = ExceptionPointer-&gt;ExceptionRecord-&gt;ExceptionCode;
01776 
01777     <span class="keywordflow">if</span> ( (*ExceptionCode == STATUS_IN_PAGE_ERROR) &amp;&amp;
01778          (ExceptionPointer-&gt;ExceptionRecord-&gt;NumberParameters &gt;= 3) ) {
01779 
01780         *ExceptionCode = (<a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>) ExceptionPointer-&gt;ExceptionRecord-&gt;ExceptionInformation[2];
01781     }
01782 
01783     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(*ExceptionCode) );
01784 
01785     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>;
01786 }
01787 
01788 
01789 BOOLEAN
<a name="l01790"></a><a class="code" href="../../d5/d7/copysup_8c.html#a6">01790</a> <a class="code" href="../../d4/d2/cache_8h.html#a72">CcCanIWrite</a> (
01791     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
01792     IN ULONG BytesToWrite,
01793     IN BOOLEAN Wait,
01794     IN UCHAR Retrying
01795     )
01796 
01797 <span class="comment">/*++</span>
01798 <span class="comment"></span>
01799 <span class="comment">Routine Description:</span>
01800 <span class="comment"></span>
01801 <span class="comment">    This routine tests whether it is ok to do a write to the cache</span>
01802 <span class="comment">    or not, according to the Thresholds of dirty bytes and available</span>
01803 <span class="comment">    pages.  The first time this routine is called for a request (Retrying</span>
01804 <span class="comment">    FALSE), we automatically make the new request queue if there are other</span>
01805 <span class="comment">    requests in the queue.</span>
01806 <span class="comment"></span>
01807 <span class="comment">    Note that the ListEmpty test is important to prevent small requests from sneaking</span>
01808 <span class="comment">    in and starving large requests.</span>
01809 <span class="comment"></span>
01810 <span class="comment">Arguments:</span>
01811 <span class="comment"></span>
01812 <span class="comment">    FileObject - for the file to be written</span>
01813 <span class="comment"></span>
01814 <span class="comment">    BytesToWrite - Number of bytes caller wishes to write to the Cache.</span>
01815 <span class="comment"></span>
01816 <span class="comment">    Wait - TRUE if the caller owns no resources, and can block inside this routine</span>
01817 <span class="comment">           until it is ok to write.</span>
01818 <span class="comment"></span>
01819 <span class="comment">    Retrying - Specified as FALSE when the request is first received, and</span>
01820 <span class="comment">               otherwise specified as TRUE if this write has already entered</span>
01821 <span class="comment">               the queue.  Special non-zero value of MAXUCHAR indicates that</span>
01822 <span class="comment">               we were called within the cache manager with a MasterSpinLock held,</span>
01823 <span class="comment">               so do not attempt to acquire it here.  MAXUCHAR - 1 means we</span>
01824 <span class="comment">               were called within the Cache Manager with some other spinlock</span>
01825 <span class="comment">               held.  For either of these two special values, we do not touch</span>
01826 <span class="comment">               the FsRtl header.</span>
01827 <span class="comment"></span>
01828 <span class="comment">Return Value:</span>
01829 <span class="comment"></span>
01830 <span class="comment">    TRUE if it is ok to write.</span>
01831 <span class="comment">    FALSE if the caller should defer the write via a call to CcDeferWrite.</span>
01832 <span class="comment"></span>
01833 <span class="comment">--*/</span>
01834 
01835 {
01836     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap;
01837     <a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a> <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>;
01838     KIRQL OldIrql;
01839     ULONG PagesToWrite;
01840     BOOLEAN ExceededPerFileThreshold;
01841     <a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html">DEFERRED_WRITE</a> DeferredWrite;
01842     <a class="code" href="../../d7/d0/struct__SECTION__OBJECT__POINTERS.html">PSECTION_OBJECT_POINTERS</a> SectionObjectPointers;
01843 
01844     <span class="comment">//</span>
01845     <span class="comment">//  Do a special test here for file objects that keep track of dirty</span>
01846     <span class="comment">//  pages on a per-file basis.  This is used mainly for slow links.</span>
01847     <span class="comment">//</span>
01848 
01849     ExceededPerFileThreshold = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01850 
01851     PagesToWrite = ((BytesToWrite &lt; <a class="code" href="../../d5/d5/cc_8h.html#a34">WRITE_CHARGE_THRESHOLD</a> ?
01852                      BytesToWrite : <a class="code" href="../../d5/d5/cc_8h.html#a34">WRITE_CHARGE_THRESHOLD</a>) + (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1)) / <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
01853 
01854     <span class="comment">//</span>
01855     <span class="comment">//  Don't dereference the FsContext field if we were called while holding</span>
01856     <span class="comment">//  a spinlock.</span>
01857     <span class="comment">//</span>
01858 
01859     <span class="keywordflow">if</span> ((Retrying &gt;= MAXUCHAR - 1) ||
01860 
01861         <a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(((<a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html">PFSRTL_COMMON_FCB_HEADER</a>)(FileObject-&gt;FsContext))-&gt;Flags,
01862                <a class="code" href="../../d1/d8/fsrtl_8h.html#a2">FSRTL_FLAG_LIMIT_MODIFIED_PAGES</a>)) {
01863 
01864         <span class="keywordflow">if</span> (Retrying != MAXUCHAR) {
01865             <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
01866         }
01867 
01868         <span class="keywordflow">if</span> (((SectionObjectPointers = FileObject-&gt;SectionObjectPointer) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
01869             ((SharedCacheMap = SectionObjectPointers-&gt;<a class="code" href="../../d7/d0/struct__SECTION__OBJECT__POINTERS.html#o1">SharedCacheMap</a>) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
01870             (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o32">DirtyPageThreshold</a> != 0) &amp;&amp;
01871             (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o20">DirtyPages</a> != 0) &amp;&amp;
01872             ((PagesToWrite + SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o20">DirtyPages</a>) &gt;
01873               SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o32">DirtyPageThreshold</a>)) {
01874 
01875             ExceededPerFileThreshold = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01876         }
01877 
01878         <span class="keywordflow">if</span> (Retrying != MAXUCHAR) {
01879             <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
01880         }
01881     }
01882 
01883     <span class="comment">//</span>
01884     <span class="comment">//  See if it is ok to do the write right now</span>
01885     <span class="comment">//</span>
01886 
01887     <span class="keywordflow">if</span> ((Retrying || IsListEmpty(&amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a29">CcDeferredWrites</a>))
01888 
01889                 &amp;&amp;
01890 
01891         (<a class="code" href="../../d5/d2/cachedat_8c.html#a36">CcTotalDirtyPages</a> + PagesToWrite &lt; <a class="code" href="../../d5/d2/cachedat_8c.html#a30">CcDirtyPageThreshold</a>)
01892 
01893                 &amp;&amp;
01894 
01895         <a class="code" href="../../d2/d1/mm_8h.html#a23">MmEnoughMemoryForWrite</a>()
01896 
01897                 &amp;&amp;
01898 
01899         !ExceededPerFileThreshold) {
01900 
01901         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01902     }
01903 
01904     <span class="comment">//</span>
01905     <span class="comment">//  Otherwise, if our caller is synchronous, we will just wait here.</span>
01906     <span class="comment">//</span>
01907 
01908     <span class="keywordflow">if</span> (IsListEmpty(&amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a29">CcDeferredWrites</a>) ) {
01909 
01910         <span class="comment">//</span>
01911         <span class="comment">// Get a write scan to occur NOW</span>
01912         <span class="comment">//</span>
01913 
01914         <a class="code" href="../../d3/d2/timerobj_8c.html#a6">KeSetTimer</a>( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o4">ScanTimer</a>, <a class="code" href="../../d5/d2/cachedat_8c.html#a13">CcNoDelay</a>, &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o3">ScanDpc</a> );
01915     }
01916 
01917     <span class="keywordflow">if</span> (Wait) {
01918 
01919         <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( &amp;<a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>, NotificationEvent, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
01920 
01921         <span class="comment">//</span>
01922         <span class="comment">//  Fill in the block.  Note that we can access the Fsrtl Common Header</span>
01923         <span class="comment">//  even if it's paged because Wait will be FALSE if called from</span>
01924         <span class="comment">//  within the cache.</span>
01925         <span class="comment">//</span>
01926 
01927         DeferredWrite.<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o0">NodeTypeCode</a> = <a class="code" href="../../d5/d5/cc_8h.html#a15">CACHE_NTC_DEFERRED_WRITE</a>;
01928         DeferredWrite.<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o1">NodeByteSize</a> = <span class="keyword">sizeof</span>(<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html">DEFERRED_WRITE</a>);
01929         DeferredWrite.<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o2">FileObject</a> = FileObject;
01930         DeferredWrite.<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o3">BytesToWrite</a> = BytesToWrite;
01931         DeferredWrite.<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o5">Event</a> = &amp;<a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>;
01932         DeferredWrite.<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o9">LimitModifiedPages</a> = <a class="code" href="../../d5/d5/cc_8h.html#a59">BooleanFlagOn</a>(((<a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html">PFSRTL_COMMON_FCB_HEADER</a>)(FileObject-&gt;FsContext))-&gt;Flags,
01933                                                          <a class="code" href="../../d1/d8/fsrtl_8h.html#a2">FSRTL_FLAG_LIMIT_MODIFIED_PAGES</a>);
01934 
01935         <span class="comment">//</span>
01936         <span class="comment">//  Now insert at the appropriate end of the list</span>
01937         <span class="comment">//</span>
01938 
01939         <span class="keywordflow">if</span> (Retrying) {
01940             <a class="code" href="../../d5/d8/ex_8h.html#a237">ExInterlockedInsertHeadList</a>( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a29">CcDeferredWrites</a>,
01941                                          &amp;DeferredWrite.<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o4">DeferredWriteLinks</a>,
01942                                          &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a28">CcDeferredWriteSpinLock</a> );
01943         } <span class="keywordflow">else</span> {
01944             <a class="code" href="../../d5/d8/ex_8h.html#a238">ExInterlockedInsertTailList</a>( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a29">CcDeferredWrites</a>,
01945                                          &amp;DeferredWrite.<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o4">DeferredWriteLinks</a>,
01946                                          &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a28">CcDeferredWriteSpinLock</a> );
01947         }
01948 
01949         <span class="keywordflow">while</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
01950 
01951             <span class="comment">//</span>
01952             <span class="comment">//  Now since we really didn't synchronize anything but the insertion,</span>
01953             <span class="comment">//  we call the post routine to make sure that in some wierd case we</span>
01954             <span class="comment">//  do not leave anyone hanging with no dirty bytes for the Lazy Writer.</span>
01955             <span class="comment">//</span>
01956 
01957             <a class="code" href="../../d5/d5/cc_8h.html#a174">CcPostDeferredWrites</a>();
01958 
01959             <span class="comment">//</span>
01960             <span class="comment">//  Finally wait until the event is signalled and we can write</span>
01961             <span class="comment">//  and return to tell the guy he can write.</span>
01962             <span class="comment">//</span>
01963 
01964             <span class="keywordflow">if</span> (<a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;<a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>,
01965                                        <a class="code" href="../../d6/d7/halmips_8h.html#a455">Executive</a>,
01966                                        <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
01967                                        <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
01968                                        &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a15">CcIdleDelay</a> ) == STATUS_SUCCESS) {
01969 
01970 
01971                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01972             }
01973         }
01974 
01975     } <span class="keywordflow">else</span> {
01976         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01977     }
01978 }
01979 
01980 
01981 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01982"></a><a class="code" href="../../d4/d2/cache_8h.html#a73">01982</a> <a class="code" href="../../d4/d2/cache_8h.html#a73">CcDeferWrite</a> (
01983     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
01984     IN PCC_POST_DEFERRED_WRITE PostRoutine,
01985     IN PVOID Context1,
01986     IN PVOID Context2,
01987     IN ULONG BytesToWrite,
01988     IN BOOLEAN Retrying
01989     )
01990 
01991 <span class="comment">/*++</span>
01992 <span class="comment"></span>
01993 <span class="comment">Routine Description:</span>
01994 <span class="comment"></span>
01995 <span class="comment">    This routine may be called to have the Cache Manager defer posting</span>
01996 <span class="comment">    of a write until the Lazy Writer makes some progress writing, or</span>
01997 <span class="comment">    there are more available pages.  A file system would normally call</span>
01998 <span class="comment">    this routine after receiving FALSE from CcCanIWrite, and preparing</span>
01999 <span class="comment">    the request to be posted.</span>
02000 <span class="comment"></span>
02001 <span class="comment">Arguments:</span>
02002 <span class="comment"></span>
02003 <span class="comment">    FileObject - for the file to be written</span>
02004 <span class="comment"></span>
02005 <span class="comment">    PostRoutine - Address of the PostRoutine that the Cache Manager can</span>
02006 <span class="comment">                  call to post the request when conditions are right.  Note</span>
02007 <span class="comment">                  that it is possible that this routine will be called</span>
02008 <span class="comment">                  immediately from this routine.</span>
02009 <span class="comment"></span>
02010 <span class="comment">    Context1 - First context parameter for the post routine.</span>
02011 <span class="comment"></span>
02012 <span class="comment">    Context2 - Secont parameter for the post routine.</span>
02013 <span class="comment"></span>
02014 <span class="comment">    BytesToWrite - Number of bytes that the request is trying to write</span>
02015 <span class="comment">                   to the cache.</span>
02016 <span class="comment"></span>
02017 <span class="comment">    Retrying - Supplied as FALSE if the request is being posted for the</span>
02018 <span class="comment">               first time, TRUE otherwise.</span>
02019 <span class="comment"></span>
02020 <span class="comment">Return Value:</span>
02021 <span class="comment"></span>
02022 <span class="comment">    None</span>
02023 <span class="comment"></span>
02024 <span class="comment">--*/</span>
02025 
02026 {
02027     <a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html">PDEFERRED_WRITE</a> DeferredWrite;
02028     KIRQL OldIrql;
02029 
02030     <span class="comment">//</span>
02031     <span class="comment">//  Attempt to allocate a deferred write block, and if we do not get</span>
02032     <span class="comment">//  one, just post it immediately rather than gobbling up must succeed</span>
02033     <span class="comment">//  pool.</span>
02034     <span class="comment">//</span>
02035 
02036     DeferredWrite = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, <span class="keyword">sizeof</span>(<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html">DEFERRED_WRITE</a>), 'wDcC' );
02037 
02038     <span class="keywordflow">if</span> (DeferredWrite == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02039         (*PostRoutine)( <a class="code" href="../../d3/d1/threads_8h.html#a107">Context1</a>, <a class="code" href="../../d3/d1/threads_8h.html#a108">Context2</a> );
02040         <span class="keywordflow">return</span>;
02041     }
02042 
02043     <span class="comment">//</span>
02044     <span class="comment">//  Fill in the block.</span>
02045     <span class="comment">//</span>
02046 
02047     DeferredWrite-&gt;<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o0">NodeTypeCode</a> = <a class="code" href="../../d5/d5/cc_8h.html#a15">CACHE_NTC_DEFERRED_WRITE</a>;
02048     DeferredWrite-&gt;<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o1">NodeByteSize</a> = <span class="keyword">sizeof</span>(<a class="code" href="../../d5/d5/cc_8h.html#a113">DEFERRED_WRITE</a>);
02049     DeferredWrite-&gt;<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o2">FileObject</a> = FileObject;
02050     DeferredWrite-&gt;<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o3">BytesToWrite</a> = BytesToWrite;
02051     DeferredWrite-&gt;<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o5">Event</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02052     DeferredWrite-&gt;<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o6">PostRoutine</a> = PostRoutine;
02053     DeferredWrite-&gt;<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o7">Context1</a> = <a class="code" href="../../d3/d1/threads_8h.html#a107">Context1</a>;
02054     DeferredWrite-&gt;<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o8">Context2</a> = <a class="code" href="../../d3/d1/threads_8h.html#a108">Context2</a>;
02055     DeferredWrite-&gt;<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o9">LimitModifiedPages</a> = <a class="code" href="../../d5/d5/cc_8h.html#a59">BooleanFlagOn</a>(((<a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html">PFSRTL_COMMON_FCB_HEADER</a>)(FileObject-&gt;FsContext))-&gt;Flags,
02056                                                       <a class="code" href="../../d1/d8/fsrtl_8h.html#a2">FSRTL_FLAG_LIMIT_MODIFIED_PAGES</a>);
02057 
02058     <span class="comment">//</span>
02059     <span class="comment">//  Now insert at the appropriate end of the list</span>
02060     <span class="comment">//</span>
02061 
02062     <span class="keywordflow">if</span> (Retrying) {
02063         <a class="code" href="../../d5/d8/ex_8h.html#a237">ExInterlockedInsertHeadList</a>( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a29">CcDeferredWrites</a>,
02064                                      &amp;DeferredWrite-&gt;<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o4">DeferredWriteLinks</a>,
02065                                      &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a28">CcDeferredWriteSpinLock</a> );
02066     } <span class="keywordflow">else</span> {
02067         <a class="code" href="../../d5/d8/ex_8h.html#a238">ExInterlockedInsertTailList</a>( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a29">CcDeferredWrites</a>,
02068                                      &amp;DeferredWrite-&gt;<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o4">DeferredWriteLinks</a>,
02069                                      &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a28">CcDeferredWriteSpinLock</a> );
02070     }
02071 
02072     <span class="comment">//</span>
02073     <span class="comment">//  Now since we really didn't synchronize anything but the insertion,</span>
02074     <span class="comment">//  we call the post routine to make sure that in some wierd case we</span>
02075     <span class="comment">//  do not leave anyone hanging with no dirty bytes for the Lazy Writer.</span>
02076     <span class="comment">//</span>
02077 
02078     <a class="code" href="../../d5/d5/cc_8h.html#a174">CcPostDeferredWrites</a>();
02079 
02080     <span class="comment">//</span>
02081     <span class="comment">//  Schedule the lazy writer in case the reason we're blocking</span>
02082     <span class="comment">//  is that we're waiting for Mm (or some other external flag)</span>
02083     <span class="comment">//  to lower and let this write happen.  He will be the one to</span>
02084     <span class="comment">//  keep coming back and checking if this can proceed, even if</span>
02085     <span class="comment">//  there are no cache manager pages to write.</span>
02086     <span class="comment">//</span>
02087             
02088     <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql);
02089             
02090     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o5">ScanActive</a>) {
02091         <a class="code" href="../../d5/d5/cc_8h.html#a185">CcScheduleLazyWriteScan</a>();
02092     }
02093 
02094     <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql);
02095 }
02096 
02097 
02098 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l02099"></a><a class="code" href="../../d5/d7/copysup_8c.html#a8">02099</a> <a class="code" href="../../d5/d5/cc_8h.html#a174">CcPostDeferredWrites</a> (
02100     )
02101 
02102 <span class="comment">/*++</span>
02103 <span class="comment"></span>
02104 <span class="comment">Routine Description:</span>
02105 <span class="comment"></span>
02106 <span class="comment">    This routine may be called to see if any deferred writes should be posted</span>
02107 <span class="comment">    now, and to post them.  It should be called any time the status of the</span>
02108 <span class="comment">    queue may have changed, such as when a new entry has been added, or the</span>
02109 <span class="comment">    Lazy Writer has finished writing out buffers and set them clean.</span>
02110 <span class="comment"></span>
02111 <span class="comment">Arguments:</span>
02112 <span class="comment"></span>
02113 <span class="comment">    None</span>
02114 <span class="comment"></span>
02115 <span class="comment">Return Value:</span>
02116 <span class="comment"></span>
02117 <span class="comment">    None</span>
02118 <span class="comment"></span>
02119 <span class="comment">--*/</span>
02120 
02121 {
02122     <a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html">PDEFERRED_WRITE</a> DeferredWrite;
02123     ULONG TotalBytesLetLoose = 0;
02124     KIRQL OldIrql;
02125 
02126     <span class="keywordflow">do</span> {
02127 
02128         <span class="comment">//</span>
02129         <span class="comment">//  Initially clear the deferred write structure pointer</span>
02130         <span class="comment">//  and syncrhronize.</span>
02131         <span class="comment">//</span>
02132 
02133         DeferredWrite = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02134 
02135         ExAcquireSpinLock( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a28">CcDeferredWriteSpinLock</a>, &amp;OldIrql );
02136 
02137         <span class="comment">//</span>
02138         <span class="comment">//  If the list is empty we are done.</span>
02139         <span class="comment">//</span>
02140 
02141         <span class="keywordflow">if</span> (!IsListEmpty(&amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a29">CcDeferredWrites</a>)) {
02142 
02143             PLIST_ENTRY Entry;
02144 
02145             Entry = <a class="code" href="../../d5/d2/cachedat_8c.html#a29">CcDeferredWrites</a>.Flink;
02146 
02147             <span class="keywordflow">while</span> (Entry != &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a29">CcDeferredWrites</a>) {
02148 
02149                 DeferredWrite = CONTAINING_RECORD( Entry,
02150                                                    <a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html">DEFERRED_WRITE</a>,
02151                                                    DeferredWriteLinks );
02152 
02153                 <span class="comment">//</span>
02154                 <span class="comment">//  Check for a paranoid case here that TotalBytesLetLoose</span>
02155                 <span class="comment">//  wraps.  We stop processing the list at this time.</span>
02156                 <span class="comment">//</span>
02157 
02158                 TotalBytesLetLoose += DeferredWrite-&gt;<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o3">BytesToWrite</a>;
02159 
02160                 <span class="keywordflow">if</span> (TotalBytesLetLoose &lt; DeferredWrite-&gt;<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o3">BytesToWrite</a>) {
02161 
02162                     DeferredWrite = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02163                     <span class="keywordflow">break</span>;
02164                 }
02165 
02166                 <span class="comment">//</span>
02167                 <span class="comment">//  If it is now ok to post this write, remove him from</span>
02168                 <span class="comment">//  the list.</span>
02169                 <span class="comment">//</span>
02170 
02171                 <span class="keywordflow">if</span> (<a class="code" href="../../d4/d2/cache_8h.html#a72">CcCanIWrite</a>( DeferredWrite-&gt;<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o2">FileObject</a>,
02172                                  TotalBytesLetLoose,
02173                                  <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
02174                                  MAXUCHAR - 1 )) {
02175 
02176                     RemoveEntryList( &amp;DeferredWrite-&gt;<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o4">DeferredWriteLinks</a> );
02177                     <span class="keywordflow">break</span>;
02178 
02179                 <span class="comment">//</span>
02180                 <span class="comment">//  Otherwise, it is time to stop processing the list, so</span>
02181                 <span class="comment">//  we clear the pointer again unless we throttled this item</span>
02182                 <span class="comment">//  because of a private dirty page limit.</span>
02183                 <span class="comment">//</span>
02184 
02185                 } <span class="keywordflow">else</span> {
02186 
02187                     <span class="comment">//</span>
02188                     <span class="comment">//  If this was a private throttle, skip over it and</span>
02189                     <span class="comment">//  remove its byte count from the running total.</span>
02190                     <span class="comment">//</span>
02191 
02192                     <span class="keywordflow">if</span> (DeferredWrite-&gt;<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o9">LimitModifiedPages</a>) {
02193 
02194                         Entry = Entry-&gt;Flink;
02195                         TotalBytesLetLoose -= DeferredWrite-&gt;<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o3">BytesToWrite</a>;
02196                         DeferredWrite = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02197                         <span class="keywordflow">continue</span>;
02198 
02199                     } <span class="keywordflow">else</span> {
02200 
02201                         DeferredWrite = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02202 
02203                         <span class="keywordflow">break</span>;
02204                     }
02205                 }
02206             }
02207         }
02208 
02209         ExReleaseSpinLock( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a28">CcDeferredWriteSpinLock</a>, OldIrql );
02210 
02211         <span class="comment">//</span>
02212         <span class="comment">//  If we got something, set the event or call the post routine</span>
02213         <span class="comment">//  and deallocate the structure.</span>
02214         <span class="comment">//</span>
02215 
02216         <span class="keywordflow">if</span> (DeferredWrite != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02217 
02218             <span class="keywordflow">if</span> (DeferredWrite-&gt;<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o5">Event</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02219 
02220                 <a class="code" href="../../d2/d8/eventobj_8c.html#a8">KeSetEvent</a>( DeferredWrite-&gt;<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o5">Event</a>, 0, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
02221 
02222             } <span class="keywordflow">else</span> {
02223 
02224                 (*DeferredWrite-&gt;<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o6">PostRoutine</a>)( DeferredWrite-&gt;<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o7">Context1</a>,
02225                                                DeferredWrite-&gt;<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o8">Context2</a> );
02226                 <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( DeferredWrite );
02227             }
02228         }
02229 
02230     <span class="comment">//</span>
02231     <span class="comment">//  Loop until we find no more work to do.</span>
02232     <span class="comment">//</span>
02233 
02234     } <span class="keywordflow">while</span> (DeferredWrite != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
02235 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:39:34 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
