<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: poolhack.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>poolhack.c</h1><a href="../../d5/d2/poolhack_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1989  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    pool.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    Implementation of the binary buddy pool allocator for the NT executive.</span>
00012 <span class="comment"></span>
00013 <span class="comment">Author:</span>
00014 <span class="comment"></span>
00015 <span class="comment">    Mark Lucovsky     16-feb-1989</span>
00016 <span class="comment"></span>
00017 <span class="comment">Environment:</span>
00018 <span class="comment"></span>
00019 <span class="comment">    kernel mode only</span>
00020 <span class="comment"></span>
00021 <span class="comment">Revision History:</span>
00022 <span class="comment"></span>
00023 <span class="comment">--*/</span>
00024 
00025 
00026 <span class="preprocessor">#if DBG</span>
00027 <span class="preprocessor"></span><span class="comment">//#define TRACE_ALLOC 1</span>
00028 
00029 <span class="preprocessor">#ifdef i386</span>
00030 <span class="preprocessor"></span><span class="preprocessor">#define DEADBEEF 1</span>
00031 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00032 <span class="preprocessor"></span>
00033 <span class="preprocessor">#endif // DBG</span>
00034 <span class="preprocessor"></span>
00035 <span class="preprocessor">#include "<a class="code" href="../../d4/d0/exp_8h.html">exp.h</a>"</span>
00036 <span class="preprocessor">#include "..\mm\mi.h"</span>
00037 
00038 <span class="comment">//</span>
00039 <span class="comment">// Global Variables</span>
00040 <span class="comment">//</span>
00041 
00042 <span class="preprocessor">#ifdef TRACE_ALLOC</span>
00043 <span class="preprocessor"></span>PULONG RtlpGetFramePointer(VOID);
00044 
00045 <a class="code" href="../../d8/d7/struct__KSEMAPHORE.html">KSEMAPHORE</a> TracePoolLock;
00046 LIST_ENTRY TracePoolListHead[<a class="code" href="../../d5/d8/ex_8h.html#a329a180">MaxPoolType</a>];
00047 
00048 <span class="keyword">typedef</span> <span class="keyword">struct </span>_TRACEBUFF {
00049     PVOID BufferAddress;
00050     <a class="code" href="../../d5/d6/struct__ETHREAD.html">PETHREAD</a> Thread;
00051     PULONG xR1;
00052     PULONG xPrevR1;
00053 } TRACEBUFF, *PTRACEBUFF;
00054 
00055 <span class="preprocessor">#define MAXTRACE 1024</span>
00056 <span class="preprocessor"></span>
00057 ULONG NextAllocTrace;
00058 ULONG NextDeallocTrace;
00059 
00060 TRACEBUFF AllocTrace[MAXTRACE];
00061 TRACEBUFF DeallocTrace[MAXTRACE];
00062 
00063 
00064 <span class="preprocessor">#endif //TRACE_ALLOC</span>
00065 <span class="preprocessor"></span>
<a name="l00066"></a><a class="code" href="../../d5/d2/poolhack_8c.html#a0">00066</a> <span class="preprocessor">#define POOL_PAGE_SIZE  0x1000</span>
<a name="l00067"></a><a class="code" href="../../d5/d2/poolhack_8c.html#a1">00067</a> <span class="preprocessor"></span><span class="preprocessor">#define POOL_LOG_PAGE   12</span>
<a name="l00068"></a><a class="code" href="../../d5/d2/poolhack_8c.html#a2">00068</a> <span class="preprocessor"></span><span class="preprocessor">#define POOL_LIST_HEADS 8</span>
<a name="l00069"></a><a class="code" href="../../d5/d2/poolhack_8c.html#a3">00069</a> <span class="preprocessor"></span><span class="preprocessor">#define POOL_LOG_MIN    (POOL_LOG_PAGE - POOL_LIST_HEADS + 1)</span>
<a name="l00070"></a><a class="code" href="../../d5/d2/poolhack_8c.html#a4">00070</a> <span class="preprocessor"></span><span class="preprocessor">#define POOL_MIN_ROUND  ( (1&lt;&lt;POOL_LOG_MIN) - 1 )</span>
<a name="l00071"></a><a class="code" href="../../d5/d2/poolhack_8c.html#a5">00071</a> <span class="preprocessor"></span><span class="preprocessor">#define PAGE_ALIGNED(p) (!(((ULONG)p) &amp; (POOL_PAGE_SIZE - 1)))</span>
00072 <span class="preprocessor"></span>
<a name="l00073"></a><a class="code" href="../../d5/d2/poolhack_8c.html#a10">00073</a> <a class="code" href="../../d1/d1/bench_8c.html#a16">CHAR</a> <a class="code" href="../../d5/d2/poolhack_8c.html#a10">PoolIndexTable</a>[128] = { 0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,
00074                              5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
00075                              6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
00076                              6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
00077                              7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
00078                              7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
00079                              7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
00080                              7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7
00081                            };
00082 
00083 <span class="comment">//</span>
00084 <span class="comment">// This structure exists in the pool descriptor structure.  There is one of</span>
00085 <span class="comment">// these for each pool block size</span>
00086 <span class="comment">//</span>
00087 
<a name="l00088"></a><a class="code" href="../../d0/d9/struct__POOL__LIST__HEAD.html">00088</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d0/d9/struct__POOL__LIST__HEAD.html">_POOL_LIST_HEAD</a> {
<a name="l00089"></a><a class="code" href="../../d0/d9/struct__POOL__LIST__HEAD.html#o0">00089</a>     ULONG <a class="code" href="../../d0/d9/struct__POOL__LIST__HEAD.html#o0">CurrentFreeLength</a>;
<a name="l00090"></a><a class="code" href="../../d0/d9/struct__POOL__LIST__HEAD.html#o1">00090</a>     ULONG <a class="code" href="../../d0/d9/struct__POOL__LIST__HEAD.html#o1">Reserved</a>;
<a name="l00091"></a><a class="code" href="../../d0/d9/struct__POOL__LIST__HEAD.html#o2">00091</a>     LIST_ENTRY <a class="code" href="../../d0/d9/struct__POOL__LIST__HEAD.html#o2">ListHead</a>;
00092 } <a class="code" href="../../d0/d9/struct__POOL__LIST__HEAD.html">POOL_LIST_HEAD</a>;
<a name="l00093"></a><a class="code" href="../../d5/d2/poolhack_8c.html#a12">00093</a> <span class="keyword">typedef</span> <a class="code" href="../../d0/d9/struct__POOL__LIST__HEAD.html">POOL_LIST_HEAD</a> *<a class="code" href="../../d0/d9/struct__POOL__LIST__HEAD.html">PPOOL_LIST_HEAD</a>;
00094 
<a name="l00095"></a><a class="code" href="../../d4/d8/struct__POOL__DESCRIPTOR.html">00095</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d4/d8/struct__POOL__DESCRIPTOR.html">_POOL_DESCRIPTOR</a> {
00096     <a class="code" href="../../d5/d8/ex_8h.html#a96">POOL_TYPE</a> <a class="code" href="../../d4/d8/struct__POOL__DESCRIPTOR.html#o0">PoolType</a>;
00097     ULONG <a class="code" href="../../d4/d8/struct__POOL__DESCRIPTOR.html#o1">TotalPages</a>;
00098     ULONG <a class="code" href="../../d4/d8/struct__POOL__DESCRIPTOR.html#o2">Threshold</a>;
00099     PVOID <a class="code" href="../../d4/d8/struct__POOL__DESCRIPTOR.html#o3">LockAddress</a>;
<a name="l00100"></a><a class="code" href="../../d4/d8/struct__POOL__DESCRIPTOR.html#o4">00100</a>     <a class="code" href="../../d0/d9/struct__POOL__LIST__HEAD.html">POOL_LIST_HEAD</a> <a class="code" href="../../d4/d8/struct__POOL__DESCRIPTOR.html#o4">ListHeads</a>[<a class="code" href="../../d5/d2/poolhack_8c.html#a2">POOL_LIST_HEADS</a>];
00101 } <a class="code" href="../../d4/d8/struct__POOL__DESCRIPTOR.html">POOL_DESCRIPTOR</a>;
<a name="l00102"></a><a class="code" href="../../d5/d2/poolhack_8c.html#a14">00102</a> <span class="keyword">typedef</span> <a class="code" href="../../d4/d8/struct__POOL__DESCRIPTOR.html">POOL_DESCRIPTOR</a> *<a class="code" href="../../d4/d8/struct__POOL__DESCRIPTOR.html">PPOOL_DESCRIPTOR</a>;
00103 
<a name="l00104"></a><a class="code" href="../../d5/d8/struct__POOL__HEADER.html">00104</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d5/d8/struct__POOL__HEADER.html">_POOL_HEADER</a> {
<a name="l00105"></a><a class="code" href="../../d5/d8/struct__POOL__HEADER.html#o0">00105</a>     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> <a class="code" href="../../d5/d8/struct__POOL__HEADER.html#o0">LogAllocationSize</a>;
<a name="l00106"></a><a class="code" href="../../d5/d8/struct__POOL__HEADER.html#o1">00106</a>     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> <a class="code" href="../../d5/d8/struct__POOL__HEADER.html#o1">PoolType</a>;
00107 <span class="preprocessor">#ifdef TRACE_ALLOC</span>
00108 <span class="preprocessor"></span>    LIST_ENTRY TraceLinks;
00109     PULONG xR1;
00110     PULONG xPrevR1;
00111 <span class="preprocessor">#endif // TRACE_ALLOC</span>
<a name="l00112"></a><a class="code" href="../../d5/d8/struct__POOL__HEADER.html#o2">00112</a> <span class="preprocessor"></span>    <a class="code" href="../../d0/d4/struct__EPROCESS.html">EPROCESS</a> *<a class="code" href="../../d5/d8/struct__POOL__HEADER.html#o2">ProcessBilled</a>;
00113 } <a class="code" href="../../d5/d8/struct__POOL__HEADER.html">POOL_HEADER</a>;
<a name="l00114"></a><a class="code" href="../../d5/d2/poolhack_8c.html#a16">00114</a> <span class="keyword">typedef</span> <a class="code" href="../../d5/d8/struct__POOL__HEADER.html">POOL_HEADER</a> *<a class="code" href="../../d5/d8/struct__POOL__HEADER.html">PPOOL_HEADER</a>;
00115 
<a name="l00116"></a><a class="code" href="../../d5/d2/poolhack_8c.html#a6">00116</a> <span class="preprocessor">#define POOL_OVERHEAD sizeof(POOL_HEADER)</span>
<a name="l00117"></a><a class="code" href="../../d5/d2/poolhack_8c.html#a7">00117</a> <span class="preprocessor"></span><span class="preprocessor">#define POOL_BUDDY_MAX (POOL_PAGE_SIZE - POOL_OVERHEAD)</span>
00118 <span class="preprocessor"></span>
<a name="l00119"></a><a class="code" href="../../d5/d2/poolhack_8c.html#a18">00119</a> <a class="code" href="../../d4/d8/struct__POOL__DESCRIPTOR.html">POOL_DESCRIPTOR</a> <a class="code" href="../../d2/d2/ex_2pool_8c.html#a52">NonPagedPoolDescriptor</a>,<a class="code" href="../../d5/d2/poolhack_8c.html#a18">PagedPoolDescriptor</a>;
<a name="l00120"></a><a class="code" href="../../d5/d2/poolhack_8c.html#a20">00120</a> <a class="code" href="../../d4/d8/struct__POOL__DESCRIPTOR.html">POOL_DESCRIPTOR</a> <a class="code" href="../../d2/d2/ex_2pool_8c.html#a53">NonPagedPoolDescriptorMS</a>,<a class="code" href="../../d5/d2/poolhack_8c.html#a20">PagedPoolDescriptorMS</a>;
00121 
<a name="l00122"></a><a class="code" href="../../d5/d2/poolhack_8c.html#a21">00122</a> KSPIN_LOCK <a class="code" href="../../d2/d2/ex_2pool_8c.html#a56">NonPagedPoolLock</a>;
<a name="l00123"></a><a class="code" href="../../d5/d2/poolhack_8c.html#a22">00123</a> <a class="code" href="../../d3/d7/struct__KMUTANT.html">KMUTEX</a> <a class="code" href="../../d5/d2/poolhack_8c.html#a22">PagedPoolLock</a>;
00124 
00125 
<a name="l00126"></a><a class="code" href="../../d5/d2/poolhack_8c.html#a23">00126</a> <a class="code" href="../../d5/d2/poolhack_8c.html#a14">PPOOL_DESCRIPTOR</a> <a class="code" href="../../d2/d2/ex_2pool_8c.html#a54">PoolVector</a>[<a class="code" href="../../d5/d8/ex_8h.html#a329a180">MaxPoolType</a>] = {
00127     &amp;<a class="code" href="../../d2/d2/ex_2pool_8c.html#a52">NonPagedPoolDescriptor</a>,
00128     &amp;<a class="code" href="../../d5/d2/poolhack_8c.html#a18">PagedPoolDescriptor</a>,
00129     &amp;<a class="code" href="../../d2/d2/ex_2pool_8c.html#a53">NonPagedPoolDescriptorMS</a>,
00130     &amp;<a class="code" href="../../d5/d2/poolhack_8c.html#a20">PagedPoolDescriptorMS</a>
00131     };
00132 
<a name="l00133"></a><a class="code" href="../../d5/d2/poolhack_8c.html#a24">00133</a> <a class="code" href="../../d5/d8/ex_8h.html#a96">POOL_TYPE</a> <a class="code" href="../../d5/d2/poolhack_8c.html#a24">BasePoolTypeTable</a>[<a class="code" href="../../d5/d8/ex_8h.html#a329a180">MaxPoolType</a>] = {
00134     <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>,
00135     <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>,
00136     <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>,
00137     <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>
00138     };
00139 
<a name="l00140"></a><a class="code" href="../../d5/d2/poolhack_8c.html#a25">00140</a> BOOLEAN <a class="code" href="../../d5/d2/poolhack_8c.html#a25">MustSucceedPoolTable</a>[<a class="code" href="../../d5/d8/ex_8h.html#a329a180">MaxPoolType</a>] = {
00141     <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00142     <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00143     <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
00144     <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>
00145     };
00146 
00147 
00148 <a class="code" href="../../d5/d2/poolhack_8c.html#a16">PPOOL_HEADER</a>
00149 <a class="code" href="../../d5/d2/poolhack_8c.html#a26">AllocatePoolInternal</a>(
00150     IN PPOOL_DESCRIPTOR PoolDesc,
00151     IN LONG Index
00152     );
00153 
00154 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00155 <a class="code" href="../../d5/d2/poolhack_8c.html#a27">DeallocatePoolInternal</a>(
00156     IN PPOOL_DESCRIPTOR PoolDesc,
00157     IN PPOOL_HEADER Entry
00158     );
00159 
00160 PLIST_ENTRY
00161 <a class="code" href="../../d5/d2/poolhack_8c.html#a28">ExpInterlockedTryAllocatePool</a>(
00162     IN PLIST_ENTRY List,
00163     IN KSPIN_LOCK Lock,
00164     IN ULONG Size,
00165     IN LONG SizeOffset
00166     );
00167 
00168 
00169 <span class="comment">//</span>
00170 <span class="comment">// LOCK_POOL is used as a macro only within this module</span>
00171 <span class="comment">//</span>
00172 
<a name="l00173"></a><a class="code" href="../../d5/d2/poolhack_8c.html#a8">00173</a> <span class="preprocessor">#define LOCK_POOL(Lock,PoolType,LockHandle)                                   \</span>
00174 <span class="preprocessor">    {                                                                         \</span>
00175 <span class="preprocessor">        if ( (PoolType) == (NonPagedPool) || (PoolType) == NonPagedPoolMustSucceed ) {                                 \</span>
00176 <span class="preprocessor">            KeAcquireSpinLock((PKSPIN_LOCK)Lock,&amp;LockHandle);                 \</span>
00177 <span class="preprocessor">        } else {                                                              \</span>
00178 <span class="preprocessor">            KeRaiseIrql(APC_LEVEL,&amp;LockHandle);                               \</span>
00179 <span class="preprocessor">            KeWaitForSingleObject(                                            \</span>
00180 <span class="preprocessor">                Lock,                                                         \</span>
00181 <span class="preprocessor">                PoolAllocation,                                               \</span>
00182 <span class="preprocessor">                KernelMode,                                                   \</span>
00183 <span class="preprocessor">                FALSE,                                                        \</span>
00184 <span class="preprocessor">                NULL                                                          \</span>
00185 <span class="preprocessor">                );                                                            \</span>
00186 <span class="preprocessor">        }                                                                     \</span>
00187 <span class="preprocessor">    }</span>
00188 <span class="preprocessor"></span>
00189 KIRQL
<a name="l00190"></a><a class="code" href="../../d5/d2/poolhack_8c.html#a29">00190</a> <a class="code" href="../../d5/d8/ex_8h.html#a226">ExLockPool</a>(
00191     IN POOL_TYPE PoolType
00192     )
00193 
00194 <span class="comment">/*++</span>
00195 <span class="comment"></span>
00196 <span class="comment">Routine Description:</span>
00197 <span class="comment"></span>
00198 <span class="comment">    This function locks the pool specified by pool type.</span>
00199 <span class="comment"></span>
00200 <span class="comment">Arguments:</span>
00201 <span class="comment"></span>
00202 <span class="comment">    PoolType - Specifies the pool that should be locked.</span>
00203 <span class="comment"></span>
00204 <span class="comment">Return Value:</span>
00205 <span class="comment"></span>
00206 <span class="comment">    Opaque - Returns a lock handle that must be returned in a subsequent</span>
00207 <span class="comment">             call to ExUnlockPool.</span>
00208 <span class="comment"></span>
00209 <span class="comment">--*/</span>
00210 
00211 {
00212 
00213     KIRQL Irql;
00214 
00215     <span class="keywordflow">if</span> ( PoolType == <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a> || PoolType == <a class="code" href="../../d5/d8/ex_8h.html#a329a175">NonPagedPoolMustSucceed</a> ) {
00216 
00217         <span class="comment">//</span>
00218         <span class="comment">// Spin Lock locking</span>
00219         <span class="comment">//</span>
00220 
00221         <a class="code" href="../../d4/d9/ke_8h.html#a37">KeAcquireSpinLock</a>((PKSPIN_LOCK)<a class="code" href="../../d2/d2/ex_2pool_8c.html#a54">PoolVector</a>[PoolType]-&gt;LockAddress, &amp;Irql);
00222         <span class="keywordflow">return</span> Irql;
00223     } <span class="keywordflow">else</span> {
00224 
00225         <span class="comment">//</span>
00226         <span class="comment">// Mutex Locking</span>
00227         <span class="comment">//</span>
00228 
00229         <a class="code" href="../../d9/d5/verifier_8c.html#a116">KeRaiseIrql</a>(<a class="code" href="../../d6/d7/halmips_8h.html#a52">APC_LEVEL</a>, &amp;Irql);
00230 
00231         <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>(
00232             <a class="code" href="../../d2/d2/ex_2pool_8c.html#a54">PoolVector</a>[PoolType]-&gt;LockAddress,
00233             <a class="code" href="../../d4/d9/ke_8h.html#a407a201">PoolAllocation</a>,
00234             <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
00235             <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00236             <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>
00237             );
00238 
00239         <span class="keywordflow">return</span> Irql;
00240     }
00241 
00242 }
00243 
00244 <span class="comment">//</span>
00245 <span class="comment">// UNLOCK_POOL is used as a macro only within this module</span>
00246 <span class="comment">//</span>
00247 
<a name="l00248"></a><a class="code" href="../../d5/d2/poolhack_8c.html#a9">00248</a> <span class="preprocessor">#define UNLOCK_POOL(Lock,PoolType,LockHandle,Wait)                               \</span>
00249 <span class="preprocessor">    {                                                                       \</span>
00250 <span class="preprocessor">        if ( PoolType == NonPagedPool || (PoolType) == NonPagedPoolMustSucceed ) {                                   \</span>
00251 <span class="preprocessor">            KeReleaseSpinLock(                                              \</span>
00252 <span class="preprocessor">                Lock,                                                       \</span>
00253 <span class="preprocessor">                (KIRQL)LockHandle                                           \</span>
00254 <span class="preprocessor">                );                                                          \</span>
00255 <span class="preprocessor">        } else {                                                            \</span>
00256 <span class="preprocessor">            KeReleaseMutex((PKMUTEX)Lock,Wait);                             \</span>
00257 <span class="preprocessor">            KeLowerIrql(LockHandle);                                        \</span>
00258 <span class="preprocessor">        }                                                                   \</span>
00259 <span class="preprocessor">    }</span>
00260 <span class="preprocessor"></span>
00261 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00262"></a><a class="code" href="../../d5/d2/poolhack_8c.html#a30">00262</a> <a class="code" href="../../d5/d8/ex_8h.html#a227">ExUnlockPool</a>(
00263     IN POOL_TYPE PoolType,
00264     IN KIRQL LockHandle,
00265     IN BOOLEAN Wait
00266     )
00267 
00268 <span class="comment">/*++</span>
00269 <span class="comment"></span>
00270 <span class="comment">Routine Description:</span>
00271 <span class="comment"></span>
00272 <span class="comment">    This function unlocks the pool specified by pool type.  If the value</span>
00273 <span class="comment">    of the Wait parameter is true, then the pool's lock is released</span>
00274 <span class="comment">    using "wait == true".</span>
00275 <span class="comment"></span>
00276 <span class="comment"></span>
00277 <span class="comment">Arguments:</span>
00278 <span class="comment"></span>
00279 <span class="comment">    PoolType - Specifies the pool that should be unlocked.</span>
00280 <span class="comment"></span>
00281 <span class="comment">    LockHandle - Specifies the lock handle from a previous call to</span>
00282 <span class="comment">                 ExLockPool.</span>
00283 <span class="comment"></span>
00284 <span class="comment">    Wait - Supplies a boolean value that signifies whether the call to</span>
00285 <span class="comment">           ExUnlockPool will be immediately followed by a call to one of</span>
00286 <span class="comment">           the kernel Wait functions.</span>
00287 <span class="comment"></span>
00288 <span class="comment">Return Value:</span>
00289 <span class="comment"></span>
00290 <span class="comment">    None.</span>
00291 <span class="comment"></span>
00292 <span class="comment">--*/</span>
00293 
00294 {
00295 
00296     <span class="keywordflow">if</span> ( PoolType == <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a> || (PoolType) == <a class="code" href="../../d5/d8/ex_8h.html#a329a175">NonPagedPoolMustSucceed</a> ) {
00297 
00298         <span class="comment">//</span>
00299         <span class="comment">// Spin Lock locking</span>
00300         <span class="comment">//</span>
00301 
00302         <a class="code" href="../../d9/d5/verifier_8c.html#a119">KeReleaseSpinLock</a>(
00303             (PKSPIN_LOCK)<a class="code" href="../../d2/d2/ex_2pool_8c.html#a54">PoolVector</a>[PoolType]-&gt;LockAddress,
00304             LockHandle
00305             );
00306 
00307     } <span class="keywordflow">else</span> {
00308 
00309         <span class="comment">//</span>
00310         <span class="comment">// Mutex Locking</span>
00311         <span class="comment">//</span>
00312 
00313         <a class="code" href="../../d3/d5/mutntobj_8c.html#a5">KeReleaseMutex</a>((<a class="code" href="../../d3/d7/struct__KMUTANT.html">PKMUTEX</a>)<a class="code" href="../../d2/d2/ex_2pool_8c.html#a54">PoolVector</a>[PoolType]-&gt;LockAddress,Wait);
00314 
00315         <span class="comment">//</span>
00316         <span class="comment">// This could be a problem if wait == true is specified !</span>
00317         <span class="comment">//</span>
00318 
00319         <a class="code" href="../../d9/d5/verifier_8c.html#a117">KeLowerIrql</a>(LockHandle);
00320     }
00321 
00322 }
00323 
00324 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00325"></a><a class="code" href="../../d5/d2/poolhack_8c.html#a31">00325</a> <a class="code" href="../../d5/d8/ex_8h.html#a215">InitializePool</a>(
00326     IN POOL_TYPE PoolType,
00327     IN ULONG Threshold
00328     )
00329 
00330 <span class="comment">/*++</span>
00331 <span class="comment"></span>
00332 <span class="comment">Routine Description:</span>
00333 <span class="comment"></span>
00334 <span class="comment">    This procedure initializes a pool descriptor for a binary buddy pool</span>
00335 <span class="comment">    type.  Once initialized, the pool may be used for allocation and</span>
00336 <span class="comment">    deallocation.</span>
00337 <span class="comment"></span>
00338 <span class="comment">    This function should be called once for each base pool type during</span>
00339 <span class="comment">    system initialization.</span>
00340 <span class="comment"></span>
00341 <span class="comment">    Each pool descriptor contains an array of list heads for free</span>
00342 <span class="comment">    blocks.  Each list head holds blocks of a particular size.  One list</span>
00343 <span class="comment">    head contains page-sized blocks.  The other list heads contain 1/2-</span>
00344 <span class="comment">    page-sized blocks, 1/4-page-sized blocks....  A threshold is</span>
00345 <span class="comment">    associated with the page-sized list head.  The number of free blocks</span>
00346 <span class="comment">    on this list will not grow past the specified threshold.  When a</span>
00347 <span class="comment">    deallocation occurs that would cause the threshold to be exceeded,</span>
00348 <span class="comment">    the page is returned to the page-aliged pool allocator.</span>
00349 <span class="comment"></span>
00350 <span class="comment">Arguments:</span>
00351 <span class="comment"></span>
00352 <span class="comment">    PoolType - Supplies the type of pool being initialized (e.g.</span>
00353 <span class="comment">               nonpaged pool, paged pool...).</span>
00354 <span class="comment"></span>
00355 <span class="comment">    Threshold - Supplies the threshold value for the specified pool.</span>
00356 <span class="comment"></span>
00357 <span class="comment">Return Value:</span>
00358 <span class="comment"></span>
00359 <span class="comment">    None.</span>
00360 <span class="comment"></span>
00361 <span class="comment">--*/</span>
00362 
00363 {
00364     <span class="keywordtype">int</span> i;
00365     <a class="code" href="../../d5/d8/ex_8h.html#a96">POOL_TYPE</a> BasePoolType, MustSucceedPoolType;
00366 
00367     <span class="keywordflow">if</span> ( <a class="code" href="../../d5/d2/poolhack_8c.html#a25">MustSucceedPoolTable</a>[PoolType] ) {
00368         <a class="code" href="../../d9/d1/bugcheck_8c.html#a13">KeBugCheck</a>(PHASE0_INITIALIZATION_FAILED);
00369     }
00370 
00371     <span class="keywordflow">if</span> (PoolType == <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>) {
00372 
00373         BasePoolType = <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>;
00374         MustSucceedPoolType = <a class="code" href="../../d5/d8/ex_8h.html#a329a175">NonPagedPoolMustSucceed</a>;
00375 
00376         <a class="code" href="../../d4/d9/ke_8h.html#a354">KeInitializeSpinLock</a>(&amp;<a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a>()-&gt;StatisticsLock);
00377         <a class="code" href="../../d4/d9/ke_8h.html#a354">KeInitializeSpinLock</a>(&amp;<a class="code" href="../../d2/d2/ex_2pool_8c.html#a56">NonPagedPoolLock</a>);
00378         <a class="code" href="../../d2/d2/ex_2pool_8c.html#a52">NonPagedPoolDescriptor</a>.<a class="code" href="../../d4/d8/struct__POOL__DESCRIPTOR.html#o3">LockAddress</a> = (PVOID)&amp;<a class="code" href="../../d2/d2/ex_2pool_8c.html#a56">NonPagedPoolLock</a>;
00379         <a class="code" href="../../d2/d2/ex_2pool_8c.html#a53">NonPagedPoolDescriptorMS</a>.<a class="code" href="../../d4/d8/struct__POOL__DESCRIPTOR.html#o3">LockAddress</a> = (PVOID)&amp;<a class="code" href="../../d2/d2/ex_2pool_8c.html#a56">NonPagedPoolLock</a>;
00380 
00381         <a class="code" href="../../d3/d5/mutntobj_8c.html#a2">KeInitializeMutex</a>(&amp;<a class="code" href="../../d5/d2/poolhack_8c.html#a22">PagedPoolLock</a>,MUTEX_LEVEL_EX_PAGED_POOL);
00382         <a class="code" href="../../d5/d2/poolhack_8c.html#a18">PagedPoolDescriptor</a>.<a class="code" href="../../d4/d8/struct__POOL__DESCRIPTOR.html#o3">LockAddress</a> = (PVOID)&amp;<a class="code" href="../../d5/d2/poolhack_8c.html#a22">PagedPoolLock</a>;
00383         <a class="code" href="../../d5/d2/poolhack_8c.html#a20">PagedPoolDescriptorMS</a>.<a class="code" href="../../d4/d8/struct__POOL__DESCRIPTOR.html#o3">LockAddress</a> = (PVOID)&amp;<a class="code" href="../../d5/d2/poolhack_8c.html#a22">PagedPoolLock</a>;
00384 
00385 <span class="preprocessor">#ifdef TRACE_ALLOC</span>
00386 <span class="preprocessor"></span>
00387         <a class="code" href="../../d1/d6/semphobj_8c.html#a1">KeInitializeSemaphore</a>(&amp;TracePoolLock,1<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>,1<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>);
00388         InitializeListHead(&amp;TracePoolListHead[<a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>]);
00389         InitializeListHead(&amp;TracePoolListHead[<a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>]);
00390 
00391 <span class="preprocessor">#endif // TRACE_ALLOC</span>
00392 <span class="preprocessor"></span>    } <span class="keywordflow">else</span> {
00393         BasePoolType = <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>;
00394         MustSucceedPoolType = PagedPoolMustSucceed;
00395     }
00396 
00397     <a class="code" href="../../d2/d2/ex_2pool_8c.html#a54">PoolVector</a>[BasePoolType]-&gt;<a class="code" href="../../d4/d8/struct__POOL__DESCRIPTOR.html#o1">TotalPages</a> = 0;
00398     <a class="code" href="../../d2/d2/ex_2pool_8c.html#a54">PoolVector</a>[BasePoolType]-&gt;<a class="code" href="../../d4/d8/struct__POOL__DESCRIPTOR.html#o2">Threshold</a> = Threshold;
00399     <a class="code" href="../../d2/d2/ex_2pool_8c.html#a54">PoolVector</a>[BasePoolType]-&gt;<a class="code" href="../../d4/d8/struct__POOL__DESCRIPTOR.html#o0">PoolType</a> = BasePoolType;
00400     <a class="code" href="../../d2/d2/ex_2pool_8c.html#a54">PoolVector</a>[MustSucceedPoolType]-&gt;<a class="code" href="../../d4/d8/struct__POOL__DESCRIPTOR.html#o1">TotalPages</a> = 0;
00401     <a class="code" href="../../d2/d2/ex_2pool_8c.html#a54">PoolVector</a>[MustSucceedPoolType]-&gt;<a class="code" href="../../d4/d8/struct__POOL__DESCRIPTOR.html#o2">Threshold</a> = 0;
00402     <a class="code" href="../../d2/d2/ex_2pool_8c.html#a54">PoolVector</a>[MustSucceedPoolType]-&gt;<a class="code" href="../../d4/d8/struct__POOL__DESCRIPTOR.html#o0">PoolType</a> = MustSucceedPoolType;
00403     <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="../../d5/d2/poolhack_8c.html#a2">POOL_LIST_HEADS</a> ;i++ ) {
00404         InitializeListHead(&amp;<a class="code" href="../../d2/d2/ex_2pool_8c.html#a54">PoolVector</a>[BasePoolType]-&gt;ListHeads[i].ListHead);
00405         <a class="code" href="../../d2/d2/ex_2pool_8c.html#a54">PoolVector</a>[BasePoolType]-&gt;<a class="code" href="../../d4/d8/struct__POOL__DESCRIPTOR.html#o4">ListHeads</a>[i].<a class="code" href="../../d0/d9/struct__POOL__LIST__HEAD.html#o0">CurrentFreeLength</a> = 0;
00406         InitializeListHead(&amp;<a class="code" href="../../d2/d2/ex_2pool_8c.html#a54">PoolVector</a>[MustSucceedPoolType]-&gt;ListHeads[i].ListHead);
00407         <a class="code" href="../../d2/d2/ex_2pool_8c.html#a54">PoolVector</a>[MustSucceedPoolType]-&gt;<a class="code" href="../../d4/d8/struct__POOL__DESCRIPTOR.html#o4">ListHeads</a>[i].<a class="code" href="../../d0/d9/struct__POOL__LIST__HEAD.html#o0">CurrentFreeLength</a> = 0;
00408     }
00409     <span class="keywordflow">return</span>;
00410 }
00411 
00412 PVOID
<a name="l00413"></a><a class="code" href="../../d5/d2/poolhack_8c.html#a32">00413</a> <a class="code" href="../../d5/d5/cc_8h.html#a10">ExAllocatePool</a>(
00414     IN POOL_TYPE PoolType,
00415     IN ULONG NumberOfBytes
00416     )
00417 
00418 <span class="comment">/*++</span>
00419 <span class="comment"></span>
00420 <span class="comment">Routine Description:</span>
00421 <span class="comment"></span>
00422 <span class="comment">    This function allocates a block of pool of the specified type and</span>
00423 <span class="comment">    returns a pointer to the allocated block.  This function is used to</span>
00424 <span class="comment">    access both the page-aligned pools, and the binary buddy (less than</span>
00425 <span class="comment">    a page) pools.</span>
00426 <span class="comment"></span>
00427 <span class="comment">    If the number of bytes specifies a size that is too large to be</span>
00428 <span class="comment">    satisfied by the appropriate binary buddy pool, then the page-aligned</span>
00429 <span class="comment">    pool allocator is used.  The allocated block will be page-aligned</span>
00430 <span class="comment">    and a page-sized multiple.</span>
00431 <span class="comment"></span>
00432 <span class="comment">    Otherwise, the appropriate binary buddy pool is used.  The allocated</span>
00433 <span class="comment">    block will be 64-bit aligned, but will not be page aligned.  The</span>
00434 <span class="comment">    binary buddy allocator calculates the smallest block size that is a</span>
00435 <span class="comment">    power of two and that can be used to satisfy the request.  If there</span>
00436 <span class="comment">    are no blocks available of this size, then a block of the next</span>
00437 <span class="comment">    larger block size is allocated and split in half.  One piece is</span>
00438 <span class="comment">    placed back into the pool, and the other piece is used to satisfy</span>
00439 <span class="comment">    the request.  If the allocator reaches the paged-sized block list,</span>
00440 <span class="comment">    and nothing is there, the page-aligned pool allocator is called.</span>
00441 <span class="comment">    The page is added to the binary buddy pool...</span>
00442 <span class="comment"></span>
00443 <span class="comment">Arguments:</span>
00444 <span class="comment"></span>
00445 <span class="comment">    PoolType - Supplies the type of pool to allocate.  If the pool type</span>
00446 <span class="comment">        is one of the "MustSucceed" pool types, then this call will</span>
00447 <span class="comment">        always succeed and return a pointer to allocated pool.</span>
00448 <span class="comment">        Otherwise, if the system can not allocate the requested amount</span>
00449 <span class="comment">        of memory a NULL is returned.</span>
00450 <span class="comment"></span>
00451 <span class="comment">    NumberOfBytes - Supplies the number of bytes to allocate.</span>
00452 <span class="comment"></span>
00453 <span class="comment">Return Value:</span>
00454 <span class="comment"></span>
00455 <span class="comment">    NULL - The PoolType is not one of the "MustSucceed" pool types, and</span>
00456 <span class="comment">        not enough pool exists to satisfy the request.</span>
00457 <span class="comment"></span>
00458 <span class="comment">    NON-NULL - Returns a pointer to the allocated pool.</span>
00459 <span class="comment"></span>
00460 <span class="comment">--*/</span>
00461 
00462 {
00463     <a class="code" href="../../d5/d2/poolhack_8c.html#a16">PPOOL_HEADER</a> Entry;
00464     <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> CurrentProcess;
00465     KIRQL LockHandle;
00466     <a class="code" href="../../d5/d2/poolhack_8c.html#a14">PPOOL_DESCRIPTOR</a> PoolDesc;
00467     PVOID <a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>;
00468     LONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
00469     PVOID Block;
00470 
00471     KIRQL OldIrql;
00472     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
00473     ULONG PageFrameIndex;
00474     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> TempPte;
00475     BOOLEAN ReleaseSpinLock = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00476 
00477 <span class="preprocessor">#if defined(TRACE_ALLOC) || defined (DEADBEEF)</span>
00478 <span class="preprocessor"></span>
00479     PULONG BadFood;
00480 <span class="preprocessor">#endif //TRACE_ALLOC</span>
00481 <span class="preprocessor"></span>
00482 <span class="preprocessor">#ifdef TRACE_ALLOC</span>
00483 <span class="preprocessor"></span>    PULONG xFp, xPrevFp, xR1, xPrevR1, xPrevPrevR1;
00484 
00485     xFp = RtlpGetFramePointer();
00486     xR1 = (PULONG)*(xFp+1);
00487     xPrevFp = (PULONG)*xFp;
00488     xPrevR1 = (PULONG)*(xPrevFp+1);
00489     xPrevFp = (PULONG)*xPrevFp;
00490     xPrevPrevR1 = (PULONG)*(xPrevFp+1);
00491 
00492 <span class="preprocessor">#endif // TRACE_ALLOC</span>
00493 <span class="preprocessor"></span>
00494 
00495 
00496     PoolDesc = <a class="code" href="../../d2/d2/ex_2pool_8c.html#a54">PoolVector</a>[PoolType];
00497     <a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a> = PoolDesc-&gt;<a class="code" href="../../d4/d8/struct__POOL__DESCRIPTOR.html#o3">LockAddress</a>;
00498 
00499     <span class="keywordflow">if</span> (NumberOfBytes &gt; <a class="code" href="../../d5/d2/poolhack_8c.html#a7">POOL_BUDDY_MAX</a>) {
00500 
00501         <a class="code" href="../../d2/d2/ex_2pool_8c.html#a33">LOCK_POOL</a>(<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>,PoolType,LockHandle);
00502 
00503         Entry = (<a class="code" href="../../d5/d2/poolhack_8c.html#a16">PPOOL_HEADER</a>)<a class="code" href="../../d1/d6/allocpag_8c.html#a54">MiAllocatePoolPages</a> (
00504                                         <a class="code" href="../../d5/d2/poolhack_8c.html#a24">BasePoolTypeTable</a>[PoolType],
00505                                         NumberOfBytes
00506                                         );
00507         <span class="keywordflow">if</span> ( !Entry &amp;&amp; <a class="code" href="../../d5/d2/poolhack_8c.html#a25">MustSucceedPoolTable</a>[PoolType] ) {
00508             Entry = (<a class="code" href="../../d5/d2/poolhack_8c.html#a16">PPOOL_HEADER</a>)<a class="code" href="../../d1/d6/allocpag_8c.html#a54">MiAllocatePoolPages</a> (
00509                                             PoolType,
00510                                             NumberOfBytes
00511                                             );
00512         }
00513         <a class="code" href="../../d2/d2/ex_2pool_8c.html#a35">UNLOCK_POOL</a>(<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>,PoolType,LockHandle,<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
00514 
00515         <span class="keywordflow">return</span> Entry;
00516     }
00517 
00518     <span class="keywordflow">if</span> (KeGetCurrentIrql() &gt;= 2) {
00519         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"allocating pool at irql &gt;= 2\n"</span>);
00520         ReleaseSpinLock = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00521 
00522     } <span class="keywordflow">else</span> {
00523         KeAcquireQueuedSpinLock(<a class="code" href="../../d0/d9/ntosdef_8h.html#a75a64">LockQueuePfnLock</a>);
00524     }
00525 
00526     PointerPte = <a class="code" href="../../d0/d9/sysptes_8c.html#a25">MiReserveSystemPtes</a> (2, <a class="code" href="../../d4/d8/mi_8h.html#a1003a769">SystemPteSpace</a>, 0, 0, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
00527 
00528             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (<a class="code" href="../../d5/d5/cc_8h.html#a94">MmAvailablePages</a> &gt; 0);
00529             PageFrameIndex = <a class="code" href="../../d7/d5/pfnlist_8c.html#a15">MiRemoveAnyPage</a> ();
00530             TempPte = <a class="code" href="../../d4/d2/datalpha_8c.html#a2">ValidKernelPte</a>;
00531             TempPte.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber = PageFrameIndex;
00532             *PointerPte = TempPte;
00533             <a class="code" href="../../d8/d2/pagfault_8c.html#a22">MiInitializePfn</a> (PageFrameIndex, PointerPte, 1<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>, 1);
00534 
00535     <span class="keywordflow">if</span> (ReleaseSpinLock) {
00536         <a class="code" href="../../d9/d5/verifier_8c.html#a119">KeReleaseSpinLock</a> ( &amp;<a class="code" href="../../d7/d2/alpha_2initkr_8c.html#a2">MmPfnLock</a>, OldIrql );
00537     }
00538 
00539     Entry = (PVOID)<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a> (PointerPte);
00540 
00541     Entry = (PVOID)(((ULONG)Entry + (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - (NumberOfBytes))) &amp;
00542             0xfffffff8<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>);
00543 
00544     <span class="keywordflow">return</span> Entry;
00545 
00546 
00547     <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = ( (NumberOfBytes+<a class="code" href="../../d5/d2/poolhack_8c.html#a6">POOL_OVERHEAD</a>+<a class="code" href="../../d5/d2/poolhack_8c.html#a4">POOL_MIN_ROUND</a>) &gt;&gt; <a class="code" href="../../d5/d2/poolhack_8c.html#a3">POOL_LOG_MIN</a>) - 1;
00548 
00549     <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = <a class="code" href="../../d5/d2/poolhack_8c.html#a10">PoolIndexTable</a>[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>];
00550 
00551     <a class="code" href="../../d2/d2/ex_2pool_8c.html#a33">LOCK_POOL</a>(<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>,PoolType,LockHandle);
00552 
00553     <span class="keywordflow">if</span> ( !IsListEmpty(&amp;PoolDesc-&gt;<a class="code" href="../../d4/d8/struct__POOL__DESCRIPTOR.html#o4">ListHeads</a>[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].ListHead) ) {
00554 
00555         Block = RemoveHeadList(&amp;PoolDesc-&gt;<a class="code" href="../../d4/d8/struct__POOL__DESCRIPTOR.html#o4">ListHeads</a>[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].ListHead);
00556         Entry = (<a class="code" href="../../d5/d2/poolhack_8c.html#a16">PPOOL_HEADER</a>) ((PCH)Block - <a class="code" href="../../d5/d2/poolhack_8c.html#a6">POOL_OVERHEAD</a>);
00557         Entry-&gt;<a class="code" href="../../d5/d8/struct__POOL__HEADER.html#o2">ProcessBilled</a> = (<a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a>)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00558         Entry-&gt;<a class="code" href="../../d5/d8/struct__POOL__HEADER.html#o0">LogAllocationSize</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)<a class="code" href="../../d5/d2/poolhack_8c.html#a3">POOL_LOG_MIN</a> + <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
00559         Entry-&gt;<a class="code" href="../../d5/d8/struct__POOL__HEADER.html#o1">PoolType</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)PoolType;
00560 <span class="preprocessor">#if defined(TRACE_ALLOC) || defined (DEADBEEF)</span>
00561 <span class="preprocessor"></span>        BadFood = (PULONG)Block;
00562         *BadFood = 0xBAADF00D;
00563         *(BadFood+1) = 0xBAADF00D;
00564 <span class="preprocessor">#endif // TRACE_ALLOC</span>
00565 <span class="preprocessor"></span>
00566     } <span class="keywordflow">else</span> {
00567 
00568         Entry = <a class="code" href="../../d5/d2/poolhack_8c.html#a26">AllocatePoolInternal</a>(PoolDesc,<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>);
00569 
00570         <span class="keywordflow">if</span> ( !Entry ) {
00571 <span class="preprocessor">#if DBG</span>
00572 <span class="preprocessor"></span>            <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"EX: ExAllocatePool returning NULL\n"</span>);
00573             DbgBreakPoint();
00574 <span class="preprocessor">#endif // DBG</span>
00575 <span class="preprocessor"></span>            <a class="code" href="../../d2/d2/ex_2pool_8c.html#a35">UNLOCK_POOL</a>(<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>,PoolType,LockHandle,<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
00576             <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00577         }
00578     }
00579 
00580     <a class="code" href="../../d2/d2/ex_2pool_8c.html#a35">UNLOCK_POOL</a>(<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>,PoolType,LockHandle,<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
00581 
00582 <span class="preprocessor">#ifdef TRACE_ALLOC</span>
00583 <span class="preprocessor"></span>        {
00584                 KIRQL xIrql;
00585 
00586                 <a class="code" href="../../d9/d5/verifier_8c.html#a116">KeRaiseIrql</a>(<a class="code" href="../../d6/d7/halmips_8h.html#a52">APC_LEVEL</a>, &amp;xIrql);
00587 
00588                 <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>(
00589                     &amp;TracePoolLock,
00590                     <a class="code" href="../../d4/d9/ke_8h.html#a407a201">PoolAllocation</a>,
00591                     <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
00592                     <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00593                     <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>
00594                     );
00595 
00596                 InsertTailList(&amp;TracePoolListHead[PoolType],&amp;Entry-&gt;TraceLinks);
00597 
00598                 Entry-&gt;xR1 = xR1;
00599                 Entry-&gt;xPrevR1 = xPrevR1;
00600                 Entry-&gt;<a class="code" href="../../d5/d8/struct__POOL__HEADER.html#o2">ProcessBilled</a> = (<a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a>)xPrevPrevR1;
00601 
00602                 <span class="comment">//Entry-&gt;ProcessBilled = (PEPROCESS)NextAllocTrace;</span>
00603 
00604                 AllocTrace[NextAllocTrace].BufferAddress = (PCH)Entry + <a class="code" href="../../d5/d2/poolhack_8c.html#a6">POOL_OVERHEAD</a>;
00605                 AllocTrace[NextAllocTrace].Thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
00606                 AllocTrace[NextAllocTrace].xR1 = xR1;
00607                 AllocTrace[NextAllocTrace++].xPrevR1 = xPrevR1;
00608                 <span class="keywordflow">if</span> ( NextAllocTrace &gt;= MAXTRACE ) {
00609                     NextAllocTrace = 0;
00610                 }
00611 
00612 
00613                 (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d1/d6/semphobj_8c.html#a3">KeReleaseSemaphore</a>(
00614                             &amp;TracePoolLock,
00615                             0<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>,
00616                             1<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>,
00617                             <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>
00618                             );
00619                 <a class="code" href="../../d9/d5/verifier_8c.html#a117">KeLowerIrql</a>(xIrql);
00620 
00621         }
00622 <span class="preprocessor">#endif // TRACE_ALLOC</span>
00623 <span class="preprocessor"></span>
00624 <span class="preprocessor">#if defined(TRACE_ALLOC) || defined (DEADBEEF)</span>
00625 <span class="preprocessor"></span>    {
00626         PULONG NewPool;
00627         ULONG LongCount;
00628 
00629         Block = (PULONG)((PCH)Entry + <a class="code" href="../../d5/d2/poolhack_8c.html#a6">POOL_OVERHEAD</a>);
00630         NewPool = (PULONG) ((PCH)Entry + <a class="code" href="../../d5/d2/poolhack_8c.html#a6">POOL_OVERHEAD</a>);
00631         LongCount = (1 &lt;&lt; Entry-&gt;<a class="code" href="../../d5/d8/struct__POOL__HEADER.html#o0">LogAllocationSize</a>) &gt;&gt; 2;
00632         LongCount -= (<a class="code" href="../../d5/d2/poolhack_8c.html#a6">POOL_OVERHEAD</a>&gt;&gt;2);
00633 
00634         <span class="keywordflow">while</span>(LongCount--) {
00635             <span class="keywordflow">if</span> ( *NewPool != 0xBAADF00D ) {
00636                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"ExAllocatePool: No BAADF00D Block %lx at %lx\n"</span>,
00637                     Block,
00638                     NewPool
00639                     );
00640                 <a class="code" href="../../d9/d1/bugcheck_8c.html#a13">KeBugCheck</a>(0xBADF00D2);
00641             }
00642             *NewPool++ = 0xDEADBEEF;
00643         }
00644     }
00645 <span class="preprocessor">#endif //TRACE_ALLOC</span>
00646 <span class="preprocessor"></span>
00647     <span class="keywordflow">return</span> ((PCH)Entry + <a class="code" href="../../d5/d2/poolhack_8c.html#a6">POOL_OVERHEAD</a>);
00648 }
00649 
00650 ULONG
<a name="l00651"></a><a class="code" href="../../d5/d2/poolhack_8c.html#a33">00651</a> <a class="code" href="../../d5/d2/poolhack_8c.html#a33">ExpAllocatePoolWithQuotaHandler</a>(
00652     IN NTSTATUS ExceptionCode,
00653     IN PVOID PoolAddress
00654     )
00655 
00656 <span class="comment">/*++</span>
00657 <span class="comment"></span>
00658 <span class="comment">Routine Description:</span>
00659 <span class="comment"></span>
00660 <span class="comment">    This function is called when an exception occurs in ExFreePool</span>
00661 <span class="comment">    while quota is being charged to a process.</span>
00662 <span class="comment"></span>
00663 <span class="comment">    Its function is to deallocate the pool block and continue the search</span>
00664 <span class="comment">    for an exception handler.</span>
00665 <span class="comment"></span>
00666 <span class="comment">Arguments:</span>
00667 <span class="comment"></span>
00668 <span class="comment">    ExceptionCode - Supplies the exception code that caused this</span>
00669 <span class="comment">        function to be entered.</span>
00670 <span class="comment"></span>
00671 <span class="comment">    PoolAddress - Supplies the address of a pool block that needs to be</span>
00672 <span class="comment">        deallocated.</span>
00673 <span class="comment"></span>
00674 <span class="comment">Return Value:</span>
00675 <span class="comment"></span>
00676 <span class="comment">    EXCEPTION_CONTINUE_SEARCH - The exception should be propagated to the</span>
00677 <span class="comment">        caller of ExAllocatePoolWithQuota.</span>
00678 <span class="comment"></span>
00679 <span class="comment">--*/</span>
00680 
00681 {
00682     <span class="keywordflow">if</span> ( PoolAddress ) {
00683         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(ExceptionCode == STATUS_QUOTA_EXCEEDED);
00684         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(PoolAddress);
00685     } <span class="keywordflow">else</span> {
00686         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(ExceptionCode == STATUS_INSUFFICIENT_RESOURCES);
00687     }
00688     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a34">EXCEPTION_CONTINUE_SEARCH</a>;
00689 }
00690 
00691 
00692 
00693 PVOID
<a name="l00694"></a><a class="code" href="../../d5/d2/poolhack_8c.html#a34">00694</a> <a class="code" href="../../d5/d5/cc_8h.html#a11">ExAllocatePoolWithQuota</a>(
00695     IN POOL_TYPE PoolType,
00696     IN ULONG NumberOfBytes
00697     )
00698 
00699 <span class="comment">/*++</span>
00700 <span class="comment"></span>
00701 <span class="comment">Routine Description:</span>
00702 <span class="comment"></span>
00703 <span class="comment">    This function allocates a block of pool of the specified type,</span>
00704 <span class="comment">    returns a pointer to the allocated block, and if the binary buddy</span>
00705 <span class="comment">    allocator was used to satisfy the request, charges pool quota to the</span>
00706 <span class="comment">    current process.  This function is used to access both the</span>
00707 <span class="comment">    page-aligned pools, and the binary buddy.</span>
00708 <span class="comment"></span>
00709 <span class="comment">    If the number of bytes specifies a size that is too large to be</span>
00710 <span class="comment">    satisfied by the appropriate binary buddy pool, then the</span>
00711 <span class="comment">    page-aligned pool allocator is used.  The allocated block will be</span>
00712 <span class="comment">    page-aligned and a page-sized multiple.  No quota is charged to the</span>
00713 <span class="comment">    current process if this is the case.</span>
00714 <span class="comment"></span>
00715 <span class="comment">    Otherwise, the appropriate binary buddy pool is used.  The allocated</span>
00716 <span class="comment">    block will be 64-bit aligned, but will not be page aligned.  After</span>
00717 <span class="comment">    the allocation completes, an attempt will be made to charge pool</span>
00718 <span class="comment">    quota (of the appropriate type) to the current process object.  If</span>
00719 <span class="comment">    the quota charge succeeds, then the pool block's header is adjusted</span>
00720 <span class="comment">    to point to the current process.  The process object is not</span>
00721 <span class="comment">    dereferenced until the pool is deallocated and the appropriate</span>
00722 <span class="comment">    amount of quota is returned to the process.  Otherwise, the pool is</span>
00723 <span class="comment">    deallocated, a "quota exceeded" condition is raised.</span>
00724 <span class="comment"></span>
00725 <span class="comment">Arguments:</span>
00726 <span class="comment"></span>
00727 <span class="comment">    PoolType - Supplies the type of pool to allocate.  If the pool type</span>
00728 <span class="comment">        is one of the "MustSucceed" pool types and sufficient quota</span>
00729 <span class="comment">        exists, then this call will always succeed and return a pointer</span>
00730 <span class="comment">        to allocated pool.  Otherwise, if the system can not allocate</span>
00731 <span class="comment">        the requested amount of memory a STATUS_INSUFFICIENT_RESOURCES</span>
00732 <span class="comment">        status is raised.</span>
00733 <span class="comment"></span>
00734 <span class="comment">    NumberOfBytes - Supplies the number of bytes to allocate.</span>
00735 <span class="comment"></span>
00736 <span class="comment">Return Value:</span>
00737 <span class="comment"></span>
00738 <span class="comment">    NON-NULL - Returns a pointer to the allocated pool.</span>
00739 <span class="comment"></span>
00740 <span class="comment">    Unspecified - If insuffient quota exists to complete the pool</span>
00741 <span class="comment">        allocation, the return value is unspecified.</span>
00742 <span class="comment"></span>
00743 <span class="comment">--*/</span>
00744 
00745 {
00746     PVOID p;
00747     <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> Process;
00748     <a class="code" href="../../d5/d2/poolhack_8c.html#a16">PPOOL_HEADER</a> Entry;
00749     ULONG AllocationSize;
00750 
00751     p = <a class="code" href="../../d5/d5/cc_8h.html#a10">ExAllocatePool</a>(PoolType,NumberOfBytes);
00752 
00753 
00754 <span class="preprocessor">#ifndef TRACE_ALLOC</span>
00755 <span class="preprocessor"></span>    <span class="keywordflow">if</span> ( p &amp;&amp; !<a class="code" href="../../d5/d2/poolhack_8c.html#a5">PAGE_ALIGNED</a>(p) ) {
00756 
00757         Entry = (<a class="code" href="../../d5/d2/poolhack_8c.html#a16">PPOOL_HEADER</a>)((PCH)p - <a class="code" href="../../d5/d2/poolhack_8c.html#a6">POOL_OVERHEAD</a>);
00758 
00759         Process = <a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a>();
00760 
00761         <span class="comment">//</span>
00762         <span class="comment">// Catch exception and back out allocation if necessary</span>
00763         <span class="comment">//</span>
00764 
00765         <span class="keywordflow">try</span> {
00766 
00767             <a class="code" href="../../d0/d2/psquota_8c.html#a2">PsChargePoolQuota</a>(Process,<a class="code" href="../../d5/d2/poolhack_8c.html#a24">BasePoolTypeTable</a>[PoolType],(1 &lt;&lt; Entry-&gt;<a class="code" href="../../d5/d8/struct__POOL__HEADER.html#o0">LogAllocationSize</a>));
00768             <a class="code" href="../../d4/d0/ob_8h.html#a15">ObReferenceObject</a>(Process);
00769             Entry-&gt;<a class="code" href="../../d5/d8/struct__POOL__HEADER.html#o2">ProcessBilled</a> = Process;
00770 
00771         } except ( <a class="code" href="../../d5/d2/poolhack_8c.html#a33">ExpAllocatePoolWithQuotaHandler</a>(GetExceptionCode(),p)) {
00772             <a class="code" href="../../d9/d1/bugcheck_8c.html#a13">KeBugCheck</a>(GetExceptionCode());
00773         }
00774 
00775     } <span class="keywordflow">else</span> {
00776         <span class="keywordflow">if</span> ( !p ) {
00777             <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>(STATUS_INSUFFICIENT_RESOURCES);
00778         }
00779     }
00780 <span class="preprocessor">#endif // TRACE_ALLOC</span>
00781 <span class="preprocessor"></span>
00782     <span class="keywordflow">return</span> p;
00783 }
00784 
00785 <a class="code" href="../../d5/d2/poolhack_8c.html#a16">PPOOL_HEADER</a>
<a name="l00786"></a><a class="code" href="../../d5/d2/poolhack_8c.html#a26">00786</a> <a class="code" href="../../d5/d2/poolhack_8c.html#a26">AllocatePoolInternal</a>(
00787     IN PPOOL_DESCRIPTOR PoolDesc,
00788     IN LONG Index
00789     )
00790 
00791 <span class="comment">/*++</span>
00792 <span class="comment"></span>
00793 <span class="comment">Routine Description:</span>
00794 <span class="comment"></span>
00795 <span class="comment">    This function implements the guts of the binary buddy pool</span>
00796 <span class="comment">    allocator.  It is a recursive function.  It assumes that the caller</span>
00797 <span class="comment">    (ExAllocatePool) chose the correct pool descriptor, and that the</span>
00798 <span class="comment">    allocation should be satisfied from the binary buddy allocator.</span>
00799 <span class="comment"></span>
00800 <span class="comment">    The binary buddy allocator calculates the smallest block size that</span>
00801 <span class="comment">    is a power of two and that can be used to satisfy the request.  If</span>
00802 <span class="comment">    there are no blocks available of this size, then a block of the next</span>
00803 <span class="comment">    larger block size is allocated and split in half.  One piece is</span>
00804 <span class="comment">    placed back into the pool, and the other piece is used to satisfy</span>
00805 <span class="comment">    the request.  If the allocator reaches the paged sized block list,</span>
00806 <span class="comment">    and nothing is there, the page aligned pool allocator is called.</span>
00807 <span class="comment">    The page is added to the binary buddy pool...</span>
00808 <span class="comment"></span>
00809 <span class="comment">Arguments:</span>
00810 <span class="comment"></span>
00811 <span class="comment">    PoolDesc - Supplies the address of the pool descriptor to use to</span>
00812 <span class="comment">               satisfy the request.</span>
00813 <span class="comment"></span>
00814 <span class="comment">    Index - Supplies the index into the pool descriptor list head array</span>
00815 <span class="comment">            that should satisfy an allocation.</span>
00816 <span class="comment"></span>
00817 <span class="comment">Return Value:</span>
00818 <span class="comment"></span>
00819 <span class="comment">    Non-Null - Returns a pointer to the allocated pool header.  Before</span>
00820 <span class="comment">               this can be returned to the caller of ExAllocatePool or</span>
00821 <span class="comment">               ExAllocatePoolWithQuota, the value must be adjusted</span>
00822 <span class="comment">               (incremented) to account for the 64bit binary buddy pool</span>
00823 <span class="comment">               overhead.</span>
00824 <span class="comment"></span>
00825 <span class="comment">--*/</span>
00826 
00827 {
00828     LONG Log2N,ShiftedN;
00829     <a class="code" href="../../d5/d2/poolhack_8c.html#a16">PPOOL_HEADER</a> Entry,Buddy;
00830     <a class="code" href="../../d5/d2/poolhack_8c.html#a12">PPOOL_LIST_HEAD</a> PoolListHead;
00831 
00832 <span class="preprocessor">#if defined(TRACE_ALLOC) || defined (DEADBEEF)</span>
00833 <span class="preprocessor"></span>    PULONG BadFood;
00834 <span class="preprocessor">#endif // TRACE_ALLOC</span>
00835 <span class="preprocessor"></span>
00836     Log2N = <a class="code" href="../../d5/d2/poolhack_8c.html#a3">POOL_LOG_MIN</a> + <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
00837     ShiftedN = 1 &lt;&lt; Log2N;
00838 
00839     PoolListHead = &amp;PoolDesc-&gt;ListHeads[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>];
00840 
00841     <span class="comment">//</span>
00842     <span class="comment">// this is the correct list head.  See if anything is on the</span>
00843     <span class="comment">// list if so, delink and mark as allocated.  Otherwise,</span>
00844     <span class="comment">// recurse and split.</span>
00845     <span class="comment">//</span>
00846 
00847     <span class="keywordflow">if</span> ( !IsListEmpty(&amp;PoolListHead-&gt;<a class="code" href="../../d0/d9/struct__POOL__LIST__HEAD.html#o2">ListHead</a>) ) {
00848 
00849         <span class="comment">//</span>
00850         <span class="comment">// list has an entry, so grab it</span>
00851         <span class="comment">//</span>
00852 
00853         Entry = (<a class="code" href="../../d5/d2/poolhack_8c.html#a16">PPOOL_HEADER</a>)RemoveHeadList(
00854                                 &amp;PoolListHead-&gt;<a class="code" href="../../d0/d9/struct__POOL__LIST__HEAD.html#o2">ListHead</a>);
00855 
00856 <span class="preprocessor">#if defined(TRACE_ALLOC) || defined (DEADBEEF)</span>
00857 <span class="preprocessor"></span>        BadFood = (PULONG)Entry;
00858         *BadFood = 0xBAADF00D;
00859         *(BadFood+1) = 0xBAADF00D;
00860 <span class="preprocessor">#endif // TRACE_ALLOC</span>
00861 <span class="preprocessor"></span>
00862         Entry = (<a class="code" href="../../d5/d2/poolhack_8c.html#a16">PPOOL_HEADER</a>) ((PCH)Entry - <a class="code" href="../../d5/d2/poolhack_8c.html#a6">POOL_OVERHEAD</a>);
00863 
00864         <span class="comment">//</span>
00865         <span class="comment">// allocated entries have a size field set and pool type set</span>
00866         <span class="comment">//</span>
00867 
00868         Entry-&gt;<a class="code" href="../../d5/d8/struct__POOL__HEADER.html#o0">LogAllocationSize</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)Log2N;
00869         Entry-&gt;<a class="code" href="../../d5/d8/struct__POOL__HEADER.html#o1">PoolType</a> = PoolDesc-&gt;PoolType;
00870         Entry-&gt;<a class="code" href="../../d5/d8/struct__POOL__HEADER.html#o2">ProcessBilled</a> = (<a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a>)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00871 
00872         <span class="keywordflow">return</span> (PVOID)Entry;
00873 
00874     } <span class="keywordflow">else</span> {
00875 
00876         <span class="keywordflow">if</span> ( <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> != (<a class="code" href="../../d5/d2/poolhack_8c.html#a2">POOL_LIST_HEADS</a> - 1) ) {
00877 
00878             <span class="comment">//</span>
00879             <span class="comment">// This is the right list head, but since it is empty</span>
00880             <span class="comment">// must recurse.  Allocate from the next highest entry.</span>
00881             <span class="comment">// The resulting entry is then split in half.  One half</span>
00882             <span class="comment">// is marked as free and added to the list.  The other</span>
00883             <span class="comment">// half is returned</span>
00884             <span class="comment">//</span>
00885 
00886             Entry = (<a class="code" href="../../d5/d2/poolhack_8c.html#a16">PPOOL_HEADER</a>)<a class="code" href="../../d5/d2/poolhack_8c.html#a26">AllocatePoolInternal</a>(PoolDesc,<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>+1);
00887 
00888             <span class="keywordflow">if</span> ( !Entry ) {
00889                 <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00890             }
00891 
00892 <span class="preprocessor">#if defined(TRACE_ALLOC) || defined (DEADBEEF)</span>
00893 <span class="preprocessor"></span>            BadFood = (PULONG)((PCH)Entry + <a class="code" href="../../d5/d2/poolhack_8c.html#a6">POOL_OVERHEAD</a>);
00894             *BadFood = 0xBAADF00D;
00895             *(BadFood+1) = 0xBAADF00D;
00896 <span class="preprocessor">#endif // TRACE_ALLOC</span>
00897 <span class="preprocessor"></span>
00898             Buddy = (<a class="code" href="../../d5/d2/poolhack_8c.html#a16">PPOOL_HEADER</a>)((PCH)Entry + ShiftedN);
00899 
00900             <span class="comment">//</span>
00901             <span class="comment">// mark buddy as free and entry as allocated</span>
00902             <span class="comment">//</span>
00903 
00904             Entry-&gt;<a class="code" href="../../d5/d8/struct__POOL__HEADER.html#o0">LogAllocationSize</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>) Log2N;
00905             Entry-&gt;<a class="code" href="../../d5/d8/struct__POOL__HEADER.html#o1">PoolType</a> = PoolDesc-&gt;PoolType;
00906             Entry-&gt;<a class="code" href="../../d5/d8/struct__POOL__HEADER.html#o2">ProcessBilled</a> = (<a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a>)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00907 
00908             Buddy-&gt;<a class="code" href="../../d5/d8/struct__POOL__HEADER.html#o0">LogAllocationSize</a> = 0;
00909             Buddy-&gt;<a class="code" href="../../d5/d8/struct__POOL__HEADER.html#o1">PoolType</a> = <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
00910             Buddy-&gt;<a class="code" href="../../d5/d8/struct__POOL__HEADER.html#o2">ProcessBilled</a> = (<a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a>)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00911 
00912             InsertTailList(
00913                &amp;PoolListHead-&gt;<a class="code" href="../../d0/d9/struct__POOL__LIST__HEAD.html#o2">ListHead</a>,
00914                (PLIST_ENTRY)(((PCH)Buddy + <a class="code" href="../../d5/d2/poolhack_8c.html#a6">POOL_OVERHEAD</a>))
00915                );
00916 
00917             <span class="keywordflow">return</span> (PVOID)Entry;
00918 
00919         } <span class="keywordflow">else</span> {
00920 
00921             <span class="comment">//</span>
00922             <span class="comment">// Need to call page allocator for a page to add to the pool</span>
00923             <span class="comment">//</span>
00924 
00925             Entry = (<a class="code" href="../../d5/d2/poolhack_8c.html#a16">PPOOL_HEADER</a>)<a class="code" href="../../d1/d6/allocpag_8c.html#a54">MiAllocatePoolPages</a> (
00926                                             <a class="code" href="../../d5/d2/poolhack_8c.html#a24">BasePoolTypeTable</a>[PoolDesc-&gt;PoolType],
00927                                             <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>
00928                                             );
00929 
00930             <span class="keywordflow">if</span> ( !Entry ) {
00931                 <span class="keywordflow">if</span> ( <a class="code" href="../../d5/d2/poolhack_8c.html#a25">MustSucceedPoolTable</a>[PoolDesc-&gt;PoolType] ) {
00932                     Entry = (<a class="code" href="../../d5/d2/poolhack_8c.html#a16">PPOOL_HEADER</a>)<a class="code" href="../../d1/d6/allocpag_8c.html#a54">MiAllocatePoolPages</a> (
00933                                             PoolDesc-&gt;PoolType,
00934                                             <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>
00935                                             );
00936                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(Entry);
00937                 } <span class="keywordflow">else</span> {
00938                     <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00939                 }
00940             }
00941 
00942             Entry-&gt;<a class="code" href="../../d5/d8/struct__POOL__HEADER.html#o0">LogAllocationSize</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>) Log2N;
00943             Entry-&gt;<a class="code" href="../../d5/d8/struct__POOL__HEADER.html#o1">PoolType</a> = PoolDesc-&gt;PoolType;
00944             Entry-&gt;<a class="code" href="../../d5/d8/struct__POOL__HEADER.html#o2">ProcessBilled</a> = (<a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a>)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00945 
00946 <span class="preprocessor">#if defined(TRACE_ALLOC) || defined (DEADBEEF)</span>
00947 <span class="preprocessor"></span>            {
00948                 PULONG NewPool;
00949                 ULONG LongCount;
00950 
00951                 NewPool = (PULONG) ((PCH)Entry + <a class="code" href="../../d5/d2/poolhack_8c.html#a6">POOL_OVERHEAD</a>);
00952                 LongCount = (1 &lt;&lt; Entry-&gt;<a class="code" href="../../d5/d8/struct__POOL__HEADER.html#o0">LogAllocationSize</a>) &gt;&gt; 2;
00953                 LongCount -= (<a class="code" href="../../d5/d2/poolhack_8c.html#a6">POOL_OVERHEAD</a>&gt;&gt;2);
00954 
00955                 <span class="keywordflow">while</span>(LongCount--) {
00956                     *NewPool++ = 0xBAADF00D;
00957                 }
00958             }
00959 <span class="preprocessor">#endif //TRACE_ALLOC</span>
00960 <span class="preprocessor"></span>
00961             PoolDesc-&gt;TotalPages++;
00962 
00963             <span class="keywordflow">return</span> (PVOID)Entry;
00964 
00965         }
00966     }
00967 }
00968 
00969 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00970"></a><a class="code" href="../../d5/d2/poolhack_8c.html#a35">00970</a> <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(
00971     IN PVOID P
00972     )
00973 
00974 <span class="comment">/*++</span>
00975 <span class="comment"></span>
00976 <span class="comment">Routine Description:</span>
00977 <span class="comment"></span>
00978 <span class="comment">    This function deallocates a block of pool.  This function is used to</span>
00979 <span class="comment">    deallocate to both the page aligned pools, and the binary buddy</span>
00980 <span class="comment">    (less than a page) pools.</span>
00981 <span class="comment"></span>
00982 <span class="comment">    If the address of the block being deallocated is page-aligned, then</span>
00983 <span class="comment">    the page-aliged pool deallocator is used.</span>
00984 <span class="comment"></span>
00985 <span class="comment">    Otherwise, the binary buddy pool deallocator is used.  Deallocation</span>
00986 <span class="comment">    looks at the allocated block's pool header to determine the pool</span>
00987 <span class="comment">    type and block size being deallocated.  If the pool was allocated</span>
00988 <span class="comment">    using ExAllocatePoolWithQuota, then after the deallocation is</span>
00989 <span class="comment">    complete, the appropriate process's pool quota is adjusted to reflect</span>
00990 <span class="comment">    the deallocation, and the process object is dereferenced.</span>
00991 <span class="comment"></span>
00992 <span class="comment">Arguments:</span>
00993 <span class="comment"></span>
00994 <span class="comment">    P - Supplies the address of the block of pool being deallocated.</span>
00995 <span class="comment"></span>
00996 <span class="comment">Return Value:</span>
00997 <span class="comment"></span>
00998 <span class="comment">    None.</span>
00999 <span class="comment"></span>
01000 <span class="comment">--*/</span>
01001 
01002 {
01003     <a class="code" href="../../d5/d2/poolhack_8c.html#a16">PPOOL_HEADER</a> Entry;
01004     <a class="code" href="../../d5/d8/ex_8h.html#a96">POOL_TYPE</a> PoolType;
01005     KIRQL LockHandle;
01006     PVOID <a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>;
01007     <a class="code" href="../../d5/d2/poolhack_8c.html#a14">PPOOL_DESCRIPTOR</a> PoolDesc;
01008 
01009     KIRQL OldIrql;
01010     BOOLEAN ReleaseSpinLock = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01011     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
01012     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn1;
01013 
01014 <span class="preprocessor">#ifdef TRACE_ALLOC</span>
01015 <span class="preprocessor"></span>
01016     PULONG xFp, xPrevFp, xR1, xPrevR1;
01017 
01018     xFp = RtlpGetFramePointer();
01019     xR1 = (PULONG)*(xFp+1);
01020     xPrevFp = (PULONG)*xFp;
01021     xPrevR1 = (PULONG)*(xPrevFp+1);
01022 
01023 <span class="preprocessor">#endif // TRACE_ALLOC</span>
01024 <span class="preprocessor"></span>
01025     <span class="comment">//</span>
01026     <span class="comment">// If Entry is page aligned, then call page aligned pool</span>
01027     <span class="comment">//</span>
01028 
01029     <span class="keywordflow">if</span> ( <a class="code" href="../../d5/d2/poolhack_8c.html#a5">PAGE_ALIGNED</a>(P) ) {
01030 
01031         PoolType = <a class="code" href="../../d1/d6/allocpag_8c.html#a48">MmDeterminePoolType</a>(P);
01032 
01033         <a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a> = <a class="code" href="../../d2/d2/ex_2pool_8c.html#a54">PoolVector</a>[PoolType]-&gt;<a class="code" href="../../d4/d8/struct__POOL__DESCRIPTOR.html#o3">LockAddress</a>;
01034 
01035         <a class="code" href="../../d2/d2/ex_2pool_8c.html#a33">LOCK_POOL</a>(<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>,PoolType,LockHandle);
01036         <a class="code" href="../../d1/d6/allocpag_8c.html#a55">MiFreePoolPages</a> (P);
01037         <a class="code" href="../../d2/d2/ex_2pool_8c.html#a35">UNLOCK_POOL</a>(<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>,PoolType,LockHandle,<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
01038         <span class="keywordflow">return</span>;
01039     }
01040 
01041     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (P);
01042 
01043     <span class="keywordflow">if</span> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 0) {
01044         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"bad pool deallocation\n"</span>);
01045         <a class="code" href="../../d9/d1/bugcheck_8c.html#a13">KeBugCheck</a> (12345);
01046     }
01047 
01048     <span class="keywordflow">if</span> (KeGetCurrentIrql() &gt;= 2) {
01049         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"deallocating pool at irql &gt;= 2\n"</span>);
01050         ReleaseSpinLock = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01051     } <span class="keywordflow">else</span> {
01052         <a class="code" href="../../d4/d9/ke_8h.html#a37">KeAcquireSpinLock</a> ( &amp;<a class="code" href="../../d7/d2/alpha_2initkr_8c.html#a2">MmPfnLock</a>, &amp;OldIrql);
01053     }
01054 
01055     <a class="code" href="../../d3/d5/ppc_2flush_8c.html#a6">KeSweepDcache</a>(<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
01056 
01057     Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber);
01058     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a> = (<a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a>)<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a0">MM_EMPTY_LIST</a>;
01059     <a class="code" href="../../d4/d8/mi_8h.html#a241">MiDecrementShareCountOnly</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber);
01060     *PointerPte = <a class="code" href="../../d4/d2/datalpha_8c.html#a0">ZeroPte</a>;
01061     <a class="code" href="../../d0/d9/sysptes_8c.html#a26">MiReleaseSystemPtes</a> (PointerPte, 2, <a class="code" href="../../d4/d8/mi_8h.html#a1003a769">SystemPteSpace</a>);
01062     <span class="comment">//</span>
01063     <span class="comment">// BUGBUG Fix for MP.</span>
01064     <span class="comment">//</span>
01065     <a class="code" href="../../d0/d0/ki_8h.html#a114">KiFlushSingleTb</a> (P,<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
01066     <span class="keywordflow">if</span> (ReleaseSpinLock) {
01067         <a class="code" href="../../d9/d5/verifier_8c.html#a119">KeReleaseSpinLock</a> ( &amp;<a class="code" href="../../d7/d2/alpha_2initkr_8c.html#a2">MmPfnLock</a>, OldIrql );
01068     }
01069     <span class="keywordflow">return</span>;
01070 
01071     Entry = (<a class="code" href="../../d5/d2/poolhack_8c.html#a16">PPOOL_HEADER</a>)((PCH)P - <a class="code" href="../../d5/d2/poolhack_8c.html#a6">POOL_OVERHEAD</a>);
01072 
01073     PoolType = Entry-&gt;<a class="code" href="../../d5/d8/struct__POOL__HEADER.html#o1">PoolType</a>;
01074 
01075     PoolDesc = <a class="code" href="../../d2/d2/ex_2pool_8c.html#a54">PoolVector</a>[PoolType];
01076     <a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a> = PoolDesc-&gt;<a class="code" href="../../d4/d8/struct__POOL__DESCRIPTOR.html#o3">LockAddress</a>;
01077 
01078     <span class="comment">//</span>
01079     <span class="comment">// Sanity Check pool header</span>
01080     <span class="comment">//</span>
01081 
01082     <span class="keywordflow">if</span> ( (Entry-&gt;<a class="code" href="../../d5/d8/struct__POOL__HEADER.html#o0">LogAllocationSize</a> == 0) || (Entry-&gt;<a class="code" href="../../d5/d8/struct__POOL__HEADER.html#o1">PoolType</a> &gt;= <a class="code" href="../../d5/d8/ex_8h.html#a329a180">MaxPoolType</a>) ) {
01083         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"Invalid pool header 0x%lx 0x%lx\n"</span>,P,*(PULONG)P);
01084         <a class="code" href="../../d9/d1/bugcheck_8c.html#a13">KeBugCheck</a>(BAD_POOL_HEADER);
01085         <span class="keywordflow">return</span>;
01086     }
01087 
01088     <span class="keywordflow">if</span> ( (ULONG)P &amp; 0x0000000f != 8 ) {
01089         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"Misaligned Deallocation 0x%lx\n"</span>,P);
01090         <a class="code" href="../../d9/d1/bugcheck_8c.html#a13">KeBugCheck</a>(BAD_POOL_HEADER);
01091         <span class="keywordflow">return</span>;
01092     }
01093 
01094 <span class="preprocessor">#ifdef TRACE_ALLOC</span>
01095 <span class="preprocessor"></span>    {
01096         KIRQL xIrql;
01097         PLIST_ENTRY Next, Target;
01098         BOOLEAN Found;
01099 
01100         <a class="code" href="../../d9/d5/verifier_8c.html#a116">KeRaiseIrql</a>(<a class="code" href="../../d6/d7/halmips_8h.html#a52">APC_LEVEL</a>, &amp;xIrql);
01101 
01102         <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>(
01103             &amp;TracePoolLock,
01104             <a class="code" href="../../d4/d9/ke_8h.html#a407a201">PoolAllocation</a>,
01105             <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
01106             <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
01107             <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>
01108             );
01109 
01110         Found = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01111         Target = &amp;Entry-&gt;TraceLinks;
01112         Next = TracePoolListHead[PoolType].Flink;
01113         <span class="keywordflow">while</span>( Next != &amp;TracePoolListHead[PoolType] ){
01114             <span class="keywordflow">if</span> ( Next == Target ) {
01115 
01116                 RemoveEntryList(&amp;Entry-&gt;TraceLinks);
01117                 Found = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01118                 <span class="keywordflow">break</span>;
01119             }
01120             Next = Next-&gt;Flink;
01121         }
01122 
01123         <span class="keywordflow">if</span> ( !Found ) {
01124             <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"Block Not in Allocated Pool List 0x%lx\n"</span>,P);
01125             <a class="code" href="../../d9/d1/bugcheck_8c.html#a13">KeBugCheck</a>(BAD_POOL_HEADER);
01126             <span class="keywordflow">return</span>;
01127         }
01128 
01129         DeallocTrace[NextDeallocTrace].BufferAddress = P;
01130         DeallocTrace[NextDeallocTrace].Thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
01131         DeallocTrace[NextDeallocTrace].xR1 = xR1;
01132         DeallocTrace[NextDeallocTrace++].xPrevR1 = xPrevR1;
01133         <span class="keywordflow">if</span> ( NextDeallocTrace &gt;= MAXTRACE ) {
01134             NextDeallocTrace = 0;
01135         }
01136 
01137         (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d1/d6/semphobj_8c.html#a3">KeReleaseSemaphore</a>(
01138                     &amp;TracePoolLock,
01139                     0<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>,
01140                     1<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>,
01141                     <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>
01142                     );
01143         <a class="code" href="../../d9/d5/verifier_8c.html#a117">KeLowerIrql</a>(xIrql);
01144 
01145     }
01146 <span class="preprocessor">#endif // TRACE_ALLOC</span>
01147 <span class="preprocessor"></span>
01148 <span class="preprocessor">#ifndef TRACE_ALLOC</span>
01149 <span class="preprocessor"></span>
01150     <span class="comment">//</span>
01151     <span class="comment">// Check ProcessBilled flag to see if quota was charged on</span>
01152     <span class="comment">// this allocation</span>
01153     <span class="comment">//</span>
01154 
01155     <span class="keywordflow">if</span> ( Entry-&gt;<a class="code" href="../../d5/d8/struct__POOL__HEADER.html#o2">ProcessBilled</a> ) {
01156 
01157         <a class="code" href="../../d0/d2/psquota_8c.html#a3">PsReturnPoolQuota</a>(
01158             Entry-&gt;<a class="code" href="../../d5/d8/struct__POOL__HEADER.html#o2">ProcessBilled</a>,
01159             <a class="code" href="../../d5/d2/poolhack_8c.html#a24">BasePoolTypeTable</a>[PoolType],
01160             (1 &lt;&lt; Entry-&gt;<a class="code" href="../../d5/d8/struct__POOL__HEADER.html#o0">LogAllocationSize</a>)
01161             );
01162 
01163         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>(Entry-&gt;<a class="code" href="../../d5/d8/struct__POOL__HEADER.html#o2">ProcessBilled</a>);
01164 
01165     }
01166 <span class="preprocessor">#endif // TRACE_ALLOC</span>
01167 <span class="preprocessor"></span>
01168     <a class="code" href="../../d2/d2/ex_2pool_8c.html#a33">LOCK_POOL</a>(<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>,PoolType,LockHandle);
01169 
01170     <a class="code" href="../../d5/d2/poolhack_8c.html#a27">DeallocatePoolInternal</a>(PoolDesc,Entry);
01171 
01172     <a class="code" href="../../d2/d2/ex_2pool_8c.html#a35">UNLOCK_POOL</a>(<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>,PoolType,LockHandle,<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
01173 
01174 }
01175 
01176 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01177"></a><a class="code" href="../../d5/d2/poolhack_8c.html#a27">01177</a> <a class="code" href="../../d5/d2/poolhack_8c.html#a27">DeallocatePoolInternal</a>(
01178     IN PPOOL_DESCRIPTOR PoolDesc,
01179     IN PPOOL_HEADER Entry
01180     )
01181 
01182 <span class="comment">/*++</span>
01183 <span class="comment"></span>
01184 <span class="comment">Routine Description:</span>
01185 <span class="comment"></span>
01186 <span class="comment">    This function implements the guts of the binary buddy pool</span>
01187 <span class="comment">    deallocator.  It is a recursive function.  It assumes that the</span>
01188 <span class="comment">    caller (ExFreePool) chose the correct pool descriptor, and that</span>
01189 <span class="comment">    the deallocation should be done using the binary buddy deallocator.</span>
01190 <span class="comment"></span>
01191 <span class="comment">    The binary buddy deallocator automatically collapses adjacent free</span>
01192 <span class="comment">    blocks of the same size into a single free block of the next larger</span>
01193 <span class="comment">    size.  This is a recursive operation.  This does not occur on a</span>
01194 <span class="comment">    deallocation of a page sized block.  If a page sized block is being</span>
01195 <span class="comment">    deallocated, then the pool descriptor's threshold is examined.  If</span>
01196 <span class="comment">    the deallocation would cause the threshold to be exceeded, the page</span>
01197 <span class="comment">    sized block is returned to the page aligned pool allocator.</span>
01198 <span class="comment"></span>
01199 <span class="comment">Arguments:</span>
01200 <span class="comment"></span>
01201 <span class="comment">    PoolDesc - Supplies the address of the pool descriptor to use to</span>
01202 <span class="comment">               satisfy the request.</span>
01203 <span class="comment"></span>
01204 <span class="comment">    Entry - Supplies the address of the pool header of the block of pool</span>
01205 <span class="comment">            being deallocated.</span>
01206 <span class="comment"></span>
01207 <span class="comment">Return Value:</span>
01208 <span class="comment"></span>
01209 <span class="comment">    None.</span>
01210 <span class="comment"></span>
01211 <span class="comment">--*/</span>
01212 
01213 {
01214     <a class="code" href="../../d5/d2/poolhack_8c.html#a16">PPOOL_HEADER</a> Buddy,Base;
01215     LONG index;
01216     ULONG EntrySize;
01217 
01218     <span class="comment">//</span>
01219     <span class="comment">// Locate buddy of Entry being deallocated.  Page size entries have no</span>
01220     <span class="comment">// buddy</span>
01221     <span class="comment">//</span>
01222 
01223 
01224     index = Entry-&gt;<a class="code" href="../../d5/d8/struct__POOL__HEADER.html#o0">LogAllocationSize</a> - <a class="code" href="../../d5/d2/poolhack_8c.html#a3">POOL_LOG_MIN</a>;
01225 
01226     EntrySize = (1<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a> &lt;&lt; Entry-&gt;LogAllocationSize);
01227 
01228     <span class="keywordflow">if</span> ( EntrySize &lt; <a class="code" href="../../d5/d2/poolhack_8c.html#a0">POOL_PAGE_SIZE</a> ) {
01229 
01230         <span class="comment">//</span>
01231         <span class="comment">// buddy of Entry is LogAllocationSize bytes from Entry rounded</span>
01232         <span class="comment">// down on a 2*LogAllocationSize boundry</span>
01233         <span class="comment">//</span>
01234 
01235         Buddy = (<a class="code" href="../../d5/d2/poolhack_8c.html#a16">PPOOL_HEADER</a>)((ULONG)Entry ^ EntrySize);
01236 
01237         <span class="comment">//</span>
01238         <span class="comment">// see if buddy is free.  If so, then join buddy and Entry and</span>
01239         <span class="comment">// deallocate the joined Entry</span>
01240         <span class="comment">//</span>
01241 
01242         <span class="keywordflow">if</span> ( Buddy-&gt;<a class="code" href="../../d5/d8/struct__POOL__HEADER.html#o0">LogAllocationSize</a> == 0 &amp;&amp;
01243              Buddy-&gt;<a class="code" href="../../d5/d8/struct__POOL__HEADER.html#o1">PoolType</a> == index ) {
01244 
01245             <span class="comment">//</span>
01246             <span class="comment">// buddy is free.  Figure out which Entry is the base.</span>
01247             <span class="comment">// Convert the size of the base to next larger size and</span>
01248             <span class="comment">// deallocate the new Entry</span>
01249             <span class="comment">//</span>
01250 
01251             Base = ((ULONG)Entry &amp; EntrySize) ? Buddy : Entry;
01252 
01253             RemoveEntryList((PLIST_ENTRY)((PCH)Buddy + <a class="code" href="../../d5/d2/poolhack_8c.html#a6">POOL_OVERHEAD</a>));
01254 
01255             <span class="comment">//</span>
01256             <span class="comment">// Update statistics for buddy's list head.</span>
01257             <span class="comment">//</span>
01258 
01259             PoolDesc-&gt;ListHeads[index].CurrentFreeLength--;
01260 
01261             <span class="comment">//</span>
01262             <span class="comment">// mark base as allocated as next size Entry and then deallocate it</span>
01263             <span class="comment">//</span>
01264 
01265             Base-&gt;<a class="code" href="../../d5/d8/struct__POOL__HEADER.html#o0">LogAllocationSize</a> = Entry-&gt;LogAllocationSize + 1;
01266 
01267             <a class="code" href="../../d5/d2/poolhack_8c.html#a27">DeallocatePoolInternal</a>(PoolDesc,Base);
01268 
01269         } <span class="keywordflow">else</span> {
01270 
01271             <span class="comment">//</span>
01272             <span class="comment">// Buddy is not free, so just mark Entry as free and return to</span>
01273             <span class="comment">// appropriate list head</span>
01274             <span class="comment">//</span>
01275 
01276 <span class="preprocessor">#if defined(TRACE_ALLOC) || defined (DEADBEEF)</span>
01277 <span class="preprocessor"></span>            {
01278                 PULONG OldPool;
01279                 ULONG LongCount;
01280 
01281                 OldPool = (PULONG)((PCH)Entry + <a class="code" href="../../d5/d2/poolhack_8c.html#a6">POOL_OVERHEAD</a>);
01282                 LongCount = EntrySize &gt;&gt; 2;
01283                 LongCount -= (<a class="code" href="../../d5/d2/poolhack_8c.html#a6">POOL_OVERHEAD</a>&gt;&gt;2);
01284 
01285                 <span class="keywordflow">while</span>(LongCount--) {
01286                     *OldPool++ = 0xBAADF00D;
01287                 }
01288             }
01289 <span class="preprocessor">#endif //TRACE_ALLOC</span>
01290 <span class="preprocessor"></span>
01291             InsertTailList(
01292                 &amp;PoolDesc-&gt;ListHeads[index].ListHead,
01293                 (PLIST_ENTRY)((PCH)Entry + <a class="code" href="../../d5/d2/poolhack_8c.html#a6">POOL_OVERHEAD</a>)
01294                 );
01295 
01296             PoolDesc-&gt;ListHeads[index].CurrentFreeLength++;
01297 
01298             Entry-&gt;LogAllocationSize = 0;
01299             Entry-&gt;PoolType = index;
01300         }
01301 
01302     } <span class="keywordflow">else</span> {
01303 
01304         <span class="comment">//</span>
01305         <span class="comment">// Page Sized Entry.  Check threshold.  If deallocating Entry</span>
01306         <span class="comment">// would cross threshold then give back the page.  Otherwise put</span>
01307         <span class="comment">// it on the free list</span>
01308         <span class="comment">//</span>
01309 
01310         <span class="keywordflow">if</span> ( PoolDesc-&gt;ListHeads[index].CurrentFreeLength == PoolDesc-&gt;Threshold ) {
01311 
01312             <a class="code" href="../../d1/d6/allocpag_8c.html#a55">MiFreePoolPages</a> (Entry);
01313 
01314         } <span class="keywordflow">else</span> {
01315 
01316             <span class="comment">//</span>
01317             <span class="comment">// so just mark Entry as free and return to appropriate list head</span>
01318             <span class="comment">//</span>
01319 
01320 <span class="preprocessor">#if defined(TRACE_ALLOC) || defined (DEADBEEF)</span>
01321 <span class="preprocessor"></span>            {
01322                 PULONG OldPool;
01323                 ULONG LongCount;
01324 
01325                 OldPool = (PULONG)((PCH)Entry + <a class="code" href="../../d5/d2/poolhack_8c.html#a6">POOL_OVERHEAD</a>);
01326                 LongCount = EntrySize &gt;&gt; 2;
01327                 LongCount -= (<a class="code" href="../../d5/d2/poolhack_8c.html#a6">POOL_OVERHEAD</a>&gt;&gt;2);
01328 
01329                 <span class="keywordflow">while</span>(LongCount--) {
01330                     *OldPool++ = 0xBAADF00D;
01331                 }
01332             }
01333 <span class="preprocessor">#endif //TRACE_ALLOC</span>
01334 <span class="preprocessor"></span>
01335             InsertTailList(
01336                 &amp;PoolDesc-&gt;ListHeads[index].ListHead,
01337                 (PLIST_ENTRY)((PCH)Entry + <a class="code" href="../../d5/d2/poolhack_8c.html#a6">POOL_OVERHEAD</a>)
01338                 );
01339 
01340             PoolDesc-&gt;ListHeads[index].CurrentFreeLength++;
01341 
01342             Entry-&gt;LogAllocationSize = 0;
01343             Entry-&gt;PoolType = index;
01344 
01345         }
01346     }
01347 }
01348 
01349 
01350 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01351"></a><a class="code" href="../../d5/d2/poolhack_8c.html#a36">01351</a> <a class="code" href="../../d4/d0/tex_8c.html#a0">DumpPool</a>(
01352     IN PSZ s,
01353     IN POOL_TYPE pt
01354     )
01355 {
01356     <a class="code" href="../../d5/d2/poolhack_8c.html#a14">PPOOL_DESCRIPTOR</a> <a class="code" href="../../d3/d8/aug98_2test_2main_8c.html#a26">pd</a>;
01357     <a class="code" href="../../d5/d2/poolhack_8c.html#a16">PPOOL_HEADER</a> ph,bph;
01358     <a class="code" href="../../d5/d2/poolhack_8c.html#a12">PPOOL_LIST_HEAD</a> plh;
01359     PLIST_ENTRY lh,next;
01360     LONG i;
01361     ULONG size;
01362 
01363     <a class="code" href="../../d3/d8/aug98_2test_2main_8c.html#a26">pd</a> = <a class="code" href="../../d2/d2/ex_2pool_8c.html#a54">PoolVector</a>[pt];
01364 
01365     <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"\n\n%s\n"</span>,s);
01366 
01367     <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"PoolType: 0x%lx\n"</span>,(ULONG)<a class="code" href="../../d3/d8/aug98_2test_2main_8c.html#a26">pd</a>-&gt;PoolType);
01368     <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"TotalPages: 0x%lx\n"</span>,<a class="code" href="../../d3/d8/aug98_2test_2main_8c.html#a26">pd</a>-&gt;TotalPages);
01369     <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"Threshold: 0x%lx\n"</span>,<a class="code" href="../../d3/d8/aug98_2test_2main_8c.html#a26">pd</a>-&gt;Threshold);
01370     <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="../../d5/d2/poolhack_8c.html#a2">POOL_LIST_HEADS</a>; i++ ) {
01371         plh = &amp;<a class="code" href="../../d3/d8/aug98_2test_2main_8c.html#a26">pd</a>-&gt;ListHeads[i];
01372         size = (1 &lt;&lt; (i + <a class="code" href="../../d5/d2/poolhack_8c.html#a3">POOL_LOG_MIN</a>));
01373         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"\npd_list_head[0x%lx] size 0x%lx\n"</span>,i,size);
01374         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"\tCurrentFreeLength 0x%lx\n"</span>,plh-&gt;<a class="code" href="../../d0/d9/struct__POOL__LIST__HEAD.html#o0">CurrentFreeLength</a>);
01375         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"\t&amp;ListHead 0x%lx\n"</span>,&amp;plh-&gt;<a class="code" href="../../d0/d9/struct__POOL__LIST__HEAD.html#o2">ListHead</a>);
01376         lh = &amp;plh-&gt;<a class="code" href="../../d0/d9/struct__POOL__LIST__HEAD.html#o2">ListHead</a>;
01377         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"\t\tpFlink 0x%lx\n"</span>,lh-&gt;Flink);
01378         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"\t\tpBlink 0x%lx\n"</span>,lh-&gt;Blink);
01379         next = lh-&gt;Flink;
01380         <span class="keywordflow">while</span> ( next != lh ) {
01381             ph = (<a class="code" href="../../d5/d2/poolhack_8c.html#a16">PPOOL_HEADER</a>)((PCH)next - <a class="code" href="../../d5/d2/poolhack_8c.html#a6">POOL_OVERHEAD</a>);
01382             <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"\t\t\tpool header at 0x%lx list 0x%lx\n"</span>,ph,next);
01383             <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"\t\t\tLogAllocationSize 0x%lx 0x%lx\n"</span>,(ULONG)ph-&gt;<a class="code" href="../../d5/d8/struct__POOL__HEADER.html#o0">LogAllocationSize</a>,(ULONG)(1&lt;&lt;ph-&gt;<a class="code" href="../../d5/d8/struct__POOL__HEADER.html#o0">LogAllocationSize</a>));
01384             <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"\t\t\tPoolType 0x%lx\n"</span>,(ULONG)ph-&gt;<a class="code" href="../../d5/d8/struct__POOL__HEADER.html#o1">PoolType</a>);
01385             <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"\t\t\tProcessBilled 0x%lx\n"</span>,ph-&gt;<a class="code" href="../../d5/d8/struct__POOL__HEADER.html#o2">ProcessBilled</a>);
01386             <span class="keywordflow">if</span> ( size != <a class="code" href="../../d5/d2/poolhack_8c.html#a0">POOL_PAGE_SIZE</a> ) {
01387                 bph = (<a class="code" href="../../d5/d2/poolhack_8c.html#a16">PPOOL_HEADER</a>)((ULONG)ph ^ size);
01388                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"\t\t\t\tBuddy pool header at 0x%lx\n"</span>,bph);
01389                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"\t\t\t\tBuddy LogAllocationSize 0x%lx 0x%lx\n"</span>,(ULONG)bph-&gt;<a class="code" href="../../d5/d8/struct__POOL__HEADER.html#o0">LogAllocationSize</a>,(ULONG)(1&lt;&lt;bph-&gt;<a class="code" href="../../d5/d8/struct__POOL__HEADER.html#o0">LogAllocationSize</a>));
01390                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"\t\t\t\tBuddy PoolType 0x%lx\n"</span>,(ULONG)bph-&gt;<a class="code" href="../../d5/d8/struct__POOL__HEADER.html#o1">PoolType</a>);
01391                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"\t\t\t\tBuddy ProcessBilled 0x%lx\n"</span>,bph-&gt;<a class="code" href="../../d5/d8/struct__POOL__HEADER.html#o2">ProcessBilled</a>);
01392             }
01393             next = next-&gt;Flink;
01394         }
01395     }
01396 }
01397 
01398 
01399 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01400"></a><a class="code" href="../../d5/d2/poolhack_8c.html#a37">01400</a> <a class="code" href="../../d5/d2/poolhack_8c.html#a37">CheckPool</a>()
01401 {
01402     <a class="code" href="../../d5/d2/poolhack_8c.html#a14">PPOOL_DESCRIPTOR</a> <a class="code" href="../../d3/d8/aug98_2test_2main_8c.html#a26">pd</a>;
01403     <a class="code" href="../../d5/d2/poolhack_8c.html#a16">PPOOL_HEADER</a> ph,bph;
01404     <a class="code" href="../../d5/d2/poolhack_8c.html#a12">PPOOL_LIST_HEAD</a> plh;
01405     PLIST_ENTRY lh,next,lh2,next2;
01406     BOOLEAN buddyinlist;
01407     LONG i,j;
01408     ULONG size;
01409 
01410     <a class="code" href="../../d3/d8/aug98_2test_2main_8c.html#a26">pd</a> = <a class="code" href="../../d2/d2/ex_2pool_8c.html#a54">PoolVector</a>[<a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>];
01411 
01412     <span class="keywordflow">if</span> ( <a class="code" href="../../d3/d8/aug98_2test_2main_8c.html#a26">pd</a>-&gt;PoolType != <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a> ) {
01413         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"pd = %8lx\n"</span>, <a class="code" href="../../d3/d8/aug98_2test_2main_8c.html#a26">pd</a>);
01414         <a class="code" href="../../d9/d1/bugcheck_8c.html#a13">KeBugCheck</a>(0x70000001);
01415     }
01416 
01417     <span class="keywordflow">if</span> ( (LONG) <a class="code" href="../../d3/d8/aug98_2test_2main_8c.html#a26">pd</a>-&gt;TotalPages &lt; 0 ) {
01418         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"pd = %8lx\n"</span>, <a class="code" href="../../d3/d8/aug98_2test_2main_8c.html#a26">pd</a>);
01419         <a class="code" href="../../d9/d1/bugcheck_8c.html#a13">KeBugCheck</a>(0x70000002);
01420     }
01421 
01422     <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="../../d5/d2/poolhack_8c.html#a2">POOL_LIST_HEADS</a>; i++ ) {
01423         plh = &amp;<a class="code" href="../../d3/d8/aug98_2test_2main_8c.html#a26">pd</a>-&gt;ListHeads[i];
01424         size = (1 &lt;&lt; (i + <a class="code" href="../../d5/d2/poolhack_8c.html#a3">POOL_LOG_MIN</a>));
01425 
01426         <span class="keywordflow">if</span> ( !IsListEmpty(&amp;plh-&gt;<a class="code" href="../../d0/d9/struct__POOL__LIST__HEAD.html#o2">ListHead</a>) ) {
01427 
01428             lh = &amp;plh-&gt;<a class="code" href="../../d0/d9/struct__POOL__LIST__HEAD.html#o2">ListHead</a>;
01429             next = lh-&gt;Flink;
01430             <span class="keywordflow">while</span> ( next != lh ) {
01431                 ph = (<a class="code" href="../../d5/d2/poolhack_8c.html#a16">PPOOL_HEADER</a>)((PCH)next - <a class="code" href="../../d5/d2/poolhack_8c.html#a6">POOL_OVERHEAD</a>);
01432 
01433                 <span class="keywordflow">if</span> ( <a class="code" href="../../d1/d6/allocpag_8c.html#a48">MmDeterminePoolType</a>(ph) != <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a> ) {
01434                     <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"ph = %8lx\n"</span>, ph);
01435                     <a class="code" href="../../d9/d1/bugcheck_8c.html#a13">KeBugCheck</a>(0x70000004);
01436                 }
01437                 <span class="keywordflow">if</span> ( size != <a class="code" href="../../d5/d2/poolhack_8c.html#a0">POOL_PAGE_SIZE</a> ) {
01438                     bph = (<a class="code" href="../../d5/d2/poolhack_8c.html#a16">PPOOL_HEADER</a>)((ULONG)ph ^ size);
01439                     <span class="keywordflow">if</span> ( bph-&gt;<a class="code" href="../../d5/d8/struct__POOL__HEADER.html#o0">LogAllocationSize</a> == 0 &amp;&amp;
01440                          bph-&gt;<a class="code" href="../../d5/d8/struct__POOL__HEADER.html#o1">PoolType</a> == i ) {
01441                         lh2 = &amp;plh-&gt;<a class="code" href="../../d0/d9/struct__POOL__LIST__HEAD.html#o2">ListHead</a>;
01442                         next2 = lh2-&gt;Flink;
01443                         buddyinlist = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01444                         <span class="keywordflow">while</span> ( next2 != lh2 ) {
01445                             ph = (<a class="code" href="../../d5/d2/poolhack_8c.html#a16">PPOOL_HEADER</a>)((PCH)next - <a class="code" href="../../d5/d2/poolhack_8c.html#a6">POOL_OVERHEAD</a>);
01446                             <span class="keywordflow">if</span> ( bph == ph ) {
01447                                 buddyinlist = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01448                             }
01449                             next2 = next2-&gt;Flink;
01450                         }
01451                         <span class="keywordflow">if</span> ( !buddyinlist ) {
01452                             <a class="code" href="../../d9/d1/bugcheck_8c.html#a13">KeBugCheck</a>(0x70000005);
01453                         }
01454                     }
01455                 }
01456                 <span class="keywordflow">if</span> ( next == next-&gt;Flink ) {
01457                     <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"next = %8lx\n"</span>, next);
01458                     <a class="code" href="../../d9/d1/bugcheck_8c.html#a13">KeBugCheck</a>(0x70000006);
01459                 }
01460                 next = next-&gt;Flink;
01461             }
01462         }
01463 
01464     }
01465 }
01466 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01467"></a><a class="code" href="../../d5/d2/poolhack_8c.html#a38">01467</a> <a class="code" href="../../d5/d2/poolhack_8c.html#a38">DumpAllocatedPool</a>(
01468     IN ULONG DumpOrFlush
01469     )
01470 {
01471     <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a> MiFlushUnusedSections( <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a> );
01472     <a class="code" href="../../d5/d8/ex_8h.html#a96">POOL_TYPE</a> pt;
01473     ULONG PoolUsage[<a class="code" href="../../d5/d8/ex_8h.html#a329a180">MaxPoolType</a>];
01474     ULONG PoolFree[<a class="code" href="../../d5/d8/ex_8h.html#a329a180">MaxPoolType</a>];
01475 
01476     <a class="code" href="../../d5/d2/poolhack_8c.html#a14">PPOOL_DESCRIPTOR</a> <a class="code" href="../../d3/d8/aug98_2test_2main_8c.html#a26">pd</a>;
01477     <a class="code" href="../../d5/d2/poolhack_8c.html#a12">PPOOL_LIST_HEAD</a> plh;
01478     PLIST_ENTRY lh,next;
01479     LONG i,j,k;
01480     ULONG size;
01481 
01482     <span class="keywordflow">if</span> ( DumpOrFlush ) {
01483         MiFlushUnusedSections();
01484         <span class="keywordflow">return</span>;
01485     }
01486 
01487     <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a> (<span class="stringliteral">"PoolHack does not work with POOL command\n"</span>);
01488 
01489     <span class="keywordflow">return</span>;
01490 }
01491 
01492 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01493"></a><a class="code" href="../../d5/d2/poolhack_8c.html#a39">01493</a> <a class="code" href="../../d5/d8/ex_8h.html#a229">ExQueryPoolUsage</a>(
01494     OUT PULONG PagedPoolPages,
01495     OUT PULONG NonPagedPoolPages
01496     )
01497 {
01498     <a class="code" href="../../d5/d2/poolhack_8c.html#a14">PPOOL_DESCRIPTOR</a> <a class="code" href="../../d3/d8/aug98_2test_2main_8c.html#a26">pd</a>;
01499 
01500     <a class="code" href="../../d3/d8/aug98_2test_2main_8c.html#a26">pd</a> = <a class="code" href="../../d2/d2/ex_2pool_8c.html#a54">PoolVector</a>[<a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>];
01501     *PagedPoolPages = <a class="code" href="../../d3/d8/aug98_2test_2main_8c.html#a26">pd</a>-&gt;TotalPages;
01502     <a class="code" href="../../d3/d8/aug98_2test_2main_8c.html#a26">pd</a> = <a class="code" href="../../d2/d2/ex_2pool_8c.html#a54">PoolVector</a>[PagedPoolMustSucceed];
01503     *PagedPoolPages += <a class="code" href="../../d3/d8/aug98_2test_2main_8c.html#a26">pd</a>-&gt;TotalPages;
01504 
01505     <a class="code" href="../../d3/d8/aug98_2test_2main_8c.html#a26">pd</a> = <a class="code" href="../../d2/d2/ex_2pool_8c.html#a54">PoolVector</a>[<a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>];
01506     *NonPagedPoolPages = <a class="code" href="../../d3/d8/aug98_2test_2main_8c.html#a26">pd</a>-&gt;TotalPages;
01507     <a class="code" href="../../d3/d8/aug98_2test_2main_8c.html#a26">pd</a> = <a class="code" href="../../d2/d2/ex_2pool_8c.html#a54">PoolVector</a>[<a class="code" href="../../d5/d8/ex_8h.html#a329a175">NonPagedPoolMustSucceed</a>];
01508     *NonPagedPoolPages += <a class="code" href="../../d3/d8/aug98_2test_2main_8c.html#a26">pd</a>-&gt;TotalPages;
01509 
01510 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:41:24 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
