<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: drawtext.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>drawtext.c</h1><a href="../../d5/d2/rtl_2drawtext_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/****************************** Module Header ******************************\</span>
00002 <span class="comment">* Module Name: drawtext.c</span>
00003 <span class="comment">*</span>
00004 <span class="comment">* Copyright (c) 1985 - 1999, Microsoft Corporation</span>
00005 <span class="comment">*</span>
00006 <span class="comment">* This module contains common text drawing functions.</span>
00007 <span class="comment">*</span>
00008 <span class="comment">* History:</span>
00009 <span class="comment">* 02-12-92 mikeke   Moved Drawtext to the client side</span>
00010 <span class="comment">\***************************************************************************/</span>
00011 
00012 
00013 <span class="comment">/***************************************************************************\</span>
00014 <span class="comment">* Define some macros to test the format flags. We won't support them all</span>
00015 <span class="comment">* on the kernel-mode side, since they're not all needed there.</span>
00016 <span class="comment">\***************************************************************************/</span>
00017 <span class="preprocessor">#ifdef _USERK_</span>
00018 <span class="preprocessor"></span><span class="preprocessor">    #define CALCRECT(wFormat)               FALSE</span>
00019 <span class="preprocessor"></span><span class="preprocessor">    #define EDITCONTROL(wFormat)            FALSE</span>
00020 <span class="preprocessor"></span><span class="preprocessor">    #define EXPANDTABS(wFormat)             FALSE</span>
00021 <span class="preprocessor"></span><span class="preprocessor">    #define EXTERNALLEADING(wFormat)        FALSE</span>
00022 <span class="preprocessor"></span><span class="preprocessor">    #define MODIFYSTRING(wFormat)           FALSE</span>
00023 <span class="preprocessor"></span><span class="preprocessor">    #define NOPREFIX(wFormat)               TRUE</span>
00024 <span class="preprocessor"></span><span class="preprocessor">    #define PATHELLIPSIS(wFormat)           FALSE</span>
00025 <span class="preprocessor"></span><span class="preprocessor">    #define SINGLELINE(wFormat)             TRUE</span>
00026 <span class="preprocessor"></span><span class="preprocessor">    #define TABSTOP(wFormat)                FALSE</span>
00027 <span class="preprocessor"></span><span class="preprocessor">    #define WORDBREAK(wFormat)              FALSE</span>
00028 <span class="preprocessor"></span><span class="preprocessor">    #define WORDELLIPSIS(wFormat)           FALSE</span>
00029 <span class="preprocessor"></span><span class="preprocessor">    #define NOFULLWIDTHCHARBREAK(dwFormat)  FALSE</span>
00030 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00031"></a><a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a0">00031</a> <span class="preprocessor"></span><span class="preprocessor">    #define CALCRECT(wFormat)               (wFormat &amp; DT_CALCRECT)</span>
<a name="l00032"></a><a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a1">00032</a> <span class="preprocessor"></span><span class="preprocessor">    #define EDITCONTROL(wFormat)            (wFormat &amp; DT_EDITCONTROL)</span>
<a name="l00033"></a><a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a2">00033</a> <span class="preprocessor"></span><span class="preprocessor">    #define EXPANDTABS(wFormat)             (wFormat &amp; DT_EXPANDTABS)</span>
<a name="l00034"></a><a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a3">00034</a> <span class="preprocessor"></span><span class="preprocessor">    #define EXTERNALLEADING(wFormat)        (wFormat &amp; DT_EXTERNALLEADING)</span>
<a name="l00035"></a><a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a4">00035</a> <span class="preprocessor"></span><span class="preprocessor">    #define MODIFYSTRING(wFormat)           (wFormat &amp; DT_MODIFYSTRING)</span>
<a name="l00036"></a><a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a5">00036</a> <span class="preprocessor"></span><span class="preprocessor">    #define NOPREFIX(wFormat)               (wFormat &amp; DT_NOPREFIX)</span>
<a name="l00037"></a><a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a6">00037</a> <span class="preprocessor"></span><span class="preprocessor">    #define PATHELLIPSIS(wFormat)           (wFormat &amp; DT_PATH_ELLIPSIS)</span>
<a name="l00038"></a><a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a7">00038</a> <span class="preprocessor"></span><span class="preprocessor">    #define SINGLELINE(wFormat)             (wFormat &amp; DT_SINGLELINE)</span>
<a name="l00039"></a><a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a8">00039</a> <span class="preprocessor"></span><span class="preprocessor">    #define TABSTOP(wFormat)                (wFormat &amp; DT_TABSTOP)</span>
<a name="l00040"></a><a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a9">00040</a> <span class="preprocessor"></span><span class="preprocessor">    #define WORDBREAK(wFormat)              (wFormat &amp; DT_WORDBREAK)</span>
<a name="l00041"></a><a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a10">00041</a> <span class="preprocessor"></span><span class="preprocessor">    #define WORDELLIPSIS(wFormat)           (wFormat &amp; DT_WORD_ELLIPSIS)</span>
00042 <span class="preprocessor"></span>    <span class="comment">// Note: DT_NOFULLWIDTHCHARBREAK exceeds WORD limit. Use dwFormat</span>
00043     <span class="comment">//  rather than wFormat.</span>
<a name="l00044"></a><a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a11">00044</a> <span class="preprocessor">    #define NOFULLWIDTHCHARBREAK(dwFormat)  (dwFormat &amp; DT_NOFULLWIDTHCHARBREAK)</span>
00045 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00046"></a><a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a12">00046</a> <span class="preprocessor"></span><span class="preprocessor">#define ENDELLIPSIS(wFormat)        (wFormat &amp; DT_END_ELLIPSIS)</span>
<a name="l00047"></a><a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a13">00047</a> <span class="preprocessor"></span><span class="preprocessor">#define NOCLIP(wFormat)             (wFormat &amp; DT_NOCLIP)</span>
<a name="l00048"></a><a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a14">00048</a> <span class="preprocessor"></span><span class="preprocessor">#define RTLREADING(wFormat)         (wFormat &amp; DT_RTLREADING)</span>
<a name="l00049"></a><a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a15">00049</a> <span class="preprocessor"></span><span class="preprocessor">#define HIDEPREFIX(wFormat)         (wFormat &amp; DT_HIDEPREFIX)</span>
00050 <span class="preprocessor"></span>
00051 <span class="comment">/***************************************************************************\</span>
00052 <span class="comment">* Stuff used in DrawText code</span>
00053 <span class="comment">\***************************************************************************/</span>
00054 
<a name="l00055"></a><a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a16">00055</a> <span class="preprocessor">#define CR 13</span>
<a name="l00056"></a><a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a17">00056</a> <span class="preprocessor"></span><span class="preprocessor">#define LF 10</span>
<a name="l00057"></a><a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a18">00057</a> <span class="preprocessor"></span><span class="preprocessor">#define DT_HFMTMASK 0x03</span>
<a name="l00058"></a><a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a19">00058</a> <span class="preprocessor"></span><span class="preprocessor">#define DT_VFMTMASK 0x0C</span>
<a name="l00059"></a><a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a20">00059</a> <span class="preprocessor"></span><span class="preprocessor">#define ETO_OPAQUEFGND 0x0A</span>
00060 <span class="preprocessor"></span>
<a name="l00061"></a><a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a24">00061</a> <span class="keyword">static</span> CONST WCHAR <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a24">szEllipsis</a>[<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a901">CCHELLIPSIS</a>+1] = TEXT(<span class="stringliteral">"..."</span>);
00062 
<a name="l00063"></a><a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a25">00063</a> <span class="keyword">extern</span> HDC    <a class="code" href="../../d1/d8/clglobal_8c.html#a26">ghdcBits2</a>;
00064 
00065 <span class="comment">/* Max length of a full path is around 260. But, most of the time, it will</span>
00066 <span class="comment"> * be less than 128. So, we alloc only this much on stack. If the string is</span>
00067 <span class="comment"> * longer, we alloc from local heap (which is slower).</span>
00068 <span class="comment"> *</span>
00069 <span class="comment"> * BOGUS: For international versions, we need to give some more margin here.</span>
00070 <span class="comment"> */</span>
<a name="l00071"></a><a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a21">00071</a> <span class="preprocessor">#define MAXBUFFSIZE     128</span>
00072 <span class="preprocessor"></span>
00073 <span class="comment">/***************************************************************************\</span>
00074 <span class="comment">*  There are word breaking characters which are compatible with</span>
00075 <span class="comment">* Japanese Windows 3.1 and FarEast Windows 95.</span>
00076 <span class="comment">*</span>
00077 <span class="comment">*  SJ - Country Japan , Charset SHIFTJIS, Codepage  932.</span>
00078 <span class="comment">*  GB - Country PRC   , Charset GB2312  , Codepage  936.</span>
00079 <span class="comment">*  B5 - Country Taiwan, Charset BIG5    , Codepage  950.</span>
00080 <span class="comment">*  WS - Country Korea , Charset WANGSUNG, Codepage  949.</span>
00081 <span class="comment">*  JB - Country Korea , Charset JOHAB   , Codepage 1361. *** LATER ***</span>
00082 <span class="comment">*</span>
00083 <span class="comment">* [START BREAK CHARACTERS]</span>
00084 <span class="comment">*</span>
00085 <span class="comment">*   These character should not be the last charatcer of the line.</span>
00086 <span class="comment">*</span>
00087 <span class="comment">*  Unicode   Japan      PRC     Taiwan     Korea</span>
00088 <span class="comment">*  -------+---------+---------+---------+---------+</span>
00089 <span class="comment">*</span>
00090 <span class="comment">* + ASCII</span>
00091 <span class="comment">*</span>
00092 <span class="comment">*   U+0024 (SJ+0024)                     (WS+0024) Dollar sign</span>
00093 <span class="comment">*   U+0028 (SJ+0028)                     (WS+0028) Opening parenthesis</span>
00094 <span class="comment">*   U+003C (SJ+003C)                               Less-than sign</span>
00095 <span class="comment">*   U+005C (SJ+005C)                               Backslash</span>
00096 <span class="comment">*   U+005B (SJ+005B) (GB+005B)           (WS+005B) Opening square bracket</span>
00097 <span class="comment">*   U+007B (SJ+007B) (GB+007B)           (WS+007B) Opening curly bracket</span>
00098 <span class="comment">*</span>
00099 <span class="comment">* + General punctuation</span>
00100 <span class="comment">*</span>
00101 <span class="comment">*   U+2018                               (WS+A1AE) Single Turned Comma Quotation Mark</span>
00102 <span class="comment">*   U+201C                               (WS+A1B0) Double Comma Quotation Mark</span>
00103 <span class="comment">*</span>
00104 <span class="comment">* + CJK symbols and punctuation</span>
00105 <span class="comment">*</span>
00106 <span class="comment">*   U+3008                               (WS+A1B4) Opening Angle Bracket</span>
00107 <span class="comment">*   U+300A (SJ+8173)                     (WS+A1B6) Opening Double Angle Bracket</span>
00108 <span class="comment">*   U+300C (SJ+8175)                     (WS+A1B8) Opening Corner Bracket</span>
00109 <span class="comment">*   U+300E (SJ+8177)                     (WS+A1BA) Opening White Corner Bracket</span>
00110 <span class="comment">*   U+3010 (SJ+9179)                     (WS+A1BC) Opening Black Lenticular Bracket</span>
00111 <span class="comment">*   U+3014 (SJ+816B)                     (WS+A1B2) Opening Tortoise Shell Bracket</span>
00112 <span class="comment">*</span>
00113 <span class="comment">* + Fullwidth ASCII variants</span>
00114 <span class="comment">*</span>
00115 <span class="comment">*   U+FF04                               (WS+A3A4) Fullwidth Dollar Sign</span>
00116 <span class="comment">*   U+FF08 (SJ+8169)                     (WS+A3A8) Fullwidth opening parenthesis</span>
00117 <span class="comment">*   U+FF1C (SJ+8183)                               Fullwidth less-than sign</span>
00118 <span class="comment">*   U+FF3B (SJ+816D)                     (WS+A3DB) Fullwidth opening square bracket</span>
00119 <span class="comment">*   U+FF5B (SJ+816F)                     (WS+A3FB) Fullwidth opening curly bracket</span>
00120 <span class="comment">*</span>
00121 <span class="comment">* + Halfwidth Katakana variants</span>
00122 <span class="comment">*</span>
00123 <span class="comment">*   U+FF62 (SJ+00A2)                               Halfwidth Opening Corner Bracket</span>
00124 <span class="comment">*</span>
00125 <span class="comment">* + Fullwidth symbol variants</span>
00126 <span class="comment">*</span>
00127 <span class="comment">*   U+FFE1                               (WS+A1CC) Fullwidth Pound Sign</span>
00128 <span class="comment">*   U+FFE6                               (WS+A3DC) Fullwidth Won Sign</span>
00129 <span class="comment">*</span>
00130 <span class="comment">* [END BREAK CHARACTERS]</span>
00131 <span class="comment">*</span>
00132 <span class="comment">*   These character should not be the top charatcer of the line.</span>
00133 <span class="comment">*</span>
00134 <span class="comment">*  Unicode   Japan      PRC     Taiwan     Korea</span>
00135 <span class="comment">*  -------+---------+---------+---------+---------+</span>
00136 <span class="comment">*</span>
00137 <span class="comment">* + ASCII</span>
00138 <span class="comment">*</span>
00139 <span class="comment">*   U+0021 (SJ+0021) (GB+0021) (B5+0021) (WS+0021) Exclamation mark</span>
00140 <span class="comment">*   U+0025                               (WS+0025) Percent Sign</span>
00141 <span class="comment">*   U+0029 (SJ+0029)                     (WS+0029) Closing parenthesis</span>
00142 <span class="comment">*   U+002C (SJ+002C) (GB+002C) (B5+002C) (WS+002C) Comma</span>
00143 <span class="comment">*   U+002E (SJ+002E) (GB+002E) (B5+002E) (WS+002E) Priod</span>
00144 <span class="comment">*   U+003A                               (WS+003A) Colon</span>
00145 <span class="comment">*   U+003B                               (WS+003B) Semicolon</span>
00146 <span class="comment">*   U+003E (SJ+003E)                               Greater-than sign</span>
00147 <span class="comment">*   U+003F (SJ+003F) (GB+003F) (B5+003F) (WS+003F) Question mark</span>
00148 <span class="comment">*   U+005D (SJ+005D) (GB+005D) (B5+005D) (WS+005D) Closing square bracket</span>
00149 <span class="comment">*   U+007D (SJ+007D) (GB+007D) (B5+007D) (WS+007D) Closing curly bracket</span>
00150 <span class="comment">*</span>
00151 <span class="comment">* + Latin1</span>
00152 <span class="comment">*</span>
00153 <span class="comment">*   U+00A8           (GB+A1A7)                     Spacing diaeresis</span>
00154 <span class="comment">*   U+00B0                               (WS+A1C6) Degree Sign</span>
00155 <span class="comment">*   U+00B7                     (B5+A150)           Middle Dot</span>
00156 <span class="comment">*</span>
00157 <span class="comment">* + Modifier letters</span>
00158 <span class="comment">*</span>
00159 <span class="comment">*   U+02C7           (GB+A1A6)                     Modifier latter hacek</span>
00160 <span class="comment">*   U+02C9           (GB+A1A5)                     Modifier letter macron</span>
00161 <span class="comment">*</span>
00162 <span class="comment">* + General punctuation</span>
00163 <span class="comment">*</span>
00164 <span class="comment">*   U+2013                     (B5+A156)           En Dash</span>
00165 <span class="comment">*   U+2014                     (b5+A158)           Em Dash</span>
00166 <span class="comment">*   U+2015           (GB+A1AA)                     Quotation dash</span>
00167 <span class="comment">*   U+2016           (GB+A1AC)                     Double vertical bar</span>
00168 <span class="comment">*   U+2018           (GB+A1AE)                     Single turned comma quotation mark</span>
00169 <span class="comment">*   U+2019           (GB+A1AF) (B5+A1A6) (WS+A1AF) Single comma quotation mark</span>
00170 <span class="comment">*   U+201D           (GB+A1B1) (B5+A1A8) (WS+A1B1) Double comma quotation mark</span>
00171 <span class="comment">*   U+2022           (GB+A1A4)                     Bullet</span>
00172 <span class="comment">*   U+2025                     (B5+A14C)           Two Dot Leader</span>
00173 <span class="comment">*   U+2026           (GB+A1AD) (B5+A14B)           Horizontal ellipsis</span>
00174 <span class="comment">*   U+2027                     (B5+A145)           Hyphenation Point</span>
00175 <span class="comment">*   U+2032                     (B5+A1AC) (WS+A1C7) Prime</span>
00176 <span class="comment">*   U+2033                               (WS+A1C8) Double Prime</span>
00177 <span class="comment">*</span>
00178 <span class="comment">* + Letterlike symbols</span>
00179 <span class="comment">*</span>
00180 <span class="comment">*   U+2103                               (WS+A1C9) Degrees Centigrade</span>
00181 <span class="comment">*</span>
00182 <span class="comment">* + Mathemetical opetartors</span>
00183 <span class="comment">*</span>
00184 <span class="comment">*   U+2236           (GB+A1C3)                     Ratio</span>
00185 <span class="comment">*</span>
00186 <span class="comment">* + Form and Chart components</span>
00187 <span class="comment">*</span>
00188 <span class="comment">*   U+2574                     (B5+A15A)           Forms Light Left</span>
00189 <span class="comment">*</span>
00190 <span class="comment">* + CJK symbols and punctuation</span>
00191 <span class="comment">*</span>
00192 <span class="comment">*   U+3001 (SJ+8141) (GB+A1A2) (B5+A142)           Ideographic comma</span>
00193 <span class="comment">*   U+3002 (SJ+8142) (GB+A1A3) (B5+A143)           Ideographic period</span>
00194 <span class="comment">*   U+3003           (GB+A1A8)                     Ditto mark</span>
00195 <span class="comment">*   U+3005           (GB+A1A9)                     Ideographic iteration</span>
00196 <span class="comment">*   U+3009           (GB+A1B5) (B5+A172) (WS+A1B5) Closing angle bracket</span>
00197 <span class="comment">*   U+300B (SJ+8174) (GB+A1B7) (B5+A16E) (WS+A1B7) Closing double angle bracket</span>
00198 <span class="comment">*   U+300D (SJ+8176) (GB+A1B9) (B5+A176) (WS+A1B9) Closing corner bracket</span>
00199 <span class="comment">*   U+300F (SJ+8178) (GB+A1BB) (B5+A17A) (WS+A1BB) Closing white corner bracket</span>
00200 <span class="comment">*   U+3011 (SJ+817A) (GB+A1BF) (B5+A16A) (WS+A1BD) Closing black lenticular bracket</span>
00201 <span class="comment">*   U+3015 (SJ+816C) (GB+A1B3) (B5+A166) (WS+A1B3) Closing tortoise shell bracket</span>
00202 <span class="comment">*   U+3017           (GB+A1BD)                     Closing white lenticular bracket</span>
00203 <span class="comment">*   U+301E                     (B5+A1AA)           Double Prime Quotation Mark</span>
00204 <span class="comment">*</span>
00205 <span class="comment">* + Hiragana</span>
00206 <span class="comment">*</span>
00207 <span class="comment">*   U+309B (SJ+814A)                               Katakana-Hiragana voiced sound mark</span>
00208 <span class="comment">*   U+309C (SJ+814B)                               Katakana-Hiragana semi-voiced sound mark</span>
00209 <span class="comment">*</span>
00210 <span class="comment">* + CNS 11643 compatibility</span>
00211 <span class="comment">*</span>
00212 <span class="comment">*   U+FE30                     (B5+A14A)           Glyph for Vertical 2 Dot Leader</span>
00213 <span class="comment">*   U+FE31                     (B5+A157)           Glyph For Vertical Em Dash</span>
00214 <span class="comment">*   U+FE33                     (B5+A159)           Glyph for Vertical Spacing Underscore</span>
00215 <span class="comment">*   U+FE34                     (B5+A15B)           Glyph for Vertical Spacing Wavy Underscore</span>
00216 <span class="comment">*   U+FE36                     (B5+A160)           Glyph For Vertical Closing Parenthesis</span>
00217 <span class="comment">*   U+FE38                     (B5+A164)           Glyph For Vertical Closing Curly Bracket</span>
00218 <span class="comment">*   U+FE3A                     (B5+A168)           Glyph For Vertical Closing Tortoise Shell Bracket</span>
00219 <span class="comment">*   U+FE3C                     (B5+A16C)           Glyph For Vertical Closing Black Lenticular Bracket</span>
00220 <span class="comment">*   U+FE3E                     (B5+A16E)           Closing Double Angle Bracket</span>
00221 <span class="comment">*   U+FE40                     (B5+A174)           Glyph For Vertical Closing Angle Bracket</span>
00222 <span class="comment">*   U+FE42                     (B5+A178)           Glyph For Vertical Closing Corner Bracket</span>
00223 <span class="comment">*   U+FE44                     (B5+A17C)           Glyph For Vertical Closing White Corner Bracket</span>
00224 <span class="comment">*   U+FE4F                     (B5+A15C)           Spacing Wavy Underscore</span>
00225 <span class="comment">*</span>
00226 <span class="comment">* + Small variants</span>
00227 <span class="comment">*</span>
00228 <span class="comment">*   U+FE50                     (B5+A14D)           Small Comma</span>
00229 <span class="comment">*   U+FE51                     (B5+A14E)           Small Ideographic Comma</span>
00230 <span class="comment">*   U+FE52                     (B5+A14F)           Small Period</span>
00231 <span class="comment">*   U+FE54                     (B5+A151)           Small Semicolon</span>
00232 <span class="comment">*   U+FE55                     (B5+A152)           Small Colon</span>
00233 <span class="comment">*   U+FE56                     (B5+A153)           Small Question Mark</span>
00234 <span class="comment">*   U+FE57                     (B5+A154)           Small Exclamation Mark</span>
00235 <span class="comment">*   U+FE5A                     (B5+A17E)           Small Closing Parenthesis</span>
00236 <span class="comment">*   U+FE5C                     (B5+A1A2)           Small Closing Curly Bracket</span>
00237 <span class="comment">*   U+FE5E                     (B5+A1A4)           Small Closing Tortoise Shell Bracket</span>
00238 <span class="comment">*</span>
00239 <span class="comment">* + Fullwidth ASCII variants</span>
00240 <span class="comment">*</span>
00241 <span class="comment">*   U+FF01 (SJ+8149) (GB+A3A1) (B5+A149) (WS+A3A1) Fullwidth exclamation mark</span>
00242 <span class="comment">*   U+FF02           (GB+A3A2)                     Fullwidth Quotation mark</span>
00243 <span class="comment">*   U+FF05                               (WS+A3A5) Fullwidth Percent Sign</span>
00244 <span class="comment">*   U+FF07           (GB+A3A7)                     Fullwidth Apostrophe</span>
00245 <span class="comment">*   U+FF09 (SJ+816A) (GB+A3A9) (B5+A15E) (WS+A3A9) Fullwidth Closing parenthesis</span>
00246 <span class="comment">*   U+FF0C (SJ+8143) (GB+A3AC) (B5+A141) (WS+A3AC) Fullwidth comma</span>
00247 <span class="comment">*   U+FF0D           (GB+A3AD)                     Fullwidth Hyphen-minus</span>
00248 <span class="comment">*   U+FF0E (SJ+8144)           (B5+A144) (WS+A3AE) Fullwidth period</span>
00249 <span class="comment">*   U+FF1A           (GB+A3BA) (B4+A147) (WS+A3BA) Fullwidth colon</span>
00250 <span class="comment">*   U+FF1B           (GB+A3BB) (B5+A146) (WS+A3BB) Fullwidth semicolon</span>
00251 <span class="comment">*   U+FF1E (SJ+8184)                               Fullwidth Greater-than sign</span>
00252 <span class="comment">*   U+FF1F (SJ+8148) (GB+A3BF) (B5+A148) (WS+A3BF) Fullwidth question mark</span>
00253 <span class="comment">*   U+FF3D (SJ+816E) (GB+A3DD)           (WS+A3DD) Fullwidth Closing square bracket</span>
00254 <span class="comment">*   U+FF5C                     (B5+A155)           Fullwidth Vertical Bar</span>
00255 <span class="comment">*   U+FF5D (SJ+8170)           (B5+A162) (WS+A3FD) Fullwidth Closing curly bracket</span>
00256 <span class="comment">*   U+FF5E           (GB+A1AB)                     Fullwidth Spacing tilde</span>
00257 <span class="comment">*</span>
00258 <span class="comment">* + Halfwidth Katakana variants</span>
00259 <span class="comment">*</span>
00260 <span class="comment">*   U+FF61 (SJ+00A1)                               Halfwidth Ideographic period</span>
00261 <span class="comment">*   U+FF63 (SJ+00A3)                               Halfwidth Closing corner bracket</span>
00262 <span class="comment">*   U+FF64 (SJ+00A4)                               Halfwidth Ideographic comma</span>
00263 <span class="comment">*   U+FF9E (SJ+00DE)                               Halfwidth Katakana voiced sound mark</span>
00264 <span class="comment">*   U+FF9F (SJ+00DF)                               Halfwidth Katakana semi-voiced sound mark</span>
00265 <span class="comment">*</span>
00266 <span class="comment">* + Fullwidth symbol variants</span>
00267 <span class="comment">*</span>
00268 <span class="comment">*   U+FFE0                               (WS+A1CB) Fullwidth Cent Sign</span>
00269 <span class="comment">*</span>
00270 <span class="comment">\***************************************************************************/</span>
00271 
00272 <span class="preprocessor">#if 0   // not currently used --- FYI only</span>
00273 <span class="preprocessor"></span><span class="comment">/***************************************************************************\</span>
00274 <span class="comment">* Start Break table</span>
00275 <span class="comment">*  These character should not be the last charatcer of the line.</span>
00276 <span class="comment">\***************************************************************************/</span>
00277 
00278 CONST <a class="code" href="../../d9/d7/halvprnt_8c.html#a0">BYTE</a> aASCII_StartBreak[] = {
00279 <span class="comment">/* 00       0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */</span>
00280 <span class="comment">/* 2X */</span>                1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
00281 <span class="comment">/* 3X */</span>    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
00282 <span class="comment">/* 4X */</span>    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
00283 <span class="comment">/* 5X */</span>    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0,
00284 <span class="comment">/* 6X */</span>    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
00285 <span class="comment">/* 7X */</span>    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1
00286 };
00287 
00288 CONST <a class="code" href="../../d9/d7/halvprnt_8c.html#a0">BYTE</a> aCJKSymbol_StartBreak[] = {
00289 <span class="comment">/* 30       0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */</span>
00290 <span class="comment">/* 0X */</span>                            1, 0, 1, 0, 1, 0, 1, 0,
00291 <span class="comment">/* 1X */</span>    1, 0, 0, 0, 1
00292 };
00293 
00294 CONST <a class="code" href="../../d9/d7/halvprnt_8c.html#a0">BYTE</a> aFullWidthHalfWidthVariants_StartBreak[] = {
00295 <span class="comment">/* FF       0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */</span>
00296 <span class="comment">/* 0X */</span>                1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
00297 <span class="comment">/* 1X */</span>    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
00298 <span class="comment">/* 2X */</span>    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
00299 <span class="comment">/* 3X */</span>    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
00300 <span class="comment">/* 4X */</span>    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
00301 <span class="comment">/* 5X */</span>    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
00302 <span class="comment">/* 6X */</span>    0, 0, 1
00303 };
00304 <span class="preprocessor">#endif</span>
00305 <span class="preprocessor"></span>
00306 <span class="comment">/***************************************************************************\</span>
00307 <span class="comment">* End Break table.</span>
00308 <span class="comment">*  These character should not be the top charatcer of the line.</span>
00309 <span class="comment">\***************************************************************************/</span>
00310 
<a name="l00311"></a><a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a26">00311</a> CONST <a class="code" href="../../d9/d7/halvprnt_8c.html#a0">BYTE</a> <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a26">aASCII_Latin1_EndBreak</a>[] = {
00312 <span class="comment">/* 00       0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */</span>
00313 <span class="comment">/* 2X */</span>       1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0,
00314 <span class="comment">/* 3X */</span>    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1,
00315 <span class="comment">/* 4X */</span>    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
00316 <span class="comment">/* 5X */</span>    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
00317 <span class="comment">/* 6X */</span>    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
00318 <span class="comment">/* 7X */</span>    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
00319 <span class="comment">/* 8X */</span>    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
00320 <span class="comment">/* 9X */</span>    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
00321 <span class="comment">/* AX */</span>    0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
00322 <span class="comment">/* BX */</span>    1, 0, 0, 0, 0, 0, 0, 1
00323 };
00324 
<a name="l00325"></a><a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a27">00325</a> CONST <a class="code" href="../../d9/d7/halvprnt_8c.html#a0">BYTE</a> <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a27">aGeneralPunctuation_EndBreak</a>[] = {
00326 <span class="comment">/* 20       0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */</span>
00327 <span class="comment">/* 1X */</span>             1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0,
00328 <span class="comment">/* 2X */</span>    0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
00329 <span class="comment">/* 3X */</span>    0, 0, 1, 1
00330 };
00331 
<a name="l00332"></a><a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a28">00332</a> CONST <a class="code" href="../../d9/d7/halvprnt_8c.html#a0">BYTE</a> <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a28">aCJKSymbol_EndBreak</a>[] = {
00333 <span class="comment">/* 30       0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */</span>
00334 <span class="comment">/* 0X */</span>       1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1,
00335 <span class="comment">/* 1X */</span>    0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1
00336 };
00337 
<a name="l00338"></a><a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a29">00338</a> CONST <a class="code" href="../../d9/d7/halvprnt_8c.html#a0">BYTE</a> <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a29">aCNS11643_SmallVariants_EndBreak</a>[] = {
00339 <span class="comment">/* FE       0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */</span>
00340 <span class="comment">/* 3X */</span>    1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
00341 <span class="comment">/* 4X */</span>    1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
00342 <span class="comment">/* 5X */</span>    1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1
00343 };
00344 
<a name="l00345"></a><a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a30">00345</a> CONST <a class="code" href="../../d9/d7/halvprnt_8c.html#a0">BYTE</a> <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a30">aFullWidthHalfWidthVariants_EndBreak</a>[] = {
00346 <span class="comment">/* FF       0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */</span>
00347 <span class="comment">/* 0X */</span>       1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0,
00348 <span class="comment">/* 1X */</span>    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1,
00349 <span class="comment">/* 2X */</span>    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
00350 <span class="comment">/* 3X */</span>    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
00351 <span class="comment">/* 4X */</span>    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
00352 <span class="comment">/* 5X */</span>    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0,
00353 <span class="comment">/* 6X */</span>    0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
00354 <span class="comment">/* 7X */</span>    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
00355 <span class="comment">/* 8X */</span>    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
00356 <span class="comment">/* 9X */</span>    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1
00357 };
00358 
00359 <span class="comment">/***************************************************************************\</span>
00360 <span class="comment">*  UserIsFELineBreak() - Detects Far East word breaking characters.         *</span>
00361 <span class="comment">*                                                                           *</span>
00362 <span class="comment">* History:                                                                  *</span>
00363 <span class="comment">* 10-Mar-1996 HideyukN  Created.                                            *</span>
00364 <span class="comment">\***************************************************************************/</span>
00365 
00366 <span class="preprocessor">#if 0   // not currently used --- FYI only</span>
00367 <span class="preprocessor"></span><a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a11">BOOL</a> UserIsFELineBreakStart(WCHAR wch)
00368 {
00369     <span class="keywordflow">switch</span> (wch&gt;&gt;8) {
00370         <span class="keywordflow">case</span> 0x00:
00371             <span class="comment">//</span>
00372             <span class="comment">// Check if word breaking chars in ASCII.</span>
00373             <span class="comment">//</span>
00374             <span class="keywordflow">if</span> ((wch &gt;= 0x0024) &amp;&amp; (wch &lt;= 0x007B))
00375                 <span class="keywordflow">return</span>((<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a11">BOOL</a>)(aASCII_StartBreak[wch - 0x0024]));
00376             <span class="keywordflow">else</span>
00377                 <span class="keywordflow">return</span>(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
00378 
00379         <span class="keywordflow">case</span> 0x20:
00380             <span class="comment">//</span>
00381             <span class="comment">// Check if work breaking chars in "General punctuation"</span>
00382             <span class="comment">//</span>
00383             <span class="keywordflow">if</span> ((wch == 0x2018) || (wch == 0x201C))
00384                 <span class="keywordflow">return</span>(<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
00385             <span class="keywordflow">else</span>
00386                 <span class="keywordflow">return</span>(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
00387 
00388         <span class="keywordflow">case</span> 0x30:
00389             <span class="comment">//</span>
00390             <span class="comment">// Check if word breaking chars in "CJK symbols and punctuation"</span>
00391             <span class="comment">// and Hiragana.</span>
00392             <span class="comment">//</span>
00393             <span class="keywordflow">if</span> ((wch &gt;= 0x3008) &amp;&amp; (wch &lt;= 0x3014))
00394                 <span class="keywordflow">return</span>((<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a11">BOOL</a>)(aCJKSymbol_StartBreak[wch - 0x3008]));
00395             <span class="keywordflow">else</span>
00396                 <span class="keywordflow">return</span>(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
00397 
00398         <span class="keywordflow">case</span> 0xFF:
00399             <span class="comment">//</span>
00400             <span class="comment">// Check if word breaking chars in "Fullwidth ASCII variants",</span>
00401             <span class="comment">// "Halfwidth Katakana variants" or "Fullwidth Symbol variants".</span>
00402             <span class="comment">//</span>
00403             <span class="keywordflow">if</span> ((wch &gt;= 0xFF04) &amp;&amp; (wch &lt;= 0xFF62))
00404                 <span class="keywordflow">return</span>((<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a11">BOOL</a>)(aFullWidthHalfWidthVariants_StartBreak[wch - 0xFF04]));
00405             <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((wch == 0xFFE1) || (wch == 0xFFE6))
00406                 <span class="keywordflow">return</span>(<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
00407             <span class="keywordflow">else</span>
00408                 <span class="keywordflow">return</span>(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
00409 
00410         <span class="keywordflow">default</span>:
00411             <span class="keywordflow">return</span>(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
00412     }
00413 }
00414 <span class="preprocessor">#endif</span>
00415 <span class="preprocessor"></span>
<a name="l00416"></a><a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a34">00416</a> <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a11">BOOL</a> <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a34">UserIsFELineBreakEnd</a>(WCHAR wch)
00417 {
00418     <span class="keywordflow">switch</span> (wch&gt;&gt;8) {
00419         <span class="keywordflow">case</span> 0x00:
00420             <span class="comment">//</span>
00421             <span class="comment">// Check if word breaking chars in ASCII or Latin1.</span>
00422             <span class="comment">//</span>
00423             <span class="keywordflow">if</span> ((wch &gt;= 0x0021) &amp;&amp; (wch &lt;= 0x00B7))
00424                 <span class="keywordflow">return</span>((<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a11">BOOL</a>)(<a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a26">aASCII_Latin1_EndBreak</a>[wch - 0x0021]));
00425             <span class="keywordflow">else</span>
00426                 <span class="keywordflow">return</span>(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
00427 
00428         <span class="keywordflow">case</span> 0x02:
00429             <span class="comment">//</span>
00430             <span class="comment">// Check if work breaking chars in "Modifier letters"</span>
00431             <span class="comment">//</span>
00432             <span class="keywordflow">if</span> ((wch == 0x02C7) || (wch == 0x02C9))
00433                 <span class="keywordflow">return</span>(<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
00434             <span class="keywordflow">else</span>
00435                 <span class="keywordflow">return</span>(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
00436 
00437         <span class="keywordflow">case</span> 0x20:
00438             <span class="comment">//</span>
00439             <span class="comment">// Check if work breaking chars in "General punctuation"</span>
00440             <span class="comment">//</span>
00441             <span class="keywordflow">if</span> ((wch &gt;= 0x2013) &amp;&amp; (wch &lt;= 0x2033))
00442                 <span class="keywordflow">return</span>((<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a11">BOOL</a>)(<a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a27">aGeneralPunctuation_EndBreak</a>[wch - 0x2013]));
00443             <span class="keywordflow">else</span>
00444                 <span class="keywordflow">return</span>(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
00445 
00446         <span class="keywordflow">case</span> 0x21:
00447             <span class="comment">//</span>
00448             <span class="comment">// Check if work breaking chars in "Letterlike symbols"</span>
00449             <span class="comment">//</span>
00450             <span class="keywordflow">if</span> (wch == 0x2103)
00451                 <span class="keywordflow">return</span>(<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
00452             <span class="keywordflow">else</span>
00453                 <span class="keywordflow">return</span>(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
00454 
00455         <span class="keywordflow">case</span> 0x22:
00456             <span class="comment">//</span>
00457             <span class="comment">// Check if work breaking chars in "Mathemetical opetartors"</span>
00458             <span class="comment">//</span>
00459             <span class="keywordflow">if</span> (wch == 0x2236)
00460                 <span class="keywordflow">return</span>(<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
00461             <span class="keywordflow">else</span>
00462                 <span class="keywordflow">return</span>(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
00463 
00464         <span class="keywordflow">case</span> 0x25:
00465             <span class="comment">//</span>
00466             <span class="comment">// Check if work breaking chars in "Form and Chart components"</span>
00467             <span class="comment">//</span>
00468             <span class="keywordflow">if</span> (wch == 0x2574)
00469                 <span class="keywordflow">return</span>(<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
00470             <span class="keywordflow">else</span>
00471                 <span class="keywordflow">return</span>(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
00472 
00473         <span class="keywordflow">case</span> 0x30:
00474             <span class="comment">//</span>
00475             <span class="comment">// Check if word breaking chars in "CJK symbols and punctuation"</span>
00476             <span class="comment">// and Hiragana.</span>
00477             <span class="comment">//</span>
00478             <span class="keywordflow">if</span> ((wch &gt;= 0x3001) &amp;&amp; (wch &lt;= 0x301E))
00479                 <span class="keywordflow">return</span>((<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a11">BOOL</a>)(<a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a28">aCJKSymbol_EndBreak</a>[wch - 0x3001]));
00480             <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((wch == 0x309B) || (wch == 0x309C))
00481                 <span class="keywordflow">return</span>(<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
00482             <span class="keywordflow">else</span>
00483                 <span class="keywordflow">return</span>(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
00484 
00485         <span class="keywordflow">case</span> 0xFE:
00486             <span class="comment">//</span>
00487             <span class="comment">// Check if word breaking chars in "CNS 11643 compatibility"</span>
00488             <span class="comment">// or "Small variants".</span>
00489             <span class="comment">//</span>
00490             <span class="keywordflow">if</span> ((wch &gt;= 0xFE30) &amp;&amp; (wch &lt;= 0xFE5E))
00491                 <span class="keywordflow">return</span>((<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a11">BOOL</a>)(<a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a29">aCNS11643_SmallVariants_EndBreak</a>[wch - 0xFE30]));
00492             <span class="keywordflow">else</span>
00493                 <span class="keywordflow">return</span>(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
00494 
00495         <span class="keywordflow">case</span> 0xFF:
00496             <span class="comment">//</span>
00497             <span class="comment">// Check if word breaking chars in "Fullwidth ASCII variants",</span>
00498             <span class="comment">// "Halfwidth Katakana variants" or "Fullwidth symbol variants".</span>
00499             <span class="comment">//</span>
00500             <span class="keywordflow">if</span> ((wch &gt;= 0xFF01) &amp;&amp; (wch &lt;= 0xFF9F))
00501                 <span class="keywordflow">return</span>((<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a11">BOOL</a>)(<a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a30">aFullWidthHalfWidthVariants_EndBreak</a>[wch - 0xFF01]));
00502             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (wch &gt;= 0xFFE0)
00503                 <span class="keywordflow">return</span>(<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
00504             <span class="keywordflow">else</span>
00505                 <span class="keywordflow">return</span>(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
00506 
00507         <span class="keywordflow">default</span>:
00508             <span class="keywordflow">return</span>(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
00509     }
00510 }
00511 
<a name="l00512"></a><a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a22">00512</a> <span class="preprocessor">#define UserIsFELineBreak(wChar)    UserIsFELineBreakEnd(wChar)</span>
00513 <span class="preprocessor"></span>
00514 <span class="comment">/***************************************************************************\</span>
00515 <span class="comment">*  UserIsFullWidth() - Detects Far East FullWidth character.                *</span>
00516 <span class="comment">*                                                                           *</span>
00517 <span class="comment">* History:                                                                  *</span>
00518 <span class="comment">* 10-Mar-1996 HideyukN  Created                                             *</span>
00519 <span class="comment">\***************************************************************************/</span>
00520 
<a name="l00521"></a><a class="code" href="../../d4/d1/struct__FULLWIDTH__UNICODE.html">00521</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d4/d1/struct__FULLWIDTH__UNICODE.html">_FULLWIDTH_UNICODE</a> {
<a name="l00522"></a><a class="code" href="../../d4/d1/struct__FULLWIDTH__UNICODE.html#o0">00522</a>     WCHAR <a class="code" href="../../d4/d1/struct__FULLWIDTH__UNICODE.html#o0">Start</a>;
<a name="l00523"></a><a class="code" href="../../d4/d1/struct__FULLWIDTH__UNICODE.html#o1">00523</a>     WCHAR <a class="code" href="../../d4/d1/struct__FULLWIDTH__UNICODE.html#o1">End</a>;
00524 } <a class="code" href="../../d4/d1/struct__FULLWIDTH__UNICODE.html">FULLWIDTH_UNICODE</a>, *<a class="code" href="../../d4/d1/struct__FULLWIDTH__UNICODE.html">PFULLWIDTH_UNICODE</a>;
00525 
<a name="l00526"></a><a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a23">00526</a> <span class="preprocessor">#define NUM_FULLWIDTH_UNICODES    4</span>
00527 <span class="preprocessor"></span>
<a name="l00528"></a><a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a33">00528</a> CONST <a class="code" href="../../d4/d1/struct__FULLWIDTH__UNICODE.html">FULLWIDTH_UNICODE</a> <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a33">FullWidthUnicodes</a>[] = {
00529    { 0x4E00, 0x9FFF }, <span class="comment">// CJK_UNIFIED_IDOGRAPHS</span>
00530    { 0x3040, 0x309F }, <span class="comment">// HIRAGANA</span>
00531    { 0x30A0, 0x30FF }, <span class="comment">// KATAKANA</span>
00532    { 0xAC00, 0xD7A3 }  <span class="comment">// HANGUL</span>
00533 };
00534 
<a name="l00535"></a><a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a35">00535</a> <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a11">BOOL</a> <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a35">UserIsFullWidth</a>(DWORD dwCodePage,WCHAR wChar)
00536 {
00537     <a class="code" href="../../d9/d5/ndismain_8h.html#a263">INT</a>  index;
00538     <a class="code" href="../../d9/d5/ndismain_8h.html#a263">INT</a>  cChars;
00539 <span class="preprocessor">#ifdef _USERK_</span>
00540 <span class="preprocessor"></span>    <a class="code" href="../../d1/d1/bench_8c.html#a16">CHAR</a> aChars[2];
00541 <span class="preprocessor">#endif // _USERK_</span>
00542 <span class="preprocessor"></span>
00543     <span class="comment">//</span>
00544     <span class="comment">// Early out for ASCII.</span>
00545     <span class="comment">//</span>
00546     <span class="keywordflow">if</span> (wChar &lt; 0x0080) {
00547         <span class="comment">//</span>
00548         <span class="comment">// if the character &lt; 0x0080, it should be a halfwidth character.</span>
00549         <span class="comment">//</span>
00550         <span class="keywordflow">return</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
00551     }
00552     <span class="comment">//</span>
00553     <span class="comment">// Scan FullWdith definition table... most of FullWidth character is</span>
00554     <span class="comment">// defined here... this is more faster than call NLS API.</span>
00555     <span class="comment">//</span>
00556     <span class="keywordflow">for</span> (index = 0; index &lt; <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a23">NUM_FULLWIDTH_UNICODES</a>; index++) {
00557         <span class="keywordflow">if</span> ((wChar &gt;= <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a33">FullWidthUnicodes</a>[index].<a class="code" href="../../d4/d1/struct__FULLWIDTH__UNICODE.html#o0">Start</a>) &amp;&amp;
00558             (wChar &lt;= <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a33">FullWidthUnicodes</a>[index].<a class="code" href="../../d4/d1/struct__FULLWIDTH__UNICODE.html#o1">End</a>)      ) {
00559             <span class="keywordflow">return</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
00560         }
00561     }
00562     <span class="comment">//</span>
00563     <span class="comment">// if this Unicode character is mapped to Double-Byte character,</span>
00564     <span class="comment">// this is also FullWidth character..</span>
00565     <span class="comment">//</span>
00566 <span class="preprocessor">#ifdef _USERK_</span>
00567 <span class="preprocessor"></span>    cChars = EngWideCharToMultiByte((<a class="code" href="../../d9/d5/ndismain_8h.html#a265">UINT</a>)dwCodePage,&amp;wChar,<span class="keyword">sizeof</span>(WCHAR),aChars,<span class="keyword">sizeof</span>(aChars));
00568 <span class="preprocessor">#else</span>
00569 <span class="preprocessor"></span>    cChars = WideCharToMultiByte((<a class="code" href="../../d9/d5/ndismain_8h.html#a265">UINT</a>)dwCodePage,0,&amp;wChar,1,<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,0,<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00570 <span class="preprocessor">#endif // _USERK_</span>
00571 <span class="preprocessor"></span>
00572     <span class="keywordflow">return</span>(cChars &gt; 1 ? <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> : <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
00573 }
00574 <span class="comment">/***************************************************************************\</span>
00575 <span class="comment">*  UserTextOutWInternal</span>
00576 <span class="comment">*  Wrapper for UserTextOutW, used to adjust the parameter passed to</span>
00577 <span class="comment">*  PSMTextOut</span>
00578 <span class="comment">*</span>
00579 <span class="comment">\***************************************************************************/</span>
<a name="l00580"></a><a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a36">00580</a> <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a11">BOOL</a> <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a36">UserTextOutWInternal</a>(
00581     HDC     hdc,
00582     <span class="keywordtype">int</span>     x,
00583     <span class="keywordtype">int</span>     y,
00584     LPCWSTR lp,
00585     UINT    cc,
00586     DWORD   dwFlags)
00587 {
00588     UNREFERENCED_PARAMETER(<a class="code" href="../../d3/d8/propapi_8h.html#a34">dwFlags</a>);
00589     <span class="keywordflow">return</span> <a class="code" href="../../d6/d1/userrtl_8h.html#a23">UserTextOutW</a>(hdc, x, y, lp, cc);
00590 }
00591 
00592 
00593 <span class="comment">/*--------------------------------------------------------------------------*/</span>
00594 <span class="comment">/*                                                                          */</span>
00595 <span class="comment">/*  KKGetPrefixWidth() -                                                    */</span>
00596 <span class="comment">/*                                                                          */</span>
00597 <span class="comment">/*  Returns total width of prefix character. Japanese Windows has           */</span>
00598 <span class="comment">/*  three shortcut prefixes, '&amp;',\036 and \037.  They may have              */</span>
00599 <span class="comment">/*  different width.                                                        */</span>
00600 <span class="comment">/*                                                                          */</span>
00601 <span class="comment">/*    From Chicago ctlmgr.c HideyukN                                        */</span>
00602 <span class="comment">/*--------------------------------------------------------------------------*/</span>
00603 
<a name="l00604"></a><a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a37">00604</a> <span class="keywordtype">int</span> <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a37">KKGetPrefixWidth</a>(HDC hdc, LPCWSTR lpStr, <span class="keywordtype">int</span> cch)
00605 {
00606     SIZE size;
00607     SIZE iPrefix1 = {-1<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>,-1<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>};
00608     SIZE iPrefix2 = {-1<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>,-1<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>};
00609     SIZE iPrefix3 = {-1<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>,-1<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>};
00610     <span class="keywordtype">int</span>  iTotal   = 0;
00611 
00612     <span class="keywordflow">while</span> (cch-- &gt; 0 &amp;&amp; *lpStr) {
00613         <span class="keywordflow">switch</span>(*lpStr) {
00614         <span class="keywordflow">case</span> <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a894">CH_PREFIX</a>:
00615             <span class="keywordflow">if</span> (lpStr[1] != <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a894">CH_PREFIX</a>) {
00616                 <span class="keywordflow">if</span> (iPrefix1.cx == -1) {
00617                     <a class="code" href="../../d6/d1/userrtl_8h.html#a11">UserGetTextExtentPointW</a>(hdc, lpStr, 1, &amp;iPrefix1);
00618                 }
00619                 iTotal += iPrefix1.cx;
00620             } <span class="keywordflow">else</span> {
00621                 lpStr++;
00622                 cch--;
00623             }
00624             <span class="keywordflow">break</span>;
00625         <span class="keywordflow">case</span> <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a895">CH_ENGLISHPREFIX</a>:
00626             <span class="keywordflow">if</span> (iPrefix2.cx == -1) {
00627                  <a class="code" href="../../d6/d1/userrtl_8h.html#a11">UserGetTextExtentPointW</a>(hdc, lpStr, 1, &amp;iPrefix2);
00628             }
00629             iTotal += iPrefix2.cx;
00630             <span class="keywordflow">break</span>;
00631         <span class="keywordflow">case</span> <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a896">CH_KANJIPREFIX</a>:
00632             <span class="keywordflow">if</span> (iPrefix3.cx == -1) {
00633                  <a class="code" href="../../d6/d1/userrtl_8h.html#a11">UserGetTextExtentPointW</a>(hdc, lpStr, 1, &amp;iPrefix3);
00634             }
00635             iTotal += iPrefix3.cx;
00636             <span class="comment">//</span>
00637             <span class="comment">// In NT, always alpha numeric mode, Then we have to sum</span>
00638             <span class="comment">// KANA accel key prefix non visible char width.</span>
00639             <span class="comment">// so always add the extent for next char.</span>
00640             <span class="comment">//</span>
00641             <a class="code" href="../../d6/d1/userrtl_8h.html#a11">UserGetTextExtentPointW</a>(hdc, lpStr, 1, &amp;size);
00642             iTotal += size.cx;
00643             <span class="keywordflow">break</span>;
00644         <span class="keywordflow">default</span>:
00645             <span class="comment">// No need to taking care of Double byte since 2nd byte of</span>
00646             <span class="comment">// DBC is grater than 0x2f but all shortcut keys are less</span>
00647             <span class="comment">// than 0x30.</span>
00648             <span class="keywordflow">break</span>;
00649         }
00650         lpStr++;
00651     }
00652     <span class="keywordflow">return</span> iTotal;
00653 }
00654 
00655 <span class="comment">/*--------------------------------------------------------------------------*/</span>
00656 <span class="comment">/*                                                                          */</span>
00657 <span class="comment">/*  GetNextWordbreak() -                                                    */</span>
00658 <span class="comment">/*    From Chicago ctlmgr.c  FritzS                                         */</span>
00659 <span class="comment">/*                                                                          */</span>
00660 <span class="comment">/*--------------------------------------------------------------------------*/</span>
00661 
<a name="l00662"></a><a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a38">00662</a> LPCWSTR <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a38">GetNextWordbreak</a>(DWORD dwCodePage,
00663                          LPCWSTR lpch,
00664                          LPCWSTR lpchEnd,
00665                          DWORD  dwFormat,
00666                          <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a1109">LPDRAWTEXTDATA</a> lpDrawInfo)
00667 
00668 {
00669     <span class="comment">/* ichNonWhite is used to make sure we always make progress. */</span>
00670     <span class="keywordtype">int</span> ichNonWhite = 1;
00671     <span class="keywordtype">int</span> ichComplexBreak = 0;        <span class="comment">// Breaking opportunity for complex scripts</span>
00672 <span class="preprocessor">#if ((DT_WORDBREAK &amp; ~0xff) != 0)</span>
00673 <span class="preprocessor"></span><span class="preprocessor">#error cannot use BOOLEAN for DT_WORDBREAK, or you should use "!!" before assigning it</span>
00674 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00675 <span class="preprocessor"></span>    BOOLEAN fBreakSpace = (BOOLEAN)<a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a9">WORDBREAK</a>(dwFormat);
00676     <span class="comment">/*</span>
00677 <span class="comment">     * If DT_WORDBREAK and DT_NOFULLWIDTHCHARBREAK are both set, we must</span>
00678 <span class="comment">     * stop assuming FullWidth characters as word as we're doing in</span>
00679 <span class="comment">     * NT4 and Win95. Instead, CR/LF and/or white space will only be</span>
00680 <span class="comment">     * a line-break characters.</span>
00681 <span class="comment">     */</span>
00682     BOOLEAN fDbcsCharBreak = (fBreakSpace &amp;&amp; !<a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a11">NOFULLWIDTHCHARBREAK</a>(dwFormat));
00683 
00684 <span class="preprocessor">#ifdef _USERK_</span>
00685 <span class="preprocessor"></span>    <span class="comment">/*</span>
00686 <span class="comment">     * Well, we actually should not and do not call GetNextWordBreak() in</span>
00687 <span class="comment">     * kernel, since only Menu stuff (no word break!) calls DrawText from kernel.</span>
00688 <span class="comment">     * In reality, thanks to a smart linker, word-break helper</span>
00689 <span class="comment">     * functions even does not exist in win32k.sys.</span>
00690 <span class="comment">     * Later, we should explicitly omit to compile those routines when we</span>
00691 <span class="comment">     * build kernel.</span>
00692 <span class="comment">     */</span>
00693     UNREFERENCED_PARAMETER(dwFormat);
00694 <span class="preprocessor">#endif</span>
00695 <span class="preprocessor"></span>
00696     <span class="comment">// We must terminate this loop before lpch == lpchEnd, otherwise, we</span>
00697     <span class="comment">// may gp fault during *lpch.</span>
00698     <span class="keywordflow">while</span> (lpch &lt; lpchEnd) {
00699         <span class="keywordflow">switch</span> (*lpch) {
00700         <span class="keywordflow">case</span> <a class="code" href="../../d3/d2/client_2drawtext_8c.html#a0">CR</a>:
00701         <span class="keywordflow">case</span> <a class="code" href="../../d3/d2/client_2drawtext_8c.html#a1">LF</a>:
00702             <span class="keywordflow">return</span> lpch;
00703 
00704         <span class="keywordflow">case</span> <span class="charliteral">'\t'</span>:
00705         <span class="keywordflow">case</span> <span class="charliteral">' '</span>:
00706             <span class="keywordflow">if</span> (fBreakSpace)
00707                 <span class="keywordflow">return</span> (lpch + ichNonWhite);
00708 
00709             <span class="comment">/*** FALL THRU ***/</span>
00710 
00711         <span class="keywordflow">default</span>:
00712             <span class="comment">/*</span>
00713 <span class="comment">             * Since most Japanese writing don't use space character</span>
00714 <span class="comment">             * to separate each word, we define each Kanji character</span>
00715 <span class="comment">             * as a word.</span>
00716 <span class="comment">             */</span>
00717             <span class="keywordflow">if</span> (fDbcsCharBreak &amp;&amp; <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a35">UserIsFullWidth</a>(dwCodePage, *lpch)) {
00718                 <span class="keywordflow">if</span> (!ichNonWhite)
00719                     <span class="keywordflow">return</span> lpch;
00720                 <span class="comment">/*</span>
00721 <span class="comment">                 * if the next character is the last character of this string,</span>
00722 <span class="comment">                 * We return the character, even this is a "KINSOKU" charcter...</span>
00723 <span class="comment">                 */</span>
00724                 <span class="keywordflow">if</span> ((lpch+1) != lpchEnd) {
00725                     <span class="comment">/*</span>
00726 <span class="comment">                     * Check next character of FullWidth character.</span>
00727 <span class="comment">                     * if the next character is "KINSOKU" character, the character</span>
00728 <span class="comment">                     * should be handled as a part of previous FullWidth character.</span>
00729 <span class="comment">                     * Never handle is as A character, and should not be a Word also.</span>
00730 <span class="comment">                     */</span>
00731                     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a22">UserIsFELineBreak</a>(*(lpch+1))) {
00732                         <span class="comment">/*</span>
00733 <span class="comment">                         * Then if the character is "KINSOKU" character, we return</span>
00734 <span class="comment">                         * the next of this character,...</span>
00735 <span class="comment">                         */</span>
00736                         <span class="keywordflow">return</span> (lpch + 1 + 1);
00737                     }
00738                 }
00739                 <span class="comment">/*</span>
00740 <span class="comment">                 * Otherwise, we just return the chracter that is next of FullWidth</span>
00741 <span class="comment">                 * Character. Because we treat A FullWidth chacter as A Word.</span>
00742 <span class="comment">                 */</span>
00743                 <span class="keywordflow">return</span> (lpch + 1);
00744             }
00745             <span class="comment">/*</span>
00746 <span class="comment">             * If the character is not a FullWidth character and the complex script</span>
00747 <span class="comment">             * LPK is present. Call it to determine the breaking opportunity for</span>
00748 <span class="comment">             * script that requires word break such as Thai. Note that if *lpch is</span>
00749 <span class="comment">             * NOT a complex script character. The LPK will fail the call and return 0</span>
00750 <span class="comment">             * since currently Uniscribe does not know how to handle FE break.</span>
00751 <span class="comment">             */</span>
00752             <span class="keywordflow">else</span> <span class="keywordflow">if</span>(fBreakSpace &amp;&amp; lpDrawInfo-&gt;bCharsetDll) {
00753 <span class="preprocessor">#ifdef _USERK_</span>
00754 <span class="preprocessor"></span>                <a class="code" href="../../d2/d8/structtagTHREADINFO.html">PTHREADINFO</a> ptiCurrent = <a class="code" href="../../d4/d1/userk_8h.html#a10">PtiCurrentShared</a>();
00755                 <span class="keywordflow">if</span>(<a class="code" href="../../d4/d1/userk_8h.html#a393">CALL_LPK</a>(ptiCurrent))
00756 <span class="preprocessor">#endif</span>
00757 <span class="preprocessor"></span>                    ichComplexBreak = (*UserLpkDrawTextEx)(0, 0, 0, lpch, (<span class="keywordtype">int</span>)(lpchEnd - lpch), 0,
00758                                         0, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a900">DT_GETNEXTWORD</a>, -1);
00759                 <span class="keywordflow">if</span> (ichComplexBreak &gt; 0)
00760                     <span class="keywordflow">return</span> (lpch + ichComplexBreak);
00761             }
00762             lpch++;
00763             ichNonWhite = 0;
00764         }
00765     }
00766 
00767     <span class="keywordflow">return</span> lpch;
00768 }
00769 
00770 <span class="comment">/***************************************************************************\</span>
00771 <span class="comment">* GetPrefixCount</span>
00772 <span class="comment">*</span>
00773 <span class="comment">* This routine returns the count of accelerator mnemonics and the</span>
00774 <span class="comment">* character location (starting at 0) of the character to underline.</span>
00775 <span class="comment">* A single CH_PREFIX character will be striped and the following character</span>
00776 <span class="comment">* underlined, all double CH_PREFIX character sequences will be replaced by</span>
00777 <span class="comment">* a single CH_PREFIX (this is done by PSMTextOut). This routine is used</span>
00778 <span class="comment">* to determine the actual character length of the string that will be</span>
00779 <span class="comment">* printed, and the location the underline should be placed. Only</span>
00780 <span class="comment">* cch characters from the input string will be processed. If the lpstrCopy</span>
00781 <span class="comment">* parameter is non-NULL, this routine will make a printable copy of the</span>
00782 <span class="comment">* string with all single prefix characters removed and all double prefix</span>
00783 <span class="comment">* characters collapsed to a single character. If copying, a maximum</span>
00784 <span class="comment">* character count must be specified which will limit the number of</span>
00785 <span class="comment">* characters copied.</span>
00786 <span class="comment">*</span>
00787 <span class="comment">* The location of the single CH_PREFIX is returned in the low order</span>
00788 <span class="comment">* word, and the count of CH_PREFIX characters that will be striped</span>
00789 <span class="comment">* from the string during printing is in the hi order word. If the</span>
00790 <span class="comment">* high order word is 0, the low order word is meaningless. If there</span>
00791 <span class="comment">* were no single prefix characters (i.e. nothing to underline), the</span>
00792 <span class="comment">* low order word will be -1 (to distinguish from location 0).</span>
00793 <span class="comment">*</span>
00794 <span class="comment">* These routines assume that there is only one single CH_PREFIX character</span>
00795 <span class="comment">* in the string.</span>
00796 <span class="comment">*</span>
00797 <span class="comment">* WARNING! this rountine returns information in BYTE count not CHAR count</span>
00798 <span class="comment">* (so it can easily be passed onto GreExtTextOutW which takes byte</span>
00799 <span class="comment">* counts as well)</span>
00800 <span class="comment">*</span>
00801 <span class="comment">* History:</span>
00802 <span class="comment">* 11-13-90 JimA         Ported to NT</span>
00803 <span class="comment">* 30-Nov-1992 mikeke    Client side version</span>
00804 <span class="comment">\***************************************************************************/</span>
00805 
<a name="l00806"></a><a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a39">00806</a> LONG <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a39">GetPrefixCount</a>(
00807     LPCWSTR lpstr,
00808     <span class="keywordtype">int</span> cch,
00809     LPWSTR lpstrCopy,
00810     <span class="keywordtype">int</span> charcopycount)
00811 {
00812     <span class="keywordtype">int</span> chprintpos = 0;         <span class="comment">/* Num of chars that will be printed */</span>
00813     <span class="keywordtype">int</span> chcount = 0;            <span class="comment">/* Num of prefix chars that will be removed */</span>
00814     <span class="keywordtype">int</span> chprefixloc = -1;       <span class="comment">/* Pos (in printed chars) of the prefix */</span>
00815     WCHAR ch;
00816 
00817     <span class="comment">/*</span>
00818 <span class="comment">     * If not copying, use a large bogus count...</span>
00819 <span class="comment">     */</span>
00820     <span class="keywordflow">if</span> (lpstrCopy == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)
00821         charcopycount = 32767;
00822 
00823     <span class="keywordflow">while</span> ((cch-- &gt; 0) &amp;&amp; *lpstr &amp;&amp; charcopycount-- != 0) {
00824 
00825         <span class="comment">/*</span>
00826 <span class="comment">         * Is this guy a prefix character ?</span>
00827 <span class="comment">         */</span>
00828         <span class="keywordflow">if</span> ((ch = *lpstr++) == <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a894">CH_PREFIX</a>) {
00829 
00830             <span class="comment">/*</span>
00831 <span class="comment">             * Yup - increment the count of characters removed during print.</span>
00832 <span class="comment">             */</span>
00833             chcount++;
00834 
00835             <span class="comment">/*</span>
00836 <span class="comment">             * Is the next also a prefix char?</span>
00837 <span class="comment">             */</span>
00838             <span class="keywordflow">if</span> (*lpstr != <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a894">CH_PREFIX</a>) {
00839 
00840                 <span class="comment">/*</span>
00841 <span class="comment">                 * Nope - this is a real one, mark its location.</span>
00842 <span class="comment">                 */</span>
00843                 chprefixloc = chprintpos;
00844 
00845             } <span class="keywordflow">else</span> {
00846 
00847                 <span class="comment">/*</span>
00848 <span class="comment">                 * yup - simply copy it if copying.</span>
00849 <span class="comment">                 */</span>
00850                 <span class="keywordflow">if</span> (lpstrCopy != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)
00851                     *(lpstrCopy++) = <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a894">CH_PREFIX</a>;
00852                 cch--;
00853                 lpstr++;
00854                 chprintpos++;
00855             }
00856         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ch == <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a895">CH_ENGLISHPREFIX</a>) {    <span class="comment">// Still needs to be parsed</span>
00857             <span class="comment">/*</span>
00858 <span class="comment">             * Yup - increment the count of characters removed during print.</span>
00859 <span class="comment">             */</span>
00860             chcount++;
00861 
00862             <span class="comment">/*</span>
00863 <span class="comment">             * Next character is a real one, mark its location.</span>
00864 <span class="comment">             */</span>
00865             chprefixloc = chprintpos;
00866 
00867         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ch == <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a896">CH_KANJIPREFIX</a>) {      <span class="comment">// Still needs to be parsed</span>
00868             <span class="comment">/*</span>
00869 <span class="comment">             * We only support Alpha Numeric(CH_ENGLISHPREFIX).</span>
00870 <span class="comment">             * no support for Kana(CH_KANJIPREFIX).</span>
00871 <span class="comment">             */</span>
00872             <span class="comment">/*</span>
00873 <span class="comment">             * Yup - increment the count of characters removed during print.</span>
00874 <span class="comment">             */</span>
00875             chcount++;
00876 
00877             <span class="keywordflow">if</span>(cch) {
00878                 <span class="comment">/* don't copy the character */</span>
00879                 chcount++;
00880                 lpstr++;
00881                 cch--;
00882             }
00883         } <span class="keywordflow">else</span> {
00884 
00885             <span class="comment">/*</span>
00886 <span class="comment">             * Nope - just inc count of char.  that will be printed</span>
00887 <span class="comment">             */</span>
00888             chprintpos++;
00889             <span class="keywordflow">if</span> (lpstrCopy != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)
00890                 *(lpstrCopy++) = ch;
00891         }
00892     }
00893 
00894     <span class="keywordflow">if</span> (lpstrCopy != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)
00895         *lpstrCopy = 0;
00896 
00897     <span class="comment">/*</span>
00898 <span class="comment">     * Return the character counts</span>
00899 <span class="comment">     */</span>
00900     <span class="keywordflow">return</span> MAKELONG(chprefixloc, chcount);
00901 }
00902 
00903 <span class="comment">/***************************************************************************\</span>
00904 <span class="comment">*  DT_GetExtentMinusPrefixes</span>
00905 <span class="comment">\***************************************************************************/</span>
00906 
<a name="l00907"></a><a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a40">00907</a> <span class="keywordtype">int</span> <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a40">DT_GetExtentMinusPrefixes</a>(HDC hdc, LPCWSTR lpchStr, <span class="keywordtype">int</span> cchCount, UINT wFormat, 
00908                         <span class="keywordtype">int</span> iOverhang, LPDRAWTEXTDATA  lpDrawInfo, <span class="keywordtype">int</span> iCharSet)
00909 {
00910   <span class="keywordtype">int</span>  iPrefixCount;
00911   <span class="keywordtype">int</span>  cxPrefixes = 0;
00912   WCHAR PrefixChar = <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a894">CH_PREFIX</a>;
00913   SIZE size;
00914   <a class="code" href="../../d2/d2/struct__CLIENTINFO.html">PCLIENTINFO</a> pci = <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a16">GetClientInfo</a>();
00915 <span class="preprocessor">#ifdef _USERK_</span>
00916 <span class="preprocessor"></span>  <a class="code" href="../../d2/d8/structtagTHREADINFO.html">PTHREADINFO</a> ptiCurrent = <a class="code" href="../../d4/d1/userk_8h.html#a10">PtiCurrentShared</a>();
00917 <span class="preprocessor">#endif</span>
00918 <span class="preprocessor"></span>  UNREFERENCED_PARAMETER(wFormat);
00919 
00920   <span class="keywordflow">if</span>(!<a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a5">NOPREFIX</a>(wFormat) &amp;&amp;
00921       (iPrefixCount = HIWORD(<a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a39">GetPrefixCount</a>(lpchStr, cchCount, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, 0)))) {
00922       <span class="comment">//</span>
00923       <span class="comment">// Kanji Windows has three shortcut prefixes...</span>
00924       <span class="comment">//  (ported from Win95 ctlmgr.c)</span>
00925       <span class="comment">//</span>
00926       <span class="keywordflow">if</span> (<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a125">IS_DBCS_ENABLED</a>() &amp;&amp; (pci-&gt;<a class="code" href="../../d2/d2/struct__CLIENTINFO.html#o4">dwTIFlags</a> &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a796">TIF_16BIT</a>)) {
00927           <span class="comment">// 16bit apps compatibility</span>
00928           cxPrefixes = <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a37">KKGetPrefixWidth</a>(hdc, lpchStr, cchCount) - (iPrefixCount * iOverhang);
00929       }
00930       <span class="keywordflow">else</span> {
00931           <span class="keywordflow">if</span>(lpDrawInfo-&gt;bCharsetDll) {
00932 <span class="preprocessor">#ifdef _USERK_</span>
00933 <span class="preprocessor"></span>              <span class="keywordflow">if</span>(<a class="code" href="../../d4/d1/userk_8h.html#a393">CALL_LPK</a>(ptiCurrent))
00934 <span class="preprocessor">#endif // _USERK_</span>
00935 <span class="preprocessor"></span>              {
00936                   <span class="comment">// Call LPKDrawTextEx with fDraw = FALSE just to get the text extent.</span>
00937                   <span class="keywordflow">return</span> (*UserLpkDrawTextEx)(hdc, 0, 0, lpchStr, cchCount, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00938                          wFormat, lpDrawInfo, <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a897">DT_CHARSETDRAW</a>, iCharSet);
00939               }
00940           } <span class="keywordflow">else</span> {
00941               cxPrefixes = <a class="code" href="../../d6/d1/userrtl_8h.html#a11">UserGetTextExtentPointW</a>(hdc, &amp;PrefixChar, 1, &amp;size);
00942               cxPrefixes = size.cx - iOverhang;
00943               cxPrefixes *=  iPrefixCount;
00944           }
00945       }
00946   }
00947 <span class="preprocessor">#ifdef _USERK_</span>
00948 <span class="preprocessor"></span>  <span class="keywordflow">if</span>(<a class="code" href="../../d4/d1/userk_8h.html#a393">CALL_LPK</a>(ptiCurrent))
00949     <a class="code" href="../../d4/d1/userk_8h.html#a1412">xxxClientGetTextExtentPointW</a>(hdc, lpchStr, cchCount, &amp;size);
00950   <span class="keywordflow">else</span>
00951 <span class="preprocessor">#endif // _USERK_</span>
00952 <span class="preprocessor"></span>    <a class="code" href="../../d6/d1/userrtl_8h.html#a11">UserGetTextExtentPointW</a>(hdc, lpchStr, cchCount, &amp;size);
00953   <span class="keywordflow">return</span> (size.cx - cxPrefixes);
00954 }
00955 
00956 <span class="comment">/***************************************************************************\</span>
00957 <span class="comment">*   DT_DrawStr</span>
00958 <span class="comment">*      This will draw the given string in the given location without worrying</span>
00959 <span class="comment">*  about the left/right justification. Gets the extent and returns it.</span>
00960 <span class="comment">*  If fDraw is TRUE and if NOT DT_CALCRECT, this draws the text.</span>
00961 <span class="comment">*        NOTE: This returns the extent minus Overhang.</span>
00962 <span class="comment">*</span>
00963 <span class="comment">*   From Chicago ctlmgr.c  FritzS</span>
00964 <span class="comment">\***************************************************************************/</span>
<a name="l00965"></a><a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a41">00965</a> <span class="keywordtype">int</span> <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a41">DT_DrawStr</a>(HDC hdc, <span class="keywordtype">int</span>  xLeft, <span class="keywordtype">int</span> yTop, LPCWSTR lpchStr,
00966                <span class="keywordtype">int</span> cchCount, BOOL fDraw, UINT wFormat,
00967                LPDRAWTEXTDATA  lpDrawInfo, <span class="keywordtype">int</span> iCharSet)
00968 {
00969     LPCWSTR        lpch;
00970     <span class="keywordtype">int</span>   iLen;
00971     <span class="keywordtype">int</span>   cxExtent;
00972     <span class="keywordtype">int</span>   xOldLeft = xLeft;  <span class="comment">// Save the xLeft given to compute the extent later</span>
00973     <span class="keywordtype">int</span>   xTabLength = lpDrawInfo-&gt;cxTabLength;
00974     <span class="keywordtype">int</span>   iTabOrigin = lpDrawInfo-&gt;rcFormat.left;
00975 
00976 <span class="preprocessor">#ifdef USE_MIRRORING</span>
00977 <span class="preprocessor"></span>    <span class="comment">//</span>
00978     <span class="comment">// Because xLeft and yTop is a point in a rect, and we shift the rect in a mirrored hdc to include</span>
00979     <span class="comment">// its most right pixel, then shift this point as well.</span>
00980     <span class="comment">//</span>
00981     <span class="keywordflow">if</span> (<a class="code" href="../../d6/d1/userrtl_8h.html#a28">UserGetLayout</a>(hdc) &amp; LAYOUT_RTL) {
00982         --xOldLeft;
00983         --xLeft;
00984     }
00985 <span class="preprocessor">#endif</span>
00986 <span class="preprocessor"></span>
00987     <span class="comment">//</span>
00988     <span class="comment">// if there is a charset dll, let it draw the text.</span>
00989     <span class="comment">//</span>
00990     <span class="keywordflow">if</span>(lpDrawInfo-&gt;bCharsetDll) {
00991 <span class="preprocessor">#ifdef _USERK_</span>
00992 <span class="preprocessor"></span>        <a class="code" href="../../d2/d8/structtagTHREADINFO.html">PTHREADINFO</a> ptiCurrent = <a class="code" href="../../d4/d1/userk_8h.html#a10">PtiCurrentShared</a>();
00993 
00994         <span class="comment">//</span>
00995         <span class="comment">// Don't perform a callback if in thread cleanup mode.</span>
00996         <span class="comment">//</span>
00997         <span class="keywordflow">if</span>(!<a class="code" href="../../d4/d1/userk_8h.html#a393">CALL_LPK</a>(ptiCurrent))
00998             <span class="keywordflow">return</span> 0 ;
00999 <span class="preprocessor">#endif // _USERK_</span>
01000 <span class="preprocessor"></span>        <span class="keywordflow">return</span> (*UserLpkDrawTextEx)(hdc, xLeft, yTop, lpchStr, cchCount, fDraw,
01001                    wFormat, lpDrawInfo, <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a897">DT_CHARSETDRAW</a>, iCharSet);
01002     }
01003 
01004     <span class="comment">// Check if the tabs need to be expanded</span>
01005     <span class="keywordflow">if</span>(<a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a2">EXPANDTABS</a>(wFormat)) {
01006         <span class="keywordflow">while</span>(cchCount) {
01007             <span class="comment">// Look for a tab</span>
01008             <span class="keywordflow">for</span>(iLen = 0, lpch = lpchStr; iLen &lt; cchCount; iLen++)
01009                   <span class="keywordflow">if</span>(*lpch++ == TEXT(<span class="charliteral">'\t'</span>))
01010                     <span class="keywordflow">break</span>;
01011 
01012                 <span class="comment">// Draw text, if any, upto the tab</span>
01013             <span class="keywordflow">if</span> (iLen) {
01014                 <span class="comment">// Draw the substring taking care of the prefixes.</span>
01015                 <span class="keywordflow">if</span> (fDraw &amp;&amp; !<a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a0">CALCRECT</a>(wFormat)) { <span class="comment">// Only if we need to draw text</span>
01016                     (*(lpDrawInfo-&gt;lpfnTextDraw))(hdc, xLeft, yTop, (LPWSTR)lpchStr, iLen, wFormat);
01017                 }
01018                 <span class="comment">// Get the extent of this sub string and add it to xLeft.</span>
01019                 xLeft += <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a40">DT_GetExtentMinusPrefixes</a>(hdc, lpchStr, iLen, wFormat, lpDrawInfo-&gt;cxOverhang, lpDrawInfo, iCharSet) - lpDrawInfo-&gt;cxOverhang;
01020             }
01021 
01022             <span class="comment">//if a TAB was found earlier, calculate the start of next sub-string.</span>
01023             <span class="keywordflow">if</span> (iLen &lt; cchCount) {
01024                 iLen++;  <span class="comment">// Skip the tab</span>
01025                 <span class="keywordflow">if</span> (xTabLength) <span class="comment">// Tab length could be zero</span>
01026                     xLeft = (((xLeft - iTabOrigin)/xTabLength) + 1)*xTabLength + iTabOrigin;
01027             }
01028 
01029             <span class="comment">// Calculate the details of the string that remains to be drawn.</span>
01030             cchCount -= iLen;
01031             lpchStr = lpch;
01032         }
01033         cxExtent = xLeft - xOldLeft;
01034     } <span class="keywordflow">else</span> {
01035         <span class="comment">// If required, draw the text (with either PSMTextOut or PSTextOut)</span>
01036         <span class="keywordflow">if</span> (fDraw &amp;&amp; !<a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a0">CALCRECT</a>(wFormat)) {
01037             (*(lpDrawInfo-&gt;lpfnTextDraw))(hdc, xLeft, yTop, (LPWSTR)lpchStr, cchCount, wFormat);
01038         }
01039         <span class="comment">// Compute the extent of the text.</span>
01040         cxExtent = <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a40">DT_GetExtentMinusPrefixes</a>(hdc, lpchStr, cchCount, wFormat,
01041                                              lpDrawInfo-&gt;cxOverhang, lpDrawInfo, iCharSet) - lpDrawInfo-&gt;cxOverhang;
01042     }
01043     <span class="keywordflow">return</span> cxExtent;
01044 }
01045 
01046 <span class="comment">/***************************************************************************\</span>
01047 <span class="comment">*  DT_DrawJustifiedLine</span>
01048 <span class="comment">*      This function draws one complete line with proper justification</span>
01049 <span class="comment">*</span>
01050 <span class="comment">*   from Chicago ctlmgr.c  FritzS</span>
01051 <span class="comment">\***************************************************************************/</span>
01052 
<a name="l01053"></a><a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a42">01053</a> <span class="keywordtype">void</span> <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a42">DT_DrawJustifiedLine</a>(HDC  hdc, <span class="keywordtype">int</span> yTop, LPCWSTR lpchLineSt,
01054                                  <span class="keywordtype">int</span> cchCount, UINT wFormat,
01055                                  LPDRAWTEXTDATA lpDrawInfo, <span class="keywordtype">int</span> iCharSet)
01056 {
01057   LPRECT lprc;
01058   <span class="keywordtype">int</span>   cxExtent;
01059   <span class="keywordtype">int</span>   xLeft;
01060 
01061   lprc = &amp;(lpDrawInfo-&gt;rcFormat);
01062   xLeft = lprc-&gt;left;
01063 
01064   <span class="comment">// Handle the special justifications (right or centered) properly.</span>
01065   <span class="keywordflow">if</span>(wFormat &amp; (DT_CENTER | DT_RIGHT)) {
01066       cxExtent = <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a41">DT_DrawStr</a>(hdc, xLeft, yTop, lpchLineSt, cchCount, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
01067                      wFormat, lpDrawInfo, iCharSet) + lpDrawInfo-&gt;cxOverhang;
01068       <span class="keywordflow">if</span>(wFormat &amp; DT_CENTER)
01069           xLeft = lprc-&gt;left + (((lprc-&gt;right - lprc-&gt;left) - cxExtent) &gt;&gt; 1);
01070       <span class="keywordflow">else</span>
01071           xLeft = lprc-&gt;right - cxExtent;
01072     } <span class="keywordflow">else</span>
01073       xLeft = lprc-&gt;left;
01074 
01075   <span class="comment">// Draw the whole line.</span>
01076   cxExtent = <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a41">DT_DrawStr</a>(hdc, xLeft, yTop, lpchLineSt, cchCount, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, wFormat,
01077                         lpDrawInfo, iCharSet) +lpDrawInfo-&gt;cxOverhang;
01078   <span class="keywordflow">if</span>(cxExtent &gt; lpDrawInfo-&gt;cxMaxExtent)
01079       lpDrawInfo-&gt;cxMaxExtent = cxExtent;
01080 }
01081 
01082 <span class="comment">/***************************************************************************\</span>
01083 <span class="comment">* DT_InitDrawTextInfo</span>
01084 <span class="comment">*      This is called at the begining of DrawText(); This initializes the</span>
01085 <span class="comment">* DRAWTEXTDATA structure passed to this function with all the required info.</span>
01086 <span class="comment">*</span>
01087 <span class="comment">*  from Chicago ctlmgr.c  FritzS</span>
01088 <span class="comment">\***************************************************************************/</span>
01089 
<a name="l01090"></a><a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a43">01090</a> <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a11">BOOL</a> <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a43">DT_InitDrawTextInfo</a>(
01091     HDC hdc,
01092     LPRECT lprc,
01093     UINT wFormat,
01094     LPDRAWTEXTDATA lpDrawInfo,
01095     LPDRAWTEXTPARAMS lpDTparams)
01096 {
01097   SIZE   sizeViewPortExt = {0, 0},sizeWindowExt = {0, 0};
01098   TEXTMETRICW tm;
01099   LPRECT      lprcDest;
01100   <span class="keywordtype">int</span>         iTabLength = 8;   <span class="comment">// Default Tab length is 8 characters.</span>
01101   <span class="keywordtype">int</span>         iLeftMargin;
01102   <span class="keywordtype">int</span>         iRightMargin;
01103   <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a11">BOOL</a>        fUseSystemFont;
01104 
01105   <span class="keywordflow">if</span> (lpDTparams) {
01106       <span class="comment">/*</span>
01107 <span class="comment">       *  Only if DT_TABSTOP flag is mentioned, we must use the iTabLength field.</span>
01108 <span class="comment">       */</span>
01109       <span class="keywordflow">if</span> (<a class="code" href="../../d4/d5/conimep_8h.html#a25">TABSTOP</a>(wFormat))
01110           iTabLength = lpDTparams-&gt;iTabLength;
01111       iLeftMargin = lpDTparams-&gt;iLeftMargin;
01112       iRightMargin = lpDTparams-&gt;iRightMargin;
01113   } <span class="keywordflow">else</span> {
01114       iLeftMargin = iRightMargin = 0;
01115   }
01116 
01117   <span class="comment">/*</span>
01118 <span class="comment">   *  Get the View port and Window extents for the given DC</span>
01119 <span class="comment">   *  If this call fails, hdc must be invalid</span>
01120 <span class="comment">   */</span>
01121   <span class="keywordflow">if</span> (!<a class="code" href="../../d6/d1/userrtl_8h.html#a13">UserGetViewportExtEx</a>(hdc,&amp;sizeViewPortExt)) {
01122 <span class="preprocessor">#ifndef _USERK_</span>
01123 <span class="preprocessor"></span>      <span class="comment">/*</span>
01124 <span class="comment">       * This call fails on  standard Metafiles. So check</span>
01125 <span class="comment">       * if the DC is really invalid to be compatible with</span>
01126 <span class="comment">       * Win9x</span>
01127 <span class="comment">       */</span>
01128       <span class="keywordflow">if</span> ((hdc == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) || !GdiValidateHandle(hdc))
01129 <span class="preprocessor">#endif</span>
01130 <span class="preprocessor"></span>          <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01131   }
01132   <a class="code" href="../../d6/d1/userrtl_8h.html#a14">UserGetWindowExtEx</a>(hdc, &amp;sizeWindowExt);
01133 
01134   <span class="comment">/*</span>
01135 <span class="comment">   *  For the current mapping mode,  find out the sign of x from left to right.</span>
01136 <span class="comment">   */</span>
01137   lpDrawInfo-&gt;iXSign =
01138       (((sizeViewPortExt.cx ^ sizeWindowExt.cx) &amp; 0x80000000) ? -1 : 1);
01139 
01140   <span class="comment">/*</span>
01141 <span class="comment">   *  For the current mapping mode,  find out the sign of y from top to bottom.</span>
01142 <span class="comment">   */</span>
01143   lpDrawInfo-&gt;iYSign =
01144       (((sizeViewPortExt.cy ^ sizeWindowExt.cy) &amp; 0x80000000) ? -1 : 1);
01145 
01146   <span class="comment">/*</span>
01147 <span class="comment">   *  Calculate the dimensions of the current font in this DC.</span>
01148 <span class="comment">   * (If it is SysFont AND the mapping mode is MM_TEXT, use system font's data)</span>
01149 <span class="comment">   */</span>
01150   fUseSystemFont = ((wFormat &amp; DT_INTERNAL) || <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a53">IsSysFontAndDefaultMode</a>(hdc));
01151   <span class="keywordflow">if</span> (!fUseSystemFont) {
01152       <span class="comment">/*</span>
01153 <span class="comment">       *  Edit controls have their own way of calculating the aveCharWidth.</span>
01154 <span class="comment">       */</span>
01155       <span class="keywordflow">if</span> (<a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a1">EDITCONTROL</a>(wFormat)) {
01156           tm.tmAveCharWidth = <a class="code" href="../../d6/d1/userrtl_8h.html#a6">UserGetCharDimensionsW</a>(hdc, &amp;tm, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
01157           tm.tmCharSet = (<a class="code" href="../../d9/d7/halvprnt_8c.html#a0">BYTE</a>)<a class="code" href="../../d6/d1/userrtl_8h.html#a24">UserGetTextCharsetInfo</a>(hdc, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, 0);
01158           <span class="keywordflow">if</span> (tm.tmAveCharWidth == 0) {
01159               fUseSystemFont = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01160           }
01161       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!<a class="code" href="../../d6/d1/userrtl_8h.html#a12">UserGetTextMetricsW</a>(hdc, &amp;tm)) {
01162           <span class="comment">/*</span>
01163 <span class="comment">           * This can fail in a hard error popup during logon or logoff</span>
01164 <span class="comment">           * because UpdatePerUserSystemParameters destroys the server-side</span>
01165 <span class="comment">           * font handle for the DC, and a repaint occurs before we switch</span>
01166 <span class="comment">           * desktops (the switch recreates the popup from scratch with the</span>
01167 <span class="comment">           * new font OK). ChrisWil's changes to move system-wide attributes</span>
01168 <span class="comment">           * into desktops should take care of this in Kernel-mode.  This is</span>
01169 <span class="comment">           * just a horrible, horrible hack for now.</span>
01170 <span class="comment">           */</span>
01171           RIPMSG0(RIP_WARNING, <span class="stringliteral">"UserGetTextMetricsW failed: only in logon/off?\n"</span>);
01172           tm.tmOverhang = 0;
01173 
01174           <span class="comment">/*</span>
01175 <span class="comment">           * We should probably set fUseSystemFont to TRUE here. But I</span>
01176 <span class="comment">           *  assume that this "horrible hack" works fine plus it has been</span>
01177 <span class="comment">           *  here for good. So I'll leave it alone. 6/3/96</span>
01178 <span class="comment">           */</span>
01179       }
01180   }
01181 
01182   <span class="keywordflow">if</span> (fUseSystemFont) {
01183       <span class="comment">/*</span>
01184 <span class="comment">       *  Avoid GetTextMetrics for internal calls since they use sys font.</span>
01185 <span class="comment">       */</span>
01186       tm.tmHeight = <a class="code" href="../../d1/d8/clglobal_8c.html#a4">gpsi</a>-&gt;cySysFontChar;
01187       tm.tmExternalLeading = <a class="code" href="../../d1/d8/clglobal_8c.html#a4">gpsi</a>-&gt;tmSysFont.tmExternalLeading;
01188       tm.tmAveCharWidth = <a class="code" href="../../d1/d8/clglobal_8c.html#a4">gpsi</a>-&gt;tmSysFont.tmAveCharWidth;
01189       tm.tmOverhang = <a class="code" href="../../d1/d8/clglobal_8c.html#a4">gpsi</a>-&gt;tmSysFont.tmOverhang;
01190 <span class="preprocessor">#ifdef _USERK_</span>
01191 <span class="preprocessor"></span>      tm.tmCharSet = (<a class="code" href="../../d9/d7/halvprnt_8c.html#a0">BYTE</a>)<a class="code" href="../../d6/d1/userrtl_8h.html#a24">UserGetTextCharsetInfo</a>(<a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a179">gpDispInfo</a>-&gt;<a class="code" href="../../d9/d3/structtagDISPLAYINFO.html#o3">hdcScreen</a>, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, 0);
01192 <span class="preprocessor">#else</span>
01193 <span class="preprocessor"></span>      tm.tmCharSet = (<a class="code" href="../../d9/d7/halvprnt_8c.html#a0">BYTE</a>)<a class="code" href="../../d6/d1/userrtl_8h.html#a24">UserGetTextCharsetInfo</a>(<a class="code" href="../../d1/d8/clglobal_8c.html#a26">ghdcBits2</a>, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, 0);
01194 <span class="preprocessor">#endif // _USERK_</span>
01195 <span class="preprocessor"></span>  }
01196 
01197 
01198   <span class="comment">// cyLineHeight is in pixels (This will be signed).</span>
01199   lpDrawInfo-&gt;cyLineHeight = (tm.tmHeight +
01200             (<a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a3">EXTERNALLEADING</a>(wFormat) ? tm.tmExternalLeading : 0)) *
01201             lpDrawInfo-&gt;iYSign;
01202 
01203   <span class="comment">// cxTabLength is the tab length in pixels (This will not be signed)</span>
01204   lpDrawInfo-&gt;cxTabLength = tm.tmAveCharWidth * iTabLength;
01205 
01206   <span class="comment">// Set the cxOverhang</span>
01207   lpDrawInfo-&gt;cxOverhang = tm.tmOverhang;
01208 
01209   <span class="comment">// Pick up the proper TextOut function based on the prefix processing reqd.</span>
01210 <span class="preprocessor">#ifdef _USERK_</span>
01211 <span class="preprocessor"></span>  lpDrawInfo-&gt;bCharsetDll = <a class="code" href="../../d4/d1/userk_8h.html#a16">PpiCurrent</a>()-&gt;dwLpkEntryPoints &amp; <a class="code" href="../../d4/d1/userk_8h.html#a390">LPK_DRAWTEXTEX</a>;
01212   <span class="keywordflow">if</span> (lpDrawInfo-&gt;bCharsetDll == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01213       lpDrawInfo-&gt;lpfnTextDraw = (<a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a5">NOPREFIX</a>(wFormat) ? (<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a1108">LPFNTEXTDRAW</a>)<a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a36">UserTextOutWInternal</a> : <a class="code" href="../../d5/d0/kernel_2text_8c.html#a1">xxxPSMTextOut</a>);
01214   }
01215 <span class="preprocessor">#else</span>
01216 <span class="preprocessor"></span>  lpDrawInfo-&gt;bCharsetDll = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a11">BOOL</a>)(<a class="code" href="../../d1/d8/clglobal_8c.html#a34">fpLpkDrawTextEx</a> != (<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a1112">FPLPKDRAWTEXTEX</a>)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
01217   <span class="keywordflow">if</span> (lpDrawInfo-&gt;bCharsetDll == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01218       lpDrawInfo-&gt;lpfnTextDraw = (<a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a5">NOPREFIX</a>(wFormat) ? (<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a1108">LPFNTEXTDRAW</a>)<a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a36">UserTextOutWInternal</a> : <a class="code" href="../../d3/d2/client_2drawtext_8c.html#a14">PSMTextOut</a>);
01219   }
01220 <span class="preprocessor">#endif // _USERK_</span>
01221 <span class="preprocessor"></span>
01222   <span class="comment">// Set up the format rectangle based on the margins.</span>
01223 <span class="comment">//  LCopyStruct(lprc, lprcDest = (LPRECT)&amp;(lpDrawInfo-&gt;rcFormat), sizeof(RECT));</span>
01224   lprcDest = &amp;(lpDrawInfo-&gt;rcFormat);
01225   *lprcDest = *lprc;
01226 
01227   <span class="comment">// We need to do the following only if the margins are given</span>
01228   <span class="keywordflow">if</span>(iLeftMargin | iRightMargin) {
01229       lprcDest-&gt;left += iLeftMargin * lpDrawInfo-&gt;iXSign;
01230       lprcDest-&gt;right -= (lpDrawInfo-&gt;cxRightMargin = iRightMargin * lpDrawInfo-&gt;iXSign);
01231     } <span class="keywordflow">else</span>
01232       lpDrawInfo-&gt;cxRightMargin = 0;  <span class="comment">// Initialize to zero.</span>
01233 
01234   <span class="comment">// cxMaxWidth is unsigned.</span>
01235   lpDrawInfo-&gt;cxMaxWidth = (lprcDest-&gt;right - lprcDest-&gt;left) * lpDrawInfo-&gt;iXSign;
01236   lpDrawInfo-&gt;cxMaxExtent = 0;  <span class="comment">// Initialize this to zero.</span>
01237 
01238   <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01239 }
01240 
01241 <span class="comment">/***************************************************************************\</span>
01242 <span class="comment">* DT_AdjustWhiteSpaces</span>
01243 <span class="comment">*      In the case of WORDWRAP, we need to treat the white spaces at the</span>
01244 <span class="comment">* begining/end of each line specially. This function does that.</span>
01245 <span class="comment">*  lpStNext = points to the begining of next line.</span>
01246 <span class="comment">*  lpiCount = points to the count of characters in the current line.</span>
01247 <span class="comment">\***************************************************************************/</span>
01248 
<a name="l01249"></a><a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a44">01249</a> LPCWSTR  <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a44">DT_AdjustWhiteSpaces</a>(LPCWSTR  lpStNext, LPINT lpiCount, UINT wFormat)
01250 {
01251   <span class="keywordflow">switch</span>(wFormat &amp; <a class="code" href="../../d3/d2/client_2drawtext_8c.html#a2">DT_HFMTMASK</a>) {
01252       <span class="keywordflow">case</span> DT_LEFT:
01253         <span class="comment">// Prevent a white space at the begining of a left justfied text.</span>
01254         <span class="comment">// Is there a white space at the begining of next line......</span>
01255         <span class="keywordflow">if</span>((*lpStNext == TEXT(<span class="charliteral">' '</span>)) || (*lpStNext == TEXT(<span class="charliteral">'\t'</span>))) {
01256             <span class="comment">// ...then, exclude it from next line.</span>
01257             lpStNext++;
01258           }
01259         <span class="keywordflow">break</span>;
01260 
01261       <span class="keywordflow">case</span> DT_RIGHT:
01262         <span class="comment">// Prevent a white space at the end of a RIGHT justified text.</span>
01263         <span class="comment">// Is there a white space at the end of current line,.......</span>
01264         <span class="keywordflow">if</span>((*(lpStNext-1) == TEXT(<span class="charliteral">' '</span>)) || (*(lpStNext - 1) == TEXT(<span class="charliteral">'\t'</span>))) {
01265             <span class="comment">// .....then, Skip the white space from the current line.</span>
01266             (*lpiCount)--;
01267           }
01268         <span class="keywordflow">break</span>;
01269 
01270       <span class="keywordflow">case</span> DT_CENTER:
01271         <span class="comment">// Exclude white spaces from the begining and end of CENTERed lines.</span>
01272         <span class="comment">// If there is a white space at the end of current line.......</span>
01273         <span class="keywordflow">if</span>((*(lpStNext-1) == TEXT(<span class="charliteral">' '</span>)) || (*(lpStNext - 1) == TEXT(<span class="charliteral">'\t'</span>)))
01274             (*lpiCount)--;    <span class="comment">//...., don't count it for justification.</span>
01275         <span class="comment">// If there is a white space at the begining of next line.......</span>
01276         <span class="keywordflow">if</span>((*lpStNext == TEXT(<span class="charliteral">' '</span>)) || (*lpStNext == TEXT(<span class="charliteral">'\t'</span>)))
01277             lpStNext++;       <span class="comment">//...., exclude it from next line.</span>
01278         <span class="keywordflow">break</span>;
01279     }
01280   <span class="keywordflow">return</span> lpStNext;
01281 }
01282 
01283 <span class="comment">/***************************************************************************\</span>
01284 <span class="comment">*  DT_BreakAWord</span>
01285 <span class="comment">*      A word needs to be broken across lines and this finds out where to</span>
01286 <span class="comment">*  break it.</span>
01287 <span class="comment">\***************************************************************************/</span>
<a name="l01288"></a><a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a45">01288</a> LPCWSTR  <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a45">DT_BreakAWord</a>(HDC  hdc, LPCWSTR lpchText,
01289               <span class="keywordtype">int</span> iLength, <span class="keywordtype">int</span> iWidth, UINT wFormat, <span class="keywordtype">int</span> iOverhang, LPDRAWTEXTDATA  lpDrawInfo, <span class="keywordtype">int</span> iCharSet)
01290 {
01291   <span class="keywordtype">int</span>  iLow = 0, iHigh = iLength;
01292   <span class="keywordtype">int</span>  iNew;
01293 
01294 
01295   <span class="keywordflow">while</span>((iHigh - iLow) &gt; 1) {
01296       iNew = iLow + (iHigh - iLow)/2;
01297       <span class="keywordflow">if</span>(<a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a40">DT_GetExtentMinusPrefixes</a>(hdc, lpchText, iNew, wFormat, iOverhang, lpDrawInfo, iCharSet) &gt; iWidth)
01298           iHigh = iNew;
01299       <span class="keywordflow">else</span>
01300           iLow = iNew;
01301     }
01302   <span class="comment">// If the width is too low, we must print atleast one char per line.</span>
01303   <span class="comment">// Else, we will be in an infinite loop.</span>
01304   <span class="keywordflow">if</span>(!iLow &amp;&amp; iLength)
01305       iLow = 1;
01306   <span class="keywordflow">return</span> (lpchText+iLow);
01307 }
01308 
01309 <span class="comment">/***************************************************************************\</span>
01310 <span class="comment">* DT_GetLineBreak</span>
01311 <span class="comment">*      This finds out the location where we can break a line.</span>
01312 <span class="comment">* Returns LPCSTR to the begining of next line.</span>
01313 <span class="comment">* Also returns via lpiLineLength, the length of the current line.</span>
01314 <span class="comment">* NOTE: (lpstNextLineStart - lpstCurrentLineStart) is not equal to the</span>
01315 <span class="comment">* line length; This is because, we exclude some white spaces at the begining</span>
01316 <span class="comment">* and/or end of lines; Also, CR/LF is excluded from the line length.</span>
01317 <span class="comment">\***************************************************************************/</span>
01318 
<a name="l01319"></a><a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a46">01319</a> LPWSTR <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a46">DT_GetLineBreak</a>(
01320     HDC  hdc,
01321     LPCWSTR lpchLineStart,
01322     <span class="keywordtype">int</span>   cchCount,
01323     DWORD dwFormat,
01324     LPINT lpiLineLength,
01325     LPDRAWTEXTDATA  lpDrawInfo,
01326     <span class="keywordtype">int</span> iCharSet)
01327 {
01328   LPCWSTR lpchText, lpchEnd, lpch, lpchLineEnd;
01329   <span class="keywordtype">int</span>   cxStart, cxExtent, cxNewExtent;
01330   <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a11">BOOL</a>  fAdjustWhiteSpaces = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01331   WCHAR  ch;
01332   <a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a> dwCodePage = USERGETCODEPAGE(hdc);
01333 
01334   cxStart = lpDrawInfo-&gt;rcFormat.left;
01335   cxExtent = cxNewExtent = 0;
01336   lpchText = lpchLineStart;
01337   lpchEnd = lpchLineStart + cchCount;
01338 
01339 
01340   <span class="keywordflow">while</span>(lpchText &lt; lpchEnd) {
01341       lpchLineEnd = lpch = <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a38">GetNextWordbreak</a>(dwCodePage,lpchText, lpchEnd, dwFormat, lpDrawInfo);
01342       <span class="comment">// DT_DrawStr does not return the overhang; Otherwise we will end up</span>
01343       <span class="comment">// adding one overhang for every word in the string.</span>
01344 
01345       <span class="comment">// For simulated Bold fonts, the summation of extents of individual</span>
01346       <span class="comment">// words in a line is greater than the extent of the whole line. So,</span>
01347       <span class="comment">// always calculate extent from the LineStart.</span>
01348       <span class="comment">// BUGTAG: #6054 -- Win95B -- SANKAR -- 3/9/95 --</span>
01349       cxNewExtent = <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a41">DT_DrawStr</a>(hdc, cxStart, 0, lpchLineStart, (<span class="keywordtype">int</span>)(((<a class="code" href="../../d9/d7/halvprnt_8c.html#a1">PBYTE</a>)lpch - (<a class="code" href="../../d9/d7/halvprnt_8c.html#a1">PBYTE</a>)lpchLineStart)/<span class="keyword">sizeof</span>(WCHAR)), <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
01350                  dwFormat, lpDrawInfo, iCharSet);
01351 
01352       <span class="keywordflow">if</span> (<a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a9">WORDBREAK</a>(dwFormat) &amp;&amp; ((cxNewExtent + lpDrawInfo-&gt;cxOverhang) &gt; lpDrawInfo-&gt;cxMaxWidth)) {
01353           <span class="comment">// Are there more than one word in this line?</span>
01354           <span class="keywordflow">if</span> (lpchText != lpchLineStart)  {
01355               lpchLineEnd = lpch = lpchText;
01356               fAdjustWhiteSpaces = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01357           } <span class="keywordflow">else</span> {
01358               <span class="comment">//One word is longer than the maximum width permissible.</span>
01359               <span class="comment">//See if we are allowed to break that single word.</span>
01360               <span class="keywordflow">if</span>(<a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a1">EDITCONTROL</a>(dwFormat) &amp;&amp; !<a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a10">WORDELLIPSIS</a>(dwFormat)) {
01361                   lpchLineEnd = lpch = <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a45">DT_BreakAWord</a>(hdc, lpchText, (<span class="keywordtype">int</span>)(((<a class="code" href="../../d9/d7/halvprnt_8c.html#a1">PBYTE</a>)lpch - (<a class="code" href="../../d9/d7/halvprnt_8c.html#a1">PBYTE</a>)lpchText)/<span class="keyword">sizeof</span>(WCHAR)),
01362                         lpDrawInfo-&gt;cxMaxWidth - cxExtent,
01363                         dwFormat,
01364                         lpDrawInfo-&gt;cxOverhang, lpDrawInfo, iCharSet); <span class="comment">//Break that word</span>
01365                   <span class="comment">//Note: Since we broke in the middle of a word, no need to</span>
01366                   <span class="comment">// adjust for white spaces.</span>
01367               } <span class="keywordflow">else</span> {
01368                   fAdjustWhiteSpaces = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01369                   <span class="comment">// Check if we need to end this line with ellipsis</span>
01370                   <span class="keywordflow">if</span>(<a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a10">WORDELLIPSIS</a>(dwFormat))
01371                     {
01372                       <span class="comment">// Don't do this if already at the end of the string.</span>
01373                       <span class="keywordflow">if</span> (lpch &lt; lpchEnd)
01374                         {
01375                           <span class="comment">// If there are CR/LF at the end, skip them.</span>
01376                           <span class="keywordflow">if</span> ((ch = *lpch) == <a class="code" href="../../d3/d2/client_2drawtext_8c.html#a0">CR</a> || ch == <a class="code" href="../../d3/d2/client_2drawtext_8c.html#a1">LF</a>)
01377                             {
01378                               <span class="keywordflow">if</span> ((++lpch &lt; lpchEnd) &amp;&amp; (*lpch == (WCHAR)(ch ^ (<a class="code" href="../../d3/d2/client_2drawtext_8c.html#a1">LF</a> ^ <a class="code" href="../../d3/d2/client_2drawtext_8c.html#a0">CR</a>))))
01379                                   lpch++;
01380                               fAdjustWhiteSpaces = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01381                             }
01382                         }
01383                     }
01384               }
01385           }
01386           <span class="comment">// Well! We found a place to break the line. Let us break from this</span>
01387           <span class="comment">// loop;</span>
01388           <span class="keywordflow">break</span>;
01389       } <span class="keywordflow">else</span> {
01390           <span class="comment">// Don't do this if already at the end of the string.</span>
01391           <span class="keywordflow">if</span> (lpch &lt; lpchEnd) {
01392               <span class="keywordflow">if</span> ((ch = *lpch) == <a class="code" href="../../d3/d2/client_2drawtext_8c.html#a0">CR</a> || ch == <a class="code" href="../../d3/d2/client_2drawtext_8c.html#a1">LF</a>) {
01393                   <span class="keywordflow">if</span> ((++lpch &lt; lpchEnd) &amp;&amp; (*lpch == (WCHAR)(ch ^ (<a class="code" href="../../d3/d2/client_2drawtext_8c.html#a1">LF</a> ^ <a class="code" href="../../d3/d2/client_2drawtext_8c.html#a0">CR</a>))))
01394                       lpch++;
01395                   fAdjustWhiteSpaces = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01396                   <span class="keywordflow">break</span>;
01397               }
01398           }
01399       }
01400 
01401       <span class="comment">// Point at the beginning of the next word.</span>
01402       lpchText = lpch;
01403       cxExtent = cxNewExtent;
01404   }
01405 
01406   <span class="comment">// Calculate the length of current line.</span>
01407   *lpiLineLength = (<a class="code" href="../../d9/d5/ndismain_8h.html#a263">INT</a>)((<a class="code" href="../../d9/d7/halvprnt_8c.html#a1">PBYTE</a>)lpchLineEnd - (<a class="code" href="../../d9/d7/halvprnt_8c.html#a1">PBYTE</a>)lpchLineStart)/<span class="keyword">sizeof</span>(WCHAR);
01408 
01409   <span class="comment">// Adjust the line length and lpch to take care of spaces.</span>
01410   <span class="keywordflow">if</span>(fAdjustWhiteSpaces &amp;&amp; (lpch &lt; lpchEnd))
01411       lpch = <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a44">DT_AdjustWhiteSpaces</a>(lpch, lpiLineLength, dwFormat);
01412 
01413   <span class="comment">// return the begining of next line;</span>
01414   <span class="keywordflow">return</span> (LPWSTR)lpch;
01415 }
01416 
01417 <span class="comment">/***************************************************************************\</span>
01418 <span class="comment">*  NeedsEndEllipsis()</span>
01419 <span class="comment">*      This function checks whether the given string fits within the given</span>
01420 <span class="comment">*      width or we need to add end-ellipse. If it required end-ellipses, it</span>
01421 <span class="comment">*      returns TRUE and it returns the number of characters that are saved</span>
01422 <span class="comment">*      in the given string via lpCount.</span>
01423 <span class="comment">\***************************************************************************/</span>
<a name="l01424"></a><a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a47">01424</a> <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a11">BOOL</a>  <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a47">NeedsEndEllipsis</a>(HDC        hdc,
01425                                      LPCWSTR     lpchText,
01426                                      LPINT      lpCount,
01427                                      LPDRAWTEXTDATA  lpDTdata,
01428                                      UINT       wFormat, LPDRAWTEXTDATA  lpDrawInfo, <span class="keywordtype">int</span> iCharSet)
01429 {
01430     <span class="keywordtype">int</span>   cchText;
01431     <span class="keywordtype">int</span>   ichMin, ichMax, ichMid;
01432     <span class="keywordtype">int</span>   cxMaxWidth;
01433     <span class="keywordtype">int</span>   iOverhang;
01434     <span class="keywordtype">int</span>   cxExtent;
01435     SIZE size;
01436     cchText = *lpCount;  <span class="comment">// Get the current count.</span>
01437 
01438     <span class="keywordflow">if</span> (cchText == 0)
01439         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01440 
01441     cxMaxWidth  = lpDTdata-&gt;cxMaxWidth;
01442     iOverhang   = lpDTdata-&gt;cxOverhang;
01443 
01444     cxExtent = <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a40">DT_GetExtentMinusPrefixes</a>(hdc, lpchText, cchText, wFormat, iOverhang, lpDrawInfo, iCharSet);
01445 
01446     <span class="keywordflow">if</span> (cxExtent &lt;= cxMaxWidth)
01447         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01448     <span class="comment">// Reserve room for the "..." ellipses;</span>
01449     <span class="comment">// (Assumption: The ellipses don't have any prefixes!)</span>
01450     <a class="code" href="../../d6/d1/userrtl_8h.html#a11">UserGetTextExtentPointW</a>(hdc, <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a24">szEllipsis</a>, <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a901">CCHELLIPSIS</a>, &amp;size);
01451     cxMaxWidth -= size.cx - iOverhang;
01452 
01453     <span class="comment">// If no room for ellipses, always show first character.</span>
01454     <span class="comment">//</span>
01455     ichMax = 1;
01456     <span class="keywordflow">if</span> (cxMaxWidth &gt; 0) {
01457         <span class="comment">// Binary search to find characters that will fit.</span>
01458         ichMin = 0;
01459         ichMax = cchText;
01460         <span class="keywordflow">while</span> (ichMin &lt; ichMax) {
01461             <span class="comment">// Be sure to round up, to make sure we make progress in</span>
01462             <span class="comment">// the loop if ichMax == ichMin + 1.</span>
01463             <span class="comment">//</span>
01464             ichMid = (ichMin + ichMax + 1) / 2;
01465 
01466             cxExtent = <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a40">DT_GetExtentMinusPrefixes</a>(hdc, lpchText, ichMid, wFormat, iOverhang, lpDrawInfo, iCharSet);
01467 
01468             <span class="keywordflow">if</span> (cxExtent &lt; cxMaxWidth)
01469                 ichMin = ichMid;
01470             <span class="keywordflow">else</span> {
01471                 <span class="keywordflow">if</span> (cxExtent &gt; cxMaxWidth)
01472                     ichMax = ichMid - 1;
01473                 <span class="keywordflow">else</span> {
01474                     <span class="comment">// Exact match up up to ichMid: just exit.</span>
01475                     <span class="comment">//</span>
01476                     ichMax = ichMid;
01477                     <span class="keywordflow">break</span>;
01478                   }
01479               }
01480           }
01481 
01482         <span class="comment">// Make sure we always show at least the first character...</span>
01483         <span class="comment">//</span>
01484         <span class="keywordflow">if</span> (ichMax &lt; 1)
01485             ichMax = 1;
01486       }
01487 
01488     *lpCount = ichMax;
01489     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01490 }
01491 
01492 <span class="comment">/***************************************************************************\</span>
01493 <span class="comment">* BOGUS: The same function is available in SHELL2.DLL also.</span>
01494 <span class="comment">* We need to remove from one of the places.</span>
01495 <span class="comment">\***************************************************************************/</span>
01496 <span class="comment">// Returns a pointer to the last component of a path string.</span>
01497 <span class="comment">//</span>
01498 <span class="comment">// in:</span>
01499 <span class="comment">//      path name, either fully qualified or not</span>
01500 <span class="comment">//</span>
01501 <span class="comment">// returns:</span>
01502 <span class="comment">//      pointer into the path where the path is.  if none is found</span>
01503 <span class="comment">//      returns a poiter to the start of the path</span>
01504 <span class="comment">//</span>
01505 <span class="comment">//  c:\foo\bar  -&gt; bar</span>
01506 <span class="comment">//  c:\foo      -&gt; foo</span>
01507 <span class="comment">//  c:\foo\     -&gt; c:\foo\      (REVIEW: is this case busted?)</span>
01508 <span class="comment">//  c:\         -&gt; c:\          (REVIEW: this case is strange)</span>
01509 <span class="comment">//  c:          -&gt; c:</span>
01510 <span class="comment">//  foo         -&gt; foo</span>
01511 <span class="comment">/***************************************************************************\</span>
01512 <span class="comment">\***************************************************************************/</span>
01513 
01514 
<a name="l01515"></a><a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a48">01515</a> LPWSTR <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a48">PathFindFileName</a>(LPCWSTR pPath, <span class="keywordtype">int</span> cchText)
01516 {
01517     LPCWSTR pT;
01518 
01519     <span class="keywordflow">for</span> (pT = pPath; cchText &gt; 0 &amp;&amp; *pPath; pPath++, cchText--) {
01520         <span class="keywordflow">if</span> ((pPath[0] == TEXT(<span class="charliteral">'\\'</span>) || pPath[0] == TEXT(<span class="charliteral">':'</span>)) &amp;&amp; pPath[1])
01521             pT = pPath + 1;
01522     }
01523 
01524     <span class="keywordflow">return</span> (LPWSTR)pT;   <span class="comment">// REVIEW, should this be const?</span>
01525 }
01526 
01527 <span class="comment">/***************************************************************************\</span>
01528 <span class="comment">* AddPathEllipse():</span>
01529 <span class="comment">*      This adds a path ellipse to the given path name.</span>
01530 <span class="comment">*      Returns TRUE if the resultant string's extent is less the the</span>
01531 <span class="comment">* cxMaxWidth. FALSE, if otherwise.</span>
01532 <span class="comment">\***************************************************************************/</span>
<a name="l01533"></a><a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a49">01533</a> <span class="keywordtype">int</span> <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a49">AddPathEllipsis</a>(
01534     HDC    hDC,
01535     LPWSTR lpszPath,
01536     <span class="keywordtype">int</span>    cchText,
01537     UINT   wFormat,
01538     <span class="keywordtype">int</span>    cxMaxWidth,
01539     <span class="keywordtype">int</span>    iOverhang, LPDRAWTEXTDATA  lpDrawInfo, <span class="keywordtype">int</span> iCharSet)
01540 {
01541   <span class="keywordtype">int</span>    iLen;
01542   <a class="code" href="../../d9/d5/ndismain_8h.html#a265">UINT</a>   dxFixed, dxEllipsis;
01543   LPWSTR lpEnd;          <span class="comment">/* end of the unfixed string */</span>
01544   LPWSTR lpFixed;        <span class="comment">/* start of text that we always display */</span>
01545   <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a11">BOOL</a>   bEllipsisIn;
01546   <span class="keywordtype">int</span>    iLenFixed;
01547   SIZE   size;
01548 
01549   lpFixed = <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a48">PathFindFileName</a>(lpszPath, cchText);
01550   <span class="keywordflow">if</span> (lpFixed != lpszPath)
01551       lpFixed--;  <span class="comment">// point at the slash</span>
01552   <span class="keywordflow">else</span>
01553       <span class="keywordflow">return</span> cchText;
01554 
01555   lpEnd = lpFixed;
01556   bEllipsisIn = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01557   iLenFixed = cchText - (<span class="keywordtype">int</span>)(lpFixed - lpszPath);
01558   dxFixed = <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a40">DT_GetExtentMinusPrefixes</a>(hDC, lpFixed, iLenFixed, wFormat, iOverhang, lpDrawInfo, iCharSet);
01559 
01560   <span class="comment">// It is assumed that the "..." string does not have any prefixes ('&amp;').</span>
01561   <a class="code" href="../../d6/d1/userrtl_8h.html#a11">UserGetTextExtentPointW</a>(hDC, <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a24">szEllipsis</a>, <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a901">CCHELLIPSIS</a>, &amp;size);
01562   dxEllipsis = size.cx - iOverhang;
01563 
01564   <span class="keywordflow">while</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
01565       iLen = dxFixed + <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a40">DT_GetExtentMinusPrefixes</a>(hDC, lpszPath, (<span class="keywordtype">int</span>)((<a class="code" href="../../d9/d7/halvprnt_8c.html#a1">PBYTE</a>)lpEnd - (<a class="code" href="../../d9/d7/halvprnt_8c.html#a1">PBYTE</a>)lpszPath)/<span class="keyword">sizeof</span>(WCHAR),
01566                                        wFormat, iOverhang, lpDrawInfo, iCharSet) - iOverhang;
01567 
01568       <span class="keywordflow">if</span> (bEllipsisIn)
01569           iLen += dxEllipsis;
01570 
01571       <span class="keywordflow">if</span> (iLen &lt;= cxMaxWidth)
01572           <span class="keywordflow">break</span>;
01573 
01574       bEllipsisIn = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01575 
01576       <span class="keywordflow">if</span> (lpEnd &lt;= lpszPath) {
01577           <span class="comment">/* Things didn't fit. */</span>
01578           lpEnd = lpszPath;
01579           <span class="keywordflow">break</span>;
01580       }
01581 
01582       <span class="comment">/* Step back a character. */</span>
01583       lpEnd--;
01584   }
01585 
01586   <span class="keywordflow">if</span> (bEllipsisIn &amp;&amp; (lpEnd + <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a901">CCHELLIPSIS</a> &lt; lpFixed)) {
01587       <span class="comment">// NOTE: the strings could over lap here. So, we use LCopyStruct.</span>
01588 
01589       RtlMoveMemory((lpEnd + <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a901">CCHELLIPSIS</a>), lpFixed, iLenFixed * <span class="keyword">sizeof</span>(WCHAR));
01590       RtlCopyMemory(lpEnd, <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a24">szEllipsis</a>, <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a901">CCHELLIPSIS</a> * <span class="keyword">sizeof</span>(WCHAR));
01591 
01592       cchText = (<span class="keywordtype">int</span>)(lpEnd - lpszPath) + <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a901">CCHELLIPSIS</a> + iLenFixed;
01593 
01594       <span class="comment">// now we can NULL terminate the string</span>
01595       *(lpszPath + cchText) = TEXT(<span class="charliteral">'\0'</span>);
01596   }
01597 
01598   <span class="keywordflow">return</span> cchText;
01599 }
01600 
01601 <span class="comment">//-----------------------------------------------------------------------</span>
01602 <span class="comment">// This function returns the number of characters actually drawn.</span>
01603 <span class="comment">//-----------------------------------------------------------------------</span>
<a name="l01604"></a><a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a50">01604</a> <span class="keywordtype">int</span> <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a50">AddEllipsisAndDrawLine</a>(
01605     HDC            hdc,
01606     <span class="keywordtype">int</span>            yLine,
01607     LPCWSTR        lpchText,
01608     <span class="keywordtype">int</span>            cchText,
01609     DWORD          dwDTformat,
01610     LPDRAWTEXTDATA lpDrawInfo,
01611     <span class="keywordtype">int</span> iCharSet)
01612 {
01613     LPWSTR pEllipsis = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01614     WCHAR  szTempBuff[<a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a21">MAXBUFFSIZE</a>];
01615     LPWSTR <a class="code" href="../../d6/d3/kcodecnv_8c.html#a4">lpDest</a>;
01616     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a11">BOOL</a>   fAlreadyCopied = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01617 
01618     <span class="comment">// Check if this is a filename with a path AND</span>
01619     <span class="comment">// Check if the width is too narrow to hold all the text.</span>
01620     <span class="keywordflow">if</span>(<a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a6">PATHELLIPSIS</a>(dwDTformat) &amp;&amp;
01621         ((<a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a40">DT_GetExtentMinusPrefixes</a>(hdc, lpchText, cchText,
01622                    dwDTformat, lpDrawInfo-&gt;cxOverhang, lpDrawInfo, iCharSet)) &gt; lpDrawInfo-&gt;cxMaxWidth)) {
01623         <span class="comment">// We need to add Path-Ellipsis. See if we can do it in-place.</span>
01624         <span class="keywordflow">if</span>(!<a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a4">MODIFYSTRING</a>(dwDTformat)) {
01625             <span class="comment">// NOTE: When you add Path-Ellipsis, the string could grow by</span>
01626             <span class="comment">// CCHELLIPSIS bytes.</span>
01627             <span class="keywordflow">if</span>((cchText + <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a901">CCHELLIPSIS</a> + 1) &lt;= <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a21">MAXBUFFSIZE</a>)
01628                 <a class="code" href="../../d6/d3/kcodecnv_8c.html#a4">lpDest</a> = szTempBuff;
01629             <span class="keywordflow">else</span> {   <span class="comment">// Alloc from local heap.</span>
01630                 <span class="comment">// Alloc the buffer from local heap.</span>
01631                 <span class="keywordflow">if</span>(!(pEllipsis = (LPWSTR)<a class="code" href="../../d6/d1/userrtl_8h.html#a31">UserRtlAllocMem</a>(
01632                         (cchText+<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a901">CCHELLIPSIS</a>+1)*<span class="keyword">sizeof</span>(WCHAR))))
01633                     <span class="keywordflow">return</span> 0;
01634                 <a class="code" href="../../d6/d3/kcodecnv_8c.html#a4">lpDest</a> = (LPWSTR)pEllipsis;
01635             }
01636             <span class="comment">// Source String may not be NULL terminated. So, copy just</span>
01637             <span class="comment">// the given number of characters.</span>
01638             RtlCopyMemory(<a class="code" href="../../d6/d3/kcodecnv_8c.html#a4">lpDest</a>, lpchText, cchText*<span class="keyword">sizeof</span>(WCHAR));
01639             lpchText = <a class="code" href="../../d6/d3/kcodecnv_8c.html#a4">lpDest</a>;        <span class="comment">// lpchText points to the copied buff.</span>
01640             fAlreadyCopied = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;    <span class="comment">// Local copy has been made.</span>
01641         }
01642         <span class="comment">// Add the path ellipsis now!</span>
01643         cchText = <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a49">AddPathEllipsis</a>(hdc, (LPWSTR)lpchText, cchText, dwDTformat,
01644             lpDrawInfo-&gt;cxMaxWidth, lpDrawInfo-&gt;cxOverhang, lpDrawInfo, iCharSet);
01645     }
01646 
01647     <span class="comment">// Check if end-ellipsis are to be added.</span>
01648     <span class="keywordflow">if</span>((<a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a12">ENDELLIPSIS</a>(dwDTformat) || <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a10">WORDELLIPSIS</a>(dwDTformat)) &amp;&amp;
01649         <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a47">NeedsEndEllipsis</a>(hdc, lpchText, &amp;cchText, lpDrawInfo, dwDTformat, lpDrawInfo, iCharSet)) {
01650         <span class="comment">// We need to add end-ellipsis; See if we can do it in-place.</span>
01651         <span class="keywordflow">if</span>(!<a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a4">MODIFYSTRING</a>(dwDTformat) &amp;&amp; !fAlreadyCopied) {
01652             <span class="comment">// See if the string is small enough for the buff on stack.</span>
01653             <span class="keywordflow">if</span>((cchText+<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a901">CCHELLIPSIS</a>+1) &lt;= <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a21">MAXBUFFSIZE</a>)
01654                 <a class="code" href="../../d6/d3/kcodecnv_8c.html#a4">lpDest</a> = szTempBuff;  <span class="comment">// If so, use it.</span>
01655             <span class="keywordflow">else</span> {
01656                 <span class="comment">// Alloc the buffer from local heap.</span>
01657                 <span class="keywordflow">if</span>(!(pEllipsis = (LPWSTR)<a class="code" href="../../d6/d1/userrtl_8h.html#a31">UserRtlAllocMem</a>(
01658                         (cchText+<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a901">CCHELLIPSIS</a>+1)*<span class="keyword">sizeof</span>(WCHAR))))
01659                     <span class="keywordflow">return</span> 0;
01660                 <a class="code" href="../../d6/d3/kcodecnv_8c.html#a4">lpDest</a> = pEllipsis;
01661             }
01662             <span class="comment">// Make a copy of the string in the local buff.</span>
01663             RtlCopyMemory(<a class="code" href="../../d6/d3/kcodecnv_8c.html#a4">lpDest</a>, lpchText, cchText*<span class="keyword">sizeof</span>(WCHAR));
01664             lpchText = <a class="code" href="../../d6/d3/kcodecnv_8c.html#a4">lpDest</a>;
01665         }
01666         <span class="comment">// Add an end-ellipsis at the proper place.</span>
01667         RtlCopyMemory((LPWSTR)(lpchText+cchText), <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a24">szEllipsis</a>, (<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a901">CCHELLIPSIS</a>+1)*<span class="keyword">sizeof</span>(WCHAR));
01668         cchText += <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a901">CCHELLIPSIS</a>;
01669     }
01670 
01671     <span class="comment">// Draw the line that we just formed.</span>
01672     <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a42">DT_DrawJustifiedLine</a>(hdc, yLine, lpchText, cchText, dwDTformat, lpDrawInfo, iCharSet);
01673 
01674     <span class="comment">// Free the block allocated for End-Ellipsis.</span>
01675     <span class="keywordflow">if</span>(pEllipsis)
01676         <a class="code" href="../../d6/d1/userrtl_8h.html#a32">UserRtlFreeMem</a>(pEllipsis);
01677 
01678     <span class="keywordflow">return</span> cchText;
01679 }
01680 
01681 
01682 <span class="comment">/***************************************************************************\</span>
01683 <span class="comment">* IDrawTextEx</span>
01684 <span class="comment">*      This is the new DrawText API</span>
01685 <span class="comment">\***************************************************************************/</span>
01686 
01687 <span class="comment">/***************************************************************************\</span>
01688 <span class="comment">* IDrawTextEx</span>
01689 <span class="comment">*      This is the new DrawText API</span>
01690 <span class="comment">\***************************************************************************/</span>
01691 
<a name="l01692"></a><a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a51">01692</a> <span class="keywordtype">int</span>  <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a51">DrawTextExW</a>(
01693    HDC               hdc,
01694    LPWSTR            lpchText,
01695    <span class="keywordtype">int</span>               cchText,
01696    LPRECT            lprc,
01697    UINT              dwDTformat,
01698    LPDRAWTEXTPARAMS  lpDTparams)
01699 {
01700    <span class="comment">/*</span>
01701 <span class="comment">    * The LPK requires a charset.  The Unicode entry point always passes a -1,</span>
01702 <span class="comment">    * but the ANSI entry point passes a more interesting value.  Both the</span>
01703 <span class="comment">    * 'W' version and 'A' version of DrawTextEx call this common worker routine.</span>
01704 <span class="comment">    */</span>
01705    <span class="keywordflow">return</span> <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a52">DrawTextExWorker</a>(hdc, lpchText, cchText, lprc, dwDTformat, lpDTparams, -1);
01706 }
01707 
<a name="l01708"></a><a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a52">01708</a> <span class="keywordtype">int</span>  <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a52">DrawTextExWorker</a>(
01709    HDC               hdc,
01710    LPWSTR            lpchText,
01711    <span class="keywordtype">int</span>               cchText,
01712    LPRECT            lprc,
01713    UINT              dwDTformat,
01714    LPDRAWTEXTPARAMS  lpDTparams,
01715    <span class="keywordtype">int</span>               iCharset)
01716 {
01717     <a class="code" href="../../d2/d8/structDRAWTEXTDATA.html">DRAWTEXTDATA</a> DrawInfo;
01718     WORD         wFormat = LOWORD(dwDTformat);
01719     LPWSTR       lpchTextBegin;
01720     LPWSTR       lpchEnd;
01721     LPWSTR       lpchNextLineSt;
01722     <span class="keywordtype">int</span>          iLineLength;
01723     <span class="keywordtype">int</span>          iySign;
01724     <span class="keywordtype">int</span>          yLine;
01725     <span class="keywordtype">int</span>          yLastLineHeight;
01726     HRGN         hrgnClip;
01727     <span class="keywordtype">int</span>          iLineCount;
01728     RECT         rc;
01729     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a11">BOOL</a>         fLastLine;
01730     WCHAR        ch;
01731     <a class="code" href="../../d9/d5/ndismain_8h.html#a265">UINT</a>         oldAlign;
01732 
01733 <span class="preprocessor">#if DBG</span>
01734 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (dwDTformat &amp; ~DT_VALID)
01735         RIPMSG0 (RIP_WARNING, <span class="stringliteral">"DrawTextExW: Invalid dwDTformat flags"</span>);
01736 <span class="preprocessor">#endif</span>
01737 <span class="preprocessor"></span>
01738     <span class="keywordflow">if</span> (lpchText == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01739         <span class="keywordflow">return</span> 1;
01740     }
01741 
01742     <span class="keywordflow">if</span> (cchText == 0 &amp;&amp; *lpchText) {
01743         <span class="comment">/*</span>
01744 <span class="comment">         * infoview.exe passes lpchText that points to '\0'</span>
01745 <span class="comment">         *</span>
01746 <span class="comment">         * "Microsoft Expedia Streets and Trips 2000" and "MS MapPoint 2000"</span>
01747 <span class="comment">         * tries cchText == 0 to detect if DrawTextW is supported.</span>
01748 <span class="comment">         */</span>
01749 
01750         <span class="comment">/* Added by Chicago:</span>
01751 <span class="comment">         * Lotus Notes doesn't like getting a zero return here</span>
01752 <span class="comment">         */</span>
01753         <span class="keywordflow">return</span> 1;
01754     }
01755 
01756     <span class="keywordflow">if</span> (cchText == -1)
01757         cchText = wcslen(lpchText);
01758 
01759 
01760 
01761     <span class="keywordflow">if</span> ((lpDTparams) &amp;&amp; (lpDTparams-&gt;cbSize != <span class="keyword">sizeof</span>(DRAWTEXTPARAMS))) {
01762         RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, <span class="stringliteral">"DrawTextEx: cbSize %ld is invalid"</span>,
01763                 lpDTparams-&gt;cbSize);
01764         <span class="keywordflow">return</span> 0;
01765     }
01766 
01767 
01768 <span class="preprocessor">#ifdef LATER</span>
01769 <span class="preprocessor"></span>    <span class="comment">/*</span>
01770 <span class="comment">     * If DT_MODIFYSTRING is specified, then check for read-write pointer.</span>
01771 <span class="comment">     */</span>
01772     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a4">MODIFYSTRING</a>(dwDTformat) &amp;&amp;
01773             (<a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a12">ENDELLIPSIS</a>(dwDTformat) || <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a6">PATHELLIPSIS</a>(dwDTformat))) {
01774         <span class="keywordflow">if</span>(IsBadWritePtr(lpchText, cchText)) {
01775             RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, <span class="stringliteral">"DrawTextEx: For DT_MODIFYSTRING, lpchText must be read-write"</span>);
01776             <span class="keywordflow">return</span>(0);
01777         }
01778     }
01779 <span class="preprocessor">#endif</span>
01780 <span class="preprocessor"></span>
01781     <span class="comment">/*</span>
01782 <span class="comment">     * Initialize the DrawInfo structure.</span>
01783 <span class="comment">     */</span>
01784     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a43">DT_InitDrawTextInfo</a>(hdc, lprc, dwDTformat, (<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a1109">LPDRAWTEXTDATA</a>)&amp;DrawInfo, lpDTparams))
01785         <span class="keywordflow">return</span> 0;
01786 
01787     DrawInfo.iCharset = iCharset;
01788     <span class="comment">/*</span>
01789 <span class="comment">     * If the rect is too narrow or the margins are too wide.....Just forget it!</span>
01790 <span class="comment">     *</span>
01791 <span class="comment">     * If wordbreak is specified, the MaxWidth must be a reasonable value.</span>
01792 <span class="comment">     * This check is sufficient because this will allow CALCRECT and NOCLIP</span>
01793 <span class="comment">     * cases.  --SANKAR.</span>
01794 <span class="comment">     *</span>
01795 <span class="comment">     * This also fixed all of our known problems with AppStudio.</span>
01796 <span class="comment">     */</span>
01797     <span class="keywordflow">if</span> (DrawInfo.cxMaxWidth &lt;= 0) {
01798 
01799         <span class="comment">/*</span>
01800 <span class="comment">         * We used to return a non-zero value in win31.</span>
01801 <span class="comment">         * If the kernel calls this we are always Ver 4.0 or above</span>
01802 <span class="comment">         */</span>
01803 <span class="preprocessor">#ifdef _USERK_</span>
01804 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (0) {
01805 <span class="preprocessor">#else</span>
01806 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (<a class="code" href="../../d6/d0/usercli_8h.html#a150">GETAPPVER</a>() &lt; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a101">VER40</a>) {
01807 <span class="preprocessor">#endif</span>
01808 <span class="preprocessor"></span>            <span class="keywordflow">if</span>((DrawInfo.cxMaxWidth == 0) &amp;&amp; !<a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a0">CALCRECT</a>(wFormat)) {
01809                 <span class="keywordflow">return</span>(1);
01810             }
01811         } <span class="keywordflow">else</span> {
01812             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a9">WORDBREAK</a>(wFormat)) {
01813                 RIPMSG0 (RIP_WARNING, <span class="stringliteral">"DrawTextExW: FAILURE DrawInfo.cxMaxWidth &lt;=0"</span>);
01814                 <span class="keywordflow">return</span> (1);
01815             }
01816         }
01817     }
01818 
01819     <span class="comment">/*</span>
01820 <span class="comment">     * if we're not doing the drawing, initialise the lpk-dll</span>
01821 <span class="comment">     */</span>
01822     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a14">RTLREADING</a>(dwDTformat)) {
01823         oldAlign = <a class="code" href="../../d6/d1/userrtl_8h.html#a26">UserSetTextAlign</a>(hdc, TA_RTLREADING | <a class="code" href="../../d6/d1/userrtl_8h.html#a25">UserGetTextAlign</a>(hdc));
01824     }
01825 
01826     <span class="keywordflow">if</span> (DrawInfo.bCharsetDll) {
01827 <span class="preprocessor">#ifdef _USERK_</span>
01828 <span class="preprocessor"></span>        <a class="code" href="../../d2/d8/structtagTHREADINFO.html">PTHREADINFO</a> ptiCurrent = <a class="code" href="../../d4/d1/userk_8h.html#a10">PtiCurrentShared</a>();
01829 
01830         <span class="keywordflow">if</span>(<a class="code" href="../../d4/d1/userk_8h.html#a393">CALL_LPK</a>(ptiCurrent))
01831 <span class="preprocessor">#endif // _USERK_</span>
01832 <span class="preprocessor"></span>            (*UserLpkDrawTextEx)(hdc, 0, 0, lpchText, cchText, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, dwDTformat,
01833                                  (<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a1109">LPDRAWTEXTDATA</a>)&amp;DrawInfo, <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a898">DT_CHARSETINIT</a>, iCharset);
01834     }
01835 
01836     <span class="comment">/*</span>
01837 <span class="comment">     * If we need to clip, let us do that.</span>
01838 <span class="comment">     */</span>
01839     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a13">NOCLIP</a>(wFormat)) {
01840         <span class="comment">//</span>
01841         <span class="comment">// Save clipping region so we can restore it later.</span>
01842         <span class="comment">//</span>
01843         <span class="comment">// hrgnSave = SaveClipRgn(hdc);</span>
01844         <span class="comment">// IntersectClipRect(hdc, lprc-&gt;left, lprc-&gt;top, lprc-&gt;right, lprc-&gt;bottom);</span>
01845 
01846         hrgnClip = <a class="code" href="../../d6/d1/userrtl_8h.html#a2">UserCreateRectRgn</a>(0,0,0,0);
01847         <span class="keywordflow">if</span> (hrgnClip != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01848             <span class="keywordflow">if</span> (<a class="code" href="../../d6/d1/userrtl_8h.html#a7">UserGetClipRgn</a>(hdc, hrgnClip) != 1) {
01849                 <a class="code" href="../../d6/d1/userrtl_8h.html#a3">UserDeleteObject</a>(hrgnClip);
01850                 hrgnClip = (HRGN)-1;
01851             }
01852             rc = *lprc;
01853             <a class="code" href="../../d6/d1/userrtl_8h.html#a15">UserIntersectClipRect</a>(hdc, rc.left, rc.top, rc.right, rc.bottom);
01854         }
01855     } <span class="keywordflow">else</span> {
01856         hrgnClip = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01857     }
01858 
01859     lpchTextBegin = lpchText;
01860     lpchEnd = lpchText + cchText;
01861 
01862 ProcessDrawText:
01863 
01864     iLineCount = 0;  <span class="comment">// Reset number of lines to 1.</span>
01865     yLine = lprc-&gt;top;
01866 
01867     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a7">SINGLELINE</a>(wFormat)) {
01868         iLineCount = 1;  <span class="comment">// It is a single line.</span>
01869 
01870 
01871         <span class="comment">/*</span>
01872 <span class="comment">         * Process single line DrawText.</span>
01873 <span class="comment">         */</span>
01874         <span class="keywordflow">switch</span> (wFormat &amp; <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a19">DT_VFMTMASK</a>) {
01875             <span class="keywordflow">case</span> DT_BOTTOM:
01876                 yLine = lprc-&gt;bottom - DrawInfo.cyLineHeight;
01877                 <span class="keywordflow">break</span>;
01878 
01879             <span class="keywordflow">case</span> DT_VCENTER:
01880                 yLine = lprc-&gt;top + ((lprc-&gt;bottom - lprc-&gt;top - DrawInfo.cyLineHeight) / 2);
01881                 <span class="keywordflow">break</span>;
01882         }
01883 
01884         cchText = <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a50">AddEllipsisAndDrawLine</a>(hdc, yLine, lpchText, cchText, dwDTformat, &amp;DrawInfo, iCharset);
01885         yLine += DrawInfo.cyLineHeight;
01886         lpchText += cchText;
01887     } <span class="keywordflow">else</span>  {
01888 
01889         <span class="comment">/*</span>
01890 <span class="comment">         * Multiline</span>
01891 <span class="comment">         * If the height of the rectangle is not an integral multiple of the</span>
01892 <span class="comment">         * average char height, then it is possible that the last line drawn</span>
01893 <span class="comment">         * is only partially visible. However, if DT_EDITCONTROL style is</span>
01894 <span class="comment">         * specified, then we must make sure that the last line is not drawn if</span>
01895 <span class="comment">         * it is going to be partially visible. This will help imitate the</span>
01896 <span class="comment">         * appearance of an edit control.</span>
01897 <span class="comment">         */</span>
01898         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a1">EDITCONTROL</a>(wFormat))
01899             yLastLineHeight = DrawInfo.cyLineHeight;
01900         <span class="keywordflow">else</span>
01901             yLastLineHeight = 0;
01902 
01903         iySign = DrawInfo.iYSign;
01904         fLastLine = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01905         <span class="comment">// Process multiline DrawText.</span>
01906         <span class="keywordflow">while</span> ((lpchText &lt; lpchEnd) &amp;&amp; (!fLastLine)) {
01907           <span class="comment">// Check if the line we are about to draw is the last line that needs</span>
01908           <span class="comment">// to be drawn.</span>
01909           <span class="comment">// Let us check if the display goes out of the clip rect and if so</span>
01910           <span class="comment">// let us stop here, as an optimisation;</span>
01911           <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a0">CALCRECT</a>(wFormat) &amp;&amp;         <span class="comment">// We don't need to calc rect?</span>
01912                   (!<a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a13">NOCLIP</a>(wFormat)) &amp;&amp;     <span class="comment">// Must we clip the display ?</span>
01913                                             <span class="comment">// Are we outside the rect?</span>
01914                   ((yLine + DrawInfo.cyLineHeight + yLastLineHeight)*iySign &gt; (lprc-&gt;bottom*iySign))) {
01915               fLastLine = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;    <span class="comment">// Let us quit this loop</span>
01916           }
01917 
01918 
01919           <span class="comment">/*</span>
01920 <span class="comment">           * We do the Ellipsis processing only for the last line.</span>
01921 <span class="comment">           */</span>
01922           <span class="keywordflow">if</span> (fLastLine &amp;&amp; (<a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a12">ENDELLIPSIS</a>(dwDTformat) || <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a6">PATHELLIPSIS</a>(dwDTformat))) {
01923               lpchText += <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a50">AddEllipsisAndDrawLine</a>(hdc, yLine, lpchText, cchText, dwDTformat, &amp;DrawInfo, iCharset);
01924           } <span class="keywordflow">else</span> {
01925               lpchNextLineSt = (LPWSTR)<a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a46">DT_GetLineBreak</a>(hdc, lpchText, cchText, dwDTformat, &amp;iLineLength, &amp;DrawInfo, iCharset);
01926 
01927               <span class="comment">/*</span>
01928 <span class="comment">               * Check if we need to put ellipsis at the end of this line.</span>
01929 <span class="comment">               * Also check if this is the last line.</span>
01930 <span class="comment">               */</span>
01931               <span class="keywordflow">if</span> (<a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a10">WORDELLIPSIS</a>(dwDTformat) ||
01932                        ((lpchNextLineSt &gt;= lpchEnd) &amp;&amp; (<a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a12">ENDELLIPSIS</a>(dwDTformat) || <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a6">PATHELLIPSIS</a>(dwDTformat))))
01933                   <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a50">AddEllipsisAndDrawLine</a>(hdc, yLine, lpchText, iLineLength, dwDTformat, &amp;DrawInfo, iCharset);
01934               <span class="keywordflow">else</span>
01935                   <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a42">DT_DrawJustifiedLine</a>(hdc, yLine, lpchText, iLineLength, dwDTformat, &amp;DrawInfo, iCharset);
01936               cchText -= (<span class="keywordtype">int</span>)((<a class="code" href="../../d9/d7/halvprnt_8c.html#a1">PBYTE</a>)lpchNextLineSt - (<a class="code" href="../../d9/d7/halvprnt_8c.html#a1">PBYTE</a>)lpchText) / <span class="keyword">sizeof</span>(WCHAR);
01937               lpchText = lpchNextLineSt;
01938           }
01939             iLineCount++; <span class="comment">// We draw one more line.</span>
01940             yLine += DrawInfo.cyLineHeight;
01941         }
01942 
01943 
01944         <span class="comment">/*</span>
01945 <span class="comment">         * For Win3.1 and NT compatibility, if the last char is a CR or a LF</span>
01946 <span class="comment">         * then the height returned includes one more line.</span>
01947 <span class="comment">         */</span>
01948         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a1">EDITCONTROL</a>(dwDTformat) &amp;&amp;
01949                 (lpchEnd &gt; lpchTextBegin)    &amp;&amp;   <span class="comment">// If zero length it will fault.</span>
01950                 (((ch = (*(lpchEnd-1))) == <a class="code" href="../../d3/d2/client_2drawtext_8c.html#a0">CR</a>) || (ch == <a class="code" href="../../d3/d2/client_2drawtext_8c.html#a1">LF</a>)))
01951             yLine += DrawInfo.cyLineHeight;
01952     }
01953 
01954 
01955     <span class="comment">/*</span>
01956 <span class="comment">     * If DT_CALCRECT, modify width and height of rectangle to include</span>
01957 <span class="comment">     * all of the text drawn.</span>
01958 <span class="comment">     */</span>
01959     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a0">CALCRECT</a>(wFormat)) {
01960         DrawInfo.rcFormat.right = DrawInfo.rcFormat.left + DrawInfo.cxMaxExtent * DrawInfo.iXSign;
01961         lprc-&gt;right = DrawInfo.rcFormat.right + DrawInfo.cxRightMargin;
01962 
01963         <span class="comment">// If the Width is more than what was provided, we have to redo all</span>
01964         <span class="comment">// the calculations, because, the number of lines can be less now.</span>
01965         <span class="comment">// (We need to do this only if we have more than one line).</span>
01966         <span class="keywordflow">if</span>((iLineCount &gt; 1) &amp;&amp; (DrawInfo.cxMaxExtent &gt; DrawInfo.cxMaxWidth)) {
01967             DrawInfo.cxMaxWidth = DrawInfo.cxMaxExtent;
01968             lpchText = lpchTextBegin;
01969             cchText = (<span class="keywordtype">int</span>)((<a class="code" href="../../d9/d7/halvprnt_8c.html#a1">PBYTE</a>)lpchEnd - (<a class="code" href="../../d9/d7/halvprnt_8c.html#a1">PBYTE</a>)lpchTextBegin)/<span class="keyword">sizeof</span>(WCHAR);
01970             <span class="keywordflow">goto</span>  ProcessDrawText;  <span class="comment">// Start all over again!</span>
01971         }
01972         lprc-&gt;bottom = yLine;
01973     }
01974 
01975 <span class="comment">// if (!NOCLIP(wFormat))</span>
01976 <span class="comment">// {</span>
01977 <span class="comment">//     RestoreClipRgn(hdc, hrgnClip);</span>
01978 <span class="comment">// }</span>
01979 
01980     <span class="keywordflow">if</span> (hrgnClip != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01981         <span class="keywordflow">if</span> (hrgnClip == (HRGN)-1) {
01982             <a class="code" href="../../d6/d1/userrtl_8h.html#a4">UserExtSelectClipRgn</a>(hdc, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, RGN_COPY);
01983         } <span class="keywordflow">else</span> {
01984             <a class="code" href="../../d6/d1/userrtl_8h.html#a4">UserExtSelectClipRgn</a>(hdc, hrgnClip, RGN_COPY);
01985             <a class="code" href="../../d6/d1/userrtl_8h.html#a3">UserDeleteObject</a>(hrgnClip);
01986         }
01987     }
01988 
01989     <span class="keywordflow">if</span>(DrawInfo.bCharsetDll) {
01990 <span class="preprocessor">#ifdef _USERK_</span>
01991 <span class="preprocessor"></span>        <a class="code" href="../../d2/d8/structtagTHREADINFO.html">PTHREADINFO</a> ptiCurrent = <a class="code" href="../../d4/d1/userk_8h.html#a10">PtiCurrentShared</a>();
01992 
01993         <span class="keywordflow">if</span>(<a class="code" href="../../d4/d1/userk_8h.html#a393">CALL_LPK</a>(ptiCurrent))
01994 <span class="preprocessor">#endif // _USERK_</span>
01995 <span class="preprocessor"></span>            (*UserLpkDrawTextEx)(hdc, 0, 0, lpchText, cchText, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, dwDTformat,
01996                                  (<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a1109">LPDRAWTEXTDATA</a>)&amp;DrawInfo, <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a899">DT_CHARSETDONE</a>, iCharset);
01997     }
01998 
01999     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a14">RTLREADING</a>(dwDTformat))
02000         <a class="code" href="../../d6/d1/userrtl_8h.html#a26">UserSetTextAlign</a>(hdc, oldAlign);
02001 
02002     <span class="comment">/*</span>
02003 <span class="comment">     * Copy the number of characters actually drawn</span>
02004 <span class="comment">     */</span>
02005     <span class="keywordflow">if</span>(lpDTparams != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)
02006         lpDTparams-&gt;uiLengthDrawn = (<a class="code" href="../../d9/d5/ndismain_8h.html#a265">UINT</a>)((<a class="code" href="../../d9/d7/halvprnt_8c.html#a1">PBYTE</a>)lpchText - (<a class="code" href="../../d9/d7/halvprnt_8c.html#a1">PBYTE</a>)lpchTextBegin)/<span class="keyword">sizeof</span>(WCHAR);
02007 
02008     <span class="keywordflow">if</span> (yLine == lprc-&gt;top)
02009         <span class="keywordflow">return</span> 1;
02010 
02011     <span class="keywordflow">return</span> (yLine - lprc-&gt;top);
02012 }
02013 
02014 <span class="comment">/***************************************************************************\</span>
02015 <span class="comment">*</span>
02016 <span class="comment">* IsSysFontAndDefaultMode()</span>
02017 <span class="comment">*</span>
02018 <span class="comment">* Returns TRUE if font selected into DC is the system font AND the current</span>
02019 <span class="comment">* mapping mode of the DC is MM_TEXT (Default mode); else returns FALSE. This</span>
02020 <span class="comment">* is called by interrupt time code so it needs to be in the fixed code</span>
02021 <span class="comment">* segment.</span>
02022 <span class="comment">*</span>
02023 <span class="comment">* History:</span>
02024 <span class="comment">* 07-Jul-95 BradG   Ported from Win95</span>
02025 <span class="comment">\***************************************************************************/</span>
02026 
<a name="l02027"></a><a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a53">02027</a> <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a11">BOOL</a> <a class="code" href="../../d5/d2/rtl_2drawtext_8c.html#a53">IsSysFontAndDefaultMode</a>(HDC hdc)
02028 {
02029     <span class="keywordflow">return</span>((<a class="code" href="../../d6/d1/userrtl_8h.html#a8">UserGetHFONT</a>(hdc) == <a class="code" href="../../d1/d8/clglobal_8c.html#a28">ghFontSys</a>) &amp;&amp; (<a class="code" href="../../d6/d1/userrtl_8h.html#a9">UserGetMapMode</a>(hdc) == MM_TEXT));
02030 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:39:46 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
