<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: namesup.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>namesup.c</h1><a href="../../d5/d5/namesup_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1991  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    NameSup.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module implements the Udfs Name support routines</span>
00012 <span class="comment"></span>
00013 <span class="comment">Author:</span>
00014 <span class="comment"></span>
00015 <span class="comment">    Dan Lovinger    [DanLo]     9-October-1996</span>
00016 <span class="comment"></span>
00017 <span class="comment">Revision History:</span>
00018 <span class="comment"></span>
00019 <span class="comment">--*/</span>
00020 
00021 <span class="preprocessor">#include "UdfProcs.h"</span>
00022 
00023 <span class="comment">//</span>
00024 <span class="comment">//  The Bug check file id for this module</span>
00025 <span class="comment">//</span>
00026 
<a name="l00027"></a><a class="code" href="../../d5/d5/namesup_8c.html#a0">00027</a> <span class="preprocessor">#define BugCheckFileId                   (UDFS_BUG_CHECK_NAMESUP)</span>
00028 <span class="preprocessor"></span>
00029 <span class="comment">//</span>
00030 <span class="comment">//  The local debug trace level</span>
00031 <span class="comment">//</span>
00032 
<a name="l00033"></a><a class="code" href="../../d5/d5/namesup_8c.html#a1">00033</a> <span class="preprocessor">#define Dbg                              (UDFS_DEBUG_LEVEL_NAMESUP)</span>
00034 <span class="preprocessor"></span>
00035 <span class="comment">//</span>
00036 <span class="comment">//  Local constants</span>
00037 <span class="comment">//</span>
00038 
<a name="l00039"></a><a class="code" href="../../d5/d5/namesup_8c.html#a2">00039</a> <span class="keyword">static</span> CONST <a class="code" href="../../d1/d1/bench_8c.html#a16">CHAR</a> <a class="code" href="../../d5/d5/namesup_8c.html#a2">UdfCrcChar</a>[] = <span class="stringliteral">"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ#_~-@"</span>;
00040 
00041 <span class="preprocessor">#ifdef ALLOC_PRAGMA</span>
00042 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfCandidateShortName)</span>
00043 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfCheckLegalCS0Dstring)</span>
00044 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfConvertCS0DstringToUnicode)</span>
00045 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfDissectName)</span>
00046 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfFullCompareNames)</span>
00047 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfGenerate8dot3Name)</span>
00048 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfIs8dot3Name)</span>
00049 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfIsNameInExpression)</span>
00050 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfRenderNameToLegalUnicode)</span>
00051 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00052 <span class="preprocessor"></span>
00053 
00054 <a class="code" href="../../d5/d3/filelock_8c.html#a1">INLINE</a>
00055 ULONG
<a name="l00056"></a><a class="code" href="../../d5/d5/namesup_8c.html#a3">00056</a> <a class="code" href="../../d5/d5/namesup_8c.html#a3">NativeDosCharLength</a> (
00057     IN WCHAR Wchar
00058     )
00059 
00060 <span class="comment">/*++</span>
00061 <span class="comment"></span>
00062 <span class="comment">Routine Description:</span>
00063 <span class="comment"></span>
00064 <span class="comment">    This routine is a translation layer for asking how big a given UNICODE</span>
00065 <span class="comment">    character will be when converted to OEM.  Aside from adding more material</span>
00066 <span class="comment">    to the kernel export table, this is how ya do it.</span>
00067 <span class="comment"></span>
00068 <span class="comment">Arguments:</span>
00069 <span class="comment"></span>
00070 <span class="comment">    Wchar - pointer to the character</span>
00071 <span class="comment"></span>
00072 <span class="comment">Return Value:</span>
00073 <span class="comment"></span>
00074 <span class="comment">    Size in bytes.</span>
00075 <span class="comment"></span>
00076 <span class="comment">--*/</span>
00077 
00078 {
00079     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00080     <a class="code" href="../../d1/d1/bench_8c.html#a16">CHAR</a> OemBuf[2];
00081     ULONG Length;
00082 
00083     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d6/nlsxlat_8c.html#a40">RtlUpcaseUnicodeToOemN</a>( OemBuf,
00084                                      <span class="keyword">sizeof</span>(OemBuf),
00085                                      &amp;Length,
00086                                      &amp;Wchar,
00087                                      <span class="keyword">sizeof</span>(WCHAR));
00088     
00089     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> ));
00090 
00091     <span class="keywordflow">return</span> Length;
00092 }
00093 
00094 
00095 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00096"></a><a class="code" href="../../d3/d8/udfprocs_8h.html#a177">00096</a> <a class="code" href="../../d3/d8/udfprocs_8h.html#a177">UdfDissectName</a> (
00097     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00098     IN OUT PUNICODE_STRING RemainingName,
00099     OUT PUNICODE_STRING FinalName
00100     )
00101 
00102 <span class="comment">/*++</span>
00103 <span class="comment"></span>
00104 <span class="comment">Routine Description:</span>
00105 <span class="comment"></span>
00106 <span class="comment">    This routine is called to strip off leading components of the name strings.  We search</span>
00107 <span class="comment">    for either the end of the string or separating characters.  The input remaining</span>
00108 <span class="comment">    name strings should have neither a trailing or leading backslash.</span>
00109 <span class="comment"></span>
00110 <span class="comment">Arguments:</span>
00111 <span class="comment"></span>
00112 <span class="comment">    RemainingName - Remaining name.</span>
00113 <span class="comment"></span>
00114 <span class="comment">    FinalName - Location to store next component of name.</span>
00115 <span class="comment"></span>
00116 <span class="comment">Return Value:</span>
00117 <span class="comment"></span>
00118 <span class="comment">    None.</span>
00119 <span class="comment"></span>
00120 <span class="comment">--*/</span>
00121 
00122 {
00123     ULONG NameLength;
00124     PWCHAR NextWchar;
00125 
00126     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00127 
00128     <span class="comment">//</span>
00129     <span class="comment">//  Check inputs.</span>
00130     <span class="comment">//</span>
00131 
00132     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
00133 
00134     <span class="comment">//</span>
00135     <span class="comment">//  Find the offset of the next component separators.</span>
00136     <span class="comment">//</span>
00137 
00138     <span class="keywordflow">for</span> (NameLength = 0, NextWchar = RemainingName-&gt;Buffer;
00139          (NameLength &lt; RemainingName-&gt;Length) &amp;&amp; (*NextWchar != <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span>);
00140          NameLength += <span class="keyword">sizeof</span>( WCHAR) , NextWchar += 1);
00141 
00142     <span class="comment">//</span>
00143     <span class="comment">//  Adjust all the strings by this amount.</span>
00144     <span class="comment">//</span>
00145 
00146     FinalName-&gt;Buffer = RemainingName-&gt;Buffer;
00147 
00148     FinalName-&gt;MaximumLength = FinalName-&gt;Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>) NameLength;
00149 
00150     <span class="comment">//</span>
00151     <span class="comment">//  If this is the last component then set the RemainingName lengths to zero.</span>
00152     <span class="comment">//</span>
00153 
00154     <span class="keywordflow">if</span> (NameLength == RemainingName-&gt;Length) {
00155 
00156         RemainingName-&gt;Length = 0;
00157 
00158     <span class="comment">//</span>
00159     <span class="comment">//  Otherwise we adjust the string by this amount plus the separating character.</span>
00160     <span class="comment">//</span>
00161 
00162     } <span class="keywordflow">else</span> {
00163 
00164         RemainingName-&gt;MaximumLength -= (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>) (NameLength + <span class="keyword">sizeof</span>( WCHAR ));
00165         RemainingName-&gt;Length -= (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>) (NameLength + <span class="keyword">sizeof</span>( WCHAR ));
00166         RemainingName-&gt;Buffer = <a class="code" href="../../d2/d7/notify_8c.html#a7">Add2Ptr</a>( RemainingName-&gt;Buffer,
00167                                          NameLength + <span class="keyword">sizeof</span>( WCHAR ),
00168                                          PWCHAR );
00169     }
00170 
00171     <span class="keywordflow">return</span>;
00172 }
00173 
00174 
00175 BOOLEAN
<a name="l00176"></a><a class="code" href="../../d3/d8/udfprocs_8h.html#a178">00176</a> <a class="code" href="../../d3/d8/udfprocs_8h.html#a178">UdfIs8dot3Name</a> (
00177     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00178     IN UNICODE_STRING FileName
00179     )
00180 
00181 <span class="comment">/*++</span>
00182 <span class="comment"></span>
00183 <span class="comment">Routine Description:</span>
00184 <span class="comment"></span>
00185 <span class="comment">    This routine checks if the name follows the 8.3 name conventions.  We check for</span>
00186 <span class="comment">    the name length and whether the characters are valid.</span>
00187 <span class="comment"></span>
00188 <span class="comment">Arguments:</span>
00189 <span class="comment"></span>
00190 <span class="comment">    FileName - String of bytes containing the name.</span>
00191 <span class="comment"></span>
00192 <span class="comment">Return Value:</span>
00193 <span class="comment"></span>
00194 <span class="comment">    BOOLEAN - TRUE if this name is a legal 8.3 name, FALSE otherwise.</span>
00195 <span class="comment"></span>
00196 <span class="comment">--*/</span>
00197 
00198 {
00199     <a class="code" href="../../d1/d1/bench_8c.html#a16">CHAR</a> DbcsNameBuffer[ <a class="code" href="../../d9/d7/udf_8h.html#a11">BYTE_COUNT_8_DOT_3</a> ];
00200     STRING DbcsName;
00201 
00202     PWCHAR NextWchar;
00203     ULONG <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a>;
00204 
00205     ULONG DotCount = 0;
00206     BOOLEAN LastCharDot = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00207 
00208     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00209 
00210     <span class="comment">//</span>
00211     <span class="comment">//  Check inputs.</span>
00212     <span class="comment">//</span>
00213 
00214     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
00215 
00216     <span class="comment">//</span>
00217     <span class="comment">//  The length must be less than 24 bytes.</span>
00218     <span class="comment">//</span>
00219 
00220     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d2/d2/rtload_8c.html#a3">FileName</a>.Length != 0 );
00221     <span class="keywordflow">if</span> (<a class="code" href="../../d2/d2/rtload_8c.html#a3">FileName</a>.Length &gt; <a class="code" href="../../d9/d7/udf_8h.html#a11">BYTE_COUNT_8_DOT_3</a>) {
00222 
00223         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00224     }
00225 
00226     <span class="comment">//</span>
00227     <span class="comment">//  Walk though and check for a space character.</span>
00228     <span class="comment">//</span>
00229 
00230     NextWchar = <a class="code" href="../../d2/d2/rtload_8c.html#a3">FileName</a>.Buffer;
00231     <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> = 0;
00232 
00233     <span class="keywordflow">do</span> {
00234 
00235         <span class="comment">//</span>
00236         <span class="comment">//  No spaces allowed.</span>
00237         <span class="comment">//</span>
00238 
00239         <span class="keywordflow">if</span> (*NextWchar == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">' '</span>) { <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>; }
00240 
00241         <span class="keywordflow">if</span> (*NextWchar == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'.'</span>) {
00242 
00243             <span class="comment">//</span>
00244             <span class="comment">//  Not an 8.3 name if more than 1 dot or more than 8 characters</span>
00245             <span class="comment">//  remaining.  (It is legal for the dot to be in the ninth</span>
00246             <span class="comment">//  position)</span>
00247             <span class="comment">//</span>
00248 
00249             <span class="keywordflow">if</span> ((DotCount &gt; 0) ||
00250                 (<a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> &gt; 8 * <span class="keyword">sizeof</span>( WCHAR ))) {
00251 
00252                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00253             }
00254 
00255             DotCount += 1;
00256             LastCharDot = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00257 
00258         } <span class="keywordflow">else</span> {
00259 
00260             LastCharDot = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00261         }
00262 
00263         <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> += 2;
00264         NextWchar += 1;
00265 
00266     } <span class="keywordflow">while</span> (<a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> &lt; <a class="code" href="../../d2/d2/rtload_8c.html#a3">FileName</a>.Length);
00267 
00268     <span class="comment">//</span>
00269     <span class="comment">//  We can't have a period at the end of the name.</span>
00270     <span class="comment">//</span>
00271 
00272     <span class="keywordflow">if</span> (LastCharDot) {
00273 
00274         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00275     }
00276 
00277     <span class="comment">//</span>
00278     <span class="comment">//  Create an Oem name to use to check for a valid short name.</span>
00279     <span class="comment">//</span>
00280 
00281     DbcsName.MaximumLength = <a class="code" href="../../d9/d7/udf_8h.html#a11">BYTE_COUNT_8_DOT_3</a>;
00282     DbcsName.Buffer = DbcsNameBuffer;
00283 
00284     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d6/d6/nls_8c.html#a29">RtlUnicodeStringToCountedOemString</a>( &amp;DbcsName,
00285                                                          &amp;<a class="code" href="../../d2/d2/rtload_8c.html#a3">FileName</a>,
00286                                                          <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> ))) {
00287 
00288         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00289     }
00290 
00291     <span class="comment">//</span>
00292     <span class="comment">//  We have now initialized the Oem string.  Call the FsRtl package to check for a</span>
00293     <span class="comment">//  valid FAT name.</span>
00294     <span class="comment">//</span>
00295 
00296     <span class="keywordflow">return</span> <a class="code" href="../../d1/d8/fsrtl_8h.html#a134">FsRtlIsFatDbcsLegal</a>( DbcsName, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00297 }
00298 
00299 
00300 BOOLEAN
<a name="l00301"></a><a class="code" href="../../d3/d8/udfprocs_8h.html#a179">00301</a> <a class="code" href="../../d3/d8/udfprocs_8h.html#a179">UdfCandidateShortName</a> (
00302     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00303     IN PUNICODE_STRING Name
00304     )
00305 
00306 <span class="comment">/*++</span>
00307 <span class="comment"></span>
00308 <span class="comment">Routine Description:</span>
00309 <span class="comment"></span>
00310 <span class="comment">    This routine is called to determine if the input name could be a generated</span>
00311 <span class="comment">    short name.</span>
00312 <span class="comment"></span>
00313 <span class="comment">Arguments:</span>
00314 <span class="comment"></span>
00315 <span class="comment">    Name - Pointer to the name to stare at.</span>
00316 <span class="comment"></span>
00317 <span class="comment">Return Value:</span>
00318 <span class="comment"></span>
00319 <span class="comment">    BOOLEAN True if it is possible that this is a shortname, False otherwise.</span>
00320 <span class="comment"></span>
00321 <span class="comment">--*/</span>
00322 
00323 {
00324     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>, SubIndex;
00325     BOOLEAN LooksShort = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00326     
00327     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00328 
00329     <span class="comment">//</span>
00330     <span class="comment">//  Check inputs.</span>
00331     <span class="comment">//</span>
00332 
00333     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
00334 
00335     <span class="comment">//</span>
00336     <span class="comment">//  The length can't be larger than an 8.3 name and must be</span>
00337     <span class="comment">//  at least as big as the uniqifier stamp.</span>
00338     <span class="comment">//</span>
00339 
00340     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length != 0 );
00341     
00342     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length &gt; <a class="code" href="../../d9/d7/udf_8h.html#a11">BYTE_COUNT_8_DOT_3</a> ||
00343         <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length &lt; <a class="code" href="../../d9/d7/udf_8h.html#a18">DOS_CRC_LEN</a> * <span class="keyword">sizeof</span>(WCHAR)) {
00344 
00345         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00346     }
00347     
00348     <span class="comment">//</span>
00349     <span class="comment">//  Walk across the name looking for the uniquifier stamp.  The stamp</span>
00350     <span class="comment">//  is of the form #&lt;hex&gt;&lt;hex&gt;&lt;hex&gt; so if we can stop before the end</span>
00351     <span class="comment">//  of the full name.</span>
00352     <span class="comment">//</span>
00353     
00354     <span class="keywordflow">for</span> ( <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = 0;
00355           <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &lt;= (<a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length / <span class="keyword">sizeof</span>(WCHAR)) - <a class="code" href="../../d9/d7/udf_8h.html#a18">DOS_CRC_LEN</a>;
00356           <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>++ ) {
00357 
00358         <span class="comment">//</span>
00359         <span class="comment">//  Is the current character the stamp UDF uses to offset the stamp?</span>
00360         <span class="comment">//</span>
00361         
00362         <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Buffer[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>] == <a class="code" href="../../d9/d7/udf_8h.html#a28">CRC_MARK</a>) {
00363         
00364             <span class="comment">//</span>
00365             <span class="comment">//  We may potentially have just a CRC at the end</span>
00366             <span class="comment">//  of the name OR have a period following.  If we</span>
00367             <span class="comment">//  do, it is reasonable to think the name may be</span>
00368             <span class="comment">//  a generated shorty.</span>
00369             <span class="comment">//</span>
00370             <span class="comment">//  #123 (a very special case - orignal name was ".")</span>
00371             <span class="comment">//  FOO#123</span>
00372             <span class="comment">//  FOO#123.TXT</span>
00373             <span class="comment">//</span>
00374             
00375             <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> == (<a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length / <span class="keyword">sizeof</span>(WCHAR)) - <a class="code" href="../../d9/d7/udf_8h.html#a18">DOS_CRC_LEN</a> ||
00376                 <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Buffer[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> + <a class="code" href="../../d9/d7/udf_8h.html#a18">DOS_CRC_LEN</a>] == <a class="code" href="../../d9/d7/udf_8h.html#a26">PERIOD</a>) {
00377 
00378                 LooksShort = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00379                 <span class="keywordflow">break</span>;
00380             }
00381         }
00382     }
00383 
00384     <span class="keywordflow">return</span> LooksShort;
00385 }
00386 
00387 
00388 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00389"></a><a class="code" href="../../d3/d8/udfprocs_8h.html#a180">00389</a> <a class="code" href="../../d3/d8/udfprocs_8h.html#a180">UdfGenerate8dot3Name</a> (
00390     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00391     IN PUNICODE_STRING FileName,
00392     OUT PUNICODE_STRING ShortFileName
00393     )
00394 
00395 <span class="comment">/*++</span>
00396 <span class="comment"></span>
00397 <span class="comment">Routine Description:</span>
00398 <span class="comment"></span>
00399 <span class="comment">    This routine is called to generate a short name from the given long name.  We will</span>
00400 <span class="comment">    generate a short name from the given long name.</span>
00401 <span class="comment"></span>
00402 <span class="comment">    The short form is to convert all runs of illegal characters to "_" and tack</span>
00403 <span class="comment">    on a base41 representation of the CRC of the original name.  The algorithm is</span>
00404 <span class="comment">    nearly directly lifted from the UDF (2.01 proposed!) standard, so apologies for the</span>
00405 <span class="comment">    style clash.</span>
00406 <span class="comment">    </span>
00407 <span class="comment">Arguments:</span>
00408 <span class="comment"></span>
00409 <span class="comment">    FileName - String of bytes containing the name.</span>
00410 <span class="comment"></span>
00411 <span class="comment">    ShortFileName - Pointer to the string to store the short name into.</span>
00412 <span class="comment">        </span>
00413 <span class="comment">Return Value:</span>
00414 <span class="comment"></span>
00415 <span class="comment">    None.</span>
00416 <span class="comment"></span>
00417 <span class="comment">--*/</span>
00418 
00419 {
00420     <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a10">INT16</a> index;
00421     <a class="code" href="../../d9/d7/udf_8h.html#a23">INT16</a> targetIndex;
00422     <a class="code" href="../../d9/d7/udf_8h.html#a23">INT16</a> crcIndex;
00423     <a class="code" href="../../d9/d7/udf_8h.html#a23">INT16</a> extLen;
00424     <a class="code" href="../../d9/d7/udf_8h.html#a23">INT16</a> nameLen;
00425     <a class="code" href="../../d9/d7/udf_8h.html#a23">INT16</a> charLen;
00426     <a class="code" href="../../d9/d7/udf_8h.html#a23">INT16</a> overlayBytes;
00427     <a class="code" href="../../d9/d7/udf_8h.html#a23">INT16</a> bytesLeft;
00428     <a class="code" href="../../d9/d7/udf_8h.html#a25">UNICODE_CHAR</a> current;
00429     BOOLEAN needsCRC;
00430     <a class="code" href="../../d9/d7/udf_8h.html#a25">UNICODE_CHAR</a> ext[<a class="code" href="../../d9/d7/udf_8h.html#a17">DOS_EXT_LEN</a>];
00431 
00432     <span class="comment">//</span>
00433     <span class="comment">//  So as to lift as directly as possible from the standard, chunk things around.</span>
00434     <span class="comment">//</span>
00435  
00436     PWCHAR dosName = ShortFileName-&gt;Buffer;
00437     PWCHAR udfName = <a class="code" href="../../d2/d2/rtload_8c.html#a3">FileName</a>-&gt;Buffer;
00438     LONG udfNameLen = <a class="code" href="../../d2/d2/rtload_8c.html#a3">FileName</a>-&gt;Length / <span class="keyword">sizeof</span>(WCHAR);
00439     
00440     needsCRC = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00441 
00442     <span class="comment">/* Start at the end of the UDF file name and scan for a period */</span>
00443     <span class="comment">/* ('.').  This will be where the DOS extension starts (if     */</span>
00444     <span class="comment">/* any).                                                       */</span>
00445     index = udfNameLen;
00446     <span class="keywordflow">while</span> (index-- &gt; 0) {
00447         <span class="keywordflow">if</span> (udfName[index] == <a class="code" href="../../d9/d7/udf_8h.html#a26">PERIOD</a>)
00448             <span class="keywordflow">break</span>;
00449     }
00450 
00451     <span class="keywordflow">if</span> (index &lt; 0) {
00452         <span class="comment">/* There name was scanned to the beginning of the buffer   */</span>
00453         <span class="comment">/* and no extension was found.                             */</span>
00454         extLen = 0;
00455         nameLen = udfNameLen;
00456     }
00457     <span class="keywordflow">else</span> {
00458         <span class="comment">/* A DOS extension was found, process it first.            */</span>
00459         extLen = udfNameLen - index - 1;
00460         nameLen = index;
00461         targetIndex = 0;
00462         bytesLeft = <a class="code" href="../../d9/d7/udf_8h.html#a17">DOS_EXT_LEN</a>;
00463 
00464         <span class="keywordflow">while</span> (++index &lt; udfNameLen &amp;&amp; bytesLeft &gt; 0) {
00465             <span class="comment">/* Get the current character and convert it to upper   */</span>
00466             <span class="comment">/* case.                                               */</span>
00467             current = <a class="code" href="../../d9/d7/udf_8h.html#a22">UnicodeToUpper</a>(udfName[index]);
00468             <span class="keywordflow">if</span> (current == <a class="code" href="../../d9/d7/udf_8h.html#a27">SPACE</a>) {
00469                 <span class="comment">/* If a space is found, a CRC must be appended to  */</span>
00470                 <span class="comment">/* the mangled file name.                          */</span>
00471                 needsCRC = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00472             }
00473             <span class="keywordflow">else</span> {
00474                 <span class="comment">/* Determine if this is a valid file name char and */</span>
00475                 <span class="comment">/* calculate its corresponding BCS character byte  */</span>
00476                 <span class="comment">/* length (zero if the char is not legal or        */</span>
00477                 <span class="comment">/* undisplayable on this system).                  */</span>
00478                 charLen = (<a class="code" href="../../d9/d7/udf_8h.html#a19">IsFileNameCharLegal</a>(current)) ?
00479                     <a class="code" href="../../d5/d5/namesup_8c.html#a3">NativeDosCharLength</a>(current) : 0;
00480 
00481                 <span class="comment">/* If the char is larger than the available space  */</span>
00482                 <span class="comment">/* in the buffer, pretend it is undisplayable.     */</span>
00483                 <span class="keywordflow">if</span> (charLen &gt; bytesLeft)
00484                     charLen = 0;
00485 
00486                 <span class="keywordflow">if</span> (charLen == 0) {
00487                     <span class="comment">/* Undisplayable or illegal characters are     */</span>
00488                     <span class="comment">/* substituted with an underscore ("_"), and   */</span>
00489                     <span class="comment">/* required a CRC code appended to the mangled */</span>
00490                     <span class="comment">/* file name.                                  */</span>
00491                     needsCRC = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00492                     charLen = 1;
00493                     current = <a class="code" href="../../d9/d7/udf_8h.html#a29">ILLEGAL_CHAR_MARK</a>;
00494 
00495                     <span class="comment">/* Skip over any following undiplayable or     */</span>
00496                     <span class="comment">/* illegal chars.                              */</span>
00497                     <span class="keywordflow">while</span> (index + 1 &lt; udfNameLen &amp;&amp;
00498                         (!<a class="code" href="../../d9/d7/udf_8h.html#a19">IsFileNameCharLegal</a>(udfName[index + 1]) ||
00499                         <a class="code" href="../../d5/d5/namesup_8c.html#a3">NativeDosCharLength</a>(udfName[index + 1]) == 0))
00500                         index++;
00501                 }
00502 
00503                 <span class="comment">/* Assign the resulting char to the next index in  */</span>
00504                 <span class="comment">/* the extension buffer and determine how many BCS */</span>
00505                 <span class="comment">/* bytes are left.                                 */</span>
00506                 ext[targetIndex++] = current;
00507                 bytesLeft -= charLen;
00508             }
00509         }
00510 
00511         <span class="comment">/* Save the number of Unicode characters in the extension  */</span>
00512         extLen = targetIndex;
00513 
00514         <span class="comment">/* If the extension was too large, or it was zero length   */</span>
00515         <span class="comment">/* (i.e. the name ended in a period), a CRC code must be   */</span>
00516         <span class="comment">/* appended to the mangled name.                           */</span>
00517         <span class="keywordflow">if</span> (index &lt; udfNameLen || extLen == 0)
00518             needsCRC = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00519     }
00520 
00521     <span class="comment">/* Now process the actual file name.                           */</span>
00522     index = 0;
00523     targetIndex = 0;
00524     crcIndex = 0;
00525     overlayBytes = -1;
00526     bytesLeft = <a class="code" href="../../d9/d7/udf_8h.html#a16">DOS_NAME_LEN</a>;
00527     <span class="keywordflow">while</span> (index &lt; nameLen &amp;&amp; bytesLeft &gt; 0) {
00528         <span class="comment">/* Get the current character and convert it to upper case. */</span>
00529         current = <a class="code" href="../../d9/d7/udf_8h.html#a22">UnicodeToUpper</a>(udfName[index]);
00530         <span class="keywordflow">if</span> (current == <a class="code" href="../../d9/d7/udf_8h.html#a27">SPACE</a> || current == <a class="code" href="../../d9/d7/udf_8h.html#a26">PERIOD</a>) {
00531             <span class="comment">/* Spaces and periods are just skipped, a CRC code     */</span>
00532             <span class="comment">/* must be added to the mangled file name.             */</span>
00533             needsCRC = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00534         }
00535         <span class="keywordflow">else</span> {
00536             <span class="comment">/* Determine if this is a valid file name char and     */</span>
00537             <span class="comment">/* calculate its corresponding BCS character byte      */</span>
00538             <span class="comment">/* length (zero if the char is not legal or            */</span>
00539             <span class="comment">/* undisplayable on this system).                      */</span>
00540             charLen = (<a class="code" href="../../d9/d7/udf_8h.html#a19">IsFileNameCharLegal</a>(current)) ?
00541                 <a class="code" href="../../d5/d5/namesup_8c.html#a3">NativeDosCharLength</a>(current) : 0;
00542 
00543             <span class="comment">/* If the char is larger than the available space in   */</span>
00544             <span class="comment">/* the buffer, pretend it is undisplayable.            */</span>
00545             <span class="keywordflow">if</span> (charLen &gt; bytesLeft)
00546                 charLen = 0;
00547 
00548             <span class="keywordflow">if</span> (charLen == 0) {
00549                 <span class="comment">/* Undisplayable or illegal characters are         */</span>
00550                 <span class="comment">/* substituted with an underscore ("_"), and       */</span>
00551                 <span class="comment">/* required a CRC code appended to the mangled     */</span>
00552                 <span class="comment">/* file name.                                      */</span>
00553                 needsCRC = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00554                 charLen = 1;
00555                 current = <a class="code" href="../../d9/d7/udf_8h.html#a29">ILLEGAL_CHAR_MARK</a>;
00556 
00557                 <span class="comment">/* Skip over any following undiplayable or illegal */</span>
00558                 <span class="comment">/* chars.                                          */</span>
00559                 <span class="keywordflow">while</span> (index + 1 &lt; nameLen &amp;&amp;
00560                     (!<a class="code" href="../../d9/d7/udf_8h.html#a19">IsFileNameCharLegal</a>(udfName[index + 1]) ||
00561                     <a class="code" href="../../d5/d5/namesup_8c.html#a3">NativeDosCharLength</a>(udfName[index + 1]) == 0))
00562                     index++;
00563 
00564                 <span class="comment">/* Terminate loop if at the end of the file name.  */</span>
00565                 <span class="keywordflow">if</span> (index &gt;= nameLen)
00566                     <span class="keywordflow">break</span>;
00567             }
00568 
00569             <span class="comment">/* Assign the resulting char to the next index in the  */</span>
00570             <span class="comment">/* file name buffer and determine how many BCS bytes   */</span>
00571             <span class="comment">/* are left.                                           */</span>
00572             dosName[targetIndex++] = current;
00573             bytesLeft -= charLen;
00574 
00575             <span class="comment">/* This figures out where the CRC code needs to start  */</span>
00576             <span class="comment">/* in the file name buffer.                            */</span>
00577             <span class="keywordflow">if</span> (bytesLeft &gt;= <a class="code" href="../../d9/d7/udf_8h.html#a18">DOS_CRC_LEN</a>) {
00578                 <span class="comment">/* If there is enough space left, just tack it     */</span>
00579                 <span class="comment">/* onto the end.                                   */</span>
00580                 crcIndex = targetIndex;
00581             }
00582             <span class="keywordflow">else</span> {
00583                 <span class="comment">/* If there is not enough space left, the CRC      */</span>
00584                 <span class="comment">/* must overlay a character already in the file    */</span>
00585                 <span class="comment">/* name buffer.  Once this condition has been      */</span>
00586                 <span class="comment">/* met, the value will not change.                 */</span>
00587                 <span class="keywordflow">if</span> (overlayBytes &lt; 0) {
00588                     <span class="comment">/* Determine the index and save the length of  */</span>
00589                     <span class="comment">/* the BCS character that is overlayed.  It    */</span>
00590                     <span class="comment">/* is possible that the CRC might overlay      */</span>
00591                     <span class="comment">/* half of a two-byte BCS character depending  */</span>
00592                     <span class="comment">/* upon how the character boundaries line up.  */</span>
00593                     overlayBytes = (bytesLeft + charLen &gt; <a class="code" href="../../d9/d7/udf_8h.html#a18">DOS_CRC_LEN</a>)
00594                         ? 1 : 0;
00595                     crcIndex = targetIndex - 1;
00596                 }
00597             }
00598         }
00599 
00600         <span class="comment">/* Advance to the next character.                          */</span>
00601         index++;
00602     }
00603 
00604     <span class="comment">/* If the scan did not reach the end of the file name, or the  */</span>
00605     <span class="comment">/* length of the file name is zero, a CRC code is needed.      */</span>
00606     <span class="keywordflow">if</span> (index &lt; nameLen || index == 0)
00607         needsCRC = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00608 
00609     <span class="comment">/* If the name has illegal characters or and extension, it     */</span>
00610     <span class="comment">/* is not a DOS device name.                                   */</span>
00611     <span class="keywordflow">if</span> (needsCRC == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> &amp;&amp; extLen == 0) {
00612         <span class="comment">/* If this is the name of a DOS device, a CRC code should  */</span>
00613         <span class="comment">/* be appended to the file name.                           */</span>
00614         <span class="keywordflow">if</span> (<a class="code" href="../../d9/d7/udf_8h.html#a20">IsDeviceName</a>(udfName, udfNameLen))
00615             needsCRC = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00616     }
00617 
00618     <span class="comment">/* Append the CRC code to the file name, if needed.            */</span>
00619     <span class="keywordflow">if</span> (needsCRC) {
00620         <span class="comment">/* Get the CRC value for the original Unicode string       */</span>
00621         <a class="code" href="../../d9/d7/udf_8h.html#a24">UINT16</a> udfCRCValue;
00622         <a class="code" href="../../d9/d7/udf_8h.html#a24">UINT16</a> modulus;
00623 
00624         <span class="comment">//</span>
00625         <span class="comment">//  In UDF 2.00, the sample code changed to take the CRC</span>
00626         <span class="comment">//  from the UNICODE expansion of the CS0 as opposed to</span>
00627         <span class="comment">//  the CS0 itself.  In UDF 2.01, the wording of the spec</span>
00628         <span class="comment">//  will actually match this.</span>
00629         <span class="comment">//</span>
00630         <span class="comment">//  Additionally, the checksum changes to be byte-order</span>
00631         <span class="comment">//  independent.</span>
00632         <span class="comment">//</span>
00633         
00634         udfCRCValue = <a class="code" href="../../d3/d8/udfprocs_8h.html#a135">UdfComputeCrc16Uni</a>(udfName, udfNameLen);
00635 
00636         <span class="comment">/* Determine the character index where the CRC should      */</span>
00637         <span class="comment">/* begin.                                                  */</span>
00638         targetIndex = crcIndex;
00639 
00640         <span class="comment">/* If the character being overlayed is a two-byte BCS      */</span>
00641         <span class="comment">/* character, replace the first byte with an underscore.   */</span>
00642         <span class="keywordflow">if</span> (overlayBytes &gt; 0)
00643             dosName[targetIndex++] = <a class="code" href="../../d9/d7/udf_8h.html#a29">ILLEGAL_CHAR_MARK</a>;
00644 
00645         <span class="comment">//</span>
00646         <span class="comment">//  UDF 2.01 changes to a base 41 encoding.  UDF 1.50 and</span>
00647         <span class="comment">//  UDF 2.00 exchanged the # delimeter with the high 4bits</span>
00648         <span class="comment">//  of the CRC.</span>
00649         <span class="comment">//</span>
00650 
00651         dosName[targetIndex++] = <a class="code" href="../../d9/d7/udf_8h.html#a28">CRC_MARK</a>;
00652         
00653         dosName[targetIndex++] =
00654             <a class="code" href="../../d5/d5/namesup_8c.html#a2">UdfCrcChar</a>[udfCRCValue / (41 * 41)];
00655         udfCRCValue %= (41 * 41);
00656         
00657         dosName[targetIndex++] =
00658             <a class="code" href="../../d5/d5/namesup_8c.html#a2">UdfCrcChar</a>[udfCRCValue / 41];
00659         udfCRCValue %= 41;
00660         
00661         dosName[targetIndex++] =
00662             <a class="code" href="../../d5/d5/namesup_8c.html#a2">UdfCrcChar</a>[udfCRCValue];
00663     }
00664 
00665     <span class="comment">/* Append the extension, if any.                               */</span>
00666     <span class="keywordflow">if</span> (extLen &gt; 0) {
00667         <span class="comment">/* Tack on a period and each successive byte in the        */</span>
00668         <span class="comment">/* extension buffer.                                       */</span>
00669         dosName[targetIndex++] = <a class="code" href="../../d9/d7/udf_8h.html#a26">PERIOD</a>;
00670         <span class="keywordflow">for</span> (index = 0; index &lt; extLen; index++)
00671             dosName[targetIndex++] = ext[index];
00672     }
00673 
00674     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( (targetIndex * <span class="keyword">sizeof</span>(WCHAR)) &lt;= ShortFileName-&gt;MaximumLength );
00675  
00676     ShortFileName-&gt;Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>) (targetIndex * <span class="keyword">sizeof</span>(WCHAR));
00677 
00678     <span class="comment">//</span>
00679     <span class="comment">//  Now we upcase the whole name at once.</span>
00680     <span class="comment">//</span>
00681 
00682     <a class="code" href="../../d3/d8/udfprocs_8h.html#a186">UdfUpcaseName</a>( IrpContext,
00683                    ShortFileName,
00684                    ShortFileName );
00685 }
00686 
00687 
00688 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00689"></a><a class="code" href="../../d3/d8/udfprocs_8h.html#a181">00689</a> <a class="code" href="../../d3/d8/udfprocs_8h.html#a181">UdfConvertCS0DstringToUnicode</a> (
00690     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00691     IN PUCHAR Dstring,
00692     IN UCHAR Length OPTIONAL,
00693     IN UCHAR FieldLength OPTIONAL,
00694     IN OUT PUNICODE_STRING Name
00695     )
00696 
00697 <span class="comment">/*++</span>
00698 <span class="comment"></span>
00699 <span class="comment">Routine Description:</span>
00700 <span class="comment"></span>
00701 <span class="comment">    This routine will convert the CS0 input dstring (1/7.2.12) to Unicode.  We assume that</span>
00702 <span class="comment">    the length is sane.</span>
00703 <span class="comment">    </span>
00704 <span class="comment">    This "compression" in CS0 is really just a special case hack for ASCII.</span>
00705 <span class="comment"></span>
00706 <span class="comment">Arguments:</span>
00707 <span class="comment"></span>
00708 <span class="comment">    Dstring - the input dstring field</span>
00709 <span class="comment">    </span>
00710 <span class="comment">    Length - length of the dstring.  If unspecified, we assume that the characters come</span>
00711 <span class="comment">        from a proper 1/7.2.12 dstring that specifies length in the last character of the</span>
00712 <span class="comment">        field.</span>
00713 <span class="comment">    </span>
00714 <span class="comment">    FieldLength - length of the dstring field.  If unspecified, we assume that the characters</span>
00715 <span class="comment">        come from an uncounted length of CS0 characters and that the Length parameter is</span>
00716 <span class="comment">        specified.</span>
00717 <span class="comment">    </span>
00718 <span class="comment">    Name - the output Unicode string</span>
00719 <span class="comment"></span>
00720 <span class="comment">Return Value:</span>
00721 <span class="comment"></span>
00722 <span class="comment">    None.</span>
00723 <span class="comment"></span>
00724 <span class="comment">--*/</span>
00725 
00726 {
00727     ULONG CompressID;
00728     ULONG UnicodeIndex, ByteIndex;
00729     PWCHAR <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a96">Unicode</a> = <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Buffer;
00730 
00731     UCHAR NameLength;
00732     ULONG CopyNameLength;
00733 
00734     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00735    
00736     <span class="comment">//</span>
00737     <span class="comment">//  Check input.</span>
00738     <span class="comment">//</span>
00739 
00740     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
00741 
00742     CompressID = *Dstring;
00743 
00744     <span class="comment">//</span>
00745     <span class="comment">//  If the length is unspecified, this is a real 1/7.2.12 dstring and the length is in</span>
00746     <span class="comment">//  the last character of the field.</span>
00747     <span class="comment">//</span>
00748     
00749     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( Length || FieldLength );
00750 
00751     <span class="keywordflow">if</span> (Length) {
00752 
00753         NameLength = FieldLength = Length;
00754     
00755     } <span class="keywordflow">else</span> {
00756 
00757         NameLength = *(Dstring + FieldLength - 1);
00758     }
00759     
00760     <span class="comment">//</span>
00761     <span class="comment">//  If the caller specified a size, they should have made sure the buffer is big enough.</span>
00762     <span class="comment">//  Otherwise, we will trim to fit.</span>
00763     <span class="comment">//</span>
00764     
00765     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( Length == 0 || <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;MaximumLength &gt;= <a class="code" href="../../d3/d8/udfprocs_8h.html#a187">UdfCS0DstringUnicodeSize</a>( IrpContext, Dstring, NameLength ) );
00766  
00767     <span class="comment">//</span>
00768     <span class="comment">//  Decide how many UNICODE bytes to "copy".</span>
00769     <span class="comment">//</span>
00770     
00771     CopyNameLength = <a class="code" href="../../d3/d8/udfprocs_8h.html#a3">Min</a>( <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;MaximumLength, <a class="code" href="../../d3/d8/udfprocs_8h.html#a187">UdfCS0DstringUnicodeSize</a>( IrpContext, Dstring, NameLength ));
00772     
00773     <span class="comment">//</span>
00774     <span class="comment">//  Reset the name length and advance over the compression ID in the dstring.</span>
00775     <span class="comment">//</span>
00776     
00777     <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length = 0;
00778     Dstring++;
00779  
00780     <span class="comment">//</span>
00781     <span class="comment">//  Loop through all the bytes.</span>
00782     <span class="comment">//</span>
00783 
00784     <span class="keywordflow">while</span> (CopyNameLength &gt; <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length) {
00785       
00786         <span class="keywordflow">if</span> (CompressID == 16) {
00787        
00788             <span class="comment">//</span>
00789             <span class="comment">//  We're little endian, and this is the single place in the entire UDF/ISO standard</span>
00790             <span class="comment">//  where they use big endian.</span>
00791             <span class="comment">//</span>
00792             <span class="comment">//  Thank you.  Thank you very much.</span>
00793             <span class="comment">//</span>
00794             <span class="comment">//  Do an unaligned swapcopy of this 16bit value.</span>
00795             <span class="comment">//</span>
00796 
00797             <a class="code" href="../../d3/d8/udfprocs_8h.html#a58">SwapCopyUchar2</a>( <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a96">Unicode</a>, Dstring );
00798             Dstring += <span class="keyword">sizeof</span>(WCHAR);
00799        
00800         } <span class="keywordflow">else</span> {
00801 
00802             <span class="comment">//</span>
00803             <span class="comment">//  Drop the byte into the low bits.</span>
00804             <span class="comment">//</span>
00805                 
00806             *<a class="code" href="../../d2/d0/nt6_2user32_8def.html#a96">Unicode</a> = *Dstring;
00807             Dstring += <span class="keyword">sizeof</span>(<a class="code" href="../../d1/d1/bench_8c.html#a16">CHAR</a>);
00808         }
00809 
00810         <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length += <span class="keyword">sizeof</span>(WCHAR);
00811         <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a96">Unicode</a>++;
00812     }
00813 
00814     <span class="keywordflow">return</span>;
00815 }
00816 
00817 
00818 BOOLEAN
<a name="l00819"></a><a class="code" href="../../d3/d8/udfprocs_8h.html#a182">00819</a> <a class="code" href="../../d3/d8/udfprocs_8h.html#a182">UdfCheckLegalCS0Dstring</a> (
00820     <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00821     PUCHAR Dstring,
00822     UCHAR Length OPTIONAL,
00823     UCHAR FieldLength OPTIONAL,
00824     BOOLEAN ReturnOnError
00825     )
00826 
00827 <span class="comment">/*++</span>
00828 <span class="comment"></span>
00829 <span class="comment">Routine Description:</span>
00830 <span class="comment"></span>
00831 <span class="comment">    This routine inspects a CS0 Dstring for conformance.</span>
00832 <span class="comment">    </span>
00833 <span class="comment">Arguments:</span>
00834 <span class="comment"></span>
00835 <span class="comment">    Dstring - a dstring to check</span>
00836 <span class="comment">    </span>
00837 <span class="comment">    Length - length of the dstring.  If unspecified, we assume that the characters come</span>
00838 <span class="comment">        from a proper 1/7.2.12 dstring that specifies length in the last character of the</span>
00839 <span class="comment">        field.</span>
00840 <span class="comment">    </span>
00841 <span class="comment">    FieldLength - length of the dstring field.  If unspecified, we assume that the characters</span>
00842 <span class="comment">        come from an uncounted length of CS0 characters and that the Length parameter is</span>
00843 <span class="comment">        specified.</span>
00844 <span class="comment">    </span>
00845 <span class="comment">    ReturnOnError - whether to return or raise on a discovered error</span>
00846 <span class="comment">    </span>
00847 <span class="comment">Return Value:</span>
00848 <span class="comment"></span>
00849 <span class="comment">    None. Raised status if corruption is found.</span>
00850 <span class="comment">    </span>
00851 <span class="comment">--*/</span>
00852 
00853 {
00854     UCHAR NameLength;
00855 
00856     <span class="comment">//</span>
00857     <span class="comment">//  Check input.</span>
00858     <span class="comment">//</span>
00859 
00860     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
00861 
00862     <span class="comment">//</span>
00863     <span class="comment">//  If the length is unspecified, this is a real 1/7.2.12 dstring and the length is in</span>
00864     <span class="comment">//  the last character of the field.</span>
00865     <span class="comment">//</span>
00866     
00867     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( Length || FieldLength );
00868 
00869     <span class="keywordflow">if</span> (Length) {
00870 
00871         NameLength = FieldLength = Length;
00872     
00873     } <span class="keywordflow">else</span> {
00874 
00875         NameLength = *(Dstring + FieldLength - 1);
00876     }
00877 
00878     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( +1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
00879                  <span class="stringliteral">"UdfCheckLegalCS0Dstring, Dstring %08x Length %02x FieldLength %02x (NameLength %02x)\n"</span>,
00880                  Dstring,
00881                  Length,
00882                  FieldLength,
00883                  NameLength ));
00884 
00885     <span class="comment">//</span>
00886     <span class="comment">//  The string must be "compressed" in 8bit or 16bit chunks.  If it</span>
00887     <span class="comment">//  is in 16bit chunks, we better have an integral number of them -</span>
00888     <span class="comment">//  remember we have the compression ID, so the length will be odd.</span>
00889     <span class="comment">//</span>
00890     
00891     <span class="keywordflow">if</span> ((NameLength &lt;= 1 &amp;&amp;
00892          <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
00893                       <span class="stringliteral">"UdfCheckLegalCS0Dstring, NameLength is too small!\n"</span> ))) ||
00894 
00895         (NameLength &gt; FieldLength &amp;&amp;
00896          <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
00897                       <span class="stringliteral">"UdfCheckLegalCS0Dstring, NameLength is bigger than the field itself!\n"</span> ))) ||
00898 
00899         ((*Dstring != 8 &amp;&amp; *Dstring != 16) &amp;&amp;
00900          <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
00901                       <span class="stringliteral">"UdfCheckLegalCS0Dstring, claims encoding %02x, unknown! (not 0x8 or 0x10)\n"</span>,
00902                       *Dstring ))) ||
00903 
00904         ((*Dstring == 16 &amp;&amp; !<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( NameLength, 1)) &amp;&amp;
00905          <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
00906                      <span class="stringliteral">"UdfCheckLegalCS0Dstring, NameLength not odd, encoding 0x10!\n"</span> )))) {
00907 
00908         <span class="keywordflow">if</span> (ReturnOnError) {
00909 
00910             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfCheckLegalCS0Dstring -&gt; FALSE\n"</span> ));
00911 
00912             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00913         }
00914 
00915         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfCheckLegalCS0Dstring -&gt; raised status\n"</span> ));
00916 
00917         <a class="code" href="../../d3/d8/udfprocs_8h.html#a122">UdfRaiseStatus</a>( IrpContext, STATUS_FILE_CORRUPT_ERROR );
00918     }
00919 
00920     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfCheckLegalCS0Dstring -&gt; TRUE\n"</span> ));
00921 
00922     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00923 }
00924 
00925 
00926 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00927"></a><a class="code" href="../../d3/d8/udfprocs_8h.html#a183">00927</a> <a class="code" href="../../d3/d8/udfprocs_8h.html#a183">UdfRenderNameToLegalUnicode</a> (
00928     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00929     IN PUNICODE_STRING Name,
00930     IN PUNICODE_STRING RenderedName
00931     )
00932 
00933 <span class="comment">/*++</span>
00934 <span class="comment"></span>
00935 <span class="comment">Routine Description:</span>
00936 <span class="comment"></span>
00937 <span class="comment">    This routine will take a Unicode string containing illegal characters and</span>
00938 <span class="comment">    run it through the UDF standard algorithim to render it into a "legal"</span>
00939 <span class="comment">    name.</span>
00940 <span class="comment">    </span>
00941 <span class="comment">    The short form is to convert all runs of illegal characters to "_" and tack</span>
00942 <span class="comment">    on a hex representation of the CRC of the original name.  The algorithm is</span>
00943 <span class="comment">    nearly directly lifted from the UDF (2.01 proposed!) standard, so apologies</span>
00944 <span class="comment">    for the style clash.</span>
00945 <span class="comment">    </span>
00946 <span class="comment">Arguments:</span>
00947 <span class="comment"></span>
00948 <span class="comment">    Name - the actual name</span>
00949 <span class="comment">    </span>
00950 <span class="comment">    RenderedName - the name rendered into legal characters</span>
00951 <span class="comment">    </span>
00952 <span class="comment">Return Value:</span>
00953 <span class="comment"></span>
00954 <span class="comment">    BOOLEAN - TRUE if the expressions match, FALSE otherwise.</span>
00955 <span class="comment"></span>
00956 <span class="comment">--*/</span>
00957 
00958 {
00959     <a class="code" href="../../d9/d7/udf_8h.html#a23">INT16</a> index;
00960     <a class="code" href="../../d9/d7/udf_8h.html#a23">INT16</a> targetIndex;
00961     <a class="code" href="../../d9/d7/udf_8h.html#a23">INT16</a> crcIndex;
00962     <a class="code" href="../../d9/d7/udf_8h.html#a23">INT16</a> extLen;
00963     <a class="code" href="../../d9/d7/udf_8h.html#a23">INT16</a> nameLen;
00964     <a class="code" href="../../d9/d7/udf_8h.html#a23">INT16</a> charLen;
00965     <a class="code" href="../../d9/d7/udf_8h.html#a23">INT16</a> overlayBytes;
00966     <a class="code" href="../../d9/d7/udf_8h.html#a23">INT16</a> bytesLeft;
00967     <a class="code" href="../../d9/d7/udf_8h.html#a25">UNICODE_CHAR</a> current;
00968     BOOLEAN needsCRC;
00969     BOOLEAN foundDot;
00970     <a class="code" href="../../d9/d7/udf_8h.html#a25">UNICODE_CHAR</a> ext[<a class="code" href="../../d9/d7/udf_8h.html#a14">EXT_LEN</a>];
00971 
00972     <span class="comment">//</span>
00973     <span class="comment">//  So as to lift as directly as possible from the standard, chunk things around.</span>
00974     <span class="comment">//</span>
00975  
00976     PWCHAR newName = RenderedName-&gt;Buffer;
00977     PWCHAR udfName = <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Buffer;
00978     LONG udfNameLen = <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length / <span class="keyword">sizeof</span>(WCHAR);
00979 
00980     <span class="comment">/* Remove trailing periods ('.') and spaces (' '), Windows     */</span>
00981     <span class="comment">/* does not like them.                                         */</span>
00982     foundDot = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00983     index = udfNameLen;
00984     <span class="keywordflow">while</span> (index-- &gt; 0) {
00985         <span class="keywordflow">if</span> (udfName[index] == <a class="code" href="../../d9/d7/udf_8h.html#a26">PERIOD</a>)
00986             foundDot = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00987         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (udfName[index] != <a class="code" href="../../d9/d7/udf_8h.html#a27">SPACE</a>)
00988             <span class="keywordflow">break</span>;
00989     }
00990 
00991     <span class="comment">/* If any trailing periods or spaces were found, a CRC code    */</span>
00992     <span class="comment">/* needs to be added to the resulting file name.               */</span>
00993     nameLen = index + 1;
00994     <span class="keywordflow">if</span> (nameLen &lt; udfNameLen)
00995         needsCRC = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00996 
00997     needsCRC = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00998     bytesLeft = <a class="code" href="../../d9/d7/udf_8h.html#a13">MAX_LEN</a>;
00999     extLen = 0;
01000 
01001     <span class="keywordflow">if</span> (needsCRC == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> || foundDot == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01002         <span class="comment">/* Look for an extension in the file name.  We do not      */</span>
01003         <span class="comment">/* need to look for one if there were any trailing periods */</span>
01004         <span class="comment">/* removed.                                                */</span>
01005         <a class="code" href="../../d9/d7/udf_8h.html#a23">INT16</a> endIndex;
01006         <a class="code" href="../../d9/d7/udf_8h.html#a23">INT16</a> prevCharLen = 1;
01007         <a class="code" href="../../d9/d7/udf_8h.html#a23">INT16</a> extBytes = 0;
01008 
01009         targetIndex = 0;
01010         index = nameLen;
01011 
01012         <span class="comment">/* Determine how many bytes we need to scan to find the    */</span>
01013         <span class="comment">/* extension delimiter.  The extension has a maximum of    */</span>
01014         <span class="comment">/* five characters, but we do not want to scan past the    */</span>
01015         <span class="comment">/* beginning of the buffer.                                */</span>
01016         endIndex = (udfNameLen &gt; <a class="code" href="../../d9/d7/udf_8h.html#a14">EXT_LEN</a> + 1) ?
01017             udfNameLen - <a class="code" href="../../d9/d7/udf_8h.html#a14">EXT_LEN</a> - 1 : 1;
01018 
01019         <span class="comment">/* Start at the end of the name and scan backward, looking */</span>
01020         <span class="comment">/* for the extension delimiter (".").                      */</span>
01021         <span class="keywordflow">while</span> (index-- &gt; endIndex) {
01022             <span class="comment">/* Get the character to test.                          */</span>
01023             current = udfName[index];
01024 
01025             <span class="keywordflow">if</span> (current == <span class="charliteral">'.'</span>) {
01026                 <span class="comment">/* The extension delimiter was found, figure out   */</span>
01027                 <span class="comment">/* how many characters the extension contains and  */</span>
01028                 <span class="comment">/* the length of the resulting file name without   */</span>
01029                 <span class="comment">/* the extension.                                  */</span>
01030                 extLen = nameLen - index - 1;
01031                 nameLen = index;
01032                 <span class="keywordflow">break</span>;
01033             }
01034 
01035             <span class="comment">/* Determine the byte length of the current character  */</span>
01036             <span class="comment">/* when converted to native format.                    */</span>
01037             charLen = (<a class="code" href="../../d9/d7/udf_8h.html#a19">IsFileNameCharLegal</a>(current)) ?
01038                 <a class="code" href="../../d9/d7/udf_8h.html#a21">NativeCharLength</a>(current) : 0;
01039 
01040             <span class="keywordflow">if</span> (charLen == 0) {
01041                 <span class="comment">/* If the character byte length is zero, it is     */</span>
01042                 <span class="comment">/* illegal or unprintable, place an underscore     */</span>
01043                 <span class="comment">/* ("_") in the extension buffer if the previous   */</span>
01044                 <span class="comment">/* character tested was legal.  Not that the       */</span>
01045                 <span class="comment">/* characters placed in the extension buffer are   */</span>
01046                 <span class="comment">/* in reverse order.                               */</span>
01047                 <span class="keywordflow">if</span> (prevCharLen != 0) {
01048                     ext[targetIndex++] = <a class="code" href="../../d9/d7/udf_8h.html#a29">ILLEGAL_CHAR_MARK</a>;
01049                     extBytes++;
01050                 }
01051             }
01052             <span class="keywordflow">else</span> {
01053                 <span class="comment">/* The current character is legal and printable,   */</span>
01054                 <span class="comment">/* put it in the extension buffer.  Note that the  */</span>
01055                 <span class="comment">/* characters placed in the extension buffer are   */</span>
01056                 <span class="comment">/* in reverse order.                               */</span>
01057                 ext[targetIndex++] = current;
01058                 extBytes += charLen;
01059             }
01060 
01061             <span class="comment">/* Save the byte length of the current character, so   */</span>
01062             <span class="comment">/* we can determine if it was a legal character during */</span>
01063             <span class="comment">/* the next test.                                      */</span>
01064             prevCharLen = charLen;
01065         }
01066 
01067         <span class="comment">/* If an extension was found, determine how many bytes     */</span>
01068         <span class="comment">/* remain in the file name buffer once we account for it.  */</span>
01069         <span class="keywordflow">if</span> (extLen &gt; 0)
01070             bytesLeft -= extBytes + 1;
01071     }
01072 
01073     index = 0;
01074     targetIndex = 0;
01075     crcIndex = 0;
01076     overlayBytes = -1;
01077     <span class="keywordflow">while</span> (index &lt; nameLen &amp;&amp; bytesLeft &gt; 0) {
01078         <span class="comment">/* Get the current character and convert it to upper case. */</span>
01079         current = udfName[index];
01080 
01081         <span class="comment">/* Determine if this is a valid file name char and         */</span>
01082         <span class="comment">/* calculate its corresponding native character byte       */</span>
01083         <span class="comment">/* length (zero if the char is not legal or undiplayable   */</span>
01084         <span class="comment">/* on this system).                                        */</span>
01085         charLen = (<a class="code" href="../../d9/d7/udf_8h.html#a19">IsFileNameCharLegal</a>(current)) ?
01086             <a class="code" href="../../d9/d7/udf_8h.html#a21">NativeCharLength</a>(current) : 0;
01087 
01088         <span class="comment">/* If the char is larger than the available space in the   */</span>
01089         <span class="comment">/* buffer, pretend it is undisplayable.                    */</span>
01090         <span class="keywordflow">if</span> (charLen &gt; bytesLeft)
01091             charLen = 0;
01092 
01093         <span class="keywordflow">if</span> (charLen == 0) {
01094             <span class="comment">/* Undisplayable or illegal characters are substituted */</span>
01095             <span class="comment">/* with an underscore ("_"), and requires a CRC code   */</span>
01096             <span class="comment">/* appended to the mangled file name.                  */</span>
01097             needsCRC = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01098             charLen = 1;
01099             current = <span class="charliteral">'_'</span>;
01100 
01101             <span class="comment">/* Skip over any following undiplayable or illegal     */</span>
01102             <span class="comment">/* chars.                                              */</span>
01103             <span class="keywordflow">while</span> (index + 1 &lt; udfNameLen &amp;&amp;
01104                 (!<a class="code" href="../../d9/d7/udf_8h.html#a19">IsFileNameCharLegal</a>(udfName[index + 1]) ||
01105                 <a class="code" href="../../d9/d7/udf_8h.html#a21">NativeCharLength</a>(udfName[index + 1]) == 0))
01106                 index++;
01107 
01108             <span class="comment">/* Terminate loop if at the end of the file name.      */</span>
01109             <span class="keywordflow">if</span> (index &gt;= udfNameLen)
01110                 <span class="keywordflow">break</span>;
01111         }
01112 
01113         <span class="comment">/* Assign the resulting char to the next index in the file */</span>
01114         <span class="comment">/* name buffer and determine how many native bytes are     */</span>
01115         <span class="comment">/* left.                                                   */</span>
01116         newName[targetIndex++] = current;
01117         bytesLeft -= charLen;
01118 
01119         <span class="comment">/* This figures out where the CRC code needs to start in   */</span>
01120         <span class="comment">/* the file name buffer.                                   */</span>
01121         <span class="keywordflow">if</span> (bytesLeft &gt;= <a class="code" href="../../d9/d7/udf_8h.html#a15">CRC_LEN</a>) {
01122             <span class="comment">/* If there is enough space left, just tack it onto    */</span>
01123             <span class="comment">/* the end.                                            */</span>
01124             crcIndex = targetIndex;
01125         }
01126         <span class="keywordflow">else</span> {
01127             <span class="comment">/* If there is not enough space left, the CRC must     */</span>
01128             <span class="comment">/* overlay a character already in the file name        */</span>
01129             <span class="comment">/* buffer.  Once this condition has been met, the      */</span>
01130             <span class="comment">/* value will not change.                              */</span>
01131             <span class="keywordflow">if</span> (overlayBytes &lt; 0) {
01132                 <span class="comment">/* Determine the index and save the length of the  */</span>
01133                 <span class="comment">/* native character that is overlayed.  It is      */</span>
01134                 <span class="comment">/* possible that the CRC might overlay half of a   */</span>
01135                 <span class="comment">/* two-byte native character depending upon how    */</span>
01136                 <span class="comment">/* the character boundaries line up.               */</span>
01137                 overlayBytes = (bytesLeft + charLen &gt; <a class="code" href="../../d9/d7/udf_8h.html#a15">CRC_LEN</a>)
01138                     ? 1 : 0;
01139                 crcIndex = targetIndex - 1;
01140             }
01141         }
01142 
01143         <span class="comment">/* Advance to the next character.                          */</span>
01144         index++;
01145     }
01146 
01147     <span class="comment">/* If the scan did not reach the end of the file name, or the  */</span>
01148     <span class="comment">/* length of the file name is zero, a CRC code is needed.      */</span>
01149     <span class="keywordflow">if</span> (index &lt; nameLen || index == 0)
01150         needsCRC = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01151 
01152     <span class="comment">/* If the name has illegal characters or and extension, it     */</span>
01153     <span class="comment">/* is not a DOS device name.                                   */</span>
01154     <span class="keywordflow">if</span> (needsCRC == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> &amp;&amp; extLen == 0) {
01155         <span class="comment">/* If this is the name of a DOS device, a CRC code should  */</span>
01156         <span class="comment">/* be appended to the file name.                           */</span>
01157         <span class="keywordflow">if</span> (<a class="code" href="../../d9/d7/udf_8h.html#a20">IsDeviceName</a>(udfName, udfNameLen))
01158             needsCRC = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01159     }
01160 
01161     <span class="comment">/* Append the CRC code to the file name, if needed.            */</span>
01162     <span class="keywordflow">if</span> (needsCRC) {
01163         <span class="comment">/* Get the CRC value for the original Unicode string       */</span>
01164         <a class="code" href="../../d9/d7/udf_8h.html#a24">UINT16</a> udfCRCValue = <a class="code" href="../../d3/d8/udfprocs_8h.html#a135">UdfComputeCrc16Uni</a>(udfName, udfNameLen);
01165 
01166         <span class="comment">/* Determine the character index where the CRC should      */</span>
01167         <span class="comment">/* begin.                                                  */</span>
01168         targetIndex = crcIndex;
01169 
01170         <span class="comment">/* If the character being overlayed is a two-byte native   */</span>
01171         <span class="comment">/* character, replace the first byte with an underscore.   */</span>
01172         <span class="keywordflow">if</span> (overlayBytes &gt; 0)
01173             newName[targetIndex++] = <a class="code" href="../../d9/d7/udf_8h.html#a29">ILLEGAL_CHAR_MARK</a>;
01174 
01175         <span class="comment">/* Append the encoded CRC value with delimiter.            */</span>
01176         newName[targetIndex++] = <a class="code" href="../../d9/d7/udf_8h.html#a28">CRC_MARK</a>;
01177         newName[targetIndex++] = <a class="code" href="../../d5/d5/namesup_8c.html#a2">UdfCrcChar</a>[(udfCRCValue &amp; 0xf000) &gt;&gt; 12];
01178         newName[targetIndex++] = <a class="code" href="../../d5/d5/namesup_8c.html#a2">UdfCrcChar</a>[(udfCRCValue &amp; 0x0f00) &gt;&gt; 8];
01179         newName[targetIndex++] = <a class="code" href="../../d5/d5/namesup_8c.html#a2">UdfCrcChar</a>[(udfCRCValue &amp; 0x00f0) &gt;&gt; 4];
01180         newName[targetIndex++] = <a class="code" href="../../d5/d5/namesup_8c.html#a2">UdfCrcChar</a>[(udfCRCValue &amp; 0x000f)];
01181     }
01182 
01183 
01184     <span class="comment">/* If an extension was found, append it here.                  */</span>
01185     <span class="keywordflow">if</span> (extLen &gt; 0) {
01186         <span class="comment">/* Add the period ('.') for the extension delimiter.       */</span>
01187         newName[targetIndex++] = <a class="code" href="../../d9/d7/udf_8h.html#a26">PERIOD</a>;
01188 
01189         <span class="comment">/* Append the characters in the extension buffer.  They    */</span>
01190         <span class="comment">/* were stored in reverse order, so we need to begin with  */</span>
01191         <span class="comment">/* the last character and work forward.                    */</span>
01192         <span class="keywordflow">while</span> (extLen-- &gt; 0)
01193             newName[targetIndex++] = ext[extLen];
01194     }
01195 
01196     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( (targetIndex * <span class="keyword">sizeof</span>(WCHAR)) &lt;= RenderedName-&gt;MaximumLength );
01197  
01198     RenderedName-&gt;Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>) (targetIndex * <span class="keyword">sizeof</span>(WCHAR));
01199 }
01200 
01201 
01202 BOOLEAN
<a name="l01203"></a><a class="code" href="../../d3/d8/udfprocs_8h.html#a184">01203</a> <a class="code" href="../../d3/d8/udfprocs_8h.html#a184">UdfIsNameInExpression</a> (
01204     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
01205     IN PUNICODE_STRING CurrentName,
01206     IN PUNICODE_STRING SearchExpression,
01207     IN BOOLEAN Wild
01208     )
01209 
01210 <span class="comment">/*++</span>
01211 <span class="comment"></span>
01212 <span class="comment">Routine Description:</span>
01213 <span class="comment"></span>
01214 <span class="comment">    This routine will compare two Unicode strings.  We assume that if this</span>
01215 <span class="comment">    is to be a case-insensitive search then they are already upcased.</span>
01216 <span class="comment"></span>
01217 <span class="comment">Arguments:</span>
01218 <span class="comment"></span>
01219 <span class="comment">    CurrentName - Filename from the disk.</span>
01220 <span class="comment"></span>
01221 <span class="comment">    SearchExpression - Filename expression to use for match.</span>
01222 <span class="comment">    </span>
01223 <span class="comment">    Wild - True if wildcards are present in SearchExpression.</span>
01224 <span class="comment"></span>
01225 <span class="comment">Return Value:</span>
01226 <span class="comment"></span>
01227 <span class="comment">    BOOLEAN - TRUE if the expressions match, FALSE otherwise.</span>
01228 <span class="comment"></span>
01229 <span class="comment">--*/</span>
01230 
01231 {
01232     BOOLEAN Match = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01233     
01234     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01235 
01236     <span class="comment">//</span>
01237     <span class="comment">//  Check inputs.</span>
01238     <span class="comment">//</span>
01239 
01240     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
01241 
01242     <span class="comment">//</span>
01243     <span class="comment">//  If there are wildcards in the expression then we call the</span>
01244     <span class="comment">//  appropriate FsRtlRoutine.</span>
01245     <span class="comment">//</span>
01246 
01247     <span class="keywordflow">if</span> (Wild) {
01248 
01249         Match = <a class="code" href="../../d1/d8/fsrtl_8h.html#a179">FsRtlIsNameInExpression</a>( SearchExpression,
01250                                          CurrentName,
01251                                          <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
01252                                          <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
01253 
01254     <span class="comment">//</span>
01255     <span class="comment">//  Otherwise do a direct memory comparison for the name string.</span>
01256     <span class="comment">//</span>
01257 
01258     } <span class="keywordflow">else</span> {
01259 
01260         <span class="keywordflow">if</span> ((CurrentName-&gt;Length != SearchExpression-&gt;Length) ||
01261             (!RtlEqualMemory( CurrentName-&gt;Buffer,
01262                               SearchExpression-&gt;Buffer,
01263                               CurrentName-&gt;Length ))) {
01264 
01265             Match = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01266         }
01267     }
01268 
01269     <span class="keywordflow">return</span> Match;
01270 }
01271 
01272 
01273 <a class="code" href="../../d1/d8/fsrtl_8h.html#a70">FSRTL_COMPARISON_RESULT</a>
<a name="l01274"></a><a class="code" href="../../d3/d8/udfprocs_8h.html#a185">01274</a> <a class="code" href="../../d3/d8/udfprocs_8h.html#a185">UdfFullCompareNames</a> (
01275     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
01276     IN PUNICODE_STRING NameA,
01277     IN PUNICODE_STRING NameB
01278     )
01279 
01280 <span class="comment">/*++</span>
01281 <span class="comment"></span>
01282 <span class="comment">Routine Description:</span>
01283 <span class="comment"></span>
01284 <span class="comment">    This function compares two names as fast as possible.  Note that since</span>
01285 <span class="comment">    this comparison is case sensitive we can do a direct memory comparison.</span>
01286 <span class="comment"></span>
01287 <span class="comment">Arguments:</span>
01288 <span class="comment"></span>
01289 <span class="comment">    NameA &amp; NameB - The names to compare.</span>
01290 <span class="comment"></span>
01291 <span class="comment">Return Value:</span>
01292 <span class="comment"></span>
01293 <span class="comment">    COMPARISON - returns</span>
01294 <span class="comment"></span>
01295 <span class="comment">        LessThan    if NameA &lt; NameB lexicalgraphically,</span>
01296 <span class="comment">        GreaterThan if NameA &gt; NameB lexicalgraphically,</span>
01297 <span class="comment">        EqualTo     if NameA is equal to NameB</span>
01298 <span class="comment"></span>
01299 <span class="comment">--*/</span>
01300 
01301 {
01302     ULONG i;
01303     ULONG MinLength = NameA-&gt;Length;
01304     <a class="code" href="../../d1/d8/fsrtl_8h.html#a70">FSRTL_COMPARISON_RESULT</a> Result = <a class="code" href="../../d1/d8/fsrtl_8h.html#a189a89">LessThan</a>;
01305 
01306     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01307 
01308     <span class="comment">//</span>
01309     <span class="comment">//  Check inputs.</span>
01310     <span class="comment">//</span>
01311 
01312     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
01313 
01314     <span class="comment">//</span>
01315     <span class="comment">//  Figure out the minimum of the two lengths</span>
01316     <span class="comment">//</span>
01317 
01318     <span class="keywordflow">if</span> (NameA-&gt;Length &gt; NameB-&gt;Length) {
01319 
01320         MinLength = NameB-&gt;Length;
01321         Result = <a class="code" href="../../d1/d8/fsrtl_8h.html#a189a91">GreaterThan</a>;
01322 
01323     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (NameA-&gt;Length == NameB-&gt;Length) {
01324 
01325         Result = <a class="code" href="../../d1/d8/fsrtl_8h.html#a189a90">EqualTo</a>;
01326     }
01327 
01328     <span class="comment">//</span>
01329     <span class="comment">//  Loop through looking at all of the characters in both strings</span>
01330     <span class="comment">//  testing for equalilty, less than, and greater than</span>
01331     <span class="comment">//</span>
01332 
01333     i = (ULONG) RtlCompareMemory( NameA-&gt;Buffer, NameB-&gt;Buffer, MinLength );
01334 
01335     <span class="keywordflow">if</span> (i &lt; MinLength) {
01336 
01337         <span class="comment">//</span>
01338         <span class="comment">//  We know the offset of the first character which is different.</span>
01339         <span class="comment">//</span>
01340 
01341         <span class="keywordflow">return</span> ((NameA-&gt;Buffer[ i / 2 ] &lt; NameB-&gt;Buffer[ i / 2 ]) ?
01342                  <a class="code" href="../../d1/d8/fsrtl_8h.html#a189a89">LessThan</a> :
01343                  <a class="code" href="../../d1/d8/fsrtl_8h.html#a189a91">GreaterThan</a>);
01344     }
01345 
01346     <span class="comment">//</span>
01347     <span class="comment">//  The names match up to the length of the shorter string.</span>
01348     <span class="comment">//  The shorter string lexically appears first.</span>
01349     <span class="comment">//</span>
01350 
01351     <span class="keywordflow">return</span> Result;
01352 }
01353 
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:40:53 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
