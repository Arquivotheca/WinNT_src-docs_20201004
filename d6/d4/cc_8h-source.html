<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: cc.h Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>cc.h</h1><a href="../../d5/d5/cc_8h.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1990  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    cc.h</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module is a header file for the Memory Management based cache</span>
00012 <span class="comment">    management routines for the common Cache subsystem.</span>
00013 <span class="comment"></span>
00014 <span class="comment">Author:</span>
00015 <span class="comment"></span>
00016 <span class="comment">    Tom Miller      [TomM]      4-May-1990</span>
00017 <span class="comment"></span>
00018 <span class="comment">Revision History:</span>
00019 <span class="comment"></span>
00020 <span class="comment">--*/</span>
00021 
00022 <span class="preprocessor">#ifndef _CCh_</span>
00023 <span class="preprocessor"></span><span class="preprocessor">#define _CCh_</span>
00024 <span class="preprocessor"></span>
00025 <span class="preprocessor">#include &lt;<a class="code" href="../../d9/d8/ntos_8h.html">ntos.h</a>&gt;</span>
00026 <span class="preprocessor">#include &lt;NtIoLogc.h&gt;</span>
00027 
00028 <span class="preprocessor">#ifdef MEMPRINT</span>
00029 <span class="preprocessor"></span><span class="preprocessor">#include &lt;<a class="code" href="../../d6/d6/memprint_8h.html">memprint.h</a>&gt;</span>
00030 <span class="preprocessor">#endif</span>
00031 <span class="preprocessor"></span>
00032 <span class="comment">//</span>
00033 <span class="comment">// Define macros to acquire and release cache manager locks.</span>
00034 <span class="comment">//</span>
00035 
00036 <span class="preprocessor">#if defined(_ALPHA_) || defined(_X86_)</span>
00037 <span class="preprocessor"></span>
00038 <span class="preprocessor">#define CcAcquireMasterLock( OldIrql ) \</span>
00039 <span class="preprocessor">    *( OldIrql ) = KeAcquireQueuedSpinLock( LockQueueMasterLock )</span>
00040 <span class="preprocessor"></span>
00041 <span class="preprocessor">#define CcReleaseMasterLock( OldIrql ) \</span>
00042 <span class="preprocessor">    KeReleaseQueuedSpinLock( LockQueueMasterLock, OldIrql )</span>
00043 <span class="preprocessor"></span>
00044 <span class="preprocessor">#define CcAcquireMasterLockAtDpcLevel() \</span>
00045 <span class="preprocessor">    KiAcquireQueuedSpinLock( &amp;KeGetCurrentPrcb()-&gt;LockQueue[LockQueueMasterLock] )</span>
00046 <span class="preprocessor"></span>
00047 <span class="preprocessor">#define CcReleaseMasterLockFromDpcLevel() \</span>
00048 <span class="preprocessor">    KiReleaseQueuedSpinLock( &amp;KeGetCurrentPrcb()-&gt;LockQueue[LockQueueMasterLock] )</span>
00049 <span class="preprocessor"></span>
00050 <span class="preprocessor">#define CcAcquireVacbLock( OldIrql ) \</span>
00051 <span class="preprocessor">    *( OldIrql ) = KeAcquireQueuedSpinLock( LockQueueVacbLock )</span>
00052 <span class="preprocessor"></span>
00053 <span class="preprocessor">#define CcReleaseVacbLock( OldIrql ) \</span>
00054 <span class="preprocessor">    KeReleaseQueuedSpinLock( LockQueueVacbLock, OldIrql )</span>
00055 <span class="preprocessor"></span>
00056 <span class="preprocessor">#define CcAcquireVacbLockAtDpcLevel() \</span>
00057 <span class="preprocessor">    KiAcquireQueuedSpinLock( &amp;KeGetCurrentPrcb()-&gt;LockQueue[LockQueueVacbLock] )</span>
00058 <span class="preprocessor"></span>
00059 <span class="preprocessor">#define CcReleaseVacbLockFromDpcLevel() \</span>
00060 <span class="preprocessor">    KiReleaseQueuedSpinLock( &amp;KeGetCurrentPrcb()-&gt;LockQueue[LockQueueVacbLock] )</span>
00061 <span class="preprocessor"></span>
00062 <span class="preprocessor">#else</span>
00063 <span class="preprocessor"></span>
<a name="l00064"></a><a class="code" href="../../d5/d5/cc_8h.html#a0">00064</a> <span class="preprocessor">#define CcAcquireMasterLock( OldIrql ) \</span>
00065 <span class="preprocessor">    ExAcquireSpinLock( &amp;CcMasterSpinLock, OldIrql )</span>
00066 <span class="preprocessor"></span>
<a name="l00067"></a><a class="code" href="../../d5/d5/cc_8h.html#a1">00067</a> <span class="preprocessor">#define CcReleaseMasterLock( OldIrql ) \</span>
00068 <span class="preprocessor">    ExReleaseSpinLock( &amp;CcMasterSpinLock, OldIrql )</span>
00069 <span class="preprocessor"></span>
<a name="l00070"></a><a class="code" href="../../d5/d5/cc_8h.html#a2">00070</a> <span class="preprocessor">#define CcAcquireMasterLockAtDpcLevel() \</span>
00071 <span class="preprocessor">    ExAcquireSpinLockAtDpcLevel( &amp;CcMasterSpinLock )</span>
00072 <span class="preprocessor"></span>
<a name="l00073"></a><a class="code" href="../../d5/d5/cc_8h.html#a3">00073</a> <span class="preprocessor">#define CcReleaseMasterLockFromDpcLevel() \</span>
00074 <span class="preprocessor">    ExReleaseSpinLockFromDpcLevel( &amp;CcMasterSpinLock )</span>
00075 <span class="preprocessor"></span>
<a name="l00076"></a><a class="code" href="../../d5/d5/cc_8h.html#a4">00076</a> <span class="preprocessor">#define CcAcquireVacbLock( OldIrql ) \</span>
00077 <span class="preprocessor">    ExAcquireSpinLock( &amp;CcVacbSpinLock, OldIrql )</span>
00078 <span class="preprocessor"></span>
<a name="l00079"></a><a class="code" href="../../d5/d5/cc_8h.html#a5">00079</a> <span class="preprocessor">#define CcReleaseVacbLock( OldIrql ) \</span>
00080 <span class="preprocessor">    ExReleaseSpinLock( &amp;CcVacbSpinLock, OldIrql )</span>
00081 <span class="preprocessor"></span>
<a name="l00082"></a><a class="code" href="../../d5/d5/cc_8h.html#a6">00082</a> <span class="preprocessor">#define CcAcquireVacbLockAtDpcLevel() \</span>
00083 <span class="preprocessor">    ExAcquireSpinLockAtDpcLevel( &amp;CcVacbSpinLock )</span>
00084 <span class="preprocessor"></span>
<a name="l00085"></a><a class="code" href="../../d5/d5/cc_8h.html#a7">00085</a> <span class="preprocessor">#define CcReleaseVacbLockFromDpcLevel() \</span>
00086 <span class="preprocessor">    ExReleaseSpinLockFromDpcLevel( &amp;CcVacbSpinLock )</span>
00087 <span class="preprocessor"></span>
00088 <span class="preprocessor">#endif</span>
00089 <span class="preprocessor"></span>
00090 <span class="comment">//</span>
00091 <span class="comment">//  This turns on the Bcb list debugging in a debug system.  Set value</span>
00092 <span class="comment">//  to 0 to turn off.</span>
00093 <span class="comment">//</span>
00094 <span class="comment">//  ****    Note it must currently be turned off because the routines in</span>
00095 <span class="comment">//          pinsup.c that manipulate this list need to be changed to do the</span>
00096 <span class="comment">//          right thing for Obcbs.  Right now they screw up by inserting Obcbs</span>
00097 <span class="comment">//          (which may not be large enough among other things) into the global</span>
00098 <span class="comment">//          list.  Ideally each place gets some code to insert the underlying</span>
00099 <span class="comment">//          Bcbs into the list if they are not already there.</span>
00100 <span class="comment">//</span>
00101 
00102 <span class="preprocessor">#if DBG</span>
00103 <span class="preprocessor"></span><span class="preprocessor">#define LIST_DBG 0</span>
00104 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00105 <span class="preprocessor"></span>
00106 <span class="preprocessor">#include &lt;FsRtl.h&gt;</span>
00107 <span class="preprocessor">#ifndef _USERKDX_  // Including stdlib.h build breaks ntos\w32\ntuser\kdexts\kd (!dso)</span>
00108 <span class="preprocessor"></span><span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00109 <span class="preprocessor">#endif</span>
00110 <span class="preprocessor"></span><span class="preprocessor">#include &lt;string.h&gt;</span>
00111 <span class="preprocessor">#include &lt;limits.h&gt;</span>
00112 
00113 <span class="comment">//</span>
00114 <span class="comment">//  Tag all of our allocations if tagging is turned on</span>
00115 <span class="comment">//</span>
00116 
00117 <span class="preprocessor">#undef FsRtlAllocatePool</span>
00118 <span class="preprocessor"></span><span class="preprocessor">#undef FsRtlAllocatePoolWithQuota</span>
00119 <span class="preprocessor"></span>
<a name="l00120"></a><a class="code" href="../../d5/d5/cc_8h.html#a8">00120</a> <span class="preprocessor">#define FsRtlAllocatePool(a,b) FsRtlAllocatePoolWithTag(a,b,'  cC')</span>
<a name="l00121"></a><a class="code" href="../../d5/d5/cc_8h.html#a9">00121</a> <span class="preprocessor"></span><span class="preprocessor">#define FsRtlAllocatePoolWithQuota(a,b) FsRtlAllocatePoolWithQuotaTag(a,b,'  cC')</span>
00122 <span class="preprocessor"></span>
00123 <span class="preprocessor">#undef ExAllocatePool</span>
00124 <span class="preprocessor"></span><span class="preprocessor">#undef ExAllocatePoolWithQuota</span>
00125 <span class="preprocessor"></span>
<a name="l00126"></a><a class="code" href="../../d5/d5/cc_8h.html#a10">00126</a> <span class="preprocessor">#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'  cC')</span>
<a name="l00127"></a><a class="code" href="../../d5/d5/cc_8h.html#a11">00127</a> <span class="preprocessor"></span><span class="preprocessor">#define ExAllocatePoolWithQuota(a,b) ExAllocatePoolWithQuotaTag(a,b,'  cC')</span>
00128 <span class="preprocessor"></span>
00129 
00130 <span class="comment">//</span>
00131 <span class="comment">//  Peek at number of available pages.</span>
00132 <span class="comment">//</span>
00133 
<a name="l00134"></a><a class="code" href="../../d5/d5/cc_8h.html#a94">00134</a> <span class="keyword">extern</span> PFN_COUNT <a class="code" href="../../d5/d5/cc_8h.html#a94">MmAvailablePages</a>;
00135 
00136 <span class="preprocessor">#if DBG</span>
00137 <span class="preprocessor"></span><span class="comment">//  #define MIPS_PREFILL 0</span>
00138 <span class="preprocessor">#endif</span>
00139 <span class="preprocessor"></span>
00140 <span class="preprocessor">#ifdef MIPS</span>
00141 <span class="preprocessor"></span><span class="preprocessor">#ifdef MIPS_PREFILL</span>
00142 <span class="preprocessor"></span><a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00143 <a class="code" href="../../d3/d5/ppc_2flush_8c.html#a6">KeSweepDcache</a> (
00144     IN BOOLEAN AllProcessors
00145         );
00146 <span class="preprocessor">#endif</span>
00147 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00148 <span class="preprocessor"></span>
00149 <span class="comment">//</span>
00150 <span class="comment">//  Define our node type codes.</span>
00151 <span class="comment">//</span>
00152 
<a name="l00153"></a><a class="code" href="../../d5/d5/cc_8h.html#a12">00153</a> <span class="preprocessor">#define CACHE_NTC_SHARED_CACHE_MAP       (0x2FF)</span>
<a name="l00154"></a><a class="code" href="../../d5/d5/cc_8h.html#a13">00154</a> <span class="preprocessor"></span><span class="preprocessor">#define CACHE_NTC_PRIVATE_CACHE_MAP      (0x2FE)</span>
<a name="l00155"></a><a class="code" href="../../d5/d5/cc_8h.html#a14">00155</a> <span class="preprocessor"></span><span class="preprocessor">#define CACHE_NTC_BCB                    (0x2FD)</span>
<a name="l00156"></a><a class="code" href="../../d5/d5/cc_8h.html#a15">00156</a> <span class="preprocessor"></span><span class="preprocessor">#define CACHE_NTC_DEFERRED_WRITE         (0x2FC)</span>
<a name="l00157"></a><a class="code" href="../../d5/d5/cc_8h.html#a16">00157</a> <span class="preprocessor"></span><span class="preprocessor">#define CACHE_NTC_MBCB                   (0x2FB)</span>
<a name="l00158"></a><a class="code" href="../../d5/d5/cc_8h.html#a17">00158</a> <span class="preprocessor"></span><span class="preprocessor">#define CACHE_NTC_OBCB                   (0x2FA)</span>
<a name="l00159"></a><a class="code" href="../../d5/d5/cc_8h.html#a18">00159</a> <span class="preprocessor"></span><span class="preprocessor">#define CACHE_NTC_MBCB_GRANDE            (0x2F9)</span>
00160 <span class="preprocessor"></span>
00161 <span class="comment">//</span>
00162 <span class="comment">//  The following definitions are used to generate meaningful blue bugcheck</span>
00163 <span class="comment">//  screens.  On a bugcheck the file system can output 4 ulongs of useful</span>
00164 <span class="comment">//  information.  The first ulong will have encoded in it a source file id</span>
00165 <span class="comment">//  (in the high word) and the line number of the bugcheck (in the low word).</span>
00166 <span class="comment">//  The other values can be whatever the caller of the bugcheck routine deems</span>
00167 <span class="comment">//  necessary.</span>
00168 <span class="comment">//</span>
00169 <span class="comment">//  Each individual file that calls bugcheck needs to have defined at the</span>
00170 <span class="comment">//  start of the file a constant called BugCheckFileId with one of the</span>
00171 <span class="comment">//  CACHE_BUG_CHECK_ values defined below and then use CcBugCheck to bugcheck</span>
00172 <span class="comment">//  the system.</span>
00173 <span class="comment">//</span>
00174 
<a name="l00175"></a><a class="code" href="../../d5/d5/cc_8h.html#a19">00175</a> <span class="preprocessor">#define CACHE_BUG_CHECK_CACHEDAT           (0x00010000)</span>
<a name="l00176"></a><a class="code" href="../../d5/d5/cc_8h.html#a20">00176</a> <span class="preprocessor"></span><span class="preprocessor">#define CACHE_BUG_CHECK_CACHESUB           (0x00020000)</span>
<a name="l00177"></a><a class="code" href="../../d5/d5/cc_8h.html#a21">00177</a> <span class="preprocessor"></span><span class="preprocessor">#define CACHE_BUG_CHECK_COPYSUP            (0x00030000)</span>
<a name="l00178"></a><a class="code" href="../../d5/d5/cc_8h.html#a22">00178</a> <span class="preprocessor"></span><span class="preprocessor">#define CACHE_BUG_CHECK_FSSUP              (0x00040000)</span>
<a name="l00179"></a><a class="code" href="../../d5/d5/cc_8h.html#a23">00179</a> <span class="preprocessor"></span><span class="preprocessor">#define CACHE_BUG_CHECK_LAZYRITE           (0x00050000)</span>
<a name="l00180"></a><a class="code" href="../../d5/d5/cc_8h.html#a24">00180</a> <span class="preprocessor"></span><span class="preprocessor">#define CACHE_BUG_CHECK_LOGSUP             (0x00060000)</span>
<a name="l00181"></a><a class="code" href="../../d5/d5/cc_8h.html#a25">00181</a> <span class="preprocessor"></span><span class="preprocessor">#define CACHE_BUG_CHECK_MDLSUP             (0x00070000)</span>
<a name="l00182"></a><a class="code" href="../../d5/d5/cc_8h.html#a26">00182</a> <span class="preprocessor"></span><span class="preprocessor">#define CACHE_BUG_CHECK_PINSUP             (0x00080000)</span>
<a name="l00183"></a><a class="code" href="../../d5/d5/cc_8h.html#a27">00183</a> <span class="preprocessor"></span><span class="preprocessor">#define CACHE_BUG_CHECK_VACBSUP            (0x00090000)</span>
00184 <span class="preprocessor"></span>
<a name="l00185"></a><a class="code" href="../../d5/d5/cc_8h.html#a28">00185</a> <span class="preprocessor">#define CcBugCheck(A,B,C) { KeBugCheckEx(CACHE_MANAGER, BugCheckFileId | __LINE__, A, B, C ); }</span>
00186 <span class="preprocessor"></span>
00187 <span class="comment">//</span>
00188 <span class="comment">//  Define maximum View Size (These constants are currently so chosen so</span>
00189 <span class="comment">//  as to be exactly a page worth of PTEs.</span>
00190 <span class="comment">//</span>
00191 
<a name="l00192"></a><a class="code" href="../../d5/d5/cc_8h.html#a29">00192</a> <span class="preprocessor">#define DEFAULT_CREATE_MODULO            ((ULONG)(0x00100000))</span>
<a name="l00193"></a><a class="code" href="../../d5/d5/cc_8h.html#a30">00193</a> <span class="preprocessor"></span><span class="preprocessor">#define DEFAULT_EXTEND_MODULO            ((ULONG)(0x00100000))</span>
00194 <span class="preprocessor"></span>
00195 <span class="comment">//</span>
00196 <span class="comment">//  For non FO_RANDOM_ACCESS files, define how far we go before umapping</span>
00197 <span class="comment">//  views.</span>
00198 <span class="comment">//</span>
00199 
<a name="l00200"></a><a class="code" href="../../d5/d5/cc_8h.html#a31">00200</a> <span class="preprocessor">#define SEQUENTIAL_MAP_LIMIT        ((ULONG)(0x00080000))</span>
00201 <span class="preprocessor"></span>
00202 <span class="comment">//</span>
00203 <span class="comment">//  Define some constants to drive read ahead and write behind</span>
00204 <span class="comment">//</span>
00205 
00206 <span class="comment">//</span>
00207 <span class="comment">//  Set max read ahead.  Even though some drivers, such as AT, break up transfers &gt;= 128kb,</span>
00208 <span class="comment">//  we need to permit enough readahead to satisfy plausible cached read operation while</span>
00209 <span class="comment">//  preventing denial of service attacks.</span>
00210 <span class="comment">//</span>
00211 <span class="comment">//  This value used to be set to 64k.  When doing cached reads in larger units (128k), we</span>
00212 <span class="comment">//  would never be bringing in enough data to keep the user from blocking. 8mb is</span>
00213 <span class="comment">//  arbitrarily chosen to be greater than plausible RAID bandwidth and user operation size</span>
00214 <span class="comment">//  by a factor of 3-4.</span>
00215 <span class="comment">//</span>
00216 
<a name="l00217"></a><a class="code" href="../../d5/d5/cc_8h.html#a32">00217</a> <span class="preprocessor">#define MAX_READ_AHEAD                   (8 * 1024 * 1024)</span>
00218 <span class="preprocessor"></span>
00219 <span class="comment">//</span>
00220 <span class="comment">//  Set maximum write behind / lazy write (most drivers break up transfers &gt;= 64kb)</span>
00221 <span class="comment">//</span>
00222 
<a name="l00223"></a><a class="code" href="../../d5/d5/cc_8h.html#a33">00223</a> <span class="preprocessor">#define MAX_WRITE_BEHIND                 (MM_MAXIMUM_DISK_IO_SIZE)</span>
00224 <span class="preprocessor"></span>
00225 <span class="comment">//</span>
00226 <span class="comment">//  Set a throttle for charging a given write against the total number of dirty</span>
00227 <span class="comment">//  pages in the system, for the purpose of seeing when we should invoke write</span>
00228 <span class="comment">//  throttling.</span>
00229 <span class="comment">//</span>
00230 <span class="comment">//  This must be the same as the throttle used for seeing when we must flush</span>
00231 <span class="comment">//  temporary files in the lazy writer.  On the back of the envelope, here</span>
00232 <span class="comment">//  is why:</span>
00233 <span class="comment">//</span>
00234 <span class="comment">//      RDP = Regular File Dirty Pages</span>
00235 <span class="comment">//      TDP = Temporary File Dirty Pages</span>
00236 <span class="comment">//      CWT = Charged Write Throttle</span>
00237 <span class="comment">//          -&gt; the maximum we will charge a user with when we see if</span>
00238 <span class="comment">//              he should be throttled</span>
00239 <span class="comment">//      TWT = Temporary Write Throttle</span>
00240 <span class="comment">//          -&gt; if we can't write this many pages, we must write temp data</span>
00241 <span class="comment">//      DPT = Dirty Page Threshold</span>
00242 <span class="comment">//          -&gt; the limit when write throttling kicks in</span>
00243 <span class="comment">//</span>
00244 <span class="comment">//      PTD = Pages To Dirty</span>
00245 <span class="comment">//      CDP = Charged Dirty Pages</span>
00246 <span class="comment">//</span>
00247 <span class="comment">//      Now, CDP = Min( PTD, CWT).</span>
00248 <span class="comment">//</span>
00249 <span class="comment">//      Excluding other effects, we throttle when:</span>
00250 <span class="comment">//          #0  (RDP + TDP) + CPD &gt;= DPT</span>
00251 <span class="comment">//</span>
00252 <span class="comment">//      To write temporary data, we must cause:</span>
00253 <span class="comment">//          #1  (RDP + TDP) + TWT &gt;= DPT</span>
00254 <span class="comment">//</span>
00255 <span class="comment">//      To release the throttle, we must eventually cause:</span>
00256 <span class="comment">//          #2  (RDP + TDP) + CDP &lt; DPT</span>
00257 <span class="comment">//</span>
00258 <span class="comment">//      Now, imagine TDP &gt;&gt; RDP (perhaps RDP == 0) and CDP == CWT for a particular</span>
00259 <span class="comment">//      throttled write.</span>
00260 <span class="comment">//</span>
00261 <span class="comment">//      If CWT &gt; TWT, as we drive RDP to zero (we never defer writing regular</span>
00262 <span class="comment">//      data except for hotspots or other very temporary conditions), it is clear</span>
00263 <span class="comment">//      that we may never trigger the writing of temporary data (#1) but also</span>
00264 <span class="comment">//      never release the throttle (#2).  Simply, we would be willing to charge</span>
00265 <span class="comment">//      for more dirty pages than we would be willing to guarantee are avaliable</span>
00266 <span class="comment">//      to dirty.  Hence, potential deadlock.</span>
00267 <span class="comment">//</span>
00268 <span class="comment">//      CWT &lt; TWT I leave aside for the moment.  This would mean we try not to</span>
00269 <span class="comment">//      allow temporary data to accumulate to the point that writes throttle as</span>
00270 <span class="comment">//      a result.  Perhaps this would even be better than CWT == TWT.</span>
00271 <span class="comment">//</span>
00272 <span class="comment">//  It is legitimate to ask if throttling temporary data writes should be relaxed</span>
00273 <span class="comment">//  if we see a large amount of dirty temp data accumulate (and it would be very</span>
00274 <span class="comment">//  easy to keep track of this).  I don't claim to know the best answer to this,</span>
00275 <span class="comment">//  but for now the attempt to avoid temporary data writes at all costs still</span>
00276 <span class="comment">//  fits the reasonable operation mix, and we will only penalize the outside</span>
00277 <span class="comment">//  oddcase with a little more throttle/release.</span>
00278 <span class="comment">//</span>
00279 
<a name="l00280"></a><a class="code" href="../../d5/d5/cc_8h.html#a34">00280</a> <span class="preprocessor">#define WRITE_CHARGE_THRESHOLD          (64 * PAGE_SIZE)</span>
00281 <span class="preprocessor"></span>
00282 <span class="comment">//</span>
00283 <span class="comment">//  Define constants to control zeroing of file data: one constant to control</span>
00284 <span class="comment">//  how much data we will actually zero ahead in the cache, and another to</span>
00285 <span class="comment">//  control what the maximum transfer size is that we will use to write zeros.</span>
00286 <span class="comment">//</span>
00287 
<a name="l00288"></a><a class="code" href="../../d5/d5/cc_8h.html#a35">00288</a> <span class="preprocessor">#define MAX_ZERO_TRANSFER               (PAGE_SIZE * 128)</span>
<a name="l00289"></a><a class="code" href="../../d5/d5/cc_8h.html#a36">00289</a> <span class="preprocessor"></span><span class="preprocessor">#define MIN_ZERO_TRANSFER               (0x10000)</span>
<a name="l00290"></a><a class="code" href="../../d5/d5/cc_8h.html#a37">00290</a> <span class="preprocessor"></span><span class="preprocessor">#define MAX_ZEROS_IN_CACHE              (0x10000)</span>
00291 <span class="preprocessor"></span>
00292 <span class="comment">//</span>
00293 <span class="comment">//  Definitions for multi-level Vacb structure.  The primary definition is the</span>
00294 <span class="comment">//  VACB_LEVEL_SHIFT.  In a multi-level Vacb structure, level in the tree of</span>
00295 <span class="comment">//  pointers has 2 ** VACB_LEVEL_SHIFT pointers.</span>
00296 <span class="comment">//</span>
00297 <span class="comment">//  For test, this value may be set as low as 4 (no lower), a value of 10 corresponds</span>
00298 <span class="comment">//  to a convenient block size of 4KB.  (If set to 2, CcExtendVacbArray will try to</span>
00299 <span class="comment">//  "push" the Vacb array allocated within the SharedCacheMap, and later someone will</span>
00300 <span class="comment">//  try to deallocate the middle of the SharedCacheMap.  At 3, the MBCB_BITMAP_BLOCK_SIZE</span>
00301 <span class="comment">//  is larger than MBCB_BITMAP_BLOCK_SIZE)</span>
00302 <span class="comment">//</span>
00303 <span class="comment">//  There is a bit of a trick as we make the jump to the multilevel structure in that</span>
00304 <span class="comment">//  we need a real fixed reference count.</span>
00305 <span class="comment">//</span>
00306 
<a name="l00307"></a><a class="code" href="../../d5/d5/cc_8h.html#a38">00307</a> <span class="preprocessor">#define VACB_LEVEL_SHIFT                  (7)</span>
00308 <span class="preprocessor"></span>
00309 <span class="comment">//</span>
00310 <span class="comment">//  This is how many bytes of pointers are at each level.  This is the size for both</span>
00311 <span class="comment">//  the Vacb array and (optional) Bcb listheads.  It does not include the reference</span>
00312 <span class="comment">//  block.</span>
00313 <span class="comment">//</span>
00314 
<a name="l00315"></a><a class="code" href="../../d5/d5/cc_8h.html#a39">00315</a> <span class="preprocessor">#define VACB_LEVEL_BLOCK_SIZE             ((1 &lt;&lt; VACB_LEVEL_SHIFT) * sizeof(PVOID))</span>
00316 <span class="preprocessor"></span>
00317 <span class="comment">//</span>
00318 <span class="comment">//  This is the last index for a level.</span>
00319 <span class="comment">//</span>
00320 
<a name="l00321"></a><a class="code" href="../../d5/d5/cc_8h.html#a40">00321</a> <span class="preprocessor">#define VACB_LAST_INDEX_FOR_LEVEL         ((1 &lt;&lt; VACB_LEVEL_SHIFT) - 1)</span>
00322 <span class="preprocessor"></span>
00323 <span class="comment">//</span>
00324 <span class="comment">//  This is the size of file which can be handled in a single level.</span>
00325 <span class="comment">//</span>
00326 
<a name="l00327"></a><a class="code" href="../../d5/d5/cc_8h.html#a41">00327</a> <span class="preprocessor">#define VACB_SIZE_OF_FIRST_LEVEL         (1 &lt;&lt; (VACB_OFFSET_SHIFT + VACB_LEVEL_SHIFT))</span>
00328 <span class="preprocessor"></span>
00329 <span class="comment">//</span>
00330 <span class="comment">//  This is the maximum number of levels it takes to support 63-bits.  It is</span>
00331 <span class="comment">//  used for routines that must remember a path.</span>
00332 <span class="comment">//</span>
00333 
<a name="l00334"></a><a class="code" href="../../d5/d5/cc_8h.html#a42">00334</a> <span class="preprocessor">#define VACB_NUMBER_OF_LEVELS            (((63 - VACB_OFFSET_SHIFT)/VACB_LEVEL_SHIFT) + 1)</span>
00335 <span class="preprocessor"></span>
00336 <span class="comment">//</span>
00337 <span class="comment">//  Define the reference structure for multilevel Vacb trees.</span>
00338 <span class="comment">//</span>
00339 
<a name="l00340"></a><a class="code" href="../../d4/d5/struct__VACB__LEVEL__REFERENCE.html">00340</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d4/d5/struct__VACB__LEVEL__REFERENCE.html">_VACB_LEVEL_REFERENCE</a> {
00341 
<a name="l00342"></a><a class="code" href="../../d4/d5/struct__VACB__LEVEL__REFERENCE.html#o0">00342</a>     LONG <a class="code" href="../../d4/d5/struct__VACB__LEVEL__REFERENCE.html#o0">Reference</a>;
<a name="l00343"></a><a class="code" href="../../d4/d5/struct__VACB__LEVEL__REFERENCE.html#o1">00343</a>     LONG <a class="code" href="../../d4/d5/struct__VACB__LEVEL__REFERENCE.html#o1">SpecialReference</a>;
00344 
00345 } <a class="code" href="../../d4/d5/struct__VACB__LEVEL__REFERENCE.html">VACB_LEVEL_REFERENCE</a>, *<a class="code" href="../../d4/d5/struct__VACB__LEVEL__REFERENCE.html">PVACB_LEVEL_REFERENCE</a>;
00346 
00347 <span class="comment">//</span>
00348 <span class="comment">//  Define the size of a bitmap allocated for a bitmap range, in bytes.</span>
00349 <span class="comment">//</span>
00350 
<a name="l00351"></a><a class="code" href="../../d5/d5/cc_8h.html#a43">00351</a> <span class="preprocessor">#define MBCB_BITMAP_BLOCK_SIZE           (VACB_LEVEL_BLOCK_SIZE)</span>
00352 <span class="preprocessor"></span>
00353 <span class="comment">//</span>
00354 <span class="comment">//  Define how many bytes of a file are covered by an Mbcb bitmap range,</span>
00355 <span class="comment">//  at a bit for each page.</span>
00356 <span class="comment">//</span>
00357 
<a name="l00358"></a><a class="code" href="../../d5/d5/cc_8h.html#a44">00358</a> <span class="preprocessor">#define MBCB_BITMAP_RANGE                (MBCB_BITMAP_BLOCK_SIZE * 8 * PAGE_SIZE)</span>
00359 <span class="preprocessor"></span>
00360 <span class="comment">//</span>
00361 <span class="comment">//  Define the initial size of the Mbcb bitmap that is self-contained in the Mbcb.</span>
00362 <span class="comment">//</span>
00363 
<a name="l00364"></a><a class="code" href="../../d5/d5/cc_8h.html#a45">00364</a> <span class="preprocessor">#define MBCB_BITMAP_INITIAL_SIZE         (2 * sizeof(BITMAP_RANGE))</span>
00365 <span class="preprocessor"></span>
00366 <span class="comment">//</span>
00367 <span class="comment">//  Define constants controlling when the Bcb list is broken into a</span>
00368 <span class="comment">//  pendaflex-style array of listheads, and how the correct listhead</span>
00369 <span class="comment">//  is found.  Begin when file size exceeds 2MB, and cover 512KB per</span>
00370 <span class="comment">//  listhead.  At 512KB per listhead, the BcbListArray is the same</span>
00371 <span class="comment">//  size as the Vacb array, i.e., it doubles the size.</span>
00372 <span class="comment">//</span>
00373 <span class="comment">//  The code handling these Bcb lists in the Vacb package contains</span>
00374 <span class="comment">//  assumptions that the size is the same as that of the Vacb pointers.</span>
00375 <span class="comment">//  Future work could undo this, but until then the size and shift</span>
00376 <span class="comment">//  below cannot change.  There really isn't a good reason to want to</span>
00377 <span class="comment">//  anyway.</span>
00378 <span class="comment">//</span>
00379 <span class="comment">//  Note that by definition a flat vacb array cannot fail to find an</span>
00380 <span class="comment">//  exact match when searching for the listhead - this is only a</span>
00381 <span class="comment">//  complication of the sparse structure.</span>
00382 <span class="comment">//</span>
00383 
00384 
<a name="l00385"></a><a class="code" href="../../d5/d5/cc_8h.html#a46">00385</a> <span class="preprocessor">#define BEGIN_BCB_LIST_ARRAY             (0x200000)</span>
<a name="l00386"></a><a class="code" href="../../d5/d5/cc_8h.html#a47">00386</a> <span class="preprocessor"></span><span class="preprocessor">#define SIZE_PER_BCB_LIST                (VACB_MAPPING_GRANULARITY * 2)</span>
<a name="l00387"></a><a class="code" href="../../d5/d5/cc_8h.html#a48">00387</a> <span class="preprocessor"></span><span class="preprocessor">#define BCB_LIST_SHIFT                   (VACB_OFFSET_SHIFT + 1)</span>
00388 <span class="preprocessor"></span>
<a name="l00389"></a><a class="code" href="../../d5/d5/cc_8h.html#a49">00389</a> <span class="preprocessor">#define GetBcbListHead(SCM,OFF,FAILSUCC) (                                                         \</span>
00390 <span class="preprocessor">  (((SCM)-&gt;SectionSize.QuadPart &gt; BEGIN_BCB_LIST_ARRAY) &amp;&amp;                                         \</span>
00391 <span class="preprocessor">   FlagOn((SCM)-&gt;Flags, MODIFIED_WRITE_DISABLED)) ?                                                \</span>
00392 <span class="preprocessor">   (((SCM)-&gt;SectionSize.QuadPart &gt; VACB_SIZE_OF_FIRST_LEVEL) ?                                     \</span>
00393 <span class="preprocessor">    CcGetBcbListHeadLargeOffset((SCM),(OFF),(FAILSUCC)) :                                          \</span>
00394 <span class="preprocessor">    (((OFF) &gt;= (SCM)-&gt;SectionSize.QuadPart) ? &amp;(SCM)-&gt;BcbList :                                    \</span>
00395 <span class="preprocessor">     ((PLIST_ENTRY)((SCM)-&gt;Vacbs) + (((SCM)-&gt;SectionSize.QuadPart + (OFF)) &gt;&gt; BCB_LIST_SHIFT)))) : \</span>
00396 <span class="preprocessor">   &amp;(SCM)-&gt;BcbList                                                                                 \</span>
00397 <span class="preprocessor">)</span>
00398 <span class="preprocessor"></span>
00399 <span class="comment">//</span>
00400 <span class="comment">//  Macros to lock/unlock a Vacb level as Bcbs are inserted/deleted</span>
00401 <span class="comment">//</span>
00402 
<a name="l00403"></a><a class="code" href="../../d5/d5/cc_8h.html#a50">00403</a> <span class="preprocessor">#define CcLockVacbLevel(SCM,OFF) {                                                               \</span>
00404 <span class="preprocessor">    if (((SCM)-&gt;SectionSize.QuadPart &gt; VACB_SIZE_OF_FIRST_LEVEL) &amp;&amp;                              \</span>
00405 <span class="preprocessor">        FlagOn(SharedCacheMap-&gt;Flags, MODIFIED_WRITE_DISABLED)) {                                \</span>
00406 <span class="preprocessor">    CcAdjustVacbLevelLockCount((SCM),(OFF), +1);}                                                \</span>
00407 <span class="preprocessor">}</span>
00408 <span class="preprocessor"></span>
<a name="l00409"></a><a class="code" href="../../d5/d5/cc_8h.html#a51">00409</a> <span class="preprocessor">#define CcUnlockVacbLevel(SCM,OFF) {                                                             \</span>
00410 <span class="preprocessor">    if (((SCM)-&gt;SectionSize.QuadPart &gt; VACB_SIZE_OF_FIRST_LEVEL) &amp;&amp;                              \</span>
00411 <span class="preprocessor">        FlagOn(SharedCacheMap-&gt;Flags, MODIFIED_WRITE_DISABLED)) {                                \</span>
00412 <span class="preprocessor">    CcAdjustVacbLevelLockCount((SCM),(OFF), -1);}                                                \</span>
00413 <span class="preprocessor">}</span>
00414 <span class="preprocessor"></span>
00415 <span class="comment">//</span>
00416 <span class="comment">//  NOISE_BITS defines how many bits are masked off when testing for</span>
00417 <span class="comment">//  sequential reads.  This allows the reader to skip up to 7 bytes</span>
00418 <span class="comment">//  for alignment purposes, and we still consider the next read to be</span>
00419 <span class="comment">//  sequential.  Starting and ending addresses are masked by this pattern</span>
00420 <span class="comment">//  before comparison.</span>
00421 <span class="comment">//</span>
00422 
<a name="l00423"></a><a class="code" href="../../d5/d5/cc_8h.html#a52">00423</a> <span class="preprocessor">#define NOISE_BITS                       (0x7)</span>
00424 <span class="preprocessor"></span>
00425 <span class="comment">//</span>
00426 <span class="comment">//  Define some constants to drive the Lazy Writer</span>
00427 <span class="comment">//</span>
00428 
<a name="l00429"></a><a class="code" href="../../d5/d5/cc_8h.html#a53">00429</a> <span class="preprocessor">#define LAZY_WRITER_IDLE_DELAY           ((LONG)(10000000))</span>
<a name="l00430"></a><a class="code" href="../../d5/d5/cc_8h.html#a54">00430</a> <span class="preprocessor"></span><span class="preprocessor">#define LAZY_WRITER_COLLISION_DELAY      ((LONG)(1000000))</span>
00431 <span class="preprocessor"></span>
00432 <span class="comment">//</span>
00433 <span class="comment">//  The following target should best be a power of 2</span>
00434 <span class="comment">//</span>
00435 
<a name="l00436"></a><a class="code" href="../../d5/d5/cc_8h.html#a55">00436</a> <span class="preprocessor">#define LAZY_WRITER_MAX_AGE_TARGET       ((ULONG)(8))</span>
00437 <span class="preprocessor"></span>
00438 <span class="comment">//</span>
00439 <span class="comment">//  Requeue information hint for the lazy writer.</span>
00440 <span class="comment">//</span>
00441 
<a name="l00442"></a><a class="code" href="../../d5/d5/cc_8h.html#a56">00442</a> <span class="preprocessor">#define CC_REQUEUE                       35422</span>
00443 <span class="preprocessor"></span>
00444 <span class="comment">//</span>
00445 <span class="comment">//  The global Cache Manager debug level variable, its values are:</span>
00446 <span class="comment">//</span>
00447 <span class="comment">//      0x00000000      Always gets printed (used when about to bug check)</span>
00448 <span class="comment">//</span>
00449 <span class="comment">//      0x00000001      FsSup</span>
00450 <span class="comment">//      0x00000002      CacheSub</span>
00451 <span class="comment">//      0x00000004      CopySup</span>
00452 <span class="comment">//      0x00000008      PinSup</span>
00453 <span class="comment">//</span>
00454 <span class="comment">//      0x00000010      MdlSup</span>
00455 <span class="comment">//      0x00000020      LazyRite</span>
00456 <span class="comment">//      0x00000040</span>
00457 <span class="comment">//      0x00000080</span>
00458 <span class="comment">//</span>
00459 <span class="comment">//      0x00000100      Trace all Mm calls</span>
00460 <span class="comment">//</span>
00461 
<a name="l00462"></a><a class="code" href="../../d5/d5/cc_8h.html#a57">00462</a> <span class="preprocessor">#define mm (0x100)</span>
00463 <span class="preprocessor"></span>
00464 <span class="comment">//</span>
00465 <span class="comment">//  Miscellaneous support macros.</span>
00466 <span class="comment">//</span>
00467 <span class="comment">//      ULONG</span>
00468 <span class="comment">//      FlagOn (</span>
00469 <span class="comment">//          IN ULONG Flags,</span>
00470 <span class="comment">//          IN ULONG SingleFlag</span>
00471 <span class="comment">//          );</span>
00472 <span class="comment">//</span>
00473 <span class="comment">//      BOOLEAN</span>
00474 <span class="comment">//      BooleanFlagOn (</span>
00475 <span class="comment">//          IN ULONG Flags,</span>
00476 <span class="comment">//          IN ULONG SingleFlag</span>
00477 <span class="comment">//          );</span>
00478 <span class="comment">//</span>
00479 <span class="comment">//      VOID</span>
00480 <span class="comment">//      SetFlag (</span>
00481 <span class="comment">//          IN ULONG Flags,</span>
00482 <span class="comment">//          IN ULONG SingleFlag</span>
00483 <span class="comment">//          );</span>
00484 <span class="comment">//</span>
00485 <span class="comment">//      VOID</span>
00486 <span class="comment">//      ClearFlag (</span>
00487 <span class="comment">//          IN ULONG Flags,</span>
00488 <span class="comment">//          IN ULONG SingleFlag</span>
00489 <span class="comment">//          );</span>
00490 <span class="comment">//</span>
00491 <span class="comment">//      ULONG</span>
00492 <span class="comment">//      QuadAlign (</span>
00493 <span class="comment">//          IN ULONG Pointer</span>
00494 <span class="comment">//          );</span>
00495 <span class="comment">//</span>
00496 
<a name="l00497"></a><a class="code" href="../../d5/d5/cc_8h.html#a58">00497</a> <span class="preprocessor">#define FlagOn(F,SF) ( \</span>
00498 <span class="preprocessor">    (((F) &amp; (SF)))     \</span>
00499 <span class="preprocessor">)</span>
00500 <span class="preprocessor"></span>
<a name="l00501"></a><a class="code" href="../../d5/d5/cc_8h.html#a59">00501</a> <span class="preprocessor">#define BooleanFlagOn(F,SF) (    \</span>
00502 <span class="preprocessor">    (BOOLEAN)(((F) &amp; (SF)) != 0) \</span>
00503 <span class="preprocessor">)</span>
00504 <span class="preprocessor"></span>
<a name="l00505"></a><a class="code" href="../../d5/d5/cc_8h.html#a60">00505</a> <span class="preprocessor">#define SetFlag(F,SF) { \</span>
00506 <span class="preprocessor">    (F) |= (SF);        \</span>
00507 <span class="preprocessor">}</span>
00508 <span class="preprocessor"></span>
<a name="l00509"></a><a class="code" href="../../d5/d5/cc_8h.html#a61">00509</a> <span class="preprocessor">#define ClearFlag(F,SF) { \</span>
00510 <span class="preprocessor">    (F) &amp;= ~(SF);         \</span>
00511 <span class="preprocessor">}</span>
00512 <span class="preprocessor"></span>
<a name="l00513"></a><a class="code" href="../../d5/d5/cc_8h.html#a62">00513</a> <span class="preprocessor">#define QuadAlign(P) (             \</span>
00514 <span class="preprocessor">    ((((P)) + 7) &amp; (-8)) \</span>
00515 <span class="preprocessor">)</span>
00516 <span class="preprocessor"></span>
00517 <span class="comment">//</span>
00518 <span class="comment">//  Turn on pseudo-asserts if CC_FREE_ASSERTS is defined.</span>
00519 <span class="comment">//</span>
00520 
00521 <span class="preprocessor">#if (!DBG &amp;&amp; defined( CC_FREE_ASSERTS ))</span>
00522 <span class="preprocessor"></span><span class="preprocessor">#undef ASSERT</span>
00523 <span class="preprocessor"></span><span class="preprocessor">#undef ASSERTMSG</span>
00524 <span class="preprocessor"></span><span class="preprocessor">#define ASSERT(exp)                                             \</span>
00525 <span class="preprocessor">    ((exp) ? TRUE :                                             \</span>
00526 <span class="preprocessor">             (DbgPrint( "%s:%d %s\n",__FILE__,__LINE__,#exp ),  \</span>
00527 <span class="preprocessor">              DbgBreakPoint(),                                  \</span>
00528 <span class="preprocessor">              TRUE))</span>
00529 <span class="preprocessor"></span><span class="preprocessor">#define ASSERTMSG(msg,exp)                                              \</span>
00530 <span class="preprocessor">    ((exp) ? TRUE :                                                     \</span>
00531 <span class="preprocessor">             (DbgPrint( "%s:%d %s %s\n",__FILE__,__LINE__,msg,#exp ),   \</span>
00532 <span class="preprocessor">              DbgBreakPoint(),                                          \</span>
00533 <span class="preprocessor">              TRUE))</span>
00534 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00535 <span class="preprocessor"></span>
00536 
00537 <span class="preprocessor">#if DANLO</span>
00538 <span class="preprocessor"></span><span class="keyword">typedef</span> <span class="keyword">struct </span>_CC_LOG_ENTRY {
00539     ULONG <a class="code" href="../../d7/d0/cmdat2_8c.html#a18">Action</a>;
00540     ULONG Reason;
00541 } CC_LOG_ENTRY;
00542 
00543 <span class="keyword">typedef</span> <span class="keyword">struct </span>_CC_LOG {
00544     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> Current;
00545     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
00546     CC_LOG_ENTRY Log[48];
00547 } CC_LOG;
00548 
00549 <span class="preprocessor">#define CcAddToLog( LOG, ACTION, REASON ) {         \</span>
00550 <span class="preprocessor">    (LOG)-&gt;Current += 1;                            \</span>
00551 <span class="preprocessor">    if ((LOG)-&gt;Current == (LOG)-&gt;Size) {            \</span>
00552 <span class="preprocessor">        (LOG)-&gt;Current = 0;                         \</span>
00553 <span class="preprocessor">    }                                               \</span>
00554 <span class="preprocessor">    (LOG)-&gt;Log[(LOG)-&gt;Current].Action = (ACTION);   \</span>
00555 <span class="preprocessor">    (LOG)-&gt;Log[(LOG)-&gt;Current].Reason = (REASON);   \</span>
00556 <span class="preprocessor">}</span>
00557 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00558"></a><a class="code" href="../../d5/d5/cc_8h.html#a63">00558</a> <span class="preprocessor"></span><span class="preprocessor">#define CcAddToLog( LOG, ACTION, REASON )</span>
00559 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00560 <span class="preprocessor"></span>
00561 
00562 <span class="comment">//</span>
00563 <span class="comment">//  Define the Virtual Address Control Block, which controls all mapping</span>
00564 <span class="comment">//  performed by the Cache Manager.</span>
00565 <span class="comment">//</span>
00566 
00567 <span class="comment">//</span>
00568 <span class="comment">//  First some constants</span>
00569 <span class="comment">//</span>
00570 
<a name="l00571"></a><a class="code" href="../../d5/d5/cc_8h.html#a64">00571</a> <span class="preprocessor">#define PREALLOCATED_VACBS               (4)</span>
00572 <span class="preprocessor"></span>
00573 <span class="comment">//</span>
00574 <span class="comment">//  Virtual Address Control Block</span>
00575 <span class="comment">//</span>
00576 
<a name="l00577"></a><a class="code" href="../../d2/d5/struct__VACB.html">00577</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d2/d5/struct__VACB.html">_VACB</a> {
00578 
00579     <span class="comment">//</span>
00580     <span class="comment">//  Base Address for this control block.</span>
00581     <span class="comment">//</span>
00582 
<a name="l00583"></a><a class="code" href="../../d2/d5/struct__VACB.html#o0">00583</a>     PVOID <a class="code" href="../../d2/d5/struct__VACB.html#o0">BaseAddress</a>;
00584 
00585     <span class="comment">//</span>
00586     <span class="comment">//  Pointer to the Shared Cache Map using this Vacb.</span>
00587     <span class="comment">//</span>
00588 
<a name="l00589"></a><a class="code" href="../../d2/d5/struct__VACB.html#o1">00589</a>     <span class="keyword">struct </span><a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">_SHARED_CACHE_MAP</a> *<a class="code" href="../../d2/d5/struct__VACB.html#o1">SharedCacheMap</a>;
00590 
00591     <span class="comment">//</span>
00592     <span class="comment">//  Overlay for remembering mapped offset within the Shared Cache Map,</span>
00593     <span class="comment">//  and the count of the number of times this Vacb is in use.</span>
00594     <span class="comment">//</span>
00595 
00596     <span class="keyword">union </span>{
00597 
00598         <span class="comment">//</span>
00599         <span class="comment">//  File Offset within Shared Cache Map</span>
00600         <span class="comment">//</span>
00601 
<a name="l00602"></a><a class="code" href="../../d2/d5/struct__VACB.html#o2">00602</a>         LARGE_INTEGER FileOffset;
00603 
00604         <span class="comment">//</span>
00605         <span class="comment">//  Count of number of times this Vacb is in use.  The size of this</span>
00606         <span class="comment">//  count is calculated to be adequate, while never large enough to</span>
00607         <span class="comment">//  overwrite nonzero bits of the FileOffset, which is a multiple</span>
00608         <span class="comment">//  of VACB_MAPPING_GRANULARITY.</span>
00609         <span class="comment">//</span>
00610 
<a name="l00611"></a><a class="code" href="../../d2/d5/struct__VACB.html#o3">00611</a>         <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> ActiveCount;
00612 
00613     } Overlay;
00614 
00615     <span class="comment">//</span>
00616     <span class="comment">//  Entry for the VACB reuse list</span>
00617     <span class="comment">//</span>
00618 
<a name="l00619"></a><a class="code" href="../../d2/d5/struct__VACB.html#o5">00619</a>     LIST_ENTRY <a class="code" href="../../d2/d5/struct__VACB.html#o5">LruList</a>;
00620 
00621 } <a class="code" href="../../d2/d5/struct__VACB.html">VACB</a>, *<a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a>;
00622 
00623 <span class="comment">//</span>
00624 <span class="comment">//  These define special flag values that are overloaded as PVACB.  They cause</span>
00625 <span class="comment">//  certain special behavior, currently only in the case of multilevel structures.</span>
00626 <span class="comment">//</span>
00627 
<a name="l00628"></a><a class="code" href="../../d5/d5/cc_8h.html#a65">00628</a> <span class="preprocessor">#define VACB_SPECIAL_REFERENCE           ((PVACB) ~0)</span>
<a name="l00629"></a><a class="code" href="../../d5/d5/cc_8h.html#a66">00629</a> <span class="preprocessor"></span><span class="preprocessor">#define VACB_SPECIAL_DEREFERENCE         ((PVACB) ~1)</span>
00630 <span class="preprocessor"></span>
<a name="l00631"></a><a class="code" href="../../d5/d5/cc_8h.html#a67">00631</a> <span class="preprocessor">#define VACB_SPECIAL_FIRST_VALID         VACB_SPECIAL_DEREFERENCE</span>
00632 <span class="preprocessor"></span>
00633 
00634 <span class="comment">//</span>
00635 <span class="comment">//  The Private Cache Map is a structure pointed to by the File Object, whenever</span>
00636 <span class="comment">//  a file is opened with caching enabled (default).</span>
00637 <span class="comment">//</span>
00638 
<a name="l00639"></a><a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html">00639</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html">_PRIVATE_CACHE_MAP</a> {
00640 
00641     <span class="comment">//</span>
00642     <span class="comment">//  Type and size of this record</span>
00643     <span class="comment">//</span>
00644 
<a name="l00645"></a><a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o0">00645</a>     CSHORT <a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o0">NodeTypeCode</a>;
<a name="l00646"></a><a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o1">00646</a>     CSHORT <a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o1">NodeByteSize</a>;
00647 
00648     <span class="comment">//</span>
00649     <span class="comment">//  Pointer to FileObject for this PrivateCacheMap.</span>
00650     <span class="comment">//</span>
00651 
<a name="l00652"></a><a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o2">00652</a>     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> <a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o2">FileObject</a>;
00653 
00654     <span class="comment">//</span>
00655     <span class="comment">//  READ AHEAD CONTROL</span>
00656     <span class="comment">//</span>
00657     <span class="comment">//  Read ahead history for determining when read ahead might be</span>
00658     <span class="comment">//  beneficial.</span>
00659     <span class="comment">//</span>
00660 
<a name="l00661"></a><a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o3">00661</a>     LARGE_INTEGER <a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o3">FileOffset1</a>;
<a name="l00662"></a><a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o4">00662</a>     LARGE_INTEGER <a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o4">BeyondLastByte1</a>;
00663 
<a name="l00664"></a><a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o5">00664</a>     LARGE_INTEGER <a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o5">FileOffset2</a>;
<a name="l00665"></a><a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o6">00665</a>     LARGE_INTEGER <a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o6">BeyondLastByte2</a>;
00666 
00667     <span class="comment">//</span>
00668     <span class="comment">//  Current read ahead requirements.</span>
00669     <span class="comment">//</span>
00670     <span class="comment">//  Array element 0 is optionally used for recording remaining bytes</span>
00671     <span class="comment">//  required for satisfying a large Mdl read.</span>
00672     <span class="comment">//</span>
00673     <span class="comment">//  Array element 1 is used for predicted read ahead.</span>
00674     <span class="comment">//</span>
00675 
<a name="l00676"></a><a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o7">00676</a>     LARGE_INTEGER <a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o7">ReadAheadOffset</a>[2];
<a name="l00677"></a><a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o8">00677</a>     ULONG <a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o8">ReadAheadLength</a>[2];
00678 
00679     <span class="comment">//</span>
00680     <span class="comment">//  SpinLock controlling access to following fields</span>
00681     <span class="comment">//</span>
00682 
<a name="l00683"></a><a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o9">00683</a>     KSPIN_LOCK <a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o9">ReadAheadSpinLock</a>;
00684 
00685     <span class="comment">//</span>
00686     <span class="comment">//  Read Ahead mask formed from Read Ahead granularity - 1</span>
00687     <span class="comment">//</span>
00688 
<a name="l00689"></a><a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o10">00689</a>     ULONG <a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o10">ReadAheadMask</a>;
00690 
00691     <span class="comment">//</span>
00692     <span class="comment">// Links for list of all PrivateCacheMaps linked to the same</span>
00693     <span class="comment">// SharedCacheMap.</span>
00694     <span class="comment">//</span>
00695 
<a name="l00696"></a><a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o11">00696</a>     LIST_ENTRY <a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o11">PrivateLinks</a>;
00697 
00698     <span class="comment">//</span>
00699     <span class="comment">//  This flag says read ahead is currently active, which means either</span>
00700     <span class="comment">//  a file system call to CcReadAhead is still determining if the</span>
00701     <span class="comment">//  desired data is already resident, or else a request to do read ahead</span>
00702     <span class="comment">//  has been queued to a worker thread.</span>
00703     <span class="comment">//</span>
00704 
<a name="l00705"></a><a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o12">00705</a>     BOOLEAN <a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o12">ReadAheadActive</a>;
00706 
00707     <span class="comment">//</span>
00708     <span class="comment">//  Flag to say whether read ahead is currently enabled for this</span>
00709     <span class="comment">//  FileObject/PrivateCacheMap.  On read misses it is enabled on</span>
00710     <span class="comment">//  read ahead hits it will be disabled.  Initially disabled.</span>
00711     <span class="comment">//</span>
00712 
<a name="l00713"></a><a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o13">00713</a>     BOOLEAN <a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o13">ReadAheadEnabled</a>;
00714 
00715 } <a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html">PRIVATE_CACHE_MAP</a>;
00716 
<a name="l00717"></a><a class="code" href="../../d5/d5/cc_8h.html#a100">00717</a> <span class="keyword">typedef</span> <a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html">PRIVATE_CACHE_MAP</a> *<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html">PPRIVATE_CACHE_MAP</a>;
00718 
00719 
00720 <span class="comment">//</span>
00721 <span class="comment">//  The Shared Cache Map is a per-file structure pointed to indirectly by</span>
00722 <span class="comment">//  each File Object.  The File Object points to a pointer in a single</span>
00723 <span class="comment">//  FS-private structure for the file (Fcb).  The SharedCacheMap maps the</span>
00724 <span class="comment">//  first part of the file for common access by all callers.</span>
00725 <span class="comment">//</span>
00726 
<a name="l00727"></a><a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">00727</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">_SHARED_CACHE_MAP</a> {
00728 
00729     <span class="comment">//</span>
00730     <span class="comment">//  Type and size of this record</span>
00731     <span class="comment">//</span>
00732 
<a name="l00733"></a><a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o0">00733</a>     CSHORT <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o0">NodeTypeCode</a>;
<a name="l00734"></a><a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o1">00734</a>     CSHORT <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o1">NodeByteSize</a>;
00735 
00736     <span class="comment">//</span>
00737     <span class="comment">//  Number of times this file has been opened cached.</span>
00738     <span class="comment">//</span>
00739 
<a name="l00740"></a><a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o2">00740</a>     ULONG <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o2">OpenCount</a>;
00741 
00742     <span class="comment">//</span>
00743     <span class="comment">//  Actual size of file, primarily for restricting Read Ahead.  Initialized</span>
00744     <span class="comment">//  on creation and maintained by extend and truncate operations.</span>
00745     <span class="comment">//</span>
00746     <span class="comment">//  NOTE:   This field may never be moved, thanks to the late DavidGoe,</span>
00747     <span class="comment">//          who should have written this comment himself :-(   cache.h</span>
00748     <span class="comment">//          exports a macro which "knows" that FileSize is the second</span>
00749     <span class="comment">//          longword in the Cache Map!</span>
00750     <span class="comment">//</span>
00751 
<a name="l00752"></a><a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o3">00752</a>     LARGE_INTEGER <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o3">FileSize</a>;
00753 
00754     <span class="comment">//</span>
00755     <span class="comment">//  Bcb Listhead.  The BcbList is ordered by descending</span>
00756     <span class="comment">//  FileOffsets, to optimize misses in the sequential I/O case.</span>
00757     <span class="comment">//  Synchronized by the BcbSpinLock.</span>
00758     <span class="comment">//</span>
00759 
<a name="l00760"></a><a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o4">00760</a>     LIST_ENTRY <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o4">BcbList</a>;
00761 
00762     <span class="comment">//</span>
00763     <span class="comment">//  Size of section created.</span>
00764     <span class="comment">//</span>
00765 
<a name="l00766"></a><a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o5">00766</a>     LARGE_INTEGER <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o5">SectionSize</a>;
00767 
00768     <span class="comment">//</span>
00769     <span class="comment">//  ValidDataLength for file, as currently stored by the file system.</span>
00770     <span class="comment">//  Synchronized by the BcbSpinLock or exclusive access by FileSystem.</span>
00771     <span class="comment">//</span>
00772 
<a name="l00773"></a><a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o6">00773</a>     LARGE_INTEGER <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o6">ValidDataLength</a>;
00774 
00775     <span class="comment">//</span>
00776     <span class="comment">//  Goal for ValidDataLength, when current dirty data is written.</span>
00777     <span class="comment">//  Synchronized by the BcbSpinLock or exclusive access by FileSystem.</span>
00778     <span class="comment">//</span>
00779 
<a name="l00780"></a><a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o7">00780</a>     LARGE_INTEGER <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o7">ValidDataGoal</a>;
00781 
00782     <span class="comment">//</span>
00783     <span class="comment">//  Pointer to a contiguous array of Vacb pointers which control mapping</span>
00784     <span class="comment">//  to this file, along with Vacbs (currently) for a 1MB file.</span>
00785     <span class="comment">//  Synchronized by CcVacbSpinLock.</span>
00786     <span class="comment">//</span>
00787 
<a name="l00788"></a><a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o8">00788</a>     <a class="code" href="../../d5/d5/cc_8h.html#a98">PVACB</a> <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o8">InitialVacbs</a>[<a class="code" href="../../d5/d5/cc_8h.html#a64">PREALLOCATED_VACBS</a>];
<a name="l00789"></a><a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o9">00789</a>     <a class="code" href="../../d5/d5/cc_8h.html#a98">PVACB</a> * <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o9">Vacbs</a>;
00790 
00791     <span class="comment">//</span>
00792     <span class="comment">//  Referenced pointer to original File Object on which the SharedCacheMap</span>
00793     <span class="comment">//  was created.</span>
00794     <span class="comment">//</span>
00795 
<a name="l00796"></a><a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o10">00796</a>     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o10">FileObject</a>;
00797 
00798     <span class="comment">//</span>
00799     <span class="comment">//  Describe Active Vacb and Page for copysup optimizations.</span>
00800     <span class="comment">//</span>
00801 
<a name="l00802"></a><a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o11">00802</a>     <span class="keyword">volatile</span> <a class="code" href="../../d5/d5/cc_8h.html#a98">PVACB</a> <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o11">ActiveVacb</a>;
<a name="l00803"></a><a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o12">00803</a>     ULONG <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o12">ActivePage</a>;
00804 
00805     <span class="comment">//</span>
00806     <span class="comment">//  Virtual address needing zero to end of page</span>
00807     <span class="comment">//</span>
00808 
<a name="l00809"></a><a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o13">00809</a>     <span class="keyword">volatile</span> PVOID <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o13">NeedToZero</a>;
<a name="l00810"></a><a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o14">00810</a>     ULONG <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o14">NeedToZeroPage</a>;
00811 
00812     <span class="comment">//</span>
00813     <span class="comment">//  Fields for synchronizing on active requests.</span>
00814     <span class="comment">//</span>
00815 
<a name="l00816"></a><a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o15">00816</a>     KSPIN_LOCK <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o15">ActiveVacbSpinLock</a>;
<a name="l00817"></a><a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o16">00817</a>     ULONG <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o16">VacbActiveCount</a>;
00818 
00819     <span class="comment">//</span>
00820     <span class="comment">//  THE NEXT TWO FIELDS MUST BE ADJACENT, TO SUPPORT</span>
00821     <span class="comment">//  SHARED_CACHE_MAP_LIST_CURSOR!</span>
00822     <span class="comment">//</span>
00823     <span class="comment">//  Links for Global SharedCacheMap List</span>
00824     <span class="comment">//</span>
00825 
<a name="l00826"></a><a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">00826</a>     LIST_ENTRY <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a>;
00827 
00828     <span class="comment">//</span>
00829     <span class="comment">//  Shared Cache Map flags (defined below)</span>
00830     <span class="comment">//</span>
00831 
<a name="l00832"></a><a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">00832</a>     ULONG <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>;
00833 
00834     <span class="comment">//</span>
00835     <span class="comment">//  Mask Bcb for this SharedCacheMap, if there is one.</span>
00836     <span class="comment">//  Synchronized by the BcbSpinLock.</span>
00837     <span class="comment">//</span>
00838 
<a name="l00839"></a><a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o19">00839</a>     <span class="keyword">struct </span><a class="code" href="../../d9/d6/struct__MBCB.html">_MBCB</a> *<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o19">Mbcb</a>;
00840 
00841     <span class="comment">//</span>
00842     <span class="comment">//  Number of dirty pages in this SharedCacheMap.  Used to trigger</span>
00843     <span class="comment">//  write behind.  Synchronized by CcMasterSpinLock.</span>
00844     <span class="comment">//</span>
00845 
<a name="l00846"></a><a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o20">00846</a>     ULONG <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o20">DirtyPages</a>;
00847 
00848     <span class="comment">//</span>
00849     <span class="comment">//  Pointer to the common Section Object used by the file system.</span>
00850     <span class="comment">//</span>
00851 
<a name="l00852"></a><a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o21">00852</a>     PVOID <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o21">Section</a>;
00853 
00854     <span class="comment">//</span>
00855     <span class="comment">//  Status variable set by creator of SharedCacheMap</span>
00856     <span class="comment">//</span>
00857 
<a name="l00858"></a><a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o22">00858</a>     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o22">Status</a>;
00859 
00860     <span class="comment">//</span>
00861     <span class="comment">//  This event pointer is used to handle creation collisions.</span>
00862     <span class="comment">//  If a second thread tries to call CcInitializeCacheMap for the</span>
00863     <span class="comment">//  same file, while BeingCreated (below) is TRUE, then that thread</span>
00864     <span class="comment">//  will allocate an event store it here (if not already allocated),</span>
00865     <span class="comment">//  and wait on it.  The first creator will set this event when it</span>
00866     <span class="comment">//  is done.  The event is not deleted until CcUninitializedCacheMap</span>
00867     <span class="comment">//  is called, to avoid possible race conditions.  (Note that normally</span>
00868     <span class="comment">//  the event never has to be allocated.</span>
00869     <span class="comment">//</span>
00870 
<a name="l00871"></a><a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o23">00871</a>     <a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a> <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o23">CreateEvent</a>;
00872 
00873     <span class="comment">//</span>
00874     <span class="comment">//  This points to an event used to wait for active count to go to zero</span>
00875     <span class="comment">//</span>
00876 
<a name="l00877"></a><a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o24">00877</a>     <a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a> <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o24">WaitOnActiveCount</a>;
00878 
00879     <span class="comment">//</span>
00880     <span class="comment">//  These two fields control the writing of large metadata</span>
00881     <span class="comment">//  streams.  The first field gives a target for the current</span>
00882     <span class="comment">//  flush interval, and the second field stores the end of</span>
00883     <span class="comment">//  the last flush that occurred on this file.</span>
00884     <span class="comment">//</span>
00885 
<a name="l00886"></a><a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o25">00886</a>     ULONG <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o25">PagesToWrite</a>;
<a name="l00887"></a><a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o26">00887</a>     LONGLONG <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o26">BeyondLastFlush</a>;
00888 
00889 <span class="preprocessor">#if 0</span>
00890 <span class="preprocessor"></span>    <span class="comment">//</span>
00891     <span class="comment">//  This records where the last view miss occured in the file.</span>
00892     <span class="comment">//</span>
00893 
00894     LARGE_INTEGER LastViewMiss;
00895 <span class="preprocessor">#endif</span>
00896 <span class="preprocessor"></span>    
00897     <span class="comment">//</span>
00898     <span class="comment">//  Pointer to structure of routines used by the Lazy Writer to Acquire</span>
00899     <span class="comment">//  and Release the file for Lazy Write and Close, to avoid deadlocks,</span>
00900     <span class="comment">//  and the context to call them with.</span>
00901     <span class="comment">//</span>
00902 
<a name="l00903"></a><a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o27">00903</a>     <a class="code" href="../../d3/d6/struct__CACHE__MANAGER__CALLBACKS.html">PCACHE_MANAGER_CALLBACKS</a> <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o27">Callbacks</a>;
00904 
<a name="l00905"></a><a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o28">00905</a>     PVOID <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o28">LazyWriteContext</a>;
00906 
00907     <span class="comment">//</span>
00908     <span class="comment">//  Listhead of all PrivateCacheMaps linked to this SharedCacheMap.</span>
00909     <span class="comment">//</span>
00910 
<a name="l00911"></a><a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o29">00911</a>     LIST_ENTRY <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o29">PrivateList</a>;
00912 
00913     <span class="comment">//</span>
00914     <span class="comment">//  Log handle specified for this shared cache map, for support of routines</span>
00915     <span class="comment">//  in logsup.c</span>
00916     <span class="comment">//</span>
00917 
<a name="l00918"></a><a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o30">00918</a>     PVOID <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o30">LogHandle</a>;
00919 
00920     <span class="comment">//</span>
00921     <span class="comment">//  Callback routine specified for flushing to Lsn.</span>
00922     <span class="comment">//</span>
00923 
<a name="l00924"></a><a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o31">00924</a>     <a class="code" href="../../d4/d2/cache_8h.html#a23">PFLUSH_TO_LSN</a> <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o31">FlushToLsnRoutine</a>;
00925 
00926     <span class="comment">//</span>
00927     <span class="comment">//  Dirty Page Threshold for this stream</span>
00928     <span class="comment">//</span>
00929 
<a name="l00930"></a><a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o32">00930</a>     ULONG <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o32">DirtyPageThreshold</a>;
00931 
00932     <span class="comment">//</span>
00933     <span class="comment">//  Lazy Writer pass count.  Used by the Lazy Writer for</span>
00934     <span class="comment">//  no modified write streams, which are not serviced on</span>
00935     <span class="comment">//  every pass in order to avoid contention with foreground</span>
00936     <span class="comment">//  activity.</span>
00937     <span class="comment">//</span>
00938 
<a name="l00939"></a><a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o33">00939</a>     ULONG <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o33">LazyWritePassCount</a>;
00940 
00941     <span class="comment">//</span>
00942     <span class="comment">//  This event pointer is used to allow a file system to be notified when</span>
00943     <span class="comment">//  the deletion of a shared cache map.</span>
00944     <span class="comment">//</span>
00945     <span class="comment">//  This has to be provided here because the cache manager may decide to</span>
00946     <span class="comment">//  "Lazy Delete" the shared cache map, and some network file systems</span>
00947     <span class="comment">//  will want to know when the lazy delete completes.</span>
00948     <span class="comment">//</span>
00949 
<a name="l00950"></a><a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o34">00950</a>     <a class="code" href="../../d4/d6/struct__CACHE__UNINITIALIZE__EVENT.html">PCACHE_UNINITIALIZE_EVENT</a> <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o34">UninitializeEvent</a>;
00951 
00952     <span class="comment">//</span>
00953     <span class="comment">//  This Vacb pointer is needed for keeping the NeedToZero virtual address</span>
00954     <span class="comment">//  valid.</span>
00955     <span class="comment">//</span>
00956 
<a name="l00957"></a><a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o35">00957</a>     <a class="code" href="../../d5/d5/cc_8h.html#a98">PVACB</a> <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o35">NeedToZeroVacb</a>;
00958 
00959     <span class="comment">//</span>
00960     <span class="comment">//  Spinlock for synchronizing the Mbcb and Bcb lists - must be acquired</span>
00961     <span class="comment">//  before CcMasterSpinLock.  This spinlock also synchronizes ValidDataGoal</span>
00962     <span class="comment">//  and ValidDataLength, as described above.</span>
00963     <span class="comment">//</span>
00964 
<a name="l00965"></a><a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o36">00965</a>     KSPIN_LOCK <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o36">BcbSpinLock</a>;
00966 
00967     <span class="comment">//</span>
00968     <span class="comment">//  This is a scratch event which can be used either for</span>
00969     <span class="comment">//  a CreateEvent or a WaitOnActiveCount event.  It is</span>
00970     <span class="comment">//  difficult to share this event, because of the very</span>
00971     <span class="comment">//  careful semantics by which they are cleared.  On the</span>
00972     <span class="comment">//  other hand, both events are relatively rarely used</span>
00973     <span class="comment">//  (especially the CreateEvent), so it will be rare that</span>
00974     <span class="comment">//  we will actually use both for the same file, and have</span>
00975     <span class="comment">//  to allocate one.</span>
00976     <span class="comment">//</span>
00977 
<a name="l00978"></a><a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o37">00978</a>     <a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a> <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o37">LocalEvent</a>;
<a name="l00979"></a><a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o38">00979</a>     <a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a> <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o38">Event</a>;
00980 
00981     <span class="comment">//</span>
00982     <span class="comment">//  Preallocate on PrivateCacheMap to reduce pool allocations.</span>
00983     <span class="comment">//</span>
00984 
<a name="l00985"></a><a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o39">00985</a>     <a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html">PRIVATE_CACHE_MAP</a> <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o39">PrivateCacheMap</a>;
00986 
00987 <span class="preprocessor">#if DANLO</span>
00988 <span class="preprocessor"></span>    <span class="comment">//</span>
00989     <span class="comment">//  Instrument reasons for OpenCount</span>
00990     <span class="comment">//</span>
00991 
00992     CC_LOG OpenCountLog;
00993 <span class="preprocessor">#endif</span>
00994 <span class="preprocessor"></span>
00995 } <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">SHARED_CACHE_MAP</a>;
00996 
<a name="l00997"></a><a class="code" href="../../d5/d5/cc_8h.html#a102">00997</a> <span class="keyword">typedef</span> <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">SHARED_CACHE_MAP</a> *<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a>;
00998 
00999 <span class="comment">//</span>
01000 <span class="comment">//  OpenCount log Reasons/Actions</span>
01001 <span class="comment">//</span>
01002 
<a name="l01003"></a><a class="code" href="../../d5/d5/cc_8h.html#a68">01003</a> <span class="preprocessor">#define CcIncrementOpenCount( SCM, REASON ) {           \</span>
01004 <span class="preprocessor">    (SCM)-&gt;OpenCount += 1;                              \</span>
01005 <span class="preprocessor">    if (REASON != 0) {                                  \</span>
01006 <span class="preprocessor">        CcAddToLog( &amp;(SCM)-&gt;OpenCountLog, REASON, 1 );  \</span>
01007 <span class="preprocessor">    }                                                   \</span>
01008 <span class="preprocessor">}</span>
01009 <span class="preprocessor"></span>
<a name="l01010"></a><a class="code" href="../../d5/d5/cc_8h.html#a69">01010</a> <span class="preprocessor">#define CcDecrementOpenCount( SCM, REASON ) {           \</span>
01011 <span class="preprocessor">    (SCM)-&gt;OpenCount -= 1;                              \</span>
01012 <span class="preprocessor">    if (REASON != 0) {                                  \</span>
01013 <span class="preprocessor">        CcAddToLog( &amp;(SCM)-&gt;OpenCountLog, REASON, -1 ); \</span>
01014 <span class="preprocessor">    }                                                   \</span>
01015 <span class="preprocessor">}</span>
01016 <span class="preprocessor"></span>
01017 <span class="comment">//</span>
01018 <span class="comment">//  Shared Cache Map Flags</span>
01019 <span class="comment">//</span>
01020 
01021 <span class="comment">//</span>
01022 <span class="comment">//  Read ahead has been disabled on this file.</span>
01023 <span class="comment">//</span>
01024 
<a name="l01025"></a><a class="code" href="../../d5/d5/cc_8h.html#a70">01025</a> <span class="preprocessor">#define DISABLE_READ_AHEAD               0x0001</span>
01026 <span class="preprocessor"></span>
01027 <span class="comment">//</span>
01028 <span class="comment">//  Write behind has been disabled on this file.</span>
01029 <span class="comment">//</span>
01030 
<a name="l01031"></a><a class="code" href="../../d5/d5/cc_8h.html#a71">01031</a> <span class="preprocessor">#define DISABLE_WRITE_BEHIND             0x0002</span>
01032 <span class="preprocessor"></span>
01033 <span class="comment">//</span>
01034 <span class="comment">//  This flag indicates whether CcInitializeCacheMap was called with</span>
01035 <span class="comment">//  PinAccess = TRUE.</span>
01036 <span class="comment">//</span>
01037 
<a name="l01038"></a><a class="code" href="../../d5/d5/cc_8h.html#a72">01038</a> <span class="preprocessor">#define PIN_ACCESS                       0x0004</span>
01039 <span class="preprocessor"></span>
01040 <span class="comment">//</span>
01041 <span class="comment">//  This flag indicates that a truncate is required when OpenCount</span>
01042 <span class="comment">//  goes to 0.</span>
01043 <span class="comment">//</span>
01044 
<a name="l01045"></a><a class="code" href="../../d5/d5/cc_8h.html#a73">01045</a> <span class="preprocessor">#define TRUNCATE_REQUIRED                0x0010</span>
01046 <span class="preprocessor"></span>
01047 <span class="comment">//</span>
01048 <span class="comment">//  This flag indicates that a LazyWrite request is queued.</span>
01049 <span class="comment">//</span>
01050 
<a name="l01051"></a><a class="code" href="../../d5/d5/cc_8h.html#a74">01051</a> <span class="preprocessor">#define WRITE_QUEUED                     0x0020</span>
01052 <span class="preprocessor"></span>
01053 <span class="comment">//</span>
01054 <span class="comment">//  This flag indicates that we have never seen anyone cache</span>
01055 <span class="comment">//  the file except for with FO_SEQUENTIAL_ONLY, so we should</span>
01056 <span class="comment">//  tell MM to quickly dump pages when we unmap.</span>
01057 <span class="comment">//</span>
01058 
<a name="l01059"></a><a class="code" href="../../d5/d5/cc_8h.html#a75">01059</a> <span class="preprocessor">#define ONLY_SEQUENTIAL_ONLY_SEEN        0x0040</span>
01060 <span class="preprocessor"></span>
01061 <span class="comment">//</span>
01062 <span class="comment">//  Active Page is locked</span>
01063 <span class="comment">//</span>
01064 
<a name="l01065"></a><a class="code" href="../../d5/d5/cc_8h.html#a76">01065</a> <span class="preprocessor">#define ACTIVE_PAGE_IS_DIRTY             0x0080</span>
01066 <span class="preprocessor"></span>
01067 <span class="comment">//</span>
01068 <span class="comment">//  Flag to say that a create is in progress.</span>
01069 <span class="comment">//</span>
01070 
<a name="l01071"></a><a class="code" href="../../d5/d5/cc_8h.html#a77">01071</a> <span class="preprocessor">#define BEING_CREATED                    0x0100</span>
01072 <span class="preprocessor"></span>
01073 <span class="comment">//</span>
01074 <span class="comment">//  Flag to say that modified write was disabled on the section.</span>
01075 <span class="comment">//</span>
01076 
<a name="l01077"></a><a class="code" href="../../d5/d5/cc_8h.html#a78">01077</a> <span class="preprocessor">#define MODIFIED_WRITE_DISABLED          0x0200</span>
01078 <span class="preprocessor"></span>
01079 <span class="comment">//</span>
01080 <span class="comment">//  Flag that indicates if a lazy write ever occurred on this file.</span>
01081 <span class="comment">//</span>
01082 
<a name="l01083"></a><a class="code" href="../../d5/d5/cc_8h.html#a79">01083</a> <span class="preprocessor">#define LAZY_WRITE_OCCURRED              0x0400</span>
01084 <span class="preprocessor"></span>
01085 <span class="comment">//</span>
01086 <span class="comment">//  Flag that indicates this structure is only a cursor, only the</span>
01087 <span class="comment">//  SharedCacheMapLinks and Flags are valid!</span>
01088 <span class="comment">//</span>
01089 
<a name="l01090"></a><a class="code" href="../../d5/d5/cc_8h.html#a80">01090</a> <span class="preprocessor">#define IS_CURSOR                        0x0800</span>
01091 <span class="preprocessor"></span>
01092 <span class="comment">//</span>
01093 <span class="comment">//  Flag that indicates that we have seen someone cache this file</span>
01094 <span class="comment">//  and specify FO_RANDOM_ACCESS.  This will deactivate our cache</span>
01095 <span class="comment">//  working set trim assist.</span>
01096 <span class="comment">//</span>
01097 
<a name="l01098"></a><a class="code" href="../../d5/d5/cc_8h.html#a81">01098</a> <span class="preprocessor">#define RANDOM_ACCESS_SEEN               0x1000</span>
01099 <span class="preprocessor"></span>
01100 <span class="comment">//</span>
01101 <span class="comment">//  Cursor structure for traversing the SharedCacheMap lists.  Anyone</span>
01102 <span class="comment">//  scanning these lists must verify that the IS_CURSOR flag is clear</span>
01103 <span class="comment">//  before looking at other SharedCacheMap fields.</span>
01104 <span class="comment">//</span>
01105 
01106 
<a name="l01107"></a><a class="code" href="../../d1/d3/struct__SHARED__CACHE__MAP__LIST__CURSOR.html">01107</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d1/d3/struct__SHARED__CACHE__MAP__LIST__CURSOR.html">_SHARED_CACHE_MAP_LIST_CURSOR</a> {
01108 
01109     <span class="comment">//</span>
01110     <span class="comment">//  Links for Global SharedCacheMap List</span>
01111     <span class="comment">//</span>
01112 
<a name="l01113"></a><a class="code" href="../../d1/d3/struct__SHARED__CACHE__MAP__LIST__CURSOR.html#o0">01113</a>     LIST_ENTRY <a class="code" href="../../d1/d3/struct__SHARED__CACHE__MAP__LIST__CURSOR.html#o0">SharedCacheMapLinks</a>;
01114 
01115     <span class="comment">//</span>
01116     <span class="comment">//  Shared Cache Map flags, IS_CURSOR must be set.</span>
01117     <span class="comment">//</span>
01118 
<a name="l01119"></a><a class="code" href="../../d1/d3/struct__SHARED__CACHE__MAP__LIST__CURSOR.html#o1">01119</a>     ULONG <a class="code" href="../../d1/d3/struct__SHARED__CACHE__MAP__LIST__CURSOR.html#o1">Flags</a>;
01120 
01121 } <a class="code" href="../../d1/d3/struct__SHARED__CACHE__MAP__LIST__CURSOR.html">SHARED_CACHE_MAP_LIST_CURSOR</a>, *<a class="code" href="../../d1/d3/struct__SHARED__CACHE__MAP__LIST__CURSOR.html">PSHARED_CACHE_MAP_LIST_CURSOR</a>;
01122 
01123 
01124 
01125 <span class="preprocessor">#ifndef KDEXT</span>
01126 <span class="preprocessor"></span><span class="comment">//</span>
01127 <span class="comment">//  Bitmap Range structure.  For small files there is just one embedded in the</span>
01128 <span class="comment">//  Mbcb.  For large files there may be many of these linked to the Mbcb.</span>
01129 <span class="comment">//</span>
01130 
<a name="l01131"></a><a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html">01131</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html">_BITMAP_RANGE</a> {
01132 
01133     <span class="comment">//</span>
01134     <span class="comment">//  Links for the list of bitmap ranges off the Mbcb.</span>
01135     <span class="comment">//</span>
01136 
<a name="l01137"></a><a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o0">01137</a>     LIST_ENTRY <a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o0">Links</a>;
01138 
01139     <span class="comment">//</span>
01140     <span class="comment">//  Base page (FileOffset / PAGE_SIZE) represented by this range.</span>
01141     <span class="comment">//  (Size is a fixed maximum.)</span>
01142     <span class="comment">//</span>
01143 
<a name="l01144"></a><a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o1">01144</a>     LONGLONG <a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o1">BasePage</a>;
01145 
01146     <span class="comment">//</span>
01147     <span class="comment">//  First and Last dirty pages relative to the BasePage.</span>
01148     <span class="comment">//</span>
01149 
<a name="l01150"></a><a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o2">01150</a>     ULONG <a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o2">FirstDirtyPage</a>;
<a name="l01151"></a><a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o3">01151</a>     ULONG <a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o3">LastDirtyPage</a>;
01152 
01153     <span class="comment">//</span>
01154     <span class="comment">//  Number of dirty pages in this range.</span>
01155     <span class="comment">//</span>
01156 
<a name="l01157"></a><a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o4">01157</a>     ULONG <a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o4">DirtyPages</a>;
01158 
01159     <span class="comment">//</span>
01160     <span class="comment">//  Pointer to the bitmap for this range.</span>
01161     <span class="comment">//</span>
01162 
<a name="l01163"></a><a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o5">01163</a>     PULONG <a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o5">Bitmap</a>;
01164 
01165 } <a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html">BITMAP_RANGE</a>, *<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html">PBITMAP_RANGE</a>;
01166 <span class="preprocessor">#endif</span>
01167 <span class="preprocessor"></span>
01168 <span class="comment">//</span>
01169 <span class="comment">//  This structure is a "mask" Bcb.  For fast simple write operations,</span>
01170 <span class="comment">//  a mask Bcb is used so that we basically only have to set bits to remember</span>
01171 <span class="comment">//  where the dirty data is.</span>
01172 <span class="comment">//</span>
01173 
<a name="l01174"></a><a class="code" href="../../d9/d6/struct__MBCB.html">01174</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d9/d6/struct__MBCB.html">_MBCB</a> {
01175 
01176     <span class="comment">//</span>
01177     <span class="comment">//  Type and size of this record</span>
01178     <span class="comment">//</span>
01179 
<a name="l01180"></a><a class="code" href="../../d9/d6/struct__MBCB.html#o0">01180</a>     CSHORT <a class="code" href="../../d9/d6/struct__MBCB.html#o0">NodeTypeCode</a>;
<a name="l01181"></a><a class="code" href="../../d9/d6/struct__MBCB.html#o1">01181</a>     CSHORT <a class="code" href="../../d9/d6/struct__MBCB.html#o1">NodeIsInZone</a>;
01182 
01183     <span class="comment">//</span>
01184     <span class="comment">//  This field is used as a scratch area for the Lazy Writer to</span>
01185     <span class="comment">//  guide how much he will write each time he wakes up.</span>
01186     <span class="comment">//</span>
01187 
<a name="l01188"></a><a class="code" href="../../d9/d6/struct__MBCB.html#o2">01188</a>     ULONG <a class="code" href="../../d9/d6/struct__MBCB.html#o2">PagesToWrite</a>;
01189 
01190     <span class="comment">//</span>
01191     <span class="comment">//  Number of dirty pages (set bits) in the bitmap below.</span>
01192     <span class="comment">//</span>
01193 
<a name="l01194"></a><a class="code" href="../../d9/d6/struct__MBCB.html#o3">01194</a>     ULONG <a class="code" href="../../d9/d6/struct__MBCB.html#o3">DirtyPages</a>;
01195 
01196     <span class="comment">//</span>
01197     <span class="comment">//  Reserved for alignment.</span>
01198     <span class="comment">//</span>
01199 
<a name="l01200"></a><a class="code" href="../../d9/d6/struct__MBCB.html#o4">01200</a>     ULONG <a class="code" href="../../d9/d6/struct__MBCB.html#o4">Reserved</a>;
01201 
01202     <span class="comment">//</span>
01203     <span class="comment">//  ListHead of Bitmap ranges.</span>
01204     <span class="comment">//</span>
01205 
<a name="l01206"></a><a class="code" href="../../d9/d6/struct__MBCB.html#o5">01206</a>     LIST_ENTRY <a class="code" href="../../d9/d6/struct__MBCB.html#o5">BitmapRanges</a>;
01207 
01208     <span class="comment">//</span>
01209     <span class="comment">//  This is a hint on where to resume writing, since we will not</span>
01210     <span class="comment">//  always write all of the dirty data at once.</span>
01211     <span class="comment">//</span>
01212 
<a name="l01213"></a><a class="code" href="../../d9/d6/struct__MBCB.html#o6">01213</a>     LONGLONG <a class="code" href="../../d9/d6/struct__MBCB.html#o6">ResumeWritePage</a>;
01214 
01215     <span class="comment">//</span>
01216     <span class="comment">//  Initial three embedded Bitmap ranges.  For a file up to 2MB, only the</span>
01217     <span class="comment">//  first range is used, and the rest of the Mbcb contains bits for 2MB of</span>
01218     <span class="comment">//  dirty pages (4MB on Alpha).  For larger files, all three ranges may</span>
01219     <span class="comment">//  be used to describe external bitmaps.</span>
01220     <span class="comment">//</span>
01221 
<a name="l01222"></a><a class="code" href="../../d9/d6/struct__MBCB.html#o7">01222</a>     <a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html">BITMAP_RANGE</a> <a class="code" href="../../d9/d6/struct__MBCB.html#o7">BitmapRange1</a>;
<a name="l01223"></a><a class="code" href="../../d9/d6/struct__MBCB.html#o8">01223</a>     <a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html">BITMAP_RANGE</a> <a class="code" href="../../d9/d6/struct__MBCB.html#o8">BitmapRange2</a>;
<a name="l01224"></a><a class="code" href="../../d9/d6/struct__MBCB.html#o9">01224</a>     <a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html">BITMAP_RANGE</a> <a class="code" href="../../d9/d6/struct__MBCB.html#o9">BitmapRange3</a>;
01225 
01226 } <a class="code" href="../../d9/d6/struct__MBCB.html">MBCB</a>;
01227 
<a name="l01228"></a><a class="code" href="../../d5/d5/cc_8h.html#a108">01228</a> <span class="keyword">typedef</span> <a class="code" href="../../d9/d6/struct__MBCB.html">MBCB</a> *<a class="code" href="../../d9/d6/struct__MBCB.html">PMBCB</a>;
01229 
01230 
01231 <span class="comment">//</span>
01232 <span class="comment">//  This is the Buffer Control Block structure for representing data which</span>
01233 <span class="comment">//  is "pinned" in memory by one or more active requests and/or dirty.  This</span>
01234 <span class="comment">//  structure is created the first time that a call to CcPinFileData specifies</span>
01235 <span class="comment">//  a particular integral range of pages.  It is deallocated whenever the Pin</span>
01236 <span class="comment">//  Count reaches 0 and the Bcb is not Dirty.</span>
01237 <span class="comment">//</span>
01238 <span class="comment">//  NOTE: The first four fields must be the same as the PUBLIC_BCB.</span>
01239 <span class="comment">//</span>
01240 
<a name="l01241"></a><a class="code" href="../../d4/d3/struct__BCB.html">01241</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d4/d3/struct__BCB.html">_BCB</a> {
01242 
01243     <span class="comment">//</span>
01244     <span class="comment">//  Type and size of this record</span>
01245     <span class="comment">//</span>
01246 
<a name="l01247"></a><a class="code" href="../../d4/d3/struct__BCB.html#o0">01247</a>     CSHORT <a class="code" href="../../d4/d3/struct__BCB.html#o0">NodeTypeCode</a>;
<a name="l01248"></a><a class="code" href="../../d4/d3/struct__BCB.html#o1">01248</a>     CSHORT <a class="code" href="../../d4/d3/struct__BCB.html#o1">NodeIsInZone</a>;
01249 
01250     <span class="comment">//</span>
01251     <span class="comment">//  Byte FileOffset and and length of entire buffer</span>
01252     <span class="comment">//</span>
01253 
<a name="l01254"></a><a class="code" href="../../d4/d3/struct__BCB.html#o2">01254</a>     ULONG  <a class="code" href="../../d4/d3/struct__BCB.html#o2">ByteLength</a>;
<a name="l01255"></a><a class="code" href="../../d4/d3/struct__BCB.html#o3">01255</a>     LARGE_INTEGER <a class="code" href="../../d4/d3/struct__BCB.html#o3">FileOffset</a>;
01256 
01257     <span class="comment">//</span>
01258     <span class="comment">//  Links for BcbList in SharedCacheMap</span>
01259     <span class="comment">//</span>
01260 
<a name="l01261"></a><a class="code" href="../../d4/d3/struct__BCB.html#o4">01261</a>     LIST_ENTRY <a class="code" href="../../d4/d3/struct__BCB.html#o4">BcbLinks</a>;
01262 
01263     <span class="comment">//</span>
01264     <span class="comment">//  Byte FileOffset of last byte in buffer (used for searching)</span>
01265     <span class="comment">//</span>
01266 
<a name="l01267"></a><a class="code" href="../../d4/d3/struct__BCB.html#o5">01267</a>     LARGE_INTEGER <a class="code" href="../../d4/d3/struct__BCB.html#o5">BeyondLastByte</a>;
01268 
01269     <span class="comment">//</span>
01270     <span class="comment">//  Oldest Lsn (if specified) when this buffer was set dirty.</span>
01271     <span class="comment">//</span>
01272 
<a name="l01273"></a><a class="code" href="../../d4/d3/struct__BCB.html#o6">01273</a>     LARGE_INTEGER <a class="code" href="../../d4/d3/struct__BCB.html#o6">OldestLsn</a>;
01274 
01275     <span class="comment">//</span>
01276     <span class="comment">//  Most recent Lsn specified when this buffer was set dirty.</span>
01277     <span class="comment">//  The FlushToLsnRoutine is called with this Lsn.</span>
01278     <span class="comment">//</span>
01279 
<a name="l01280"></a><a class="code" href="../../d4/d3/struct__BCB.html#o7">01280</a>     LARGE_INTEGER <a class="code" href="../../d4/d3/struct__BCB.html#o7">NewestLsn</a>;
01281 
01282     <span class="comment">//</span>
01283     <span class="comment">//  Pointer to Vacb via which this Bcb is mapped.</span>
01284     <span class="comment">//</span>
01285 
<a name="l01286"></a><a class="code" href="../../d4/d3/struct__BCB.html#o8">01286</a>     <a class="code" href="../../d5/d5/cc_8h.html#a98">PVACB</a> <a class="code" href="../../d4/d3/struct__BCB.html#o8">Vacb</a>;
01287 
01288     <span class="comment">//</span>
01289     <span class="comment">//  Links and caller addresses for the global Bcb list (for debug only)</span>
01290     <span class="comment">//</span>
01291 
01292 <span class="preprocessor">#if LIST_DBG</span>
01293 <span class="preprocessor"></span>    LIST_ENTRY CcBcbLinks;
01294     PVOID CallerAddress;
01295     PVOID CallersCallerAddress;
01296 <span class="preprocessor">#endif</span>
01297 <span class="preprocessor"></span>
01298     <span class="comment">//</span>
01299     <span class="comment">//  Count of threads actively using this Bcb to process a request.</span>
01300     <span class="comment">//  This must be manipulated under protection of the BcbListSpinLock</span>
01301     <span class="comment">//  in the SharedCacheMap.</span>
01302     <span class="comment">//</span>
01303 
<a name="l01304"></a><a class="code" href="../../d4/d3/struct__BCB.html#o9">01304</a>     ULONG <a class="code" href="../../d4/d3/struct__BCB.html#o9">PinCount</a>;
01305 
01306     <span class="comment">//</span>
01307     <span class="comment">//  Resource to synchronize buffer access.  Pinning Readers and all Writers</span>
01308     <span class="comment">//  of the described buffer take out shared access (synchronization of</span>
01309     <span class="comment">//  buffer modifications is strictly up to the caller).  Note that pinning</span>
01310     <span class="comment">//  readers do not declare if they are going to modify the buffer or not.</span>
01311     <span class="comment">//  Anyone writing to disk takes out exclusive access, to prevent the buffer</span>
01312     <span class="comment">//  from changing while it is being written out.</span>
01313     <span class="comment">//</span>
01314 
<a name="l01315"></a><a class="code" href="../../d4/d3/struct__BCB.html#o10">01315</a>     <a class="code" href="../../d6/d4/struct__ERESOURCE.html">ERESOURCE</a> <a class="code" href="../../d4/d3/struct__BCB.html#o10">Resource</a>;
01316 
01317     <span class="comment">//</span>
01318     <span class="comment">//  Pointer to SharedCacheMap for this Bcb.</span>
01319     <span class="comment">//</span>
01320 
<a name="l01321"></a><a class="code" href="../../d4/d3/struct__BCB.html#o11">01321</a>     <a class="code" href="../../d5/d5/cc_8h.html#a102">PSHARED_CACHE_MAP</a> <a class="code" href="../../d4/d3/struct__BCB.html#o11">SharedCacheMap</a>;
01322 
01323     <span class="comment">//</span>
01324     <span class="comment">//  This is the Base Address at which the buffer can be seen in</span>
01325     <span class="comment">//  system space.  All access to buffer data should go through this</span>
01326     <span class="comment">//  address.</span>
01327     <span class="comment">//</span>
01328 
<a name="l01329"></a><a class="code" href="../../d4/d3/struct__BCB.html#o12">01329</a>     PVOID <a class="code" href="../../d4/d3/struct__BCB.html#o12">BaseAddress</a>;
01330 
01331     <span class="comment">//</span>
01332     <span class="comment">//  Flags</span>
01333     <span class="comment">//</span>
01334 
<a name="l01335"></a><a class="code" href="../../d4/d3/struct__BCB.html#o13">01335</a>     BOOLEAN <a class="code" href="../../d4/d3/struct__BCB.html#o13">Dirty</a>;
01336 
01337 } <a class="code" href="../../d4/d3/struct__BCB.html">BCB</a>;
01338 
01339 <span class="preprocessor">#ifndef KDEXT</span>
<a name="l01340"></a><a class="code" href="../../d5/d5/cc_8h.html#a110">01340</a> <span class="preprocessor"></span><span class="keyword">typedef</span> <a class="code" href="../../d4/d3/struct__BCB.html">BCB</a> *<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>;
01341 <span class="preprocessor">#endif</span>
01342 <span class="preprocessor"></span>
01343 <span class="comment">//</span>
01344 <span class="comment">//  This is the Overlap Buffer Control Block structure for representing data which</span>
01345 <span class="comment">//  is "pinned" in memory and must be represented by multiple Bcbs due to overlaps.</span>
01346 <span class="comment">//</span>
01347 <span class="comment">//  NOTE: The first four fields must be the same as the PUBLIC_BCB.</span>
01348 <span class="comment">//</span>
01349 
<a name="l01350"></a><a class="code" href="../../d6/d4/struct__OBCB.html">01350</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d6/d4/struct__OBCB.html">_OBCB</a> {
01351 
01352     <span class="comment">//</span>
01353     <span class="comment">//  Type and size of this record</span>
01354     <span class="comment">//</span>
01355 
<a name="l01356"></a><a class="code" href="../../d6/d4/struct__OBCB.html#o0">01356</a>     CSHORT <a class="code" href="../../d6/d4/struct__OBCB.html#o0">NodeTypeCode</a>;
<a name="l01357"></a><a class="code" href="../../d6/d4/struct__OBCB.html#o1">01357</a>     CSHORT <a class="code" href="../../d6/d4/struct__OBCB.html#o1">NodeByteSize</a>;
01358 
01359     <span class="comment">//</span>
01360     <span class="comment">//  Byte FileOffset and and length of entire buffer</span>
01361     <span class="comment">//</span>
01362 
<a name="l01363"></a><a class="code" href="../../d6/d4/struct__OBCB.html#o2">01363</a>     ULONG  <a class="code" href="../../d6/d4/struct__OBCB.html#o2">ByteLength</a>;
<a name="l01364"></a><a class="code" href="../../d6/d4/struct__OBCB.html#o3">01364</a>     LARGE_INTEGER <a class="code" href="../../d6/d4/struct__OBCB.html#o3">FileOffset</a>;
01365 
01366     <span class="comment">//</span>
01367     <span class="comment">//  Vector of Bcb pointers.</span>
01368     <span class="comment">//</span>
01369 
<a name="l01370"></a><a class="code" href="../../d6/d4/struct__OBCB.html#o4">01370</a>     <a class="code" href="../../d5/d5/cc_8h.html#a110">PBCB</a> <a class="code" href="../../d6/d4/struct__OBCB.html#o4">Bcbs</a>[<a class="code" href="../../d5/d4/acpitabl_8h.html#a44">ANYSIZE_ARRAY</a>];
01371 
01372 } <a class="code" href="../../d6/d4/struct__OBCB.html">OBCB</a>;
01373 
<a name="l01374"></a><a class="code" href="../../d5/d5/cc_8h.html#a112">01374</a> <span class="keyword">typedef</span> <a class="code" href="../../d6/d4/struct__OBCB.html">OBCB</a> *<a class="code" href="../../d6/d4/struct__OBCB.html">POBCB</a>;
01375 
01376 
01377 <span class="comment">//</span>
01378 <span class="comment">//  Struct for remembering deferred writes for later posting.</span>
01379 <span class="comment">//</span>
01380 
<a name="l01381"></a><a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html">01381</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html">_DEFERRED_WRITE</a> {
01382 
01383     <span class="comment">//</span>
01384     <span class="comment">//  Type and size of this record</span>
01385     <span class="comment">//</span>
01386 
<a name="l01387"></a><a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o0">01387</a>     CSHORT <a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o0">NodeTypeCode</a>;
<a name="l01388"></a><a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o1">01388</a>     CSHORT <a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o1">NodeByteSize</a>;
01389 
01390     <span class="comment">//</span>
01391     <span class="comment">//  The file to be written.</span>
01392     <span class="comment">//</span>
01393 
<a name="l01394"></a><a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o2">01394</a>     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> <a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o2">FileObject</a>;
01395 
01396     <span class="comment">//</span>
01397     <span class="comment">//  Number of bytes the caller intends to write</span>
01398     <span class="comment">//</span>
01399 
<a name="l01400"></a><a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o3">01400</a>     ULONG <a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o3">BytesToWrite</a>;
01401 
01402     <span class="comment">//</span>
01403     <span class="comment">//  Links for the deferred write queue.</span>
01404     <span class="comment">//</span>
01405 
<a name="l01406"></a><a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o4">01406</a>     LIST_ENTRY <a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o4">DeferredWriteLinks</a>;
01407 
01408     <span class="comment">//</span>
01409     <span class="comment">//  If this event pointer is not NULL, then this event will</span>
01410     <span class="comment">//  be signalled when the write is ok, rather than calling</span>
01411     <span class="comment">//  the PostRoutine below.</span>
01412     <span class="comment">//</span>
01413 
<a name="l01414"></a><a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o5">01414</a>     <a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a> <a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o5">Event</a>;
01415 
01416     <span class="comment">//</span>
01417     <span class="comment">//  The posting routine and its parameters</span>
01418     <span class="comment">//</span>
01419 
<a name="l01420"></a><a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o6">01420</a>     <a class="code" href="../../d4/d2/cache_8h.html#a56">PCC_POST_DEFERRED_WRITE</a> <a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o6">PostRoutine</a>;
<a name="l01421"></a><a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o7">01421</a>     PVOID <a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o7">Context1</a>;
<a name="l01422"></a><a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o8">01422</a>     PVOID <a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o8">Context2</a>;
01423 
<a name="l01424"></a><a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o9">01424</a>     BOOLEAN <a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o9">LimitModifiedPages</a>;
01425 
01426 } <a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html">DEFERRED_WRITE</a>, *<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html">PDEFERRED_WRITE</a>;
01427 
01428 
01429 <span class="comment">//</span>
01430 <span class="comment">//  Struct controlling the Lazy Writer algorithms</span>
01431 <span class="comment">//</span>
01432 
<a name="l01433"></a><a class="code" href="../../d3/d9/struct__LAZY__WRITER.html">01433</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d3/d9/struct__LAZY__WRITER.html">_LAZY_WRITER</a> {
01434 
01435     <span class="comment">//</span>
01436     <span class="comment">//  A few Mm routines still require a process.</span>
01437     <span class="comment">//</span>
01438 
<a name="l01439"></a><a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o0">01439</a>     <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> <a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o0">OurProcess</a>;
01440 
01441     <span class="comment">//</span>
01442     <span class="comment">//  Work queue.</span>
01443     <span class="comment">//</span>
01444 
<a name="l01445"></a><a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o1">01445</a>     LIST_ENTRY <a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o1">WorkQueue</a>;
01446 
01447     <span class="comment">//</span>
01448     <span class="comment">//  Zone for Bcbs.</span>
01449     <span class="comment">//</span>
01450 
<a name="l01451"></a><a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o2">01451</a>     <a class="code" href="../../d0/d0/struct__ZONE__HEADER.html">ZONE_HEADER</a> <a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o2">BcbZone</a>;
01452 
01453     <span class="comment">//</span>
01454     <span class="comment">//  Dpc and Timer Structures used for activating periodic scan when active.</span>
01455     <span class="comment">//</span>
01456 
<a name="l01457"></a><a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o3">01457</a>     <a class="code" href="../../d1/d6/struct__KDPC.html">KDPC</a> <a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o3">ScanDpc</a>;
<a name="l01458"></a><a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o4">01458</a>     <a class="code" href="../../d3/d8/struct__KTIMER.html">KTIMER</a> <a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o4">ScanTimer</a>;
01459 
01460     <span class="comment">//</span>
01461     <span class="comment">//  Boolean to say whether Lazy Writer scan is active or not.</span>
01462     <span class="comment">//</span>
01463 
<a name="l01464"></a><a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o5">01464</a>     BOOLEAN <a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o5">ScanActive</a>;
01465 
01466     <span class="comment">//</span>
01467     <span class="comment">//  Boolean indicating if there is any other reason for Lazy Writer to</span>
01468     <span class="comment">//  wake up.</span>
01469     <span class="comment">//</span>
01470 
<a name="l01471"></a><a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o6">01471</a>     BOOLEAN <a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o6">OtherWork</a>;
01472 
01473 } <a class="code" href="../../d3/d9/struct__LAZY__WRITER.html">LAZY_WRITER</a>;
01474 
01475 
01476 <span class="preprocessor">#ifndef KDEXT</span>
01477 <span class="preprocessor"></span><span class="comment">//</span>
01478 <span class="comment">//  Work queue entry for the worker threads, with an enumerated</span>
01479 <span class="comment">//  function code.</span>
01480 <span class="comment">//</span>
01481 
<a name="l01482"></a><a class="code" href="../../d5/d5/cc_8h.html#a210">01482</a> <span class="keyword">typedef</span> <span class="keyword">enum</span> <a class="code" href="../../d5/d5/cc_8h.html#a210">_WORKER_FUNCTION</a> {
01483     <a class="code" href="../../d5/d5/cc_8h.html#a210a166">Noop</a> = 0,
01484     <a class="code" href="../../d5/d5/cc_8h.html#a210a167">ReadAhead</a>,
01485     <a class="code" href="../../d5/d5/cc_8h.html#a210a168">WriteBehind</a>,
01486     <a class="code" href="../../d5/d5/cc_8h.html#a210a169">LazyWriteScan</a>,
01487     <a class="code" href="../../d5/d5/cc_8h.html#a210a170">EventSet</a>
01488     } <a class="code" href="../../d5/d5/cc_8h.html#a116">WORKER_FUNCTION</a>;
01489 <span class="preprocessor">#endif</span>
01490 <span class="preprocessor"></span>
<a name="l01491"></a><a class="code" href="../../d2/d9/struct__WORK__QUEUE__ENTRY.html">01491</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d2/d9/struct__WORK__QUEUE__ENTRY.html">_WORK_QUEUE_ENTRY</a> {
01492 
01493     <span class="comment">//</span>
01494     <span class="comment">//  List entry for our work queues.</span>
01495     <span class="comment">//</span>
01496 
<a name="l01497"></a><a class="code" href="../../d2/d9/struct__WORK__QUEUE__ENTRY.html#o0">01497</a>     LIST_ENTRY <a class="code" href="../../d2/d9/struct__WORK__QUEUE__ENTRY.html#o0">WorkQueueLinks</a>;
01498 
01499     <span class="comment">//</span>
01500     <span class="comment">//  Define a union to contain function-specific parameters.</span>
01501     <span class="comment">//</span>
01502 
01503     <span class="keyword">union </span>{
01504 
01505         <span class="comment">//</span>
01506         <span class="comment">//  Read parameters (for read ahead)</span>
01507         <span class="comment">//</span>
01508 
01509         <span class="keyword">struct </span>{
<a name="l01510"></a><a class="code" href="../../d2/d9/struct__WORK__QUEUE__ENTRY.html#o1">01510</a>             <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> <a class="code" href="../../d2/d9/struct__WORK__QUEUE__ENTRY.html#o1">FileObject</a>;
01511         } Read;
01512 
01513         <span class="comment">//</span>
01514         <span class="comment">//  Write parameters (for write behind)</span>
01515         <span class="comment">//</span>
01516 
01517         <span class="keyword">struct </span>{
<a name="l01518"></a><a class="code" href="../../d2/d9/struct__WORK__QUEUE__ENTRY.html#o3">01518</a>             <a class="code" href="../../d5/d5/cc_8h.html#a102">PSHARED_CACHE_MAP</a> <a class="code" href="../../d2/d9/struct__WORK__QUEUE__ENTRY.html#o3">SharedCacheMap</a>;
01519         } Write;
01520         
01521         <span class="comment">//</span>
01522         <span class="comment">//  Set event parameters (for queue checks)</span>
01523         <span class="comment">//</span>
01524 
01525         <span class="keyword">struct </span>{
<a name="l01526"></a><a class="code" href="../../d2/d9/struct__WORK__QUEUE__ENTRY.html#o5">01526</a>             <a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a> <a class="code" href="../../d2/d9/struct__WORK__QUEUE__ENTRY.html#o5">Event</a>;
01527         } Event;
01528 
01529     } <a class="code" href="../../d2/d9/struct__WORK__QUEUE__ENTRY.html#o7">Parameters</a>;
01530 
01531     <span class="comment">//</span>
01532     <span class="comment">//  Function code for this entry:</span>
01533     <span class="comment">//</span>
01534 
<a name="l01535"></a><a class="code" href="../../d2/d9/struct__WORK__QUEUE__ENTRY.html#o8">01535</a>     UCHAR <a class="code" href="../../d2/d9/struct__WORK__QUEUE__ENTRY.html#o8">Function</a>;
01536 
01537 } <a class="code" href="../../d2/d9/struct__WORK__QUEUE__ENTRY.html">WORK_QUEUE_ENTRY</a>, *<a class="code" href="../../d2/d9/struct__WORK__QUEUE__ENTRY.html">PWORK_QUEUE_ENTRY</a>;
01538 
01539 <span class="comment">//</span>
01540 <span class="comment">//  This is a structure apended to the end of an MDL</span>
01541 <span class="comment">//</span>
01542 
<a name="l01543"></a><a class="code" href="../../d7/d7/struct__MDL__WRITE.html">01543</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d7/d7/struct__MDL__WRITE.html">_MDL_WRITE</a> {
01544 
01545     <span class="comment">//</span>
01546     <span class="comment">//  This field is for the use of the Server to stash anything interesting</span>
01547     <span class="comment">//</span>
01548 
<a name="l01549"></a><a class="code" href="../../d7/d7/struct__MDL__WRITE.html#o0">01549</a>     PVOID <a class="code" href="../../d7/d7/struct__MDL__WRITE.html#o0">ServerContext</a>;
01550 
01551     <span class="comment">//</span>
01552     <span class="comment">//  This is the resource to release when the write is complete.</span>
01553     <span class="comment">//</span>
01554 
<a name="l01555"></a><a class="code" href="../../d7/d7/struct__MDL__WRITE.html#o1">01555</a>     <a class="code" href="../../d6/d4/struct__ERESOURCE.html">PERESOURCE</a> <a class="code" href="../../d7/d7/struct__MDL__WRITE.html#o1">Resource</a>;
01556 
01557     <span class="comment">//</span>
01558     <span class="comment">//  This is thread caller's thread, and the thread that must release</span>
01559     <span class="comment">//  the resource.</span>
01560     <span class="comment">//</span>
01561 
<a name="l01562"></a><a class="code" href="../../d7/d7/struct__MDL__WRITE.html#o2">01562</a>     <a class="code" href="../../d5/d8/ex_8h.html#a121">ERESOURCE_THREAD</a> <a class="code" href="../../d7/d7/struct__MDL__WRITE.html#o2">Thread</a>;
01563 
01564     <span class="comment">//</span>
01565     <span class="comment">//  This links all the pending MDLs through the shared cache map.</span>
01566     <span class="comment">//</span>
01567 
<a name="l01568"></a><a class="code" href="../../d7/d7/struct__MDL__WRITE.html#o3">01568</a>     LIST_ENTRY <a class="code" href="../../d7/d7/struct__MDL__WRITE.html#o3">MdlLinks</a>;
01569 
01570 } <a class="code" href="../../d7/d7/struct__MDL__WRITE.html">MDL_WRITE</a>, *<a class="code" href="../../d7/d7/struct__MDL__WRITE.html">PMDL_WRITE</a>;
01571 
01572 
01573 <span class="comment">//</span>
01574 <span class="comment">//  Common Private routine definitions for the Cache Manager</span>
01575 <span class="comment">//</span>
01576 
<a name="l01577"></a><a class="code" href="../../d5/d5/cc_8h.html#a82">01577</a> <span class="preprocessor">#define GetActiveVacb(SCM,IRQ,V,P,D) {                                  \</span>
01578 <span class="preprocessor">    ExAcquireFastLock(&amp;(SCM)-&gt;ActiveVacbSpinLock, &amp;(IRQ));              \</span>
01579 <span class="preprocessor">    (V) = (SCM)-&gt;ActiveVacb;                                            \</span>
01580 <span class="preprocessor">    if ((V) != NULL) {                                                  \</span>
01581 <span class="preprocessor">        (P) = (SCM)-&gt;ActivePage;                                        \</span>
01582 <span class="preprocessor">        (SCM)-&gt;ActiveVacb = NULL;                                       \</span>
01583 <span class="preprocessor">        (D) = (SCM)-&gt;Flags &amp; ACTIVE_PAGE_IS_DIRTY;                      \</span>
01584 <span class="preprocessor">    }                                                                   \</span>
01585 <span class="preprocessor">    ExReleaseFastLock(&amp;(SCM)-&gt;ActiveVacbSpinLock, (IRQ));               \</span>
01586 <span class="preprocessor">}</span>
01587 <span class="preprocessor"></span>
<a name="l01588"></a><a class="code" href="../../d5/d5/cc_8h.html#a83">01588</a> <span class="preprocessor">#define GetActiveVacbAtDpcLevel(SCM,V,P,D) {                            \</span>
01589 <span class="preprocessor">    ExAcquireSpinLockAtDpcLevel(&amp;(SCM)-&gt;ActiveVacbSpinLock);            \</span>
01590 <span class="preprocessor">    (V) = (SCM)-&gt;ActiveVacb;                                            \</span>
01591 <span class="preprocessor">    if ((V) != NULL) {                                                  \</span>
01592 <span class="preprocessor">        (P) = (SCM)-&gt;ActivePage;                                        \</span>
01593 <span class="preprocessor">        (SCM)-&gt;ActiveVacb = NULL;                                       \</span>
01594 <span class="preprocessor">        (D) = (SCM)-&gt;Flags &amp; ACTIVE_PAGE_IS_DIRTY;                      \</span>
01595 <span class="preprocessor">    }                                                                   \</span>
01596 <span class="preprocessor">    ExReleaseSpinLockFromDpcLevel(&amp;(SCM)-&gt;ActiveVacbSpinLock);          \</span>
01597 <span class="preprocessor">}</span>
01598 <span class="preprocessor"></span>
01599 <span class="comment">//</span>
01600 <span class="comment">//  When setting dirty, when we set ACTIVE_PAGE_IS_DIRTY the first time,</span>
01601 <span class="comment">//  we increment the dirty counts, and they never get decremented until</span>
01602 <span class="comment">//  CcFreeActiveVacb.  If we are trying to set and there is already an</span>
01603 <span class="comment">//  active Vacb *or* we are trying to set a clean one and the flag above</span>
01604 <span class="comment">//  is set, we do not allow it, and we just free the vacb (we only want</span>
01605 <span class="comment">//  to handle the clean transition in one place).</span>
01606 <span class="comment">//</span>
01607 <span class="comment">//  MP &amp; UP cases are separately defined, because I do not trust the compiler</span>
01608 <span class="comment">//  to otherwise generate the optimal UP code.</span>
01609 <span class="comment">//</span>
01610 
01611 
01612 <span class="comment">//</span>
01613 <span class="comment">//  In the MP case, we test if we are setting the page dirty, because then</span>
01614 <span class="comment">//  we must acquire CcMasterSpinLock to diddle CcDirtyPages.</span>
01615 <span class="comment">//</span>
01616 
01617 <span class="preprocessor">#if !defined(NT_UP)                                                                     \</span>
01618 <span class="preprocessor"></span>
<a name="l01619"></a><a class="code" href="../../d5/d5/cc_8h.html#a84">01619</a> <span class="preprocessor"></span><span class="preprocessor">#define SetActiveVacb(SCM,IRQ,V,P,D) {                                                  \</span>
01620 <span class="preprocessor">    if (D) {                                                                            \</span>
01621 <span class="preprocessor">        CcAcquireMasterLock(&amp;(IRQ));                                                    \</span>
01622 <span class="preprocessor">        ExAcquireSpinLockAtDpcLevel(&amp;(SCM)-&gt;ActiveVacbSpinLock);                        \</span>
01623 <span class="preprocessor">    } else {                                                                            \</span>
01624 <span class="preprocessor">        ExAcquireSpinLock(&amp;(SCM)-&gt;ActiveVacbSpinLock, &amp;(IRQ));                          \</span>
01625 <span class="preprocessor">    }                                                                                   \</span>
01626 <span class="preprocessor">    do {                                                                                \</span>
01627 <span class="preprocessor">        if ((SCM)-&gt;ActiveVacb == NULL) {                                                \</span>
01628 <span class="preprocessor">            if (((SCM)-&gt;Flags &amp; ACTIVE_PAGE_IS_DIRTY) != (D)) {                         \</span>
01629 <span class="preprocessor">                if (D) {                                                                \</span>
01630 <span class="preprocessor">                    (SCM)-&gt;ActiveVacb = (V);                                            \</span>
01631 <span class="preprocessor">                    (SCM)-&gt;ActivePage = (P);                                            \</span>
01632 <span class="preprocessor">                    (V) = NULL;                                                         \</span>
01633 <span class="preprocessor">                    SetFlag((SCM)-&gt;Flags, ACTIVE_PAGE_IS_DIRTY);                        \</span>
01634 <span class="preprocessor">                    CcTotalDirtyPages += 1;                                             \</span>
01635 <span class="preprocessor">                    (SCM)-&gt;DirtyPages += 1;                                             \</span>
01636 <span class="preprocessor">                    if ((SCM)-&gt;DirtyPages == 1) {                                       \</span>
01637 <span class="preprocessor">                        PLIST_ENTRY Blink;                                              \</span>
01638 <span class="preprocessor">                        PLIST_ENTRY Entry;                                              \</span>
01639 <span class="preprocessor">                        PLIST_ENTRY Flink;                                              \</span>
01640 <span class="preprocessor">                        PLIST_ENTRY Head;                                               \</span>
01641 <span class="preprocessor">                        Entry = &amp;(SCM)-&gt;SharedCacheMapLinks;                            \</span>
01642 <span class="preprocessor">                        Blink = Entry-&gt;Blink;                                           \</span>
01643 <span class="preprocessor">                        Flink = Entry-&gt;Flink;                                           \</span>
01644 <span class="preprocessor">                        Blink-&gt;Flink = Flink;                                           \</span>
01645 <span class="preprocessor">                        Flink-&gt;Blink = Blink;                                           \</span>
01646 <span class="preprocessor">                        Head = &amp;CcDirtySharedCacheMapList.SharedCacheMapLinks;          \</span>
01647 <span class="preprocessor">                        Blink = Head-&gt;Blink;                                            \</span>
01648 <span class="preprocessor">                        Entry-&gt;Flink = Head;                                            \</span>
01649 <span class="preprocessor">                        Entry-&gt;Blink = Blink;                                           \</span>
01650 <span class="preprocessor">                        Blink-&gt;Flink = Entry;                                           \</span>
01651 <span class="preprocessor">                        Head-&gt;Blink = Entry;                                            \</span>
01652 <span class="preprocessor">                        if (!LazyWriter.ScanActive) {                                   \</span>
01653 <span class="preprocessor">                            LazyWriter.ScanActive = TRUE;                               \</span>
01654 <span class="preprocessor">                            ExReleaseSpinLockFromDpcLevel(&amp;(SCM)-&gt;ActiveVacbSpinLock);  \</span>
01655 <span class="preprocessor">                            CcReleaseMasterLock((IRQ));                                 \</span>
01656 <span class="preprocessor">                            KeSetTimer( &amp;LazyWriter.ScanTimer,                          \</span>
01657 <span class="preprocessor">                                        CcFirstDelay,                                   \</span>
01658 <span class="preprocessor">                                        &amp;LazyWriter.ScanDpc );                          \</span>
01659 <span class="preprocessor">                            break;                                                      \</span>
01660 <span class="preprocessor">                        }                                                               \</span>
01661 <span class="preprocessor">                    }                                                                   \</span>
01662 <span class="preprocessor">                }                                                                       \</span>
01663 <span class="preprocessor">            } else {                                                                    \</span>
01664 <span class="preprocessor">                (SCM)-&gt;ActiveVacb = (V);                                                \</span>
01665 <span class="preprocessor">                (SCM)-&gt;ActivePage = (P);                                                \</span>
01666 <span class="preprocessor">                (V) = NULL;                                                             \</span>
01667 <span class="preprocessor">            }                                                                           \</span>
01668 <span class="preprocessor">        }                                                                               \</span>
01669 <span class="preprocessor">        if (D) {                                                                        \</span>
01670 <span class="preprocessor">            ExReleaseSpinLockFromDpcLevel(&amp;(SCM)-&gt;ActiveVacbSpinLock);                  \</span>
01671 <span class="preprocessor">            CcReleaseMasterLock((IRQ));                                                 \</span>
01672 <span class="preprocessor">        } else {                                                                        \</span>
01673 <span class="preprocessor">            ExReleaseSpinLock(&amp;(SCM)-&gt;ActiveVacbSpinLock, (IRQ));                       \</span>
01674 <span class="preprocessor">        }                                                                               \</span>
01675 <span class="preprocessor">        if ((V) != NULL) {                                                              \</span>
01676 <span class="preprocessor">            CcFreeActiveVacb( (SCM), (V), (P), (D));                                    \</span>
01677 <span class="preprocessor">        }                                                                               \</span>
01678 <span class="preprocessor">    } while (FALSE);                                                                    \</span>
01679 <span class="preprocessor">}</span>
01680 <span class="preprocessor"></span>
01681 <span class="comment">//</span>
01682 <span class="comment">//  In the UP case, any FastLock will do, so we just use the ActiveVacb lock, and do not</span>
01683 <span class="comment">//  explicitly acquire CcMasterSpinLock.</span>
01684 <span class="comment">//</span>
01685 
01686 <span class="preprocessor">#else</span>
01687 <span class="preprocessor"></span>
01688 <span class="preprocessor">#define SetActiveVacb(SCM,IRQ,V,P,D) {                                                  \</span>
01689 <span class="preprocessor">    ExAcquireFastLock(&amp;(SCM)-&gt;ActiveVacbSpinLock, &amp;(IRQ));                              \</span>
01690 <span class="preprocessor">    do {                                                                                \</span>
01691 <span class="preprocessor">        if ((SCM)-&gt;ActiveVacb == NULL) {                                                \</span>
01692 <span class="preprocessor">            if (((SCM)-&gt;Flags &amp; ACTIVE_PAGE_IS_DIRTY) != (D)) {                         \</span>
01693 <span class="preprocessor">                if (D) {                                                                \</span>
01694 <span class="preprocessor">                    (SCM)-&gt;ActiveVacb = (V);                                            \</span>
01695 <span class="preprocessor">                    (SCM)-&gt;ActivePage = (P);                                            \</span>
01696 <span class="preprocessor">                    (V) = NULL;                                                         \</span>
01697 <span class="preprocessor">                    SetFlag((SCM)-&gt;Flags, ACTIVE_PAGE_IS_DIRTY);                        \</span>
01698 <span class="preprocessor">                    CcTotalDirtyPages += 1;                                             \</span>
01699 <span class="preprocessor">                    (SCM)-&gt;DirtyPages += 1;                                             \</span>
01700 <span class="preprocessor">                    if ((SCM)-&gt;DirtyPages == 1) {                                       \</span>
01701 <span class="preprocessor">                        PLIST_ENTRY Blink;                                              \</span>
01702 <span class="preprocessor">                        PLIST_ENTRY Entry;                                              \</span>
01703 <span class="preprocessor">                        PLIST_ENTRY Flink;                                              \</span>
01704 <span class="preprocessor">                        PLIST_ENTRY Head;                                               \</span>
01705 <span class="preprocessor">                        Entry = &amp;(SCM)-&gt;SharedCacheMapLinks;                            \</span>
01706 <span class="preprocessor">                        Blink = Entry-&gt;Blink;                                           \</span>
01707 <span class="preprocessor">                        Flink = Entry-&gt;Flink;                                           \</span>
01708 <span class="preprocessor">                        Blink-&gt;Flink = Flink;                                           \</span>
01709 <span class="preprocessor">                        Flink-&gt;Blink = Blink;                                           \</span>
01710 <span class="preprocessor">                        Head = &amp;CcDirtySharedCacheMapList.SharedCacheMapLinks;          \</span>
01711 <span class="preprocessor">                        Blink = Head-&gt;Blink;                                            \</span>
01712 <span class="preprocessor">                        Entry-&gt;Flink = Head;                                            \</span>
01713 <span class="preprocessor">                        Entry-&gt;Blink = Blink;                                           \</span>
01714 <span class="preprocessor">                        Blink-&gt;Flink = Entry;                                           \</span>
01715 <span class="preprocessor">                        Head-&gt;Blink = Entry;                                            \</span>
01716 <span class="preprocessor">                        if (!LazyWriter.ScanActive) {                                   \</span>
01717 <span class="preprocessor">                            LazyWriter.ScanActive = TRUE;                               \</span>
01718 <span class="preprocessor">                            ExReleaseFastLock(&amp;(SCM)-&gt;ActiveVacbSpinLock, (IRQ));       \</span>
01719 <span class="preprocessor">                            KeSetTimer( &amp;LazyWriter.ScanTimer,                          \</span>
01720 <span class="preprocessor">                                        CcFirstDelay,                                   \</span>
01721 <span class="preprocessor">                                        &amp;LazyWriter.ScanDpc );                          \</span>
01722 <span class="preprocessor">                            break;                                                      \</span>
01723 <span class="preprocessor">                        }                                                               \</span>
01724 <span class="preprocessor">                    }                                                                   \</span>
01725 <span class="preprocessor">                }                                                                       \</span>
01726 <span class="preprocessor">            } else {                                                                    \</span>
01727 <span class="preprocessor">                (SCM)-&gt;ActiveVacb = (V);                                                \</span>
01728 <span class="preprocessor">                (SCM)-&gt;ActivePage = (P);                                                \</span>
01729 <span class="preprocessor">                (V) = NULL;                                                             \</span>
01730 <span class="preprocessor">            }                                                                           \</span>
01731 <span class="preprocessor">        }                                                                               \</span>
01732 <span class="preprocessor">        ExReleaseFastLock(&amp;(SCM)-&gt;ActiveVacbSpinLock, (IRQ));                           \</span>
01733 <span class="preprocessor">        if ((V) != NULL) {                                                              \</span>
01734 <span class="preprocessor">            CcFreeActiveVacb( (SCM), (V), (P), (D));                                    \</span>
01735 <span class="preprocessor">        }                                                                               \</span>
01736 <span class="preprocessor">    } while (FALSE);                                                                    \</span>
01737 <span class="preprocessor">}</span>
01738 <span class="preprocessor"></span>
01739 <span class="preprocessor">#endif</span>
01740 <span class="preprocessor"></span>
01741 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01742 <a class="code" href="../../d5/d5/cc_8h.html#a174">CcPostDeferredWrites</a> (
01743     );
01744 
01745 BOOLEAN
01746 <a class="code" href="../../d5/d5/cc_8h.html#a175">CcPinFileData</a> (
01747     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
01748     IN PLARGE_INTEGER FileOffset,
01749     IN ULONG Length,
01750     IN BOOLEAN ReadOnly,
01751     IN BOOLEAN WriteOnly,
01752     IN ULONG Flags,
01753     OUT PBCB *Bcb,
01754     OUT PVOID *BaseAddress,
01755     OUT PLARGE_INTEGER BeyondLastByte
01756     );
01757 
<a name="l01758"></a><a class="code" href="../../d5/d5/cc_8h.html#a211">01758</a> <span class="keyword">typedef</span> <span class="keyword">enum</span> {
01759     <a class="code" href="../../d5/d5/cc_8h.html#a211a171">UNPIN</a>,
01760     <a class="code" href="../../d5/d5/cc_8h.html#a211a172">UNREF</a>,
01761     <a class="code" href="../../d5/d5/cc_8h.html#a211a173">SET_CLEAN</a>
01762 } <a class="code" href="../../d5/d5/cc_8h.html#a211">UNMAP_ACTIONS</a>;
01763 
01764 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01765 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
01766 <a class="code" href="../../d5/d5/cc_8h.html#a176">CcUnpinFileData</a> (
01767     IN OUT PBCB Bcb,
01768     IN BOOLEAN ReadOnly,
01769     IN UNMAP_ACTIONS UnmapAction
01770     );
01771 
01772 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01773 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
01774 <a class="code" href="../../d5/d5/cc_8h.html#a177">CcDeallocateBcb</a> (
01775     IN PBCB Bcb
01776     );
01777 
01778 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01779 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
01780 <a class="code" href="../../d5/d5/cc_8h.html#a178">CcPerformReadAhead</a> (
01781     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject
01782     );
01783 
01784 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01785 <a class="code" href="../../d5/d5/cc_8h.html#a179">CcSetDirtyInMask</a> (
01786     IN PSHARED_CACHE_MAP SharedCacheMap,
01787     IN PLARGE_INTEGER FileOffset,
01788     IN ULONG Length
01789     );
01790 
01791 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01792 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
01793 <a class="code" href="../../d5/d5/cc_8h.html#a180">CcWriteBehind</a> (
01794     IN PSHARED_CACHE_MAP SharedCacheMap,
01795     IN PIO_STATUS_BLOCK IoStatus
01796     );
01797 
<a name="l01798"></a><a class="code" href="../../d5/d5/cc_8h.html#a85">01798</a> <span class="preprocessor">#define ZERO_FIRST_PAGE                  1</span>
<a name="l01799"></a><a class="code" href="../../d5/d5/cc_8h.html#a86">01799</a> <span class="preprocessor"></span><span class="preprocessor">#define ZERO_MIDDLE_PAGES                2</span>
<a name="l01800"></a><a class="code" href="../../d5/d5/cc_8h.html#a87">01800</a> <span class="preprocessor"></span><span class="preprocessor">#define ZERO_LAST_PAGE                   4</span>
01801 <span class="preprocessor"></span>
01802 BOOLEAN
01803 <a class="code" href="../../d5/d5/cc_8h.html#a181">CcMapAndRead</a>(
01804     IN PSHARED_CACHE_MAP SharedCacheMap,
01805     IN PLARGE_INTEGER FileOffset,
01806     IN ULONG Length,
01807     IN ULONG ZeroFlags,
01808     IN BOOLEAN Wait,
01809     IN PVOID BaseAddress
01810     );
01811 
01812 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01813 <a class="code" href="../../d5/d5/cc_8h.html#a182">CcFreeActiveVacb</a> (
01814     IN PSHARED_CACHE_MAP SharedCacheMap,
01815     IN PVACB ActiveVacb OPTIONAL,
01816     IN ULONG ActivePage,
01817     IN ULONG PageIsDirty
01818     );
01819 
01820 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01821 <a class="code" href="../../d5/d5/cc_8h.html#a183">CcMapAndCopy</a>(
01822     IN PSHARED_CACHE_MAP SharedCacheMap,
01823     IN PVOID UserBuffer,
01824     IN PLARGE_INTEGER FileOffset,
01825     IN ULONG Length,
01826     IN ULONG ZeroFlags,
01827     IN BOOLEAN WriteThrough
01828     );
01829 
01830 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01831 <a class="code" href="../../d5/d1/lazyrite_8c.html#a5">CcScanDpc</a> (
01832     IN <a class="code" href="../../d1/d6/struct__KDPC.html">PKDPC</a> Dpc,
01833     IN PVOID DeferredContext,
01834     IN PVOID SystemArgument1,
01835     IN PVOID SystemArgument2
01836     );
01837 
01838 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01839 <a class="code" href="../../d5/d5/cc_8h.html#a185">CcScheduleLazyWriteScan</a> (
01840     );
01841 
01842 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01843 <a class="code" href="../../d5/d5/cc_8h.html#a186">CcStartLazyWriter</a> (
01844     IN PVOID NotUsed
01845     );
01846 
<a name="l01847"></a><a class="code" href="../../d5/d5/cc_8h.html#a88">01847</a> <span class="preprocessor">#define CcAllocateWorkQueueEntry() \</span>
01848 <span class="preprocessor">    (PWORK_QUEUE_ENTRY)ExAllocateFromPPNPagedLookasideList(LookasideTwilightList)</span>
01849 <span class="preprocessor"></span>
<a name="l01850"></a><a class="code" href="../../d5/d5/cc_8h.html#a89">01850</a> <span class="preprocessor">#define CcFreeWorkQueueEntry(_entry_)         \</span>
01851 <span class="preprocessor">    ExFreeToPPNPagedLookasideList(LookasideTwilightList, (_entry_))</span>
01852 <span class="preprocessor"></span>
01853 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01854 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
01855 <a class="code" href="../../d5/d1/lazyrite_8c.html#a8">CcPostWorkQueue</a> (
01856     IN PWORK_QUEUE_ENTRY WorkQueueEntry,
01857     IN PLIST_ENTRY WorkQueue
01858     );
01859 
01860 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01861 <a class="code" href="../../d5/d1/lazyrite_8c.html#a9">CcWorkerThread</a> (
01862     PVOID ExWorkQueueItem
01863     );
01864 
01865 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01866 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
01867 <a class="code" href="../../d5/d8/fssup_8c.html#a11">CcDeleteSharedCacheMap</a> (
01868     IN PSHARED_CACHE_MAP SharedCacheMap,
01869     IN KIRQL ListIrql,
01870     IN ULONG ReleaseFile
01871     );
01872 
01873 <span class="comment">//</span>
01874 <span class="comment">//  This exception filter handles STATUS_IN_PAGE_ERROR correctly</span>
01875 <span class="comment">//</span>
01876 
01877 LONG
01878 <a class="code" href="../../d5/d7/copysup_8c.html#a5">CcCopyReadExceptionFilter</a>(
01879     IN PEXCEPTION_POINTERS ExceptionPointer,
01880     IN PNTSTATUS ExceptionCode
01881     );
01882 
01883 <span class="comment">//</span>
01884 <span class="comment">//  Exception filter for Worker Threads in lazyrite.c</span>
01885 <span class="comment">//</span>
01886 
01887 LONG
01888 <a class="code" href="../../d5/d1/lazyrite_8c.html#a7">CcExceptionFilter</a> (
01889     IN NTSTATUS ExceptionCode
01890     );
01891 
01892 <span class="preprocessor">#ifdef CCDBG</span>
01893 <span class="preprocessor"></span><a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01894 CcDump (
01895     IN PVOID Ptr
01896     );
01897 <span class="preprocessor">#endif</span>
01898 <span class="preprocessor"></span>
01899 <span class="comment">//</span>
01900 <span class="comment">//  Vacb routines</span>
01901 <span class="comment">//</span>
01902 
01903 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01904 <a class="code" href="../../d5/d5/cc_8h.html#a192">CcInitializeVacbs</a>(
01905     );
01906 
01907 PVOID
01908 <a class="code" href="../../d5/d3/vacbsup_8c.html#a14">CcGetVirtualAddressIfMapped</a> (
01909     IN PSHARED_CACHE_MAP SharedCacheMap,
01910     IN LONGLONG FileOffset,
01911     OUT PVACB *Vacb,
01912     OUT PULONG ReceivedLength
01913     );
01914 
01915 PVOID
01916 <a class="code" href="../../d5/d3/vacbsup_8c.html#a15">CcGetVirtualAddress</a> (
01917     IN PSHARED_CACHE_MAP SharedCacheMap,
01918     IN LARGE_INTEGER FileOffset,
01919     OUT PVACB *Vacb,
01920     OUT PULONG ReceivedLength
01921     );
01922 
01923 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01924 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
01925 <a class="code" href="../../d5/d3/vacbsup_8c.html#a16">CcFreeVirtualAddress</a> (
01926     IN PVACB Vacb
01927     );
01928 
01929 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01930 <a class="code" href="../../d5/d3/vacbsup_8c.html#a17">CcReferenceFileOffset</a> (
01931     IN PSHARED_CACHE_MAP SharedCacheMap,
01932     IN LARGE_INTEGER FileOffset
01933     );
01934 
01935 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01936 <a class="code" href="../../d5/d3/vacbsup_8c.html#a18">CcDereferenceFileOffset</a> (
01937     IN PSHARED_CACHE_MAP SharedCacheMap,
01938     IN LARGE_INTEGER FileOffset
01939     );
01940 
01941 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01942 <a class="code" href="../../d5/d3/vacbsup_8c.html#a19">CcWaitOnActiveCount</a> (
01943     IN PSHARED_CACHE_MAP SharedCacheMap
01944     );
01945 
01946 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01947 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
01948 <a class="code" href="../../d5/d3/vacbsup_8c.html#a20">CcCreateVacbArray</a> (
01949     IN PSHARED_CACHE_MAP SharedCacheMap,
01950     IN LARGE_INTEGER NewSectionSize
01951     );
01952 
01953 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01954 <a class="code" href="../../d5/d3/vacbsup_8c.html#a21">CcExtendVacbArray</a> (
01955     IN PSHARED_CACHE_MAP SharedCacheMap,
01956     IN LARGE_INTEGER NewSectionSize
01957     );
01958 
01959 BOOLEAN
01960 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
01961 <a class="code" href="../../d5/d3/vacbsup_8c.html#a22">CcUnmapVacbArray</a> (
01962     IN PSHARED_CACHE_MAP SharedCacheMap,
01963     IN PLARGE_INTEGER FileOffset OPTIONAL,
01964     IN ULONG Length,
01965     IN BOOLEAN UnmapBehind
01966     );
01967 
01968 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01969 <a class="code" href="../../d5/d3/vacbsup_8c.html#a26">CcAdjustVacbLevelLockCount</a> (
01970     IN PSHARED_CACHE_MAP SharedCacheMap,
01971     IN LONGLONG FileOffset,
01972     IN LONG Adjustment
01973     );
01974 
01975 PLIST_ENTRY
01976 <a class="code" href="../../d5/d3/vacbsup_8c.html#a25">CcGetBcbListHeadLargeOffset</a> (
01977     IN PSHARED_CACHE_MAP SharedCacheMap,
01978     IN LONGLONG FileOffset,
01979     IN BOOLEAN FailToSuccessor
01980     );
01981 
01982 ULONG
01983 <a class="code" href="../../d5/d3/vacbsup_8c.html#a23">CcPrefillVacbLevelZone</a> (
01984     IN ULONG NumberNeeded,
01985     OUT PKIRQL OldIrql,
01986     IN ULONG NeedBcbListHeads
01987     );
01988 
01989 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01990 <a class="code" href="../../d5/d5/cc_8h.html#a205">CcDrainVacbLevelZone</a> (
01991     );
01992 
01993 <span class="comment">//</span>
01994 <span class="comment">//  Define references to global data</span>
01995 <span class="comment">//</span>
01996 
<a name="l01997"></a><a class="code" href="../../d5/d5/cc_8h.html#a121">01997</a> <span class="keyword">extern</span> KSPIN_LOCK <a class="code" href="../../d5/d2/cachedat_8c.html#a0">CcMasterSpinLock</a>;
<a name="l01998"></a><a class="code" href="../../d5/d5/cc_8h.html#a122">01998</a> <span class="keyword">extern</span> KSPIN_LOCK <a class="code" href="../../d5/d5/cc_8h.html#a122">CcBcbSpinLock</a>;
<a name="l01999"></a><a class="code" href="../../d5/d5/cc_8h.html#a123">01999</a> <span class="keyword">extern</span> LIST_ENTRY <a class="code" href="../../d5/d2/cachedat_8c.html#a1">CcCleanSharedCacheMapList</a>;
<a name="l02000"></a><a class="code" href="../../d5/d5/cc_8h.html#a124">02000</a> <span class="keyword">extern</span> <a class="code" href="../../d1/d3/struct__SHARED__CACHE__MAP__LIST__CURSOR.html">SHARED_CACHE_MAP_LIST_CURSOR</a> <a class="code" href="../../d5/d2/cachedat_8c.html#a2">CcDirtySharedCacheMapList</a>;
<a name="l02001"></a><a class="code" href="../../d5/d5/cc_8h.html#a125">02001</a> <span class="keyword">extern</span> <a class="code" href="../../d1/d3/struct__SHARED__CACHE__MAP__LIST__CURSOR.html">SHARED_CACHE_MAP_LIST_CURSOR</a> <a class="code" href="../../d5/d2/cachedat_8c.html#a3">CcLazyWriterCursor</a>;
<a name="l02002"></a><a class="code" href="../../d5/d5/cc_8h.html#a126">02002</a> <span class="keyword">extern</span> <a class="code" href="../../d1/d4/struct__NPAGED__LOOKASIDE__LIST.html">NPAGED_LOOKASIDE_LIST</a> <a class="code" href="../../d5/d2/cachedat_8c.html#a42">CcTwilightLookasideList</a>;
<a name="l02003"></a><a class="code" href="../../d5/d5/cc_8h.html#a127">02003</a> <span class="keyword">extern</span> KSPIN_LOCK <a class="code" href="../../d5/d2/cachedat_8c.html#a4">CcWorkQueueSpinlock</a>;
<a name="l02004"></a><a class="code" href="../../d5/d5/cc_8h.html#a128">02004</a> <span class="keyword">extern</span> ULONG <a class="code" href="../../d5/d2/cachedat_8c.html#a5">CcNumberWorkerThreads</a>;
<a name="l02005"></a><a class="code" href="../../d5/d5/cc_8h.html#a129">02005</a> <span class="keyword">extern</span> ULONG <a class="code" href="../../d5/d2/cachedat_8c.html#a6">CcNumberActiveWorkerThreads</a>;
<a name="l02006"></a><a class="code" href="../../d5/d5/cc_8h.html#a130">02006</a> <span class="keyword">extern</span> LIST_ENTRY <a class="code" href="../../d5/d2/cachedat_8c.html#a7">CcIdleWorkerThreadList</a>;
<a name="l02007"></a><a class="code" href="../../d5/d5/cc_8h.html#a131">02007</a> <span class="keyword">extern</span> LIST_ENTRY <a class="code" href="../../d5/d2/cachedat_8c.html#a8">CcExpressWorkQueue</a>;
<a name="l02008"></a><a class="code" href="../../d5/d5/cc_8h.html#a132">02008</a> <span class="keyword">extern</span> LIST_ENTRY <a class="code" href="../../d5/d2/cachedat_8c.html#a9">CcRegularWorkQueue</a>;
<a name="l02009"></a><a class="code" href="../../d5/d5/cc_8h.html#a133">02009</a> <span class="keyword">extern</span> LIST_ENTRY <a class="code" href="../../d5/d2/cachedat_8c.html#a10">CcPostTickWorkQueue</a>;
<a name="l02010"></a><a class="code" href="../../d5/d5/cc_8h.html#a134">02010</a> <span class="keyword">extern</span> BOOLEAN <a class="code" href="../../d5/d2/cachedat_8c.html#a11">CcQueueThrottle</a>;
<a name="l02011"></a><a class="code" href="../../d5/d5/cc_8h.html#a135">02011</a> <span class="keyword">extern</span> ULONG <a class="code" href="../../d5/d2/cachedat_8c.html#a12">CcIdleDelayTick</a>;
<a name="l02012"></a><a class="code" href="../../d5/d5/cc_8h.html#a136">02012</a> <span class="keyword">extern</span> LARGE_INTEGER <a class="code" href="../../d5/d2/cachedat_8c.html#a13">CcNoDelay</a>;
<a name="l02013"></a><a class="code" href="../../d5/d5/cc_8h.html#a137">02013</a> <span class="keyword">extern</span> LARGE_INTEGER <a class="code" href="../../d5/d2/cachedat_8c.html#a14">CcFirstDelay</a>;
<a name="l02014"></a><a class="code" href="../../d5/d5/cc_8h.html#a138">02014</a> <span class="keyword">extern</span> LARGE_INTEGER <a class="code" href="../../d5/d2/cachedat_8c.html#a15">CcIdleDelay</a>;
<a name="l02015"></a><a class="code" href="../../d5/d5/cc_8h.html#a139">02015</a> <span class="keyword">extern</span> LARGE_INTEGER <a class="code" href="../../d5/d2/cachedat_8c.html#a16">CcCollisionDelay</a>;
<a name="l02016"></a><a class="code" href="../../d5/d5/cc_8h.html#a140">02016</a> <span class="keyword">extern</span> LARGE_INTEGER <a class="code" href="../../d5/d2/cachedat_8c.html#a17">CcTargetCleanDelay</a>;
<a name="l02017"></a><a class="code" href="../../d5/d5/cc_8h.html#a141">02017</a> <span class="keyword">extern</span> <a class="code" href="../../d3/d9/struct__LAZY__WRITER.html">LAZY_WRITER</a> <a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>;
<a name="l02018"></a><a class="code" href="../../d5/d5/cc_8h.html#a142">02018</a> <span class="keyword">extern</span> KSPIN_LOCK <a class="code" href="../../d5/d2/cachedat_8c.html#a18">CcVacbSpinLock</a>;
<a name="l02019"></a><a class="code" href="../../d5/d5/cc_8h.html#a143">02019</a> <span class="keyword">extern</span> ULONG <a class="code" href="../../d5/d2/cachedat_8c.html#a19">CcNumberVacbs</a>;
<a name="l02020"></a><a class="code" href="../../d5/d5/cc_8h.html#a144">02020</a> <span class="keyword">extern</span> <a class="code" href="../../d5/d5/cc_8h.html#a98">PVACB</a> <a class="code" href="../../d5/d2/cachedat_8c.html#a20">CcVacbs</a>;
<a name="l02021"></a><a class="code" href="../../d5/d5/cc_8h.html#a145">02021</a> <span class="keyword">extern</span> <a class="code" href="../../d5/d5/cc_8h.html#a98">PVACB</a> <a class="code" href="../../d5/d2/cachedat_8c.html#a21">CcBeyondVacbs</a>;
<a name="l02022"></a><a class="code" href="../../d5/d5/cc_8h.html#a146">02022</a> <span class="keyword">extern</span> LIST_ENTRY <a class="code" href="../../d5/d2/cachedat_8c.html#a22">CcVacbLru</a>;
<a name="l02023"></a><a class="code" href="../../d5/d5/cc_8h.html#a147">02023</a> <span class="keyword">extern</span> KSPIN_LOCK <a class="code" href="../../d5/d2/cachedat_8c.html#a28">CcDeferredWriteSpinLock</a>;
<a name="l02024"></a><a class="code" href="../../d5/d5/cc_8h.html#a148">02024</a> <span class="keyword">extern</span> LIST_ENTRY <a class="code" href="../../d5/d2/cachedat_8c.html#a29">CcDeferredWrites</a>;
<a name="l02025"></a><a class="code" href="../../d5/d5/cc_8h.html#a149">02025</a> <span class="keyword">extern</span> ULONG <a class="code" href="../../d5/d2/cachedat_8c.html#a30">CcDirtyPageThreshold</a>;
<a name="l02026"></a><a class="code" href="../../d5/d5/cc_8h.html#a150">02026</a> <span class="keyword">extern</span> ULONG <a class="code" href="../../d5/d2/cachedat_8c.html#a31">CcDirtyPageTarget</a>;
<a name="l02027"></a><a class="code" href="../../d5/d5/cc_8h.html#a151">02027</a> <span class="keyword">extern</span> ULONG <a class="code" href="../../d5/d2/cachedat_8c.html#a34">CcDirtyPagesLastScan</a>;
<a name="l02028"></a><a class="code" href="../../d5/d5/cc_8h.html#a152">02028</a> <span class="keyword">extern</span> ULONG <a class="code" href="../../d5/d2/cachedat_8c.html#a32">CcPagesYetToWrite</a>;
<a name="l02029"></a><a class="code" href="../../d5/d5/cc_8h.html#a153">02029</a> <span class="keyword">extern</span> ULONG <a class="code" href="../../d5/d2/cachedat_8c.html#a33">CcPagesWrittenLastTime</a>;
<a name="l02030"></a><a class="code" href="../../d5/d5/cc_8h.html#a154">02030</a> <span class="keyword">extern</span> ULONG <a class="code" href="../../d5/d2/cachedat_8c.html#a35">CcAvailablePagesThreshold</a>;
<a name="l02031"></a><a class="code" href="../../d5/d5/cc_8h.html#a155">02031</a> <span class="keyword">extern</span> ULONG <a class="code" href="../../d5/d2/cachedat_8c.html#a36">CcTotalDirtyPages</a>;
<a name="l02032"></a><a class="code" href="../../d5/d5/cc_8h.html#a156">02032</a> <span class="keyword">extern</span> ULONG <a class="code" href="../../d5/d2/cachedat_8c.html#a40">CcTune</a>;
<a name="l02033"></a><a class="code" href="../../d5/d5/cc_8h.html#a157">02033</a> <span class="keyword">extern</span> LONG <a class="code" href="../../d5/d2/cachedat_8c.html#a38">CcAggressiveZeroCount</a>;
<a name="l02034"></a><a class="code" href="../../d5/d5/cc_8h.html#a158">02034</a> <span class="keyword">extern</span> LONG <a class="code" href="../../d5/d2/cachedat_8c.html#a39">CcAggressiveZeroThreshold</a>;
<a name="l02035"></a><a class="code" href="../../d5/d5/cc_8h.html#a159">02035</a> <span class="keyword">extern</span> ULONG <a class="code" href="../../d5/d2/cachedat_8c.html#a70">CcLazyWriteHotSpots</a>;
<a name="l02036"></a><a class="code" href="../../d5/d5/cc_8h.html#a160">02036</a> <span class="keyword">extern</span> <a class="code" href="../../d2/d1/mm_8h.html#a140">MM_SYSTEMSIZE</a> <a class="code" href="../../d5/d2/cachedat_8c.html#a37">CcCapturedSystemSize</a>;
<a name="l02037"></a><a class="code" href="../../d5/d5/cc_8h.html#a161">02037</a> <span class="keyword">extern</span> ULONG <a class="code" href="../../d5/d2/cachedat_8c.html#a23">CcMaxVacbLevelsSeen</a>;
<a name="l02038"></a><a class="code" href="../../d5/d5/cc_8h.html#a162">02038</a> <span class="keyword">extern</span> ULONG <a class="code" href="../../d5/d2/cachedat_8c.html#a24">CcVacbLevelEntries</a>;
<a name="l02039"></a><a class="code" href="../../d5/d5/cc_8h.html#a163">02039</a> <span class="keyword">extern</span> <a class="code" href="../../d5/d5/cc_8h.html#a98">PVACB</a> *<a class="code" href="../../d5/d2/cachedat_8c.html#a25">CcVacbLevelFreeList</a>;
<a name="l02040"></a><a class="code" href="../../d5/d5/cc_8h.html#a164">02040</a> <span class="keyword">extern</span> ULONG <a class="code" href="../../d5/d2/cachedat_8c.html#a26">CcVacbLevelWithBcbsEntries</a>;
<a name="l02041"></a><a class="code" href="../../d5/d5/cc_8h.html#a165">02041</a> <span class="keyword">extern</span> <a class="code" href="../../d5/d5/cc_8h.html#a98">PVACB</a> *<a class="code" href="../../d5/d2/cachedat_8c.html#a27">CcVacbLevelWithBcbsFreeList</a>;
02042 
02043 <span class="comment">//</span>
02044 <span class="comment">//  Macros for allocating and deallocating Vacb levels - CcVacbSpinLock must</span>
02045 <span class="comment">//  be acquired.</span>
02046 <span class="comment">//</span>
02047 
<a name="l02048"></a><a class="code" href="../../d5/d5/cc_8h.html#a206">02048</a> _inline <a class="code" href="../../d5/d5/cc_8h.html#a98">PVACB</a> *<a class="code" href="../../d5/d5/cc_8h.html#a206">CcAllocateVacbLevel</a> (
02049     IN BOOLEAN AllocatingBcbListHeads
02050     )
02051 
02052 {
02053     <a class="code" href="../../d5/d5/cc_8h.html#a98">PVACB</a> *ReturnEntry;
02054 
02055     <span class="keywordflow">if</span> (AllocatingBcbListHeads) {
02056         ReturnEntry = <a class="code" href="../../d5/d2/cachedat_8c.html#a27">CcVacbLevelWithBcbsFreeList</a>;
02057         <a class="code" href="../../d5/d2/cachedat_8c.html#a27">CcVacbLevelWithBcbsFreeList</a> = (<a class="code" href="../../d5/d5/cc_8h.html#a98">PVACB</a> *)*ReturnEntry;
02058         <a class="code" href="../../d5/d2/cachedat_8c.html#a26">CcVacbLevelWithBcbsEntries</a> -= 1;
02059     } <span class="keywordflow">else</span> {
02060         ReturnEntry = <a class="code" href="../../d5/d2/cachedat_8c.html#a25">CcVacbLevelFreeList</a>;
02061         <a class="code" href="../../d5/d2/cachedat_8c.html#a25">CcVacbLevelFreeList</a> = (<a class="code" href="../../d5/d5/cc_8h.html#a98">PVACB</a> *)*ReturnEntry;
02062         <a class="code" href="../../d5/d2/cachedat_8c.html#a24">CcVacbLevelEntries</a> -= 1;
02063     }
02064     *ReturnEntry = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02065     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(RtlCompareMemory(ReturnEntry, ReturnEntry + 1, <a class="code" href="../../d5/d5/cc_8h.html#a39">VACB_LEVEL_BLOCK_SIZE</a> - <span class="keyword">sizeof</span>(<a class="code" href="../../d5/d5/cc_8h.html#a98">PVACB</a>)) ==
02066                                                           (<a class="code" href="../../d5/d5/cc_8h.html#a39">VACB_LEVEL_BLOCK_SIZE</a> - <span class="keyword">sizeof</span>(<a class="code" href="../../d5/d5/cc_8h.html#a98">PVACB</a>)));
02067     <span class="keywordflow">return</span> ReturnEntry;
02068 }
02069 
<a name="l02070"></a><a class="code" href="../../d5/d5/cc_8h.html#a207">02070</a> _inline <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a> <a class="code" href="../../d5/d5/cc_8h.html#a207">CcDeallocateVacbLevel</a> (
02071     IN PVACB *Entry,
02072     IN BOOLEAN DeallocatingBcbListHeads
02073     )
02074 
02075 {
02076     <span class="keywordflow">if</span> (DeallocatingBcbListHeads) {
02077         *Entry = (<a class="code" href="../../d5/d5/cc_8h.html#a98">PVACB</a>)<a class="code" href="../../d5/d2/cachedat_8c.html#a27">CcVacbLevelWithBcbsFreeList</a>;
02078         <a class="code" href="../../d5/d2/cachedat_8c.html#a27">CcVacbLevelWithBcbsFreeList</a> = Entry;
02079         <a class="code" href="../../d5/d2/cachedat_8c.html#a26">CcVacbLevelWithBcbsEntries</a> += 1;
02080     } <span class="keywordflow">else</span> {
02081         *Entry = (<a class="code" href="../../d5/d5/cc_8h.html#a98">PVACB</a>)<a class="code" href="../../d5/d2/cachedat_8c.html#a25">CcVacbLevelFreeList</a>;
02082         <a class="code" href="../../d5/d2/cachedat_8c.html#a25">CcVacbLevelFreeList</a> = Entry;
02083         <a class="code" href="../../d5/d2/cachedat_8c.html#a24">CcVacbLevelEntries</a> += 1;
02084     }
02085 }
02086 
02087 <span class="comment">//</span>
02088 <span class="comment">//  Export the macros for inspecting the reference counts for</span>
02089 <span class="comment">//  the multilevel Vacb array.</span>
02090 <span class="comment">//</span>
02091 
02092 _inline
02093 <a class="code" href="../../d5/d5/cc_8h.html#a96">PVACB_LEVEL_REFERENCE</a>
<a name="l02094"></a><a class="code" href="../../d5/d5/cc_8h.html#a208">02094</a> <a class="code" href="../../d5/d5/cc_8h.html#a208">VacbLevelReference</a> (
02095     IN PSHARED_CACHE_MAP SharedCacheMap,
02096     IN PVACB *VacbArray,
02097     IN ULONG Level
02098     )
02099 {
02100     <span class="keywordflow">return</span> (<a class="code" href="../../d5/d5/cc_8h.html#a96">PVACB_LEVEL_REFERENCE</a>)
02101            ((PCHAR)VacbArray +
02102             <a class="code" href="../../d5/d5/cc_8h.html#a39">VACB_LEVEL_BLOCK_SIZE</a> +
02103             (Level != 0?
02104              0 : (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( SharedCacheMap-&gt;Flags, <a class="code" href="../../d5/d5/cc_8h.html#a78">MODIFIED_WRITE_DISABLED</a> )?
02105                   <a class="code" href="../../d5/d5/cc_8h.html#a39">VACB_LEVEL_BLOCK_SIZE</a> : 0)));
02106 }
02107 
02108 _inline
02109 ULONG
<a name="l02110"></a><a class="code" href="../../d5/d5/cc_8h.html#a209">02110</a> <a class="code" href="../../d5/d5/cc_8h.html#a209">IsVacbLevelReferenced</a> (
02111     IN PSHARED_CACHE_MAP SharedCacheMap,
02112     IN PVACB *VacbArray,
02113     IN ULONG Level
02114     )
02115 {
02116     <a class="code" href="../../d5/d5/cc_8h.html#a96">PVACB_LEVEL_REFERENCE</a> VacbReference = <a class="code" href="../../d5/d5/cc_8h.html#a208">VacbLevelReference</a>( SharedCacheMap, VacbArray, Level );
02117 
02118     <span class="keywordflow">return</span> VacbReference-&gt;<a class="code" href="../../d4/d5/struct__VACB__LEVEL__REFERENCE.html#o0">Reference</a> | VacbReference-&gt;<a class="code" href="../../d4/d5/struct__VACB__LEVEL__REFERENCE.html#o1">SpecialReference</a>;
02119 }
02120 
02121 
02122 <span class="comment">//</span>
02123 <span class="comment">//  Here is a page of macros stolen directly from Pinball...</span>
02124 <span class="comment">//</span>
02125 
02126 <span class="comment">//</span>
02127 <span class="comment">//  The following macros are used to establish the semantics needed</span>
02128 <span class="comment">//  to do a return from within a try-finally clause.  As a rule every</span>
02129 <span class="comment">//  try clause must end with a label call try_exit.  For example,</span>
02130 <span class="comment">//</span>
02131 <span class="comment">//      try {</span>
02132 <span class="comment">//              :</span>
02133 <span class="comment">//              :</span>
02134 <span class="comment">//</span>
02135 <span class="comment">//      try_exit: NOTHING;</span>
02136 <span class="comment">//      } finally {</span>
02137 <span class="comment">//</span>
02138 <span class="comment">//              :</span>
02139 <span class="comment">//              :</span>
02140 <span class="comment">//      }</span>
02141 <span class="comment">//</span>
02142 <span class="comment">//  Every return statement executed inside of a try clause should use the</span>
02143 <span class="comment">//  try_return macro.  If the compiler fully supports the try-finally construct</span>
02144 <span class="comment">//  then the macro should be</span>
02145 <span class="comment">//</span>
02146 <span class="comment">//      #define try_return(S)  { return(S); }</span>
02147 <span class="comment">//</span>
02148 <span class="comment">//  If the compiler does not support the try-finally construct then the macro</span>
02149 <span class="comment">//  should be</span>
02150 <span class="comment">//</span>
02151 <span class="comment">//      #define try_return(S)  { S; goto try_exit; }</span>
02152 <span class="comment">//</span>
02153 
<a name="l02154"></a><a class="code" href="../../d5/d5/cc_8h.html#a90">02154</a> <span class="preprocessor">#define try_return(S) { S; goto try_exit; }</span>
02155 <span class="preprocessor"></span>
02156 <span class="preprocessor">#ifdef CCDBG</span>
02157 <span class="preprocessor"></span>
02158 <span class="keyword">extern</span> LONG CcDebugTraceLevel;
02159 <span class="keyword">extern</span> LONG CcDebugTraceIndent;
02160 
02161 <span class="preprocessor">#ifndef CCDBG_LOCK</span>
02162 <span class="preprocessor"></span>
02163 <span class="preprocessor">#define DebugTrace(INDENT,LEVEL,X,Y) {                     \</span>
02164 <span class="preprocessor">    LONG _i;                                               \</span>
02165 <span class="preprocessor">    if (((LEVEL) == 0) || (CcDebugTraceLevel &amp; (LEVEL))) { \</span>
02166 <span class="preprocessor">        _i = (ULONG)PsGetCurrentThread();                  \</span>
02167 <span class="preprocessor">        DbgPrint("%08lx:",_i);                             \</span>
02168 <span class="preprocessor">        if ((INDENT) &lt; 0) {                                \</span>
02169 <span class="preprocessor">            CcDebugTraceIndent += (INDENT);                \</span>
02170 <span class="preprocessor">        }                                                  \</span>
02171 <span class="preprocessor">        if (CcDebugTraceIndent &lt; 0) {                      \</span>
02172 <span class="preprocessor">            CcDebugTraceIndent = 0;                        \</span>
02173 <span class="preprocessor">        }                                                  \</span>
02174 <span class="preprocessor">        for (_i=0; _i&lt;CcDebugTraceIndent; _i+=1) {         \</span>
02175 <span class="preprocessor">            DbgPrint(" ");                                 \</span>
02176 <span class="preprocessor">        }                                                  \</span>
02177 <span class="preprocessor">        DbgPrint(X,Y);                                     \</span>
02178 <span class="preprocessor">        if ((INDENT) &gt; 0) {                                \</span>
02179 <span class="preprocessor">            CcDebugTraceIndent += (INDENT);                \</span>
02180 <span class="preprocessor">        }                                                  \</span>
02181 <span class="preprocessor">    }                                                      \</span>
02182 <span class="preprocessor">}</span>
02183 <span class="preprocessor"></span>
02184 <span class="preprocessor">#define DebugTrace2(INDENT,LEVEL,X,Y,Z) {                  \</span>
02185 <span class="preprocessor">    LONG _i;                                               \</span>
02186 <span class="preprocessor">    if (((LEVEL) == 0) || (CcDebugTraceLevel &amp; (LEVEL))) { \</span>
02187 <span class="preprocessor">        _i = (ULONG)PsGetCurrentThread();                  \</span>
02188 <span class="preprocessor">        DbgPrint("%08lx:",_i);                             \</span>
02189 <span class="preprocessor">        if ((INDENT) &lt; 0) {                                \</span>
02190 <span class="preprocessor">            CcDebugTraceIndent += (INDENT);                \</span>
02191 <span class="preprocessor">        }                                                  \</span>
02192 <span class="preprocessor">        if (CcDebugTraceIndent &lt; 0) {                      \</span>
02193 <span class="preprocessor">            CcDebugTraceIndent = 0;                        \</span>
02194 <span class="preprocessor">        }                                                  \</span>
02195 <span class="preprocessor">        for (_i=0; _i&lt;CcDebugTraceIndent; _i+=1) {         \</span>
02196 <span class="preprocessor">            DbgPrint(" ");                                 \</span>
02197 <span class="preprocessor">        }                                                  \</span>
02198 <span class="preprocessor">        DbgPrint(X,Y,Z);                                   \</span>
02199 <span class="preprocessor">        if ((INDENT) &gt; 0) {                                \</span>
02200 <span class="preprocessor">            CcDebugTraceIndent += (INDENT);                \</span>
02201 <span class="preprocessor">        }                                                  \</span>
02202 <span class="preprocessor">    }                                                      \</span>
02203 <span class="preprocessor">}</span>
02204 <span class="preprocessor"></span>
02205 <span class="preprocessor">#define DebugDump(STR,LEVEL,PTR) {                         \</span>
02206 <span class="preprocessor">    LONG _i;                                               \</span>
02207 <span class="preprocessor">    VOID CcDump();                                         \</span>
02208 <span class="preprocessor">    if (((LEVEL) == 0) || (CcDebugTraceLevel &amp; (LEVEL))) { \</span>
02209 <span class="preprocessor">        _i = (ULONG)PsGetCurrentThread();                  \</span>
02210 <span class="preprocessor">        DbgPrint("%08lx:",_i);                             \</span>
02211 <span class="preprocessor">        DbgPrint(STR);                                     \</span>
02212 <span class="preprocessor">        if (PTR != NULL) {CcDump(PTR);}                    \</span>
02213 <span class="preprocessor">        DbgBreakPoint();                                   \</span>
02214 <span class="preprocessor">    }                                                      \</span>
02215 <span class="preprocessor">}</span>
02216 <span class="preprocessor"></span>
02217 <span class="preprocessor">#else //  ndef CCDBG_LOCK</span>
02218 <span class="preprocessor"></span>
02219 <span class="keyword">extern</span> KSPIN_LOCK <a class="code" href="../../d4/d4/alpha_2splocks_8c.html#a2">CcDebugTraceLock</a>;
02220 
02221 <span class="preprocessor">#define DebugTrace(INDENT,LEVEL,X,Y) {                     \</span>
02222 <span class="preprocessor">    LONG _i;                                               \</span>
02223 <span class="preprocessor">    KIRQL _oldIrql;                                        \</span>
02224 <span class="preprocessor">    if (((LEVEL) == 0) || (CcDebugTraceLevel &amp; (LEVEL))) { \</span>
02225 <span class="preprocessor">        _i = (ULONG)PsGetCurrentThread();                  \</span>
02226 <span class="preprocessor">        ExAcquireSpinLock( &amp;CcDebugTraceLock, &amp;_oldIrql ); \</span>
02227 <span class="preprocessor">        DbgPrint("%08lx:",_i);                             \</span>
02228 <span class="preprocessor">        if ((INDENT) &lt; 0) {                                \</span>
02229 <span class="preprocessor">            CcDebugTraceIndent += (INDENT);                \</span>
02230 <span class="preprocessor">        }                                                  \</span>
02231 <span class="preprocessor">        if (CcDebugTraceIndent &lt; 0) {                      \</span>
02232 <span class="preprocessor">            CcDebugTraceIndent = 0;                        \</span>
02233 <span class="preprocessor">        }                                                  \</span>
02234 <span class="preprocessor">        for (_i=0; _i&lt;CcDebugTraceIndent; _i+=1) {         \</span>
02235 <span class="preprocessor">            DbgPrint(" ");                                 \</span>
02236 <span class="preprocessor">        }                                                  \</span>
02237 <span class="preprocessor">        DbgPrint(X,Y);                                     \</span>
02238 <span class="preprocessor">        if ((INDENT) &gt; 0) {                                \</span>
02239 <span class="preprocessor">            CcDebugTraceIndent += (INDENT);                \</span>
02240 <span class="preprocessor">        }                                                  \</span>
02241 <span class="preprocessor">        ExReleaseSpinLock( &amp;CcDebugTraceLock, _oldIrql );  \</span>
02242 <span class="preprocessor">    }                                                      \</span>
02243 <span class="preprocessor">}</span>
02244 <span class="preprocessor"></span>
02245 <span class="preprocessor">#define DebugTrace2(INDENT,LEVEL,X,Y,Z) {                  \</span>
02246 <span class="preprocessor">    LONG _i;                                               \</span>
02247 <span class="preprocessor">    KIRQL _oldIrql;                                        \</span>
02248 <span class="preprocessor">    if (((LEVEL) == 0) || (CcDebugTraceLevel &amp; (LEVEL))) { \</span>
02249 <span class="preprocessor">        _i = (ULONG)PsGetCurrentThread();                  \</span>
02250 <span class="preprocessor">        ExAcquireSpinLock( &amp;CcDebugTraceLock, &amp;_oldIrql ); \</span>
02251 <span class="preprocessor">        DbgPrint("%08lx:",_i);                             \</span>
02252 <span class="preprocessor">        if ((INDENT) &lt; 0) {                                \</span>
02253 <span class="preprocessor">            CcDebugTraceIndent += (INDENT);                \</span>
02254 <span class="preprocessor">        }                                                  \</span>
02255 <span class="preprocessor">        if (CcDebugTraceIndent &lt; 0) {                      \</span>
02256 <span class="preprocessor">            CcDebugTraceIndent = 0;                        \</span>
02257 <span class="preprocessor">        }                                                  \</span>
02258 <span class="preprocessor">        for (_i=0; _i&lt;CcDebugTraceIndent; _i+=1) {         \</span>
02259 <span class="preprocessor">            DbgPrint(" ");                                 \</span>
02260 <span class="preprocessor">        }                                                  \</span>
02261 <span class="preprocessor">        DbgPrint(X,Y,Z);                                   \</span>
02262 <span class="preprocessor">        if ((INDENT) &gt; 0) {                                \</span>
02263 <span class="preprocessor">            CcDebugTraceIndent += (INDENT);                \</span>
02264 <span class="preprocessor">        }                                                  \</span>
02265 <span class="preprocessor">      ExReleaseSpinLock( &amp;CcDebugTraceLock, _oldIrql );  \</span>
02266 <span class="preprocessor">    }                                                      \</span>
02267 <span class="preprocessor">}</span>
02268 <span class="preprocessor"></span>
02269 <span class="preprocessor">#define DebugDump(STR,LEVEL,PTR) {                         \</span>
02270 <span class="preprocessor">    LONG _i;                                               \</span>
02271 <span class="preprocessor">    KIRQL _oldIrql;                                        \</span>
02272 <span class="preprocessor">    VOID CcDump();                                         \</span>
02273 <span class="preprocessor">    if (((LEVEL) == 0) || (CcDebugTraceLevel &amp; (LEVEL))) { \</span>
02274 <span class="preprocessor">        _i = (ULONG)PsGetCurrentThread();                  \</span>
02275 <span class="preprocessor">      ExAcquireSpinLock( &amp;CcDebugTraceLock, &amp;_oldIrql ); \</span>
02276 <span class="preprocessor">        DbgPrint("%08lx:",_i);                             \</span>
02277 <span class="preprocessor">        DbgPrint(STR);                                     \</span>
02278 <span class="preprocessor">        if (PTR != NULL) {CcDump(PTR);}                    \</span>
02279 <span class="preprocessor">        DbgBreakPoint();                                   \</span>
02280 <span class="preprocessor">      ExReleaseSpinLock( &amp;CcDebugTraceLock, _oldIrql );  \</span>
02281 <span class="preprocessor">    }                                                      \</span>
02282 <span class="preprocessor">}</span>
02283 <span class="preprocessor"></span>
02284 <span class="preprocessor">#endif //  else ndef CCDBG_LOCK</span>
02285 <span class="preprocessor"></span>
02286 <span class="preprocessor">#else</span>
02287 <span class="preprocessor"></span>
02288 <span class="preprocessor">#undef CCDBG_LOCK</span>
02289 <span class="preprocessor"></span>
<a name="l02290"></a><a class="code" href="../../d5/d5/cc_8h.html#a91">02290</a> <span class="preprocessor">#define DebugTrace(INDENT,LEVEL,X,Y) {NOTHING;}</span>
02291 <span class="preprocessor"></span>
<a name="l02292"></a><a class="code" href="../../d5/d5/cc_8h.html#a92">02292</a> <span class="preprocessor">#define DebugTrace2(INDENT,LEVEL,X,Y,Z) {NOTHING;}</span>
02293 <span class="preprocessor"></span>
<a name="l02294"></a><a class="code" href="../../d5/d5/cc_8h.html#a93">02294</a> <span class="preprocessor">#define DebugDump(STR,LEVEL,PTR) {NOTHING;}</span>
02295 <span class="preprocessor"></span>
02296 <span class="preprocessor">#endif //  CCDBG</span>
02297 <span class="preprocessor"></span>
02298 <span class="comment">//</span>
02299 <span class="comment">//  Global list of pinned Bcbs which may be examined for debug purposes</span>
02300 <span class="comment">//</span>
02301 
02302 <span class="preprocessor">#if DBG</span>
02303 <span class="preprocessor"></span>
02304 <span class="keyword">extern</span> ULONG CcBcbCount;
02305 <span class="keyword">extern</span> LIST_ENTRY CcBcbList;
02306 
02307 <span class="preprocessor">#endif</span>
02308 <span class="preprocessor"></span>
02309 <span class="preprocessor">#endif  //  _CCh_</span>
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:39:21 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
