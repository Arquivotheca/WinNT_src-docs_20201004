<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: csrutil.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>csrutil.c</h1><a href="../../d5/d0/csrutil_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1989  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    dllutil.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module contains utility procedures for the Windows Client DLL</span>
00012 <span class="comment"></span>
00013 <span class="comment"></span>
00014 <span class="comment">Author:</span>
00015 <span class="comment"></span>
00016 <span class="comment">    Steve Wood (stevewo) 8-Oct-1990</span>
00017 <span class="comment"></span>
00018 <span class="comment">Revision History:</span>
00019 <span class="comment"></span>
00020 <span class="comment">--*/</span>
00021 
00022 <span class="preprocessor">#include "<a class="code" href="../../d9/d9/csrdll_8h.html">csrdll.h</a>"</span>
00023 
00024 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00025"></a><a class="code" href="../../d5/d0/csrutil_8c.html#a0">00025</a> <a class="code" href="../../d8/d9/wow64csr_8c.html#a4">CsrClientCallServer</a>(
00026     IN OUT PCSR_API_MSG m,
00027     IN OUT PCSR_CAPTURE_HEADER CaptureBuffer OPTIONAL,
00028     IN CSR_API_NUMBER ApiNumber,
00029     IN ULONG ArgLength
00030     )
00031 
00032 <span class="comment">/*++</span>
00033 <span class="comment"></span>
00034 <span class="comment">Routine Description:</span>
00035 <span class="comment"></span>
00036 <span class="comment">    This function sends an API request to the Windows Emulation Subsystem</span>
00037 <span class="comment">    Server and waits for a reply.</span>
00038 <span class="comment"></span>
00039 <span class="comment">Arguments:</span>
00040 <span class="comment"></span>
00041 <span class="comment">    m - Pointer to the API request message to send.</span>
00042 <span class="comment"></span>
00043 <span class="comment">    CaptureBuffer - Optional pointer to a capture buffer located in the</span>
00044 <span class="comment">        Port Memory section that contains additional data being sent</span>
00045 <span class="comment">        to the server.  Since Port Memory is also visible to the server,</span>
00046 <span class="comment">        no data needs to be copied, but pointers to locations within the</span>
00047 <span class="comment">        capture buffer need to be converted into pointers valid in the</span>
00048 <span class="comment">        server's process context, since the server's view of the Port Memory</span>
00049 <span class="comment">        is not at the same virtual address as the client's view.</span>
00050 <span class="comment"></span>
00051 <span class="comment">    ApiNumber - Small integer that is the number of the API being called.</span>
00052 <span class="comment"></span>
00053 <span class="comment">    ArgLength - Length, in bytes, of the argument portion located at the</span>
00054 <span class="comment">        end of the request message.  Used to calculate the length of the</span>
00055 <span class="comment">        request message.</span>
00056 <span class="comment"></span>
00057 <span class="comment">Return Value:</span>
00058 <span class="comment"></span>
00059 <span class="comment">    Status Code from either client or server</span>
00060 <span class="comment"></span>
00061 <span class="comment">--*/</span>
00062 
00063 {
00064     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00065     PULONG_PTR PointerOffsets;
00066     ULONG CountPointers;
00067     ULONG_PTR Pointer;
00068 
00069     <span class="comment">//</span>
00070     <span class="comment">// Initialize the header of the message.</span>
00071     <span class="comment">//</span>
00072 
00073     <span class="keywordflow">if</span> ((LONG)ArgLength &lt; 0) {
00074         ArgLength = (ULONG)(-(LONG)ArgLength);
00075         m-&gt;h.u2.s2.Type = 0;
00076         }
00077     <span class="keywordflow">else</span> {
00078         m-&gt;h.u2.ZeroInit = 0;
00079         }
00080 
00081     ArgLength |= (ArgLength &lt;&lt; 16);
00082     ArgLength +=     ((<span class="keyword">sizeof</span>( CSR_API_MSG ) - <span class="keyword">sizeof</span>( m-&gt;u )) &lt;&lt; 16) |
00083                      (FIELD_OFFSET( CSR_API_MSG, u ) - <span class="keyword">sizeof</span>( m-&gt;h ));
00084     m-&gt;h.u1.Length = ArgLength;
00085     m-&gt;CaptureBuffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00086     m-&gt;ApiNumber = ApiNumber;
00087 
00088     <span class="comment">//</span>
00089     <span class="comment">// if the caller is within the server process, do the API call directly</span>
00090     <span class="comment">// and skip the capture buffer fixups and LPC call.</span>
00091     <span class="comment">//</span>
00092 
00093     <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/csrdll_8h.html#a9">CsrServerProcess</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
00094 
00095         <span class="comment">//</span>
00096         <span class="comment">// If the CaptureBuffer argument is present, then there is data located</span>
00097         <span class="comment">// in the Port Memory section that is being passed to the server.  All</span>
00098         <span class="comment">// Port Memory pointers need to be converted so they are valid in the</span>
00099         <span class="comment">// Server's view of the Port Memory.</span>
00100         <span class="comment">//</span>
00101 
00102         <span class="keywordflow">if</span> (ARGUMENT_PRESENT( CaptureBuffer )) {
00103             <span class="comment">//</span>
00104             <span class="comment">// Store a pointer to the capture buffer in the message that is valid</span>
00105             <span class="comment">// in the server process's context.</span>
00106             <span class="comment">//</span>
00107 
00108             m-&gt;CaptureBuffer = (PCSR_CAPTURE_HEADER)
00109                 ((PCHAR)CaptureBuffer + <a class="code" href="../../d9/d9/csrdll_8h.html#a17">CsrPortMemoryRemoteDelta</a>);
00110 
00111             <span class="comment">//</span>
00112             <span class="comment">// Mark the fact that we are done allocating space from the end of</span>
00113             <span class="comment">// the capture buffer.</span>
00114             <span class="comment">//</span>
00115 
00116             CaptureBuffer-&gt;FreeSpace = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00117 
00118             <span class="comment">//</span>
00119             <span class="comment">// Loop over all of the pointers to Port Memory within the message</span>
00120             <span class="comment">// itself and convert them into server pointers.  Also, convert</span>
00121             <span class="comment">// the pointers to pointers into offsets.</span>
00122             <span class="comment">//</span>
00123 
00124             PointerOffsets = CaptureBuffer-&gt;MessagePointerOffsets;
00125             CountPointers = CaptureBuffer-&gt;CountMessagePointers;
00126             <span class="keywordflow">while</span> (CountPointers--) {
00127                 Pointer = *PointerOffsets++;
00128                 <span class="keywordflow">if</span> (Pointer != 0) {
00129                     *(PULONG_PTR)Pointer += <a class="code" href="../../d9/d9/csrdll_8h.html#a17">CsrPortMemoryRemoteDelta</a>;
00130                     PointerOffsets[ -1 ] = Pointer - (ULONG_PTR)m;
00131                     }
00132                 }
00133             }
00134 
00135         <span class="comment">//</span>
00136         <span class="comment">// Send the request to the server and wait for a reply.  The wait is</span>
00137         <span class="comment">// NOT alertable, because ? FIX,FIX</span>
00138         <span class="comment">//</span>
00139 
00140         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d6/d7/lpcsend_8c.html#a1">NtRequestWaitReplyPort</a>( <a class="code" href="../../d9/d9/csrdll_8h.html#a15">CsrPortHandle</a>,
00141                                          (PPORT_MESSAGE)m,
00142                                          (PPORT_MESSAGE)m
00143                                        );
00144         <span class="comment">//</span>
00145         <span class="comment">// If the CaptureBuffer argument is present then reverse what we did</span>
00146         <span class="comment">// to the pointers above so that the client side code can use them</span>
00147         <span class="comment">// again.</span>
00148         <span class="comment">//</span>
00149 
00150         <span class="keywordflow">if</span> (ARGUMENT_PRESENT( CaptureBuffer )) {
00151             <span class="comment">//</span>
00152             <span class="comment">// Convert the capture buffer pointer back to a client pointer.</span>
00153             <span class="comment">//</span>
00154 
00155             m-&gt;CaptureBuffer = (PCSR_CAPTURE_HEADER)
00156                 ((PCHAR)m-&gt;CaptureBuffer - <a class="code" href="../../d9/d9/csrdll_8h.html#a17">CsrPortMemoryRemoteDelta</a>);
00157 
00158             <span class="comment">//</span>
00159             <span class="comment">// Loop over all of the pointers to Port Memory within the message</span>
00160             <span class="comment">// itself and convert them into client pointers.  Also, convert</span>
00161             <span class="comment">// the offsets pointers to pointers into back into pointers</span>
00162             <span class="comment">//</span>
00163 
00164             PointerOffsets = CaptureBuffer-&gt;MessagePointerOffsets;
00165             CountPointers = CaptureBuffer-&gt;CountMessagePointers;
00166             <span class="keywordflow">while</span> (CountPointers--) {
00167                 Pointer = *PointerOffsets++;
00168                 <span class="keywordflow">if</span> (Pointer != 0) {
00169                     Pointer += (ULONG_PTR)m;
00170                     PointerOffsets[ -1 ] = Pointer;
00171                     *(PULONG_PTR)Pointer -= <a class="code" href="../../d9/d9/csrdll_8h.html#a17">CsrPortMemoryRemoteDelta</a>;
00172                     }
00173                 }
00174             }
00175 
00176         <span class="comment">//</span>
00177         <span class="comment">// Check for failed status and do something.</span>
00178         <span class="comment">//</span>
00179         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
00180             <a class="code" href="../../d0/d9/ntosdef_8h.html#a9">IF_DEBUG</a> {
00181                 <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> != STATUS_PORT_DISCONNECTED &amp;&amp;
00182                     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> != STATUS_INVALID_HANDLE
00183                    ) {
00184                     <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>( <span class="stringliteral">"CSRDLL: NtRequestWaitReplyPort failed - Status == %X\n"</span>,
00185                               <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>
00186                             );
00187                     }
00188                 }
00189 
00190             m-&gt;ReturnValue = <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00191             }
00192         }
00193     <span class="keywordflow">else</span> {
00194         m-&gt;h.ClientId = NtCurrentTeb()-&gt;ClientId;
00195         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = (<a class="code" href="../../d9/d9/csrdll_8h.html#a10">CsrServerApiRoutine</a>)((PCSR_API_MSG)m,
00196                                        (PCSR_API_MSG)m
00197                                       );
00198 
00199         <span class="comment">//</span>
00200         <span class="comment">// Check for failed status and do something.</span>
00201         <span class="comment">//</span>
00202 
00203         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
00204             <a class="code" href="../../d0/d9/ntosdef_8h.html#a9">IF_DEBUG</a> {
00205                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>( <span class="stringliteral">"CSRDLL: Server side client call failed - Status == %X\n"</span>,
00206                           <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>
00207                         );
00208                 }
00209 
00210             m-&gt;ReturnValue = <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00211             }
00212         }
00213 
00214     <span class="comment">//</span>
00215     <span class="comment">// The value of this function is whatever the server function returned.</span>
00216     <span class="comment">//</span>
00217 
00218     <span class="keywordflow">return</span>( m-&gt;ReturnValue );
00219 }
00220 
00221 
00222 PCSR_CAPTURE_HEADER
<a name="l00223"></a><a class="code" href="../../d5/d0/csrutil_8c.html#a1">00223</a> <a class="code" href="../../d8/d9/wow64csr_8c.html#a5">CsrAllocateCaptureBuffer</a>(
00224     IN ULONG CountMessagePointers,
00225     IN ULONG Size
00226     )
00227 
00228 <span class="comment">/*++</span>
00229 <span class="comment"></span>
00230 <span class="comment">Routine Description:</span>
00231 <span class="comment"></span>
00232 <span class="comment">    This function allocates a buffer from the Port Memory section for</span>
00233 <span class="comment">    use by the client in capture arguments into Port Memory.  In addition to</span>
00234 <span class="comment">    specifying the size of the data that needs to be captured, the caller</span>
00235 <span class="comment">    needs to specify how many pointers to captured data will be passed.</span>
00236 <span class="comment">    Pointers can be located in either the request message itself, and/or</span>
00237 <span class="comment">    the capture buffer.</span>
00238 <span class="comment"></span>
00239 <span class="comment">Arguments:</span>
00240 <span class="comment"></span>
00241 <span class="comment">    CountMessagePointers - Number of pointers within the request message</span>
00242 <span class="comment">        that will point to locations within the allocated capture buffer.</span>
00243 <span class="comment"></span>
00244 <span class="comment">    Size - Total size of the data that will be captured into the capture</span>
00245 <span class="comment">        buffer.</span>
00246 <span class="comment"></span>
00247 <span class="comment">Return Value:</span>
00248 <span class="comment"></span>
00249 <span class="comment">    A pointer to the capture buffer header.</span>
00250 <span class="comment"></span>
00251 <span class="comment">--*/</span>
00252 
00253 {
00254     PCSR_CAPTURE_HEADER CaptureBuffer;
00255     ULONG CountPointers;
00256 
00257     <span class="comment">//</span>
00258     <span class="comment">// Calculate the total number of pointers that will be passed</span>
00259     <span class="comment">//</span>
00260 
00261     CountPointers = CountMessagePointers;
00262 
00263     <span class="comment">//</span>
00264     <span class="comment">// Calculate the total size of the capture buffer.  This includes the</span>
00265     <span class="comment">// header, the array of pointer offsets and the data length.  We round</span>
00266     <span class="comment">// the data length to a 32-bit boundary, assuming that each pointer</span>
00267     <span class="comment">// points to data whose length is not aligned on a 32-bit boundary.</span>
00268     <span class="comment">//</span>
00269 
00270     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> &gt;= MAXLONG) {
00271         <span class="comment">//</span>
00272         <span class="comment">// Bail early if too big</span>
00273         <span class="comment">//</span>
00274         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00275         }
00276     <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> += FIELD_OFFSET(CSR_CAPTURE_HEADER, MessagePointerOffsets) + (CountPointers * <span class="keyword">sizeof</span>( PVOID ));
00277     <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> = (<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> + (3 * (CountPointers+1))) &amp; ~3;
00278 
00279     <span class="comment">//</span>
00280     <span class="comment">// Allocate the capture buffer from the Port Memory Heap.</span>
00281     <span class="comment">//</span>
00282 
00283     CaptureBuffer = <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a0">RtlAllocateHeap</a>( <a class="code" href="../../d9/d9/csrdll_8h.html#a16">CsrPortHeap</a>, <a class="code" href="../../d9/d9/csrdll_8h.html#a5">MAKE_CSRPORT_TAG</a>( <a class="code" href="../../d9/d9/csrdll_8h.html#a6">CAPTURE_TAG</a> ), <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> );
00284     <span class="keywordflow">if</span> (CaptureBuffer == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00285 
00286         <span class="comment">//</span>
00287         <span class="comment">// FIX, FIX - need to attempt the receive lost reply messages to</span>
00288         <span class="comment">// to see if they contain CaptureBuffer pointers that can be freed.</span>
00289         <span class="comment">//</span>
00290 
00291         <span class="keywordflow">return</span>( <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00292     }
00293 
00294     <span class="comment">//</span>
00295     <span class="comment">// Initialize the capture buffer header</span>
00296     <span class="comment">//</span>
00297 
00298     CaptureBuffer-&gt;Length = <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
00299     CaptureBuffer-&gt;CountMessagePointers = 0;
00300 
00301     <span class="comment">//</span>
00302     <span class="comment">// If there are pointers being passed then initialize the arrays of</span>
00303     <span class="comment">// pointer offsets to zero.  In either case set the free space pointer</span>
00304     <span class="comment">// in the capture buffer header to point to the first 32-bit aligned</span>
00305     <span class="comment">// location after the header, the arrays of pointer offsets are considered</span>
00306     <span class="comment">// part of the header.</span>
00307     <span class="comment">//</span>
00308 
00309     RtlZeroMemory( CaptureBuffer-&gt;MessagePointerOffsets,
00310                    CountPointers * <span class="keyword">sizeof</span>( ULONG_PTR )
00311                  );
00312 
00313     CaptureBuffer-&gt;FreeSpace = (PCHAR)
00314         (CaptureBuffer-&gt;MessagePointerOffsets + CountPointers);
00315 
00316     <span class="comment">//</span>
00317     <span class="comment">// Returned the address of the capture buffer.</span>
00318     <span class="comment">//</span>
00319 
00320     <span class="keywordflow">return</span>( CaptureBuffer );
00321 }
00322 
00323 
00324 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00325"></a><a class="code" href="../../d5/d0/csrutil_8c.html#a2">00325</a> <a class="code" href="../../d8/d9/wow64csr_8c.html#a6">CsrFreeCaptureBuffer</a>(
00326     IN PCSR_CAPTURE_HEADER CaptureBuffer
00327     )
00328 
00329 <span class="comment">/*++</span>
00330 <span class="comment"></span>
00331 <span class="comment">Routine Description:</span>
00332 <span class="comment"></span>
00333 <span class="comment">    This function frees a capture buffer allocated by CsrAllocateCaptureBuffer.</span>
00334 <span class="comment"></span>
00335 <span class="comment">Arguments:</span>
00336 <span class="comment"></span>
00337 <span class="comment">    CaptureBuffer - Pointer to a capture buffer allocated by</span>
00338 <span class="comment">        CsrAllocateCaptureBuffer.</span>
00339 <span class="comment"></span>
00340 <span class="comment">Return Value:</span>
00341 <span class="comment"></span>
00342 <span class="comment">    None.</span>
00343 <span class="comment"></span>
00344 <span class="comment">--*/</span>
00345 
00346 {
00347     <span class="comment">//</span>
00348     <span class="comment">// Free the capture buffer back to the Port Memory heap.</span>
00349     <span class="comment">//</span>
00350 
00351     <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>( <a class="code" href="../../d9/d9/csrdll_8h.html#a16">CsrPortHeap</a>, 0, CaptureBuffer );
00352 }
00353 
00354 
00355 ULONG
<a name="l00356"></a><a class="code" href="../../d5/d0/csrutil_8c.html#a3">00356</a> <a class="code" href="../../d8/d9/wow64csr_8c.html#a7">CsrAllocateMessagePointer</a>(
00357     IN OUT PCSR_CAPTURE_HEADER CaptureBuffer,
00358     IN ULONG Length,
00359     OUT PVOID *Pointer
00360     )
00361 
00362 <span class="comment">/*++</span>
00363 <span class="comment"></span>
00364 <span class="comment">Routine Description:</span>
00365 <span class="comment"></span>
00366 <span class="comment">    This function allocates space from the capture buffer along with a</span>
00367 <span class="comment">    pointer to point to it.  The pointer is presumed to be located in</span>
00368 <span class="comment">    the request message structure.</span>
00369 <span class="comment"></span>
00370 <span class="comment">Arguments:</span>
00371 <span class="comment"></span>
00372 <span class="comment">    CaptureBuffer - Pointer to a capture buffer allocated by</span>
00373 <span class="comment">        CsrAllocateCaptureBuffer.</span>
00374 <span class="comment"></span>
00375 <span class="comment">    Length - Size of data being allocated from the capture buffer.</span>
00376 <span class="comment"></span>
00377 <span class="comment">    Pointer - Address of the pointer within the request message that</span>
00378 <span class="comment">        is to point to the space allocated out of the capture buffer.</span>
00379 <span class="comment"></span>
00380 <span class="comment">Return Value:</span>
00381 <span class="comment"></span>
00382 <span class="comment">    The actual length of the buffer allocated, after it has been rounded</span>
00383 <span class="comment">    up to a multiple of 4.</span>
00384 <span class="comment"></span>
00385 <span class="comment">--*/</span>
00386 
00387 {
00388     <span class="keywordflow">if</span> (Length == 0) {
00389         *Pointer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00390         Pointer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00391         }
00392 
00393     <span class="keywordflow">else</span> {
00394 
00395         <span class="comment">//</span>
00396         <span class="comment">// Set the returned pointer value to point to the next free byte in</span>
00397         <span class="comment">// the capture buffer.</span>
00398         <span class="comment">//</span>
00399 
00400         *Pointer = CaptureBuffer-&gt;FreeSpace;
00401 
00402         <span class="comment">//</span>
00403         <span class="comment">// Round the length up to a multiple of 4</span>
00404         <span class="comment">//</span>
00405 
00406         <span class="keywordflow">if</span> (Length &gt;= MAXLONG) {
00407             <span class="comment">//</span>
00408             <span class="comment">// Bail early if too big</span>
00409             <span class="comment">//</span>
00410             <span class="keywordflow">return</span> 0;
00411             }
00412 
00413         Length = (Length + 3) &amp; ~3;
00414 
00415         <span class="comment">//</span>
00416         <span class="comment">// Update the free space pointer to point to the next available byte</span>
00417         <span class="comment">// in the capture buffer.</span>
00418         <span class="comment">//</span>
00419 
00420         CaptureBuffer-&gt;FreeSpace += Length;
00421         }
00422 
00423 
00424     <span class="comment">//</span>
00425     <span class="comment">// Remember the location of this pointer so that CsrClientCallServer can</span>
00426     <span class="comment">// convert it into a server pointer prior to sending the request to</span>
00427     <span class="comment">// the server.</span>
00428     <span class="comment">//</span>
00429 
00430     CaptureBuffer-&gt;MessagePointerOffsets[ CaptureBuffer-&gt;CountMessagePointers++ ] =
00431         (ULONG_PTR)Pointer;
00432 
00433     <span class="comment">//</span>
00434     <span class="comment">// Returned the actual length allocated.</span>
00435     <span class="comment">//</span>
00436 
00437     <span class="keywordflow">return</span>( Length );
00438 }
00439 
00440 
00441 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00442"></a><a class="code" href="../../d5/d0/csrutil_8c.html#a4">00442</a> <a class="code" href="../../d8/d9/wow64csr_8c.html#a8">CsrCaptureMessageBuffer</a>(
00443     IN OUT PCSR_CAPTURE_HEADER CaptureBuffer,
00444     IN PVOID Buffer OPTIONAL,
00445     IN ULONG Length,
00446     OUT PVOID *CapturedBuffer
00447     )
00448 
00449 <span class="comment">/*++</span>
00450 <span class="comment"></span>
00451 <span class="comment">Routine Description:</span>
00452 <span class="comment"></span>
00453 <span class="comment">    This function captures an ASCII string into a counted string data</span>
00454 <span class="comment">    structure located in an API request message.</span>
00455 <span class="comment"></span>
00456 <span class="comment">Arguments:</span>
00457 <span class="comment"></span>
00458 <span class="comment">    CaptureBuffer - Pointer to a capture buffer allocated by</span>
00459 <span class="comment">        CsrAllocateCaptureBuffer.</span>
00460 <span class="comment"></span>
00461 <span class="comment">    Buffer - Optional pointer to the buffer.  If this parameter is</span>
00462 <span class="comment">        not present, then the counted string data structure is set to</span>
00463 <span class="comment">        the null string and no space is allocated from the capture</span>
00464 <span class="comment">        buffer.</span>
00465 <span class="comment"></span>
00466 <span class="comment">    Length - Length of the buffer.</span>
00467 <span class="comment"></span>
00468 <span class="comment">    CaptureString - Pointer to the field in the message that will</span>
00469 <span class="comment">        be filled in to point to the capture buffer.</span>
00470 <span class="comment"></span>
00471 <span class="comment">Return Value:</span>
00472 <span class="comment"></span>
00473 <span class="comment">    None.</span>
00474 <span class="comment"></span>
00475 <span class="comment">--*/</span>
00476 
00477 {
00478     <span class="comment">//</span>
00479     <span class="comment">// Set the length fields of the captured string structure and allocated</span>
00480     <span class="comment">// the Length for the string from the capture buffer.</span>
00481     <span class="comment">//</span>
00482 
00483     <a class="code" href="../../d8/d9/wow64csr_8c.html#a7">CsrAllocateMessagePointer</a>( CaptureBuffer,
00484                                Length,
00485                                CapturedBuffer
00486                              );
00487 
00488     <span class="comment">//</span>
00489     <span class="comment">// If Buffer parameter is not present or the length of the data is zero,</span>
00490     <span class="comment">// return.</span>
00491     <span class="comment">//</span>
00492 
00493     <span class="keywordflow">if</span> (!ARGUMENT_PRESENT( <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> ) || (Length == 0)) {
00494         <span class="keywordflow">return</span>;
00495         }
00496 
00497     <span class="comment">//</span>
00498     <span class="comment">// Copy the buffer data to the capture area.</span>
00499     <span class="comment">//</span>
00500 
00501     RtlMoveMemory( *CapturedBuffer, <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>, Length );
00502 
00503     <span class="keywordflow">return</span>;
00504 }
00505 
00506 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00507"></a><a class="code" href="../../d5/d0/csrutil_8c.html#a5">00507</a> <a class="code" href="../../d8/d9/wow64csr_8c.html#a9">CsrCaptureMessageString</a>(
00508     IN OUT PCSR_CAPTURE_HEADER CaptureBuffer,
00509     IN PCSTR String OPTIONAL,
00510     IN ULONG Length,
00511     IN ULONG MaximumLength,
00512     OUT PSTRING CapturedString
00513     )
00514 
00515 <span class="comment">/*++</span>
00516 <span class="comment"></span>
00517 <span class="comment">Routine Description:</span>
00518 <span class="comment"></span>
00519 <span class="comment">    This function captures an ASCII string into a counted string data</span>
00520 <span class="comment">    structure located in an API request message.</span>
00521 <span class="comment"></span>
00522 <span class="comment">Arguments:</span>
00523 <span class="comment"></span>
00524 <span class="comment">    CaptureBuffer - Pointer to a capture buffer allocated by</span>
00525 <span class="comment">        CsrAllocateCaptureBuffer.</span>
00526 <span class="comment"></span>
00527 <span class="comment">    String - Optional pointer to the ASCII string.  If this parameter is</span>
00528 <span class="comment">        not present, then the counted string data structure is set to</span>
00529 <span class="comment">        the null string and no space is allocated from the capture</span>
00530 <span class="comment">        buffer.</span>
00531 <span class="comment"></span>
00532 <span class="comment">    Length - Length of the ASCII string.</span>
00533 <span class="comment"></span>
00534 <span class="comment">    MaximumLength - Maximum length of the string.  Different for null</span>
00535 <span class="comment">        terminated strings, where Length does not include the null and</span>
00536 <span class="comment">        MaximumLength does.</span>
00537 <span class="comment"></span>
00538 <span class="comment">    CaptureString - Pointer to the counted string data structure that will</span>
00539 <span class="comment">        be filled in to point to the capture ASCII string.</span>
00540 <span class="comment"></span>
00541 <span class="comment">Return Value:</span>
00542 <span class="comment"></span>
00543 <span class="comment">    None.</span>
00544 <span class="comment"></span>
00545 <span class="comment">--*/</span>
00546 
00547 {
00548     <span class="comment">//</span>
00549     <span class="comment">// If String parameter is not present, then set the captured string</span>
00550     <span class="comment">// to be the null string and returned.</span>
00551     <span class="comment">//</span>
00552 
00553     <span class="keywordflow">if</span> (!ARGUMENT_PRESENT( <a class="code" href="../../d4/d9/talloc_8c.html#a0">String</a> )) {
00554         CapturedString-&gt;Length = 0;
00555         CapturedString-&gt;MaximumLength = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)MaximumLength;
00556         <a class="code" href="../../d8/d9/wow64csr_8c.html#a7">CsrAllocateMessagePointer</a>( CaptureBuffer,
00557                                    MaximumLength,
00558                                    (PVOID *)&amp;CapturedString-&gt;Buffer
00559                                  );
00560         <span class="keywordflow">return</span>;
00561         }
00562 
00563     <span class="comment">//</span>
00564     <span class="comment">// Set the length fields of the captured string structure and allocated</span>
00565     <span class="comment">// the MaximumLength for the string from the capture buffer.</span>
00566     <span class="comment">//</span>
00567 
00568     CapturedString-&gt;Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)Length;
00569     CapturedString-&gt;MaximumLength = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)
00570         <a class="code" href="../../d8/d9/wow64csr_8c.html#a7">CsrAllocateMessagePointer</a>( CaptureBuffer,
00571                                    MaximumLength,
00572                                    (PVOID *)&amp;CapturedString-&gt;Buffer
00573                                  );
00574     <span class="comment">//</span>
00575     <span class="comment">// If the Length of the ASCII string is non-zero then move it to the</span>
00576     <span class="comment">// capture area.</span>
00577     <span class="comment">//</span>
00578 
00579     <span class="keywordflow">if</span> (Length != 0) {
00580         RtlMoveMemory( CapturedString-&gt;Buffer, <a class="code" href="../../d4/d9/talloc_8c.html#a0">String</a>, MaximumLength );
00581         <span class="keywordflow">if</span> (CapturedString-&gt;Length &lt; CapturedString-&gt;MaximumLength) {
00582             CapturedString-&gt;Buffer[ CapturedString-&gt;Length ] = <span class="charliteral">'\0'</span>;
00583             }
00584         }
00585 
00586     <span class="keywordflow">return</span>;
00587 }
00588 
00589 
00590 
00591 PLARGE_INTEGER
<a name="l00592"></a><a class="code" href="../../d5/d0/csrutil_8c.html#a6">00592</a> <a class="code" href="../../d8/d9/wow64csr_8c.html#a10">CsrCaptureTimeout</a>(
00593     IN ULONG MilliSeconds,
00594     OUT PLARGE_INTEGER Timeout
00595     )
00596 {
00597     <span class="keywordflow">if</span> (MilliSeconds == -1) {
00598         <span class="keywordflow">return</span>( <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00599         }
00600     <span class="keywordflow">else</span> {
00601         Timeout-&gt;QuadPart = Int32x32To64( MilliSeconds, -10000 );
00602         <span class="keywordflow">return</span>( (PLARGE_INTEGER)Timeout );
00603         }
00604 }
00605 
00606 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00607"></a><a class="code" href="../../d5/d0/csrutil_8c.html#a7">00607</a> <a class="code" href="../../d8/d9/wow64csr_8c.html#a11">CsrProbeForWrite</a>(
00608     IN PVOID Address,
00609     IN ULONG Length,
00610     IN ULONG Alignment
00611     )
00612 
00613 <span class="comment">/*++</span>
00614 <span class="comment"></span>
00615 <span class="comment">Routine Description:</span>
00616 <span class="comment"></span>
00617 <span class="comment">    This function probes a structure for read accessibility.</span>
00618 <span class="comment">    If the structure is not accessible, then an exception is raised.</span>
00619 <span class="comment"></span>
00620 <span class="comment">Arguments:</span>
00621 <span class="comment"></span>
00622 <span class="comment">    Address - Supplies a pointer to the structure to be probed.</span>
00623 <span class="comment"></span>
00624 <span class="comment">    Length - Supplies the length of the structure.</span>
00625 <span class="comment"></span>
00626 <span class="comment">    Alignment - Supplies the required alignment of the structure expressed</span>
00627 <span class="comment">        as the number of bytes in the primitive datatype (e.g., 1 for char,</span>
00628 <span class="comment">        2 for short, 4 for long, and 8 for quad).</span>
00629 <span class="comment"></span>
00630 <span class="comment">Return Value:</span>
00631 <span class="comment"></span>
00632 <span class="comment">    None.</span>
00633 <span class="comment"></span>
00634 <span class="comment">--*/</span>
00635 
00636 {
00637     <span class="keyword">volatile</span> <a class="code" href="../../d1/d1/bench_8c.html#a16">CHAR</a> *StartAddress;
00638     <span class="keyword">volatile</span> <a class="code" href="../../d1/d1/bench_8c.html#a16">CHAR</a> *EndAddress;
00639     <a class="code" href="../../d1/d1/bench_8c.html#a16">CHAR</a> Temp;
00640 
00641     <span class="comment">//</span>
00642     <span class="comment">// If the structure has zero length, then do not probe the structure for</span>
00643     <span class="comment">// write accessibility or alignment.</span>
00644     <span class="comment">//</span>
00645 
00646     <span class="keywordflow">if</span> (Length != 0) {
00647 
00648         <span class="comment">//</span>
00649         <span class="comment">// If the structure is not properly aligned, then raise a data</span>
00650         <span class="comment">// misalignment exception.</span>
00651         <span class="comment">//</span>
00652 
00653         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>((Alignment == 1) || (Alignment == 2) ||
00654                (Alignment == 4) || (Alignment == 8));
00655         StartAddress = (<span class="keyword">volatile</span> <a class="code" href="../../d1/d1/bench_8c.html#a16">CHAR</a> *)Address;
00656 
00657         <span class="keywordflow">if</span> (((ULONG_PTR)StartAddress &amp; (Alignment - 1)) != 0) {
00658             <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a10">RtlRaiseStatus</a>(STATUS_DATATYPE_MISALIGNMENT);
00659         } <span class="keywordflow">else</span> {
00660             <span class="comment">//</span>
00661             <span class="comment">// BUG, BUG - this should not be necessary once the 386 kernel</span>
00662             <span class="comment">// makes system space inaccessable to user mode.</span>
00663             <span class="comment">//</span>
00664             <span class="keywordflow">if</span> ((ULONG_PTR)StartAddress &gt; <a class="code" href="../../d9/d9/csrdll_8h.html#a11">CsrNtSysInfo</a>.MaximumUserModeAddress) {
00665                 <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a10">RtlRaiseStatus</a>(STATUS_ACCESS_VIOLATION);
00666             }
00667 
00668             Temp = *StartAddress;
00669             *StartAddress = Temp;
00670             EndAddress = StartAddress + Length - 1;
00671             Temp = *EndAddress;
00672             *EndAddress = Temp;
00673         }
00674     }
00675 }
00676 
00677 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00678"></a><a class="code" href="../../d5/d0/csrutil_8c.html#a8">00678</a> <a class="code" href="../../d8/d9/wow64csr_8c.html#a12">CsrProbeForRead</a>(
00679     IN PVOID Address,
00680     IN ULONG Length,
00681     IN ULONG Alignment
00682     )
00683 
00684 <span class="comment">/*++</span>
00685 <span class="comment"></span>
00686 <span class="comment">Routine Description:</span>
00687 <span class="comment"></span>
00688 <span class="comment">    This function probes a structure for read accessibility.</span>
00689 <span class="comment">    If the structure is not accessible, then an exception is raised.</span>
00690 <span class="comment"></span>
00691 <span class="comment">Arguments:</span>
00692 <span class="comment"></span>
00693 <span class="comment">    Address - Supplies a pointer to the structure to be probed.</span>
00694 <span class="comment"></span>
00695 <span class="comment">    Length - Supplies the length of the structure.</span>
00696 <span class="comment"></span>
00697 <span class="comment">    Alignment - Supplies the required alignment of the structure expressed</span>
00698 <span class="comment">        as the number of bytes in the primitive datatype (e.g., 1 for char,</span>
00699 <span class="comment">        2 for short, 4 for long, and 8 for quad).</span>
00700 <span class="comment"></span>
00701 <span class="comment">Return Value:</span>
00702 <span class="comment"></span>
00703 <span class="comment">    None.</span>
00704 <span class="comment"></span>
00705 <span class="comment">--*/</span>
00706 
00707 {
00708     <span class="keyword">volatile</span> <a class="code" href="../../d1/d1/bench_8c.html#a16">CHAR</a> *StartAddress;
00709     <span class="keyword">volatile</span> <a class="code" href="../../d1/d1/bench_8c.html#a16">CHAR</a> *EndAddress;
00710     <a class="code" href="../../d1/d1/bench_8c.html#a16">CHAR</a> Temp;
00711 
00712     <span class="comment">//</span>
00713     <span class="comment">// If the structure has zero length, then do not probe the structure for</span>
00714     <span class="comment">// read accessibility or alignment.</span>
00715     <span class="comment">//</span>
00716 
00717     <span class="keywordflow">if</span> (Length != 0) {
00718 
00719         <span class="comment">//</span>
00720         <span class="comment">// If the structure is not properly aligned, then raise a data</span>
00721         <span class="comment">// misalignment exception.</span>
00722         <span class="comment">//</span>
00723 
00724         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>((Alignment == 1) || (Alignment == 2) ||
00725                (Alignment == 4) || (Alignment == 8));
00726         StartAddress = (<span class="keyword">volatile</span> <a class="code" href="../../d1/d1/bench_8c.html#a16">CHAR</a> *)Address;
00727 
00728         <span class="keywordflow">if</span> (((ULONG_PTR)StartAddress &amp; (Alignment - 1)) != 0) {
00729             <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a10">RtlRaiseStatus</a>(STATUS_DATATYPE_MISALIGNMENT);
00730         } <span class="keywordflow">else</span> {
00731             Temp = *StartAddress;
00732             EndAddress = StartAddress + Length - 1;
00733             Temp = *EndAddress;
00734         }
00735     }
00736 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:39:37 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
